CCS PCH C Compiler, Version 5.117, 2138               05-Dec-25 14:37

               Filename:   C:\Users\Aidan\Documents\GitHub\DiFCS-Controller\src\main.lst

               ROM used:   41754 bytes (64%)
                           Largest free fragment is 23780
               RAM used:   1651 (46%) at main() level
                           1765 (49%) worst case
               Stack used: 6 locations (4 in main + 2 for interrupts)
               Stack size: 30

*
00000:  NOP   
00002:  GOTO   9ECC
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  MOVLB  E
00056:  BTFSS  xC0.5
00058:  GOTO   0062
0005C:  BTFSC  xC8.5
0005E:  GOTO   00E8
00062:  BTFSS  xC1.0
00064:  GOTO   006E
00068:  BTFSC  xC9.0
0006A:  GOTO   025C
0006E:  MOVFF  0E,00
00072:  MOVFF  0F,01
00076:  MOVFF  10,02
0007A:  MOVFF  11,03
0007E:  MOVFF  0C,FE9
00082:  MOVFF  07,FEA
00086:  BSF    07.7
00088:  MOVFF  08,FE1
0008C:  MOVFF  09,FE2
00090:  MOVFF  0A,FD9
00094:  MOVFF  0B,FDA
00098:  MOVFF  12,FF3
0009C:  MOVFF  13,FF4
000A0:  MOVFF  14,FFA
000A4:  MOVFF  15,FF5
000A8:  MOVFF  16,FF6
000AC:  MOVFF  17,FF7
000B0:  MOVF   04,W
000B2:  MOVFF  06,FE0
000B6:  MOVFF  05,FD8
000BA:  RETFIE 0
.................... #include <main.h>
.................... #include <18F46Q10.h>
.................... //////////// Standard Header file for the PIC18F46Q10 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F46Q10
000BC:  MOVFF  FEC,FFA
000C0:  MOVF   FED,F
000C2:  MOVFF  FEF,FE8
000C6:  MOVWF  FF9
000C8:  RETURN 0
*
00330:  DATA 32,30
00332:  DATA 32,35
00334:  DATA 31,31
00336:  DATA 30,34
00338:  DATA 00,00
0033A:  DATA 30,30
0033C:  DATA 30,30
0033E:  DATA 00,00
00340:  DATA 25,64
00342:  DATA 2C,4D
00344:  DATA 41,4E
00346:  DATA 55,41
00348:  DATA 4C,2C
0034A:  DATA 00,00
0034C:  DATA 25,64
0034E:  DATA 2C,4D
00350:  DATA 41,47
00352:  DATA 53,4E
00354:  DATA 53,2C
00356:  DATA 00,00
*
0067E:  ADDWF  FE8,W
00680:  CLRF   FF7
00682:  RLCF   FF7,F
00684:  ADDLW  99
00686:  MOVWF  FF6
00688:  MOVLW  06
0068A:  ADDWFC FF7,F
0068C:  TBLRD*-
0068E:  MOVF   FF5,W
00690:  MOVWF  FFA
00692:  TBLRD*
00694:  MOVF   FF5,W
00696:  MOVWF  FF9
00698:  DATA 48,06
0069A:  DATA 52,06
0069C:  DATA 5C,06
0069E:  DATA 66,06
*
0082A:  MOVLB  6
0082C:  MOVF   xB3,W
0082E:  MULWF  xB5
00830:  MOVFF  FF3,01
00834:  MOVFF  FF4,00
00838:  MULWF  xB6
0083A:  MOVF   FF3,W
0083C:  ADDWF  00,F
0083E:  MOVF   xB4,W
00840:  MULWF  xB5
00842:  MOVF   FF3,W
00844:  ADDWFC 00,W
00846:  MOVWF  02
00848:  MOVLB  0
0084A:  RETURN 0
0084C:  MOVLB  6
0084E:  MOVF   xB1,W
00850:  CLRF   01
00852:  SUBWF  xB0,W
00854:  BC    085C
00856:  MOVFF  6B0,00
0085A:  BRA    0874
0085C:  CLRF   00
0085E:  MOVLW  08
00860:  MOVWF  xB2
00862:  RLCF   xB0,F
00864:  RLCF   00,F
00866:  MOVF   xB1,W
00868:  SUBWF  00,W
0086A:  BTFSC  FD8.0
0086C:  MOVWF  00
0086E:  RLCF   01,F
00870:  DECFSZ xB2,F
00872:  BRA    0862
00874:  MOVLB  0
00876:  RETURN 0
*
00CDC:  MOVLW  8E
00CDE:  MOVWF  00
00CE0:  MOVFF  6C2,01
00CE4:  MOVFF  6C1,02
00CE8:  CLRF   03
00CEA:  MOVF   01,F
00CEC:  BNZ   0D00
00CEE:  MOVFF  02,01
00CF2:  CLRF   02
00CF4:  MOVLW  08
00CF6:  SUBWF  00,F
00CF8:  MOVF   01,F
00CFA:  BNZ   0D00
00CFC:  CLRF   00
00CFE:  BRA    0D10
00D00:  BCF    FD8.0
00D02:  BTFSC  01.7
00D04:  BRA    0D0E
00D06:  RLCF   02,F
00D08:  RLCF   01,F
00D0A:  DECF   00,F
00D0C:  BRA    0D00
00D0E:  BCF    01.7
00D10:  RETURN 0
00D12:  MOVLB  6
00D14:  MOVF   xC2,W
00D16:  BTFSC  FD8.2
00D18:  BRA    0DFC
00D1A:  MOVWF  00
00D1C:  MOVF   xC6,W
00D1E:  BTFSC  FD8.2
00D20:  BRA    0DFC
00D22:  ADDWF  00,F
00D24:  BNC   0D2E
00D26:  MOVLW  81
00D28:  ADDWF  00,F
00D2A:  BC    0DFC
00D2C:  BRA    0D36
00D2E:  MOVLW  7F
00D30:  SUBWF  00,F
00D32:  BNC   0DFC
00D34:  BZ    0DFC
00D36:  MOVFF  6C3,6CA
00D3A:  MOVF   xC7,W
00D3C:  XORWF  xCA,F
00D3E:  BSF    xC3.7
00D40:  BSF    xC7.7
00D42:  MOVF   xC5,W
00D44:  MULWF  xC9
00D46:  MOVFF  FF4,6CC
00D4A:  MOVF   xC4,W
00D4C:  MULWF  xC8
00D4E:  MOVFF  FF4,03
00D52:  MOVFF  FF3,6CB
00D56:  MULWF  xC9
00D58:  MOVF   FF3,W
00D5A:  ADDWF  xCC,F
00D5C:  MOVF   FF4,W
00D5E:  ADDWFC xCB,F
00D60:  MOVLW  00
00D62:  ADDWFC 03,F
00D64:  MOVF   xC5,W
00D66:  MULWF  xC8
00D68:  MOVF   FF3,W
00D6A:  ADDWF  xCC,F
00D6C:  MOVF   FF4,W
00D6E:  ADDWFC xCB,F
00D70:  MOVLW  00
00D72:  CLRF   02
00D74:  ADDWFC 03,F
00D76:  ADDWFC 02,F
00D78:  MOVF   xC3,W
00D7A:  MULWF  xC9
00D7C:  MOVF   FF3,W
00D7E:  ADDWF  xCB,F
00D80:  MOVF   FF4,W
00D82:  ADDWFC 03,F
00D84:  MOVLW  00
00D86:  ADDWFC 02,F
00D88:  MOVF   xC3,W
00D8A:  MULWF  xC8
00D8C:  MOVF   FF3,W
00D8E:  ADDWF  03,F
00D90:  MOVF   FF4,W
00D92:  ADDWFC 02,F
00D94:  MOVLW  00
00D96:  CLRF   01
00D98:  ADDWFC 01,F
00D9A:  MOVF   xC5,W
00D9C:  MULWF  xC7
00D9E:  MOVF   FF3,W
00DA0:  ADDWF  xCB,F
00DA2:  MOVF   FF4,W
00DA4:  ADDWFC 03,F
00DA6:  MOVLW  00
00DA8:  ADDWFC 02,F
00DAA:  ADDWFC 01,F
00DAC:  MOVF   xC4,W
00DAE:  MULWF  xC7
00DB0:  MOVF   FF3,W
00DB2:  ADDWF  03,F
00DB4:  MOVF   FF4,W
00DB6:  ADDWFC 02,F
00DB8:  MOVLW  00
00DBA:  ADDWFC 01,F
00DBC:  MOVF   xC3,W
00DBE:  MULWF  xC7
00DC0:  MOVF   FF3,W
00DC2:  ADDWF  02,F
00DC4:  MOVF   FF4,W
00DC6:  ADDWFC 01,F
00DC8:  INCF   00,F
00DCA:  BTFSC  01.7
00DCC:  BRA    0DD8
00DCE:  RLCF   xCB,F
00DD0:  RLCF   03,F
00DD2:  RLCF   02,F
00DD4:  RLCF   01,F
00DD6:  DECF   00,F
00DD8:  MOVLW  00
00DDA:  BTFSS  xCB.7
00DDC:  BRA    0DF2
00DDE:  INCF   03,F
00DE0:  ADDWFC 02,F
00DE2:  ADDWFC 01,F
00DE4:  MOVF   01,W
00DE6:  BNZ   0DF2
00DE8:  MOVF   02,W
00DEA:  BNZ   0DF2
00DEC:  MOVF   03,W
00DEE:  BNZ   0DF2
00DF0:  INCF   00,F
00DF2:  BTFSC  xCA.7
00DF4:  BSF    01.7
00DF6:  BTFSS  xCA.7
00DF8:  BCF    01.7
00DFA:  BRA    0E04
00DFC:  CLRF   00
00DFE:  CLRF   01
00E00:  CLRF   02
00E02:  CLRF   03
00E04:  MOVLB  0
00E06:  RETURN 0
00E08:  MOVLW  80
00E0A:  BTFSS  FD8.1
00E0C:  BRA    0E12
00E0E:  MOVLB  6
00E10:  XORWF  xC6,F
00E12:  MOVLB  6
00E14:  CLRF   xCB
00E16:  CLRF   xCC
00E18:  MOVFF  6C2,6CA
00E1C:  MOVF   xC6,W
00E1E:  XORWF  xCA,F
00E20:  MOVF   xC1,W
00E22:  BTFSC  FD8.2
00E24:  BRA    0FE4
00E26:  MOVWF  xC9
00E28:  MOVWF  00
00E2A:  MOVF   xC5,W
00E2C:  BTFSC  FD8.2
00E2E:  BRA    0FF6
00E30:  SUBWF  xC9,F
00E32:  BTFSC  FD8.2
00E34:  BRA    0F3C
00E36:  BNC   0EB4
00E38:  MOVFF  6C6,6CF
00E3C:  BSF    xCF.7
00E3E:  MOVFF  6C7,6CE
00E42:  MOVFF  6C8,6CD
00E46:  CLRF   xCC
00E48:  BCF    FD8.0
00E4A:  RRCF   xCF,F
00E4C:  RRCF   xCE,F
00E4E:  RRCF   xCD,F
00E50:  RRCF   xCC,F
00E52:  DECFSZ xC9,F
00E54:  BRA    0E46
00E56:  BTFSS  xCA.7
00E58:  BRA    0E60
00E5A:  BSF    xCB.0
00E5C:  BRA    101E
00E5E:  BCF    xCB.0
00E60:  BCF    xC9.0
00E62:  BSF    xCB.4
00E64:  MOVLW  06
00E66:  MOVWF  FEA
00E68:  MOVLW  C4
00E6A:  MOVWF  FE9
00E6C:  BRA    1044
00E6E:  BCF    xCB.4
00E70:  BTFSC  xCA.7
00E72:  BRA    0E88
00E74:  BTFSS  xC9.0
00E76:  BRA    0E9E
00E78:  RRCF   xCF,F
00E7A:  RRCF   xCE,F
00E7C:  RRCF   xCD,F
00E7E:  RRCF   xCC,F
00E80:  INCF   00,F
00E82:  BTFSC  FD8.2
00E84:  BRA    1014
00E86:  BRA    0E9E
00E88:  BTFSC  xCF.7
00E8A:  BRA    0EA4
00E8C:  BCF    FD8.0
00E8E:  RLCF   xCC,F
00E90:  RLCF   xCD,F
00E92:  RLCF   xCE,F
00E94:  RLCF   xCF,F
00E96:  DECF   00,F
00E98:  BTFSC  FD8.2
00E9A:  BRA    1014
00E9C:  BRA    0E88
00E9E:  BSF    xCB.6
00EA0:  BRA    0F7C
00EA2:  BCF    xCB.6
00EA4:  MOVFF  6C2,6CA
00EA8:  BTFSS  xC2.7
00EAA:  BRA    0EB0
00EAC:  BSF    xCF.7
00EAE:  BRA    1006
00EB0:  BCF    xCF.7
00EB2:  BRA    1006
00EB4:  MOVFF  6C5,6C9
00EB8:  MOVFF  6C5,00
00EBC:  MOVF   xC1,W
00EBE:  SUBWF  xC9,F
00EC0:  MOVFF  6C2,6CF
00EC4:  BSF    xCF.7
00EC6:  MOVFF  6C3,6CE
00ECA:  MOVFF  6C4,6CD
00ECE:  CLRF   xCC
00ED0:  BCF    FD8.0
00ED2:  RRCF   xCF,F
00ED4:  RRCF   xCE,F
00ED6:  RRCF   xCD,F
00ED8:  RRCF   xCC,F
00EDA:  DECFSZ xC9,F
00EDC:  BRA    0ECE
00EDE:  BTFSS  xCA.7
00EE0:  BRA    0EE8
00EE2:  BSF    xCB.1
00EE4:  BRA    101E
00EE6:  BCF    xCB.1
00EE8:  BCF    xC9.0
00EEA:  BSF    xCB.5
00EEC:  MOVLW  06
00EEE:  MOVWF  FEA
00EF0:  MOVLW  C8
00EF2:  MOVWF  FE9
00EF4:  BRA    1044
00EF6:  BCF    xCB.5
00EF8:  BTFSC  xCA.7
00EFA:  BRA    0F10
00EFC:  BTFSS  xC9.0
00EFE:  BRA    0F26
00F00:  RRCF   xCF,F
00F02:  RRCF   xCE,F
00F04:  RRCF   xCD,F
00F06:  RRCF   xCC,F
00F08:  INCF   00,F
00F0A:  BTFSC  FD8.2
00F0C:  BRA    1014
00F0E:  BRA    0F26
00F10:  BTFSC  xCF.7
00F12:  BRA    0F2C
00F14:  BCF    FD8.0
00F16:  RLCF   xCC,F
00F18:  RLCF   xCD,F
00F1A:  RLCF   xCE,F
00F1C:  RLCF   xCF,F
00F1E:  DECF   00,F
00F20:  BTFSC  FD8.2
00F22:  BRA    1014
00F24:  BRA    0F10
00F26:  BSF    xCB.7
00F28:  BRA    0F7C
00F2A:  BCF    xCB.7
00F2C:  MOVFF  6C6,6CA
00F30:  BTFSS  xC6.7
00F32:  BRA    0F38
00F34:  BSF    xCF.7
00F36:  BRA    1006
00F38:  BCF    xCF.7
00F3A:  BRA    1006
00F3C:  MOVFF  6C6,6CF
00F40:  BSF    xCF.7
00F42:  MOVFF  6C7,6CE
00F46:  MOVFF  6C8,6CD
00F4A:  BTFSS  xCA.7
00F4C:  BRA    0F56
00F4E:  BCF    xCF.7
00F50:  BSF    xCB.2
00F52:  BRA    101E
00F54:  BCF    xCB.2
00F56:  CLRF   xCC
00F58:  BCF    xC9.0
00F5A:  MOVLW  06
00F5C:  MOVWF  FEA
00F5E:  MOVLW  C4
00F60:  MOVWF  FE9
00F62:  BRA    1044
00F64:  BTFSC  xCA.7
00F66:  BRA    0FA0
00F68:  MOVFF  6C2,6CA
00F6C:  BTFSS  xC9.0
00F6E:  BRA    0F7C
00F70:  RRCF   xCF,F
00F72:  RRCF   xCE,F
00F74:  RRCF   xCD,F
00F76:  RRCF   xCC,F
00F78:  INCF   00,F
00F7A:  BZ    1014
00F7C:  BTFSS  xCC.7
00F7E:  BRA    0F96
00F80:  INCF   xCD,F
00F82:  BNZ   0F96
00F84:  INCF   xCE,F
00F86:  BNZ   0F96
00F88:  INCF   xCF,F
00F8A:  BNZ   0F96
00F8C:  RRCF   xCF,F
00F8E:  RRCF   xCE,F
00F90:  RRCF   xCD,F
00F92:  INCF   00,F
00F94:  BZ    1014
00F96:  BTFSC  xCB.6
00F98:  BRA    0EA2
00F9A:  BTFSC  xCB.7
00F9C:  BRA    0F2A
00F9E:  BRA    0FD8
00FA0:  MOVLW  80
00FA2:  XORWF  xCF,F
00FA4:  BTFSS  xCF.7
00FA6:  BRA    0FB0
00FA8:  BRA    101E
00FAA:  MOVFF  6C6,6CA
00FAE:  BRA    0FC4
00FB0:  MOVFF  6C2,6CA
00FB4:  MOVF   xCF,F
00FB6:  BNZ   0FC4
00FB8:  MOVF   xCE,F
00FBA:  BNZ   0FC4
00FBC:  MOVF   xCD,F
00FBE:  BNZ   0FC4
00FC0:  CLRF   00
00FC2:  BRA    1006
00FC4:  BTFSC  xCF.7
00FC6:  BRA    0FD8
00FC8:  BCF    FD8.0
00FCA:  RLCF   xCC,F
00FCC:  RLCF   xCD,F
00FCE:  RLCF   xCE,F
00FD0:  RLCF   xCF,F
00FD2:  DECFSZ 00,F
00FD4:  BRA    0FC4
00FD6:  BRA    1014
00FD8:  BTFSS  xCA.7
00FDA:  BRA    0FE0
00FDC:  BSF    xCF.7
00FDE:  BRA    1006
00FE0:  BCF    xCF.7
00FE2:  BRA    1006
00FE4:  MOVFF  6C5,00
00FE8:  MOVFF  6C6,6CF
00FEC:  MOVFF  6C7,6CE
00FF0:  MOVFF  6C8,6CD
00FF4:  BRA    1006
00FF6:  MOVFF  6C1,00
00FFA:  MOVFF  6C2,6CF
00FFE:  MOVFF  6C3,6CE
01002:  MOVFF  6C4,6CD
01006:  MOVFF  6CF,01
0100A:  MOVFF  6CE,02
0100E:  MOVFF  6CD,03
01012:  BRA    107C
01014:  CLRF   00
01016:  CLRF   01
01018:  CLRF   02
0101A:  CLRF   03
0101C:  BRA    107C
0101E:  CLRF   xCC
01020:  COMF   xCD,F
01022:  COMF   xCE,F
01024:  COMF   xCF,F
01026:  COMF   xCC,F
01028:  INCF   xCC,F
0102A:  BNZ   1036
0102C:  INCF   xCD,F
0102E:  BNZ   1036
01030:  INCF   xCE,F
01032:  BNZ   1036
01034:  INCF   xCF,F
01036:  BTFSC  xCB.0
01038:  BRA    0E5E
0103A:  BTFSC  xCB.1
0103C:  BRA    0EE6
0103E:  BTFSC  xCB.2
01040:  BRA    0F54
01042:  BRA    0FAA
01044:  MOVF   FEF,W
01046:  ADDWF  xCD,F
01048:  BNC   1054
0104A:  INCF   xCE,F
0104C:  BNZ   1054
0104E:  INCF   xCF,F
01050:  BTFSC  FD8.2
01052:  BSF    xC9.0
01054:  MOVF   FED,F
01056:  MOVF   FEF,W
01058:  ADDWF  xCE,F
0105A:  BNC   1062
0105C:  INCF   xCF,F
0105E:  BTFSC  FD8.2
01060:  BSF    xC9.0
01062:  MOVF   FED,F
01064:  MOVF   FEF,W
01066:  BTFSC  FEF.7
01068:  BRA    106C
0106A:  XORLW  80
0106C:  ADDWF  xCF,F
0106E:  BTFSC  FD8.0
01070:  BSF    xC9.0
01072:  BTFSC  xCB.4
01074:  BRA    0E6E
01076:  BTFSC  xCB.5
01078:  BRA    0EF6
0107A:  BRA    0F64
0107C:  MOVLB  0
0107E:  RETURN 0
*
015D6:  ADDWF  FE8,W
015D8:  CLRF   FF7
015DA:  RLCF   FF7,F
015DC:  ADDLW  F1
015DE:  MOVWF  FF6
015E0:  MOVLW  15
015E2:  ADDWFC FF7,F
015E4:  TBLRD*-
015E6:  MOVF   FF5,W
015E8:  MOVWF  FFA
015EA:  TBLRD*
015EC:  MOVF   FF5,W
015EE:  MOVWF  FF9
015F0:  DATA 98,10
015F2:  DATA 58,11
015F4:  DATA 18,12
015F6:  DATA D8,12
015F8:  DATA 98,13
015FA:  DATA 58,14
015FC:  DATA 18,15
015FE:  BTFSC  FD8.1
01600:  BRA    160A
01602:  MOVLW  06
01604:  MOVWF  FEA
01606:  MOVLW  B0
01608:  MOVWF  FE9
0160A:  MOVLB  6
0160C:  MOVF   xAB,W
0160E:  XORWF  xAF,W
01610:  ANDLW  80
01612:  MOVWF  xB5
01614:  BTFSS  xAB.7
01616:  BRA    162E
01618:  COMF   xA8,F
0161A:  COMF   xA9,F
0161C:  COMF   xAA,F
0161E:  COMF   xAB,F
01620:  INCF   xA8,F
01622:  BTFSC  FD8.2
01624:  INCF   xA9,F
01626:  BTFSC  FD8.2
01628:  INCF   xAA,F
0162A:  BTFSC  FD8.2
0162C:  INCF   xAB,F
0162E:  BTFSS  xAF.7
01630:  BRA    1648
01632:  COMF   xAC,F
01634:  COMF   xAD,F
01636:  COMF   xAE,F
01638:  COMF   xAF,F
0163A:  INCF   xAC,F
0163C:  BTFSC  FD8.2
0163E:  INCF   xAD,F
01640:  BTFSC  FD8.2
01642:  INCF   xAE,F
01644:  BTFSC  FD8.2
01646:  INCF   xAF,F
01648:  CLRF   00
0164A:  CLRF   01
0164C:  CLRF   02
0164E:  CLRF   03
01650:  CLRF   xB0
01652:  CLRF   xB1
01654:  CLRF   xB2
01656:  CLRF   xB3
01658:  MOVF   xAF,W
0165A:  IORWF  xAE,W
0165C:  IORWF  xAD,W
0165E:  IORWF  xAC,W
01660:  BZ    16BA
01662:  MOVLW  20
01664:  MOVWF  xB4
01666:  BCF    FD8.0
01668:  RLCF   xA8,F
0166A:  RLCF   xA9,F
0166C:  RLCF   xAA,F
0166E:  RLCF   xAB,F
01670:  RLCF   xB0,F
01672:  RLCF   xB1,F
01674:  RLCF   xB2,F
01676:  RLCF   xB3,F
01678:  MOVF   xAF,W
0167A:  SUBWF  xB3,W
0167C:  BNZ   168E
0167E:  MOVF   xAE,W
01680:  SUBWF  xB2,W
01682:  BNZ   168E
01684:  MOVF   xAD,W
01686:  SUBWF  xB1,W
01688:  BNZ   168E
0168A:  MOVF   xAC,W
0168C:  SUBWF  xB0,W
0168E:  BNC   16AE
01690:  MOVF   xAC,W
01692:  SUBWF  xB0,F
01694:  MOVF   xAD,W
01696:  BTFSS  FD8.0
01698:  INCFSZ xAD,W
0169A:  SUBWF  xB1,F
0169C:  MOVF   xAE,W
0169E:  BTFSS  FD8.0
016A0:  INCFSZ xAE,W
016A2:  SUBWF  xB2,F
016A4:  MOVF   xAF,W
016A6:  BTFSS  FD8.0
016A8:  INCFSZ xAF,W
016AA:  SUBWF  xB3,F
016AC:  BSF    FD8.0
016AE:  RLCF   00,F
016B0:  RLCF   01,F
016B2:  RLCF   02,F
016B4:  RLCF   03,F
016B6:  DECFSZ xB4,F
016B8:  BRA    1666
016BA:  BTFSS  xB5.7
016BC:  BRA    16D4
016BE:  COMF   00,F
016C0:  COMF   01,F
016C2:  COMF   02,F
016C4:  COMF   03,F
016C6:  INCF   00,F
016C8:  BTFSC  FD8.2
016CA:  INCF   01,F
016CC:  BTFSC  FD8.2
016CE:  INCF   02,F
016D0:  BTFSC  FD8.2
016D2:  INCF   03,F
016D4:  MOVFF  6B0,FEF
016D8:  MOVFF  6B1,FEC
016DC:  MOVFF  6B2,FEC
016E0:  MOVFF  6B3,FEC
016E4:  MOVLB  0
016E6:  RETURN 0
*
01C44:  MOVLW  B6
01C46:  MOVWF  00
01C48:  CLRF   03
01C4A:  CLRF   02
01C4C:  CLRF   01
01C4E:  MOVLB  6
01C50:  BCF    x8B.0
01C52:  BTFSS  x8A.7
01C54:  BRA    1C6E
01C56:  BSF    x8B.0
01C58:  COMF   x87,F
01C5A:  COMF   x88,F
01C5C:  COMF   x89,F
01C5E:  COMF   x8A,F
01C60:  INCF   x87,F
01C62:  BNZ   1C6E
01C64:  INCF   x88,F
01C66:  BNZ   1C6E
01C68:  INCF   x89,F
01C6A:  BTFSC  FD8.2
01C6C:  INCF   x8A,F
01C6E:  MOVF   x87,W
01C70:  IORWF  x88,W
01C72:  IORWF  x89,W
01C74:  IORWF  x8A,W
01C76:  BNZ   1C7C
01C78:  CLRF   00
01C7A:  BRA    1C9A
01C7C:  BCF    FD8.0
01C7E:  BTFSC  01.7
01C80:  BRA    1C94
01C82:  RLCF   x87,F
01C84:  RLCF   x88,F
01C86:  RLCF   x89,F
01C88:  RLCF   x8A,F
01C8A:  RLCF   03,F
01C8C:  RLCF   02,F
01C8E:  RLCF   01,F
01C90:  DECFSZ 00,F
01C92:  BRA    1C7C
01C94:  BCF    01.7
01C96:  BTFSC  x8B.0
01C98:  BSF    01.7
01C9A:  MOVLB  0
01C9C:  RETURN 0
01C9E:  MOVFF  6BE,6C5
01CA2:  MOVLB  6
01CA4:  MOVF   xC2,W
01CA6:  XORWF  xC5,F
01CA8:  BTFSS  xC5.7
01CAA:  BRA    1CB6
01CAC:  BCF    FD8.2
01CAE:  BCF    FD8.0
01CB0:  BTFSC  xBE.7
01CB2:  BSF    FD8.0
01CB4:  BRA    1D14
01CB6:  MOVFF  6BE,6C5
01CBA:  MOVFF  6C1,6C6
01CBE:  MOVF   xBD,W
01CC0:  SUBWF  xC6,F
01CC2:  BZ    1CD0
01CC4:  BTFSS  xC5.7
01CC6:  BRA    1D14
01CC8:  MOVF   FD8,W
01CCA:  XORLW  01
01CCC:  MOVWF  FD8
01CCE:  BRA    1D14
01CD0:  MOVFF  6C2,6C6
01CD4:  MOVF   xBE,W
01CD6:  SUBWF  xC6,F
01CD8:  BZ    1CE6
01CDA:  BTFSS  xC5.7
01CDC:  BRA    1D14
01CDE:  MOVF   FD8,W
01CE0:  XORLW  01
01CE2:  MOVWF  FD8
01CE4:  BRA    1D14
01CE6:  MOVFF  6C3,6C6
01CEA:  MOVF   xBF,W
01CEC:  SUBWF  xC6,F
01CEE:  BZ    1CFC
01CF0:  BTFSS  xC5.7
01CF2:  BRA    1D14
01CF4:  MOVF   FD8,W
01CF6:  XORLW  01
01CF8:  MOVWF  FD8
01CFA:  BRA    1D14
01CFC:  MOVFF  6C4,6C6
01D00:  MOVF   xC0,W
01D02:  SUBWF  xC6,F
01D04:  BZ    1D12
01D06:  BTFSS  xC5.7
01D08:  BRA    1D14
01D0A:  MOVF   FD8,W
01D0C:  XORLW  01
01D0E:  MOVWF  FD8
01D10:  BRA    1D14
01D12:  BCF    FD8.0
01D14:  MOVLB  0
01D16:  RETURN 0
01D18:  MOVLB  6
01D1A:  MOVF   xB6,W
01D1C:  BTFSC  FD8.2
01D1E:  BRA    1E6A
01D20:  MOVWF  xC2
01D22:  MOVF   xBA,W
01D24:  BTFSC  FD8.2
01D26:  BRA    1E6A
01D28:  SUBWF  xC2,F
01D2A:  BNC   1D36
01D2C:  MOVLW  7F
01D2E:  ADDWF  xC2,F
01D30:  BTFSC  FD8.0
01D32:  BRA    1E6A
01D34:  BRA    1D42
01D36:  MOVLW  81
01D38:  SUBWF  xC2,F
01D3A:  BTFSS  FD8.0
01D3C:  BRA    1E6A
01D3E:  BTFSC  FD8.2
01D40:  BRA    1E6A
01D42:  MOVFF  6C2,00
01D46:  CLRF   01
01D48:  CLRF   02
01D4A:  CLRF   03
01D4C:  CLRF   xC1
01D4E:  MOVFF  6B7,6C0
01D52:  BSF    xC0.7
01D54:  MOVFF  6B8,6BF
01D58:  MOVFF  6B9,6BE
01D5C:  MOVLW  19
01D5E:  MOVWF  xC2
01D60:  MOVF   xBD,W
01D62:  SUBWF  xBE,F
01D64:  BC    1D80
01D66:  MOVLW  01
01D68:  SUBWF  xBF,F
01D6A:  BC    1D80
01D6C:  SUBWF  xC0,F
01D6E:  BC    1D80
01D70:  SUBWF  xC1,F
01D72:  BC    1D80
01D74:  INCF   xC1,F
01D76:  INCF   xC0,F
01D78:  INCF   xBF,F
01D7A:  MOVF   xBD,W
01D7C:  ADDWF  xBE,F
01D7E:  BRA    1DD0
01D80:  MOVF   xBC,W
01D82:  SUBWF  xBF,F
01D84:  BC    1DAA
01D86:  MOVLW  01
01D88:  SUBWF  xC0,F
01D8A:  BC    1DAA
01D8C:  SUBWF  xC1,F
01D8E:  BC    1DAA
01D90:  INCF   xC1,F
01D92:  INCF   xC0,F
01D94:  MOVF   xBC,W
01D96:  ADDWF  xBF,F
01D98:  MOVF   xBD,W
01D9A:  ADDWF  xBE,F
01D9C:  BNC   1DD0
01D9E:  INCF   xBF,F
01DA0:  BNZ   1DD0
01DA2:  INCF   xC0,F
01DA4:  BNZ   1DD0
01DA6:  INCF   xC1,F
01DA8:  BRA    1DD0
01DAA:  MOVF   xBB,W
01DAC:  IORLW  80
01DAE:  SUBWF  xC0,F
01DB0:  BC    1DCE
01DB2:  MOVLW  01
01DB4:  SUBWF  xC1,F
01DB6:  BC    1DCE
01DB8:  INCF   xC1,F
01DBA:  MOVF   xBB,W
01DBC:  IORLW  80
01DBE:  ADDWF  xC0,F
01DC0:  MOVF   xBC,W
01DC2:  ADDWF  xBF,F
01DC4:  BNC   1D98
01DC6:  INCF   xC0,F
01DC8:  BNZ   1D98
01DCA:  INCF   xC1,F
01DCC:  BRA    1D98
01DCE:  BSF    03.0
01DD0:  DECFSZ xC2,F
01DD2:  BRA    1DD6
01DD4:  BRA    1DEC
01DD6:  BCF    FD8.0
01DD8:  RLCF   xBE,F
01DDA:  RLCF   xBF,F
01DDC:  RLCF   xC0,F
01DDE:  RLCF   xC1,F
01DE0:  BCF    FD8.0
01DE2:  RLCF   03,F
01DE4:  RLCF   02,F
01DE6:  RLCF   01,F
01DE8:  RLCF   xC3,F
01DEA:  BRA    1D60
01DEC:  BTFSS  xC3.0
01DEE:  BRA    1DFC
01DF0:  BCF    FD8.0
01DF2:  RRCF   01,F
01DF4:  RRCF   02,F
01DF6:  RRCF   03,F
01DF8:  RRCF   xC3,F
01DFA:  BRA    1E00
01DFC:  DECF   00,F
01DFE:  BZ    1E6A
01E00:  BTFSC  xC3.7
01E02:  BRA    1E40
01E04:  BCF    FD8.0
01E06:  RLCF   xBE,F
01E08:  RLCF   xBF,F
01E0A:  RLCF   xC0,F
01E0C:  RLCF   xC1,F
01E0E:  MOVF   xBD,W
01E10:  SUBWF  xBE,F
01E12:  BC    1E22
01E14:  MOVLW  01
01E16:  SUBWF  xBF,F
01E18:  BC    1E22
01E1A:  SUBWF  xC0,F
01E1C:  BC    1E22
01E1E:  SUBWF  xC1,F
01E20:  BNC   1E56
01E22:  MOVF   xBC,W
01E24:  SUBWF  xBF,F
01E26:  BC    1E32
01E28:  MOVLW  01
01E2A:  SUBWF  xC0,F
01E2C:  BC    1E32
01E2E:  SUBWF  xC1,F
01E30:  BNC   1E56
01E32:  MOVF   xBB,W
01E34:  IORLW  80
01E36:  SUBWF  xC0,F
01E38:  BC    1E40
01E3A:  MOVLW  01
01E3C:  SUBWF  xC1,F
01E3E:  BNC   1E56
01E40:  INCF   03,F
01E42:  BNZ   1E56
01E44:  INCF   02,F
01E46:  BNZ   1E56
01E48:  INCF   01,F
01E4A:  BNZ   1E56
01E4C:  INCF   00,F
01E4E:  BZ    1E6A
01E50:  RRCF   01,F
01E52:  RRCF   02,F
01E54:  RRCF   03,F
01E56:  MOVFF  6B7,6C2
01E5A:  MOVF   xBB,W
01E5C:  XORWF  xC2,F
01E5E:  BTFSS  xC2.7
01E60:  BRA    1E66
01E62:  BSF    01.7
01E64:  BRA    1E72
01E66:  BCF    01.7
01E68:  BRA    1E72
01E6A:  CLRF   00
01E6C:  CLRF   01
01E6E:  CLRF   02
01E70:  CLRF   03
01E72:  MOVLB  0
01E74:  RETURN 0
*
02620:  ADDWF  FE8,W
02622:  CLRF   FF7
02624:  RLCF   FF7,F
02626:  ADDLW  3B
02628:  MOVWF  FF6
0262A:  MOVLW  26
0262C:  ADDWFC FF7,F
0262E:  TBLRD*-
02630:  MOVF   FF5,W
02632:  MOVWF  FFA
02634:  TBLRD*
02636:  MOVF   FF5,W
02638:  MOVWF  FF9
0263A:  DATA 28,25
0263C:  DATA 42,25
0263E:  DATA 96,25
02640:  DATA FA,25
02642:  MOVLW  8E
02644:  MOVWF  00
02646:  MOVFF  6B4,01
0264A:  MOVFF  6B3,02
0264E:  CLRF   03
02650:  BTFSS  01.7
02652:  BRA    265E
02654:  COMF   01,F
02656:  COMF   02,F
02658:  INCF   02,F
0265A:  BNZ   265E
0265C:  INCF   01,F
0265E:  MOVF   01,F
02660:  BNZ   2674
02662:  MOVFF  02,01
02666:  CLRF   02
02668:  MOVLW  08
0266A:  SUBWF  00,F
0266C:  MOVF   01,F
0266E:  BNZ   2674
02670:  CLRF   00
02672:  BRA    2690
02674:  BCF    FD8.0
02676:  BTFSC  01.7
02678:  BRA    2682
0267A:  RLCF   02,F
0267C:  RLCF   01,F
0267E:  DECF   00,F
02680:  BRA    2674
02682:  MOVLB  6
02684:  BTFSS  xB4.7
02686:  BRA    268C
02688:  MOVLB  0
0268A:  BRA    2690
0268C:  BCF    01.7
0268E:  MOVLB  0
02690:  RETURN 0
02692:  MOVLW  8E
02694:  MOVWF  00
02696:  MOVLB  6
02698:  MOVF   xBD,W
0269A:  SUBWF  00,F
0269C:  MOVFF  6BE,02
026A0:  MOVFF  6BF,01
026A4:  BSF    02.7
026A6:  MOVF   00,F
026A8:  BZ    26BC
026AA:  BCF    FD8.0
026AC:  MOVF   02,F
026AE:  BNZ   26B4
026B0:  MOVF   01,F
026B2:  BZ    26BC
026B4:  RRCF   02,F
026B6:  RRCF   01,F
026B8:  DECFSZ 00,F
026BA:  BRA    26AA
026BC:  BTFSS  xBE.7
026BE:  BRA    26CA
026C0:  COMF   01,F
026C2:  COMF   02,F
026C4:  INCF   01,F
026C6:  BTFSC  FD8.2
026C8:  INCF   02,F
026CA:  MOVLB  0
026CC:  RETURN 0
*
04582:  MOVLB  6
04584:  MOVF   x7F,W
04586:  ANDLW  07
04588:  MOVWF  00
0458A:  RRCF   x7F,W
0458C:  MOVWF  01
0458E:  RRCF   01,F
04590:  RRCF   01,F
04592:  MOVLW  1F
04594:  ANDWF  01,F
04596:  MOVF   01,W
04598:  ADDWF  x80,W
0459A:  MOVWF  FE9
0459C:  MOVLW  00
0459E:  ADDWFC x81,W
045A0:  MOVWF  FEA
045A2:  MOVFF  FEF,01
045A6:  INCF   00,F
045A8:  BRA    45AC
045AA:  RRCF   01,F
045AC:  DECFSZ 00,F
045AE:  BRA    45AA
045B0:  MOVLW  01
045B2:  ANDWF  01,F
045B4:  MOVLB  0
045B6:  RETURN 0
*
04FBC:  MOVF   FEF,F
04FBE:  BZ    4FDE
04FC0:  MOVFF  FEA,678
04FC4:  MOVFF  FE9,677
04FC8:  MOVFF  FEF,679
04FCC:  RCALL  4F94
04FCE:  MOVFF  678,FEA
04FD2:  MOVFF  677,FE9
04FD6:  INCF   FE9,F
04FD8:  BTFSC  FD8.2
04FDA:  INCF   FEA,F
04FDC:  BRA    4FBC
04FDE:  RETURN 0
*
0561C:  MOVFF  54B,FEA
05620:  MOVFF  54A,FE9
05624:  MOVFF  6C2,FEF
05628:  INCF   FE9,F
0562A:  BTFSC  FD8.2
0562C:  INCF   FEA,F
0562E:  CLRF   FEF
05630:  MOVLB  5
05632:  INCF   x4A,F
05634:  BTFSC  FD8.2
05636:  INCF   x4B,F
05638:  MOVLB  0
0563A:  RETURN 0
0563C:  TBLRD*+
0563E:  MOVF   FF5,F
05640:  BZ    565A
05642:  MOVFF  FF6,680
05646:  MOVFF  FF7,681
0564A:  MOVFF  FF5,6C2
0564E:  RCALL  561C
05650:  MOVFF  680,FF6
05654:  MOVFF  681,FF7
05658:  BRA    563C
0565A:  RETURN 0
*
0577E:  MOVLB  6
05780:  MOVF   xDA,W
05782:  XORWF  xDC,W
05784:  ANDLW  80
05786:  MOVWF  xDE
05788:  BTFSS  xDA.7
0578A:  BRA    5796
0578C:  COMF   xD9,F
0578E:  COMF   xDA,F
05790:  INCF   xD9,F
05792:  BTFSC  FD8.2
05794:  INCF   xDA,F
05796:  BTFSS  xDC.7
05798:  BRA    57A4
0579A:  COMF   xDB,F
0579C:  COMF   xDC,F
0579E:  INCF   xDB,F
057A0:  BTFSC  FD8.2
057A2:  INCF   xDC,F
057A4:  MOVF   xD9,W
057A6:  MULWF  xDB
057A8:  MOVFF  FF3,01
057AC:  MOVFF  FF4,00
057B0:  MULWF  xDC
057B2:  MOVF   FF3,W
057B4:  ADDWF  00,F
057B6:  MOVF   xDA,W
057B8:  MULWF  xDB
057BA:  MOVF   FF3,W
057BC:  ADDWFC 00,W
057BE:  MOVWF  02
057C0:  BTFSS  xDE.7
057C2:  BRA    57CE
057C4:  COMF   01,F
057C6:  COMF   02,F
057C8:  INCF   01,F
057CA:  BTFSC  FD8.2
057CC:  INCF   02,F
057CE:  MOVLB  0
057D0:  GOTO   5A64 (RETURN)
*
05B28:  MOVLW  20
05B2A:  MOVLB  6
05B2C:  BTFSS  xA7.4
05B2E:  MOVLW  30
05B30:  MOVWF  xA8
05B32:  MOVFF  6A6,00
05B36:  BTFSS  00.7
05B38:  BRA    5B4A
05B3A:  COMF   00,F
05B3C:  INCF   00,F
05B3E:  MOVFF  00,6A6
05B42:  MOVLW  2D
05B44:  MOVWF  xA8
05B46:  BSF    xA7.7
05B48:  BSF    xA7.0
05B4A:  MOVF   01,W
05B4C:  MOVFF  6A6,6B0
05B50:  MOVLW  64
05B52:  MOVWF  xB1
05B54:  MOVLB  0
05B56:  CALL   084C
05B5A:  MOVFF  00,6A6
05B5E:  MOVLW  30
05B60:  ADDWF  01,W
05B62:  MOVLB  6
05B64:  MOVWF  xA9
05B66:  MOVFF  6A6,6B0
05B6A:  MOVLW  0A
05B6C:  MOVWF  xB1
05B6E:  MOVLB  0
05B70:  CALL   084C
05B74:  MOVLW  30
05B76:  ADDWF  00,W
05B78:  MOVLB  6
05B7A:  MOVWF  xAB
05B7C:  MOVLW  30
05B7E:  ADDWF  01,W
05B80:  MOVWF  xAA
05B82:  MOVFF  6A8,00
05B86:  MOVLW  30
05B88:  SUBWF  xA9,W
05B8A:  BZ    5B94
05B8C:  BSF    xA7.1
05B8E:  BTFSC  xA7.7
05B90:  BSF    xA7.2
05B92:  BRA    5BB8
05B94:  MOVFF  6A8,6A9
05B98:  MOVLW  20
05B9A:  MOVWF  xA8
05B9C:  MOVLW  30
05B9E:  SUBWF  xAA,W
05BA0:  BZ    5BAA
05BA2:  BSF    xA7.0
05BA4:  BTFSC  xA7.7
05BA6:  BSF    xA7.1
05BA8:  BRA    5BB8
05BAA:  BTFSS  FD8.2
05BAC:  BSF    xA7.0
05BAE:  BNZ   5BB8
05BB0:  MOVFF  6A9,6AA
05BB4:  MOVLW  20
05BB6:  MOVWF  xA9
05BB8:  BTFSC  xA7.2
05BBA:  BRA    5BC6
05BBC:  BTFSC  xA7.1
05BBE:  BRA    5BCE
05BC0:  BTFSC  xA7.0
05BC2:  BRA    5BD6
05BC4:  BRA    5BDE
05BC6:  MOVFF  6A8,6C2
05BCA:  MOVLB  0
05BCC:  RCALL  561C
05BCE:  MOVFF  6A9,6C2
05BD2:  MOVLB  0
05BD4:  RCALL  561C
05BD6:  MOVFF  6AA,6C2
05BDA:  MOVLB  0
05BDC:  RCALL  561C
05BDE:  MOVFF  6AB,6C2
05BE2:  MOVLB  0
05BE4:  RCALL  561C
05BE6:  RETURN 0
*
05D84:  MOVLB  6
05D86:  MOVF   x94,W
05D88:  ANDLW  07
05D8A:  MOVWF  00
05D8C:  RRCF   x94,W
05D8E:  MOVWF  01
05D90:  RRCF   01,F
05D92:  RRCF   01,F
05D94:  MOVLW  1F
05D96:  ANDWF  01,F
05D98:  MOVF   01,W
05D9A:  ADDWF  x96,W
05D9C:  MOVWF  FE9
05D9E:  MOVLW  00
05DA0:  ADDWFC x97,W
05DA2:  MOVWF  FEA
05DA4:  CLRF   01
05DA6:  INCF   01,F
05DA8:  INCF   00,F
05DAA:  BRA    5DAE
05DAC:  RLCF   01,F
05DAE:  DECFSZ 00,F
05DB0:  BRA    5DAC
05DB2:  MOVF   x95,F
05DB4:  BZ    5DBC
05DB6:  MOVF   01,W
05DB8:  IORWF  FEF,F
05DBA:  BRA    5DC2
05DBC:  COMF   01,F
05DBE:  MOVF   01,W
05DC0:  ANDWF  FEF,F
05DC2:  MOVLB  0
05DC4:  RETURN 0
*
05F74:  TBLRD*+
05F76:  MOVFF  FF6,682
05F7A:  MOVFF  FF7,683
05F7E:  MOVFF  FF5,6C2
05F82:  CALL   561C
05F86:  MOVFF  682,FF6
05F8A:  MOVFF  683,FF7
05F8E:  MOVLB  6
05F90:  DECFSZ x81,F
05F92:  BRA    5F96
05F94:  BRA    5F9A
05F96:  MOVLB  0
05F98:  BRA    5F74
05F9A:  MOVLB  0
05F9C:  RETURN 0
*
06344:  MOVLB  6
06346:  MOVF   xC2,W
06348:  SUBLW  B6
0634A:  MOVWF  xC2
0634C:  CLRF   03
0634E:  MOVFF  6C3,6C6
06352:  BSF    xC3.7
06354:  BCF    FD8.0
06356:  RRCF   xC3,F
06358:  RRCF   xC4,F
0635A:  RRCF   xC5,F
0635C:  RRCF   03,F
0635E:  RRCF   02,F
06360:  RRCF   01,F
06362:  RRCF   00,F
06364:  DECFSZ xC2,F
06366:  BRA    6354
06368:  BTFSS  xC6.7
0636A:  BRA    6382
0636C:  COMF   00,F
0636E:  COMF   01,F
06370:  COMF   02,F
06372:  COMF   03,F
06374:  INCF   00,F
06376:  BTFSC  FD8.2
06378:  INCF   01,F
0637A:  BTFSC  FD8.2
0637C:  INCF   02,F
0637E:  BTFSC  FD8.2
06380:  INCF   03,F
06382:  MOVLB  0
06384:  RETURN 0
06386:  BTFSC  FD8.1
06388:  BRA    6392
0638A:  MOVLW  06
0638C:  MOVWF  FEA
0638E:  MOVLW  CA
06390:  MOVWF  FE9
06392:  CLRF   00
06394:  CLRF   01
06396:  CLRF   02
06398:  CLRF   03
0639A:  MOVLB  6
0639C:  CLRF   xCA
0639E:  CLRF   xCB
063A0:  CLRF   xCC
063A2:  CLRF   xCD
063A4:  MOVF   xC9,W
063A6:  IORWF  xC8,W
063A8:  IORWF  xC7,W
063AA:  IORWF  xC6,W
063AC:  BZ    6406
063AE:  MOVLW  20
063B0:  MOVWF  xCE
063B2:  BCF    FD8.0
063B4:  RLCF   xC2,F
063B6:  RLCF   xC3,F
063B8:  RLCF   xC4,F
063BA:  RLCF   xC5,F
063BC:  RLCF   xCA,F
063BE:  RLCF   xCB,F
063C0:  RLCF   xCC,F
063C2:  RLCF   xCD,F
063C4:  MOVF   xC9,W
063C6:  SUBWF  xCD,W
063C8:  BNZ   63DA
063CA:  MOVF   xC8,W
063CC:  SUBWF  xCC,W
063CE:  BNZ   63DA
063D0:  MOVF   xC7,W
063D2:  SUBWF  xCB,W
063D4:  BNZ   63DA
063D6:  MOVF   xC6,W
063D8:  SUBWF  xCA,W
063DA:  BNC   63FA
063DC:  MOVF   xC6,W
063DE:  SUBWF  xCA,F
063E0:  MOVF   xC7,W
063E2:  BTFSS  FD8.0
063E4:  INCFSZ xC7,W
063E6:  SUBWF  xCB,F
063E8:  MOVF   xC8,W
063EA:  BTFSS  FD8.0
063EC:  INCFSZ xC8,W
063EE:  SUBWF  xCC,F
063F0:  MOVF   xC9,W
063F2:  BTFSS  FD8.0
063F4:  INCFSZ xC9,W
063F6:  SUBWF  xCD,F
063F8:  BSF    FD8.0
063FA:  RLCF   00,F
063FC:  RLCF   01,F
063FE:  RLCF   02,F
06400:  RLCF   03,F
06402:  DECFSZ xCE,F
06404:  BRA    63B2
06406:  MOVFF  6CA,FEF
0640A:  MOVFF  6CB,FEC
0640E:  MOVFF  6CC,FEC
06412:  MOVFF  6CD,FEC
06416:  MOVLB  0
06418:  RETURN 0
0641A:  MOVF   FE9,W
0641C:  MOVLB  6
0641E:  MOVWF  xBA
06420:  MOVF   xB9,W
06422:  MOVWF  xBC
06424:  BZ    645E
06426:  MOVFF  6B8,6C5
0642A:  MOVFF  6B7,6C4
0642E:  MOVFF  6B6,6C3
06432:  MOVFF  6B5,6C2
06436:  CLRF   xC9
06438:  CLRF   xC8
0643A:  MOVLW  20
0643C:  MOVWF  xC7
0643E:  MOVLW  82
06440:  MOVWF  xC6
06442:  MOVLB  0
06444:  CALL   0D12
06448:  MOVFF  03,6B8
0644C:  MOVFF  02,6B7
06450:  MOVFF  01,6B6
06454:  MOVFF  00,6B5
06458:  MOVLB  6
0645A:  DECFSZ xBC,F
0645C:  BRA    6426
0645E:  MOVFF  6B8,6C5
06462:  MOVFF  6B7,6C4
06466:  MOVFF  6B6,6C3
0646A:  MOVFF  6B5,6C2
0646E:  MOVLB  0
06470:  RCALL  6344
06472:  MOVFF  03,6B8
06476:  MOVFF  02,6B7
0647A:  MOVFF  01,6B6
0647E:  MOVFF  00,6B5
06482:  MOVLB  6
06484:  BTFSS  xB8.7
06486:  BRA    64A2
06488:  DECF   xBA,F
0648A:  BSF    xBA.5
0648C:  COMF   xB5,F
0648E:  COMF   xB6,F
06490:  COMF   xB7,F
06492:  COMF   xB8,F
06494:  INCF   xB5,F
06496:  BTFSC  FD8.2
06498:  INCF   xB6,F
0649A:  BTFSC  FD8.2
0649C:  INCF   xB7,F
0649E:  BTFSC  FD8.2
064A0:  INCF   xB8,F
064A2:  MOVLW  3B
064A4:  MOVWF  xC1
064A6:  MOVLW  9A
064A8:  MOVWF  xC0
064AA:  MOVLW  CA
064AC:  MOVWF  xBF
064AE:  CLRF   xBE
064B0:  MOVLW  0A
064B2:  MOVWF  xBC
064B4:  MOVF   xB9,W
064B6:  BTFSC  FD8.2
064B8:  INCF   xBA,F
064BA:  BSF    FD8.1
064BC:  MOVLW  06
064BE:  MOVWF  FEA
064C0:  MOVLW  B5
064C2:  MOVWF  FE9
064C4:  MOVFF  6B8,6C5
064C8:  MOVFF  6B7,6C4
064CC:  MOVFF  6B6,6C3
064D0:  MOVFF  6B5,6C2
064D4:  MOVFF  6C1,6C9
064D8:  MOVFF  6C0,6C8
064DC:  MOVFF  6BF,6C7
064E0:  MOVFF  6BE,6C6
064E4:  MOVLB  0
064E6:  RCALL  6386
064E8:  MOVF   01,W
064EA:  MOVF   00,F
064EC:  BNZ   6514
064EE:  MOVLB  6
064F0:  INCF   xB9,W
064F2:  SUBWF  xBC,W
064F4:  BTFSS  FD8.2
064F6:  BRA    64FC
064F8:  MOVLB  0
064FA:  BRA    6514
064FC:  MOVF   xBA,W
064FE:  BZ    651A
06500:  ANDLW  0F
06502:  SUBWF  xBC,W
06504:  BZ    6508
06506:  BC    6590
06508:  BTFSC  xBA.7
0650A:  BRA    6590
0650C:  BTFSC  xBA.6
0650E:  BRA    651A
06510:  MOVLW  20
06512:  BRA    6582
06514:  MOVLW  20
06516:  MOVLB  6
06518:  ANDWF  xBA,F
0651A:  BTFSS  xBA.5
0651C:  BRA    653C
0651E:  BCF    xBA.5
06520:  MOVF   xB9,W
06522:  BTFSS  FD8.2
06524:  DECF   xBA,F
06526:  MOVF   00,W
06528:  MOVWF  xBA
0652A:  MOVLW  2D
0652C:  MOVWF  xC2
0652E:  MOVLB  0
06530:  CALL   561C
06534:  MOVLB  6
06536:  MOVF   xBA,W
06538:  MOVWF  00
0653A:  CLRF   xBA
0653C:  MOVF   xB9,W
0653E:  SUBWF  xBC,W
06540:  BNZ   655C
06542:  MOVF   00,W
06544:  MOVWF  xBA
06546:  MOVLW  2E
06548:  MOVWF  xC2
0654A:  MOVLB  0
0654C:  CALL   561C
06550:  MOVLB  6
06552:  MOVF   xBA,W
06554:  MOVWF  00
06556:  MOVLW  20
06558:  ANDWF  xBA,F
0655A:  MOVLW  00
0655C:  MOVLW  30
0655E:  BTFSS  xBA.5
06560:  BRA    6582
06562:  BCF    xBA.5
06564:  MOVF   xB9,W
06566:  BTFSS  FD8.2
06568:  DECF   xBA,F
0656A:  MOVF   00,W
0656C:  MOVWF  xBA
0656E:  MOVLW  2D
06570:  MOVWF  xC2
06572:  MOVLB  0
06574:  CALL   561C
06578:  MOVLB  6
0657A:  MOVF   xBA,W
0657C:  MOVWF  00
0657E:  CLRF   xBA
06580:  MOVLW  30
06582:  ADDWF  00,F
06584:  MOVFF  00,6C2
06588:  MOVLB  0
0658A:  CALL   561C
0658E:  MOVLB  6
06590:  BCF    FD8.1
06592:  MOVFF  6C1,6C5
06596:  MOVFF  6C0,6C4
0659A:  MOVFF  6BF,6C3
0659E:  MOVFF  6BE,6C2
065A2:  CLRF   xC9
065A4:  CLRF   xC8
065A6:  CLRF   xC7
065A8:  MOVLW  0A
065AA:  MOVWF  xC6
065AC:  MOVLB  0
065AE:  RCALL  6386
065B0:  MOVFF  03,6C1
065B4:  MOVFF  02,6C0
065B8:  MOVFF  01,6BF
065BC:  MOVFF  00,6BE
065C0:  MOVLB  6
065C2:  DECFSZ xBC,F
065C4:  BRA    64BA
065C6:  MOVLB  0
065C8:  RETURN 0
*
09032:  MOVF   FE9,W
09034:  MOVLB  6
09036:  MOVWF  xAF
09038:  BTFSS  xAE.7
0903A:  BRA    9056
0903C:  DECF   xAF,F
0903E:  BSF    xAF.5
09040:  COMF   xAB,F
09042:  COMF   xAC,F
09044:  COMF   xAD,F
09046:  COMF   xAE,F
09048:  INCF   xAB,F
0904A:  BTFSC  FD8.2
0904C:  INCF   xAC,F
0904E:  BTFSC  FD8.2
09050:  INCF   xAD,F
09052:  BTFSC  FD8.2
09054:  INCF   xAE,F
09056:  MOVLW  3B
09058:  MOVWF  xB6
0905A:  MOVLW  9A
0905C:  MOVWF  xB5
0905E:  MOVLW  CA
09060:  MOVWF  xB4
09062:  CLRF   xB3
09064:  MOVLW  0A
09066:  MOVWF  xB1
09068:  BSF    FD8.1
0906A:  MOVLW  06
0906C:  MOVWF  FEA
0906E:  MOVLW  AB
09070:  MOVWF  FE9
09072:  MOVFF  6AE,6C5
09076:  MOVFF  6AD,6C4
0907A:  MOVFF  6AC,6C3
0907E:  MOVFF  6AB,6C2
09082:  MOVFF  6B6,6C9
09086:  MOVFF  6B5,6C8
0908A:  MOVFF  6B4,6C7
0908E:  MOVFF  6B3,6C6
09092:  MOVLB  0
09094:  CALL   6386
09098:  MOVF   01,W
0909A:  MOVF   00,F
0909C:  BNZ   90C4
0909E:  MOVLB  6
090A0:  MOVF   xB1,W
090A2:  XORLW  01
090A4:  BTFSS  FD8.2
090A6:  BRA    90AC
090A8:  MOVLB  0
090AA:  BRA    90C4
090AC:  MOVF   xAF,W
090AE:  BZ    90CA
090B0:  ANDLW  0F
090B2:  SUBWF  xB1,W
090B4:  BZ    90B8
090B6:  BC    9114
090B8:  BTFSC  xAF.7
090BA:  BRA    9114
090BC:  BTFSC  xAF.6
090BE:  BRA    90CA
090C0:  MOVLW  20
090C2:  BRA    9106
090C4:  MOVLW  20
090C6:  MOVLB  6
090C8:  ANDWF  xAF,F
090CA:  BTFSS  xAF.5
090CC:  BRA    90E6
090CE:  BCF    xAF.5
090D0:  MOVFF  00,6AF
090D4:  MOVLW  2D
090D6:  MOVWF  xC2
090D8:  MOVLB  0
090DA:  CALL   561C
090DE:  MOVLB  6
090E0:  MOVFF  6AF,00
090E4:  CLRF   xAF
090E6:  MOVLW  30
090E8:  BTFSS  xAF.5
090EA:  BRA    9106
090EC:  BCF    xAF.5
090EE:  MOVFF  00,6AF
090F2:  MOVLW  2D
090F4:  MOVWF  xC2
090F6:  MOVLB  0
090F8:  CALL   561C
090FC:  MOVLB  6
090FE:  MOVFF  6AF,00
09102:  CLRF   xAF
09104:  MOVLW  30
09106:  ADDWF  00,F
09108:  MOVFF  00,6C2
0910C:  MOVLB  0
0910E:  CALL   561C
09112:  MOVLB  6
09114:  BCF    FD8.1
09116:  MOVFF  6B6,6C5
0911A:  MOVFF  6B5,6C4
0911E:  MOVFF  6B4,6C3
09122:  MOVFF  6B3,6C2
09126:  CLRF   xC9
09128:  CLRF   xC8
0912A:  CLRF   xC7
0912C:  MOVLW  0A
0912E:  MOVWF  xC6
09130:  MOVLB  0
09132:  CALL   6386
09136:  MOVFF  03,6B6
0913A:  MOVFF  02,6B5
0913E:  MOVFF  01,6B4
09142:  MOVFF  00,6B3
09146:  MOVLB  6
09148:  DECFSZ xB1,F
0914A:  BRA    9068
0914C:  MOVLB  0
0914E:  RETURN 0
*
09DAA:  MOVF   FEF,F
09DAC:  BZ    9DCE
09DAE:  MOVFF  FEA,678
09DB2:  MOVFF  FE9,677
09DB6:  MOVFF  FEF,6C2
09DBA:  CALL   561C
09DBE:  MOVFF  678,FEA
09DC2:  MOVFF  677,FE9
09DC6:  INCF   FE9,F
09DC8:  BTFSC  FD8.2
09DCA:  INCF   FEA,F
09DCC:  BRA    9DAA
09DCE:  GOTO   9E4C (RETURN)
.................... 
.................... #list
.................... 
.................... 
.................... #device ADC=10
.................... 
.................... //!#FUSES WDT                      //Watch Dog Timer
.................... //!#FUSES WDT4096                  //Watch Dog Timer uses 1:4096 Postscale
.................... 
.................... #use delay(internal=64000000)
*
003EE:  MOVLW  06
003F0:  MOVWF  FEA
003F2:  MOVLW  78
003F4:  MOVWF  FE9
003F6:  MOVF   FEF,W
003F8:  BZ    0416
003FA:  MOVLW  14
003FC:  MOVWF  01
003FE:  CLRF   00
00400:  DECFSZ 00,F
00402:  BRA    0400
00404:  DECFSZ 01,F
00406:  BRA    03FE
00408:  MOVLW  BF
0040A:  MOVWF  00
0040C:  DECFSZ 00,F
0040E:  BRA    040C
00410:  BRA    0412
00412:  DECFSZ FEF,F
00414:  BRA    03FA
00416:  RETURN 0
*
006B6:  MOVLW  01
006B8:  MOVLB  6
006BA:  SUBWF  x7E,F
006BC:  BNC   06D6
006BE:  MOVLW  06
006C0:  MOVWF  FEA
006C2:  MOVLW  7E
006C4:  MOVWF  FE9
006C6:  MOVF   FEF,W
006C8:  BZ    06D6
006CA:  MOVLW  04
006CC:  MOVWF  00
006CE:  DECFSZ 00,F
006D0:  BRA    06CE
006D2:  DECFSZ FEF,F
006D4:  BRA    06CA
006D6:  MOVLB  0
006D8:  GOTO   071E (RETURN)
.................... #define baudRate 128000
.................... #define numChannels 2
.................... 
.................... #define version  "20251104" // SW Version
.................... #define serialID "0000"     // Unique Serial ID
.................... #define magPP 1             // Magnetoresistive Sensor Pole Pitch in mm   
.................... #define gainLvl 16          // 1, 2, 4, 8, 16, 32, 64, 128
.................... 
.................... 
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
*
00358:  MOVLW  CF
0035A:  MOVWF  F87
0035C:  CLRF   F82
....................    output_b(portB_reset);
0035E:  MOVLW  C4
00360:  MOVWF  F88
00362:  CLRF   F83
....................    output_c(portC_reset);
00364:  MOVLW  93
00366:  MOVWF  F89
00368:  CLRF   F84
....................    output_d(portD_reset);
0036A:  MOVLW  1F
0036C:  MOVWF  F8A
0036E:  CLRF   F85
....................    output_e(portE_reset);
00370:  BCF    F8B.0
00372:  BCF    F8B.1
00374:  BCF    F8B.2
00376:  BCF    F8B.3
00378:  CLRF   F86
....................    
....................    port_a_pullups(portA_pullups);
0037A:  MOVLB  F
0037C:  SETF   x0B
....................    port_b_pullups(portB_pullups);
0037E:  CLRF   x13
....................    port_c_pullups(portC_pullups);
00380:  CLRF   x1B
....................    port_d_pullups(portD_pullups);
00382:  SETF   x20
....................    port_e_pullups(portE_pullups);
00384:  CLRF   x28
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
00386:  MOVLW  40
00388:  MOVWF  x0C
0038A:  CLRF   x14
0038C:  MOVLW  03
0038E:  MOVWF  x1C
00390:  MOVLW  0F
00392:  MOVWF  x21
00394:  CLRF   x29
00396:  MOVLB  0
00398:  GOTO   A2AC (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
*
055A4:  MOVFF  6B4,FEA
055A8:  MOVLB  6
055AA:  MOVFF  6B3,FE9
055AE:  MOVFF  FEF,6B7
055B2:  MOVFF  6B6,FEA
055B6:  MOVFF  6B5,FE9
055BA:  MOVF   FEF,W
055BC:  SUBWF  xB7,W
055BE:  BNZ   55EE
....................       if (*s1 == '\0')
055C0:  MOVFF  6B4,03
055C4:  MOVFF  6B3,FE9
055C8:  MOVFF  03,FEA
055CC:  MOVF   FEF,F
055CE:  BNZ   55D6
....................          return(0);
055D0:  MOVLW  00
055D2:  MOVWF  01
055D4:  BRA    5618
055D6:  MOVFF  6B4,03
055DA:  MOVF   xB3,W
055DC:  INCF   xB3,F
055DE:  BTFSC  FD8.2
055E0:  INCF   xB4,F
055E2:  INCF   xB5,F
055E4:  BTFSC  FD8.2
055E6:  INCF   xB6,F
055E8:  MOVLB  0
055EA:  BRA    55A4
055EC:  MOVLB  6
....................    return((*s1 < *s2) ? -1: 1);
055EE:  MOVFF  6B4,03
055F2:  MOVFF  6B3,FE9
055F6:  MOVFF  03,FEA
055FA:  MOVFF  FEF,6B7
055FE:  MOVFF  6B6,03
05602:  MOVFF  6B5,FE9
05606:  MOVFF  03,FEA
0560A:  MOVF   FEF,W
0560C:  SUBWF  xB7,W
0560E:  BC    5614
05610:  MOVLW  FF
05612:  BRA    5616
05614:  MOVLW  01
05616:  MOVWF  01
05618:  MOVLB  0
0561A:  RETURN 0
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
*
05734:  MOVFF  6DA,6DD
....................    for(su=s;0<n;++su,--n)
05738:  MOVFF  6D9,6DF
0573C:  MOVFF  6D8,6DE
05740:  MOVLB  6
05742:  MOVF   xDC,F
05744:  BNZ   574C
05746:  MOVF   xDB,W
05748:  SUBLW  00
0574A:  BC    5774
....................       if(*su==uc)
0574C:  MOVFF  6DF,FEA
05750:  MOVFF  6DE,FE9
05754:  MOVF   xDD,W
05756:  SUBWF  FEF,W
05758:  BNZ   5764
....................       return su;
0575A:  MOVFF  6DE,01
0575E:  MOVFF  6DF,02
05762:  BRA    577A
05764:  INCF   xDE,F
05766:  BTFSC  FD8.2
05768:  INCF   xDF,F
0576A:  MOVF   xDB,W
0576C:  BTFSC  FD8.2
0576E:  DECF   xDC,F
05770:  DECF   xDB,F
05772:  BRA    5742
....................    return NULL;
05774:  MOVLW  00
05776:  MOVWF  01
05778:  MOVWF  02
0577A:  MOVLB  0
0577C:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
*
0556C:  MOVFF  6B4,6B6
05570:  MOVFF  6B3,6B5
05574:  MOVFF  6B6,FEA
05578:  MOVLB  6
0557A:  MOVFF  6B5,FE9
0557E:  MOVF   FEF,F
05580:  BZ    558E
05582:  INCF   xB5,F
05584:  BTFSC  FD8.2
05586:  INCF   xB6,F
05588:  MOVLB  0
0558A:  BRA    5574
0558C:  MOVLB  6
....................    return(sc - s);
0558E:  MOVF   xB3,W
05590:  SUBWF  xB5,W
05592:  MOVWF  00
05594:  MOVF   xB4,W
05596:  SUBWFB xB6,W
05598:  MOVWF  03
0559A:  MOVFF  00,01
0559E:  MOVWF  02
055A0:  MOVLB  0
055A2:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
*
06B42:  MOVLB  6
06B44:  CLRF   x8D
06B46:  CLRF   x8C
06B48:  CLRF   x8B
06B4A:  MOVLW  7F
06B4C:  MOVWF  x8A
06B4E:  CLRF   x91
06B50:  CLRF   x90
06B52:  CLRF   x8F
06B54:  CLRF   x8E
06B56:  BSF    x92.0
06B58:  BCF    x92.1
06B5A:  BCF    x92.2
06B5C:  CLRF   x94
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
06B5E:  MOVF   x86,W
06B60:  IORWF  x87,W
06B62:  BNZ   6B6E
....................       return 0;
06B64:  CLRF   00
06B66:  CLRF   01
06B68:  CLRF   02
06B6A:  CLRF   03
06B6C:  BRA    6D98
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
06B6E:  MOVF   x94,W
06B70:  INCF   x94,F
06B72:  ADDWF  x86,W
06B74:  MOVWF  FE9
06B76:  MOVLW  00
06B78:  ADDWFC x87,W
06B7A:  MOVWF  FEA
06B7C:  MOVFF  FEF,693
06B80:  MOVF   x93,F
06B82:  BTFSC  FD8.2
06B84:  BRA    6D1C
....................    {
....................       if (skip && !isspace(c))
06B86:  BTFSS  x92.0
06B88:  BRA    6BA8
06B8A:  MOVF   x93,W
06B8C:  SUBLW  20
06B8E:  BZ    6BA8
....................       {
....................          skip = 0;
06B90:  BCF    x92.0
....................          if (c == '+')
06B92:  MOVF   x93,W
06B94:  SUBLW  2B
06B96:  BNZ   6B9E
....................          {
....................             sign = 0;
06B98:  BCF    x92.1
....................             continue;
06B9A:  BRA    6D04
....................          }            
06B9C:  BRA    6BA8
....................          else if (c == '-')
06B9E:  MOVF   x93,W
06BA0:  SUBLW  2D
06BA2:  BNZ   6BA8
....................          {
....................             sign = 1;
06BA4:  BSF    x92.1
....................             continue;
06BA6:  BRA    6D04
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
06BA8:  BTFSC  x92.0
06BAA:  BRA    6BBA
06BAC:  MOVF   x93,W
06BAE:  SUBLW  2E
06BB0:  BNZ   6BBA
06BB2:  BTFSC  x92.2
06BB4:  BRA    6BBA
....................          point = 1;
06BB6:  BSF    x92.2
06BB8:  BRA    6D04
....................       else if (!skip && isdigit(c))
06BBA:  BTFSC  x92.0
06BBC:  BRA    6CFE
06BBE:  MOVF   x93,W
06BC0:  SUBLW  2F
06BC2:  BTFSC  FD8.0
06BC4:  BRA    6CFE
06BC6:  MOVF   x93,W
06BC8:  SUBLW  39
06BCA:  BTFSS  FD8.0
06BCC:  BRA    6CFE
....................       {
....................          c -= '0';
06BCE:  MOVLW  30
06BD0:  SUBWF  x93,F
....................          if (point)
06BD2:  BTFSS  x92.2
06BD4:  BRA    6C84
....................          {
....................             pow10 = pow10 * 10.0;
06BD6:  MOVFF  68D,6C5
06BDA:  MOVFF  68C,6C4
06BDE:  MOVFF  68B,6C3
06BE2:  MOVFF  68A,6C2
06BE6:  CLRF   xC9
06BE8:  CLRF   xC8
06BEA:  MOVLW  20
06BEC:  MOVWF  xC7
06BEE:  MOVLW  82
06BF0:  MOVWF  xC6
06BF2:  MOVLB  0
06BF4:  CALL   0D12
06BF8:  MOVFF  03,68D
06BFC:  MOVFF  02,68C
06C00:  MOVFF  01,68B
06C04:  MOVFF  00,68A
....................             result += (float)c / pow10;   
06C08:  MOVLB  6
06C0A:  CLRF   xC2
06C0C:  MOVFF  693,6C1
06C10:  MOVLB  0
06C12:  CALL   0CDC
06C16:  MOVFF  03,698
06C1A:  MOVFF  02,697
06C1E:  MOVFF  01,696
06C22:  MOVFF  00,695
06C26:  MOVFF  03,6B9
06C2A:  MOVFF  02,6B8
06C2E:  MOVFF  01,6B7
06C32:  MOVFF  00,6B6
06C36:  MOVFF  68D,6BD
06C3A:  MOVFF  68C,6BC
06C3E:  MOVFF  68B,6BB
06C42:  MOVFF  68A,6BA
06C46:  CALL   1D18
06C4A:  BCF    FD8.1
06C4C:  MOVFF  691,6C4
06C50:  MOVFF  690,6C3
06C54:  MOVFF  68F,6C2
06C58:  MOVFF  68E,6C1
06C5C:  MOVFF  03,6C8
06C60:  MOVFF  02,6C7
06C64:  MOVFF  01,6C6
06C68:  MOVFF  00,6C5
06C6C:  CALL   0E08
06C70:  MOVFF  03,691
06C74:  MOVFF  02,690
06C78:  MOVFF  01,68F
06C7C:  MOVFF  00,68E
....................          }
06C80:  BRA    6CFA
06C82:  MOVLB  6
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
06C84:  CLRF   xC5
06C86:  CLRF   xC4
06C88:  MOVLW  20
06C8A:  MOVWF  xC3
06C8C:  MOVLW  82
06C8E:  MOVWF  xC2
06C90:  MOVFF  691,6C9
06C94:  MOVFF  690,6C8
06C98:  MOVFF  68F,6C7
06C9C:  MOVFF  68E,6C6
06CA0:  MOVLB  0
06CA2:  CALL   0D12
06CA6:  MOVFF  03,698
06CAA:  MOVFF  02,697
06CAE:  MOVFF  01,696
06CB2:  MOVFF  00,695
06CB6:  MOVLB  6
06CB8:  CLRF   xC2
06CBA:  MOVFF  693,6C1
06CBE:  MOVLB  0
06CC0:  CALL   0CDC
06CC4:  BCF    FD8.1
06CC6:  MOVFF  698,6C4
06CCA:  MOVFF  697,6C3
06CCE:  MOVFF  696,6C2
06CD2:  MOVFF  695,6C1
06CD6:  MOVFF  03,6C8
06CDA:  MOVFF  02,6C7
06CDE:  MOVFF  01,6C6
06CE2:  MOVFF  00,6C5
06CE6:  CALL   0E08
06CEA:  MOVFF  03,691
06CEE:  MOVFF  02,690
06CF2:  MOVFF  01,68F
06CF6:  MOVFF  00,68E
....................          }
....................       }
06CFA:  BRA    6D06
06CFC:  MOVLB  6
....................       else if (!skip)
06CFE:  BTFSC  x92.0
06D00:  BRA    6D04
....................          break;
06D02:  BRA    6D1C
06D04:  MOVLB  0
06D06:  MOVLB  6
06D08:  MOVF   x94,W
06D0A:  INCF   x94,F
06D0C:  ADDWF  x86,W
06D0E:  MOVWF  FE9
06D10:  MOVLW  00
06D12:  ADDWFC x87,W
06D14:  MOVWF  FEA
06D16:  MOVFF  FEF,693
06D1A:  BRA    6B80
....................    }
.................... 
....................    if (sign)
06D1C:  BTFSS  x92.1
06D1E:  BRA    6D54
....................       result = -1*result;
06D20:  CLRF   xC5
06D22:  CLRF   xC4
06D24:  MOVLW  80
06D26:  MOVWF  xC3
06D28:  MOVLW  7F
06D2A:  MOVWF  xC2
06D2C:  MOVFF  691,6C9
06D30:  MOVFF  690,6C8
06D34:  MOVFF  68F,6C7
06D38:  MOVFF  68E,6C6
06D3C:  MOVLB  0
06D3E:  CALL   0D12
06D42:  MOVFF  03,691
06D46:  MOVFF  02,690
06D4A:  MOVFF  01,68F
06D4E:  MOVFF  00,68E
06D52:  MOVLB  6
....................       
....................    if(endptr)
06D54:  MOVF   x88,W
06D56:  IORWF  x89,W
06D58:  BZ    6D88
....................    {
....................       if (ptr) {
06D5A:  MOVF   x94,F
06D5C:  BZ    6D76
....................          ptr--;
06D5E:  DECF   x94,F
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
06D60:  MOVFF  689,FEA
06D64:  MOVFF  688,FE9
06D68:  MOVF   x94,W
06D6A:  ADDWF  x86,W
06D6C:  MOVWF  FEF
06D6E:  MOVLW  00
06D70:  ADDWFC x87,W
06D72:  MOVWF  FEC
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
06D74:  BRA    6D88
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
06D76:  MOVFF  689,FEA
06D7A:  MOVFF  688,FE9
06D7E:  MOVFF  687,FEC
06D82:  MOVF   FED,F
06D84:  MOVFF  686,FEF
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
06D88:  MOVFF  68E,00
06D8C:  MOVFF  68F,01
06D90:  MOVFF  690,02
06D94:  MOVFF  691,03
06D98:  MOVLB  0
06D9A:  RETURN 0
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
*
057D4:  MOVLB  6
057D6:  CLRF   xB1
057D8:  CLRF   xB0
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
057DA:  MOVLW  30
057DC:  MOVWF  xB3
057DE:  MOVLW  31
057E0:  MOVWF  xB4
057E2:  MOVLW  32
057E4:  MOVWF  xB5
057E6:  MOVLW  33
057E8:  MOVWF  xB6
057EA:  MOVLW  34
057EC:  MOVWF  xB7
057EE:  MOVLW  35
057F0:  MOVWF  xB8
057F2:  MOVLW  36
057F4:  MOVWF  xB9
057F6:  MOVLW  37
057F8:  MOVWF  xBA
057FA:  MOVLW  38
057FC:  MOVWF  xBB
057FE:  MOVLW  39
05800:  MOVWF  xBC
05802:  MOVLW  61
05804:  MOVWF  xBD
05806:  MOVLW  62
05808:  MOVWF  xBE
0580A:  MOVLW  63
0580C:  MOVWF  xBF
0580E:  MOVLW  64
05810:  MOVWF  xC0
05812:  MOVLW  65
05814:  MOVWF  xC1
05816:  MOVLW  66
05818:  MOVWF  xC2
0581A:  MOVLW  67
0581C:  MOVWF  xC3
0581E:  MOVLW  68
05820:  MOVWF  xC4
05822:  MOVLW  69
05824:  MOVWF  xC5
05826:  MOVLW  6A
05828:  MOVWF  xC6
0582A:  MOVLW  6B
0582C:  MOVWF  xC7
0582E:  MOVLW  6C
05830:  MOVWF  xC8
05832:  MOVLW  6D
05834:  MOVWF  xC9
05836:  MOVLW  6E
05838:  MOVWF  xCA
0583A:  MOVLW  6F
0583C:  MOVWF  xCB
0583E:  MOVLW  70
05840:  MOVWF  xCC
05842:  MOVLW  71
05844:  MOVWF  xCD
05846:  MOVLW  73
05848:  MOVWF  xCE
0584A:  MOVLW  74
0584C:  MOVWF  xCF
0584E:  MOVLW  75
05850:  MOVWF  xD0
05852:  MOVLW  76
05854:  MOVWF  xD1
05856:  MOVLW  77
05858:  MOVWF  xD2
0585A:  MOVLW  78
0585C:  MOVWF  xD3
0585E:  MOVLW  79
05860:  MOVWF  xD4
05862:  MOVLW  7A
05864:  MOVWF  xD5
05866:  CLRF   xD6
....................    for(sc=s;isspace(*sc);++sc);
05868:  MOVFF  6A6,6AB
0586C:  MOVFF  6A5,6AA
05870:  MOVFF  6AB,FEA
05874:  MOVFF  6AA,FE9
05878:  MOVF   FEF,W
0587A:  SUBLW  20
0587C:  BNZ   5886
0587E:  INCF   xAA,F
05880:  BTFSC  FD8.2
05882:  INCF   xAB,F
05884:  BRA    5870
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
05886:  MOVFF  6AB,03
0588A:  MOVFF  6AA,FE9
0588E:  MOVFF  03,FEA
05892:  MOVF   FEF,W
05894:  SUBLW  2D
05896:  BZ    58A6
05898:  MOVFF  6AB,FEA
0589C:  MOVFF  6AA,FE9
058A0:  MOVF   FEF,W
058A2:  SUBLW  2B
058A4:  BNZ   58B8
058A6:  MOVFF  6AB,FEA
058AA:  MOVF   xAA,W
058AC:  INCF   xAA,F
058AE:  BTFSC  FD8.2
058B0:  INCF   xAB,F
058B2:  MOVWF  FE9
058B4:  MOVF   FEF,W
058B6:  BRA    58BA
058B8:  MOVLW  2B
058BA:  MOVWF  xB2
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
058BC:  MOVF   xB2,W
058BE:  SUBLW  2D
058C0:  BZ    58D6
058C2:  BTFSC  xA9.7
058C4:  BRA    58D6
058C6:  DECFSZ xA9,W
058C8:  BRA    58CC
058CA:  BRA    58D6
058CC:  BTFSC  xA9.7
058CE:  BRA    58DA
058D0:  MOVF   xA9,W
058D2:  SUBLW  24
058D4:  BC    58DA
....................    goto StrtoulGO;
058D6:  BRA    5AE2
058D8:  BRA    59D2
.................... 
....................    else if (base)
058DA:  MOVF   xA9,F
058DC:  BZ    596A
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
058DE:  MOVF   xA9,W
058E0:  SUBLW  10
058E2:  BNZ   591E
058E4:  MOVFF  6AB,FEA
058E8:  MOVFF  6AA,FE9
058EC:  MOVF   FEF,W
058EE:  SUBLW  30
058F0:  BNZ   591E
058F2:  MOVLW  01
058F4:  ADDWF  xAA,W
058F6:  MOVWF  FE9
058F8:  MOVLW  00
058FA:  ADDWFC xAB,W
058FC:  MOVWF  FEA
058FE:  MOVF   FEF,W
05900:  SUBLW  78
05902:  BZ    5916
05904:  MOVLW  01
05906:  ADDWF  xAA,W
05908:  MOVWF  FE9
0590A:  MOVLW  00
0590C:  ADDWFC xAB,W
0590E:  MOVWF  FEA
05910:  MOVF   FEF,W
05912:  SUBLW  58
05914:  BNZ   591E
....................          sc+=2;
05916:  MOVLW  02
05918:  ADDWF  xAA,F
0591A:  MOVLW  00
0591C:  ADDWFC xAB,F
....................       if(base==8 && *sc =='0')
0591E:  MOVF   xA9,W
05920:  SUBLW  08
05922:  BNZ   593A
05924:  MOVFF  6AB,FEA
05928:  MOVFF  6AA,FE9
0592C:  MOVF   FEF,W
0592E:  SUBLW  30
05930:  BNZ   593A
....................          sc+=1;
05932:  MOVLW  01
05934:  ADDWF  xAA,F
05936:  MOVLW  00
05938:  ADDWFC xAB,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
0593A:  MOVF   xA9,W
0593C:  SUBLW  02
0593E:  BNZ   5968
05940:  MOVFF  6AB,FEA
05944:  MOVFF  6AA,FE9
05948:  MOVF   FEF,W
0594A:  SUBLW  30
0594C:  BNZ   5968
0594E:  MOVLW  01
05950:  ADDWF  xAA,W
05952:  MOVWF  FE9
05954:  MOVLW  00
05956:  ADDWFC xAB,W
05958:  MOVWF  FEA
0595A:  MOVF   FEF,W
0595C:  SUBLW  62
0595E:  BNZ   5968
....................          sc+=2;
05960:  MOVLW  02
05962:  ADDWF  xAA,F
05964:  MOVLW  00
05966:  ADDWFC xAB,F
.................... 
....................    }
05968:  BRA    59D2
....................    else if(*sc!='0') // base is 0, find base
0596A:  MOVFF  6AB,FEA
0596E:  MOVFF  6AA,FE9
05972:  MOVF   FEF,W
05974:  SUBLW  30
05976:  BZ    597E
....................       base=10;
05978:  MOVLW  0A
0597A:  MOVWF  xA9
0597C:  BRA    59D2
....................    else if (sc[1]=='x' || sc[1]=='X')
0597E:  MOVLW  01
05980:  ADDWF  xAA,W
05982:  MOVWF  FE9
05984:  MOVLW  00
05986:  ADDWFC xAB,W
05988:  MOVWF  FEA
0598A:  MOVF   FEF,W
0598C:  SUBLW  78
0598E:  BZ    59A2
05990:  MOVLW  01
05992:  ADDWF  xAA,W
05994:  MOVWF  FE9
05996:  MOVLW  00
05998:  ADDWFC xAB,W
0599A:  MOVWF  FEA
0599C:  MOVF   FEF,W
0599E:  SUBLW  58
059A0:  BNZ   59B0
....................       base =16,sc+=2;
059A2:  MOVLW  10
059A4:  MOVWF  xA9
059A6:  MOVLW  02
059A8:  ADDWF  xAA,F
059AA:  MOVLW  00
059AC:  ADDWFC xAB,F
059AE:  BRA    59D2
....................    else if(sc[1]=='b')
059B0:  MOVLW  01
059B2:  ADDWF  xAA,W
059B4:  MOVWF  FE9
059B6:  MOVLW  00
059B8:  ADDWFC xAB,W
059BA:  MOVWF  FEA
059BC:  MOVF   FEF,W
059BE:  SUBLW  62
059C0:  BNZ   59CE
....................       base=2,sc+=2;
059C2:  MOVLW  02
059C4:  MOVWF  xA9
059C6:  ADDWF  xAA,F
059C8:  MOVLW  00
059CA:  ADDWFC xAB,F
059CC:  BRA    59D2
....................    else
....................       base=8;
059CE:  MOVLW  08
059D0:  MOVWF  xA9
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
059D2:  MOVFF  6AB,6AD
059D6:  MOVFF  6AA,6AC
059DA:  MOVFF  6AB,FEA
059DE:  MOVFF  6AA,FE9
059E2:  MOVF   FEF,W
059E4:  SUBLW  30
059E6:  BNZ   59F0
059E8:  INCF   xAA,F
059EA:  BTFSC  FD8.2
059EC:  INCF   xAB,F
059EE:  BRA    59DA
....................    sd=memchr(digits,tolower(*sc),base);
059F0:  MOVFF  6AB,03
059F4:  MOVFF  6AA,FE9
059F8:  MOVFF  03,FEA
059FC:  MOVFF  FEF,6D7
05A00:  MOVF   xD7,W
05A02:  SUBLW  40
05A04:  BC    5A12
05A06:  MOVF   xD7,W
05A08:  SUBLW  5A
05A0A:  BNC   5A12
05A0C:  MOVF   xD7,W
05A0E:  IORLW  20
05A10:  BRA    5A14
05A12:  MOVF   xD7,W
05A14:  MOVWF  xD7
05A16:  MOVLW  06
05A18:  MOVWF  xD9
05A1A:  MOVLW  B3
05A1C:  MOVWF  xD8
05A1E:  MOVFF  6D7,6DA
05A22:  CLRF   xDC
05A24:  MOVFF  6A9,6DB
05A28:  BTFSC  xDB.7
05A2A:  DECF   xDC,F
05A2C:  MOVLB  0
05A2E:  RCALL  5734
05A30:  MOVFF  02,6AF
05A34:  MOVFF  01,6AE
....................    for(; sd!=0; )
05A38:  MOVLB  6
05A3A:  MOVF   xAE,F
05A3C:  BNZ   5A42
05A3E:  MOVF   xAF,F
05A40:  BZ    5AD6
....................    {
....................       x=x*base+(int16)(sd-digits);
05A42:  CLRF   03
05A44:  MOVF   xA9,W
05A46:  MOVWF  00
05A48:  BTFSC  FE8.7
05A4A:  DECF   03,F
05A4C:  MOVWF  xD7
05A4E:  MOVFF  03,6D8
05A52:  MOVFF  6B1,6DA
05A56:  MOVFF  6B0,6D9
05A5A:  MOVFF  03,6DC
05A5E:  MOVWF  xDB
05A60:  MOVLB  0
05A62:  BRA    577E
05A64:  MOVFF  01,6D7
05A68:  MOVLW  B3
05A6A:  MOVLB  6
05A6C:  SUBWF  xAE,W
05A6E:  MOVWF  00
05A70:  MOVLW  06
05A72:  SUBWFB xAF,W
05A74:  MOVWF  03
05A76:  MOVF   00,W
05A78:  ADDWF  01,W
05A7A:  MOVWF  01
05A7C:  MOVF   02,W
05A7E:  ADDWFC 03,F
05A80:  MOVFF  01,6B0
05A84:  MOVFF  03,6B1
....................       ++sc;
05A88:  INCF   xAA,F
05A8A:  BTFSC  FD8.2
05A8C:  INCF   xAB,F
....................       sd=memchr(digits,tolower(*sc),base);
05A8E:  MOVFF  6AB,FEA
05A92:  MOVFF  6AA,FE9
05A96:  MOVFF  FEF,6D7
05A9A:  MOVF   xD7,W
05A9C:  SUBLW  40
05A9E:  BC    5AAC
05AA0:  MOVF   xD7,W
05AA2:  SUBLW  5A
05AA4:  BNC   5AAC
05AA6:  MOVF   xD7,W
05AA8:  IORLW  20
05AAA:  BRA    5AAE
05AAC:  MOVF   xD7,W
05AAE:  MOVWF  xD7
05AB0:  MOVLW  06
05AB2:  MOVWF  xD9
05AB4:  MOVLW  B3
05AB6:  MOVWF  xD8
05AB8:  MOVFF  6D7,6DA
05ABC:  CLRF   xDC
05ABE:  MOVFF  6A9,6DB
05AC2:  BTFSC  xDB.7
05AC4:  DECF   xDC,F
05AC6:  MOVLB  0
05AC8:  RCALL  5734
05ACA:  MOVFF  02,6AF
05ACE:  MOVFF  01,6AE
05AD2:  BRA    5A38
05AD4:  MOVLB  6
....................    }
....................    if(s1==sc)
05AD6:  MOVF   xAA,W
05AD8:  SUBWF  xAC,W
05ADA:  BNZ   5B04
05ADC:  MOVF   xAB,W
05ADE:  SUBWF  xAD,W
05AE0:  BNZ   5B04
....................    {
....................    StrtoulGO:
....................       if (endptr)
05AE2:  MOVLB  6
05AE4:  MOVF   xA7,W
05AE6:  IORWF  xA8,W
05AE8:  BZ    5AFC
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
05AEA:  MOVFF  6A8,FEA
05AEE:  MOVFF  6A7,FE9
05AF2:  MOVFF  6A6,FEC
05AF6:  MOVF   FED,F
05AF8:  MOVFF  6A5,FEF
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
05AFC:  MOVLW  00
05AFE:  MOVWF  01
05B00:  MOVWF  02
05B02:  BRA    5B24
....................    }
....................    if (endptr)
05B04:  MOVF   xA7,W
05B06:  IORWF  xA8,W
05B08:  BZ    5B1C
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
05B0A:  MOVFF  6A8,FEA
05B0E:  MOVFF  6A7,FE9
05B12:  MOVFF  6AB,FEC
05B16:  MOVF   FED,F
05B18:  MOVFF  6AA,FEF
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
05B1C:  MOVFF  6B0,01
05B20:  MOVFF  6B1,02
05B24:  MOVLB  0
05B26:  RETURN 0
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................   //  P     I     D
....................   //0.01    0.3   0.1
....................    {0.01,   0.3,  0.1, 0,0,0,0,0}, 
....................    {0.01,   0.3,  0.1, 0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... BOOLEAN adcFilter = TRUE;
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
*
00418:  MOVLB  6
0041A:  CLRF   x77
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
0041C:  CLRF   x77
0041E:  MOVF   x76,W
00420:  SUBWF  x77,W
00422:  BC    047A
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
00424:  MOVF   x77,W
00426:  ADDWF  x74,W
00428:  MOVWF  x78
0042A:  MOVLW  00
0042C:  ADDWFC x75,W
0042E:  MOVWF  x79
00430:  MOVF   x77,W
00432:  ADDWF  x72,W
00434:  MOVWF  01
00436:  MOVLW  00
00438:  ADDWFC x73,W
0043A:  MOVWF  03
0043C:  MOVF   01,W
0043E:  MOVWF  FE9
00440:  MOVFF  03,FEA
00444:  MOVFF  FEF,67A
00448:  BSF    F7F.7
0044A:  MOVF   FF2,W
0044C:  MOVWF  00
0044E:  BCF    FF2.7
00450:  MOVFF  679,F7A
00454:  MOVFF  678,F79
00458:  MOVLW  31
0045A:  MOVWF  F7B
0045C:  MOVFF  67A,F7C
00460:  MOVLB  F
00462:  MOVLW  55
00464:  MOVWF  F81
00466:  MOVLW  AA
00468:  MOVWF  F81
0046A:  BSF    F80.4
0046C:  BTFSC  F80.4
0046E:  BRA    046C
00470:  MOVF   00,W
00472:  IORWF  FF2,F
00474:  MOVLB  6
00476:  INCF   x77,F
00478:  BRA    041E
....................    }
0047A:  MOVLB  0
0047C:  RETURN 0
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
*
0039C:  MOVLB  6
0039E:  CLRF   x77
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
003A0:  CLRF   x77
003A2:  MOVF   x76,W
003A4:  SUBWF  x77,W
003A6:  BC    03EA
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
003A8:  MOVF   x77,W
003AA:  ADDWF  x72,W
003AC:  MOVWF  01
003AE:  MOVLW  00
003B0:  ADDWFC x73,W
003B2:  MOVWF  03
003B4:  MOVF   01,W
003B6:  MOVWF  FE9
003B8:  MOVFF  03,FEA
003BC:  MOVF   x77,W
003BE:  ADDWF  x74,W
003C0:  MOVWF  x7A
003C2:  MOVLW  00
003C4:  ADDWFC x75,W
003C6:  MOVWF  x7B
003C8:  BSF    F7F.7
003CA:  MOVFF  FF2,67C
003CE:  BCF    FF2.7
003D0:  MOVFF  67B,F7A
003D4:  MOVFF  67A,F79
003D8:  MOVLW  31
003DA:  MOVWF  F7B
003DC:  BSF    F80.0
003DE:  MOVF   F7C,W
003E0:  BTFSC  x7C.7
003E2:  BSF    FF2.7
003E4:  MOVWF  FEF
003E6:  INCF   x77,F
003E8:  BRA    03A2
....................    }
003EA:  MOVLB  0
003EC:  RETURN 0
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
*
0047E:  MOVLB  6
00480:  CLRF   x73
00482:  MOVLW  20
00484:  MOVWF  x72
00486:  CLRF   x75
00488:  CLRF   x74
0048A:  MOVLW  80
0048C:  MOVWF  x76
0048E:  MOVLB  0
00490:  RCALL  0418
....................    delay_ms(1);
00492:  MOVLW  01
00494:  MOVLB  6
00496:  MOVWF  x78
00498:  MOVLB  0
0049A:  RCALL  03EE
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
0049C:  MOVLB  6
0049E:  CLRF   x73
004A0:  MOVLW  60
004A2:  MOVWF  x72
004A4:  CLRF   x75
004A6:  MOVLW  80
004A8:  MOVWF  x74
004AA:  MOVLW  02
004AC:  MOVWF  x76
004AE:  MOVLB  0
004B0:  RCALL  0418
....................    delay_ms(1);
004B2:  MOVLW  01
004B4:  MOVLB  6
004B6:  MOVWF  x78
004B8:  MOVLB  0
004BA:  RCALL  03EE
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
004BC:  MOVLB  6
004BE:  CLRF   x73
004C0:  MOVLW  61
004C2:  MOVWF  x72
004C4:  CLRF   x75
004C6:  MOVLW  90
004C8:  MOVWF  x74
004CA:  MOVLW  02
004CC:  MOVWF  x76
004CE:  MOVLB  0
004D0:  RCALL  0418
....................    delay_ms(1);
004D2:  MOVLW  01
004D4:  MOVLB  6
004D6:  MOVWF  x78
004D8:  MOVLB  0
004DA:  RCALL  03EE
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
004DC:  MOVLB  6
004DE:  CLRF   x73
004E0:  MOVLW  62
004E2:  MOVWF  x72
004E4:  CLRF   x75
004E6:  MOVLW  A0
004E8:  MOVWF  x74
004EA:  MOVLW  20
004EC:  MOVWF  x76
004EE:  MOVLB  0
004F0:  RCALL  0418
....................    delay_ms(1);
004F2:  MOVLW  01
004F4:  MOVLB  6
004F6:  MOVWF  x78
004F8:  MOVLB  0
004FA:  RCALL  03EE
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
004FC:  MOVLB  6
004FE:  CLRF   x73
00500:  MOVLW  82
00502:  MOVWF  x72
00504:  CLRF   x75
00506:  MOVLW  C0
00508:  MOVWF  x74
0050A:  MOVLW  30
0050C:  MOVWF  x76
0050E:  MOVLB  0
00510:  RCALL  0418
....................    delay_ms(1);
00512:  MOVLW  01
00514:  MOVLB  6
00516:  MOVWF  x78
00518:  MOVLB  0
0051A:  RCALL  03EE
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
0051C:  MOVLB  6
0051E:  CLRF   x73
00520:  MOVLW  B2
00522:  MOVWF  x72
00524:  CLRF   x75
00526:  MOVLW  F0
00528:  MOVWF  x74
0052A:  MOVLW  38
0052C:  MOVWF  x76
0052E:  MOVLB  0
00530:  RCALL  0418
....................    delay_ms(1);
00532:  MOVLW  01
00534:  MOVLB  6
00536:  MOVWF  x78
00538:  MOVLB  0
0053A:  RCALL  03EE
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
0053C:  MOVLB  6
0053E:  CLRF   x73
00540:  MOVLW  EA
00542:  MOVWF  x72
00544:  MOVLW  01
00546:  MOVWF  x75
00548:  MOVLW  40
0054A:  MOVWF  x74
0054C:  MOVLW  01
0054E:  MOVWF  x76
00550:  MOVLB  0
00552:  RCALL  0418
....................    delay_ms(1);
00554:  MOVLW  01
00556:  MOVLB  6
00558:  MOVWF  x78
0055A:  MOVLB  0
0055C:  RCALL  03EE
0055E:  GOTO   062E (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
00562:  MOVLB  6
00564:  CLRF   x73
00566:  MOVLW  20
00568:  MOVWF  x72
0056A:  CLRF   x75
0056C:  CLRF   x74
0056E:  MOVLW  80
00570:  MOVWF  x76
00572:  MOVLB  0
00574:  RCALL  039C
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
00576:  MOVLB  6
00578:  CLRF   x73
0057A:  MOVLW  60
0057C:  MOVWF  x72
0057E:  CLRF   x75
00580:  MOVLW  80
00582:  MOVWF  x74
00584:  MOVLW  02
00586:  MOVWF  x76
00588:  MOVLB  0
0058A:  RCALL  039C
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
0058C:  MOVLB  6
0058E:  CLRF   x73
00590:  MOVLW  61
00592:  MOVWF  x72
00594:  CLRF   x75
00596:  MOVLW  90
00598:  MOVWF  x74
0059A:  MOVLW  02
0059C:  MOVWF  x76
0059E:  MOVLB  0
005A0:  RCALL  039C
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
005A2:  MOVLB  6
005A4:  CLRF   x73
005A6:  MOVLW  62
005A8:  MOVWF  x72
005AA:  CLRF   x75
005AC:  MOVLW  A0
005AE:  MOVWF  x74
005B0:  MOVLW  20
005B2:  MOVWF  x76
005B4:  MOVLB  0
005B6:  RCALL  039C
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
005B8:  MOVLB  6
005BA:  CLRF   x73
005BC:  MOVLW  82
005BE:  MOVWF  x72
005C0:  CLRF   x75
005C2:  MOVLW  C0
005C4:  MOVWF  x74
005C6:  MOVLW  30
005C8:  MOVWF  x76
005CA:  MOVLB  0
005CC:  RCALL  039C
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
005CE:  MOVLB  6
005D0:  CLRF   x73
005D2:  MOVLW  B2
005D4:  MOVWF  x72
005D6:  CLRF   x75
005D8:  MOVLW  F0
005DA:  MOVWF  x74
005DC:  MOVLW  38
005DE:  MOVWF  x76
005E0:  MOVLB  0
005E2:  RCALL  039C
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
005E4:  MOVLB  6
005E6:  CLRF   x73
005E8:  MOVLW  EA
005EA:  MOVWF  x72
005EC:  MOVLW  01
005EE:  MOVWF  x75
005F0:  MOVLW  40
005F2:  MOVWF  x74
005F4:  MOVLW  01
005F6:  MOVWF  x76
005F8:  MOVLB  0
005FA:  RCALL  039C
005FC:  GOTO   0632 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
00600:  MOVLB  6
00602:  CLRF   x73
00604:  MOVLW  EA
00606:  MOVWF  x72
00608:  MOVLW  01
0060A:  MOVWF  x75
0060C:  MOVLW  40
0060E:  MOVWF  x74
00610:  MOVLW  01
00612:  MOVWF  x76
00614:  MOVLB  0
00616:  RCALL  039C
....................    delay_ms(1);
00618:  MOVLW  01
0061A:  MOVLB  6
0061C:  MOVWF  x78
0061E:  MOVLB  0
00620:  RCALL  03EE
....................    if (paramsValid != isValid)
00622:  MOVF   xEA,W
00624:  SUBLW  AA
00626:  BZ    0630
....................    {
....................       paramsValid = isValid;
00628:  MOVLW  AA
0062A:  MOVWF  xEA
....................       params_save_to_ee(); // saves the base parameters on first boot
0062C:  BRA    047E
....................    }
0062E:  BRA    0632
....................    else
....................    {
....................       params_load_from_ee();
00630:  BRA    0562
....................    }
00632:  GOTO   A2B0 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <monitor.h>
.................... #ifndef monitor
.................... #define monitor
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
....................    output_b(portB_reset);
....................    output_c(portC_reset);
....................    output_d(portD_reset);
....................    output_e(portE_reset);
....................    
....................    port_a_pullups(portA_pullups);
....................    port_b_pullups(portB_pullups);
....................    port_c_pullups(portC_pullups);
....................    port_d_pullups(portD_pullups);
....................    port_e_pullups(portE_pullups);
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................   //  P     I     D
....................   //0.01    0.3   0.1
....................    {0.01,   0.3,  0.1, 0,0,0,0,0}, 
....................    {0.01,   0.3,  0.1, 0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... BOOLEAN adcFilter = TRUE;
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <ADS1220.h>
.................... #ifndef ADS1220
.................... #define ADS1220
.................... 
.................... /*****************************************************************************/
.................... /* SET UP PORTS FOR USE WITH DRIVER                                          */
.................... /*****************************************************************************/
.................... #define _CS0  PIN_D5 // chip select pins 
.................... #define _CS1  PIN_D6
.................... #define _CS2  PIN_D7
.................... #define _CS3  PIN_B0
.................... 
.................... #pin_select SCK2=PIN_B1
.................... #pin_select SDI2=PIN_B2
.................... #pin_select SDO2=PIN_B3
.................... #use spi(MASTER, SPI2, BAUD=4096000, MODE=1, STREAM=SPI_mon)
.................... //!setup_spi2(SPI_MASTER | SPI_SCK_IDLE_LOW | SPI_XMIT_H_TO_L | SPI_CLK_DIV_64);
.................... 
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* REGISTER DEFINITIONS                                                      */
.................... /*****************************************************************************/
.................... typedef enum {reg0 = 0x00,reg1 = 0x04 ,reg2 = 0x08, reg3 = 0x0C}adsReg;
.................... 
.................... //REGISTER 0 OPTIONS
.................... 
.................... #define IPp0n1 0x00
.................... #define IPp0n2 0x10
.................... #define IPp0n3 0x20
.................... #define IPp1n2 0x30
.................... #define IPp1n3 0x40
.................... #define IPp2n3 0x50
.................... #define IPp1n0 0x60
.................... #define IPp3n2 0x70
.................... #define IPp0nVss 0x80
.................... #define IPp1nVss 0x90
.................... #define IPp2nVss 0xA0
.................... #define IPp3nVss 0xB0
.................... #define IPVrpVrn 0xC0
.................... #define IPVddVss 0xD0
.................... #define IPhalfRail 0xE0
.................... 
.................... #define g1 0x00
.................... #define g2 0x02
.................... #define g4 0x04
.................... #define g8 0x06
.................... #define g16 0x08
.................... #define g32 0x0A
.................... #define g64 0x0C
.................... #define g128 0x0E
.................... 
.................... #define PGAenabled 0x00
.................... #define PGAbypass 0x01
.................... 
.................... //REGISTER 1 OPTIONS
.................... 
.................... #define DRn20 0x00
.................... #define DRn45 0x20
.................... #define DRn90 0x40
.................... #define DRn175 0x60
.................... #define DRn330 0x80
.................... #define DRn600 0xA0
.................... #define DRn1000 0xC0
.................... 
.................... #define MDnormal 0x00
.................... #define MDduty 0x80
.................... #define MDturbo 0x10
.................... 
.................... #define CMsingle 0x00
.................... #define CMcont 0x40
.................... 
.................... #define TSdisable 0x00
.................... #define TSenable 0x20
.................... 
.................... #define BCSoff 0x00
.................... #define BCSon 0x01
.................... 
.................... //REGISTER 2 OPTIONS
.................... 
.................... #define REFinternal 0x00
.................... #define REFp0n0 0x40
.................... #define REFp1n1 0x80
.................... #define REFVddVss 0xC0
.................... 
.................... #define FIRoff 0x00
.................... #define FIR5060 0x10
.................... #define FIR50 0x20
.................... #define FIR60 0x30
.................... 
.................... #define PSWopen 0x00
.................... #define PSWstart 0x08
.................... 
.................... #define Ioff 0x00
.................... #define Iu10 0x01
.................... #define Iu50 0x02
.................... #define Iu100 0x03
.................... #define Iu250 0x04
.................... #define Iu500 0x05
.................... #define Iu1000 0x06
.................... #define Iu1500 0x07  
.................... 
.................... //REGISTER 3 OPTIONS
.................... 
.................... #define I1disabled 0x00
.................... #define I1a0p1 0x20
.................... #define I1a1 0x40
.................... #define I1a2 0x60
.................... #define I1a3n1 0x80
.................... #define I1p0 0xA0
.................... #define I1n0 0xC0
.................... 
.................... #define I2disabled 0x00
.................... #define I2a0p1 0x04
.................... #define I2a1 0x08
.................... #define I2a2 0x0A
.................... #define I2a3n1 0x10
.................... #define I2p0 0x14
.................... #define I2n0 0x18
.................... 
.................... #define drdyPin 0x00
.................... #define doutPin 0x20
.................... 
.................... // REGISTER CONGIGURATIONS FOR THIS APP
.................... #define reg0config IPp1n2|g1|PGAenabled // 0x30//
.................... #define reg1config DRn20|MDturbo|CMsingle|TSDisable|BCSoff //0x10
.................... #define reg2config REFinternal|FIRoff|PSWopen|Ioff //0x30
.................... #define reg3config I1disabled|I2disabled|drdyPin //0x00
.................... 
.................... //COMMANDS
.................... #define ADSreset 0x06
.................... #define ADSstart 0x08
.................... #define ADSpowerDn 0x02
.................... #define ADSreadData 0x10
.................... #define ADSreadReg 0x20
.................... #define ADSwriteReg 0x40
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* DESELECT ALL ADCs                                                         */
.................... /*****************************************************************************/
.................... void ads_deselect_all()
.................... {   
....................    output_high(_CS0); // deselect all chip select pins
*
00138:  MOVLW  1F
0013A:  MOVWF  F8A
0013C:  BSF    F85.5
....................    output_high(_CS1);
0013E:  MOVWF  F8A
00140:  BSF    F85.6
....................    output_high(_CS2);
00142:  MOVWF  F8A
00144:  BSF    F85.7
....................    output_high(_CS3); 
00146:  MOVLW  C4
00148:  MOVWF  F88
0014A:  BSF    F83.0
....................    delay_us(10);
0014C:  MOVLW  35
0014E:  MOVWF  00
00150:  DECFSZ 00,F
00152:  BRA    0150
00154:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT DESIRED ADC                                                        */
.................... /*****************************************************************************/
.................... void ads_select_ch(int8 ch)
.................... {
....................    ads_deselect_all();
*
00636:  RCALL  0138
....................    switch(ch)
00638:  MOVLB  6
0063A:  MOVF   x83,W
0063C:  ADDLW  FC
0063E:  BC    0672
00640:  ADDLW  04
00642:  MOVLB  0
00644:  GOTO   067E
....................    {
....................       case 0:
....................          output_low(_CS0);
00648:  MOVLW  1F
0064A:  MOVWF  F8A
0064C:  BCF    F85.5
....................       break; 
0064E:  MOVLB  6
00650:  BRA    0672
....................       case 1:
....................          output_low(_CS1);
00652:  MOVLW  1F
00654:  MOVWF  F8A
00656:  BCF    F85.6
....................       break;   
00658:  MOVLB  6
0065A:  BRA    0672
....................       case 2:
....................          output_low(_CS2);
0065C:  MOVLW  1F
0065E:  MOVWF  F8A
00660:  BCF    F85.7
....................       break;
00662:  MOVLB  6
00664:  BRA    0672
....................       case 3:
....................          output_low(_CS3);
00666:  MOVLW  C4
00668:  MOVWF  F88
0066A:  BCF    F83.0
....................       break;              
0066C:  MOVLB  6
0066E:  BRA    0672
00670:  MOVLB  6
....................    }
....................    delay_us(10);
00672:  MOVLW  35
00674:  MOVWF  00
00676:  DECFSZ 00,F
00678:  BRA    0676
0067A:  MOVLB  0
0067C:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT ADC BLOCK (2 ADCs/BLOCK)                                           */
.................... /*****************************************************************************/
.................... void ads_select_block(int8 block)
.................... {
....................    ads_deselect_all();
*
00156:  RCALL  0138
....................    switch(block)
00158:  MOVLB  6
0015A:  MOVF   xE4,W
0015C:  XORLW  00
0015E:  MOVLB  0
00160:  BZ    0168
00162:  XORLW  01
00164:  BZ    0174
00166:  BRA    0180
....................    {
....................       case 0:
....................          output_low(_CS0);
00168:  MOVLW  1F
0016A:  MOVWF  F8A
0016C:  BCF    F85.5
....................          output_low(_CS1);
0016E:  MOVWF  F8A
00170:  BCF    F85.6
....................       break; 
00172:  BRA    0180
....................       case 1:         
....................          output_low(_CS2);
00174:  MOVLW  1F
00176:  MOVWF  F8A
00178:  BCF    F85.7
....................          output_low(_CS3);
0017A:  MOVLW  C4
0017C:  MOVWF  F88
0017E:  BCF    F83.0
....................       break;         
....................    }
....................    delay_us(10);
00180:  MOVLW  35
00182:  MOVWF  00
00184:  DECFSZ 00,F
00186:  BRA    0184
00188:  GOTO   0192 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT ALL ADCs                                                           */
.................... /*****************************************************************************/
.................... void ads_select_all()
.................... {
....................    output_low(_CS0);
*
0076C:  MOVLW  1F
0076E:  MOVWF  F8A
00770:  BCF    F85.5
....................    output_low(_CS1);
00772:  MOVWF  F8A
00774:  BCF    F85.6
....................    output_low(_CS2);
00776:  MOVWF  F8A
00778:  BCF    F85.7
....................    output_low(_CS3);
0077A:  MOVLW  C4
0077C:  MOVWF  F88
0077E:  BCF    F83.0
....................    delay_us(10);
00780:  MOVLW  35
00782:  MOVWF  00
00784:  DECFSZ 00,F
00786:  BRA    0784
00788:  GOTO   078E (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO AN ADC                                          */
.................... /*****************************************************************************/
.................... void ads_write_command(int8 ch, unsigned int8 command)
.................... {
....................    ads_select_ch(ch);
*
006A0:  MOVFF  681,683
006A4:  RCALL  0636
....................    spi_write2(command);
006A6:  MOVLB  E
006A8:  MOVF   x8D,W
006AA:  MOVFF  682,E8D
006AE:  RRCF   x90,W
006B0:  BNC   06AE
006B2:  MOVLB  0
006B4:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO A BLOCK OF ADCs                                 */
.................... /*****************************************************************************/
.................... void ads_write_command_block(int8 block, unsigned int8 command)
.................... {
....................    ads_select_block(block);
*
0018C:  MOVFF  6E2,6E4
00190:  BRA    0156
....................    spi_write2(command);
00192:  MOVLB  E
00194:  MOVF   x8D,W
00196:  MOVFF  6E3,E8D
0019A:  RRCF   x90,W
0019C:  BNC   019A
0019E:  MOVLB  0
001A0:  GOTO   01B2 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO ALL ADCs                                        */
.................... /*****************************************************************************/
.................... void ads_write_command_all(unsigned int8 command)
.................... {
....................    ads_select_all();
*
0078C:  BRA    076C
....................    spi_write2(command);
0078E:  MOVLB  E
00790:  MOVF   x8D,W
00792:  MOVFF  678,E8D
00796:  RRCF   x90,W
00798:  BNC   0796
0079A:  MOVLB  0
0079C:  GOTO   07AA (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PREPARE TO READ FROM AN ADC                                               */
.................... /*****************************************************************************/
.................... void ads_read_command(int8 ch, unsigned int8 command)
.................... {
....................    ads_select_ch(ch);
*
007B8:  MOVFF  680,683
007BC:  RCALL  0636
....................    spi_read2(command);
007BE:  MOVLB  E
007C0:  MOVF   x8D,W
007C2:  MOVFF  681,E8D
007C6:  RRCF   x90,W
007C8:  BNC   07C6
007CA:  MOVLB  0
007CC:  GOTO   07DE (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE TO THE CONFIGURATION REGISTERS                                      */
.................... /*****************************************************************************/
.................... void ads_write_reg(int8 ch, adsReg regID, int8 data)
*
006DC:  MOVLB  6
006DE:  MOVF   x7E,W
006E0:  IORLW  40
006E2:  MOVWF  x80
.................... {
....................    unsigned int8 command = ADSwriteReg | regID | 0; // 0 is numbytes to write-1
....................    ads_write_command(ch, command);
006E4:  MOVFF  67D,681
006E8:  MOVFF  680,682
006EC:  MOVLB  0
006EE:  RCALL  06A0
....................    spi_write2(data);
006F0:  MOVLB  E
006F2:  MOVF   x8D,W
006F4:  MOVFF  67F,E8D
006F8:  RRCF   x90,W
006FA:  BNC   06F8
....................    ads_deselect_all();
006FC:  MOVLB  0
006FE:  RCALL  0138
00700:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* READ FROM THE CONFIGURATION REGISTERS                                     */
.................... /*****************************************************************************/
.................... unsigned int8 ads_read_reg(int8 ch, adsReg regID)
.................... {
....................    unsigned int8 command = ADSreadReg | regID | 0;
....................    ads_read_command(ch, command);
....................    unsigned int8 data = spi_read2(0);
....................    ads_deselect_all();
....................    return data;
.................... }
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* START BLOCK CONVERSION                                                    */
.................... /*****************************************************************************/
.................... void ads_start_conv_block(int8 block)
.................... {
....................    ads_write_command_block(block, ADSstart);
*
001A4:  MOVFF  6E1,6E2
001A8:  MOVLW  08
001AA:  MOVLB  6
001AC:  MOVWF  xE3
001AE:  MOVLB  0
001B0:  BRA    018C
....................    delay_us(10);
001B2:  MOVLW  35
001B4:  MOVWF  00
001B6:  DECFSZ 00,F
001B8:  BRA    01B6
....................    ads_deselect_all();
001BA:  RCALL  0138
001BC:  GOTO   0202 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* START ALL CONVERSION                                                      */
.................... /*****************************************************************************/
.................... void ads_start_conv_all()
.................... {
....................    ads_write_command_all(ADSstart);
*
007A0:  MOVLW  08
007A2:  MOVLB  6
007A4:  MOVWF  x78
007A6:  MOVLB  0
007A8:  BRA    078C
....................    delay_us(10);
007AA:  MOVLW  35
007AC:  MOVWF  00
007AE:  DECFSZ 00,F
007B0:  BRA    07AE
....................    ads_deselect_all();
007B2:  RCALL  0138
007B4:  GOTO   093A (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* READ THE MOST RECENT CONVERSION                                           */
.................... /*****************************************************************************/
.................... signed int32 ads_read_data(int8 ch)
.................... {
....................    union Data
....................    {
....................       unsigned int8 dBytes[4];
....................       signed int32 dWord;
....................    }data;
....................    
....................    ads_read_command(ch, ADSreadData);
*
007D0:  MOVFF  67B,680
007D4:  MOVLW  10
007D6:  MOVLB  6
007D8:  MOVWF  x81
007DA:  MOVLB  0
007DC:  BRA    07B8
....................    data.dBytes[3] = 0;
007DE:  MOVLB  6
007E0:  CLRF   x7F
....................    data.dBytes[2] = spi_read2(0);
007E2:  MOVLB  E
007E4:  MOVF   x8D,W
007E6:  CLRF   x8D
007E8:  RRCF   x90,W
007EA:  BNC   07E8
007EC:  MOVFF  E8D,67E
....................    data.dBytes[1] = spi_read2(0);
007F0:  MOVF   x8D,W
007F2:  CLRF   x8D
007F4:  RRCF   x90,W
007F6:  BNC   07F4
007F8:  MOVFF  E8D,67D
....................    data.dBytes[0] = spi_read2(0);
007FC:  MOVF   x8D,W
007FE:  CLRF   x8D
00800:  RRCF   x90,W
00802:  BNC   0800
00804:  MOVFF  E8D,67C
....................    
....................    //convert 24-bit 2's complement to 32-bit 2's complement
....................    if (0x80 & data.dBytes[2]) data.dBytes[3] |= 0xFF;
00808:  MOVLB  6
0080A:  MOVF   x7E,W
0080C:  ANDLW  80
0080E:  BZ    0814
00810:  MOVLW  FF
00812:  IORWF  x7F,F
....................    
....................    ads_deselect_all();
00814:  MOVLB  0
00816:  RCALL  0138
....................    return data.dWord;
00818:  MOVFF  67C,00
0081C:  MOVFF  67D,01
00820:  MOVFF  67E,02
00824:  MOVFF  67F,03
00828:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE A CHANNEL                                                      */
.................... /*****************************************************************************/
.................... 
.................... void ADS1220init(int8 ch, rc0=reg0config, rc1=reg1config, rc2=reg2config, rc3=reg3config)
.................... {
....................    ads_write_command(ch, ADSreset);   //reset the device
*
00702:  MOVFF  678,681
00706:  MOVLW  06
00708:  MOVLB  6
0070A:  MOVWF  x82
0070C:  MOVLB  0
0070E:  RCALL  06A0
....................    delay_us(300);                    
00710:  MOVLW  02
00712:  MOVLB  6
00714:  MOVWF  x7D
00716:  MOVLW  96
00718:  MOVWF  x7E
0071A:  MOVLB  0
0071C:  BRA    06B6
0071E:  MOVLB  6
00720:  DECFSZ x7D,F
00722:  BRA    0716
....................    ads_write_reg(ch, reg0, rc0);   //send default configurations
00724:  MOVFF  678,67D
00728:  CLRF   x7E
0072A:  MOVFF  679,67F
0072E:  MOVLB  0
00730:  RCALL  06DC
....................    ads_write_reg(ch, reg1, rc1);
00732:  MOVFF  678,67D
00736:  MOVLW  04
00738:  MOVLB  6
0073A:  MOVWF  x7E
0073C:  MOVFF  67A,67F
00740:  MOVLB  0
00742:  RCALL  06DC
....................    ads_write_reg(ch, reg2, rc2);
00744:  MOVFF  678,67D
00748:  MOVLW  08
0074A:  MOVLB  6
0074C:  MOVWF  x7E
0074E:  MOVFF  67B,67F
00752:  MOVLB  0
00754:  RCALL  06DC
....................    ads_write_reg(ch, reg3, rc3);  
00756:  MOVFF  678,67D
0075A:  MOVLW  0C
0075C:  MOVLB  6
0075E:  MOVWF  x7E
00760:  MOVFF  67C,67F
00764:  MOVLB  0
00766:  RCALL  06DC
00768:  GOTO   0914 (RETURN)
.................... }
.................... #endif 
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
*
026CE:  MOVLB  6
026D0:  BCF    xBC.0
....................    y = x;
026D2:  MOVFF  6B0,6B5
026D6:  MOVFF  6AF,6B4
026DA:  MOVFF  6AE,6B3
026DE:  MOVFF  6AD,6B2
.................... 
....................    if (x < 0)
026E2:  MOVFF  6B0,6C0
026E6:  MOVFF  6AF,6BF
026EA:  MOVFF  6AE,6BE
026EE:  MOVFF  6AD,6BD
026F2:  CLRF   xC4
026F4:  CLRF   xC3
026F6:  CLRF   xC2
026F8:  CLRF   xC1
026FA:  MOVLB  0
026FC:  CALL   1C9E
02700:  BNC   270E
....................    {
....................       s = 1;
02702:  MOVLB  6
02704:  BSF    xBC.0
....................       y = -y;
02706:  MOVF   xB3,W
02708:  XORLW  80
0270A:  MOVWF  xB3
0270C:  MOVLB  0
....................    }
.................... 
....................    if (y <= 32768.0)
0270E:  MOVFF  6B5,6C0
02712:  MOVFF  6B4,6BF
02716:  MOVFF  6B3,6BE
0271A:  MOVFF  6B2,6BD
0271E:  MOVLB  6
02720:  CLRF   xC4
02722:  CLRF   xC3
02724:  CLRF   xC2
02726:  MOVLW  8E
02728:  MOVWF  xC1
0272A:  MOVLB  0
0272C:  CALL   1C9E
02730:  BC    2734
02732:  BNZ   2764
....................       res = (float32)(unsigned int16)y;
02734:  MOVFF  6B5,6C0
02738:  MOVFF  6B4,6BF
0273C:  MOVFF  6B3,6BE
02740:  MOVFF  6B2,6BD
02744:  RCALL  2692
02746:  MOVFF  02,6C2
0274A:  MOVFF  01,6C1
0274E:  CALL   0CDC
02752:  MOVFF  03,6B9
02756:  MOVFF  02,6B8
0275A:  MOVFF  01,6B7
0275E:  MOVFF  00,6B6
02762:  BRA    2906
.................... 
....................  else if (y < 10000000.0)
02764:  MOVFF  6B5,6C0
02768:  MOVFF  6B4,6BF
0276C:  MOVFF  6B3,6BE
02770:  MOVFF  6B2,6BD
02774:  MOVLW  80
02776:  MOVLB  6
02778:  MOVWF  xC4
0277A:  MOVLW  96
0277C:  MOVWF  xC3
0277E:  MOVLW  18
02780:  MOVWF  xC2
02782:  MOVLW  96
02784:  MOVWF  xC1
02786:  MOVLB  0
02788:  CALL   1C9E
0278C:  BTFSS  FD8.0
0278E:  BRA    28F6
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
02790:  MOVFF  6B5,6C5
02794:  MOVFF  6B4,6C4
02798:  MOVFF  6B3,6C3
0279C:  MOVFF  6B2,6C2
027A0:  MOVLB  6
027A2:  CLRF   xC9
027A4:  CLRF   xC8
027A6:  CLRF   xC7
027A8:  MOVLW  70
027AA:  MOVWF  xC6
027AC:  MOVLB  0
027AE:  CALL   0D12
027B2:  MOVFF  03,6C0
027B6:  MOVFF  02,6BF
027BA:  MOVFF  01,6BE
027BE:  MOVFF  00,6BD
027C2:  RCALL  2692
027C4:  MOVFF  02,6BB
027C8:  MOVFF  01,6BA
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
027CC:  MOVFF  6B5,6C5
027D0:  MOVFF  6B4,6C4
027D4:  MOVFF  6B3,6C3
027D8:  MOVFF  6B2,6C2
027DC:  MOVLB  6
027DE:  CLRF   xC9
027E0:  CLRF   xC8
027E2:  CLRF   xC7
027E4:  MOVLW  70
027E6:  MOVWF  xC6
027E8:  MOVLB  0
027EA:  CALL   0D12
027EE:  MOVFF  03,6C0
027F2:  MOVFF  02,6BF
027F6:  MOVFF  01,6BE
027FA:  MOVFF  00,6BD
027FE:  MOVFF  6BB,6C2
02802:  MOVFF  6BA,6C1
02806:  CALL   0CDC
0280A:  BSF    FD8.1
0280C:  MOVFF  6C0,6C4
02810:  MOVFF  6BF,6C3
02814:  MOVFF  6BE,6C2
02818:  MOVFF  6BD,6C1
0281C:  MOVFF  03,6C8
02820:  MOVFF  02,6C7
02824:  MOVFF  01,6C6
02828:  MOVFF  00,6C5
0282C:  CALL   0E08
02830:  MOVLB  6
02832:  CLRF   xC5
02834:  CLRF   xC4
02836:  CLRF   xC3
02838:  MOVLW  8E
0283A:  MOVWF  xC2
0283C:  MOVFF  03,6C9
02840:  MOVFF  02,6C8
02844:  MOVFF  01,6C7
02848:  MOVFF  00,6C6
0284C:  MOVLB  0
0284E:  CALL   0D12
02852:  MOVFF  03,6B5
02856:  MOVFF  02,6B4
0285A:  MOVFF  01,6B3
0285E:  MOVFF  00,6B2
....................       res = 32768.0*(float32)l;
02862:  MOVFF  6BB,6C2
02866:  MOVFF  6BA,6C1
0286A:  CALL   0CDC
0286E:  MOVLB  6
02870:  CLRF   xC5
02872:  CLRF   xC4
02874:  CLRF   xC3
02876:  MOVLW  8E
02878:  MOVWF  xC2
0287A:  MOVFF  03,6C9
0287E:  MOVFF  02,6C8
02882:  MOVFF  01,6C7
02886:  MOVFF  00,6C6
0288A:  MOVLB  0
0288C:  CALL   0D12
02890:  MOVFF  03,6B9
02894:  MOVFF  02,6B8
02898:  MOVFF  01,6B7
0289C:  MOVFF  00,6B6
....................       res += (float32)(unsigned int16)y;
028A0:  MOVFF  6B5,6C0
028A4:  MOVFF  6B4,6BF
028A8:  MOVFF  6B3,6BE
028AC:  MOVFF  6B2,6BD
028B0:  RCALL  2692
028B2:  MOVFF  02,6C2
028B6:  MOVFF  01,6C1
028BA:  CALL   0CDC
028BE:  BCF    FD8.1
028C0:  MOVFF  6B9,6C4
028C4:  MOVFF  6B8,6C3
028C8:  MOVFF  6B7,6C2
028CC:  MOVFF  6B6,6C1
028D0:  MOVFF  03,6C8
028D4:  MOVFF  02,6C7
028D8:  MOVFF  01,6C6
028DC:  MOVFF  00,6C5
028E0:  CALL   0E08
028E4:  MOVFF  03,6B9
028E8:  MOVFF  02,6B8
028EC:  MOVFF  01,6B7
028F0:  MOVFF  00,6B6
....................    }
028F4:  BRA    2906
.................... 
....................  else
....................   res = y;
028F6:  MOVFF  6B5,6B9
028FA:  MOVFF  6B4,6B8
028FE:  MOVFF  6B3,6B7
02902:  MOVFF  6B2,6B6
.................... 
....................  y = y - (float32)(unsigned int16)y;
02906:  MOVFF  6B5,6C0
0290A:  MOVFF  6B4,6BF
0290E:  MOVFF  6B3,6BE
02912:  MOVFF  6B2,6BD
02916:  RCALL  2692
02918:  MOVFF  02,6C2
0291C:  MOVFF  01,6C1
02920:  CALL   0CDC
02924:  BSF    FD8.1
02926:  MOVFF  6B5,6C4
0292A:  MOVFF  6B4,6C3
0292E:  MOVFF  6B3,6C2
02932:  MOVFF  6B2,6C1
02936:  MOVFF  03,6C8
0293A:  MOVFF  02,6C7
0293E:  MOVFF  01,6C6
02942:  MOVFF  00,6C5
02946:  CALL   0E08
0294A:  MOVFF  03,6B5
0294E:  MOVFF  02,6B4
02952:  MOVFF  01,6B3
02956:  MOVFF  00,6B2
.................... 
....................  if (s)
0295A:  MOVLB  6
0295C:  BTFSS  xBC.0
0295E:  BRA    2966
....................   res = -res;
02960:  MOVF   xB7,W
02962:  XORLW  80
02964:  MOVWF  xB7
.................... 
....................  if (y != 0)
02966:  MOVFF  6B5,6C0
0296A:  MOVFF  6B4,6BF
0296E:  MOVFF  6B3,6BE
02972:  MOVFF  6B2,6BD
02976:  CLRF   xC4
02978:  CLRF   xC3
0297A:  CLRF   xC2
0297C:  CLRF   xC1
0297E:  MOVLB  0
02980:  CALL   1C9E
02984:  BZ    29FE
....................  {
....................   if (s == 1 && n == 0)
02986:  MOVLB  6
02988:  BTFSS  xBC.0
0298A:  BRA    29C4
0298C:  MOVF   xB1,F
0298E:  BNZ   29C4
....................    res -= 1.0;
02990:  BSF    FD8.1
02992:  MOVFF  6B9,6C4
02996:  MOVFF  6B8,6C3
0299A:  MOVFF  6B7,6C2
0299E:  MOVFF  6B6,6C1
029A2:  CLRF   xC8
029A4:  CLRF   xC7
029A6:  CLRF   xC6
029A8:  MOVLW  7F
029AA:  MOVWF  xC5
029AC:  MOVLB  0
029AE:  CALL   0E08
029B2:  MOVFF  03,6B9
029B6:  MOVFF  02,6B8
029BA:  MOVFF  01,6B7
029BE:  MOVFF  00,6B6
029C2:  MOVLB  6
.................... 
....................   if (s == 0 && n == 1)
029C4:  BTFSC  xBC.0
029C6:  BRA    2A00
029C8:  DECFSZ xB1,W
029CA:  BRA    2A00
....................    res += 1.0;
029CC:  BCF    FD8.1
029CE:  MOVFF  6B9,6C4
029D2:  MOVFF  6B8,6C3
029D6:  MOVFF  6B7,6C2
029DA:  MOVFF  6B6,6C1
029DE:  CLRF   xC8
029E0:  CLRF   xC7
029E2:  CLRF   xC6
029E4:  MOVLW  7F
029E6:  MOVWF  xC5
029E8:  MOVLB  0
029EA:  CALL   0E08
029EE:  MOVFF  03,6B9
029F2:  MOVFF  02,6B8
029F6:  MOVFF  01,6B7
029FA:  MOVFF  00,6B6
029FE:  MOVLB  6
....................  }
....................  if (x == 0)
02A00:  MOVFF  6B0,6C0
02A04:  MOVFF  6AF,6BF
02A08:  MOVFF  6AE,6BE
02A0C:  MOVFF  6AD,6BD
02A10:  CLRF   xC4
02A12:  CLRF   xC3
02A14:  CLRF   xC2
02A16:  CLRF   xC1
02A18:  MOVLB  0
02A1A:  CALL   1C9E
02A1E:  BNZ   2A2C
....................     res = 0;
02A20:  MOVLB  6
02A22:  CLRF   xB9
02A24:  CLRF   xB8
02A26:  CLRF   xB7
02A28:  CLRF   xB6
02A2A:  MOVLB  0
.................... 
....................  return (res);
02A2C:  MOVFF  6B6,00
02A30:  MOVFF  6B7,01
02A34:  MOVFF  6B8,02
02A38:  MOVFF  6B9,03
02A3C:  RETURN 0
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
*
02A5C:  MOVFF  6AC,6B0
02A60:  MOVFF  6AB,6AF
02A64:  MOVFF  6AA,6AE
02A68:  MOVFF  6A9,6AD
02A6C:  MOVLB  6
02A6E:  CLRF   xB1
02A70:  MOVLB  0
02A72:  RCALL  26CE
02A74:  GOTO   2B80 (RETURN)
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
*
02A3E:  MOVFF  6AC,6B0
02A42:  MOVFF  6AB,6AF
02A46:  MOVFF  6AA,6AE
02A4A:  MOVFF  6A9,6AD
02A4E:  MOVLW  01
02A50:  MOVLB  6
02A52:  MOVWF  xB1
02A54:  MOVLB  0
02A56:  RCALL  26CE
02A58:  GOTO   2B38 (RETURN)
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
*
02A78:  MOVFF  6A0,6C0
02A7C:  MOVFF  69F,6BF
02A80:  MOVFF  69E,6BE
02A84:  MOVFF  69D,6BD
02A88:  MOVLB  6
02A8A:  CLRF   xC4
02A8C:  CLRF   xC3
02A8E:  CLRF   xC2
02A90:  CLRF   xC1
02A92:  MOVLB  0
02A94:  CALL   1C9E
02A98:  BTFSC  FD8.2
02A9A:  BRA    2BDC
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
02A9C:  MOVFF  69C,6B9
02AA0:  MOVFF  69B,6B8
02AA4:  MOVFF  69A,6B7
02AA8:  MOVFF  699,6B6
02AAC:  MOVFF  6A0,6BD
02AB0:  MOVFF  69F,6BC
02AB4:  MOVFF  69E,6BB
02AB8:  MOVFF  69D,6BA
02ABC:  CALL   1D18
02AC0:  MOVFF  03,6A8
02AC4:  MOVFF  02,6A7
02AC8:  MOVFF  01,6A6
02ACC:  MOVFF  00,6A5
02AD0:  MOVFF  03,6C0
02AD4:  MOVFF  02,6BF
02AD8:  MOVFF  01,6BE
02ADC:  MOVFF  00,6BD
02AE0:  MOVLB  6
02AE2:  CLRF   xC4
02AE4:  CLRF   xC3
02AE6:  CLRF   xC2
02AE8:  CLRF   xC1
02AEA:  MOVLB  0
02AEC:  CALL   1C9E
02AF0:  BNC   2B3A
02AF2:  MOVFF  69C,6B9
02AF6:  MOVFF  69B,6B8
02AFA:  MOVFF  69A,6B7
02AFE:  MOVFF  699,6B6
02B02:  MOVFF  6A0,6BD
02B06:  MOVFF  69F,6BC
02B0A:  MOVFF  69E,6BB
02B0E:  MOVFF  69D,6BA
02B12:  CALL   1D18
02B16:  MOVFF  03,6A8
02B1A:  MOVFF  02,6A7
02B1E:  MOVFF  01,6A6
02B22:  MOVFF  00,6A5
02B26:  MOVFF  03,6AC
02B2A:  MOVFF  02,6AB
02B2E:  MOVFF  01,6AA
02B32:  MOVFF  00,6A9
02B36:  BRA    2A3E
02B38:  BRA    2B80
02B3A:  MOVFF  69C,6B9
02B3E:  MOVFF  69B,6B8
02B42:  MOVFF  69A,6B7
02B46:  MOVFF  699,6B6
02B4A:  MOVFF  6A0,6BD
02B4E:  MOVFF  69F,6BC
02B52:  MOVFF  69E,6BB
02B56:  MOVFF  69D,6BA
02B5A:  CALL   1D18
02B5E:  MOVFF  03,6A8
02B62:  MOVFF  02,6A7
02B66:  MOVFF  01,6A6
02B6A:  MOVFF  00,6A5
02B6E:  MOVFF  03,6AC
02B72:  MOVFF  02,6AB
02B76:  MOVFF  01,6AA
02B7A:  MOVFF  00,6A9
02B7E:  BRA    2A5C
02B80:  MOVFF  03,6A4
02B84:  MOVFF  02,6A3
02B88:  MOVFF  01,6A2
02B8C:  MOVFF  00,6A1
....................       return(x-(i*y));
02B90:  MOVFF  6A4,6C5
02B94:  MOVFF  6A3,6C4
02B98:  MOVFF  6A2,6C3
02B9C:  MOVFF  6A1,6C2
02BA0:  MOVFF  6A0,6C9
02BA4:  MOVFF  69F,6C8
02BA8:  MOVFF  69E,6C7
02BAC:  MOVFF  69D,6C6
02BB0:  CALL   0D12
02BB4:  BSF    FD8.1
02BB6:  MOVFF  69C,6C4
02BBA:  MOVFF  69B,6C3
02BBE:  MOVFF  69A,6C2
02BC2:  MOVFF  699,6C1
02BC6:  MOVFF  03,6C8
02BCA:  MOVFF  02,6C7
02BCE:  MOVFF  01,6C6
02BD2:  MOVFF  00,6C5
02BD6:  CALL   0E08
02BDA:  BRA    2BDC
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
02BDC:  RETURN 0
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
*
02F72:  MOVFF  6A0,6C5
02F76:  MOVFF  69F,6C4
02F7A:  MOVFF  69E,6C3
02F7E:  MOVFF  69D,6C2
02F82:  MOVLW  3B
02F84:  MOVLB  6
02F86:  MOVWF  xC9
02F88:  MOVLW  AA
02F8A:  MOVWF  xC8
02F8C:  MOVLW  38
02F8E:  MOVWF  xC7
02F90:  MOVLW  7F
02F92:  MOVWF  xC6
02F94:  MOVLB  0
02F96:  CALL   0D12
02F9A:  MOVFF  03,6C0
02F9E:  MOVFF  02,6BF
02FA2:  MOVFF  01,6BE
02FA6:  MOVFF  00,6BD
02FAA:  CALL   2692
02FAE:  MOVFF  01,6AD
....................    s = 0;
02FB2:  MOVLB  6
02FB4:  BCF    xAE.0
....................    y = x;
02FB6:  MOVFF  6A0,6A4
02FBA:  MOVFF  69F,6A3
02FBE:  MOVFF  69E,6A2
02FC2:  MOVFF  69D,6A1
.................... 
....................    if (x < 0)
02FC6:  MOVFF  6A0,6C0
02FCA:  MOVFF  69F,6BF
02FCE:  MOVFF  69E,6BE
02FD2:  MOVFF  69D,6BD
02FD6:  CLRF   xC4
02FD8:  CLRF   xC3
02FDA:  CLRF   xC2
02FDC:  CLRF   xC1
02FDE:  MOVLB  0
02FE0:  CALL   1C9E
02FE4:  BNC   2FF4
....................    {
....................       s = 1;
02FE6:  MOVLB  6
02FE8:  BSF    xAE.0
....................       n = -n;
02FEA:  NEGF   xAD
....................       y = -y;
02FEC:  MOVF   xA2,W
02FEE:  XORLW  80
02FF0:  MOVWF  xA2
02FF2:  MOVLB  0
....................    }
.................... 
....................    res = 0.0;
02FF4:  MOVLB  6
02FF6:  CLRF   xA8
02FF8:  CLRF   xA7
02FFA:  CLRF   xA6
02FFC:  CLRF   xA5
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
02FFE:  MOVLW  06
03000:  MOVWF  xB0
03002:  MOVLW  A5
03004:  MOVFF  6B0,FEA
03008:  MOVWF  FE9
0300A:  MOVLW  7F
0300C:  ADDWF  xAD,W
0300E:  MOVWF  FEF
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
03010:  MOVFF  6A4,6C5
03014:  MOVFF  6A3,6C4
03018:  MOVFF  6A2,6C3
0301C:  MOVFF  6A1,6C2
03020:  MOVLW  3B
03022:  MOVWF  xC9
03024:  MOVLW  AA
03026:  MOVWF  xC8
03028:  MOVLW  38
0302A:  MOVWF  xC7
0302C:  MOVLW  7F
0302E:  MOVWF  xC6
03030:  MOVLB  0
03032:  CALL   0D12
03036:  MOVFF  03,6B2
0303A:  MOVFF  02,6B1
0303E:  MOVFF  01,6B0
03042:  MOVFF  00,6AF
03046:  MOVLB  6
03048:  CLRF   xB4
0304A:  MOVFF  6AD,6B3
0304E:  BTFSC  xB3.7
03050:  DECF   xB4,F
03052:  MOVLB  0
03054:  CALL   2642
03058:  BSF    FD8.1
0305A:  MOVFF  6B2,6C4
0305E:  MOVFF  6B1,6C3
03062:  MOVFF  6B0,6C2
03066:  MOVFF  6AF,6C1
0306A:  MOVFF  03,6C8
0306E:  MOVFF  02,6C7
03072:  MOVFF  01,6C6
03076:  MOVFF  00,6C5
0307A:  CALL   0E08
0307E:  MOVFF  03,6A4
03082:  MOVFF  02,6A3
03086:  MOVFF  01,6A2
0308A:  MOVFF  00,6A1
.................... 
....................    r = pe[0]*y + pe[1];
0308E:  MOVLW  7C
03090:  MOVLB  6
03092:  MOVWF  xC5
03094:  MOVLW  88
03096:  MOVWF  xC4
03098:  MOVLW  59
0309A:  MOVWF  xC3
0309C:  MOVLW  72
0309E:  MOVWF  xC2
030A0:  MOVFF  6A4,6C9
030A4:  MOVFF  6A3,6C8
030A8:  MOVFF  6A2,6C7
030AC:  MOVFF  6A1,6C6
030B0:  MOVLB  0
030B2:  CALL   0D12
030B6:  MOVFF  03,6B2
030BA:  MOVFF  02,6B1
030BE:  MOVFF  01,6B0
030C2:  MOVFF  00,6AF
030C6:  BCF    FD8.1
030C8:  MOVFF  03,6C4
030CC:  MOVFF  02,6C3
030D0:  MOVFF  01,6C2
030D4:  MOVFF  00,6C1
030D8:  MOVLW  E0
030DA:  MOVLB  6
030DC:  MOVWF  xC8
030DE:  MOVLW  97
030E0:  MOVWF  xC7
030E2:  MOVLW  26
030E4:  MOVWF  xC6
030E6:  MOVLW  75
030E8:  MOVWF  xC5
030EA:  MOVLB  0
030EC:  CALL   0E08
030F0:  MOVFF  03,6AC
030F4:  MOVFF  02,6AB
030F8:  MOVFF  01,6AA
030FC:  MOVFF  00,6A9
....................    r = r*y + pe[2];
03100:  MOVFF  6AC,6C5
03104:  MOVFF  6AB,6C4
03108:  MOVFF  6AA,6C3
0310C:  MOVFF  6A9,6C2
03110:  MOVFF  6A4,6C9
03114:  MOVFF  6A3,6C8
03118:  MOVFF  6A2,6C7
0311C:  MOVFF  6A1,6C6
03120:  CALL   0D12
03124:  MOVFF  03,6B2
03128:  MOVFF  02,6B1
0312C:  MOVFF  01,6B0
03130:  MOVFF  00,6AF
03134:  BCF    FD8.1
03136:  MOVFF  03,6C4
0313A:  MOVFF  02,6C3
0313E:  MOVFF  01,6C2
03142:  MOVFF  00,6C1
03146:  MOVLW  C4
03148:  MOVLB  6
0314A:  MOVWF  xC8
0314C:  MOVLW  1D
0314E:  MOVWF  xC7
03150:  MOVLW  1E
03152:  MOVWF  xC6
03154:  MOVLW  78
03156:  MOVWF  xC5
03158:  MOVLB  0
0315A:  CALL   0E08
0315E:  MOVFF  03,6AC
03162:  MOVFF  02,6AB
03166:  MOVFF  01,6AA
0316A:  MOVFF  00,6A9
....................    r = r*y + pe[3];
0316E:  MOVFF  6AC,6C5
03172:  MOVFF  6AB,6C4
03176:  MOVFF  6AA,6C3
0317A:  MOVFF  6A9,6C2
0317E:  MOVFF  6A4,6C9
03182:  MOVFF  6A3,6C8
03186:  MOVFF  6A2,6C7
0318A:  MOVFF  6A1,6C6
0318E:  CALL   0D12
03192:  MOVFF  03,6B2
03196:  MOVFF  02,6B1
0319A:  MOVFF  01,6B0
0319E:  MOVFF  00,6AF
031A2:  BCF    FD8.1
031A4:  MOVFF  03,6C4
031A8:  MOVFF  02,6C3
031AC:  MOVFF  01,6C2
031B0:  MOVFF  00,6C1
031B4:  MOVLW  5E
031B6:  MOVLB  6
031B8:  MOVWF  xC8
031BA:  MOVLW  50
031BC:  MOVWF  xC7
031BE:  MOVLW  63
031C0:  MOVWF  xC6
031C2:  MOVLW  7A
031C4:  MOVWF  xC5
031C6:  MOVLB  0
031C8:  CALL   0E08
031CC:  MOVFF  03,6AC
031D0:  MOVFF  02,6AB
031D4:  MOVFF  01,6AA
031D8:  MOVFF  00,6A9
....................    r = r*y + pe[4];
031DC:  MOVFF  6AC,6C5
031E0:  MOVFF  6AB,6C4
031E4:  MOVFF  6AA,6C3
031E8:  MOVFF  6A9,6C2
031EC:  MOVFF  6A4,6C9
031F0:  MOVFF  6A3,6C8
031F4:  MOVFF  6A2,6C7
031F8:  MOVFF  6A1,6C6
031FC:  CALL   0D12
03200:  MOVFF  03,6B2
03204:  MOVFF  02,6B1
03208:  MOVFF  01,6B0
0320C:  MOVFF  00,6AF
03210:  BCF    FD8.1
03212:  MOVFF  03,6C4
03216:  MOVFF  02,6C3
0321A:  MOVFF  01,6C2
0321E:  MOVFF  00,6C1
03222:  MOVLW  1A
03224:  MOVLB  6
03226:  MOVWF  xC8
03228:  MOVLW  FE
0322A:  MOVWF  xC7
0322C:  MOVLW  75
0322E:  MOVWF  xC6
03230:  MOVLW  7C
03232:  MOVWF  xC5
03234:  MOVLB  0
03236:  CALL   0E08
0323A:  MOVFF  03,6AC
0323E:  MOVFF  02,6AB
03242:  MOVFF  01,6AA
03246:  MOVFF  00,6A9
....................    r = r*y + pe[5];
0324A:  MOVFF  6AC,6C5
0324E:  MOVFF  6AB,6C4
03252:  MOVFF  6AA,6C3
03256:  MOVFF  6A9,6C2
0325A:  MOVFF  6A4,6C9
0325E:  MOVFF  6A3,6C8
03262:  MOVFF  6A2,6C7
03266:  MOVFF  6A1,6C6
0326A:  CALL   0D12
0326E:  MOVFF  03,6B2
03272:  MOVFF  02,6B1
03276:  MOVFF  01,6B0
0327A:  MOVFF  00,6AF
0327E:  BCF    FD8.1
03280:  MOVFF  03,6C4
03284:  MOVFF  02,6C3
03288:  MOVFF  01,6C2
0328C:  MOVFF  00,6C1
03290:  MOVLW  18
03292:  MOVLB  6
03294:  MOVWF  xC8
03296:  MOVLW  72
03298:  MOVWF  xC7
0329A:  MOVLW  31
0329C:  MOVWF  xC6
0329E:  MOVLW  7E
032A0:  MOVWF  xC5
032A2:  MOVLB  0
032A4:  CALL   0E08
032A8:  MOVFF  03,6AC
032AC:  MOVFF  02,6AB
032B0:  MOVFF  01,6AA
032B4:  MOVFF  00,6A9
.................... 
....................    res = res*(1.0 + y*r);
032B8:  MOVFF  6A4,6C5
032BC:  MOVFF  6A3,6C4
032C0:  MOVFF  6A2,6C3
032C4:  MOVFF  6A1,6C2
032C8:  MOVFF  6AC,6C9
032CC:  MOVFF  6AB,6C8
032D0:  MOVFF  6AA,6C7
032D4:  MOVFF  6A9,6C6
032D8:  CALL   0D12
032DC:  BCF    FD8.1
032DE:  MOVLB  6
032E0:  CLRF   xC4
032E2:  CLRF   xC3
032E4:  CLRF   xC2
032E6:  MOVLW  7F
032E8:  MOVWF  xC1
032EA:  MOVFF  03,6C8
032EE:  MOVFF  02,6C7
032F2:  MOVFF  01,6C6
032F6:  MOVFF  00,6C5
032FA:  MOVLB  0
032FC:  CALL   0E08
03300:  MOVFF  6A8,6C5
03304:  MOVFF  6A7,6C4
03308:  MOVFF  6A6,6C3
0330C:  MOVFF  6A5,6C2
03310:  MOVFF  03,6C9
03314:  MOVFF  02,6C8
03318:  MOVFF  01,6C7
0331C:  MOVFF  00,6C6
03320:  CALL   0D12
03324:  MOVFF  03,6A8
03328:  MOVFF  02,6A7
0332C:  MOVFF  01,6A6
03330:  MOVFF  00,6A5
.................... 
....................    if (s)
03334:  MOVLB  6
03336:  BTFSS  xAE.0
03338:  BRA    336C
....................       res = 1.0/res;
0333A:  CLRF   xB9
0333C:  CLRF   xB8
0333E:  CLRF   xB7
03340:  MOVLW  7F
03342:  MOVWF  xB6
03344:  MOVFF  6A8,6BD
03348:  MOVFF  6A7,6BC
0334C:  MOVFF  6A6,6BB
03350:  MOVFF  6A5,6BA
03354:  MOVLB  0
03356:  CALL   1D18
0335A:  MOVFF  03,6A8
0335E:  MOVFF  02,6A7
03362:  MOVFF  01,6A6
03366:  MOVFF  00,6A5
0336A:  MOVLB  6
....................    return(res);
0336C:  MOVFF  6A5,00
03370:  MOVFF  6A6,01
03374:  MOVFF  6A7,02
03378:  MOVFF  6A8,03
0337C:  MOVLB  0
0337E:  RETURN 0
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
*
02BDE:  MOVFF  6A0,6A4
02BE2:  MOVFF  69F,6A3
02BE6:  MOVFF  69E,6A2
02BEA:  MOVFF  69D,6A1
.................... 
....................    if (y != 1.0)
02BEE:  MOVFF  6A4,6C0
02BF2:  MOVFF  6A3,6BF
02BF6:  MOVFF  6A2,6BE
02BFA:  MOVFF  6A1,6BD
02BFE:  MOVLB  6
02C00:  CLRF   xC4
02C02:  CLRF   xC3
02C04:  CLRF   xC2
02C06:  MOVLW  7F
02C08:  MOVWF  xC1
02C0A:  MOVLB  0
02C0C:  CALL   1C9E
02C10:  BTFSC  FD8.2
02C12:  BRA    2F54
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
02C14:  MOVLW  06
02C16:  MOVLB  6
02C18:  MOVWF  xB3
02C1A:  MOVLW  A1
02C1C:  MOVFF  6B3,FEA
02C20:  MOVWF  FE9
02C22:  MOVLW  7E
02C24:  MOVWF  FEF
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
02C26:  BSF    FD8.1
02C28:  MOVFF  6A4,6C4
02C2C:  MOVFF  6A3,6C3
02C30:  MOVFF  6A2,6C2
02C34:  MOVFF  6A1,6C1
02C38:  CLRF   xC8
02C3A:  CLRF   xC7
02C3C:  CLRF   xC6
02C3E:  MOVLW  7F
02C40:  MOVWF  xC5
02C42:  MOVLB  0
02C44:  CALL   0E08
02C48:  MOVFF  03,6B5
02C4C:  MOVFF  02,6B4
02C50:  MOVFF  01,6B3
02C54:  MOVFF  00,6B2
02C58:  BCF    FD8.1
02C5A:  MOVFF  6A4,6C4
02C5E:  MOVFF  6A3,6C3
02C62:  MOVFF  6A2,6C2
02C66:  MOVFF  6A1,6C1
02C6A:  MOVLB  6
02C6C:  CLRF   xC8
02C6E:  CLRF   xC7
02C70:  CLRF   xC6
02C72:  MOVLW  7F
02C74:  MOVWF  xC5
02C76:  MOVLB  0
02C78:  CALL   0E08
02C7C:  MOVFF  6B5,6B9
02C80:  MOVFF  6B4,6B8
02C84:  MOVFF  6B3,6B7
02C88:  MOVFF  6B2,6B6
02C8C:  MOVFF  03,6BD
02C90:  MOVFF  02,6BC
02C94:  MOVFF  01,6BB
02C98:  MOVFF  00,6BA
02C9C:  CALL   1D18
02CA0:  MOVFF  03,6A4
02CA4:  MOVFF  02,6A3
02CA8:  MOVFF  01,6A2
02CAC:  MOVFF  00,6A1
.................... 
....................       y2=y*y;
02CB0:  MOVFF  6A4,6C5
02CB4:  MOVFF  6A3,6C4
02CB8:  MOVFF  6A2,6C3
02CBC:  MOVFF  6A1,6C2
02CC0:  MOVFF  6A4,6C9
02CC4:  MOVFF  6A3,6C8
02CC8:  MOVFF  6A2,6C7
02CCC:  MOVFF  6A1,6C6
02CD0:  CALL   0D12
02CD4:  MOVFF  03,6B0
02CD8:  MOVFF  02,6AF
02CDC:  MOVFF  01,6AE
02CE0:  MOVFF  00,6AD
.................... 
....................       res = pl[0]*y2 + pl[1];
02CE4:  MOVLW  99
02CE6:  MOVLB  6
02CE8:  MOVWF  xC5
02CEA:  MOVLW  47
02CEC:  MOVWF  xC4
02CEE:  MOVLW  8A
02CF0:  MOVWF  xC3
02CF2:  MOVLW  7F
02CF4:  MOVWF  xC2
02CF6:  MOVFF  6B0,6C9
02CFA:  MOVFF  6AF,6C8
02CFE:  MOVFF  6AE,6C7
02D02:  MOVFF  6AD,6C6
02D06:  MOVLB  0
02D08:  CALL   0D12
02D0C:  MOVFF  03,6B5
02D10:  MOVFF  02,6B4
02D14:  MOVFF  01,6B3
02D18:  MOVFF  00,6B2
02D1C:  BCF    FD8.1
02D1E:  MOVFF  03,6C4
02D22:  MOVFF  02,6C3
02D26:  MOVFF  01,6C2
02D2A:  MOVFF  00,6C1
02D2E:  MOVLB  6
02D30:  CLRF   xC8
02D32:  CLRF   xC7
02D34:  CLRF   xC6
02D36:  MOVLW  80
02D38:  MOVWF  xC5
02D3A:  MOVLB  0
02D3C:  CALL   0E08
02D40:  MOVFF  03,6A8
02D44:  MOVFF  02,6A7
02D48:  MOVFF  01,6A6
02D4C:  MOVFF  00,6A5
.................... 
....................       r = ql[0]*y2 + ql[1];
02D50:  MOVLW  4C
02D52:  MOVLB  6
02D54:  MOVWF  xC5
02D56:  MOVLW  F3
02D58:  MOVWF  xC4
02D5A:  MOVLW  3A
02D5C:  MOVWF  xC3
02D5E:  MOVLW  7B
02D60:  MOVWF  xC2
02D62:  MOVFF  6B0,6C9
02D66:  MOVFF  6AF,6C8
02D6A:  MOVFF  6AE,6C7
02D6E:  MOVFF  6AD,6C6
02D72:  MOVLB  0
02D74:  CALL   0D12
02D78:  MOVFF  03,6B5
02D7C:  MOVFF  02,6B4
02D80:  MOVFF  01,6B3
02D84:  MOVFF  00,6B2
02D88:  BCF    FD8.1
02D8A:  MOVFF  03,6C4
02D8E:  MOVFF  02,6C3
02D92:  MOVFF  01,6C2
02D96:  MOVFF  00,6C1
02D9A:  MOVLW  2B
02D9C:  MOVLB  6
02D9E:  MOVWF  xC8
02DA0:  MOVLW  9D
02DA2:  MOVWF  xC7
02DA4:  MOVLW  DF
02DA6:  MOVWF  xC6
02DA8:  MOVLW  7E
02DAA:  MOVWF  xC5
02DAC:  MOVLB  0
02DAE:  CALL   0E08
02DB2:  MOVFF  03,6AC
02DB6:  MOVFF  02,6AB
02DBA:  MOVFF  01,6AA
02DBE:  MOVFF  00,6A9
....................       r = r*y2 + 1.0;
02DC2:  MOVFF  6AC,6C5
02DC6:  MOVFF  6AB,6C4
02DCA:  MOVFF  6AA,6C3
02DCE:  MOVFF  6A9,6C2
02DD2:  MOVFF  6B0,6C9
02DD6:  MOVFF  6AF,6C8
02DDA:  MOVFF  6AE,6C7
02DDE:  MOVFF  6AD,6C6
02DE2:  CALL   0D12
02DE6:  MOVFF  03,6B5
02DEA:  MOVFF  02,6B4
02DEE:  MOVFF  01,6B3
02DF2:  MOVFF  00,6B2
02DF6:  BCF    FD8.1
02DF8:  MOVFF  03,6C4
02DFC:  MOVFF  02,6C3
02E00:  MOVFF  01,6C2
02E04:  MOVFF  00,6C1
02E08:  MOVLB  6
02E0A:  CLRF   xC8
02E0C:  CLRF   xC7
02E0E:  CLRF   xC6
02E10:  MOVLW  7F
02E12:  MOVWF  xC5
02E14:  MOVLB  0
02E16:  CALL   0E08
02E1A:  MOVFF  03,6AC
02E1E:  MOVFF  02,6AB
02E22:  MOVFF  01,6AA
02E26:  MOVFF  00,6A9
.................... 
....................       res = y*res/r;
02E2A:  MOVFF  6A4,6C5
02E2E:  MOVFF  6A3,6C4
02E32:  MOVFF  6A2,6C3
02E36:  MOVFF  6A1,6C2
02E3A:  MOVFF  6A8,6C9
02E3E:  MOVFF  6A7,6C8
02E42:  MOVFF  6A6,6C7
02E46:  MOVFF  6A5,6C6
02E4A:  CALL   0D12
02E4E:  MOVFF  03,6B5
02E52:  MOVFF  02,6B4
02E56:  MOVFF  01,6B3
02E5A:  MOVFF  00,6B2
02E5E:  MOVFF  03,6B9
02E62:  MOVFF  02,6B8
02E66:  MOVFF  01,6B7
02E6A:  MOVFF  00,6B6
02E6E:  MOVFF  6AC,6BD
02E72:  MOVFF  6AB,6BC
02E76:  MOVFF  6AA,6BB
02E7A:  MOVFF  6A9,6BA
02E7E:  CALL   1D18
02E82:  MOVFF  03,6A8
02E86:  MOVFF  02,6A7
02E8A:  MOVFF  01,6A6
02E8E:  MOVFF  00,6A5
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
02E92:  MOVLW  06
02E94:  MOVLB  6
02E96:  MOVWF  xB3
02E98:  MOVLW  9D
02E9A:  MOVFF  6B3,FEA
02E9E:  MOVWF  FE9
02EA0:  MOVLW  7E
02EA2:  SUBWF  FEF,W
02EA4:  MOVWF  xB1
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
02EA6:  BTFSS  xB1.7
02EA8:  BRA    2ED4
....................          r = -(float32)-n;
02EAA:  MOVLW  00
02EAC:  BSF    FD8.0
02EAE:  SUBFWB xB1,W
02EB0:  CLRF   xB4
02EB2:  MOVWF  xB3
02EB4:  BTFSC  xB3.7
02EB6:  DECF   xB4,F
02EB8:  MOVLB  0
02EBA:  CALL   2642
02EBE:  MOVFF  00,6A9
02EC2:  MOVF   01,W
02EC4:  XORLW  80
02EC6:  MOVLB  6
02EC8:  MOVWF  xAA
02ECA:  MOVFF  02,6AB
02ECE:  MOVFF  03,6AC
02ED2:  BRA    2EF6
....................       else
....................          r = (float32)n;
02ED4:  CLRF   xB4
02ED6:  MOVFF  6B1,6B3
02EDA:  BTFSC  xB3.7
02EDC:  DECF   xB4,F
02EDE:  MOVLB  0
02EE0:  CALL   2642
02EE4:  MOVFF  03,6AC
02EE8:  MOVFF  02,6AB
02EEC:  MOVFF  01,6AA
02EF0:  MOVFF  00,6A9
02EF4:  MOVLB  6
.................... 
....................       res += r*LN2;
02EF6:  MOVFF  6AC,6C5
02EFA:  MOVFF  6AB,6C4
02EFE:  MOVFF  6AA,6C3
02F02:  MOVFF  6A9,6C2
02F06:  MOVLW  18
02F08:  MOVWF  xC9
02F0A:  MOVLW  72
02F0C:  MOVWF  xC8
02F0E:  MOVLW  31
02F10:  MOVWF  xC7
02F12:  MOVLW  7E
02F14:  MOVWF  xC6
02F16:  MOVLB  0
02F18:  CALL   0D12
02F1C:  BCF    FD8.1
02F1E:  MOVFF  6A8,6C4
02F22:  MOVFF  6A7,6C3
02F26:  MOVFF  6A6,6C2
02F2A:  MOVFF  6A5,6C1
02F2E:  MOVFF  03,6C8
02F32:  MOVFF  02,6C7
02F36:  MOVFF  01,6C6
02F3A:  MOVFF  00,6C5
02F3E:  CALL   0E08
02F42:  MOVFF  03,6A8
02F46:  MOVFF  02,6A7
02F4A:  MOVFF  01,6A6
02F4E:  MOVFF  00,6A5
....................    }
02F52:  BRA    2F60
.................... 
....................    else
....................       res = 0.0;
02F54:  MOVLB  6
02F56:  CLRF   xA8
02F58:  CLRF   xA7
02F5A:  CLRF   xA6
02F5C:  CLRF   xA5
02F5E:  MOVLB  0
.................... 
....................    return(res);
02F60:  MOVFF  6A5,00
02F64:  MOVFF  6A6,01
02F68:  MOVFF  6A7,02
02F6C:  MOVFF  6A8,03
02F70:  RETURN 0
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
*
03380:  MOVFF  694,6C0
03384:  MOVFF  693,6BF
03388:  MOVFF  692,6BE
0338C:  MOVFF  691,6BD
03390:  MOVLB  6
03392:  CLRF   xC4
03394:  CLRF   xC3
03396:  CLRF   xC2
03398:  CLRF   xC1
0339A:  MOVLB  0
0339C:  CALL   1C9E
033A0:  BTFSS  FD8.0
033A2:  BRA    353E
033A4:  MOVFF  698,69C
033A8:  MOVFF  697,69B
033AC:  MOVFF  696,69A
033B0:  MOVFF  695,699
033B4:  MOVLB  6
033B6:  CLRF   xA0
033B8:  CLRF   x9F
033BA:  CLRF   x9E
033BC:  MOVLW  7F
033BE:  MOVWF  x9D
033C0:  MOVLB  0
033C2:  CALL   2A78
033C6:  MOVFF  03,69C
033CA:  MOVFF  02,69B
033CE:  MOVFF  01,69A
033D2:  MOVFF  00,699
033D6:  MOVFF  03,6C0
033DA:  MOVFF  02,6BF
033DE:  MOVFF  01,6BE
033E2:  MOVFF  00,6BD
033E6:  MOVLB  6
033E8:  CLRF   xC4
033EA:  CLRF   xC3
033EC:  CLRF   xC2
033EE:  CLRF   xC1
033F0:  MOVLB  0
033F2:  CALL   1C9E
033F6:  BTFSS  FD8.2
033F8:  BRA    353E
....................       if(fmod(y, 2) == 0) {
033FA:  MOVFF  698,69C
033FE:  MOVFF  697,69B
03402:  MOVFF  696,69A
03406:  MOVFF  695,699
0340A:  MOVLB  6
0340C:  CLRF   xA0
0340E:  CLRF   x9F
03410:  CLRF   x9E
03412:  MOVLW  80
03414:  MOVWF  x9D
03416:  MOVLB  0
03418:  CALL   2A78
0341C:  MOVFF  03,69C
03420:  MOVFF  02,69B
03424:  MOVFF  01,69A
03428:  MOVFF  00,699
0342C:  MOVFF  03,6C0
03430:  MOVFF  02,6BF
03434:  MOVFF  01,6BE
03438:  MOVFF  00,6BD
0343C:  MOVLB  6
0343E:  CLRF   xC4
03440:  CLRF   xC3
03442:  CLRF   xC2
03444:  CLRF   xC1
03446:  MOVLB  0
03448:  CALL   1C9E
0344C:  BNZ   34C4
....................          return (exp(log(-x) * y));
0344E:  MOVLB  6
03450:  MOVF   x92,W
03452:  XORLW  80
03454:  MOVWF  x9A
03456:  MOVFF  694,6A0
0345A:  MOVFF  693,69F
0345E:  MOVWF  x9E
03460:  MOVFF  691,69D
03464:  MOVLB  0
03466:  CALL   2BDE
0346A:  MOVFF  03,69C
0346E:  MOVFF  02,69B
03472:  MOVFF  01,69A
03476:  MOVFF  00,699
0347A:  MOVFF  03,6C5
0347E:  MOVFF  02,6C4
03482:  MOVFF  01,6C3
03486:  MOVFF  00,6C2
0348A:  MOVFF  698,6C9
0348E:  MOVFF  697,6C8
03492:  MOVFF  696,6C7
03496:  MOVFF  695,6C6
0349A:  CALL   0D12
0349E:  MOVFF  03,69C
034A2:  MOVFF  02,69B
034A6:  MOVFF  01,69A
034AA:  MOVFF  00,699
034AE:  MOVFF  03,6A0
034B2:  MOVFF  02,69F
034B6:  MOVFF  01,69E
034BA:  MOVFF  00,69D
034BE:  RCALL  2F72
034C0:  BRA    367C
....................       } else {
034C2:  BRA    353C
....................          return (-exp(log(-x) * y));
034C4:  MOVLB  6
034C6:  MOVF   x92,W
034C8:  XORLW  80
034CA:  MOVWF  x9A
034CC:  MOVFF  694,6A0
034D0:  MOVFF  693,69F
034D4:  MOVWF  x9E
034D6:  MOVFF  691,69D
034DA:  MOVLB  0
034DC:  CALL   2BDE
034E0:  MOVFF  03,69C
034E4:  MOVFF  02,69B
034E8:  MOVFF  01,69A
034EC:  MOVFF  00,699
034F0:  MOVFF  03,6C5
034F4:  MOVFF  02,6C4
034F8:  MOVFF  01,6C3
034FC:  MOVFF  00,6C2
03500:  MOVFF  698,6C9
03504:  MOVFF  697,6C8
03508:  MOVFF  696,6C7
0350C:  MOVFF  695,6C6
03510:  CALL   0D12
03514:  MOVFF  03,69C
03518:  MOVFF  02,69B
0351C:  MOVFF  01,69A
03520:  MOVFF  00,699
03524:  MOVFF  03,6A0
03528:  MOVFF  02,69F
0352C:  MOVFF  01,69E
03530:  MOVFF  00,69D
03534:  RCALL  2F72
03536:  MOVLW  80
03538:  XORWF  01,F
0353A:  BRA    367C
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
0353C:  BRA    367C
0353E:  MOVFF  694,6C0
03542:  MOVFF  693,6BF
03546:  MOVFF  692,6BE
0354A:  MOVFF  691,6BD
0354E:  MOVLB  6
03550:  CLRF   xC4
03552:  CLRF   xC3
03554:  CLRF   xC2
03556:  CLRF   xC1
03558:  MOVLB  0
0355A:  CALL   1C9E
0355E:  BNC   35C0
03560:  MOVFF  698,69C
03564:  MOVFF  697,69B
03568:  MOVFF  696,69A
0356C:  MOVFF  695,699
03570:  MOVLB  6
03572:  CLRF   xA0
03574:  CLRF   x9F
03576:  CLRF   x9E
03578:  MOVLW  7F
0357A:  MOVWF  x9D
0357C:  MOVLB  0
0357E:  CALL   2A78
03582:  MOVFF  03,69C
03586:  MOVFF  02,69B
0358A:  MOVFF  01,69A
0358E:  MOVFF  00,699
03592:  MOVFF  03,6C0
03596:  MOVFF  02,6BF
0359A:  MOVFF  01,6BE
0359E:  MOVFF  00,6BD
035A2:  MOVLB  6
035A4:  CLRF   xC4
035A6:  CLRF   xC3
035A8:  CLRF   xC2
035AA:  CLRF   xC1
035AC:  MOVLB  0
035AE:  CALL   1C9E
035B2:  BZ    35C0
....................       return 0;
035B4:  CLRF   00
035B6:  CLRF   01
035B8:  CLRF   02
035BA:  CLRF   03
035BC:  BRA    367C
....................    } else {
035BE:  BRA    367C
....................       if(x != 0 || 0 >= y) {
035C0:  MOVFF  694,6C0
035C4:  MOVFF  693,6BF
035C8:  MOVFF  692,6BE
035CC:  MOVFF  691,6BD
035D0:  MOVLB  6
035D2:  CLRF   xC4
035D4:  CLRF   xC3
035D6:  CLRF   xC2
035D8:  CLRF   xC1
035DA:  MOVLB  0
035DC:  CALL   1C9E
035E0:  BNZ   3606
035E2:  MOVFF  698,6C0
035E6:  MOVFF  697,6BF
035EA:  MOVFF  696,6BE
035EE:  MOVFF  695,6BD
035F2:  MOVLB  6
035F4:  CLRF   xC4
035F6:  CLRF   xC3
035F8:  CLRF   xC2
035FA:  CLRF   xC1
035FC:  MOVLB  0
035FE:  CALL   1C9E
03602:  BC    3606
03604:  BNZ   3674
....................          return (exp(log(x) * y));
03606:  MOVFF  694,6A0
0360A:  MOVFF  693,69F
0360E:  MOVFF  692,69E
03612:  MOVFF  691,69D
03616:  CALL   2BDE
0361A:  MOVFF  03,69C
0361E:  MOVFF  02,69B
03622:  MOVFF  01,69A
03626:  MOVFF  00,699
0362A:  MOVFF  03,6C5
0362E:  MOVFF  02,6C4
03632:  MOVFF  01,6C3
03636:  MOVFF  00,6C2
0363A:  MOVFF  698,6C9
0363E:  MOVFF  697,6C8
03642:  MOVFF  696,6C7
03646:  MOVFF  695,6C6
0364A:  CALL   0D12
0364E:  MOVFF  03,69C
03652:  MOVFF  02,69B
03656:  MOVFF  01,69A
0365A:  MOVFF  00,699
0365E:  MOVFF  03,6A0
03662:  MOVFF  02,69F
03666:  MOVFF  01,69E
0366A:  MOVFF  00,69D
0366E:  RCALL  2F72
03670:  BRA    367C
....................       } else return 0;
03672:  BRA    367C
03674:  CLRF   00
03676:  CLRF   01
03678:  CLRF   02
0367A:  CLRF   03
....................    }
0367C:  RETURN 0
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
*
01E76:  MOVLB  6
01E78:  BCF    xAF.0
....................    flag = 0;
01E7A:  BCF    xAF.1
....................    y = x;
01E7C:  MOVFF  6A2,6A6
01E80:  MOVFF  6A1,6A5
01E84:  MOVFF  6A0,6A4
01E88:  MOVFF  69F,6A3
.................... 
....................    if (x < 0)
01E8C:  MOVFF  6A2,6C0
01E90:  MOVFF  6A1,6BF
01E94:  MOVFF  6A0,6BE
01E98:  MOVFF  69F,6BD
01E9C:  CLRF   xC4
01E9E:  CLRF   xC3
01EA0:  CLRF   xC2
01EA2:  CLRF   xC1
01EA4:  MOVLB  0
01EA6:  RCALL  1C9E
01EA8:  BNC   1EB6
....................    {
....................       s = 1;
01EAA:  MOVLB  6
01EAC:  BSF    xAF.0
....................       y = -y;
01EAE:  MOVF   xA4,W
01EB0:  XORLW  80
01EB2:  MOVWF  xA4
01EB4:  MOVLB  0
....................    }
.................... 
....................    if (y > 1.0)
01EB6:  MOVLB  6
01EB8:  CLRF   xC0
01EBA:  CLRF   xBF
01EBC:  CLRF   xBE
01EBE:  MOVLW  7F
01EC0:  MOVWF  xBD
01EC2:  MOVFF  6A6,6C4
01EC6:  MOVFF  6A5,6C3
01ECA:  MOVFF  6A4,6C2
01ECE:  MOVFF  6A3,6C1
01ED2:  MOVLB  0
01ED4:  RCALL  1C9E
01ED6:  BNC   1F0E
....................    {
....................       y = 1.0/y;
01ED8:  MOVLB  6
01EDA:  CLRF   xB9
01EDC:  CLRF   xB8
01EDE:  CLRF   xB7
01EE0:  MOVLW  7F
01EE2:  MOVWF  xB6
01EE4:  MOVFF  6A6,6BD
01EE8:  MOVFF  6A5,6BC
01EEC:  MOVFF  6A4,6BB
01EF0:  MOVFF  6A3,6BA
01EF4:  MOVLB  0
01EF6:  RCALL  1D18
01EF8:  MOVFF  03,6A6
01EFC:  MOVFF  02,6A5
01F00:  MOVFF  01,6A4
01F04:  MOVFF  00,6A3
....................       flag = 1;
01F08:  MOVLB  6
01F0A:  BSF    xAF.1
01F0C:  MOVLB  0
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
01F0E:  MOVLW  0A
01F10:  MOVLB  6
01F12:  MOVWF  xC5
01F14:  MOVLW  89
01F16:  MOVWF  xC4
01F18:  MOVLW  34
01F1A:  MOVWF  xC3
01F1C:  MOVLW  7C
01F1E:  MOVWF  xC2
01F20:  MOVFF  6A6,6C9
01F24:  MOVFF  6A5,6C8
01F28:  MOVFF  6A4,6C7
01F2C:  MOVFF  6A3,6C6
01F30:  MOVLB  0
01F32:  CALL   0D12
01F36:  MOVFF  03,6B3
01F3A:  MOVFF  02,6B2
01F3E:  MOVFF  01,6B1
01F42:  MOVFF  00,6B0
01F46:  MOVFF  03,6C5
01F4A:  MOVFF  02,6C4
01F4E:  MOVFF  01,6C3
01F52:  MOVFF  00,6C2
01F56:  MOVFF  6A6,6C9
01F5A:  MOVFF  6A5,6C8
01F5E:  MOVFF  6A4,6C7
01F62:  MOVFF  6A3,6C6
01F66:  CALL   0D12
01F6A:  MOVFF  03,6B3
01F6E:  MOVFF  02,6B2
01F72:  MOVFF  01,6B1
01F76:  MOVFF  00,6B0
01F7A:  BCF    FD8.1
01F7C:  MOVFF  03,6C4
01F80:  MOVFF  02,6C3
01F84:  MOVFF  01,6C2
01F88:  MOVFF  00,6C1
01F8C:  MOVLW  7C
01F8E:  MOVLB  6
01F90:  MOVWF  xC8
01F92:  MOVLW  79
01F94:  MOVWF  xC7
01F96:  MOVLW  35
01F98:  MOVWF  xC6
01F9A:  MOVLW  81
01F9C:  MOVWF  xC5
01F9E:  MOVLB  0
01FA0:  CALL   0E08
01FA4:  MOVFF  03,6AA
01FA8:  MOVFF  02,6A9
01FAC:  MOVFF  01,6A8
01FB0:  MOVFF  00,6A7
....................    res = res*y*y + pat[2];
01FB4:  MOVFF  6AA,6C5
01FB8:  MOVFF  6A9,6C4
01FBC:  MOVFF  6A8,6C3
01FC0:  MOVFF  6A7,6C2
01FC4:  MOVFF  6A6,6C9
01FC8:  MOVFF  6A5,6C8
01FCC:  MOVFF  6A4,6C7
01FD0:  MOVFF  6A3,6C6
01FD4:  CALL   0D12
01FD8:  MOVFF  03,6B3
01FDC:  MOVFF  02,6B2
01FE0:  MOVFF  01,6B1
01FE4:  MOVFF  00,6B0
01FE8:  MOVFF  03,6C5
01FEC:  MOVFF  02,6C4
01FF0:  MOVFF  01,6C3
01FF4:  MOVFF  00,6C2
01FF8:  MOVFF  6A6,6C9
01FFC:  MOVFF  6A5,6C8
02000:  MOVFF  6A4,6C7
02004:  MOVFF  6A3,6C6
02008:  CALL   0D12
0200C:  MOVFF  03,6B3
02010:  MOVFF  02,6B2
02014:  MOVFF  01,6B1
02018:  MOVFF  00,6B0
0201C:  BCF    FD8.1
0201E:  MOVFF  03,6C4
02022:  MOVFF  02,6C3
02026:  MOVFF  01,6C2
0202A:  MOVFF  00,6C1
0202E:  MOVLW  3F
02030:  MOVLB  6
02032:  MOVWF  xC8
02034:  MOVLW  02
02036:  MOVWF  xC7
02038:  MOVLW  33
0203A:  MOVWF  xC6
0203C:  MOVLW  83
0203E:  MOVWF  xC5
02040:  MOVLB  0
02042:  CALL   0E08
02046:  MOVFF  03,6AA
0204A:  MOVFF  02,6A9
0204E:  MOVFF  01,6A8
02052:  MOVFF  00,6A7
....................    res = res*y*y + pat[3];
02056:  MOVFF  6AA,6C5
0205A:  MOVFF  6A9,6C4
0205E:  MOVFF  6A8,6C3
02062:  MOVFF  6A7,6C2
02066:  MOVFF  6A6,6C9
0206A:  MOVFF  6A5,6C8
0206E:  MOVFF  6A4,6C7
02072:  MOVFF  6A3,6C6
02076:  CALL   0D12
0207A:  MOVFF  03,6B3
0207E:  MOVFF  02,6B2
02082:  MOVFF  01,6B1
02086:  MOVFF  00,6B0
0208A:  MOVFF  03,6C5
0208E:  MOVFF  02,6C4
02092:  MOVFF  01,6C3
02096:  MOVFF  00,6C2
0209A:  MOVFF  6A6,6C9
0209E:  MOVFF  6A5,6C8
020A2:  MOVFF  6A4,6C7
020A6:  MOVFF  6A3,6C6
020AA:  CALL   0D12
020AE:  MOVFF  03,6B3
020B2:  MOVFF  02,6B2
020B6:  MOVFF  01,6B1
020BA:  MOVFF  00,6B0
020BE:  BCF    FD8.1
020C0:  MOVFF  03,6C4
020C4:  MOVFF  02,6C3
020C8:  MOVFF  01,6C2
020CC:  MOVFF  00,6C1
020D0:  MOVLW  33
020D2:  MOVLB  6
020D4:  MOVWF  xC8
020D6:  MOVLW  8C
020D8:  MOVWF  xC7
020DA:  MOVLW  1E
020DC:  MOVWF  xC6
020DE:  MOVLW  83
020E0:  MOVWF  xC5
020E2:  MOVLB  0
020E4:  CALL   0E08
020E8:  MOVFF  03,6AA
020EC:  MOVFF  02,6A9
020F0:  MOVFF  01,6A8
020F4:  MOVFF  00,6A7
.................... 
....................    r = qat[0]*y*y + qat[1];
020F8:  MOVLB  6
020FA:  CLRF   xC5
020FC:  CLRF   xC4
020FE:  CLRF   xC3
02100:  MOVLW  7F
02102:  MOVWF  xC2
02104:  MOVFF  6A6,6C9
02108:  MOVFF  6A5,6C8
0210C:  MOVFF  6A4,6C7
02110:  MOVFF  6A3,6C6
02114:  MOVLB  0
02116:  CALL   0D12
0211A:  MOVFF  03,6B3
0211E:  MOVFF  02,6B2
02122:  MOVFF  01,6B1
02126:  MOVFF  00,6B0
0212A:  MOVFF  03,6C5
0212E:  MOVFF  02,6C4
02132:  MOVFF  01,6C3
02136:  MOVFF  00,6C2
0213A:  MOVFF  6A6,6C9
0213E:  MOVFF  6A5,6C8
02142:  MOVFF  6A4,6C7
02146:  MOVFF  6A3,6C6
0214A:  CALL   0D12
0214E:  MOVFF  03,6B3
02152:  MOVFF  02,6B2
02156:  MOVFF  01,6B1
0215A:  MOVFF  00,6B0
0215E:  BCF    FD8.1
02160:  MOVFF  03,6C4
02164:  MOVFF  02,6C3
02168:  MOVFF  01,6C2
0216C:  MOVFF  00,6C1
02170:  MOVLW  1B
02172:  MOVLB  6
02174:  MOVWF  xC8
02176:  MOVLW  E4
02178:  MOVWF  xC7
0217A:  MOVLW  35
0217C:  MOVWF  xC6
0217E:  MOVLW  82
02180:  MOVWF  xC5
02182:  MOVLB  0
02184:  CALL   0E08
02188:  MOVFF  03,6AE
0218C:  MOVFF  02,6AD
02190:  MOVFF  01,6AC
02194:  MOVFF  00,6AB
....................    r = r*y*y + qat[2];
02198:  MOVFF  6AE,6C5
0219C:  MOVFF  6AD,6C4
021A0:  MOVFF  6AC,6C3
021A4:  MOVFF  6AB,6C2
021A8:  MOVFF  6A6,6C9
021AC:  MOVFF  6A5,6C8
021B0:  MOVFF  6A4,6C7
021B4:  MOVFF  6A3,6C6
021B8:  CALL   0D12
021BC:  MOVFF  03,6B3
021C0:  MOVFF  02,6B2
021C4:  MOVFF  01,6B1
021C8:  MOVFF  00,6B0
021CC:  MOVFF  03,6C5
021D0:  MOVFF  02,6C4
021D4:  MOVFF  01,6C3
021D8:  MOVFF  00,6C2
021DC:  MOVFF  6A6,6C9
021E0:  MOVFF  6A5,6C8
021E4:  MOVFF  6A4,6C7
021E8:  MOVFF  6A3,6C6
021EC:  CALL   0D12
021F0:  MOVFF  03,6B3
021F4:  MOVFF  02,6B2
021F8:  MOVFF  01,6B1
021FC:  MOVFF  00,6B0
02200:  BCF    FD8.1
02202:  MOVFF  03,6C4
02206:  MOVFF  02,6C3
0220A:  MOVFF  01,6C2
0220E:  MOVFF  00,6C1
02212:  MOVLW  A4
02214:  MOVLB  6
02216:  MOVWF  xC8
02218:  MOVLW  DB
0221A:  MOVWF  xC7
0221C:  MOVLW  67
0221E:  MOVWF  xC6
02220:  MOVLW  83
02222:  MOVWF  xC5
02224:  MOVLB  0
02226:  CALL   0E08
0222A:  MOVFF  03,6AE
0222E:  MOVFF  02,6AD
02232:  MOVFF  01,6AC
02236:  MOVFF  00,6AB
....................    r = r*y*y + qat[3];
0223A:  MOVFF  6AE,6C5
0223E:  MOVFF  6AD,6C4
02242:  MOVFF  6AC,6C3
02246:  MOVFF  6AB,6C2
0224A:  MOVFF  6A6,6C9
0224E:  MOVFF  6A5,6C8
02252:  MOVFF  6A4,6C7
02256:  MOVFF  6A3,6C6
0225A:  CALL   0D12
0225E:  MOVFF  03,6B3
02262:  MOVFF  02,6B2
02266:  MOVFF  01,6B1
0226A:  MOVFF  00,6B0
0226E:  MOVFF  03,6C5
02272:  MOVFF  02,6C4
02276:  MOVFF  01,6C3
0227A:  MOVFF  00,6C2
0227E:  MOVFF  6A6,6C9
02282:  MOVFF  6A5,6C8
02286:  MOVFF  6A4,6C7
0228A:  MOVFF  6A3,6C6
0228E:  CALL   0D12
02292:  MOVFF  03,6B3
02296:  MOVFF  02,6B2
0229A:  MOVFF  01,6B1
0229E:  MOVFF  00,6B0
022A2:  BCF    FD8.1
022A4:  MOVFF  03,6C4
022A8:  MOVFF  02,6C3
022AC:  MOVFF  01,6C2
022B0:  MOVFF  00,6C1
022B4:  MOVLW  33
022B6:  MOVLB  6
022B8:  MOVWF  xC8
022BA:  MOVLW  8C
022BC:  MOVWF  xC7
022BE:  MOVLW  1E
022C0:  MOVWF  xC6
022C2:  MOVLW  83
022C4:  MOVWF  xC5
022C6:  MOVLB  0
022C8:  CALL   0E08
022CC:  MOVFF  03,6AE
022D0:  MOVFF  02,6AD
022D4:  MOVFF  01,6AC
022D8:  MOVFF  00,6AB
.................... 
....................    res = y*res/r;
022DC:  MOVFF  6A6,6C5
022E0:  MOVFF  6A5,6C4
022E4:  MOVFF  6A4,6C3
022E8:  MOVFF  6A3,6C2
022EC:  MOVFF  6AA,6C9
022F0:  MOVFF  6A9,6C8
022F4:  MOVFF  6A8,6C7
022F8:  MOVFF  6A7,6C6
022FC:  CALL   0D12
02300:  MOVFF  03,6B3
02304:  MOVFF  02,6B2
02308:  MOVFF  01,6B1
0230C:  MOVFF  00,6B0
02310:  MOVFF  03,6B9
02314:  MOVFF  02,6B8
02318:  MOVFF  01,6B7
0231C:  MOVFF  00,6B6
02320:  MOVFF  6AE,6BD
02324:  MOVFF  6AD,6BC
02328:  MOVFF  6AC,6BB
0232C:  MOVFF  6AB,6BA
02330:  RCALL  1D18
02332:  MOVFF  03,6AA
02336:  MOVFF  02,6A9
0233A:  MOVFF  01,6A8
0233E:  MOVFF  00,6A7
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
02342:  MOVLB  6
02344:  BTFSS  xAF.1
02346:  BRA    2382
....................       res = PI_DIV_BY_TWO - res;
02348:  BSF    FD8.1
0234A:  MOVLW  DB
0234C:  MOVWF  xC4
0234E:  MOVLW  0F
02350:  MOVWF  xC3
02352:  MOVLW  49
02354:  MOVWF  xC2
02356:  MOVLW  7F
02358:  MOVWF  xC1
0235A:  MOVFF  6AA,6C8
0235E:  MOVFF  6A9,6C7
02362:  MOVFF  6A8,6C6
02366:  MOVFF  6A7,6C5
0236A:  MOVLB  0
0236C:  CALL   0E08
02370:  MOVFF  03,6AA
02374:  MOVFF  02,6A9
02378:  MOVFF  01,6A8
0237C:  MOVFF  00,6A7
02380:  MOVLB  6
....................    if (s)
02382:  BTFSS  xAF.0
02384:  BRA    238C
....................       res = -res;
02386:  MOVF   xA8,W
02388:  XORLW  80
0238A:  MOVWF  xA8
.................... 
....................    return(res);
0238C:  MOVFF  6A7,00
02390:  MOVFF  6A8,01
02394:  MOVFF  6A9,02
02398:  MOVFF  6AA,03
0239C:  MOVLB  0
0239E:  RETURN 0
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
023A0:  MOVLB  6
023A2:  BCF    x9D.0
....................    quad=0; //quadrant
023A4:  CLRF   x9E
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
023A6:  MOVFF  694,6C0
023AA:  MOVFF  693,6BF
023AE:  MOVFF  692,6BE
023B2:  MOVFF  691,6BD
023B6:  CLRF   xC4
023B8:  CLRF   xC3
023BA:  CLRF   xC2
023BC:  CLRF   xC1
023BE:  MOVLB  0
023C0:  RCALL  1C9E
023C2:  BC    23C6
023C4:  BNZ   23F0
023C6:  MOVFF  698,6C0
023CA:  MOVFF  697,6BF
023CE:  MOVFF  696,6BE
023D2:  MOVFF  695,6BD
023D6:  MOVLB  6
023D8:  CLRF   xC4
023DA:  CLRF   xC3
023DC:  CLRF   xC2
023DE:  CLRF   xC1
023E0:  MOVLB  0
023E2:  RCALL  1C9E
023E4:  BC    23E8
023E6:  BNZ   23EC
023E8:  MOVLW  03
023EA:  BRA    23EE
023EC:  MOVLW  04
023EE:  BRA    2416
023F0:  MOVFF  698,6C0
023F4:  MOVFF  697,6BF
023F8:  MOVFF  696,6BE
023FC:  MOVFF  695,6BD
02400:  MOVLB  6
02402:  CLRF   xC4
02404:  CLRF   xC3
02406:  CLRF   xC2
02408:  CLRF   xC1
0240A:  MOVLB  0
0240C:  RCALL  1C9E
0240E:  BNC   2414
02410:  MOVLW  02
02412:  BRA    2416
02414:  MOVLW  01
02416:  MOVLB  6
02418:  MOVWF  x9E
....................    if(y<0.0)
0241A:  MOVFF  694,6C0
0241E:  MOVFF  693,6BF
02422:  MOVFF  692,6BE
02426:  MOVFF  691,6BD
0242A:  CLRF   xC4
0242C:  CLRF   xC3
0242E:  CLRF   xC2
02430:  CLRF   xC1
02432:  MOVLB  0
02434:  RCALL  1C9E
02436:  BNC   2444
....................    {
....................       sign=1;
02438:  MOVLB  6
0243A:  BSF    x9D.0
....................       y=-y;
0243C:  MOVF   x92,W
0243E:  XORLW  80
02440:  MOVWF  x92
02442:  MOVLB  0
....................    }
....................    if(x<0.0)
02444:  MOVFF  698,6C0
02448:  MOVFF  697,6BF
0244C:  MOVFF  696,6BE
02450:  MOVFF  695,6BD
02454:  MOVLB  6
02456:  CLRF   xC4
02458:  CLRF   xC3
0245A:  CLRF   xC2
0245C:  CLRF   xC1
0245E:  MOVLB  0
02460:  RCALL  1C9E
02462:  BNC   246E
....................    {
....................       x=-x;
02464:  MOVLB  6
02466:  MOVF   x96,W
02468:  XORLW  80
0246A:  MOVWF  x96
0246C:  MOVLB  0
....................    }
....................    if (x==0.0)
0246E:  MOVFF  698,6C0
02472:  MOVFF  697,6BF
02476:  MOVFF  696,6BE
0247A:  MOVFF  695,6BD
0247E:  MOVLB  6
02480:  CLRF   xC4
02482:  CLRF   xC3
02484:  CLRF   xC2
02486:  CLRF   xC1
02488:  MOVLB  0
0248A:  RCALL  1C9E
0248C:  BNZ   24E2
....................    {
....................       if(y==0.0)
0248E:  MOVFF  694,6C0
02492:  MOVFF  693,6BF
02496:  MOVFF  692,6BE
0249A:  MOVFF  691,6BD
0249E:  MOVLB  6
024A0:  CLRF   xC4
024A2:  CLRF   xC3
024A4:  CLRF   xC2
024A6:  CLRF   xC1
024A8:  MOVLB  0
024AA:  CALL   1C9E
024AE:  BNZ   24B2
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
024B0:  BRA    24E0
....................       else
....................       {
....................          if(sign)
024B2:  MOVLB  6
024B4:  BTFSS  x9D.0
024B6:  BRA    24CC
....................          {
....................          return (-(PI_DIV_BY_TWO));
024B8:  MOVLW  7F
024BA:  MOVWF  00
024BC:  MOVLW  C9
024BE:  MOVWF  01
024C0:  MOVLW  0F
024C2:  MOVWF  02
024C4:  MOVLW  DB
024C6:  MOVWF  03
024C8:  BRA    261A
....................          }
024CA:  BRA    24DE
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
024CC:  MOVLW  7F
024CE:  MOVWF  00
024D0:  MOVLW  49
024D2:  MOVWF  01
024D4:  MOVLW  0F
024D6:  MOVWF  02
024D8:  MOVLW  DB
024DA:  MOVWF  03
024DC:  BRA    261A
024DE:  MOVLB  0
....................          }
....................       }
....................    }
024E0:  BRA    2618
....................    else
....................    {
....................       z=y/x;
024E2:  MOVFF  694,6B9
024E6:  MOVFF  693,6B8
024EA:  MOVFF  692,6B7
024EE:  MOVFF  691,6B6
024F2:  MOVFF  698,6BD
024F6:  MOVFF  697,6BC
024FA:  MOVFF  696,6BB
024FE:  MOVFF  695,6BA
02502:  RCALL  1D18
02504:  MOVFF  03,69C
02508:  MOVFF  02,69B
0250C:  MOVFF  01,69A
02510:  MOVFF  00,699
....................       switch(quad)
02514:  MOVLW  01
02516:  MOVLB  6
02518:  SUBWF  x9E,W
0251A:  ADDLW  FC
0251C:  BTFSC  FD8.0
0251E:  BRA    261A
02520:  ADDLW  04
02522:  MOVLB  0
02524:  GOTO   2620
....................       {
....................          case 1:
....................          {
....................             return atan(z);
02528:  MOVFF  69C,6A2
0252C:  MOVFF  69B,6A1
02530:  MOVFF  69A,6A0
02534:  MOVFF  699,69F
02538:  RCALL  1E76
0253A:  MOVLB  6
0253C:  BRA    261A
....................             break;
0253E:  BRA    261A
02540:  MOVLB  0
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
02542:  MOVFF  69C,6A2
02546:  MOVFF  69B,6A1
0254A:  MOVFF  69A,6A0
0254E:  MOVFF  699,69F
02552:  RCALL  1E76
02554:  MOVFF  FEA,6A0
02558:  MOVFF  FE9,69F
0255C:  BSF    FD8.1
0255E:  MOVLW  DB
02560:  MOVLB  6
02562:  MOVWF  xC4
02564:  MOVLW  0F
02566:  MOVWF  xC3
02568:  MOVLW  49
0256A:  MOVWF  xC2
0256C:  MOVLW  80
0256E:  MOVWF  xC1
02570:  MOVFF  03,6C8
02574:  MOVFF  02,6C7
02578:  MOVFF  01,6C6
0257C:  MOVFF  00,6C5
02580:  MOVLB  0
02582:  CALL   0E08
02586:  MOVFF  6A0,FEA
0258A:  MOVFF  69F,FE9
0258E:  MOVLB  6
02590:  BRA    261A
....................             break;
02592:  BRA    261A
02594:  MOVLB  0
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
02596:  MOVFF  69C,6A2
0259A:  MOVFF  69B,6A1
0259E:  MOVFF  69A,6A0
025A2:  MOVFF  699,69F
025A6:  RCALL  1E76
025A8:  MOVFF  03,6A2
025AC:  MOVFF  02,6A1
025B0:  MOVFF  01,6A0
025B4:  MOVFF  00,69F
025B8:  MOVFF  FEA,6A4
025BC:  MOVFF  FE9,6A3
025C0:  BSF    FD8.1
025C2:  MOVFF  03,6C4
025C6:  MOVFF  02,6C3
025CA:  MOVFF  01,6C2
025CE:  MOVFF  00,6C1
025D2:  MOVLW  DB
025D4:  MOVLB  6
025D6:  MOVWF  xC8
025D8:  MOVLW  0F
025DA:  MOVWF  xC7
025DC:  MOVLW  49
025DE:  MOVWF  xC6
025E0:  MOVLW  80
025E2:  MOVWF  xC5
025E4:  MOVLB  0
025E6:  CALL   0E08
025EA:  MOVFF  6A4,FEA
025EE:  MOVFF  6A3,FE9
025F2:  MOVLB  6
025F4:  BRA    261A
....................             break;
025F6:  BRA    261A
025F8:  MOVLB  0
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
025FA:  MOVFF  69C,6A2
025FE:  MOVFF  69B,6A1
02602:  MOVFF  69A,6A0
02606:  MOVFF  699,69F
0260A:  RCALL  1E76
0260C:  MOVLW  80
0260E:  XORWF  01,F
02610:  MOVLB  6
02612:  BRA    261A
....................             break;
02614:  BRA    261A
02616:  MOVLB  0
02618:  MOVLB  6
....................          }
....................       }
....................    }
0261A:  MOVLB  0
0261C:  GOTO   3D26 (RETURN)
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... #define sensorSampleRate 50 // 50mS delay between each sensor sample = 100ms cadence 
.................... 
.................... #define maxCount 16777216.0   // ADC max count
.................... #define vRef 2.048            // ADC vRef
.................... 
.................... #define sc sensorCal
.................... 
.................... #define vMonN15   6
.................... #define vMon200   16
.................... #define vMon5V6   24
.................... #define vMon5VA   25
.................... #define vMon3V6X  17
.................... #define vMon3V3A  27
.................... #define vMon3V3D  26
.................... 
.................... #define BUFFER_SIZE 5
.................... 
.................... signed int32 sQ_x[BUFFER_SIZE];
.................... signed int32 cQ_x[BUFFER_SIZE];
.................... signed int32 sQ_y[BUFFER_SIZE];
.................... signed int32 cQ_y[BUFFER_SIZE];
.................... int sIn_x=0;
.................... int cIn_x=0;
.................... int sIn_y=0;
.................... int cIn_y=0;
.................... 
.................... struct sensorMonitorData
.................... {
....................    boolean dataReady;
....................    boolean adcBusy;
....................    signed int32 avgSin;
....................    signed int32 avgCos;
.................... } smData[2] = 
.................... {
....................    {false, false, 0, 0},
....................    {false, false, 0, 0}
.................... };
.................... 
.................... void push(signed int32* buff, int* idx, signed int32 newData) {
....................    buff[*idx]=newData;
*
00878:  MOVFF  6A7,FEA
0087C:  MOVLB  6
0087E:  MOVFF  6A6,FE9
00882:  CLRF   xB4
00884:  MOVFF  FEF,6B3
00888:  CLRF   xB6
0088A:  MOVLW  04
0088C:  MOVWF  xB5
0088E:  MOVLB  0
00890:  RCALL  082A
00892:  MOVF   01,W
00894:  MOVLB  6
00896:  ADDWF  xA4,W
00898:  MOVWF  FE9
0089A:  MOVF   xA5,W
0089C:  ADDWFC 02,W
0089E:  MOVWF  FEA
008A0:  MOVFF  6A8,FEF
008A4:  MOVFF  6A9,FEC
008A8:  MOVFF  6AA,FEC
008AC:  MOVFF  6AB,FEC
....................    *idx=(*idx+1) % BUFFER_SIZE;
008B0:  MOVFF  6A7,6AD
008B4:  MOVFF  6A7,FEA
008B8:  MOVFF  6A6,FE9
008BC:  MOVLW  01
008BE:  ADDWF  FEF,W
008C0:  MOVWF  xAF
008C2:  MOVWF  xB0
008C4:  MOVLW  05
008C6:  MOVWF  xB1
008C8:  MOVLB  0
008CA:  RCALL  084C
008CC:  MOVLB  6
008CE:  MOVFF  6AD,FEA
008D2:  MOVFF  6A6,FE9
008D6:  MOVFF  00,FEF
008DA:  MOVLB  0
008DC:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INTERNAL MONITOR task - gets voltages                                     */
.................... /* gets one value each time the task is run                                  */
.................... /*****************************************************************************/
.................... void internal_monitor_task(){
....................    static int8 state = 0;
....................    if (adc_done()){
*
01080:  MOVLB  F
01082:  BTFSC  x5B.0
01084:  BRA    15D0
....................       switch (state)
01086:  MOVLB  1
01088:  MOVF   xCC,W
0108A:  ADDLW  F9
0108C:  BTFSC  FD8.0
0108E:  BRA    15CE
01090:  ADDLW  07
01092:  MOVLB  0
01094:  GOTO   15D6
....................       {
....................          case 0:     // vMonN15
....................             monitorVals.vN15 = read_adc(ADC_READ_ONLY) * monCal.vN15[1] + monCal.vN15[0];
01098:  MOVLB  F
0109A:  BTFSC  x5B.0
0109C:  BRA    109A
0109E:  MOVFF  F5F,02
010A2:  MOVFF  F5E,01
010A6:  MOVFF  02,673
010AA:  MOVFF  01,672
010AE:  MOVFF  02,6C2
010B2:  MOVFF  01,6C1
010B6:  MOVLB  0
010B8:  RCALL  0CDC
010BA:  MOVFF  03,6C5
010BE:  MOVFF  02,6C4
010C2:  MOVFF  01,6C3
010C6:  MOVFF  00,6C2
010CA:  MOVFF  B9,6C9
010CE:  MOVFF  B8,6C8
010D2:  MOVFF  B7,6C7
010D6:  MOVFF  B6,6C6
010DA:  RCALL  0D12
010DC:  MOVFF  03,675
010E0:  MOVFF  02,674
010E4:  MOVFF  01,673
010E8:  MOVFF  00,672
010EC:  BCF    FD8.1
010EE:  MOVFF  03,6C4
010F2:  MOVFF  02,6C3
010F6:  MOVFF  01,6C2
010FA:  MOVFF  00,6C1
010FE:  MOVFF  B5,6C8
01102:  MOVFF  B4,6C7
01106:  MOVFF  B3,6C6
0110A:  MOVFF  B2,6C5
0110E:  RCALL  0E08
01110:  MOVFF  03,EE
01114:  MOVFF  02,ED
01118:  MOVFF  01,EC
0111C:  MOVFF  00,EB
....................             set_adc_channel(vMon200);
01120:  MOVLB  F
01122:  MOVF   x5A,W
01124:  ANDLW  3F
01126:  MOVWF  01
01128:  MOVLW  10
0112A:  MOVWF  x5A
0112C:  BTFSS  x5B.7
0112E:  BRA    113E
01130:  MOVF   01,W
01132:  SUBLW  10
01134:  BZ    113E
01136:  BSF    x5B.0
01138:  NOP   
0113A:  BTFSC  x5B.0
0113C:  BRA    113A
....................             delay_ms(10);
0113E:  MOVLW  0A
01140:  MOVLB  6
01142:  MOVWF  x78
01144:  MOVLB  0
01146:  CALL   03EE
....................             read_adc(ADC_START_ONLY);
0114A:  MOVLB  F
0114C:  BSF    x5B.0
0114E:  NOP   
....................             state = 1;
01150:  MOVLW  01
01152:  MOVLB  1
01154:  MOVWF  xCC
....................          break;
01156:  BRA    15CE
....................          
....................          case 1:     // vMon200
....................             monitorVals.v200 = read_adc(ADC_READ_ONLY) * monCal.v200[1] + monCal.v200[0];
01158:  MOVLB  F
0115A:  BTFSC  x5B.0
0115C:  BRA    115A
0115E:  MOVFF  F5F,02
01162:  MOVFF  F5E,01
01166:  MOVFF  02,673
0116A:  MOVFF  01,672
0116E:  MOVFF  02,6C2
01172:  MOVFF  01,6C1
01176:  MOVLB  0
01178:  RCALL  0CDC
0117A:  MOVFF  03,6C5
0117E:  MOVFF  02,6C4
01182:  MOVFF  01,6C3
01186:  MOVFF  00,6C2
0118A:  MOVFF  C1,6C9
0118E:  MOVFF  C0,6C8
01192:  MOVFF  BF,6C7
01196:  MOVFF  BE,6C6
0119A:  RCALL  0D12
0119C:  MOVFF  03,675
011A0:  MOVFF  02,674
011A4:  MOVFF  01,673
011A8:  MOVFF  00,672
011AC:  BCF    FD8.1
011AE:  MOVFF  03,6C4
011B2:  MOVFF  02,6C3
011B6:  MOVFF  01,6C2
011BA:  MOVFF  00,6C1
011BE:  MOVFF  BD,6C8
011C2:  MOVFF  BC,6C7
011C6:  MOVFF  BB,6C6
011CA:  MOVFF  BA,6C5
011CE:  RCALL  0E08
011D0:  MOVFF  03,F2
011D4:  MOVFF  02,F1
011D8:  MOVFF  01,F0
011DC:  MOVFF  00,EF
....................             set_adc_channel(vMon5V6);
011E0:  MOVLB  F
011E2:  MOVF   x5A,W
011E4:  ANDLW  3F
011E6:  MOVWF  01
011E8:  MOVLW  18
011EA:  MOVWF  x5A
011EC:  BTFSS  x5B.7
011EE:  BRA    11FE
011F0:  MOVF   01,W
011F2:  SUBLW  18
011F4:  BZ    11FE
011F6:  BSF    x5B.0
011F8:  NOP   
011FA:  BTFSC  x5B.0
011FC:  BRA    11FA
....................             delay_ms(10);
011FE:  MOVLW  0A
01200:  MOVLB  6
01202:  MOVWF  x78
01204:  MOVLB  0
01206:  CALL   03EE
....................             read_adc(ADC_START_ONLY);
0120A:  MOVLB  F
0120C:  BSF    x5B.0
0120E:  NOP   
....................             state = 2;
01210:  MOVLW  02
01212:  MOVLB  1
01214:  MOVWF  xCC
....................          break;
01216:  BRA    15CE
....................          
....................          case 2:     // vMon5V6
....................             monitorVals.v5V6 = read_adc(ADC_READ_ONLY) * monCal.v5V6[1] + monCal.v5V6[0];
01218:  MOVLB  F
0121A:  BTFSC  x5B.0
0121C:  BRA    121A
0121E:  MOVFF  F5F,02
01222:  MOVFF  F5E,01
01226:  MOVFF  02,673
0122A:  MOVFF  01,672
0122E:  MOVFF  02,6C2
01232:  MOVFF  01,6C1
01236:  MOVLB  0
01238:  RCALL  0CDC
0123A:  MOVFF  03,6C5
0123E:  MOVFF  02,6C4
01242:  MOVFF  01,6C3
01246:  MOVFF  00,6C2
0124A:  MOVFF  C9,6C9
0124E:  MOVFF  C8,6C8
01252:  MOVFF  C7,6C7
01256:  MOVFF  C6,6C6
0125A:  RCALL  0D12
0125C:  MOVFF  03,675
01260:  MOVFF  02,674
01264:  MOVFF  01,673
01268:  MOVFF  00,672
0126C:  BCF    FD8.1
0126E:  MOVFF  03,6C4
01272:  MOVFF  02,6C3
01276:  MOVFF  01,6C2
0127A:  MOVFF  00,6C1
0127E:  MOVFF  C5,6C8
01282:  MOVFF  C4,6C7
01286:  MOVFF  C3,6C6
0128A:  MOVFF  C2,6C5
0128E:  RCALL  0E08
01290:  MOVFF  03,F6
01294:  MOVFF  02,F5
01298:  MOVFF  01,F4
0129C:  MOVFF  00,F3
....................             set_adc_channel(vMon5VA);
012A0:  MOVLB  F
012A2:  MOVF   x5A,W
012A4:  ANDLW  3F
012A6:  MOVWF  01
012A8:  MOVLW  19
012AA:  MOVWF  x5A
012AC:  BTFSS  x5B.7
012AE:  BRA    12BE
012B0:  MOVF   01,W
012B2:  SUBLW  19
012B4:  BZ    12BE
012B6:  BSF    x5B.0
012B8:  NOP   
012BA:  BTFSC  x5B.0
012BC:  BRA    12BA
....................             delay_ms(10);
012BE:  MOVLW  0A
012C0:  MOVLB  6
012C2:  MOVWF  x78
012C4:  MOVLB  0
012C6:  CALL   03EE
....................             read_adc(ADC_START_ONLY);
012CA:  MOVLB  F
012CC:  BSF    x5B.0
012CE:  NOP   
....................             state = 3;
012D0:  MOVLW  03
012D2:  MOVLB  1
012D4:  MOVWF  xCC
....................          break;
012D6:  BRA    15CE
....................          
....................          case 3:     // vMon5VA
....................             monitorVals.v5VA = read_adc(ADC_READ_ONLY) * monCal.v5VA[1] + monCal.v5VA[0];
012D8:  MOVLB  F
012DA:  BTFSC  x5B.0
012DC:  BRA    12DA
012DE:  MOVFF  F5F,02
012E2:  MOVFF  F5E,01
012E6:  MOVFF  02,673
012EA:  MOVFF  01,672
012EE:  MOVFF  02,6C2
012F2:  MOVFF  01,6C1
012F6:  MOVLB  0
012F8:  RCALL  0CDC
012FA:  MOVFF  03,6C5
012FE:  MOVFF  02,6C4
01302:  MOVFF  01,6C3
01306:  MOVFF  00,6C2
0130A:  MOVFF  D1,6C9
0130E:  MOVFF  D0,6C8
01312:  MOVFF  CF,6C7
01316:  MOVFF  CE,6C6
0131A:  RCALL  0D12
0131C:  MOVFF  03,675
01320:  MOVFF  02,674
01324:  MOVFF  01,673
01328:  MOVFF  00,672
0132C:  BCF    FD8.1
0132E:  MOVFF  03,6C4
01332:  MOVFF  02,6C3
01336:  MOVFF  01,6C2
0133A:  MOVFF  00,6C1
0133E:  MOVFF  CD,6C8
01342:  MOVFF  CC,6C7
01346:  MOVFF  CB,6C6
0134A:  MOVFF  CA,6C5
0134E:  RCALL  0E08
01350:  MOVFF  03,FA
01354:  MOVFF  02,F9
01358:  MOVFF  01,F8
0135C:  MOVFF  00,F7
....................             set_adc_channel(vMon3V6X);
01360:  MOVLB  F
01362:  MOVF   x5A,W
01364:  ANDLW  3F
01366:  MOVWF  01
01368:  MOVLW  11
0136A:  MOVWF  x5A
0136C:  BTFSS  x5B.7
0136E:  BRA    137E
01370:  MOVF   01,W
01372:  SUBLW  11
01374:  BZ    137E
01376:  BSF    x5B.0
01378:  NOP   
0137A:  BTFSC  x5B.0
0137C:  BRA    137A
....................             delay_ms(10);
0137E:  MOVLW  0A
01380:  MOVLB  6
01382:  MOVWF  x78
01384:  MOVLB  0
01386:  CALL   03EE
....................             read_adc(ADC_START_ONLY);
0138A:  MOVLB  F
0138C:  BSF    x5B.0
0138E:  NOP   
....................             state = 4;
01390:  MOVLW  04
01392:  MOVLB  1
01394:  MOVWF  xCC
....................          break;
01396:  BRA    15CE
....................          
....................          case 4:     // vMon3V6X
....................             monitorVals.v3V6X = read_adc(ADC_READ_ONLY) * monCal.v3V6X[1] + monCal.v3V6X[0];
01398:  MOVLB  F
0139A:  BTFSC  x5B.0
0139C:  BRA    139A
0139E:  MOVFF  F5F,02
013A2:  MOVFF  F5E,01
013A6:  MOVFF  02,673
013AA:  MOVFF  01,672
013AE:  MOVFF  02,6C2
013B2:  MOVFF  01,6C1
013B6:  MOVLB  0
013B8:  RCALL  0CDC
013BA:  MOVFF  03,6C5
013BE:  MOVFF  02,6C4
013C2:  MOVFF  01,6C3
013C6:  MOVFF  00,6C2
013CA:  MOVFF  D9,6C9
013CE:  MOVFF  D8,6C8
013D2:  MOVFF  D7,6C7
013D6:  MOVFF  D6,6C6
013DA:  RCALL  0D12
013DC:  MOVFF  03,675
013E0:  MOVFF  02,674
013E4:  MOVFF  01,673
013E8:  MOVFF  00,672
013EC:  BCF    FD8.1
013EE:  MOVFF  03,6C4
013F2:  MOVFF  02,6C3
013F6:  MOVFF  01,6C2
013FA:  MOVFF  00,6C1
013FE:  MOVFF  D5,6C8
01402:  MOVFF  D4,6C7
01406:  MOVFF  D3,6C6
0140A:  MOVFF  D2,6C5
0140E:  RCALL  0E08
01410:  MOVFF  03,FE
01414:  MOVFF  02,FD
01418:  MOVFF  01,FC
0141C:  MOVFF  00,FB
....................             set_adc_channel(vMon3V3A);
01420:  MOVLB  F
01422:  MOVF   x5A,W
01424:  ANDLW  3F
01426:  MOVWF  01
01428:  MOVLW  1B
0142A:  MOVWF  x5A
0142C:  BTFSS  x5B.7
0142E:  BRA    143E
01430:  MOVF   01,W
01432:  SUBLW  1B
01434:  BZ    143E
01436:  BSF    x5B.0
01438:  NOP   
0143A:  BTFSC  x5B.0
0143C:  BRA    143A
....................             delay_ms(10);
0143E:  MOVLW  0A
01440:  MOVLB  6
01442:  MOVWF  x78
01444:  MOVLB  0
01446:  CALL   03EE
....................             read_adc(ADC_START_ONLY);
0144A:  MOVLB  F
0144C:  BSF    x5B.0
0144E:  NOP   
....................             state = 5;
01450:  MOVLW  05
01452:  MOVLB  1
01454:  MOVWF  xCC
....................          break;
01456:  BRA    15CE
....................          
....................          case 5:     // vMon3V3A
....................             monitorVals.v3V3A = read_adc(ADC_READ_ONLY) * monCal.v3V3A[1] + monCal.v3V3A[0];
01458:  MOVLB  F
0145A:  BTFSC  x5B.0
0145C:  BRA    145A
0145E:  MOVFF  F5F,02
01462:  MOVFF  F5E,01
01466:  MOVFF  02,673
0146A:  MOVFF  01,672
0146E:  MOVFF  02,6C2
01472:  MOVFF  01,6C1
01476:  MOVLB  0
01478:  RCALL  0CDC
0147A:  MOVFF  03,6C5
0147E:  MOVFF  02,6C4
01482:  MOVFF  01,6C3
01486:  MOVFF  00,6C2
0148A:  MOVFF  E1,6C9
0148E:  MOVFF  E0,6C8
01492:  MOVFF  DF,6C7
01496:  MOVFF  DE,6C6
0149A:  RCALL  0D12
0149C:  MOVFF  03,675
014A0:  MOVFF  02,674
014A4:  MOVFF  01,673
014A8:  MOVFF  00,672
014AC:  BCF    FD8.1
014AE:  MOVFF  03,6C4
014B2:  MOVFF  02,6C3
014B6:  MOVFF  01,6C2
014BA:  MOVFF  00,6C1
014BE:  MOVFF  DD,6C8
014C2:  MOVFF  DC,6C7
014C6:  MOVFF  DB,6C6
014CA:  MOVFF  DA,6C5
014CE:  RCALL  0E08
014D0:  MOVFF  03,102
014D4:  MOVFF  02,101
014D8:  MOVFF  01,100
014DC:  MOVFF  00,FF
....................             set_adc_channel(vMon3V3D);
014E0:  MOVLB  F
014E2:  MOVF   x5A,W
014E4:  ANDLW  3F
014E6:  MOVWF  01
014E8:  MOVLW  1A
014EA:  MOVWF  x5A
014EC:  BTFSS  x5B.7
014EE:  BRA    14FE
014F0:  MOVF   01,W
014F2:  SUBLW  1A
014F4:  BZ    14FE
014F6:  BSF    x5B.0
014F8:  NOP   
014FA:  BTFSC  x5B.0
014FC:  BRA    14FA
....................             delay_ms(10);
014FE:  MOVLW  0A
01500:  MOVLB  6
01502:  MOVWF  x78
01504:  MOVLB  0
01506:  CALL   03EE
....................             read_adc(ADC_START_ONLY);
0150A:  MOVLB  F
0150C:  BSF    x5B.0
0150E:  NOP   
....................             state = 6;
01510:  MOVLW  06
01512:  MOVLB  1
01514:  MOVWF  xCC
....................          break;
01516:  BRA    15CE
....................          
....................          case 6:    // vMon3V3D
....................             monitorVals.v3V3D = read_adc(ADC_READ_ONLY) * monCal.v3V3D[1] + monCal.v3V3D[0];
01518:  MOVLB  F
0151A:  BTFSC  x5B.0
0151C:  BRA    151A
0151E:  MOVFF  F5F,02
01522:  MOVFF  F5E,01
01526:  MOVFF  02,673
0152A:  MOVFF  01,672
0152E:  MOVFF  02,6C2
01532:  MOVFF  01,6C1
01536:  MOVLB  0
01538:  CALL   0CDC
0153C:  MOVFF  03,6C5
01540:  MOVFF  02,6C4
01544:  MOVFF  01,6C3
01548:  MOVFF  00,6C2
0154C:  MOVFF  E9,6C9
01550:  MOVFF  E8,6C8
01554:  MOVFF  E7,6C7
01558:  MOVFF  E6,6C6
0155C:  CALL   0D12
01560:  MOVFF  03,675
01564:  MOVFF  02,674
01568:  MOVFF  01,673
0156C:  MOVFF  00,672
01570:  BCF    FD8.1
01572:  MOVFF  03,6C4
01576:  MOVFF  02,6C3
0157A:  MOVFF  01,6C2
0157E:  MOVFF  00,6C1
01582:  MOVFF  E5,6C8
01586:  MOVFF  E4,6C7
0158A:  MOVFF  E3,6C6
0158E:  MOVFF  E2,6C5
01592:  RCALL  0E08
01594:  MOVFF  03,106
01598:  MOVFF  02,105
0159C:  MOVFF  01,104
015A0:  MOVFF  00,103
....................             set_adc_channel(vMonN15);
015A4:  MOVLB  F
015A6:  MOVF   x5A,W
015A8:  ANDLW  3F
015AA:  MOVWF  01
015AC:  MOVLW  06
015AE:  MOVWF  x5A
015B0:  BTFSS  x5B.7
015B2:  BRA    15C2
015B4:  MOVF   01,W
015B6:  SUBLW  06
015B8:  BZ    15C2
015BA:  BSF    x5B.0
015BC:  NOP   
015BE:  BTFSC  x5B.0
015C0:  BRA    15BE
....................             read_adc(ADC_START_ONLY);
015C2:  BSF    x5B.0
015C4:  NOP   
....................             state = 0;
015C6:  MOVLB  1
015C8:  CLRF   xCC
....................          break;   
015CA:  BRA    15CE
015CC:  MOVLB  1
015CE:  MOVLB  F
....................       }
....................    }
015D0:  MOVLB  0
015D2:  GOTO   A2C8 (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* PROCESS ADC SENSOR DATA                                                   */
.................... /*****************************************************************************/
.................... void sensor_process_data(int8 ch){
....................    adcVals[ch].sinLast = adcVals[ch].sinCounts;
*
0367E:  MOVLB  6
03680:  MOVF   x7A,W
03682:  MULLW  21
03684:  MOVF   FF3,W
03686:  CLRF   x84
03688:  MOVWF  x83
0368A:  MOVLW  10
0368C:  ADDWF  x83,W
0368E:  MOVWF  01
03690:  MOVLW  00
03692:  ADDWFC x84,W
03694:  MOVWF  03
03696:  MOVF   01,W
03698:  ADDLW  07
0369A:  MOVWF  01
0369C:  MOVLW  01
0369E:  ADDWFC 03,F
036A0:  MOVFF  01,683
036A4:  MOVFF  03,684
036A8:  MOVF   x7A,W
036AA:  MULLW  21
036AC:  MOVF   FF3,W
036AE:  CLRF   x86
036B0:  MOVWF  x85
036B2:  MOVLW  08
036B4:  ADDWF  x85,W
036B6:  MOVWF  01
036B8:  MOVLW  00
036BA:  ADDWFC x86,W
036BC:  MOVWF  03
036BE:  MOVF   01,W
036C0:  ADDLW  07
036C2:  MOVWF  FE9
036C4:  MOVLW  01
036C6:  ADDWFC 03,W
036C8:  MOVWF  FEA
036CA:  MOVFF  FEF,00
036CE:  MOVFF  FEC,01
036D2:  MOVFF  FEC,02
036D6:  MOVFF  FEC,03
036DA:  MOVFF  684,FEA
036DE:  MOVFF  683,FE9
036E2:  MOVFF  00,FEF
036E6:  MOVFF  01,FEC
036EA:  MOVFF  02,FEC
036EE:  MOVFF  03,FEC
....................    adcVals[ch].cosLast = adcVals[ch].cosCounts;
036F2:  MOVF   x7A,W
036F4:  MULLW  21
036F6:  MOVF   FF3,W
036F8:  CLRF   x84
036FA:  MOVWF  x83
036FC:  MOVLW  14
036FE:  ADDWF  x83,W
03700:  MOVWF  01
03702:  MOVLW  00
03704:  ADDWFC x84,W
03706:  MOVWF  03
03708:  MOVF   01,W
0370A:  ADDLW  07
0370C:  MOVWF  01
0370E:  MOVLW  01
03710:  ADDWFC 03,F
03712:  MOVFF  01,683
03716:  MOVFF  03,684
0371A:  MOVF   x7A,W
0371C:  MULLW  21
0371E:  MOVF   FF3,W
03720:  CLRF   x86
03722:  MOVWF  x85
03724:  MOVLW  0C
03726:  ADDWF  x85,W
03728:  MOVWF  01
0372A:  MOVLW  00
0372C:  ADDWFC x86,W
0372E:  MOVWF  03
03730:  MOVF   01,W
03732:  ADDLW  07
03734:  MOVWF  FE9
03736:  MOVLW  01
03738:  ADDWFC 03,W
0373A:  MOVWF  FEA
0373C:  MOVFF  FEF,00
03740:  MOVFF  FEC,01
03744:  MOVFF  FEC,02
03748:  MOVFF  FEC,03
0374C:  MOVFF  684,FEA
03750:  MOVFF  683,FE9
03754:  MOVFF  00,FEF
03758:  MOVFF  01,FEC
0375C:  MOVFF  02,FEC
03760:  MOVFF  03,FEC
....................    
....................    adcVals[ch].sinRaw = (float)smData[ch].avgSin;
03764:  MOVF   x7A,W
03766:  MULLW  21
03768:  MOVF   FF3,W
0376A:  CLRF   x84
0376C:  MOVWF  x83
0376E:  MOVLW  07
03770:  ADDWF  x83,W
03772:  MOVWF  01
03774:  MOVLW  01
03776:  ADDWFC x84,W
03778:  MOVWF  03
0377A:  MOVFF  01,685
0377E:  MOVWF  x86
03780:  MOVF   x7A,W
03782:  MULLW  09
03784:  MOVF   FF3,W
03786:  CLRF   x88
03788:  MOVWF  x87
0378A:  MOVLW  01
0378C:  ADDWF  x87,W
0378E:  MOVWF  01
03790:  MOVLW  00
03792:  ADDWFC x88,W
03794:  MOVWF  03
03796:  MOVF   01,W
03798:  ADDLW  BA
0379A:  MOVWF  FE9
0379C:  MOVLW  01
0379E:  ADDWFC 03,W
037A0:  MOVWF  FEA
037A2:  MOVFF  FEF,687
037A6:  MOVFF  FEC,01
037AA:  MOVFF  FEC,02
037AE:  MOVFF  FEC,03
037B2:  MOVFF  03,68A
037B6:  MOVFF  02,689
037BA:  MOVFF  01,688
037BE:  MOVLB  0
037C0:  CALL   1C44
037C4:  MOVFF  686,FEA
037C8:  MOVFF  685,FE9
037CC:  MOVFF  00,FEF
037D0:  MOVFF  01,FEC
037D4:  MOVFF  02,FEC
037D8:  MOVFF  03,FEC
....................    adcVals[ch].cosRaw = (float)smData[ch].avgCos;
037DC:  MOVLB  6
037DE:  MOVF   x7A,W
037E0:  MULLW  21
037E2:  MOVF   FF3,W
037E4:  CLRF   x84
037E6:  MOVWF  x83
037E8:  MOVLW  04
037EA:  ADDWF  x83,W
037EC:  MOVWF  01
037EE:  MOVLW  00
037F0:  ADDWFC x84,W
037F2:  MOVWF  03
037F4:  MOVF   01,W
037F6:  ADDLW  07
037F8:  MOVWF  01
037FA:  MOVLW  01
037FC:  ADDWFC 03,F
037FE:  MOVFF  01,683
03802:  MOVFF  03,684
03806:  MOVF   x7A,W
03808:  MULLW  09
0380A:  MOVF   FF3,W
0380C:  CLRF   x86
0380E:  MOVWF  x85
03810:  MOVLW  05
03812:  ADDWF  x85,W
03814:  MOVWF  01
03816:  MOVLW  00
03818:  ADDWFC x86,W
0381A:  MOVWF  03
0381C:  MOVF   01,W
0381E:  ADDLW  BA
03820:  MOVWF  FE9
03822:  MOVLW  01
03824:  ADDWFC 03,W
03826:  MOVWF  FEA
03828:  MOVFF  FEF,687
0382C:  MOVFF  FEC,01
03830:  MOVFF  FEC,02
03834:  MOVFF  FEC,03
03838:  MOVFF  03,68A
0383C:  MOVFF  02,689
03840:  MOVFF  01,688
03844:  MOVLB  0
03846:  CALL   1C44
0384A:  MOVFF  684,FEA
0384E:  MOVFF  683,FE9
03852:  MOVFF  00,FEF
03856:  MOVFF  01,FEC
0385A:  MOVFF  02,FEC
0385E:  MOVFF  03,FEC
....................    
....................    adcVals[ch].sinCounts = adcVals[ch].sinRaw * adcCal[ch].sinGain + adcCal[ch].sinOS;
03862:  MOVLB  6
03864:  MOVF   x7A,W
03866:  MULLW  21
03868:  MOVF   FF3,W
0386A:  CLRF   x84
0386C:  MOVWF  x83
0386E:  MOVLW  08
03870:  ADDWF  x83,W
03872:  MOVWF  01
03874:  MOVLW  00
03876:  ADDWFC x84,W
03878:  MOVWF  03
0387A:  MOVF   01,W
0387C:  ADDLW  07
0387E:  MOVWF  01
03880:  MOVLW  01
03882:  ADDWFC 03,F
03884:  MOVFF  01,683
03888:  MOVFF  03,684
0388C:  MOVF   x7A,W
0388E:  MULLW  21
03890:  MOVF   FF3,W
03892:  CLRF   x86
03894:  MOVWF  x85
03896:  MOVLW  07
03898:  ADDWF  x85,W
0389A:  MOVWF  FE9
0389C:  MOVLW  01
0389E:  ADDWFC x86,W
038A0:  MOVWF  FEA
038A2:  MOVFF  FEF,6C2
038A6:  MOVFF  FEC,6C3
038AA:  MOVFF  FEC,6C4
038AE:  MOVFF  FEC,6C5
038B2:  MOVF   x7A,W
038B4:  MULLW  10
038B6:  MOVF   FF3,W
038B8:  CLRF   x8C
038BA:  MOVWF  x8B
038BC:  MOVLW  08
038BE:  ADDWF  x8B,W
038C0:  MOVWF  01
038C2:  MOVLW  00
038C4:  ADDWFC x8C,W
038C6:  MOVWF  03
038C8:  MOVF   01,W
038CA:  ADDLW  62
038CC:  MOVWF  FE9
038CE:  MOVLW  00
038D0:  ADDWFC 03,W
038D2:  MOVWF  FEA
038D4:  MOVFF  FEF,6C6
038D8:  MOVFF  FEC,01
038DC:  MOVFF  FEC,02
038E0:  MOVFF  FEC,03
038E4:  MOVFF  03,6C9
038E8:  MOVFF  02,6C8
038EC:  MOVFF  01,6C7
038F0:  MOVLB  0
038F2:  CALL   0D12
038F6:  MOVFF  03,6C4
038FA:  MOVFF  02,6C3
038FE:  MOVFF  01,6C2
03902:  MOVFF  00,6C1
03906:  MOVLB  6
03908:  MOVF   x7A,W
0390A:  MULLW  10
0390C:  MOVF   FF3,W
0390E:  CLRF   x8C
03910:  MOVWF  x8B
03912:  MOVLW  62
03914:  ADDWF  x8B,W
03916:  MOVWF  FE9
03918:  MOVLW  00
0391A:  ADDWFC x8C,W
0391C:  MOVWF  FEA
0391E:  MOVFF  FEF,6C5
03922:  MOVFF  FEC,01
03926:  MOVFF  FEC,02
0392A:  MOVFF  FEC,03
0392E:  BCF    FD8.1
03930:  MOVFF  03,6C8
03934:  MOVFF  02,6C7
03938:  MOVFF  01,6C6
0393C:  MOVLB  0
0393E:  CALL   0E08
03942:  MOVFF  684,FEA
03946:  MOVFF  683,FE9
0394A:  MOVFF  00,FEF
0394E:  MOVFF  01,FEC
03952:  MOVFF  02,FEC
03956:  MOVFF  03,FEC
....................    adcVals[ch].cosCounts = adcVals[ch].cosRaw * adcCal[ch].cosGain + adcCal[ch].cosOS;
0395A:  MOVLB  6
0395C:  MOVF   x7A,W
0395E:  MULLW  21
03960:  MOVF   FF3,W
03962:  CLRF   x84
03964:  MOVWF  x83
03966:  MOVLW  0C
03968:  ADDWF  x83,W
0396A:  MOVWF  01
0396C:  MOVLW  00
0396E:  ADDWFC x84,W
03970:  MOVWF  03
03972:  MOVF   01,W
03974:  ADDLW  07
03976:  MOVWF  01
03978:  MOVLW  01
0397A:  ADDWFC 03,F
0397C:  MOVFF  01,683
03980:  MOVFF  03,684
03984:  MOVF   x7A,W
03986:  MULLW  21
03988:  MOVF   FF3,W
0398A:  CLRF   x86
0398C:  MOVWF  x85
0398E:  MOVLW  04
03990:  ADDWF  x85,W
03992:  MOVWF  01
03994:  MOVLW  00
03996:  ADDWFC x86,W
03998:  MOVWF  03
0399A:  MOVF   01,W
0399C:  ADDLW  07
0399E:  MOVWF  FE9
039A0:  MOVLW  01
039A2:  ADDWFC 03,W
039A4:  MOVWF  FEA
039A6:  MOVFF  FEF,6C2
039AA:  MOVFF  FEC,6C3
039AE:  MOVFF  FEC,6C4
039B2:  MOVFF  FEC,6C5
039B6:  MOVF   x7A,W
039B8:  MULLW  10
039BA:  MOVF   FF3,W
039BC:  CLRF   x8A
039BE:  MOVWF  x89
039C0:  MOVLW  0C
039C2:  ADDWF  x89,W
039C4:  MOVWF  01
039C6:  MOVLW  00
039C8:  ADDWFC x8A,W
039CA:  MOVWF  03
039CC:  MOVF   01,W
039CE:  ADDLW  62
039D0:  MOVWF  FE9
039D2:  MOVLW  00
039D4:  ADDWFC 03,W
039D6:  MOVWF  FEA
039D8:  MOVFF  FEF,6C6
039DC:  MOVFF  FEC,01
039E0:  MOVFF  FEC,02
039E4:  MOVFF  FEC,03
039E8:  MOVFF  03,6C9
039EC:  MOVFF  02,6C8
039F0:  MOVFF  01,6C7
039F4:  MOVLB  0
039F6:  CALL   0D12
039FA:  MOVFF  03,6C4
039FE:  MOVFF  02,6C3
03A02:  MOVFF  01,6C2
03A06:  MOVFF  00,6C1
03A0A:  MOVLB  6
03A0C:  MOVF   x7A,W
03A0E:  MULLW  10
03A10:  MOVF   FF3,W
03A12:  CLRF   x8A
03A14:  MOVWF  x89
03A16:  MOVLW  04
03A18:  ADDWF  x89,W
03A1A:  MOVWF  01
03A1C:  MOVLW  00
03A1E:  ADDWFC x8A,W
03A20:  MOVWF  03
03A22:  MOVF   01,W
03A24:  ADDLW  62
03A26:  MOVWF  FE9
03A28:  MOVLW  00
03A2A:  ADDWFC 03,W
03A2C:  MOVWF  FEA
03A2E:  MOVFF  FEF,6C5
03A32:  MOVFF  FEC,01
03A36:  MOVFF  FEC,02
03A3A:  MOVFF  FEC,03
03A3E:  BCF    FD8.1
03A40:  MOVFF  03,6C8
03A44:  MOVFF  02,6C7
03A48:  MOVFF  01,6C6
03A4C:  MOVLB  0
03A4E:  CALL   0E08
03A52:  MOVFF  684,FEA
03A56:  MOVFF  683,FE9
03A5A:  MOVFF  00,FEF
03A5E:  MOVFF  01,FEC
03A62:  MOVFF  02,FEC
03A66:  MOVFF  03,FEC
....................    float pTmp = 0;
....................    float polePitch = magPP;
03A6A:  MOVLB  6
03A6C:  CLRF   x7E
03A6E:  CLRF   x7D
03A70:  CLRF   x7C
03A72:  CLRF   x7B
03A74:  CLRF   x82
03A76:  CLRF   x81
03A78:  CLRF   x80
03A7A:  MOVLW  7F
03A7C:  MOVWF  x7F
....................    
....................    if (adcVals[ch].cosCounts < 0){
03A7E:  MOVF   x7A,W
03A80:  MULLW  21
03A82:  MOVF   FF3,W
03A84:  CLRF   x84
03A86:  MOVWF  x83
03A88:  MOVLW  0C
03A8A:  ADDWF  x83,W
03A8C:  MOVWF  01
03A8E:  MOVLW  00
03A90:  ADDWFC x84,W
03A92:  MOVWF  03
03A94:  MOVF   01,W
03A96:  ADDLW  07
03A98:  MOVWF  FE9
03A9A:  MOVLW  01
03A9C:  ADDWFC 03,W
03A9E:  MOVWF  FEA
03AA0:  MOVFF  FEF,6BD
03AA4:  MOVFF  FEC,6BE
03AA8:  MOVFF  FEC,6BF
03AAC:  MOVFF  FEC,6C0
03AB0:  CLRF   xC4
03AB2:  CLRF   xC3
03AB4:  CLRF   xC2
03AB6:  CLRF   xC1
03AB8:  MOVLB  0
03ABA:  CALL   1C9E
03ABE:  BTFSS  FD8.0
03AC0:  BRA    3C2A
....................       if ((adcVals[ch].sinCounts > 0) && (adcVals[ch].sinLast < 0)){
03AC2:  MOVLB  6
03AC4:  MOVF   x7A,W
03AC6:  MULLW  21
03AC8:  MOVF   FF3,W
03ACA:  CLRF   x84
03ACC:  MOVWF  x83
03ACE:  MOVLW  08
03AD0:  ADDWF  x83,W
03AD2:  MOVWF  01
03AD4:  MOVLW  00
03AD6:  ADDWFC x84,W
03AD8:  MOVWF  03
03ADA:  MOVF   01,W
03ADC:  ADDLW  07
03ADE:  MOVWF  FE9
03AE0:  MOVLW  01
03AE2:  ADDWFC 03,W
03AE4:  MOVWF  FEA
03AE6:  MOVFF  FEF,6C1
03AEA:  MOVFF  FEC,684
03AEE:  MOVFF  FEC,6C3
03AF2:  MOVFF  FEC,6C4
03AF6:  CLRF   xC0
03AF8:  CLRF   xBF
03AFA:  CLRF   xBE
03AFC:  CLRF   xBD
03AFE:  MOVFF  684,6C2
03B02:  MOVLB  0
03B04:  CALL   1C9E
03B08:  BNC   3B76
03B0A:  MOVLB  6
03B0C:  MOVF   x7A,W
03B0E:  MULLW  21
03B10:  MOVF   FF3,W
03B12:  CLRF   x84
03B14:  MOVWF  x83
03B16:  MOVLW  10
03B18:  ADDWF  x83,W
03B1A:  MOVWF  01
03B1C:  MOVLW  00
03B1E:  ADDWFC x84,W
03B20:  MOVWF  03
03B22:  MOVF   01,W
03B24:  ADDLW  07
03B26:  MOVWF  FE9
03B28:  MOVLW  01
03B2A:  ADDWFC 03,W
03B2C:  MOVWF  FEA
03B2E:  MOVFF  FEF,6BD
03B32:  MOVFF  FEC,6BE
03B36:  MOVFF  FEC,6BF
03B3A:  MOVFF  FEC,6C0
03B3E:  CLRF   xC4
03B40:  CLRF   xC3
03B42:  CLRF   xC2
03B44:  CLRF   xC1
03B46:  MOVLB  0
03B48:  CALL   1C9E
03B4C:  BNC   3B76
....................          adcVals[ch].npoles--;
03B4E:  MOVLB  6
03B50:  MOVF   x7A,W
03B52:  MULLW  21
03B54:  MOVF   FF3,W
03B56:  CLRF   x84
03B58:  MOVWF  x83
03B5A:  MOVLW  1C
03B5C:  ADDWF  x83,W
03B5E:  MOVWF  01
03B60:  MOVLW  00
03B62:  ADDWFC x84,W
03B64:  MOVWF  03
03B66:  MOVF   01,W
03B68:  ADDLW  07
03B6A:  MOVWF  FE9
03B6C:  MOVLW  01
03B6E:  ADDWFC 03,W
03B70:  MOVWF  FEA
03B72:  DECF   FEF,F
....................       }
03B74:  BRA    3C28
....................       else if ((adcVals[ch].sinCounts < 0) && (adcVals[ch].sinLast > 0)){
03B76:  MOVLB  6
03B78:  MOVF   x7A,W
03B7A:  MULLW  21
03B7C:  MOVF   FF3,W
03B7E:  CLRF   x84
03B80:  MOVWF  x83
03B82:  MOVLW  08
03B84:  ADDWF  x83,W
03B86:  MOVWF  01
03B88:  MOVLW  00
03B8A:  ADDWFC x84,W
03B8C:  MOVWF  03
03B8E:  MOVF   01,W
03B90:  ADDLW  07
03B92:  MOVWF  FE9
03B94:  MOVLW  01
03B96:  ADDWFC 03,W
03B98:  MOVWF  FEA
03B9A:  MOVFF  FEF,6BD
03B9E:  MOVFF  FEC,684
03BA2:  MOVFF  FEC,6BF
03BA6:  MOVFF  FEC,6C0
03BAA:  MOVFF  684,6BE
03BAE:  CLRF   xC4
03BB0:  CLRF   xC3
03BB2:  CLRF   xC2
03BB4:  CLRF   xC1
03BB6:  MOVLB  0
03BB8:  CALL   1C9E
03BBC:  BNC   3C2A
03BBE:  MOVLB  6
03BC0:  MOVF   x7A,W
03BC2:  MULLW  21
03BC4:  MOVF   FF3,W
03BC6:  CLRF   x84
03BC8:  MOVWF  x83
03BCA:  MOVLW  10
03BCC:  ADDWF  x83,W
03BCE:  MOVWF  01
03BD0:  MOVLW  00
03BD2:  ADDWFC x84,W
03BD4:  MOVWF  03
03BD6:  MOVF   01,W
03BD8:  ADDLW  07
03BDA:  MOVWF  FE9
03BDC:  MOVLW  01
03BDE:  ADDWFC 03,W
03BE0:  MOVWF  FEA
03BE2:  MOVFF  FEF,6C1
03BE6:  MOVFF  FEC,6C2
03BEA:  MOVFF  FEC,6C3
03BEE:  MOVFF  FEC,6C4
03BF2:  CLRF   xC0
03BF4:  CLRF   xBF
03BF6:  CLRF   xBE
03BF8:  CLRF   xBD
03BFA:  MOVLB  0
03BFC:  CALL   1C9E
03C00:  BNC   3C2A
....................          adcVals[ch].npoles++;
03C02:  MOVLB  6
03C04:  MOVF   x7A,W
03C06:  MULLW  21
03C08:  MOVF   FF3,W
03C0A:  CLRF   x84
03C0C:  MOVWF  x83
03C0E:  MOVLW  1C
03C10:  ADDWF  x83,W
03C12:  MOVWF  01
03C14:  MOVLW  00
03C16:  ADDWFC x84,W
03C18:  MOVWF  03
03C1A:  MOVF   01,W
03C1C:  ADDLW  07
03C1E:  MOVWF  FE9
03C20:  MOVLW  01
03C22:  ADDWFC 03,W
03C24:  MOVWF  FEA
03C26:  INCF   FEF,F
03C28:  MOVLB  0
....................       }
....................    }
....................    
....................    adcVals[ch].p0 = polePitch * ( 1000 / (2*PI) ) * atan2( (float)adcVals[ch].sinCounts, (float)adcVals[ch].cosCounts );
03C2A:  MOVLB  6
03C2C:  MOVF   x7A,W
03C2E:  MULLW  21
03C30:  MOVF   FF3,W
03C32:  CLRF   x84
03C34:  MOVWF  x83
03C36:  MOVLW  18
03C38:  ADDWF  x83,W
03C3A:  MOVWF  01
03C3C:  MOVLW  00
03C3E:  ADDWFC x84,W
03C40:  MOVWF  03
03C42:  MOVF   01,W
03C44:  ADDLW  07
03C46:  MOVWF  01
03C48:  MOVLW  01
03C4A:  ADDWFC 03,F
03C4C:  MOVFF  01,683
03C50:  MOVFF  03,684
03C54:  MOVFF  682,6C5
03C58:  MOVFF  681,6C4
03C5C:  MOVFF  680,6C3
03C60:  MOVFF  67F,6C2
03C64:  MOVLW  AA
03C66:  MOVWF  xC9
03C68:  MOVLW  27
03C6A:  MOVWF  xC8
03C6C:  MOVLW  1F
03C6E:  MOVWF  xC7
03C70:  MOVLW  86
03C72:  MOVWF  xC6
03C74:  MOVLB  0
03C76:  CALL   0D12
03C7A:  MOVFF  03,688
03C7E:  MOVFF  02,687
03C82:  MOVFF  01,686
03C86:  MOVFF  00,685
03C8A:  MOVLB  6
03C8C:  MOVF   x7A,W
03C8E:  MULLW  21
03C90:  MOVF   FF3,W
03C92:  CLRF   x8A
03C94:  MOVWF  x89
03C96:  MOVLW  08
03C98:  ADDWF  x89,W
03C9A:  MOVWF  01
03C9C:  MOVLW  00
03C9E:  ADDWFC x8A,W
03CA0:  MOVWF  03
03CA2:  MOVF   01,W
03CA4:  ADDLW  07
03CA6:  MOVWF  FE9
03CA8:  MOVLW  01
03CAA:  ADDWFC 03,W
03CAC:  MOVWF  FEA
03CAE:  MOVFF  FEF,689
03CB2:  MOVFF  FEC,68A
03CB6:  MOVFF  FEC,68B
03CBA:  MOVFF  FEC,68C
03CBE:  MOVF   x7A,W
03CC0:  MULLW  21
03CC2:  MOVF   FF3,W
03CC4:  CLRF   x8E
03CC6:  MOVWF  x8D
03CC8:  MOVLW  0C
03CCA:  ADDWF  x8D,W
03CCC:  MOVWF  01
03CCE:  MOVLW  00
03CD0:  ADDWFC x8E,W
03CD2:  MOVWF  03
03CD4:  MOVF   01,W
03CD6:  ADDLW  07
03CD8:  MOVWF  FE9
03CDA:  MOVLW  01
03CDC:  ADDWFC 03,W
03CDE:  MOVWF  FEA
03CE0:  MOVFF  FEF,00
03CE4:  MOVFF  FEC,01
03CE8:  MOVFF  FEC,02
03CEC:  MOVFF  FEC,03
03CF0:  MOVFF  03,690
03CF4:  MOVFF  02,68F
03CF8:  MOVFF  01,68E
03CFC:  MOVFF  00,68D
03D00:  MOVFF  68C,694
03D04:  MOVFF  68B,693
03D08:  MOVFF  68A,692
03D0C:  MOVFF  689,691
03D10:  MOVFF  03,698
03D14:  MOVFF  02,697
03D18:  MOVFF  01,696
03D1C:  MOVFF  00,695
03D20:  MOVLB  0
03D22:  GOTO   23A0
03D26:  MOVFF  688,6C5
03D2A:  MOVFF  687,6C4
03D2E:  MOVFF  686,6C3
03D32:  MOVFF  685,6C2
03D36:  MOVFF  03,6C9
03D3A:  MOVFF  02,6C8
03D3E:  MOVFF  01,6C7
03D42:  MOVFF  00,6C6
03D46:  CALL   0D12
03D4A:  MOVFF  684,FEA
03D4E:  MOVFF  683,FE9
03D52:  MOVFF  00,FEF
03D56:  MOVFF  01,FEC
03D5A:  MOVFF  02,FEC
03D5E:  MOVFF  03,FEC
....................    pTmp = adcVals[ch].p0 + ( 1000 * polePitch * (float)adcVals[ch].npoles );
03D62:  MOVLB  6
03D64:  MOVF   x7A,W
03D66:  MULLW  21
03D68:  MOVF   FF3,W
03D6A:  CLRF   x84
03D6C:  MOVWF  x83
03D6E:  MOVLW  18
03D70:  ADDWF  x83,W
03D72:  MOVWF  01
03D74:  MOVLW  00
03D76:  ADDWFC x84,W
03D78:  MOVWF  03
03D7A:  MOVF   01,W
03D7C:  ADDLW  07
03D7E:  MOVWF  FE9
03D80:  MOVLW  01
03D82:  ADDWFC 03,W
03D84:  MOVWF  FEA
03D86:  MOVFF  FEF,683
03D8A:  MOVFF  FEC,684
03D8E:  MOVFF  FEC,685
03D92:  MOVFF  FEC,686
03D96:  CLRF   xC5
03D98:  CLRF   xC4
03D9A:  MOVLW  7A
03D9C:  MOVWF  xC3
03D9E:  MOVLW  88
03DA0:  MOVWF  xC2
03DA2:  MOVFF  682,6C9
03DA6:  MOVFF  681,6C8
03DAA:  MOVFF  680,6C7
03DAE:  MOVFF  67F,6C6
03DB2:  MOVLB  0
03DB4:  CALL   0D12
03DB8:  MOVFF  03,68A
03DBC:  MOVFF  02,689
03DC0:  MOVFF  01,688
03DC4:  MOVFF  00,687
03DC8:  MOVLB  6
03DCA:  MOVF   x7A,W
03DCC:  MULLW  21
03DCE:  MOVF   FF3,W
03DD0:  CLRF   x8C
03DD2:  MOVWF  x8B
03DD4:  MOVLW  1C
03DD6:  ADDWF  x8B,W
03DD8:  MOVWF  01
03DDA:  MOVLW  00
03DDC:  ADDWFC x8C,W
03DDE:  MOVWF  03
03DE0:  MOVF   01,W
03DE2:  ADDLW  07
03DE4:  MOVWF  FE9
03DE6:  MOVLW  01
03DE8:  ADDWFC 03,W
03DEA:  MOVWF  FEA
03DEC:  MOVF   FEF,W
03DEE:  CLRF   xB4
03DF0:  MOVWF  xB3
03DF2:  BTFSC  xB3.7
03DF4:  DECF   xB4,F
03DF6:  MOVLB  0
03DF8:  CALL   2642
03DFC:  MOVFF  68A,6C5
03E00:  MOVFF  689,6C4
03E04:  MOVFF  688,6C3
03E08:  MOVFF  687,6C2
03E0C:  MOVFF  03,6C9
03E10:  MOVFF  02,6C8
03E14:  MOVFF  01,6C7
03E18:  MOVFF  00,6C6
03E1C:  CALL   0D12
03E20:  MOVFF  FEA,688
03E24:  MOVFF  FE9,687
03E28:  BCF    FD8.1
03E2A:  MOVFF  686,6C4
03E2E:  MOVFF  685,6C3
03E32:  MOVFF  684,6C2
03E36:  MOVFF  683,6C1
03E3A:  MOVFF  03,6C8
03E3E:  MOVFF  02,6C7
03E42:  MOVFF  01,6C6
03E46:  MOVFF  00,6C5
03E4A:  CALL   0E08
03E4E:  MOVFF  688,FEA
03E52:  MOVFF  687,FE9
03E56:  MOVFF  03,67E
03E5A:  MOVFF  02,67D
03E5E:  MOVFF  01,67C
03E62:  MOVFF  00,67B
....................    
....................    adcVals[ch].pReal = (pow(pTmp*sc[ch].c5,5) + pow(pTmp*sc[ch].c4,4) + pow(pTmp*sc[ch].c3,3) + pow(pTmp*sc[ch].c2,2) + pTmp*sc[ch].c1 + sc[ch].c0);
03E66:  MOVLB  6
03E68:  MOVF   x7A,W
03E6A:  MULLW  21
03E6C:  MOVF   FF3,W
03E6E:  CLRF   x84
03E70:  MOVWF  x83
03E72:  MOVLW  1D
03E74:  ADDWF  x83,W
03E76:  MOVWF  01
03E78:  MOVLW  00
03E7A:  ADDWFC x84,W
03E7C:  MOVWF  03
03E7E:  MOVF   01,W
03E80:  ADDLW  07
03E82:  MOVWF  01
03E84:  MOVLW  01
03E86:  ADDWFC 03,F
03E88:  MOVFF  01,683
03E8C:  MOVFF  03,684
03E90:  MOVF   x7A,W
03E92:  MULLW  18
03E94:  MOVF   FF3,W
03E96:  CLRF   x86
03E98:  MOVWF  x85
03E9A:  MOVLW  14
03E9C:  ADDWF  x85,W
03E9E:  MOVWF  01
03EA0:  MOVLW  00
03EA2:  ADDWFC x86,W
03EA4:  MOVWF  03
03EA6:  MOVF   01,W
03EA8:  ADDLW  82
03EAA:  MOVWF  FE9
03EAC:  MOVLW  00
03EAE:  ADDWFC 03,W
03EB0:  MOVWF  FEA
03EB2:  MOVFF  FEF,6C6
03EB6:  MOVFF  FEC,01
03EBA:  MOVFF  FEC,02
03EBE:  MOVFF  FEC,03
03EC2:  MOVFF  67E,6C5
03EC6:  MOVFF  67D,6C4
03ECA:  MOVFF  67C,6C3
03ECE:  MOVFF  67B,6C2
03ED2:  MOVFF  03,6C9
03ED6:  MOVFF  02,6C8
03EDA:  MOVFF  01,6C7
03EDE:  MOVLB  0
03EE0:  CALL   0D12
03EE4:  MOVFF  03,688
03EE8:  MOVFF  02,687
03EEC:  MOVFF  01,686
03EF0:  MOVFF  00,685
03EF4:  MOVFF  03,694
03EF8:  MOVFF  02,693
03EFC:  MOVFF  01,692
03F00:  MOVFF  00,691
03F04:  MOVLB  6
03F06:  CLRF   x98
03F08:  CLRF   x97
03F0A:  MOVLW  20
03F0C:  MOVWF  x96
03F0E:  MOVLW  81
03F10:  MOVWF  x95
03F12:  MOVLB  0
03F14:  CALL   3380
03F18:  MOVFF  03,688
03F1C:  MOVFF  02,687
03F20:  MOVFF  01,686
03F24:  MOVFF  00,685
03F28:  MOVLB  6
03F2A:  MOVF   x7A,W
03F2C:  MULLW  18
03F2E:  MOVF   FF3,W
03F30:  CLRF   x8A
03F32:  MOVWF  x89
03F34:  MOVLW  10
03F36:  ADDWF  x89,W
03F38:  MOVWF  01
03F3A:  MOVLW  00
03F3C:  ADDWFC x8A,W
03F3E:  MOVWF  03
03F40:  MOVF   01,W
03F42:  ADDLW  82
03F44:  MOVWF  FE9
03F46:  MOVLW  00
03F48:  ADDWFC 03,W
03F4A:  MOVWF  FEA
03F4C:  MOVFF  FEF,6C6
03F50:  MOVFF  FEC,01
03F54:  MOVFF  FEC,02
03F58:  MOVFF  FEC,03
03F5C:  MOVFF  67E,6C5
03F60:  MOVFF  67D,6C4
03F64:  MOVFF  67C,6C3
03F68:  MOVFF  67B,6C2
03F6C:  MOVFF  03,6C9
03F70:  MOVFF  02,6C8
03F74:  MOVFF  01,6C7
03F78:  MOVLB  0
03F7A:  CALL   0D12
03F7E:  MOVFF  03,68C
03F82:  MOVFF  02,68B
03F86:  MOVFF  01,68A
03F8A:  MOVFF  00,689
03F8E:  MOVFF  03,694
03F92:  MOVFF  02,693
03F96:  MOVFF  01,692
03F9A:  MOVFF  00,691
03F9E:  MOVLB  6
03FA0:  CLRF   x98
03FA2:  CLRF   x97
03FA4:  CLRF   x96
03FA6:  MOVLW  81
03FA8:  MOVWF  x95
03FAA:  MOVLB  0
03FAC:  CALL   3380
03FB0:  MOVFF  FEA,68A
03FB4:  MOVFF  FE9,689
03FB8:  BCF    FD8.1
03FBA:  MOVFF  688,6C4
03FBE:  MOVFF  687,6C3
03FC2:  MOVFF  686,6C2
03FC6:  MOVFF  685,6C1
03FCA:  MOVFF  03,6C8
03FCE:  MOVFF  02,6C7
03FD2:  MOVFF  01,6C6
03FD6:  MOVFF  00,6C5
03FDA:  CALL   0E08
03FDE:  MOVFF  68A,FEA
03FE2:  MOVFF  689,FE9
03FE6:  MOVFF  03,688
03FEA:  MOVFF  02,687
03FEE:  MOVFF  01,686
03FF2:  MOVFF  00,685
03FF6:  MOVLB  6
03FF8:  MOVF   x7A,W
03FFA:  MULLW  18
03FFC:  MOVF   FF3,W
03FFE:  CLRF   x8C
04000:  MOVWF  x8B
04002:  MOVLW  0C
04004:  ADDWF  x8B,W
04006:  MOVWF  01
04008:  MOVLW  00
0400A:  ADDWFC x8C,W
0400C:  MOVWF  03
0400E:  MOVF   01,W
04010:  ADDLW  82
04012:  MOVWF  FE9
04014:  MOVLW  00
04016:  ADDWFC 03,W
04018:  MOVWF  FEA
0401A:  MOVFF  FEF,6C6
0401E:  MOVFF  FEC,01
04022:  MOVFF  FEC,02
04026:  MOVFF  FEC,03
0402A:  MOVFF  67E,6C5
0402E:  MOVFF  67D,6C4
04032:  MOVFF  67C,6C3
04036:  MOVFF  67B,6C2
0403A:  MOVFF  03,6C9
0403E:  MOVFF  02,6C8
04042:  MOVFF  01,6C7
04046:  MOVLB  0
04048:  CALL   0D12
0404C:  MOVFF  03,68E
04050:  MOVFF  02,68D
04054:  MOVFF  01,68C
04058:  MOVFF  00,68B
0405C:  MOVFF  03,694
04060:  MOVFF  02,693
04064:  MOVFF  01,692
04068:  MOVFF  00,691
0406C:  MOVLB  6
0406E:  CLRF   x98
04070:  CLRF   x97
04072:  MOVLW  40
04074:  MOVWF  x96
04076:  MOVLW  80
04078:  MOVWF  x95
0407A:  MOVLB  0
0407C:  CALL   3380
04080:  MOVFF  FEA,68C
04084:  MOVFF  FE9,68B
04088:  BCF    FD8.1
0408A:  MOVFF  688,6C4
0408E:  MOVFF  687,6C3
04092:  MOVFF  686,6C2
04096:  MOVFF  685,6C1
0409A:  MOVFF  03,6C8
0409E:  MOVFF  02,6C7
040A2:  MOVFF  01,6C6
040A6:  MOVFF  00,6C5
040AA:  CALL   0E08
040AE:  MOVFF  68C,FEA
040B2:  MOVFF  68B,FE9
040B6:  MOVFF  03,688
040BA:  MOVFF  02,687
040BE:  MOVFF  01,686
040C2:  MOVFF  00,685
040C6:  MOVLB  6
040C8:  MOVF   x7A,W
040CA:  MULLW  18
040CC:  MOVF   FF3,W
040CE:  CLRF   x8E
040D0:  MOVWF  x8D
040D2:  MOVLW  08
040D4:  ADDWF  x8D,W
040D6:  MOVWF  01
040D8:  MOVLW  00
040DA:  ADDWFC x8E,W
040DC:  MOVWF  03
040DE:  MOVF   01,W
040E0:  ADDLW  82
040E2:  MOVWF  FE9
040E4:  MOVLW  00
040E6:  ADDWFC 03,W
040E8:  MOVWF  FEA
040EA:  MOVFF  FEF,6C6
040EE:  MOVFF  FEC,01
040F2:  MOVFF  FEC,02
040F6:  MOVFF  FEC,03
040FA:  MOVFF  67E,6C5
040FE:  MOVFF  67D,6C4
04102:  MOVFF  67C,6C3
04106:  MOVFF  67B,6C2
0410A:  MOVFF  03,6C9
0410E:  MOVFF  02,6C8
04112:  MOVFF  01,6C7
04116:  MOVLB  0
04118:  CALL   0D12
0411C:  MOVFF  03,690
04120:  MOVFF  02,68F
04124:  MOVFF  01,68E
04128:  MOVFF  00,68D
0412C:  MOVFF  03,694
04130:  MOVFF  02,693
04134:  MOVFF  01,692
04138:  MOVFF  00,691
0413C:  MOVLB  6
0413E:  CLRF   x98
04140:  CLRF   x97
04142:  CLRF   x96
04144:  MOVLW  80
04146:  MOVWF  x95
04148:  MOVLB  0
0414A:  CALL   3380
0414E:  MOVFF  FEA,68E
04152:  MOVFF  FE9,68D
04156:  BCF    FD8.1
04158:  MOVFF  688,6C4
0415C:  MOVFF  687,6C3
04160:  MOVFF  686,6C2
04164:  MOVFF  685,6C1
04168:  MOVFF  03,6C8
0416C:  MOVFF  02,6C7
04170:  MOVFF  01,6C6
04174:  MOVFF  00,6C5
04178:  CALL   0E08
0417C:  MOVFF  68E,FEA
04180:  MOVFF  68D,FE9
04184:  MOVFF  03,688
04188:  MOVFF  02,687
0418C:  MOVFF  01,686
04190:  MOVFF  00,685
04194:  MOVLB  6
04196:  MOVF   x7A,W
04198:  MULLW  18
0419A:  MOVF   FF3,W
0419C:  CLRF   x90
0419E:  MOVWF  x8F
041A0:  MOVLW  04
041A2:  ADDWF  x8F,W
041A4:  MOVWF  01
041A6:  MOVLW  00
041A8:  ADDWFC x90,W
041AA:  MOVWF  03
041AC:  MOVF   01,W
041AE:  ADDLW  82
041B0:  MOVWF  FE9
041B2:  MOVLW  00
041B4:  ADDWFC 03,W
041B6:  MOVWF  FEA
041B8:  MOVFF  FEF,6C6
041BC:  MOVFF  FEC,01
041C0:  MOVFF  FEC,02
041C4:  MOVFF  FEC,03
041C8:  MOVFF  67E,6C5
041CC:  MOVFF  67D,6C4
041D0:  MOVFF  67C,6C3
041D4:  MOVFF  67B,6C2
041D8:  MOVFF  03,6C9
041DC:  MOVFF  02,6C8
041E0:  MOVFF  01,6C7
041E4:  MOVLB  0
041E6:  CALL   0D12
041EA:  MOVFF  FEA,690
041EE:  MOVFF  FE9,68F
041F2:  BCF    FD8.1
041F4:  MOVFF  688,6C4
041F8:  MOVFF  687,6C3
041FC:  MOVFF  686,6C2
04200:  MOVFF  685,6C1
04204:  MOVFF  03,6C8
04208:  MOVFF  02,6C7
0420C:  MOVFF  01,6C6
04210:  MOVFF  00,6C5
04214:  CALL   0E08
04218:  MOVFF  690,FEA
0421C:  MOVFF  68F,FE9
04220:  MOVFF  03,6C4
04224:  MOVFF  02,6C3
04228:  MOVFF  01,6C2
0422C:  MOVFF  00,6C1
04230:  MOVLB  6
04232:  MOVF   x7A,W
04234:  MULLW  18
04236:  MOVF   FF3,W
04238:  CLRF   x92
0423A:  MOVWF  x91
0423C:  MOVLW  82
0423E:  ADDWF  x91,W
04240:  MOVWF  FE9
04242:  MOVLW  00
04244:  ADDWFC x92,W
04246:  MOVWF  FEA
04248:  MOVFF  FEF,6C5
0424C:  MOVFF  FEC,01
04250:  MOVFF  FEC,02
04254:  MOVFF  FEC,03
04258:  BCF    FD8.1
0425A:  MOVFF  03,6C8
0425E:  MOVFF  02,6C7
04262:  MOVFF  01,6C6
04266:  MOVLB  0
04268:  CALL   0E08
0426C:  MOVFF  684,FEA
04270:  MOVFF  683,FE9
04274:  MOVFF  00,FEF
04278:  MOVFF  01,FEC
0427C:  MOVFF  02,FEC
04280:  MOVFF  03,FEC
....................    if (ch == chX) adcVals[ch].pReal *= -1;
04284:  MOVLB  6
04286:  MOVF   x7A,F
04288:  BNZ   42E6
0428A:  MOVF   x7A,W
0428C:  MULLW  21
0428E:  MOVF   FF3,W
04290:  CLRF   x84
04292:  MOVWF  x83
04294:  MOVLW  1D
04296:  ADDWF  x83,W
04298:  MOVWF  01
0429A:  MOVLW  00
0429C:  ADDWFC x84,W
0429E:  MOVWF  03
042A0:  MOVF   01,W
042A2:  ADDLW  07
042A4:  MOVWF  FE9
042A6:  MOVLW  01
042A8:  ADDWFC 03,W
042AA:  MOVWF  FEA
042AC:  MOVFF  FEF,6C2
042B0:  MOVFF  FEC,6C3
042B4:  MOVFF  FEC,6C4
042B8:  MOVFF  FEC,6C5
042BC:  MOVF   FED,F
042BE:  MOVF   FED,F
042C0:  MOVF   FED,F
042C2:  CLRF   xC9
042C4:  CLRF   xC8
042C6:  MOVLW  80
042C8:  MOVWF  xC7
042CA:  MOVLW  7F
042CC:  MOVWF  xC6
042CE:  MOVLB  0
042D0:  CALL   0D12
042D4:  MOVFF  00,FEF
042D8:  MOVFF  01,FEC
042DC:  MOVFF  02,FEC
042E0:  MOVFF  03,FEC
042E4:  MOVLB  6
....................    PID[ch].PVold = PID[ch].PV;
042E6:  MOVF   x7A,W
042E8:  MULLW  20
042EA:  MOVF   FF3,W
042EC:  CLRF   x84
042EE:  MOVWF  x83
042F0:  MOVLW  14
042F2:  ADDWF  x83,W
042F4:  MOVWF  01
042F6:  MOVLW  00
042F8:  ADDWFC x84,W
042FA:  MOVWF  03
042FC:  MOVF   01,W
042FE:  ADDLW  20
04300:  MOVWF  01
04302:  MOVLW  00
04304:  ADDWFC 03,F
04306:  MOVFF  01,683
0430A:  MOVFF  03,684
0430E:  MOVF   x7A,W
04310:  MULLW  20
04312:  MOVF   FF3,W
04314:  CLRF   x86
04316:  MOVWF  x85
04318:  MOVLW  10
0431A:  ADDWF  x85,W
0431C:  MOVWF  01
0431E:  MOVLW  00
04320:  ADDWFC x86,W
04322:  MOVWF  03
04324:  MOVF   01,W
04326:  ADDLW  20
04328:  MOVWF  FE9
0432A:  MOVLW  00
0432C:  ADDWFC 03,W
0432E:  MOVWF  FEA
04330:  MOVFF  FEF,00
04334:  MOVFF  FEC,01
04338:  MOVFF  FEC,02
0433C:  MOVFF  FEC,03
04340:  MOVFF  684,FEA
04344:  MOVFF  683,FE9
04348:  MOVFF  00,FEF
0434C:  MOVFF  01,FEC
04350:  MOVFF  02,FEC
04354:  MOVFF  03,FEC
....................    PID[ch].PV = adcVals[ch].pReal;
04358:  MOVF   x7A,W
0435A:  MULLW  20
0435C:  MOVF   FF3,W
0435E:  CLRF   x84
04360:  MOVWF  x83
04362:  MOVLW  10
04364:  ADDWF  x83,W
04366:  MOVWF  01
04368:  MOVLW  00
0436A:  ADDWFC x84,W
0436C:  MOVWF  03
0436E:  MOVF   01,W
04370:  ADDLW  20
04372:  MOVWF  01
04374:  MOVLW  00
04376:  ADDWFC 03,F
04378:  MOVFF  01,683
0437C:  MOVFF  03,684
04380:  MOVF   x7A,W
04382:  MULLW  21
04384:  MOVF   FF3,W
04386:  CLRF   x86
04388:  MOVWF  x85
0438A:  MOVLW  1D
0438C:  ADDWF  x85,W
0438E:  MOVWF  01
04390:  MOVLW  00
04392:  ADDWFC x86,W
04394:  MOVWF  03
04396:  MOVF   01,W
04398:  ADDLW  07
0439A:  MOVWF  FE9
0439C:  MOVLW  01
0439E:  ADDWFC 03,W
043A0:  MOVWF  FEA
043A2:  MOVFF  FEF,00
043A6:  MOVFF  FEC,01
043AA:  MOVFF  FEC,02
043AE:  MOVFF  FEC,03
043B2:  MOVFF  684,FEA
043B6:  MOVFF  683,FE9
043BA:  MOVFF  00,FEF
043BE:  MOVFF  01,FEC
043C2:  MOVFF  02,FEC
043C6:  MOVFF  03,FEC
043CA:  MOVLB  0
043CC:  GOTO   4528 (RETURN)
.................... }  
.................... 
.................... /*****************************************************************************/
.................... /* SENSOR MONITOR INTERRUPT TASK                                             */
.................... /* starts conversion of the other two ADCs                                   */
.................... /*****************************************************************************/
.................... void sensor_monitor_interrupt_task(){
....................    static int8 ch = 0;
....................    
....................    if (!smData[ch].adcBusy){
*
001C0:  MOVLB  1
001C2:  MOVF   xCD,W
001C4:  MULLW  09
001C6:  MOVF   FF3,W
001C8:  MOVLB  6
001CA:  CLRF   xE2
001CC:  MOVWF  xE1
001CE:  MOVLW  BA
001D0:  ADDWF  xE1,W
001D2:  MOVWF  FE9
001D4:  MOVLW  01
001D6:  ADDWFC xE2,W
001D8:  MOVWF  FEA
001DA:  BTFSC  FEF.1
001DC:  BRA    0256
....................       smData[ch].adcBusy = true;
001DE:  MOVLB  1
001E0:  MOVF   xCD,W
001E2:  MULLW  09
001E4:  MOVF   FF3,W
001E6:  MOVLB  6
001E8:  CLRF   xE2
001EA:  MOVWF  xE1
001EC:  MOVLW  BA
001EE:  ADDWF  xE1,W
001F0:  MOVWF  FE9
001F2:  MOVLW  01
001F4:  ADDWFC xE2,W
001F6:  MOVWF  FEA
001F8:  BSF    FEF.1
....................          
....................       ads_start_conv_block(ch);
001FA:  MOVFF  1CD,6E1
001FE:  MOVLB  0
00200:  BRA    01A4
....................       ch = !ch;
00202:  MOVLB  1
00204:  MOVF   xCD,F
00206:  BZ    020C
00208:  MOVLW  00
0020A:  BRA    020E
0020C:  MOVLW  01
0020E:  MOVWF  xCD
....................          
....................       smData[!ch].dataReady = true;
00210:  MOVF   xCD,F
00212:  BZ    0218
00214:  MOVLW  00
00216:  BRA    021A
00218:  MOVLW  01
0021A:  MULLW  09
0021C:  MOVF   FF3,W
0021E:  MOVLB  6
00220:  CLRF   xE2
00222:  MOVWF  xE1
00224:  MOVLW  BA
00226:  ADDWF  xE1,W
00228:  MOVWF  FE9
0022A:  MOVLW  01
0022C:  ADDWFC xE2,W
0022E:  MOVWF  FEA
00230:  BSF    FEF.0
....................       smData[!ch].adcBusy = false;
00232:  MOVLB  1
00234:  MOVF   xCD,F
00236:  BZ    023C
00238:  MOVLW  00
0023A:  BRA    023E
0023C:  MOVLW  01
0023E:  MULLW  09
00240:  MOVF   FF3,W
00242:  MOVLB  6
00244:  CLRF   xE2
00246:  MOVWF  xE1
00248:  MOVLW  BA
0024A:  ADDWF  xE1,W
0024C:  MOVWF  FE9
0024E:  MOVLW  01
00250:  ADDWFC xE2,W
00252:  MOVWF  FEA
00254:  BCF    FEF.1
....................    }
00256:  MOVLB  0
00258:  GOTO   031A (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Interquartile Mean Ring Buffer                                            */
.................... /* Filters the ADC data to remove spurious readings                          */
.................... /*****************************************************************************/
.................... void iqm_ring_buffer(int8 ch, signed int32 sinCnts, signed int32 cosCnts){
*
016E8:  MOVLB  6
016EA:  CLRF   x8E
016EC:  CLRF   x8D
016EE:  CLRF   x8C
016F0:  CLRF   x8B
016F2:  CLRF   x92
016F4:  CLRF   x91
016F6:  CLRF   x90
016F8:  CLRF   x8F
016FA:  CLRF   x96
016FC:  CLRF   x95
016FE:  CLRF   x94
01700:  CLRF   x93
01702:  CLRF   x9A
01704:  CLRF   x99
01706:  CLRF   x98
01708:  CLRF   x97
0170A:  CLRF   x9E
0170C:  CLRF   x9D
0170E:  CLRF   x9C
01710:  CLRF   x9B
01712:  CLRF   xA2
01714:  CLRF   xA1
01716:  CLRF   xA0
01718:  CLRF   x9F
....................    signed int32* sQ_ch;
....................    signed int32* cQ_ch;
....................    int* sIn_ch;
....................    int* cIn_ch;
.................... 
....................    signed int32 sumSin=0;
....................    signed int32 sumCos=0;
....................    
....................    signed int32 sinMax=0;
....................    signed int32 sinMin=0;
....................    signed int32 cosMax=0;
....................    signed int32 cosMin=0;
....................    
....................    if (ch==0){
0171A:  MOVF   x7A,F
0171C:  BNZ   1740
....................       sQ_ch = sQ_x;
0171E:  MOVLW  01
01720:  MOVWF  x84
01722:  MOVLW  66
01724:  MOVWF  x83
....................       cQ_ch = cQ_x;
01726:  MOVLW  01
01728:  MOVWF  x86
0172A:  MOVLW  7A
0172C:  MOVWF  x85
....................       sIn_ch = &sIn_x;
0172E:  MOVLW  01
01730:  MOVWF  x88
01732:  MOVLW  B6
01734:  MOVWF  x87
....................       cIn_ch = &cIn_x;
01736:  MOVLW  01
01738:  MOVWF  x8A
0173A:  MOVLW  B7
0173C:  MOVWF  x89
....................    }
0173E:  BRA    1764
....................    else if (ch==1){
01740:  DECFSZ x7A,W
01742:  BRA    1764
....................       sQ_ch = sQ_y;
01744:  MOVLW  01
01746:  MOVWF  x84
01748:  MOVLW  8E
0174A:  MOVWF  x83
....................       cQ_ch = cQ_y;
0174C:  MOVLW  01
0174E:  MOVWF  x86
01750:  MOVLW  A2
01752:  MOVWF  x85
....................       sIn_ch = &sIn_y;
01754:  MOVLW  01
01756:  MOVWF  x88
01758:  MOVLW  B8
0175A:  MOVWF  x87
....................       cIn_ch = &cIn_y;
0175C:  MOVLW  01
0175E:  MOVWF  x8A
01760:  MOVLW  B9
01762:  MOVWF  x89
....................    }
.................... 
....................    push(sQ_ch, sIn_ch, sinCnts); // push new data into queues
01764:  MOVFF  684,6A5
01768:  MOVFF  683,6A4
0176C:  MOVFF  688,6A7
01770:  MOVFF  687,6A6
01774:  MOVFF  67E,6AB
01778:  MOVFF  67D,6AA
0177C:  MOVFF  67C,6A9
01780:  MOVFF  67B,6A8
01784:  MOVLB  0
01786:  CALL   0878
....................    push(cQ_ch, cIn_ch, cosCnts);
0178A:  MOVFF  686,6A5
0178E:  MOVFF  685,6A4
01792:  MOVFF  68A,6A7
01796:  MOVFF  689,6A6
0179A:  MOVFF  682,6AB
0179E:  MOVFF  681,6AA
017A2:  MOVFF  680,6A9
017A6:  MOVFF  67F,6A8
017AA:  CALL   0878
....................    
....................    // MAX and MIN of the rolling buffer initial vals
....................    sinMax=sQ_ch[0];
017AE:  MOVLB  6
017B0:  MOVFF  683,FE9
017B4:  MOVFF  684,FEA
017B8:  MOVFF  FEF,693
017BC:  MOVFF  FEC,694
017C0:  MOVFF  FEC,695
017C4:  MOVFF  FEC,696
....................    sinMin=sQ_ch[0];
017C8:  MOVFF  683,FE9
017CC:  MOVFF  684,FEA
017D0:  MOVFF  FEF,697
017D4:  MOVFF  FEC,698
017D8:  MOVFF  FEC,699
017DC:  MOVFF  FEC,69A
....................    cosMax=cQ_ch[0];
017E0:  MOVFF  685,FE9
017E4:  MOVFF  686,FEA
017E8:  MOVFF  FEF,69B
017EC:  MOVFF  FEC,69C
017F0:  MOVFF  FEC,69D
017F4:  MOVFF  FEC,69E
....................    cosMin=cQ_ch[0];
017F8:  MOVFF  685,FE9
017FC:  MOVFF  686,FEA
01800:  MOVFF  FEF,69F
01804:  MOVFF  FEC,6A0
01808:  MOVFF  FEC,6A1
0180C:  MOVFF  FEC,6A2
....................    
....................    // step thru buffer, adding up all vals and finding MAX and MIN
....................    for (int i=1; i<BUFFER_SIZE; i++){
01810:  MOVLW  01
01812:  MOVWF  xA3
01814:  MOVF   xA3,W
01816:  SUBLW  04
01818:  BTFSS  FD8.0
0181A:  BRA    1B2A
....................       (sinMax < sQ_ch[i]) ? (sinMax=sQ_ch[i]) : (0);
0181C:  CLRF   xB4
0181E:  MOVFF  6A3,6B3
01822:  CLRF   xB6
01824:  MOVLW  04
01826:  MOVWF  xB5
01828:  MOVLB  0
0182A:  CALL   082A
0182E:  MOVFF  02,03
01832:  MOVF   01,W
01834:  MOVLB  6
01836:  ADDWF  x83,W
01838:  MOVWF  FE9
0183A:  MOVF   x84,W
0183C:  ADDWFC 02,W
0183E:  MOVWF  FEA
01840:  MOVFF  FEF,00
01844:  MOVFF  FEC,01
01848:  MOVFF  FEC,02
0184C:  MOVFF  FEC,03
01850:  BTFSS  x96.7
01852:  BRA    185A
01854:  BTFSS  03.7
01856:  BRA    187C
01858:  BRA    185E
0185A:  BTFSC  03.7
0185C:  BRA    18B2
0185E:  MOVF   x96,W
01860:  SUBWF  03,W
01862:  BNC   18B2
01864:  BNZ   187C
01866:  MOVF   x95,W
01868:  SUBWF  02,W
0186A:  BNC   18B2
0186C:  BNZ   187C
0186E:  MOVF   x94,W
01870:  SUBWF  01,W
01872:  BNC   18B2
01874:  BNZ   187C
01876:  MOVF   00,W
01878:  SUBWF  x93,W
0187A:  BC    18B2
0187C:  CLRF   xB4
0187E:  MOVFF  6A3,6B3
01882:  CLRF   xB6
01884:  MOVLW  04
01886:  MOVWF  xB5
01888:  MOVLB  0
0188A:  CALL   082A
0188E:  MOVFF  02,03
01892:  MOVF   01,W
01894:  MOVLB  6
01896:  ADDWF  x83,W
01898:  MOVWF  FE9
0189A:  MOVF   x84,W
0189C:  ADDWFC 02,W
0189E:  MOVWF  FEA
018A0:  MOVFF  FEF,693
018A4:  MOVFF  FEC,694
018A8:  MOVFF  FEC,695
018AC:  MOVFF  FEC,696
018B0:  MOVF   x93,W
....................       (sinMin > sQ_ch[i]) ? (sinMin=sQ_ch[i]) : (0);
018B2:  CLRF   xB4
018B4:  MOVFF  6A3,6B3
018B8:  CLRF   xB6
018BA:  MOVLW  04
018BC:  MOVWF  xB5
018BE:  MOVLB  0
018C0:  CALL   082A
018C4:  MOVFF  02,03
018C8:  MOVF   01,W
018CA:  MOVLB  6
018CC:  ADDWF  x83,W
018CE:  MOVWF  FE9
018D0:  MOVF   x84,W
018D2:  ADDWFC 02,W
018D4:  MOVWF  FEA
018D6:  MOVFF  FEF,00
018DA:  MOVFF  FEC,01
018DE:  MOVFF  FEC,02
018E2:  MOVFF  FEC,03
018E6:  BTFSS  03.7
018E8:  BRA    18F0
018EA:  BTFSS  x9A.7
018EC:  BRA    1912
018EE:  BRA    18F4
018F0:  BTFSC  x9A.7
018F2:  BRA    1956
018F4:  MOVF   03,W
018F6:  SUBWF  x9A,W
018F8:  BNC   1956
018FA:  BNZ   1912
018FC:  MOVF   02,W
018FE:  SUBWF  x99,W
01900:  BNC   1956
01902:  BNZ   1912
01904:  MOVF   01,W
01906:  SUBWF  x98,W
01908:  BNC   1956
0190A:  BNZ   1912
0190C:  MOVF   x97,W
0190E:  SUBWF  00,W
01910:  BC    1956
01912:  CLRF   xB4
01914:  MOVFF  6A3,6B3
01918:  CLRF   xB6
0191A:  MOVLW  04
0191C:  MOVWF  xB5
0191E:  MOVLB  0
01920:  CALL   082A
01924:  MOVFF  02,03
01928:  MOVF   01,W
0192A:  MOVLB  6
0192C:  ADDWF  x83,W
0192E:  MOVWF  FE9
01930:  MOVF   x84,W
01932:  ADDWFC 02,W
01934:  MOVWF  FEA
01936:  MOVFF  FEF,697
0193A:  MOVFF  FEC,698
0193E:  MOVFF  FEC,699
01942:  MOVFF  FEC,69A
01946:  MOVFF  697,00
0194A:  MOVFF  698,01
0194E:  MOVFF  699,02
01952:  MOVFF  69A,03
....................       (cosMax < cQ_ch[i]) ? (cosMax=cQ_ch[i]) : (0);
01956:  CLRF   xB4
01958:  MOVFF  6A3,6B3
0195C:  CLRF   xB6
0195E:  MOVLW  04
01960:  MOVWF  xB5
01962:  MOVLB  0
01964:  CALL   082A
01968:  MOVFF  02,03
0196C:  MOVF   01,W
0196E:  MOVLB  6
01970:  ADDWF  x85,W
01972:  MOVWF  FE9
01974:  MOVF   x86,W
01976:  ADDWFC 02,W
01978:  MOVWF  FEA
0197A:  MOVFF  FEF,00
0197E:  MOVFF  FEC,01
01982:  MOVFF  FEC,02
01986:  MOVFF  FEC,03
0198A:  BTFSS  x9E.7
0198C:  BRA    1994
0198E:  BTFSS  03.7
01990:  BRA    19B6
01992:  BRA    1998
01994:  BTFSC  03.7
01996:  BRA    19FA
01998:  MOVF   x9E,W
0199A:  SUBWF  03,W
0199C:  BNC   19FA
0199E:  BNZ   19B6
019A0:  MOVF   x9D,W
019A2:  SUBWF  02,W
019A4:  BNC   19FA
019A6:  BNZ   19B6
019A8:  MOVF   x9C,W
019AA:  SUBWF  01,W
019AC:  BNC   19FA
019AE:  BNZ   19B6
019B0:  MOVF   00,W
019B2:  SUBWF  x9B,W
019B4:  BC    19FA
019B6:  CLRF   xB4
019B8:  MOVFF  6A3,6B3
019BC:  CLRF   xB6
019BE:  MOVLW  04
019C0:  MOVWF  xB5
019C2:  MOVLB  0
019C4:  CALL   082A
019C8:  MOVFF  02,03
019CC:  MOVF   01,W
019CE:  MOVLB  6
019D0:  ADDWF  x85,W
019D2:  MOVWF  FE9
019D4:  MOVF   x86,W
019D6:  ADDWFC 02,W
019D8:  MOVWF  FEA
019DA:  MOVFF  FEF,69B
019DE:  MOVFF  FEC,69C
019E2:  MOVFF  FEC,69D
019E6:  MOVFF  FEC,69E
019EA:  MOVFF  69B,00
019EE:  MOVFF  69C,01
019F2:  MOVFF  69D,02
019F6:  MOVFF  69E,03
....................       (cosMin > cQ_ch[i]) ? (cosMin=cQ_ch[i]) : (0);
019FA:  CLRF   xB4
019FC:  MOVFF  6A3,6B3
01A00:  CLRF   xB6
01A02:  MOVLW  04
01A04:  MOVWF  xB5
01A06:  MOVLB  0
01A08:  CALL   082A
01A0C:  MOVFF  02,03
01A10:  MOVF   01,W
01A12:  MOVLB  6
01A14:  ADDWF  x85,W
01A16:  MOVWF  FE9
01A18:  MOVF   x86,W
01A1A:  ADDWFC 02,W
01A1C:  MOVWF  FEA
01A1E:  MOVFF  FEF,00
01A22:  MOVFF  FEC,01
01A26:  MOVFF  FEC,02
01A2A:  MOVFF  FEC,03
01A2E:  BTFSS  03.7
01A30:  BRA    1A38
01A32:  BTFSS  xA2.7
01A34:  BRA    1A5A
01A36:  BRA    1A3C
01A38:  BTFSC  xA2.7
01A3A:  BRA    1A9E
01A3C:  MOVF   03,W
01A3E:  SUBWF  xA2,W
01A40:  BNC   1A9E
01A42:  BNZ   1A5A
01A44:  MOVF   02,W
01A46:  SUBWF  xA1,W
01A48:  BNC   1A9E
01A4A:  BNZ   1A5A
01A4C:  MOVF   01,W
01A4E:  SUBWF  xA0,W
01A50:  BNC   1A9E
01A52:  BNZ   1A5A
01A54:  MOVF   x9F,W
01A56:  SUBWF  00,W
01A58:  BC    1A9E
01A5A:  CLRF   xB4
01A5C:  MOVFF  6A3,6B3
01A60:  CLRF   xB6
01A62:  MOVLW  04
01A64:  MOVWF  xB5
01A66:  MOVLB  0
01A68:  CALL   082A
01A6C:  MOVFF  02,03
01A70:  MOVF   01,W
01A72:  MOVLB  6
01A74:  ADDWF  x85,W
01A76:  MOVWF  FE9
01A78:  MOVF   x86,W
01A7A:  ADDWFC 02,W
01A7C:  MOVWF  FEA
01A7E:  MOVFF  FEF,69F
01A82:  MOVFF  FEC,6A0
01A86:  MOVFF  FEC,6A1
01A8A:  MOVFF  FEC,6A2
01A8E:  MOVFF  69F,00
01A92:  MOVFF  6A0,01
01A96:  MOVFF  6A1,02
01A9A:  MOVFF  6A2,03
....................       sumSin+=sQ_ch[i];
01A9E:  CLRF   xB4
01AA0:  MOVFF  6A3,6B3
01AA4:  CLRF   xB6
01AA6:  MOVLW  04
01AA8:  MOVWF  xB5
01AAA:  MOVLB  0
01AAC:  CALL   082A
01AB0:  MOVFF  02,03
01AB4:  MOVF   01,W
01AB6:  MOVLB  6
01AB8:  ADDWF  x83,W
01ABA:  MOVWF  FE9
01ABC:  MOVF   x84,W
01ABE:  ADDWFC 02,W
01AC0:  MOVWF  FEA
01AC2:  MOVFF  FEF,00
01AC6:  MOVFF  FEC,01
01ACA:  MOVFF  FEC,02
01ACE:  MOVFF  FEC,03
01AD2:  MOVF   00,W
01AD4:  ADDWF  x8B,F
01AD6:  MOVF   01,W
01AD8:  ADDWFC x8C,F
01ADA:  MOVF   02,W
01ADC:  ADDWFC x8D,F
01ADE:  MOVF   03,W
01AE0:  ADDWFC x8E,F
....................       sumCos+=cQ_ch[i];
01AE2:  CLRF   xB4
01AE4:  MOVFF  6A3,6B3
01AE8:  CLRF   xB6
01AEA:  MOVLW  04
01AEC:  MOVWF  xB5
01AEE:  MOVLB  0
01AF0:  CALL   082A
01AF4:  MOVFF  02,03
01AF8:  MOVF   01,W
01AFA:  MOVLB  6
01AFC:  ADDWF  x85,W
01AFE:  MOVWF  FE9
01B00:  MOVF   x86,W
01B02:  ADDWFC 02,W
01B04:  MOVWF  FEA
01B06:  MOVFF  FEF,00
01B0A:  MOVFF  FEC,01
01B0E:  MOVFF  FEC,02
01B12:  MOVFF  FEC,03
01B16:  MOVF   00,W
01B18:  ADDWF  x8F,F
01B1A:  MOVF   01,W
01B1C:  ADDWFC x90,F
01B1E:  MOVF   02,W
01B20:  ADDWFC x91,F
01B22:  MOVF   03,W
01B24:  ADDWFC x92,F
01B26:  INCF   xA3,F
01B28:  BRA    1814
....................    }
....................    
....................    // subtract MAX and MIN from sum
....................    sumSin-=(sinMax+sinMin);
01B2A:  MOVF   x97,W
01B2C:  ADDWF  x93,W
01B2E:  MOVWF  00
01B30:  MOVF   x98,W
01B32:  ADDWFC x94,W
01B34:  MOVWF  01
01B36:  MOVF   x99,W
01B38:  ADDWFC x95,W
01B3A:  MOVWF  02
01B3C:  MOVF   x9A,W
01B3E:  ADDWFC x96,W
01B40:  MOVWF  03
01B42:  MOVF   00,W
01B44:  SUBWF  x8B,F
01B46:  MOVF   01,W
01B48:  SUBWFB x8C,F
01B4A:  MOVF   02,W
01B4C:  SUBWFB x8D,F
01B4E:  MOVF   03,W
01B50:  SUBWFB x8E,F
....................    sumCos-=(cosMax+cosMin);
01B52:  MOVF   x9F,W
01B54:  ADDWF  x9B,W
01B56:  MOVWF  00
01B58:  MOVF   xA0,W
01B5A:  ADDWFC x9C,W
01B5C:  MOVWF  01
01B5E:  MOVF   xA1,W
01B60:  ADDWFC x9D,W
01B62:  MOVWF  02
01B64:  MOVF   xA2,W
01B66:  ADDWFC x9E,W
01B68:  MOVWF  03
01B6A:  MOVF   00,W
01B6C:  SUBWF  x8F,F
01B6E:  MOVF   01,W
01B70:  SUBWFB x90,F
01B72:  MOVF   02,W
01B74:  SUBWFB x91,F
01B76:  MOVF   03,W
01B78:  SUBWFB x92,F
....................    
....................    // calc AVG
....................    smData[ch].avgSin = sumSin / (BUFFER_SIZE-2);
01B7A:  MOVF   x7A,W
01B7C:  MULLW  09
01B7E:  MOVF   FF3,W
01B80:  CLRF   xA5
01B82:  MOVWF  xA4
01B84:  MOVLW  01
01B86:  ADDWF  xA4,W
01B88:  MOVWF  01
01B8A:  MOVLW  00
01B8C:  ADDWFC xA5,W
01B8E:  MOVWF  03
01B90:  MOVF   01,W
01B92:  ADDLW  BA
01B94:  MOVWF  FE9
01B96:  MOVLW  01
01B98:  ADDWFC 03,W
01B9A:  MOVWF  FEA
01B9C:  MOVFF  FEA,6A7
01BA0:  MOVFF  FE9,6A6
01BA4:  BCF    FD8.1
01BA6:  MOVFF  68E,6AB
01BAA:  MOVFF  68D,6AA
01BAE:  MOVFF  68C,6A9
01BB2:  MOVFF  68B,6A8
01BB6:  CLRF   xAF
01BB8:  CLRF   xAE
01BBA:  CLRF   xAD
01BBC:  MOVLW  03
01BBE:  MOVWF  xAC
01BC0:  MOVLB  0
01BC2:  RCALL  15FE
01BC4:  MOVFF  6A7,FEA
01BC8:  MOVFF  6A6,FE9
01BCC:  MOVFF  00,FEF
01BD0:  MOVFF  01,FEC
01BD4:  MOVFF  02,FEC
01BD8:  MOVFF  03,FEC
....................    smData[ch].avgCos = sumCos / (BUFFER_SIZE-2);
01BDC:  MOVLB  6
01BDE:  MOVF   x7A,W
01BE0:  MULLW  09
01BE2:  MOVF   FF3,W
01BE4:  CLRF   xA5
01BE6:  MOVWF  xA4
01BE8:  MOVLW  05
01BEA:  ADDWF  xA4,W
01BEC:  MOVWF  01
01BEE:  MOVLW  00
01BF0:  ADDWFC xA5,W
01BF2:  MOVWF  03
01BF4:  MOVF   01,W
01BF6:  ADDLW  BA
01BF8:  MOVWF  FE9
01BFA:  MOVLW  01
01BFC:  ADDWFC 03,W
01BFE:  MOVWF  FEA
01C00:  MOVFF  FEA,6A7
01C04:  MOVFF  FE9,6A6
01C08:  BCF    FD8.1
01C0A:  MOVFF  692,6AB
01C0E:  MOVFF  691,6AA
01C12:  MOVFF  690,6A9
01C16:  MOVFF  68F,6A8
01C1A:  CLRF   xAF
01C1C:  CLRF   xAE
01C1E:  CLRF   xAD
01C20:  MOVLW  03
01C22:  MOVWF  xAC
01C24:  MOVLB  0
01C26:  RCALL  15FE
01C28:  MOVFF  6A7,FEA
01C2C:  MOVFF  6A6,FE9
01C30:  MOVFF  00,FEF
01C34:  MOVFF  01,FEC
01C38:  MOVFF  02,FEC
01C3C:  MOVFF  03,FEC
01C40:  GOTO   44B0 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SENSOR MONITOR task - gets magnetoresistive sensor counts                 */
.................... /* gets two values each time the task is run                                 */
.................... /*****************************************************************************/
.................... void sensor_monitor_task(){
*
043D0:  MOVLB  6
043D2:  CLRF   x75
043D4:  CLRF   x74
043D6:  CLRF   x73
043D8:  CLRF   x72
043DA:  CLRF   x79
043DC:  CLRF   x78
043DE:  CLRF   x77
043E0:  CLRF   x76
....................    static int8 ch = 0;
....................    signed int32 sinNew = 0;
....................    signed int32 cosNew = 0;
....................    
....................    if ( (!smData[ch].adcBusy) && smData[ch].dataReady ){
043E2:  MOVLB  1
043E4:  MOVF   xCE,W
043E6:  MULLW  09
043E8:  MOVF   FF3,W
043EA:  MOVLB  6
043EC:  CLRF   x7B
043EE:  MOVWF  x7A
043F0:  MOVLW  BA
043F2:  ADDWF  x7A,W
043F4:  MOVWF  FE9
043F6:  MOVLW  01
043F8:  ADDWFC x7B,W
043FA:  MOVWF  FEA
043FC:  BTFSC  FEF.1
043FE:  BRA    457C
04400:  MOVLB  1
04402:  MOVF   xCE,W
04404:  MULLW  09
04406:  MOVF   FF3,W
04408:  MOVLB  6
0440A:  CLRF   x7D
0440C:  MOVWF  x7C
0440E:  MOVLW  BA
04410:  ADDWF  x7C,W
04412:  MOVWF  FE9
04414:  MOVLW  01
04416:  ADDWFC x7D,W
04418:  MOVWF  FEA
0441A:  BTFSS  FEF.0
0441C:  BRA    457C
....................       smData[ch].adcBusy = true;
0441E:  MOVLB  1
04420:  MOVF   xCE,W
04422:  MULLW  09
04424:  MOVF   FF3,W
04426:  MOVLB  6
04428:  CLRF   x7B
0442A:  MOVWF  x7A
0442C:  MOVLW  BA
0442E:  ADDWF  x7A,W
04430:  MOVWF  FE9
04432:  MOVLW  01
04434:  ADDWFC x7B,W
04436:  MOVWF  FEA
04438:  BSF    FEF.1
....................       
....................       sinNew = ads_read_data(ch*2);
0443A:  BCF    FD8.0
0443C:  MOVLB  1
0443E:  RLCF   xCE,W
04440:  MOVLB  6
04442:  MOVWF  x7A
04444:  MOVWF  x7B
04446:  MOVLB  0
04448:  CALL   07D0
0444C:  MOVFF  03,675
04450:  MOVFF  02,674
04454:  MOVFF  01,673
04458:  MOVFF  00,672
....................       cosNew = ads_read_data(ch*2+1);      
0445C:  BCF    FD8.0
0445E:  MOVLB  1
04460:  RLCF   xCE,W
04462:  ADDLW  01
04464:  MOVLB  6
04466:  MOVWF  x7A
04468:  MOVWF  x7B
0446A:  MOVLB  0
0446C:  CALL   07D0
04470:  MOVFF  03,679
04474:  MOVFF  02,678
04478:  MOVFF  01,677
0447C:  MOVFF  00,676
....................       
....................       if (adcFilter){
04480:  MOVLB  1
04482:  BTFSS  x49.0
04484:  BRA    44B4
....................          iqm_ring_buffer(ch, sinNew, cosNew);
04486:  MOVFF  1CE,67A
0448A:  MOVFF  675,67E
0448E:  MOVFF  674,67D
04492:  MOVFF  673,67C
04496:  MOVFF  672,67B
0449A:  MOVFF  679,682
0449E:  MOVFF  678,681
044A2:  MOVFF  677,680
044A6:  MOVFF  676,67F
044AA:  MOVLB  0
044AC:  GOTO   16E8
....................       }
044B0:  BRA    4520
044B2:  MOVLB  1
....................       else{
....................          smData[ch].avgSin = sinNew;
044B4:  MOVF   xCE,W
044B6:  MULLW  09
044B8:  MOVF   FF3,W
044BA:  MOVLB  6
044BC:  CLRF   x7B
044BE:  MOVWF  x7A
044C0:  MOVLW  01
044C2:  ADDWF  x7A,W
044C4:  MOVWF  01
044C6:  MOVLW  00
044C8:  ADDWFC x7B,W
044CA:  MOVWF  03
044CC:  MOVF   01,W
044CE:  ADDLW  BA
044D0:  MOVWF  FE9
044D2:  MOVLW  01
044D4:  ADDWFC 03,W
044D6:  MOVWF  FEA
044D8:  MOVFF  672,FEF
044DC:  MOVFF  673,FEC
044E0:  MOVFF  674,FEC
044E4:  MOVFF  675,FEC
....................          smData[ch].avgCos = cosNew;
044E8:  MOVLB  1
044EA:  MOVF   xCE,W
044EC:  MULLW  09
044EE:  MOVF   FF3,W
044F0:  MOVLB  6
044F2:  CLRF   x7B
044F4:  MOVWF  x7A
044F6:  MOVLW  05
044F8:  ADDWF  x7A,W
044FA:  MOVWF  01
044FC:  MOVLW  00
044FE:  ADDWFC x7B,W
04500:  MOVWF  03
04502:  MOVF   01,W
04504:  ADDLW  BA
04506:  MOVWF  FE9
04508:  MOVLW  01
0450A:  ADDWFC 03,W
0450C:  MOVWF  FEA
0450E:  MOVFF  676,FEF
04512:  MOVFF  677,FEC
04516:  MOVFF  678,FEC
0451A:  MOVFF  679,FEC
0451E:  MOVLB  0
....................       }
....................       
....................       sensor_process_data(ch);
04520:  MOVFF  1CE,67A
04524:  GOTO   367E
....................       ch = !ch;
04528:  MOVLB  1
0452A:  MOVF   xCE,F
0452C:  BZ    4532
0452E:  MOVLW  00
04530:  BRA    4534
04532:  MOVLW  01
04534:  MOVWF  xCE
....................       
....................       smData[!ch].dataReady = false;
04536:  MOVF   xCE,F
04538:  BZ    453E
0453A:  MOVLW  00
0453C:  BRA    4540
0453E:  MOVLW  01
04540:  MULLW  09
04542:  MOVF   FF3,W
04544:  MOVLB  6
04546:  CLRF   x7B
04548:  MOVWF  x7A
0454A:  MOVLW  BA
0454C:  ADDWF  x7A,W
0454E:  MOVWF  FE9
04550:  MOVLW  01
04552:  ADDWFC x7B,W
04554:  MOVWF  FEA
04556:  BCF    FEF.0
....................       smData[!ch].adcBusy = false;
04558:  MOVLB  1
0455A:  MOVF   xCE,F
0455C:  BZ    4562
0455E:  MOVLW  00
04560:  BRA    4564
04562:  MOVLW  01
04564:  MULLW  09
04566:  MOVF   FF3,W
04568:  MOVLB  6
0456A:  CLRF   x7B
0456C:  MOVWF  x7A
0456E:  MOVLW  BA
04570:  ADDWF  x7A,W
04572:  MOVWF  FE9
04574:  MOVLW  01
04576:  ADDWFC x7B,W
04578:  MOVWF  FEA
0457A:  BCF    FEF.1
....................    }
0457C:  MOVLB  0
0457E:  GOTO   A2CC (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* INITIALIZE ADC's                                                          */
.................... /*****************************************************************************/
.................... void setup_external_ADCs(){
*
008DE:  MOVLB  6
008E0:  CLRF   x72
008E2:  CLRF   x73
008E4:  CLRF   x74
008E6:  CLRF   x75
....................    unsigned int8 rc0=0;
....................    unsigned int8 rc1=0;
....................    unsigned int8 rc2=0;
....................    unsigned int8 rc3=0;
....................    
....................    for (int ch = 0; ch < 4; ch++){
008E8:  CLRF   x76
008EA:  MOVF   x76,W
008EC:  SUBLW  03
008EE:  BNC   0924
....................       rc0=reg0config;
008F0:  MOVLW  30
008F2:  MOVWF  x72
....................       rc1=reg1config;
008F4:  MOVLW  10
008F6:  MOVWF  x73
....................       rc2=reg2config;
008F8:  CLRF   x74
....................       rc3=reg3config;
008FA:  CLRF   x75
....................       
....................       ADS1220init(ch, rc0, rc1, rc2, rc3);
008FC:  MOVFF  676,678
00900:  MOVFF  672,679
00904:  MOVFF  673,67A
00908:  MOVFF  674,67B
0090C:  MOVFF  675,67C
00910:  MOVLB  0
00912:  BRA    0702
....................       delay_ms(100);
00914:  MOVLW  64
00916:  MOVLB  6
00918:  MOVWF  x78
0091A:  MOVLB  0
0091C:  RCALL  03EE
0091E:  MOVLB  6
00920:  INCF   x76,F
00922:  BRA    08EA
....................    }
....................    
....................    if (adcFilter){
00924:  MOVLB  1
00926:  BTFSS  x49.0
00928:  BRA    0A4A
....................       for (int i = 0; i < BUFFER_SIZE; i++){
0092A:  MOVLB  6
0092C:  CLRF   x77
0092E:  MOVF   x77,W
00930:  SUBLW  04
00932:  BTFSS  FD8.0
00934:  BRA    0A48
....................          ads_start_conv_all();
00936:  MOVLB  0
00938:  BRA    07A0
....................          delay_ms(50);
0093A:  MOVLW  32
0093C:  MOVLB  6
0093E:  MOVWF  x78
00940:  MOVLB  0
00942:  RCALL  03EE
....................          push(sQ_x, &sIn_x, ads_read_data(0));
00944:  MOVLB  6
00946:  CLRF   x7B
00948:  MOVLB  0
0094A:  RCALL  07D0
0094C:  MOVFF  03,67B
00950:  MOVFF  02,67A
00954:  MOVFF  01,679
00958:  MOVFF  00,678
0095C:  MOVLW  01
0095E:  MOVLB  6
00960:  MOVWF  xA5
00962:  MOVLW  66
00964:  MOVWF  xA4
00966:  MOVLW  01
00968:  MOVWF  xA7
0096A:  MOVLW  B6
0096C:  MOVWF  xA6
0096E:  MOVFF  03,6AB
00972:  MOVFF  02,6AA
00976:  MOVFF  01,6A9
0097A:  MOVFF  00,6A8
0097E:  MOVLB  0
00980:  RCALL  0878
....................          push(cQ_x, &cIn_x, ads_read_data(1));      
00982:  MOVLW  01
00984:  MOVLB  6
00986:  MOVWF  x7B
00988:  MOVLB  0
0098A:  RCALL  07D0
0098C:  MOVFF  03,67B
00990:  MOVFF  02,67A
00994:  MOVFF  01,679
00998:  MOVFF  00,678
0099C:  MOVLW  01
0099E:  MOVLB  6
009A0:  MOVWF  xA5
009A2:  MOVLW  7A
009A4:  MOVWF  xA4
009A6:  MOVLW  01
009A8:  MOVWF  xA7
009AA:  MOVLW  B7
009AC:  MOVWF  xA6
009AE:  MOVFF  03,6AB
009B2:  MOVFF  02,6AA
009B6:  MOVFF  01,6A9
009BA:  MOVFF  00,6A8
009BE:  MOVLB  0
009C0:  RCALL  0878
....................          push(sQ_y, &sIn_y, ads_read_data(2));
009C2:  MOVLW  02
009C4:  MOVLB  6
009C6:  MOVWF  x7B
009C8:  MOVLB  0
009CA:  RCALL  07D0
009CC:  MOVFF  03,67B
009D0:  MOVFF  02,67A
009D4:  MOVFF  01,679
009D8:  MOVFF  00,678
009DC:  MOVLW  01
009DE:  MOVLB  6
009E0:  MOVWF  xA5
009E2:  MOVLW  8E
009E4:  MOVWF  xA4
009E6:  MOVLW  01
009E8:  MOVWF  xA7
009EA:  MOVLW  B8
009EC:  MOVWF  xA6
009EE:  MOVFF  03,6AB
009F2:  MOVFF  02,6AA
009F6:  MOVFF  01,6A9
009FA:  MOVFF  00,6A8
009FE:  MOVLB  0
00A00:  RCALL  0878
....................          push(cQ_y, &cIn_y, ads_read_data(3));      
00A02:  MOVLW  03
00A04:  MOVLB  6
00A06:  MOVWF  x7B
00A08:  MOVLB  0
00A0A:  RCALL  07D0
00A0C:  MOVFF  03,67B
00A10:  MOVFF  02,67A
00A14:  MOVFF  01,679
00A18:  MOVFF  00,678
00A1C:  MOVLW  01
00A1E:  MOVLB  6
00A20:  MOVWF  xA5
00A22:  MOVLW  A2
00A24:  MOVWF  xA4
00A26:  MOVLW  01
00A28:  MOVWF  xA7
00A2A:  MOVLW  B9
00A2C:  MOVWF  xA6
00A2E:  MOVFF  03,6AB
00A32:  MOVFF  02,6AA
00A36:  MOVFF  01,6A9
00A3A:  MOVFF  00,6A8
00A3E:  MOVLB  0
00A40:  RCALL  0878
00A42:  MOVLB  6
00A44:  INCF   x77,F
00A46:  BRA    092E
00A48:  MOVLB  1
....................       }
....................    }
00A4A:  MOVLB  0
00A4C:  GOTO   0AB0 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE MONITOR -- sets up ADC channels                                */
.................... /*****************************************************************************/
.................... void monitor_init(){
....................    setup_adc_ports(sAN6 | sAN16 | sAN17 | sAN24 | sAN25 | sAN26 | sAN27, NO_ANALOGS_P2, VSS_VDD);
00A50:  MOVLW  00
00A52:  MOVLB  F
00A54:  MOVWF  x53
00A56:  MOVLW  40
00A58:  MOVWF  x0C
00A5A:  MOVLW  00
00A5C:  MOVWF  x14
00A5E:  MOVLW  03
00A60:  MOVWF  x1C
00A62:  MOVLW  0F
00A64:  MOVWF  x21
00A66:  MOVLW  00
00A68:  MOVWF  x29
....................    setup_adc(ADC_CLOCK_INTERNAL | ADC_TAD_MUL_255 | ADC_LEGACY_MODE | ADC_THRESHOLD_INT_DISABLED);
00A6A:  MOVLW  08
00A6C:  MOVWF  x55
00A6E:  CLRF   x56
00A70:  CLRF   x52
00A72:  SETF   x57
00A74:  CLRF   F61
00A76:  MOVLW  94
00A78:  MOVWF  x5B
....................    output_high(EN_EXC);
00A7A:  MOVLW  E8
00A7C:  MOVWF  F8B
00A7E:  BSF    F86.0
....................    set_adc_channel(vMonN15); // internal MUX
00A80:  MOVF   x5A,W
00A82:  ANDLW  3F
00A84:  MOVWF  01
00A86:  MOVLW  06
00A88:  MOVWF  x5A
00A8A:  BTFSS  x5B.7
00A8C:  BRA    0A9C
00A8E:  MOVF   01,W
00A90:  SUBLW  06
00A92:  BZ    0A9C
00A94:  BSF    x5B.0
00A96:  NOP   
00A98:  BTFSC  x5B.0
00A9A:  BRA    0A98
....................    delay_ms(10);
00A9C:  MOVLW  0A
00A9E:  MOVLB  6
00AA0:  MOVWF  x78
00AA2:  MOVLB  0
00AA4:  RCALL  03EE
....................    read_adc(ADC_START_ONLY);
00AA6:  MOVLB  F
00AA8:  BSF    x5B.0
00AAA:  NOP   
....................    setup_external_ADCs();
00AAC:  MOVLB  0
00AAE:  BRA    08DE
....................    intTimeoutReg = sensorSampleRate;
00AB0:  MOVLB  1
00AB2:  CLRF   x65
00AB4:  MOVLW  32
00AB6:  MOVWF  x64
00AB8:  MOVLB  0
00ABA:  GOTO   A2B4 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <control.h>
.................... #ifndef control
.................... #define control
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................   //  P     I     D
....................   //0.01    0.3   0.1
....................    {0.01,   0.3,  0.1, 0,0,0,0,0}, 
....................    {0.01,   0.3,  0.1, 0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... BOOLEAN adcFilter = TRUE;
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <pid.h>
.................... #ifndef pidcontroller
.................... #define pidcontroller
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................   //  P     I     D
....................   //0.01    0.3   0.1
....................    {0.01,   0.3,  0.1, 0,0,0,0,0}, 
....................    {0.01,   0.3,  0.1, 0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... BOOLEAN adcFilter = TRUE;
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float32)(unsigned int16)y;
.................... 
....................  else if (y < 10000000.0)
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
....................       res = 32768.0*(float32)l;
....................       res += (float32)(unsigned int16)y;
....................    }
.................... 
....................  else
....................   res = y;
.................... 
....................  y = y - (float32)(unsigned int16)y;
.................... 
....................  if (s)
....................   res = -res;
.................... 
....................  if (y != 0)
....................  {
....................   if (s == 1 && n == 0)
....................    res -= 1.0;
.................... 
....................   if (s == 0 && n == 1)
....................    res += 1.0;
....................  }
....................  if (x == 0)
....................     res = 0;
.................... 
....................  return (res);
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl[0]*y2 + pl[1];
.................... 
....................       r = ql[0]*y2 + ql[1];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
....................          r = -(float32)-n;
....................       else
....................          r = (float32)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* UPDATE the Control Variable (CV)                                          */
.................... /*****************************************************************************/
.................... void pid_update (channelMap ch){
*
0465C:  MOVLB  6
0465E:  MOVF   x76,W
04660:  MULLW  20
04662:  MOVF   FF3,W
04664:  CLRF   x84
04666:  MOVWF  x83
04668:  MOVLW  0C
0466A:  ADDWF  x83,W
0466C:  MOVWF  01
0466E:  MOVLW  00
04670:  ADDWFC x84,W
04672:  MOVWF  03
04674:  MOVF   01,W
04676:  ADDLW  20
04678:  MOVWF  FE9
0467A:  MOVLW  00
0467C:  ADDWFC 03,W
0467E:  MOVWF  FEA
04680:  MOVFF  FEF,6C1
04684:  MOVFF  FEC,6C2
04688:  MOVFF  FEC,6C3
0468C:  MOVFF  FEC,6C4
04690:  MOVF   x76,W
04692:  MULLW  20
04694:  MOVF   FF3,W
04696:  CLRF   x88
04698:  MOVWF  x87
0469A:  MOVLW  10
0469C:  ADDWF  x87,W
0469E:  MOVWF  01
046A0:  MOVLW  00
046A2:  ADDWFC x88,W
046A4:  MOVWF  03
046A6:  MOVF   01,W
046A8:  ADDLW  20
046AA:  MOVWF  FE9
046AC:  MOVLW  00
046AE:  ADDWFC 03,W
046B0:  MOVWF  FEA
046B2:  MOVFF  FEF,6C5
046B6:  MOVFF  FEC,01
046BA:  MOVFF  FEC,02
046BE:  MOVFF  FEC,03
046C2:  MOVFF  FEA,688
046C6:  MOVFF  FE9,687
046CA:  BSF    FD8.1
046CC:  MOVFF  03,6C8
046D0:  MOVFF  02,6C7
046D4:  MOVFF  01,6C6
046D8:  MOVLB  0
046DA:  CALL   0E08
046DE:  MOVFF  688,FEA
046E2:  MOVFF  687,FE9
046E6:  MOVFF  03,67A
046EA:  MOVFF  02,679
046EE:  MOVFF  01,678
046F2:  MOVFF  00,677
....................    float err = PID[ch].SP - PID[ch].PV;  // error = set value - measured
....................    
....................    PID[ch].I += err*PID[ch].kI;
046F6:  MOVLB  6
046F8:  MOVF   x76,W
046FA:  MULLW  20
046FC:  MOVF   FF3,W
046FE:  CLRF   x84
04700:  MOVWF  x83
04702:  MOVLW  1C
04704:  ADDWF  x83,W
04706:  MOVWF  01
04708:  MOVLW  00
0470A:  ADDWFC x84,W
0470C:  MOVWF  03
0470E:  MOVF   01,W
04710:  ADDLW  20
04712:  MOVWF  01
04714:  MOVLW  00
04716:  ADDWFC 03,F
04718:  MOVFF  01,683
0471C:  MOVFF  03,684
04720:  MOVFF  03,FEA
04724:  MOVFF  01,FE9
04728:  MOVFF  FEF,685
0472C:  MOVFF  FEC,686
04730:  MOVFF  FEC,687
04734:  MOVFF  FEC,688
04738:  MOVF   x76,W
0473A:  MULLW  20
0473C:  MOVF   FF3,W
0473E:  CLRF   x8A
04740:  MOVWF  x89
04742:  MOVLW  04
04744:  ADDWF  x89,W
04746:  MOVWF  01
04748:  MOVLW  00
0474A:  ADDWFC x8A,W
0474C:  MOVWF  03
0474E:  MOVF   01,W
04750:  ADDLW  20
04752:  MOVWF  FE9
04754:  MOVLW  00
04756:  ADDWFC 03,W
04758:  MOVWF  FEA
0475A:  MOVFF  FEF,6C6
0475E:  MOVFF  FEC,01
04762:  MOVFF  FEC,02
04766:  MOVFF  FEC,03
0476A:  MOVFF  67A,6C5
0476E:  MOVFF  679,6C4
04772:  MOVFF  678,6C3
04776:  MOVFF  677,6C2
0477A:  MOVFF  03,6C9
0477E:  MOVFF  02,6C8
04782:  MOVFF  01,6C7
04786:  MOVLB  0
04788:  CALL   0D12
0478C:  BCF    FD8.1
0478E:  MOVFF  688,6C4
04792:  MOVFF  687,6C3
04796:  MOVFF  686,6C2
0479A:  MOVFF  685,6C1
0479E:  MOVFF  03,6C8
047A2:  MOVFF  02,6C7
047A6:  MOVFF  01,6C6
047AA:  MOVFF  00,6C5
047AE:  CALL   0E08
047B2:  MOVFF  684,FEA
047B6:  MOVFF  683,FE9
047BA:  MOVFF  00,FEF
047BE:  MOVFF  01,FEC
047C2:  MOVFF  02,FEC
047C6:  MOVFF  03,FEC
....................    if (PID[ch].I > op_upper_bound) PID[ch].I = op_upper_bound; // anti-windup
047CA:  MOVLB  6
047CC:  MOVF   x76,W
047CE:  MULLW  20
047D0:  MOVF   FF3,W
047D2:  CLRF   x84
047D4:  MOVWF  x83
047D6:  MOVLW  1C
047D8:  ADDWF  x83,W
047DA:  MOVWF  01
047DC:  MOVLW  00
047DE:  ADDWFC x84,W
047E0:  MOVWF  03
047E2:  MOVF   01,W
047E4:  ADDLW  20
047E6:  MOVWF  FE9
047E8:  MOVLW  00
047EA:  ADDWFC 03,W
047EC:  MOVWF  FEA
047EE:  MOVFF  FEF,6C1
047F2:  MOVFF  FEC,684
047F6:  MOVFF  FEC,6C3
047FA:  MOVFF  FEC,6C4
047FE:  CLRF   xC0
04800:  CLRF   xBF
04802:  MOVLW  7C
04804:  MOVWF  xBE
04806:  MOVLW  84
04808:  MOVWF  xBD
0480A:  MOVFF  684,6C2
0480E:  MOVLB  0
04810:  CALL   1C9E
04814:  BNC   4848
04816:  MOVLB  6
04818:  MOVF   x76,W
0481A:  MULLW  20
0481C:  MOVF   FF3,W
0481E:  CLRF   x84
04820:  MOVWF  x83
04822:  MOVLW  1C
04824:  ADDWF  x83,W
04826:  MOVWF  01
04828:  MOVLW  00
0482A:  ADDWFC x84,W
0482C:  MOVWF  03
0482E:  MOVF   01,W
04830:  ADDLW  20
04832:  MOVWF  FE9
04834:  MOVLW  00
04836:  ADDWFC 03,W
04838:  MOVWF  FEA
0483A:  MOVLW  84
0483C:  MOVWF  FEF
0483E:  MOVLW  7C
04840:  MOVWF  FEC
04842:  CLRF   FEC
04844:  CLRF   FEC
04846:  BRA    48C4
....................    else if (PID[ch].I < op_lower_bound) PID[ch].I = op_lower_bound;
04848:  MOVLB  6
0484A:  MOVF   x76,W
0484C:  MULLW  20
0484E:  MOVF   FF3,W
04850:  CLRF   x84
04852:  MOVWF  x83
04854:  MOVLW  1C
04856:  ADDWF  x83,W
04858:  MOVWF  01
0485A:  MOVLW  00
0485C:  ADDWFC x84,W
0485E:  MOVWF  03
04860:  MOVF   01,W
04862:  ADDLW  20
04864:  MOVWF  FE9
04866:  MOVLW  00
04868:  ADDWFC 03,W
0486A:  MOVWF  FEA
0486C:  MOVFF  FEF,6BD
04870:  MOVFF  FEC,684
04874:  MOVFF  FEC,6BF
04878:  MOVFF  FEC,6C0
0487C:  MOVFF  684,6BE
04880:  CLRF   xC4
04882:  CLRF   xC3
04884:  MOVLW  FC
04886:  MOVWF  xC2
04888:  MOVLW  84
0488A:  MOVWF  xC1
0488C:  MOVLB  0
0488E:  CALL   1C9E
04892:  BNC   48C6
04894:  MOVLB  6
04896:  MOVF   x76,W
04898:  MULLW  20
0489A:  MOVF   FF3,W
0489C:  CLRF   x84
0489E:  MOVWF  x83
048A0:  MOVLW  1C
048A2:  ADDWF  x83,W
048A4:  MOVWF  01
048A6:  MOVLW  00
048A8:  ADDWFC x84,W
048AA:  MOVWF  03
048AC:  MOVF   01,W
048AE:  ADDLW  20
048B0:  MOVWF  FE9
048B2:  MOVLW  00
048B4:  ADDWFC 03,W
048B6:  MOVWF  FEA
048B8:  MOVLW  84
048BA:  MOVWF  FEF
048BC:  MOVLW  FC
048BE:  MOVWF  FEC
048C0:  CLRF   FEC
048C2:  CLRF   FEC
048C4:  MOVLB  0
....................    
....................    float P = err * PID[ch].kP;  // proportional value
....................    
....................    float D = PID[ch].kD * (PID[ch].PV - PID[ch].PVold);  // derivative value
048C6:  MOVLB  6
048C8:  MOVF   x76,W
048CA:  MULLW  20
048CC:  MOVF   FF3,W
048CE:  CLRF   x84
048D0:  MOVWF  x83
048D2:  MOVLW  20
048D4:  ADDWF  x83,W
048D6:  MOVWF  FE9
048D8:  MOVLW  00
048DA:  ADDWFC x84,W
048DC:  MOVWF  FEA
048DE:  MOVFF  FEF,6C6
048E2:  MOVFF  FEC,01
048E6:  MOVFF  FEC,02
048EA:  MOVFF  FEC,03
048EE:  MOVFF  67A,6C5
048F2:  MOVFF  679,6C4
048F6:  MOVFF  678,6C3
048FA:  MOVFF  677,6C2
048FE:  MOVFF  03,6C9
04902:  MOVFF  02,6C8
04906:  MOVFF  01,6C7
0490A:  MOVLB  0
0490C:  CALL   0D12
04910:  MOVFF  03,67E
04914:  MOVFF  02,67D
04918:  MOVFF  01,67C
0491C:  MOVFF  00,67B
04920:  MOVLB  6
04922:  MOVF   x76,W
04924:  MULLW  20
04926:  MOVF   FF3,W
04928:  CLRF   x86
0492A:  MOVWF  x85
0492C:  MOVLW  08
0492E:  ADDWF  x85,W
04930:  MOVWF  01
04932:  MOVLW  00
04934:  ADDWFC x86,W
04936:  MOVWF  03
04938:  MOVF   01,W
0493A:  ADDLW  20
0493C:  MOVWF  FE9
0493E:  MOVLW  00
04940:  ADDWFC 03,W
04942:  MOVWF  FEA
04944:  MOVFF  FEF,685
04948:  MOVFF  FEC,686
0494C:  MOVFF  FEC,687
04950:  MOVFF  FEC,688
04954:  MOVF   x76,W
04956:  MULLW  20
04958:  MOVF   FF3,W
0495A:  CLRF   x8A
0495C:  MOVWF  x89
0495E:  MOVLW  10
04960:  ADDWF  x89,W
04962:  MOVWF  01
04964:  MOVLW  00
04966:  ADDWFC x8A,W
04968:  MOVWF  03
0496A:  MOVF   01,W
0496C:  ADDLW  20
0496E:  MOVWF  FE9
04970:  MOVLW  00
04972:  ADDWFC 03,W
04974:  MOVWF  FEA
04976:  MOVFF  FEF,6C1
0497A:  MOVFF  FEC,6C2
0497E:  MOVFF  FEC,6C3
04982:  MOVFF  FEC,6C4
04986:  MOVF   x76,W
04988:  MULLW  20
0498A:  MOVF   FF3,W
0498C:  CLRF   x8E
0498E:  MOVWF  x8D
04990:  MOVLW  14
04992:  ADDWF  x8D,W
04994:  MOVWF  01
04996:  MOVLW  00
04998:  ADDWFC x8E,W
0499A:  MOVWF  03
0499C:  MOVF   01,W
0499E:  ADDLW  20
049A0:  MOVWF  FE9
049A2:  MOVLW  00
049A4:  ADDWFC 03,W
049A6:  MOVWF  FEA
049A8:  MOVFF  FEF,6C5
049AC:  MOVFF  FEC,01
049B0:  MOVFF  FEC,02
049B4:  MOVFF  FEC,03
049B8:  MOVFF  FEA,68E
049BC:  MOVFF  FE9,68D
049C0:  BSF    FD8.1
049C2:  MOVFF  03,6C8
049C6:  MOVFF  02,6C7
049CA:  MOVFF  01,6C6
049CE:  MOVLB  0
049D0:  CALL   0E08
049D4:  MOVFF  68E,FEA
049D8:  MOVFF  68D,FE9
049DC:  MOVFF  688,6C5
049E0:  MOVFF  687,6C4
049E4:  MOVFF  686,6C3
049E8:  MOVFF  685,6C2
049EC:  MOVFF  03,6C9
049F0:  MOVFF  02,6C8
049F4:  MOVFF  01,6C7
049F8:  MOVFF  00,6C6
049FC:  CALL   0D12
04A00:  MOVFF  03,682
04A04:  MOVFF  02,681
04A08:  MOVFF  01,680
04A0C:  MOVFF  00,67F
....................    
....................    PID[ch].CV = P + PID[ch].I + D;  // new control variable
04A10:  MOVLB  6
04A12:  MOVF   x76,W
04A14:  MULLW  20
04A16:  MOVF   FF3,W
04A18:  CLRF   x84
04A1A:  MOVWF  x83
04A1C:  MOVLW  18
04A1E:  ADDWF  x83,W
04A20:  MOVWF  01
04A22:  MOVLW  00
04A24:  ADDWFC x84,W
04A26:  MOVWF  03
04A28:  MOVF   01,W
04A2A:  ADDLW  20
04A2C:  MOVWF  01
04A2E:  MOVLW  00
04A30:  ADDWFC 03,F
04A32:  MOVFF  01,683
04A36:  MOVFF  03,684
04A3A:  MOVF   x76,W
04A3C:  MULLW  20
04A3E:  MOVF   FF3,W
04A40:  CLRF   x86
04A42:  MOVWF  x85
04A44:  MOVLW  1C
04A46:  ADDWF  x85,W
04A48:  MOVWF  01
04A4A:  MOVLW  00
04A4C:  ADDWFC x86,W
04A4E:  MOVWF  03
04A50:  MOVF   01,W
04A52:  ADDLW  20
04A54:  MOVWF  FE9
04A56:  MOVLW  00
04A58:  ADDWFC 03,W
04A5A:  MOVWF  FEA
04A5C:  MOVFF  FEF,6C5
04A60:  MOVFF  FEC,01
04A64:  MOVFF  FEC,02
04A68:  MOVFF  FEC,03
04A6C:  MOVFF  FEA,686
04A70:  MOVFF  FE9,685
04A74:  BCF    FD8.1
04A76:  MOVFF  67E,6C4
04A7A:  MOVFF  67D,6C3
04A7E:  MOVFF  67C,6C2
04A82:  MOVFF  67B,6C1
04A86:  MOVFF  03,6C8
04A8A:  MOVFF  02,6C7
04A8E:  MOVFF  01,6C6
04A92:  MOVLB  0
04A94:  CALL   0E08
04A98:  MOVFF  686,FEA
04A9C:  MOVFF  685,FE9
04AA0:  MOVFF  03,68A
04AA4:  MOVFF  02,689
04AA8:  MOVFF  01,688
04AAC:  MOVFF  00,687
04AB0:  BCF    FD8.1
04AB2:  MOVFF  03,6C4
04AB6:  MOVFF  02,6C3
04ABA:  MOVFF  01,6C2
04ABE:  MOVFF  00,6C1
04AC2:  MOVFF  682,6C8
04AC6:  MOVFF  681,6C7
04ACA:  MOVFF  680,6C6
04ACE:  MOVFF  67F,6C5
04AD2:  CALL   0E08
04AD6:  MOVFF  684,FEA
04ADA:  MOVFF  683,FE9
04ADE:  MOVFF  00,FEF
04AE2:  MOVFF  01,FEC
04AE6:  MOVFF  02,FEC
04AEA:  MOVFF  03,FEC
....................    if (PID[ch].CV > op_upper_bound) PID[ch].CV = op_upper_bound; // limit positive output
04AEE:  MOVLB  6
04AF0:  MOVF   x76,W
04AF2:  MULLW  20
04AF4:  MOVF   FF3,W
04AF6:  CLRF   x84
04AF8:  MOVWF  x83
04AFA:  MOVLW  18
04AFC:  ADDWF  x83,W
04AFE:  MOVWF  01
04B00:  MOVLW  00
04B02:  ADDWFC x84,W
04B04:  MOVWF  03
04B06:  MOVF   01,W
04B08:  ADDLW  20
04B0A:  MOVWF  FE9
04B0C:  MOVLW  00
04B0E:  ADDWFC 03,W
04B10:  MOVWF  FEA
04B12:  MOVFF  FEF,6C1
04B16:  MOVFF  FEC,684
04B1A:  MOVFF  FEC,6C3
04B1E:  MOVFF  FEC,6C4
04B22:  CLRF   xC0
04B24:  CLRF   xBF
04B26:  MOVLW  7C
04B28:  MOVWF  xBE
04B2A:  MOVLW  84
04B2C:  MOVWF  xBD
04B2E:  MOVFF  684,6C2
04B32:  MOVLB  0
04B34:  CALL   1C9E
04B38:  BNC   4B6C
04B3A:  MOVLB  6
04B3C:  MOVF   x76,W
04B3E:  MULLW  20
04B40:  MOVF   FF3,W
04B42:  CLRF   x84
04B44:  MOVWF  x83
04B46:  MOVLW  18
04B48:  ADDWF  x83,W
04B4A:  MOVWF  01
04B4C:  MOVLW  00
04B4E:  ADDWFC x84,W
04B50:  MOVWF  03
04B52:  MOVF   01,W
04B54:  ADDLW  20
04B56:  MOVWF  FE9
04B58:  MOVLW  00
04B5A:  ADDWFC 03,W
04B5C:  MOVWF  FEA
04B5E:  MOVLW  84
04B60:  MOVWF  FEF
04B62:  MOVLW  7C
04B64:  MOVWF  FEC
04B66:  CLRF   FEC
04B68:  CLRF   FEC
04B6A:  BRA    4BE8
....................    else if (PID[ch].CV < op_lower_bound) PID[ch].CV = op_lower_bound; // limit negative output
04B6C:  MOVLB  6
04B6E:  MOVF   x76,W
04B70:  MULLW  20
04B72:  MOVF   FF3,W
04B74:  CLRF   x84
04B76:  MOVWF  x83
04B78:  MOVLW  18
04B7A:  ADDWF  x83,W
04B7C:  MOVWF  01
04B7E:  MOVLW  00
04B80:  ADDWFC x84,W
04B82:  MOVWF  03
04B84:  MOVF   01,W
04B86:  ADDLW  20
04B88:  MOVWF  FE9
04B8A:  MOVLW  00
04B8C:  ADDWFC 03,W
04B8E:  MOVWF  FEA
04B90:  MOVFF  FEF,6BD
04B94:  MOVFF  FEC,684
04B98:  MOVFF  FEC,6BF
04B9C:  MOVFF  FEC,6C0
04BA0:  MOVFF  684,6BE
04BA4:  CLRF   xC4
04BA6:  CLRF   xC3
04BA8:  MOVLW  FC
04BAA:  MOVWF  xC2
04BAC:  MOVLW  84
04BAE:  MOVWF  xC1
04BB0:  MOVLB  0
04BB2:  CALL   1C9E
04BB6:  BNC   4BE8
04BB8:  MOVLB  6
04BBA:  MOVF   x76,W
04BBC:  MULLW  20
04BBE:  MOVF   FF3,W
04BC0:  CLRF   x84
04BC2:  MOVWF  x83
04BC4:  MOVLW  18
04BC6:  ADDWF  x83,W
04BC8:  MOVWF  01
04BCA:  MOVLW  00
04BCC:  ADDWFC x84,W
04BCE:  MOVWF  03
04BD0:  MOVF   01,W
04BD2:  ADDLW  20
04BD4:  MOVWF  FE9
04BD6:  MOVLW  00
04BD8:  ADDWFC 03,W
04BDA:  MOVWF  FEA
04BDC:  MOVLW  84
04BDE:  MOVWF  FEF
04BE0:  MOVLW  FC
04BE2:  MOVWF  FEC
04BE4:  CLRF   FEC
04BE6:  CLRF   FEC
04BE8:  MOVLB  0
04BEA:  GOTO   4C62 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PID Task - looks for change to PV and updates CV                          */
.................... /*****************************************************************************/
.................... void pid_task(channelMap ch){
....................    static int index = 0;
....................    if (PID[ch].SP != PID[ch].PV) pid_update(ch);
04BEE:  MOVLB  6
04BF0:  MOVF   x75,W
04BF2:  MULLW  20
04BF4:  MOVF   FF3,W
04BF6:  CLRF   x77
04BF8:  MOVWF  x76
04BFA:  MOVLW  0C
04BFC:  ADDWF  x76,W
04BFE:  MOVWF  01
04C00:  MOVLW  00
04C02:  ADDWFC x77,W
04C04:  MOVWF  03
04C06:  MOVF   01,W
04C08:  ADDLW  20
04C0A:  MOVWF  FE9
04C0C:  MOVLW  00
04C0E:  ADDWFC 03,W
04C10:  MOVWF  FEA
04C12:  MOVFF  FEF,6BD
04C16:  MOVFF  FEC,6BE
04C1A:  MOVFF  FEC,6BF
04C1E:  MOVFF  FEC,6C0
04C22:  MOVF   x75,W
04C24:  MULLW  20
04C26:  MOVF   FF3,W
04C28:  CLRF   x7B
04C2A:  MOVWF  x7A
04C2C:  MOVLW  10
04C2E:  ADDWF  x7A,W
04C30:  MOVWF  01
04C32:  MOVLW  00
04C34:  ADDWFC x7B,W
04C36:  MOVWF  03
04C38:  MOVF   01,W
04C3A:  ADDLW  20
04C3C:  MOVWF  FE9
04C3E:  MOVLW  00
04C40:  ADDWFC 03,W
04C42:  MOVWF  FEA
04C44:  MOVFF  FEF,6C1
04C48:  MOVFF  FEC,6C2
04C4C:  MOVFF  FEC,6C3
04C50:  MOVFF  FEC,6C4
04C54:  MOVLB  0
04C56:  CALL   1C9E
04C5A:  BZ    4C62
04C5C:  MOVFF  675,676
04C60:  BRA    465C
....................    if ((index++) >= numChannels) index = 0;
04C62:  MOVLB  1
04C64:  MOVF   xCF,W
04C66:  INCF   xCF,F
04C68:  SUBLW  01
04C6A:  BC    4C6E
04C6C:  CLRF   xCF
04C6E:  MOVLB  0
04C70:  GOTO   4D5C (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... #pin_select SCK1=PIN_C3
.................... #pin_select SDO1=PIN_C2
.................... #use spi (MASTER, SPI1, BAUD=100000, MODE=2, STREAM=SPI_ctrl)
*
00ABE:  CLRF   03
00AC0:  MOVF   F91,W
00AC2:  MOVFF  677,F91
00AC6:  RRCF   F94,W
00AC8:  BNC   0AC6
00ACA:  MOVF   F91,W
00ACC:  MOVWF  02
00ACE:  MOVFF  676,F91
00AD2:  RRCF   F94,W
00AD4:  BNC   0AD2
00AD6:  MOVF   F91,W
00AD8:  MOVWF  01
00ADA:  MOVFF  675,F91
00ADE:  RRCF   F94,W
00AE0:  BNC   0ADE
00AE2:  MOVFF  F91,00
00AE6:  RETURN 0
.................... 
.................... #define DACfullScale 655.35 // full scale/100 because CV = %
.................... 
.................... /*****************************************************************************/
.................... /*  Inverts the output voltage ( -180V - 0V )                                */ 
.................... /*****************************************************************************/
.................... void invert_voltage(channelMap ch, BOOLEAN inv_v){
....................    if ( inv_v ) {
*
045B8:  MOVLB  6
045BA:  MOVF   x76,F
045BC:  BZ    460C
....................       if (chMap[0] == ch) output_low(INV_HVX);
045BE:  MOVLW  00
045C0:  MOVLB  0
045C2:  BTFSC  x60.0
045C4:  MOVLW  01
045C6:  MOVLB  6
045C8:  SUBWF  x75,W
045CA:  BNZ   45D2
045CC:  MOVLW  C4
045CE:  MOVWF  F88
045D0:  BCF    F83.4
....................       if (chMap[1] == ch) output_low(INV_HVY);
045D2:  MOVLW  00
045D4:  MOVLB  0
045D6:  BTFSC  x60.1
045D8:  MOVLW  01
045DA:  MOVLB  6
045DC:  SUBWF  x75,W
045DE:  BNZ   45E6
045E0:  MOVLW  C4
045E2:  MOVWF  F88
045E4:  BCF    F83.5
....................       dacVals[ch].invV = TRUE;
045E6:  MOVF   x75,W
045E8:  MULLW  03
045EA:  MOVF   FF3,W
045EC:  CLRF   x78
045EE:  MOVWF  x77
045F0:  MOVLW  02
045F2:  ADDWF  x77,W
045F4:  MOVWF  01
045F6:  MOVLW  00
045F8:  ADDWFC x78,W
045FA:  MOVWF  03
045FC:  MOVF   01,W
045FE:  ADDLW  4A
04600:  MOVWF  FE9
04602:  MOVLW  01
04604:  ADDWFC 03,W
04606:  MOVWF  FEA
04608:  BSF    FEF.0
....................    }
0460A:  BRA    4658
....................    else {
....................       if (chMap[0] == ch) output_high(INV_HVX);
0460C:  MOVLW  00
0460E:  MOVLB  0
04610:  BTFSC  x60.0
04612:  MOVLW  01
04614:  MOVLB  6
04616:  SUBWF  x75,W
04618:  BNZ   4620
0461A:  MOVLW  C4
0461C:  MOVWF  F88
0461E:  BSF    F83.4
....................       if (chMap[1] == ch) output_high(INV_HVY);
04620:  MOVLW  00
04622:  MOVLB  0
04624:  BTFSC  x60.1
04626:  MOVLW  01
04628:  MOVLB  6
0462A:  SUBWF  x75,W
0462C:  BNZ   4634
0462E:  MOVLW  C4
04630:  MOVWF  F88
04632:  BSF    F83.5
....................       dacVals[ch].invV = FALSE;
04634:  MOVF   x75,W
04636:  MULLW  03
04638:  MOVF   FF3,W
0463A:  CLRF   x78
0463C:  MOVWF  x77
0463E:  MOVLW  02
04640:  ADDWF  x77,W
04642:  MOVWF  01
04644:  MOVLW  00
04646:  ADDWFC x78,W
04648:  MOVWF  03
0464A:  MOVF   01,W
0464C:  ADDLW  4A
0464E:  MOVWF  FE9
04650:  MOVLW  01
04652:  ADDWFC 03,W
04654:  MOVWF  FEA
04656:  BCF    FEF.0
....................    }
04658:  MOVLB  0
0465A:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  Nano DAC's have a 16bit serial shift register. Data is sync'ed to output */ 
.................... /*****************************************************************************/
.................... void set_nanoDAC_outputs(channelMap ch){
*
04C74:  MOVLB  6
04C76:  CLRF   x74
04C78:  CLRF   x73
....................    unsigned int16 txData = 0;
....................    
....................    // use manualOutputValues if channel is manual mode
....................    // else, use PID control variable
....................    if (chMode[ch] == MANUAL){
04C7A:  MOVFF  672,67F
04C7E:  CLRF   x81
04C80:  MOVLW  61
04C82:  MOVWF  x80
04C84:  MOVLB  0
04C86:  RCALL  4582
04C88:  MOVF   01,F
04C8A:  BNZ   4D56
....................       if ( manualOutputValues[ch] < 0) invert_voltage(ch, TRUE); 
04C8C:  MOVLB  6
04C8E:  MOVF   x72,W
04C90:  MULLW  04
04C92:  MOVF   FF3,W
04C94:  CLRF   03
04C96:  ADDLW  50
04C98:  MOVWF  FE9
04C9A:  MOVLW  01
04C9C:  ADDWFC 03,W
04C9E:  MOVWF  FEA
04CA0:  MOVFF  FEF,6BD
04CA4:  MOVFF  FEC,6BE
04CA8:  MOVFF  FEC,6BF
04CAC:  MOVFF  FEC,6C0
04CB0:  CLRF   xC4
04CB2:  CLRF   xC3
04CB4:  CLRF   xC2
04CB6:  CLRF   xC1
04CB8:  MOVLB  0
04CBA:  CALL   1C9E
04CBE:  BNC   4CD0
04CC0:  MOVFF  672,675
04CC4:  MOVLW  01
04CC6:  MOVLB  6
04CC8:  MOVWF  x76
04CCA:  MOVLB  0
04CCC:  RCALL  45B8
04CCE:  BRA    4CDC
....................       else                             invert_voltage(ch, FALSE);
04CD0:  MOVFF  672,675
04CD4:  MOVLB  6
04CD6:  CLRF   x76
04CD8:  MOVLB  0
04CDA:  RCALL  45B8
....................       
....................       txData = (unsigned int16)(abs(manualOutputValues[ch]) * DACfullScale);
04CDC:  MOVLB  6
04CDE:  MOVF   x72,W
04CE0:  MULLW  04
04CE2:  MOVF   FF3,W
04CE4:  CLRF   03
04CE6:  ADDLW  50
04CE8:  MOVWF  FE9
04CEA:  MOVLW  01
04CEC:  ADDWFC 03,W
04CEE:  MOVWF  FEA
04CF0:  MOVFF  FEF,00
04CF4:  MOVFF  FEC,01
04CF8:  MOVFF  FEC,02
04CFC:  MOVFF  FEC,03
04D00:  BCF    01.7
04D02:  MOVFF  03,678
04D06:  MOVFF  02,677
04D0A:  MOVFF  01,676
04D0E:  MOVFF  00,675
04D12:  MOVFF  03,6C5
04D16:  MOVFF  02,6C4
04D1A:  MOVFF  01,6C3
04D1E:  MOVFF  00,6C2
04D22:  MOVLW  66
04D24:  MOVWF  xC9
04D26:  MOVLW  D6
04D28:  MOVWF  xC8
04D2A:  MOVLW  23
04D2C:  MOVWF  xC7
04D2E:  MOVLW  88
04D30:  MOVWF  xC6
04D32:  MOVLB  0
04D34:  CALL   0D12
04D38:  MOVFF  03,6C0
04D3C:  MOVFF  02,6BF
04D40:  MOVFF  01,6BE
04D44:  MOVFF  00,6BD
04D48:  CALL   2692
04D4C:  MOVFF  02,674
04D50:  MOVFF  01,673
....................    }
04D54:  BRA    4E46
....................    else {
....................       pid_task(ch);
04D56:  MOVFF  672,675
04D5A:  BRA    4BEE
....................       if ( PID[(int)ch].CV < 0 ) invert_voltage(ch, TRUE); 
04D5C:  MOVLB  6
04D5E:  MOVF   x72,W
04D60:  MULLW  20
04D62:  MOVF   FF3,W
04D64:  CLRF   x76
04D66:  MOVWF  x75
04D68:  MOVLW  18
04D6A:  ADDWF  x75,W
04D6C:  MOVWF  01
04D6E:  MOVLW  00
04D70:  ADDWFC x76,W
04D72:  MOVWF  03
04D74:  MOVF   01,W
04D76:  ADDLW  20
04D78:  MOVWF  FE9
04D7A:  MOVLW  00
04D7C:  ADDWFC 03,W
04D7E:  MOVWF  FEA
04D80:  MOVFF  FEF,6BD
04D84:  MOVFF  FEC,6BE
04D88:  MOVFF  FEC,6BF
04D8C:  MOVFF  FEC,6C0
04D90:  CLRF   xC4
04D92:  CLRF   xC3
04D94:  CLRF   xC2
04D96:  CLRF   xC1
04D98:  MOVLB  0
04D9A:  CALL   1C9E
04D9E:  BNC   4DB0
04DA0:  MOVFF  672,675
04DA4:  MOVLW  01
04DA6:  MOVLB  6
04DA8:  MOVWF  x76
04DAA:  MOVLB  0
04DAC:  RCALL  45B8
04DAE:  BRA    4DBE
....................       else                       invert_voltage(ch, FALSE);
04DB0:  MOVFF  672,675
04DB4:  MOVLB  6
04DB6:  CLRF   x76
04DB8:  MOVLB  0
04DBA:  CALL   45B8
....................       
....................       txData = (unsigned int16)(abs(PID[(int)ch].CV) * DACfullScale);
04DBE:  MOVLB  6
04DC0:  MOVF   x72,W
04DC2:  MULLW  20
04DC4:  MOVF   FF3,W
04DC6:  CLRF   x76
04DC8:  MOVWF  x75
04DCA:  MOVLW  18
04DCC:  ADDWF  x75,W
04DCE:  MOVWF  01
04DD0:  MOVLW  00
04DD2:  ADDWFC x76,W
04DD4:  MOVWF  03
04DD6:  MOVF   01,W
04DD8:  ADDLW  20
04DDA:  MOVWF  FE9
04DDC:  MOVLW  00
04DDE:  ADDWFC 03,W
04DE0:  MOVWF  FEA
04DE2:  MOVFF  FEF,00
04DE6:  MOVFF  FEC,01
04DEA:  MOVFF  FEC,02
04DEE:  MOVFF  FEC,03
04DF2:  BCF    01.7
04DF4:  MOVFF  03,678
04DF8:  MOVFF  02,677
04DFC:  MOVFF  01,676
04E00:  MOVFF  00,675
04E04:  MOVFF  03,6C5
04E08:  MOVFF  02,6C4
04E0C:  MOVFF  01,6C3
04E10:  MOVFF  00,6C2
04E14:  MOVLW  66
04E16:  MOVWF  xC9
04E18:  MOVLW  D6
04E1A:  MOVWF  xC8
04E1C:  MOVLW  23
04E1E:  MOVWF  xC7
04E20:  MOVLW  88
04E22:  MOVWF  xC6
04E24:  MOVLB  0
04E26:  CALL   0D12
04E2A:  MOVFF  03,6C0
04E2E:  MOVFF  02,6BF
04E32:  MOVFF  01,6BE
04E36:  MOVFF  00,6BD
04E3A:  CALL   2692
04E3E:  MOVFF  02,674
04E42:  MOVFF  01,673
....................    }
....................    
....................    dacVals[ch].val = txData;
04E46:  MOVLB  6
04E48:  MOVF   x72,W
04E4A:  MULLW  03
04E4C:  MOVF   FF3,W
04E4E:  CLRF   x76
04E50:  MOVWF  x75
04E52:  MOVLW  4A
04E54:  ADDWF  x75,W
04E56:  MOVWF  FE9
04E58:  MOVLW  01
04E5A:  ADDWFC x76,W
04E5C:  MOVWF  FEA
04E5E:  MOVFF  674,FEC
04E62:  MOVF   FED,F
04E64:  MOVFF  673,FEF
....................    
....................    // use channel map to decide which outputs channels to update
....................    // strobe _sync low to push data to the outputs
....................    if (chMap[0] == ch) output_high(_SYNC_X);
04E68:  MOVLW  00
04E6A:  MOVLB  0
04E6C:  BTFSC  x60.0
04E6E:  MOVLW  01
04E70:  MOVLB  6
04E72:  SUBWF  x72,W
04E74:  BNZ   4E7C
04E76:  MOVLW  E8
04E78:  MOVWF  F8B
04E7A:  BSF    F86.2
....................    if (chMap[1] == ch) output_high(_SYNC_Y);
04E7C:  MOVLW  00
04E7E:  MOVLB  0
04E80:  BTFSC  x60.1
04E82:  MOVLW  01
04E84:  MOVLB  6
04E86:  SUBWF  x72,W
04E88:  BNZ   4E90
04E8A:  MOVLW  E8
04E8C:  MOVWF  F8B
04E8E:  BSF    F86.1
....................    
....................    delay_ms(1);
04E90:  MOVLW  01
04E92:  MOVWF  x78
04E94:  MOVLB  0
04E96:  CALL   03EE
....................    
....................    if (chMap[0] == ch) output_low(_SYNC_X);
04E9A:  MOVLW  00
04E9C:  BTFSC  x60.0
04E9E:  MOVLW  01
04EA0:  MOVLB  6
04EA2:  SUBWF  x72,W
04EA4:  BNZ   4EAC
04EA6:  MOVLW  E8
04EA8:  MOVWF  F8B
04EAA:  BCF    F86.2
....................    if (chMap[1] == ch) output_low(_SYNC_Y);
04EAC:  MOVLW  00
04EAE:  MOVLB  0
04EB0:  BTFSC  x60.1
04EB2:  MOVLW  01
04EB4:  MOVLB  6
04EB6:  SUBWF  x72,W
04EB8:  BNZ   4EC0
04EBA:  MOVLW  E8
04EBC:  MOVWF  F8B
04EBE:  BCF    F86.1
....................    delay_ms(1);
04EC0:  MOVLW  01
04EC2:  MOVWF  x78
04EC4:  MOVLB  0
04EC6:  CALL   03EE
....................    
....................    // shift 16 bits of data
....................    spi_xfer(SPI_ctrl, txData, 24);
04ECA:  MOVLB  6
04ECC:  CLRF   x78
04ECE:  CLRF   x77
04ED0:  MOVFF  674,676
04ED4:  MOVFF  673,675
04ED8:  MOVLB  0
04EDA:  CALL   0ABE
....................    delay_ms(1);
04EDE:  MOVLW  01
04EE0:  MOVLB  6
04EE2:  MOVWF  x78
04EE4:  MOVLB  0
04EE6:  CALL   03EE
....................    
....................    if (chMap[0] == ch) output_high(_SYNC_X);
04EEA:  MOVLW  00
04EEC:  BTFSC  x60.0
04EEE:  MOVLW  01
04EF0:  MOVLB  6
04EF2:  SUBWF  x72,W
04EF4:  BNZ   4EFC
04EF6:  MOVLW  E8
04EF8:  MOVWF  F8B
04EFA:  BSF    F86.2
....................    if (chMap[1] == ch) output_high(_SYNC_Y);
04EFC:  MOVLW  00
04EFE:  MOVLB  0
04F00:  BTFSC  x60.1
04F02:  MOVLW  01
04F04:  MOVLB  6
04F06:  SUBWF  x72,W
04F08:  BNZ   4F10
04F0A:  MOVLW  E8
04F0C:  MOVWF  F8B
04F0E:  BSF    F86.1
04F10:  MOVLB  0
04F12:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  control task sets up the outputs channels                                */ 
.................... /*****************************************************************************/
.................... void control_task(){
....................    static int state = 0;
....................    
....................    switch (state)
04F14:  MOVLB  1
04F16:  MOVF   xD0,W
04F18:  XORLW  00
04F1A:  MOVLB  0
04F1C:  BZ    4F24
04F1E:  XORLW  01
04F20:  BZ    4F36
04F22:  BRA    4F46
....................    {
....................       case 0:
....................          set_nanoDAC_outputs(chX);
04F24:  MOVLB  6
04F26:  CLRF   x72
04F28:  MOVLB  0
04F2A:  RCALL  4C74
....................          state = 1;
04F2C:  MOVLW  01
04F2E:  MOVLB  1
04F30:  MOVWF  xD0
....................       break;
04F32:  MOVLB  0
04F34:  BRA    4F46
....................       case 1:
....................          set_nanoDAC_outputs(chY);
04F36:  MOVLW  01
04F38:  MOVLB  6
04F3A:  MOVWF  x72
04F3C:  MOVLB  0
04F3E:  RCALL  4C74
....................          state = 0;
04F40:  MOVLB  1
04F42:  CLRF   xD0
....................       break;
04F44:  MOVLB  0
....................    }
04F46:  GOTO   A2DE (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  control task sets up the outputs channels                                */ 
.................... /*****************************************************************************/
.................... void control_init(){
....................    spi_xfer(SPI_ctrl, 0, 24);
*
00AE8:  MOVLB  6
00AEA:  CLRF   x78
00AEC:  CLRF   x77
00AEE:  CLRF   x76
00AF0:  CLRF   x75
00AF2:  MOVLB  0
00AF4:  RCALL  0ABE
....................    output_low(_SYNC_X);
00AF6:  MOVLW  E8
00AF8:  MOVWF  F8B
00AFA:  BCF    F86.2
....................    output_low(_SYNC_Y);
00AFC:  MOVWF  F8B
00AFE:  BCF    F86.1
....................    output_high(_SYNC_X);
00B00:  MOVWF  F8B
00B02:  BSF    F86.2
....................    output_high(_SYNC_Y);
00B04:  MOVWF  F8B
00B06:  BSF    F86.1
00B08:  GOTO   A2B8 (RETURN)
.................... }
.................... #endif
.................... 
.................... #include <serialport.h>
.................... #ifndef serialPort
.................... #define serialPort
.................... #include <cmdBuffer.h>
.................... #ifndef cmd_buffer
.................... #define cmd_buffer
.................... 
.................... /*****************************************************************************/
.................... /* DIFCS COMMAND BUFFER                                                      */
.................... /* The beginning of a message is signified by an address record. The address */
.................... /* is 4 characters. The first 2 are the hardware identifier (TC - temperature*/
.................... /* controller, DC - difics controller, etc..) The second 2 characters dev-   */
.................... /* ice ID... Valid values are 00 thru 0F. A device ID of FF writes to all    */
.................... /* boards. This might be used to feed angles data to all listeners.          */
.................... /*****************************************************************************/
.................... 
.................... // t,p0,p1,p2,p3,p4,p5,p6
.................... // t is the start character, p0 is the address, p1 is command, p2-6 are params
.................... // these characters used for storing messages
.................... 
.................... #define startChr '~' // start character. Also diagnostic command type
.................... #define diagCmdType startChr
.................... #define endChr '\n'
.................... #define delimiter ','
.................... #define ignoreChr1 '\r'
.................... #define ignoreChr2 ' '
.................... #define noRecordFound (char)0xFF
.................... 
.................... #define numRecords 4
.................... #define numParam 7
.................... #define lenParam 25
.................... 
.................... #define useSerial
.................... //#define useTCPIP
.................... 
.................... typedef enum cmdMode {tcp, ser};
.................... 
.................... // this structure holds a command. This is used by the serial routine as well
.................... // as the TCP routine to store an incoming command + parameters
.................... // in the case of TCP socket id is also passed in this structure
.................... typedef struct cmd 
.................... {
....................    BOOLEAN full;        // if full, command is ready to execute
....................    unsigned int8 chrIndex;
....................    unsigned int8 paramIndex;
....................    unsigned int8 recReadIndex;
....................    unsigned int8 recWriteIndex;
....................    #ifdef useTCPIP
....................    TCP_SOCKET s;              // socket ID for TCP commands 
....................    #endif
....................    char t;
....................    char p[numParam][lenParam];   // only used with ~ type command
.................... };
.................... 
.................... #ifdef useSerial
.................... struct cmd SERcmd[numRecords]; // holds serial command 
.................... unsigned int8 SRI = 0; //usb readindex
.................... unsigned int8 SWI = 0; //usb write index
.................... #endif
.................... 
.................... #ifdef useTCPIP
.................... struct cmd TCPcmd[numRecords]; // holds TCP command
.................... unsigned int8 TRI = 0; //usb readindex
.................... unsigned int8 TWI = 0; //usb write index
.................... #endif
.................... 
.................... char retData[100]; // this is used to hold return data 
.................... 
.................... #ifdef useSerial
.................... /*****************************************************************************/
.................... /* RESET SER COMMAND -- ready for a new command                              */
.................... /*****************************************************************************/
.................... void resetSERcmd(unsigned int8 recNum)
.................... {
....................    if (recNum < numRecords)
00B0C:  MOVLB  6
00B0E:  MOVF   x73,W
00B10:  SUBLW  03
00B12:  BTFSS  FD8.0
00B14:  BRA    0C82
....................    {
....................       for (int i = 0; i <numParam; i ++)
00B16:  CLRF   x74
00B18:  MOVF   x74,W
00B1A:  SUBLW  06
00B1C:  BNC   0B6C
....................       {
....................          SERcmd[recNum].p[i][0] = '\0';
00B1E:  CLRF   xB4
00B20:  MOVFF  673,6B3
00B24:  CLRF   xB6
00B26:  MOVLW  B5
00B28:  MOVWF  xB5
00B2A:  MOVLB  0
00B2C:  RCALL  082A
00B2E:  MOVFF  02,676
00B32:  MOVFF  01,675
00B36:  MOVLW  06
00B38:  MOVLB  6
00B3A:  ADDWF  x75,F
00B3C:  MOVLW  00
00B3E:  ADDWFC x76,F
00B40:  CLRF   xB4
00B42:  MOVFF  674,6B3
00B46:  CLRF   xB6
00B48:  MOVLW  19
00B4A:  MOVWF  xB5
00B4C:  MOVLB  0
00B4E:  RCALL  082A
00B50:  MOVF   01,W
00B52:  MOVLB  6
00B54:  ADDWF  x75,F
00B56:  MOVF   02,W
00B58:  ADDWFC x76,F
00B5A:  MOVLW  D1
00B5C:  ADDWF  x75,W
00B5E:  MOVWF  FE9
00B60:  MOVLW  01
00B62:  ADDWFC x76,W
00B64:  MOVWF  FEA
00B66:  CLRF   FEF
00B68:  INCF   x74,F
00B6A:  BRA    0B18
....................       }
....................       SERcmd[recNum].t = 0;
00B6C:  CLRF   xB4
00B6E:  MOVFF  673,6B3
00B72:  CLRF   xB6
00B74:  MOVLW  B5
00B76:  MOVWF  xB5
00B78:  MOVLB  0
00B7A:  RCALL  082A
00B7C:  MOVFF  01,675
00B80:  MOVLW  05
00B82:  MOVLB  6
00B84:  ADDWF  01,W
00B86:  MOVWF  01
00B88:  MOVLW  00
00B8A:  ADDWFC 02,W
00B8C:  MOVWF  03
00B8E:  MOVF   01,W
00B90:  ADDLW  D1
00B92:  MOVWF  FE9
00B94:  MOVLW  01
00B96:  ADDWFC 03,W
00B98:  MOVWF  FEA
00B9A:  CLRF   FEF
....................       SERcmd[recNum].chrIndex = 0;
00B9C:  CLRF   xB4
00B9E:  MOVFF  673,6B3
00BA2:  CLRF   xB6
00BA4:  MOVLW  B5
00BA6:  MOVWF  xB5
00BA8:  MOVLB  0
00BAA:  RCALL  082A
00BAC:  MOVFF  01,675
00BB0:  MOVLW  01
00BB2:  MOVLB  6
00BB4:  ADDWF  01,W
00BB6:  MOVWF  01
00BB8:  MOVLW  00
00BBA:  ADDWFC 02,W
00BBC:  MOVWF  03
00BBE:  MOVF   01,W
00BC0:  ADDLW  D1
00BC2:  MOVWF  FE9
00BC4:  MOVLW  01
00BC6:  ADDWFC 03,W
00BC8:  MOVWF  FEA
00BCA:  CLRF   FEF
....................       SERcmd[recNum].paramIndex = 0;
00BCC:  CLRF   xB4
00BCE:  MOVFF  673,6B3
00BD2:  CLRF   xB6
00BD4:  MOVLW  B5
00BD6:  MOVWF  xB5
00BD8:  MOVLB  0
00BDA:  RCALL  082A
00BDC:  MOVFF  01,675
00BE0:  MOVLW  02
00BE2:  MOVLB  6
00BE4:  ADDWF  01,W
00BE6:  MOVWF  01
00BE8:  MOVLW  00
00BEA:  ADDWFC 02,W
00BEC:  MOVWF  03
00BEE:  MOVF   01,W
00BF0:  ADDLW  D1
00BF2:  MOVWF  FE9
00BF4:  MOVLW  01
00BF6:  ADDWFC 03,W
00BF8:  MOVWF  FEA
00BFA:  CLRF   FEF
....................       SERcmd[recNum].recReadIndex = 0;
00BFC:  CLRF   xB4
00BFE:  MOVFF  673,6B3
00C02:  CLRF   xB6
00C04:  MOVLW  B5
00C06:  MOVWF  xB5
00C08:  MOVLB  0
00C0A:  RCALL  082A
00C0C:  MOVFF  01,675
00C10:  MOVLW  03
00C12:  MOVLB  6
00C14:  ADDWF  01,W
00C16:  MOVWF  01
00C18:  MOVLW  00
00C1A:  ADDWFC 02,W
00C1C:  MOVWF  03
00C1E:  MOVF   01,W
00C20:  ADDLW  D1
00C22:  MOVWF  FE9
00C24:  MOVLW  01
00C26:  ADDWFC 03,W
00C28:  MOVWF  FEA
00C2A:  CLRF   FEF
....................       SERcmd[recNum].recWriteIndex = 0;
00C2C:  CLRF   xB4
00C2E:  MOVFF  673,6B3
00C32:  CLRF   xB6
00C34:  MOVLW  B5
00C36:  MOVWF  xB5
00C38:  MOVLB  0
00C3A:  RCALL  082A
00C3C:  MOVFF  01,675
00C40:  MOVLW  04
00C42:  MOVLB  6
00C44:  ADDWF  01,W
00C46:  MOVWF  01
00C48:  MOVLW  00
00C4A:  ADDWFC 02,W
00C4C:  MOVWF  03
00C4E:  MOVF   01,W
00C50:  ADDLW  D1
00C52:  MOVWF  FE9
00C54:  MOVLW  01
00C56:  ADDWFC 03,W
00C58:  MOVWF  FEA
00C5A:  CLRF   FEF
....................       SERcmd[recNum].full = FALSE;
00C5C:  CLRF   xB4
00C5E:  MOVFF  673,6B3
00C62:  CLRF   xB6
00C64:  MOVLW  B5
00C66:  MOVWF  xB5
00C68:  MOVLB  0
00C6A:  RCALL  082A
00C6C:  MOVLW  D1
00C6E:  MOVLB  6
00C70:  ADDWF  01,W
00C72:  MOVWF  FE9
00C74:  MOVLW  01
00C76:  ADDWFC 02,W
00C78:  MOVWF  FEA
00C7A:  BCF    FEF.0
....................       retData[0] = '\0';
00C7C:  MOVLB  4
00C7E:  CLRF   xA7
00C80:  MOVLB  6
....................    }
00C82:  MOVLB  0
00C84:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next serial read index (SRI)                                          */
.................... /*****************************************************************************/
.................... BOOLEAN getNextSERReadIndex()
.................... {
....................    while (!SERcmd[SRI].full)
*
054D8:  MOVLB  6
054DA:  CLRF   xB4
054DC:  MOVFF  4A5,6B3
054E0:  CLRF   xB6
054E2:  MOVLW  B5
054E4:  MOVWF  xB5
054E6:  MOVLB  0
054E8:  CALL   082A
054EC:  MOVFF  02,674
054F0:  MOVFF  01,673
054F4:  MOVLW  D1
054F6:  MOVLB  6
054F8:  ADDWF  01,W
054FA:  MOVWF  FE9
054FC:  MOVLW  01
054FE:  ADDWFC 02,W
05500:  MOVWF  FEA
05502:  BTFSC  FEF.0
05504:  BRA    5526
....................    {
....................       if (SRI == SWI) return FALSE;
05506:  MOVLB  4
05508:  MOVF   xA6,W
0550A:  SUBWF  xA5,W
0550C:  BNZ   5514
0550E:  MOVLW  00
05510:  MOVWF  01
05512:  BRA    552C
....................       SRI +=1;
05514:  MOVLW  01
05516:  ADDWF  xA5,F
....................       if (SRI >= numRecords) SRI=0;
05518:  MOVF   xA5,W
0551A:  SUBLW  03
0551C:  BC    5520
0551E:  CLRF   xA5
05520:  MOVLB  0
05522:  BRA    54D8
05524:  MOVLB  6
....................    }
....................    return TRUE;
05526:  MOVLW  01
05528:  MOVWF  01
0552A:  MOVLB  4
0552C:  MOVLB  0
0552E:  GOTO   9DD6 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next serial write index (SWI)                                         */
.................... /*****************************************************************************/
.................... void setNextSERWriteIndex()
.................... {
....................    SWI +=1;
*
04F82:  MOVLW  01
04F84:  MOVLB  4
04F86:  ADDWF  xA6,F
....................    if (SWI >= numRecords) SWI=0;
04F88:  MOVF   xA6,W
04F8A:  SUBLW  03
04F8C:  BC    4F90
04F8E:  CLRF   xA6
04F90:  MOVLB  0
04F92:  RETURN 0
.................... }
.................... #endif
.................... 
.................... #ifdef useTCPIP
.................... /*****************************************************************************/
.................... /* RESET TCP COMMAND -- ready for a new command                              */
.................... /*****************************************************************************/
.................... void resetTCPcmd(unsigned int8 recNum)
.................... {
....................    if(recNum < numRecords)
....................    {
....................       for (int i = 0; i <numParam; i ++)
....................       {
....................          TCPcmd[recNum].p[i][0] = '\0';
....................       }
....................       TCPcmd[recNum].t = 0;
....................       TCPcmd[recNum].chrIndex = 0;
....................       TCPcmd[recNum].paramIndex = 0;
....................       TCPcmd[recNum].full = FALSE;
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next TCP read index (TRI)                                             */
.................... /*****************************************************************************/
.................... BOOLEAN getNextTCPReadIndex()
.................... {
....................    while (!TCPcmd[TRI].full)
....................    {
....................       if (TRI == TWI) return FALSE;
....................       TRI +=1;
....................       if (TRI >= numRecords) TRI=0;
....................    }
....................    return TRUE;
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next TCP write index (TWI)                                            */
.................... /*****************************************************************************/
.................... void setNextTCPWriteIndex()
.................... {
....................    TWI +=1;
....................    if (TWI >= numRecords) TWI=0;
.................... }
.................... #endif
.................... #endif
.................... 
.................... 
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
....................    output_b(portB_reset);
....................    output_c(portC_reset);
....................    output_d(portD_reset);
....................    output_e(portE_reset);
....................    
....................    port_a_pullups(portA_pullups);
....................    port_b_pullups(portB_pullups);
....................    port_c_pullups(portC_pullups);
....................    port_d_pullups(portD_pullups);
....................    port_e_pullups(portE_pullups);
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... #define use_RS485 // adds RX enable pin//
.................... 
.................... #define oneByteCmdTestValue 128
.................... #define UART_BUFFER_SIZE 60
.................... #define UART_EOT_CHAR1 0x0D //Carriage Return
.................... #define UART_EOT_CHAR2 0x0A //Line Feed
.................... #define UART_SOT_CHAR  '~' // START CHARACTER
.................... #define line_turnaround_char 0xFF
.................... 
.................... #bit UART_TXBuffer_Empty = 0x0FAC.1
.................... 
.................... char UART_BUFFER[UART_BUFFER_SIZE] = {0};
.................... unsigned int8 UART_WR_PTR = 0;
.................... unsigned int8 UART_RD_PTR = 0;
.................... boolean BYTES_AVAILABLE= FALSE;
.................... 
.................... #ifdef use_RS485
.................... #use rs232(baud=baudRate, xmit=TX_PIN, rcv=RX_PIN, enable=TX_ENABLE, stream=SERIAL, ERRORS)
*
000CA:  MOVLB  E
000CC:  BTFSS  xC8.5
000CE:  BRA    00CC
000D0:  MOVFF  F9C,549
000D4:  MOVLB  5
000D6:  MOVFF  F98,01
000DA:  BTFSS  x49.1
000DC:  BRA    00E2
000DE:  BCF    F9C.4
000E0:  BSF    F9C.4
000E2:  MOVLB  0
000E4:  GOTO   010C (RETURN)
*
04F94:  MOVLW  93
04F96:  MOVWF  F89
04F98:  BSF    F84.5
04F9A:  MOVLB  E
04F9C:  BTFSS  xC8.4
04F9E:  BRA    4F9C
04FA0:  MOVLW  93
04FA2:  MOVWF  F89
04FA4:  BSF    F84.5
04FA6:  MOVLB  6
04FA8:  MOVFF  679,F99
04FAC:  NOP   
04FAE:  BTFSS  F9D.1
04FB0:  BRA    4FAE
04FB2:  MOVLW  93
04FB4:  MOVWF  F89
04FB6:  BCF    F84.5
04FB8:  MOVLB  0
04FBA:  RETURN 0
.................... #else
.................... #use rs232(baud=baudRate, xmit=TX_PIN, rcv=RX_PIN, stream=SERIAL)
.................... #endif
.................... 
.................... // Message format: [SOT]addr ,cmd, arg1, arg2, arg3[EOT]} 
.................... // arguments are optional
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* SERIAL PORT ISR                                                           */
.................... /*****************************************************************************/
.................... #INT_RDA
.................... void RX_isr()
*
000E8:  MOVLB  0
.................... {
....................    while (kbhit())
000EA:  MOVLB  E
000EC:  BTFSS  xC8.5
000EE:  BRA    0130
....................    {
....................       UART_BUFFER[UART_WR_PTR]=getch();
000F0:  CLRF   03
000F2:  MOVLB  5
000F4:  MOVF   x47,W
000F6:  ADDLW  0B
000F8:  MOVWF  FE9
000FA:  MOVLW  05
000FC:  ADDWFC 03,W
000FE:  MOVWF  FEA
00100:  MOVFF  FEA,6E4
00104:  MOVFF  FE9,6E3
00108:  MOVLB  0
0010A:  BRA    00CA
0010C:  MOVFF  6E4,FEA
00110:  MOVFF  6E3,FE9
00114:  MOVFF  01,FEF
....................       UART_WR_PTR +=1;
00118:  MOVLW  01
0011A:  MOVLB  5
0011C:  ADDWF  x47,F
....................       if (UART_WR_PTR>=UART_BUFFER_SIZE) UART_WR_PTR=0;
0011E:  MOVF   x47,W
00120:  SUBLW  3B
00122:  BC    0126
00124:  CLRF   x47
....................       BYTES_AVAILABLE=TRUE;
00126:  MOVLB  1
00128:  BSF    x49.1
0012A:  MOVLB  0
0012C:  BRA    00EA
0012E:  MOVLB  E
....................    }
00130:  BCF    xC8.5
00132:  MOVLB  0
00134:  GOTO   006E
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get character from buffer                                                 */
.................... /*****************************************************************************/
.................... char getchFromBuffer()
*
04F4A:  CLRF   03
04F4C:  MOVLB  5
04F4E:  MOVF   x48,W
04F50:  ADDLW  0B
04F52:  MOVWF  FE9
04F54:  MOVLW  05
04F56:  ADDWFC 03,W
04F58:  MOVWF  FEA
04F5A:  MOVFF  FEF,673
.................... {
....................    char data = UART_BUFFER[UART_RD_PTR];
....................    UART_RD_PTR +=1;
04F5E:  MOVLW  01
04F60:  ADDWF  x48,F
....................    if (UART_RD_PTR>=UART_BUFFER_SIZE) UART_RD_PTR=0;
04F62:  MOVF   x48,W
04F64:  SUBLW  3B
04F66:  BC    4F6A
04F68:  CLRF   x48
....................    if (UART_RD_PTR == UART_WR_PTR) BYTES_AVAILABLE=FALSE;
04F6A:  MOVF   x47,W
04F6C:  SUBWF  x48,W
04F6E:  BNZ   4F76
04F70:  MOVLB  1
04F72:  BCF    x49.1
04F74:  MOVLB  5
....................    return data;
04F76:  MOVLB  6
04F78:  MOVFF  673,01
04F7C:  MOVLB  0
04F7E:  GOTO   5022 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Serial Task transfers bytes to command buffer                             */
.................... /*****************************************************************************/
.................... void serial_task()
.................... {
....................    while(BYTES_AVAILABLE && SERcmd[SWI].full==FALSE)
*
04FE0:  MOVLB  1
04FE2:  BTFSS  x49.1
04FE4:  BRA    54D2
04FE6:  MOVLB  6
04FE8:  CLRF   xB4
04FEA:  MOVFF  4A6,6B3
04FEE:  CLRF   xB6
04FF0:  MOVLW  B5
04FF2:  MOVWF  xB5
04FF4:  MOVLB  0
04FF6:  CALL   082A
04FFA:  MOVFF  02,674
04FFE:  MOVFF  01,673
05002:  MOVLW  D1
05004:  MOVLB  6
05006:  ADDWF  01,W
05008:  MOVWF  01
0500A:  MOVLW  01
0500C:  ADDWFC 02,W
0500E:  MOVWF  03
05010:  MOVFF  01,FE9
05014:  MOVWF  FEA
05016:  BTFSS  FEF.0
05018:  BRA    501E
0501A:  MOVLB  1
0501C:  BRA    54D2
....................    {  
....................       unsigned int8 rxChar = getchFromBuffer();
0501E:  MOVLB  0
05020:  BRA    4F4A
05022:  MOVFF  01,672
....................       if (rxChar == ignoreChr1 || rxChar == ignoreChr2)
05026:  MOVLB  6
05028:  MOVF   x72,W
0502A:  SUBLW  0D
0502C:  BZ    5034
0502E:  MOVF   x72,W
05030:  SUBLW  20
05032:  BNZ   5036
....................       {
....................       }
05034:  BRA    54CC
....................       else if (rxChar == UART_SOT_CHAR)
05036:  MOVF   x72,W
05038:  SUBLW  7E
0503A:  BNZ   507E
....................       {
....................          resetSERcmd(SWI);
0503C:  MOVFF  4A6,673
05040:  MOVLB  0
05042:  CALL   0B0C
....................          SERcmd[SWI].t = rxChar;
05046:  MOVLB  6
05048:  CLRF   xB4
0504A:  MOVFF  4A6,6B3
0504E:  CLRF   xB6
05050:  MOVLW  B5
05052:  MOVWF  xB5
05054:  MOVLB  0
05056:  CALL   082A
0505A:  MOVFF  01,673
0505E:  MOVLW  05
05060:  MOVLB  6
05062:  ADDWF  01,W
05064:  MOVWF  01
05066:  MOVLW  00
05068:  ADDWFC 02,W
0506A:  MOVWF  03
0506C:  MOVF   01,W
0506E:  ADDLW  D1
05070:  MOVWF  FE9
05072:  MOVLW  01
05074:  ADDWFC 03,W
05076:  MOVWF  FEA
05078:  MOVFF  672,FEF
....................       }
0507C:  BRA    54CC
....................       else if (rxChar >= oneByteCmdTestValue)
0507E:  MOVF   x72,W
05080:  SUBLW  7F
05082:  BC    50EE
....................       {
....................          resetSERcmd(SWI);
05084:  MOVFF  4A6,673
05088:  MOVLB  0
0508A:  CALL   0B0C
....................          SERcmd[SWI].t = rxChar;
0508E:  MOVLB  6
05090:  CLRF   xB4
05092:  MOVFF  4A6,6B3
05096:  CLRF   xB6
05098:  MOVLW  B5
0509A:  MOVWF  xB5
0509C:  MOVLB  0
0509E:  CALL   082A
050A2:  MOVFF  01,673
050A6:  MOVLW  05
050A8:  MOVLB  6
050AA:  ADDWF  01,W
050AC:  MOVWF  01
050AE:  MOVLW  00
050B0:  ADDWFC 02,W
050B2:  MOVWF  03
050B4:  MOVF   01,W
050B6:  ADDLW  D1
050B8:  MOVWF  FE9
050BA:  MOVLW  01
050BC:  ADDWFC 03,W
050BE:  MOVWF  FEA
050C0:  MOVFF  672,FEF
....................          SERcmd[SWI].full = TRUE;
050C4:  CLRF   xB4
050C6:  MOVFF  4A6,6B3
050CA:  CLRF   xB6
050CC:  MOVLW  B5
050CE:  MOVWF  xB5
050D0:  MOVLB  0
050D2:  CALL   082A
050D6:  MOVLW  D1
050D8:  MOVLB  6
050DA:  ADDWF  01,W
050DC:  MOVWF  FE9
050DE:  MOVLW  01
050E0:  ADDWFC 02,W
050E2:  MOVWF  FEA
050E4:  BSF    FEF.0
....................          setNextSERWriteIndex();
050E6:  MOVLB  0
050E8:  RCALL  4F82
....................       }
050EA:  BRA    54CA
050EC:  MOVLB  6
....................       else if (rxChar == UART_EOT_CHAR2)
050EE:  MOVF   x72,W
050F0:  SUBLW  0A
050F2:  BTFSS  FD8.2
050F4:  BRA    51FA
....................       {
....................          SERcmd[SWI].full = TRUE;
050F6:  CLRF   xB4
050F8:  MOVFF  4A6,6B3
050FC:  CLRF   xB6
050FE:  MOVLW  B5
05100:  MOVWF  xB5
05102:  MOVLB  0
05104:  CALL   082A
05108:  MOVLW  D1
0510A:  MOVLB  6
0510C:  ADDWF  01,W
0510E:  MOVWF  FE9
05110:  MOVLW  01
05112:  ADDWFC 02,W
05114:  MOVWF  FEA
05116:  BSF    FEF.0
....................          SERcmd[SWI].recWriteIndex = SERcmd[SWI].paramIndex;
05118:  CLRF   xB4
0511A:  MOVFF  4A6,6B3
0511E:  CLRF   xB6
05120:  MOVLW  B5
05122:  MOVWF  xB5
05124:  MOVLB  0
05126:  CALL   082A
0512A:  MOVFF  01,673
0512E:  MOVLW  04
05130:  MOVLB  6
05132:  ADDWF  01,W
05134:  MOVWF  01
05136:  MOVLW  00
05138:  ADDWFC 02,W
0513A:  MOVWF  03
0513C:  MOVF   01,W
0513E:  ADDLW  D1
05140:  MOVWF  01
05142:  MOVLW  01
05144:  ADDWFC 03,F
05146:  MOVFF  01,673
0514A:  MOVFF  03,674
0514E:  CLRF   xB4
05150:  MOVFF  4A6,6B3
05154:  CLRF   xB6
05156:  MOVLW  B5
05158:  MOVWF  xB5
0515A:  MOVLB  0
0515C:  CALL   082A
05160:  MOVFF  01,675
05164:  MOVLW  02
05166:  MOVLB  6
05168:  ADDWF  01,W
0516A:  MOVWF  01
0516C:  MOVLW  00
0516E:  ADDWFC 02,W
05170:  MOVWF  03
05172:  MOVF   01,W
05174:  ADDLW  D1
05176:  MOVWF  FE9
05178:  MOVLW  01
0517A:  ADDWFC 03,W
0517C:  MOVWF  FEA
0517E:  MOVFF  FEF,675
05182:  MOVFF  674,FEA
05186:  MOVFF  673,FE9
0518A:  MOVFF  675,FEF
....................          SERcmd[SWI].chrIndex = 0;
0518E:  CLRF   xB4
05190:  MOVFF  4A6,6B3
05194:  CLRF   xB6
05196:  MOVLW  B5
05198:  MOVWF  xB5
0519A:  MOVLB  0
0519C:  CALL   082A
051A0:  MOVFF  01,673
051A4:  MOVLW  01
051A6:  MOVLB  6
051A8:  ADDWF  01,W
051AA:  MOVWF  01
051AC:  MOVLW  00
051AE:  ADDWFC 02,W
051B0:  MOVWF  03
051B2:  MOVF   01,W
051B4:  ADDLW  D1
051B6:  MOVWF  FE9
051B8:  MOVLW  01
051BA:  ADDWFC 03,W
051BC:  MOVWF  FEA
051BE:  CLRF   FEF
....................          SERcmd[SWI].paramIndex = 0;
051C0:  CLRF   xB4
051C2:  MOVFF  4A6,6B3
051C6:  CLRF   xB6
051C8:  MOVLW  B5
051CA:  MOVWF  xB5
051CC:  MOVLB  0
051CE:  CALL   082A
051D2:  MOVFF  01,673
051D6:  MOVLW  02
051D8:  MOVLB  6
051DA:  ADDWF  01,W
051DC:  MOVWF  01
051DE:  MOVLW  00
051E0:  ADDWFC 02,W
051E2:  MOVWF  03
051E4:  MOVF   01,W
051E6:  ADDLW  D1
051E8:  MOVWF  FE9
051EA:  MOVLW  01
051EC:  ADDWFC 03,W
051EE:  MOVWF  FEA
051F0:  CLRF   FEF
....................          setNextSERWriteIndex();
051F2:  MOVLB  0
051F4:  RCALL  4F82
....................       }
051F6:  BRA    54CA
051F8:  MOVLB  6
....................       else if (rxChar == delimiter)
051FA:  MOVF   x72,W
051FC:  SUBLW  2C
051FE:  BNZ   52BC
....................       {
....................          if (SERcmd[SWI].paramIndex < numParam-1)
05200:  CLRF   xB4
05202:  MOVFF  4A6,6B3
05206:  CLRF   xB6
05208:  MOVLW  B5
0520A:  MOVWF  xB5
0520C:  MOVLB  0
0520E:  CALL   082A
05212:  MOVFF  02,674
05216:  MOVFF  01,673
0521A:  MOVLW  02
0521C:  MOVLB  6
0521E:  ADDWF  01,W
05220:  MOVWF  01
05222:  MOVLW  00
05224:  ADDWFC 02,W
05226:  MOVWF  03
05228:  MOVF   01,W
0522A:  ADDLW  D1
0522C:  MOVWF  FE9
0522E:  MOVLW  01
05230:  ADDWFC 03,W
05232:  MOVWF  FEA
05234:  MOVF   FEF,W
05236:  SUBLW  05
05238:  BNC   52A4
....................          {
....................             SERcmd[SWI].paramIndex +=1;
0523A:  CLRF   xB4
0523C:  MOVFF  4A6,6B3
05240:  CLRF   xB6
05242:  MOVLW  B5
05244:  MOVWF  xB5
05246:  MOVLB  0
05248:  CALL   082A
0524C:  MOVFF  01,673
05250:  MOVLW  02
05252:  MOVLB  6
05254:  ADDWF  01,W
05256:  MOVWF  01
05258:  MOVLW  00
0525A:  ADDWFC 02,W
0525C:  MOVWF  03
0525E:  MOVF   01,W
05260:  ADDLW  D1
05262:  MOVWF  FE9
05264:  MOVLW  01
05266:  ADDWFC 03,W
05268:  MOVWF  FEA
0526A:  MOVLW  01
0526C:  ADDWF  FEF,W
0526E:  MOVWF  FEF
....................             SERcmd[SWI].chrIndex = 0;
05270:  CLRF   xB4
05272:  MOVFF  4A6,6B3
05276:  CLRF   xB6
05278:  MOVLW  B5
0527A:  MOVWF  xB5
0527C:  MOVLB  0
0527E:  CALL   082A
05282:  MOVFF  01,673
05286:  MOVLW  01
05288:  MOVLB  6
0528A:  ADDWF  01,W
0528C:  MOVWF  01
0528E:  MOVLW  00
05290:  ADDWFC 02,W
05292:  MOVWF  03
05294:  MOVF   01,W
05296:  ADDLW  D1
05298:  MOVWF  FE9
0529A:  MOVLW  01
0529C:  ADDWFC 03,W
0529E:  MOVWF  FEA
052A0:  CLRF   FEF
....................          }
052A2:  BRA    52BA
....................          else
....................          {
....................             resetSERcmd(SWI); // exceed number of params... reset capture
052A4:  MOVFF  4A6,673
052A8:  MOVLB  0
052AA:  CALL   0B0C
....................             fprintf(SERIAL, retData);
052AE:  MOVLW  04
052B0:  MOVWF  FEA
052B2:  MOVLW  A7
052B4:  MOVWF  FE9
052B6:  RCALL  4FBC
052B8:  MOVLB  6
....................          }
....................       }
052BA:  BRA    54CC
....................       
....................       else
....................       {
....................          if (SERcmd[SWI].chrIndex < lenParam)
052BC:  CLRF   xB4
052BE:  MOVFF  4A6,6B3
052C2:  CLRF   xB6
052C4:  MOVLW  B5
052C6:  MOVWF  xB5
052C8:  MOVLB  0
052CA:  CALL   082A
052CE:  MOVFF  02,674
052D2:  MOVFF  01,673
052D6:  MOVLW  01
052D8:  MOVLB  6
052DA:  ADDWF  01,W
052DC:  MOVWF  01
052DE:  MOVLW  00
052E0:  ADDWFC 02,W
052E2:  MOVWF  03
052E4:  MOVF   01,W
052E6:  ADDLW  D1
052E8:  MOVWF  FE9
052EA:  MOVLW  01
052EC:  ADDWFC 03,W
052EE:  MOVWF  FEA
052F0:  MOVF   FEF,W
052F2:  SUBLW  18
052F4:  BTFSS  FD8.0
052F6:  BRA    54B6
....................          {
....................             SERcmd[SWI].p[SERcmd[SWI].paramIndex][SERcmd[SWI].chrIndex] = rxChar;
052F8:  CLRF   xB4
052FA:  MOVFF  4A6,6B3
052FE:  CLRF   xB6
05300:  MOVLW  B5
05302:  MOVWF  xB5
05304:  MOVLB  0
05306:  CALL   082A
0530A:  MOVFF  02,674
0530E:  MOVFF  01,673
05312:  MOVLW  06
05314:  MOVLB  6
05316:  ADDWF  x73,F
05318:  MOVLW  00
0531A:  ADDWFC x74,F
0531C:  CLRF   xB4
0531E:  MOVFF  4A6,6B3
05322:  CLRF   xB6
05324:  MOVLW  B5
05326:  MOVWF  xB5
05328:  MOVLB  0
0532A:  CALL   082A
0532E:  MOVFF  02,676
05332:  MOVFF  01,675
05336:  MOVLW  02
05338:  MOVLB  6
0533A:  ADDWF  01,W
0533C:  MOVWF  01
0533E:  MOVLW  00
05340:  ADDWFC 02,W
05342:  MOVWF  03
05344:  MOVF   01,W
05346:  ADDLW  D1
05348:  MOVWF  FE9
0534A:  MOVLW  01
0534C:  ADDWFC 03,W
0534E:  MOVWF  FEA
05350:  CLRF   xB4
05352:  MOVFF  FEF,6B3
05356:  CLRF   xB6
05358:  MOVLW  19
0535A:  MOVWF  xB5
0535C:  MOVLB  0
0535E:  CALL   082A
05362:  MOVFF  02,03
05366:  MOVF   01,W
05368:  MOVLB  6
0536A:  ADDWF  x73,F
0536C:  MOVF   02,W
0536E:  ADDWFC x74,F
05370:  CLRF   xB4
05372:  MOVFF  4A6,6B3
05376:  CLRF   xB6
05378:  MOVLW  B5
0537A:  MOVWF  xB5
0537C:  MOVLB  0
0537E:  CALL   082A
05382:  MOVFF  01,675
05386:  MOVLW  01
05388:  MOVLB  6
0538A:  ADDWF  01,W
0538C:  MOVWF  01
0538E:  MOVLW  00
05390:  ADDWFC 02,W
05392:  MOVWF  03
05394:  MOVF   01,W
05396:  ADDLW  D1
05398:  MOVWF  FE9
0539A:  MOVLW  01
0539C:  ADDWFC 03,W
0539E:  MOVWF  FEA
053A0:  MOVF   FEF,W
053A2:  ADDWF  x73,W
053A4:  MOVWF  01
053A6:  MOVLW  00
053A8:  ADDWFC x74,W
053AA:  MOVWF  03
053AC:  MOVF   01,W
053AE:  ADDLW  D1
053B0:  MOVWF  FE9
053B2:  MOVLW  01
053B4:  ADDWFC 03,W
053B6:  MOVWF  FEA
053B8:  MOVFF  672,FEF
....................             SERcmd[SWI].chrIndex += 1;
053BC:  CLRF   xB4
053BE:  MOVFF  4A6,6B3
053C2:  CLRF   xB6
053C4:  MOVLW  B5
053C6:  MOVWF  xB5
053C8:  MOVLB  0
053CA:  CALL   082A
053CE:  MOVFF  01,673
053D2:  MOVLW  01
053D4:  MOVLB  6
053D6:  ADDWF  01,W
053D8:  MOVWF  01
053DA:  MOVLW  00
053DC:  ADDWFC 02,W
053DE:  MOVWF  03
053E0:  MOVF   01,W
053E2:  ADDLW  D1
053E4:  MOVWF  FE9
053E6:  MOVLW  01
053E8:  ADDWFC 03,W
053EA:  MOVWF  FEA
053EC:  MOVLW  01
053EE:  ADDWF  FEF,W
053F0:  MOVWF  FEF
....................             SERcmd[SWI].p[SERcmd[SWI].paramIndex][SERcmd[SWI].chrIndex] = '\0';
053F2:  CLRF   xB4
053F4:  MOVFF  4A6,6B3
053F8:  CLRF   xB6
053FA:  MOVLW  B5
053FC:  MOVWF  xB5
053FE:  MOVLB  0
05400:  CALL   082A
05404:  MOVFF  02,674
05408:  MOVFF  01,673
0540C:  MOVLW  06
0540E:  MOVLB  6
05410:  ADDWF  x73,F
05412:  MOVLW  00
05414:  ADDWFC x74,F
05416:  CLRF   xB4
05418:  MOVFF  4A6,6B3
0541C:  CLRF   xB6
0541E:  MOVLW  B5
05420:  MOVWF  xB5
05422:  MOVLB  0
05424:  CALL   082A
05428:  MOVFF  02,676
0542C:  MOVFF  01,675
05430:  MOVLW  02
05432:  MOVLB  6
05434:  ADDWF  01,W
05436:  MOVWF  01
05438:  MOVLW  00
0543A:  ADDWFC 02,W
0543C:  MOVWF  03
0543E:  MOVF   01,W
05440:  ADDLW  D1
05442:  MOVWF  FE9
05444:  MOVLW  01
05446:  ADDWFC 03,W
05448:  MOVWF  FEA
0544A:  CLRF   xB4
0544C:  MOVFF  FEF,6B3
05450:  CLRF   xB6
05452:  MOVLW  19
05454:  MOVWF  xB5
05456:  MOVLB  0
05458:  CALL   082A
0545C:  MOVFF  02,03
05460:  MOVF   01,W
05462:  MOVLB  6
05464:  ADDWF  x73,F
05466:  MOVF   02,W
05468:  ADDWFC x74,F
0546A:  CLRF   xB4
0546C:  MOVFF  4A6,6B3
05470:  CLRF   xB6
05472:  MOVLW  B5
05474:  MOVWF  xB5
05476:  MOVLB  0
05478:  CALL   082A
0547C:  MOVFF  01,675
05480:  MOVLW  01
05482:  MOVLB  6
05484:  ADDWF  01,W
05486:  MOVWF  01
05488:  MOVLW  00
0548A:  ADDWFC 02,W
0548C:  MOVWF  03
0548E:  MOVF   01,W
05490:  ADDLW  D1
05492:  MOVWF  FE9
05494:  MOVLW  01
05496:  ADDWFC 03,W
05498:  MOVWF  FEA
0549A:  MOVF   FEF,W
0549C:  ADDWF  x73,W
0549E:  MOVWF  01
054A0:  MOVLW  00
054A2:  ADDWFC x74,W
054A4:  MOVWF  03
054A6:  MOVF   01,W
054A8:  ADDLW  D1
054AA:  MOVWF  FE9
054AC:  MOVLW  01
054AE:  ADDWFC 03,W
054B0:  MOVWF  FEA
054B2:  CLRF   FEF
....................          }
054B4:  BRA    54CC
....................          else
....................          {
....................             resetSERcmd(SWI); // exceed number of characters... reset capture
054B6:  MOVFF  4A6,673
054BA:  MOVLB  0
054BC:  CALL   0B0C
....................             fprintf(SERIAL, retData);
054C0:  MOVLW  04
054C2:  MOVWF  FEA
054C4:  MOVLW  A7
054C6:  MOVWF  FE9
054C8:  RCALL  4FBC
054CA:  MOVLB  6
....................          }
....................       }
054CC:  MOVLB  0
054CE:  BRA    4FE0
054D0:  MOVLB  1
....................    }          
054D2:  MOVLB  0
054D4:  GOTO   A2F2 (RETURN)
.................... }
....................            
.................... /*****************************************************************************/
.................... /* serialInit ROUTINE  - Sets up serial port                                 */
.................... /*****************************************************************************/ 
.................... void serial_init()
.................... {
....................    for (int i = 0; i < numRecords; i++) 
*
00C86:  MOVLB  6
00C88:  CLRF   x72
00C8A:  MOVF   x72,W
00C8C:  SUBLW  03
00C8E:  BNC   0C9E
....................    {
....................       resetSERcmd(i);
00C90:  MOVFF  672,673
00C94:  MOVLB  0
00C96:  RCALL  0B0C
00C98:  MOVLB  6
00C9A:  INCF   x72,F
00C9C:  BRA    0C8A
....................    }
....................    enable_interrupts(INT_RDA);
00C9E:  MOVLB  E
00CA0:  BSF    xC0.5
00CA2:  MOVLB  0
00CA4:  GOTO   A2BC (RETURN)
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #include <pid.h>
.................... #ifndef pidcontroller
.................... #define pidcontroller
.................... #include <parameters.h>
.................... #include <math.h>
.................... 
.................... /*****************************************************************************/
.................... /* UPDATE the Control Variable (CV)                                          */
.................... /*****************************************************************************/
.................... void pid_update (channelMap ch){
....................    float err = PID[ch].SP - PID[ch].PV;  // error = set value - measured
....................    
....................    PID[ch].I += err*PID[ch].kI;
....................    if (PID[ch].I > op_upper_bound) PID[ch].I = op_upper_bound; // anti-windup
....................    else if (PID[ch].I < op_lower_bound) PID[ch].I = op_lower_bound;
....................    
....................    float P = err * PID[ch].kP;  // proportional value
....................    
....................    float D = PID[ch].kD * (PID[ch].PV - PID[ch].PVold);  // derivative value
....................    
....................    PID[ch].CV = P + PID[ch].I + D;  // new control variable
....................    if (PID[ch].CV > op_upper_bound) PID[ch].CV = op_upper_bound; // limit positive output
....................    else if (PID[ch].CV < op_lower_bound) PID[ch].CV = op_lower_bound; // limit negative output
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PID Task - looks for change to PV and updates CV                          */
.................... /*****************************************************************************/
.................... void pid_task(channelMap ch){
....................    static int index = 0;
....................    if (PID[ch].SP != PID[ch].PV) pid_update(ch);
....................    if ((index++) >= numChannels) index = 0;
.................... }
.................... 
.................... #endif
.................... 
.................... #include <eventTimer.h>
.................... #ifndef timeout
.................... #define timeout
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................   //  P     I     D
....................   //0.01    0.3   0.1
....................    {0.01,   0.3,  0.1, 0,0,0,0,0}, 
....................    {0.01,   0.3,  0.1, 0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... BOOLEAN adcFilter = TRUE;
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/           
.................... /* Global timers used by all routnes                                         */
.................... /* timeoutReg0-2 are used for timeouts. Other routines monitor the value of  */
.................... /* intTimeoutReg. On boot, they will be loaded from EEProm. Any              */
.................... /* configuration changes will be changed in EEprom, hence will be restored on*/
.................... /* subsequent boot.                                                          */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* Register definitions                                                      */
.................... /*****************************************************************************/
.................... //!unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... //!unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... //!unsigned int32 timeoutReg2 = 0;
.................... //!unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... unsigned int32 timeCounter = 0;
.................... 
.................... /*****************************************************************************/
.................... /* TIMEOUT_INIT initializes the timer                                        */
.................... /*****************************************************************************/
.................... void event_timer_init()
.................... {        
....................    disable_interrupts(INT_TIMER1);
00CA8:  MOVLB  E
00CAA:  BCF    xC1.0
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_1);
00CAC:  MOVLW  01
00CAE:  MOVWF  FD1
00CB0:  MOVLW  07
00CB2:  MOVWF  FCE
00CB4:  CLRF   FCF
00CB6:  CLRF   FD0
....................    timeoutReg0 = 0;  // clear all the timers
00CB8:  MOVLB  1
00CBA:  CLRF   x5B
00CBC:  CLRF   x5A
00CBE:  CLRF   x59
00CC0:  CLRF   x58
....................    timeoutReg1 = 0;
00CC2:  CLRF   x5F
00CC4:  CLRF   x5E
00CC6:  CLRF   x5D
00CC8:  CLRF   x5C
....................    timeoutReg2 = 0;
00CCA:  CLRF   x63
00CCC:  CLRF   x62
00CCE:  CLRF   x61
00CD0:  CLRF   x60
.................... //!   intTimeoutReg = 50;
....................    enable_interrupts(INT_TIMER1);
00CD2:  MOVLB  E
00CD4:  BSF    xC1.0
00CD6:  MOVLB  0
00CD8:  GOTO   A2C0 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* TIMEOUT INTERRUPT decrements the timeout registers every second           */
.................... /*****************************************************************************/
.................... #INT_TIMER1
.................... void TIMER1_isr(void) 
*
0025C:  MOVLB  0
.................... {
....................    set_timer1(0x0BDB); // load timer register to allow 10 millisecond interupts
0025E:  MOVLW  0B
00260:  MOVWF  FCD
00262:  MOVLW  DB
00264:  MOVWF  FCC
00266:  NOP   
....................    if (timeoutReg0 > 10) timeoutReg0 -= 10; else timeoutReg0 = 0;
00268:  MOVLB  1
0026A:  MOVF   x5B,F
0026C:  BNZ   027C
0026E:  MOVF   x5A,F
00270:  BNZ   027C
00272:  MOVF   x59,F
00274:  BNZ   027C
00276:  MOVF   x58,W
00278:  SUBLW  0A
0027A:  BC    028A
0027C:  MOVLW  0A
0027E:  SUBWF  x58,F
00280:  MOVLW  00
00282:  SUBWFB x59,F
00284:  SUBWFB x5A,F
00286:  SUBWFB x5B,F
00288:  BRA    0292
0028A:  CLRF   x5B
0028C:  CLRF   x5A
0028E:  CLRF   x59
00290:  CLRF   x58
....................    if (timeoutReg1 > 10) timeoutReg1 -= 10; else timeoutReg1 = 0;
00292:  MOVF   x5F,F
00294:  BNZ   02A4
00296:  MOVF   x5E,F
00298:  BNZ   02A4
0029A:  MOVF   x5D,F
0029C:  BNZ   02A4
0029E:  MOVF   x5C,W
002A0:  SUBLW  0A
002A2:  BC    02B2
002A4:  MOVLW  0A
002A6:  SUBWF  x5C,F
002A8:  MOVLW  00
002AA:  SUBWFB x5D,F
002AC:  SUBWFB x5E,F
002AE:  SUBWFB x5F,F
002B0:  BRA    02BA
002B2:  CLRF   x5F
002B4:  CLRF   x5E
002B6:  CLRF   x5D
002B8:  CLRF   x5C
....................    if (timeoutReg2 > 10) timeoutReg2 -= 10; else timeoutReg2 = 0;
002BA:  MOVF   x63,F
002BC:  BNZ   02CC
002BE:  MOVF   x62,F
002C0:  BNZ   02CC
002C2:  MOVF   x61,F
002C4:  BNZ   02CC
002C6:  MOVF   x60,W
002C8:  SUBLW  0A
002CA:  BC    02DA
002CC:  MOVLW  0A
002CE:  SUBWF  x60,F
002D0:  MOVLW  00
002D2:  SUBWFB x61,F
002D4:  SUBWFB x62,F
002D6:  SUBWFB x63,F
002D8:  BRA    02E2
002DA:  CLRF   x63
002DC:  CLRF   x62
002DE:  CLRF   x61
002E0:  CLRF   x60
....................    if (intTimeoutReg != 0) // INTERRUPTING TIMER
002E2:  MOVF   x64,F
002E4:  BNZ   02EA
002E6:  MOVF   x65,F
002E8:  BZ    0326
....................    {
....................       timeCounter+=10;
002EA:  MOVLW  0A
002EC:  MOVLB  5
002EE:  ADDWF  x4C,F
002F0:  MOVLW  00
002F2:  ADDWFC x4D,F
002F4:  ADDWFC x4E,F
002F6:  ADDWFC x4F,F
....................       if (timeCounter >= intTimeoutReg)
002F8:  MOVF   x4F,F
002FA:  BNZ   0316
002FC:  MOVF   x4E,F
002FE:  BNZ   0316
00300:  MOVLB  1
00302:  MOVF   x65,W
00304:  MOVLB  5
00306:  SUBWF  x4D,W
00308:  BNC   0324
0030A:  BNZ   0316
0030C:  MOVLB  1
0030E:  MOVF   x64,W
00310:  MOVLB  5
00312:  SUBWF  x4C,W
00314:  BNC   0324
....................       {
....................          sensor_monitor_interrupt_task();
00316:  MOVLB  0
00318:  BRA    01C0
....................          timeCounter = 0;
0031A:  MOVLB  5
0031C:  CLRF   x4F
0031E:  CLRF   x4E
00320:  CLRF   x4D
00322:  CLRF   x4C
00324:  MOVLB  1
....................       }
....................    }
.................... }
.................... 
.................... #endif
.................... 
.................... #include <commandHandler.c>
.................... #ifndef cmdHandlerC
.................... #define cmdHandlerC
.................... #include <commandHandler.h>
.................... #ifndef cmdHandler
.................... #define cmdHandler
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................   //  P     I     D
....................   //0.01    0.3   0.1
....................    {0.01,   0.3,  0.1, 0,0,0,0,0}, 
....................    {0.01,   0.3,  0.1, 0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... BOOLEAN adcFilter = TRUE;
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... 
00326:  MOVLB  E
00328:  BCF    xC9.0
0032A:  MOVLB  0
0032C:  GOTO   006E
.................... #define hwID 'D'   // DiFCS
.................... 
.................... /*****************************************************************************/
.................... /* RESPONSE MESSAGES                                                         */
.................... /*****************************************************************************/
.................... typedef struct response {
....................    int8 id;
....................    char *msg;
.................... } resp;
.................... 
.................... //!#define INVALID_DATA "error - invalid data"
.................... //!#define invalidTime "error - invalid TO value"
.................... //!#define overrun "error - buffer overrun"
.................... //!#define dcVoltage "VDC:%f1"
.................... //!#define USBVoltage "VUSB:%f"
.................... //!#define USBupstream "VUSBup:%f"
.................... //!#define plus5V "5V Rail:%f"
.................... //!#define plus3V3 "3V3 Rai:%f"
.................... //!#define allVoltages "All Voltages = %f, %f, %f, %f, %f"
.................... //!#define USBdownstream "USB downstream status:\r\nPG:%s\r\nch0:%s\r\nch1:%s"
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC MESSGAGE DUMP                                                  */
.................... /*****************************************************************************/
.................... //!#define voltageMsg "V0:%f\r\nV1:%f\r\nV2:%f\r\nV3:%f\r\nV4:%f"
.................... //!#define TimerMsg "T0:%Lu\r\nT1:%Lu\r\nT2:%Lu\r\Tint:%Lu\r\nTtick:%Lu"
.................... //!#define ioStatusMsg "Inputs:%u\r\nOutputs:%u\r\nStatus:%u"
.................... //!#define diagnosticMsg "V0:%f\r\nV1:%f\r\nV2:%f\r\nV3:%f\r\nV4:%f\r\nT0:%Lu\r\nT1:%Lu\r\nT2:%Lu\r\nTint:%Lu\r\nTtick:%Lu\r\nInputs:%u\r\nOutputs:%u\r\nStatus:%u"
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC COMMAND PROTOTYPES                                             */
.................... /*****************************************************************************/
.................... int8 getRev(unsigned int8);                // gr 
.................... int8 getSN(unsigned int8);                 // gs
.................... 
.................... int8 getOPchMap(unsigned int8);            // gChMap,   {1|2}
.................... int8 setOPchMap(unsigned int8);            // sChMap,   {1|2}, {X|Y}
.................... 
.................... int8 getIPchMode(unsigned int8);           // gChMode,  {1|2}
.................... int8 setIPchMode(unsigned int8);           // sChMode,  {1|2}, {MANUAL|MAGSNS}
....................    
.................... int8 getPIDvals(unsigned int8);            // gPID,     {1|2}, {P|I|D}
.................... int8 setPIDvals(unsigned int8);            // sPID,     {1|2}, {P|I|D}, <float>
.................... 
.................... int8 enablePID(unsigned int8);             // enaPID,   {1|2}
.................... int8 disablePID(unsigned int8);            // disPID,   {1|2}
.................... 
.................... int8 getSetPoint(unsigned int8);           // gSP,      {1|2}
.................... int8 setSetPoint(unsigned int8);           // sSP,      {1|2}, <float>
.................... 
.................... int8 getAllSensorCalParams(unsigned int8); // gSCals,   {1|2}
.................... int8 getSensorCalParam(unsigned int8);     // gSCal,    {1|2}, {0|1|2|3|4|5}
.................... int8 setSensorCalParam(unsigned int8);     // sSCal,    {1|2}, {0|1|2|3|4|5}, <float>
.................... 
.................... int8 getMonitorCalParam(unsigned int8);    // gMCal,    {N15|200|5V6|5VA|3V6X|3V3A|3V3D}
.................... int8 setMonitorCalParam(unsigned int8);    // sMCal,    {N15|200|5V6|5VA|3V6X|3V3A|3V3D}, <float>, <float>
.................... int8 getMonitorValue(unsigned int8);       // gMon,     {N15|200|5V6|5VA|3V6X|3V3A|3V3D|all}
.................... 
.................... int8 getPIDdata(unsigned int8);            // gPIDdata, {1|2}, {PV|CV|PVold|I}
.................... 
.................... int8 getIPdata(unsigned int8);             // gIPdata,  {1|2}, {raw|calib|p0|poles|real}
....................    
.................... int8 getManOPvals(unsigned int8);          // gManOP,   {1|2}  
.................... int8 setManOPvals(unsigned int8);          // sManOP,   {1|2}, <float>  
.................... 
.................... int8 setFilterOn(unsigned int8);           // sFiltOn
.................... int8 setFilterOff(unsigned int8);          // sFiltOff
.................... 
.................... int8 invalidCmd(unsigned int8);
.................... 
.................... struct command {
....................    char *cmd_name;
....................    int8 (*cmd_func)(unsigned int8);
.................... };
.................... 
.................... BOOLEAN arg_is_float(char *);
.................... BOOLEAN is_valid_channel(char *);
.................... int8 hex_to_int(char);
.................... void echo_cmd(unsigned int8 rec);
.................... int8 command_parser(unsigned int8 rec);
.................... void command_handler_task();
.................... 
.................... #endif
.................... 
.................... 
.................... /* LIST OF DIAGNOSTIC COMMAND KEYWORDS AND THEIR FUNCTIONS */
.................... struct command cmd_list[] = {
....................    {"gr",       &getRev},
....................    {"gs",       &getSN},
....................    {"gChMap",   &getOPchMap},
....................    {"sChMap",   &setOPchMap},
....................    {"gChMode",  &getIPchMode},
....................    {"sChMode",  &setIPchMode},
....................    {"gPID",     &getPIDvals},
....................    {"sPID",     &setPIDvals},
.................... //!   {"enaPID",   &enablePID},
.................... //!   {"disPID",   &disablePID},
....................    {"gSP",      &getSetPoint},
....................    {"sSP",      &setSetPoint},
....................    {"gSCals",   &getAllSensorCalParams},
....................    {"gSCal",    &getSensorCalParam},
....................    {"sSCal",    &setSensorCalParam},
....................    {"gMCal",    &getMonitorCalParam},
....................    {"sMCal",    &setMonitorCalParam},
....................    {"gMon",     &getMonitorValue},
....................    {"gPIDdata", &getPIDdata},
....................    {"gIPdata",  &getIPdata},
....................    {"gManOP",   &getManOPvals},
....................    {"sManOP",   &setManOPvals},
....................    {"sFiltOn",  &setFilterOn},
....................    {"sFiltOff", &setFilterOff},
....................    {"\0", &invalidCmd}
.................... };
.................... 
.................... /* LIST OF RESPONSE MESSAGES */
.................... enum resp_e { 
....................    SUCCESS,
....................    INV_CMD,
....................    INV_PARAM 
.................... };
.................... 
.................... resp resp_list[] = {
....................    {SUCCESS, "SUCCESS"},
....................    {INV_CMD, "INVALID COMMAND"},
....................    {INV_PARAM, "INVALID PARAMETER"}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC COMMAND DEFINITIONS                                            */
.................... /*****************************************************************************/
....................                           
.................... int8 getRev(unsigned int8 rec){
....................    sprintf(retData+strlen(retData), "%s,", version);
*
0565C:  MOVLW  04
0565E:  MOVLB  6
05660:  MOVWF  xB4
05662:  MOVLW  A7
05664:  MOVWF  xB3
05666:  MOVLB  0
05668:  RCALL  556C
0566A:  MOVFF  02,03
0566E:  MOVF   01,W
05670:  ADDLW  A7
05672:  MOVLB  6
05674:  MOVWF  x7D
05676:  MOVLW  04
05678:  ADDWFC 02,W
0567A:  MOVWF  x7E
0567C:  MOVFF  FE8,54B
05680:  MOVFF  67D,54A
05684:  MOVLW  30
05686:  MOVWF  FF6
05688:  MOVLW  03
0568A:  MOVWF  FF7
0568C:  MOVLB  0
0568E:  RCALL  563C
05690:  MOVLW  2C
05692:  MOVLB  6
05694:  MOVWF  xC2
05696:  MOVLB  0
05698:  RCALL  561C
....................    return SUCCESS;
0569A:  MOVLW  00
0569C:  MOVWF  01
0569E:  RETURN 0
.................... }
.................... 
.................... int8 getSN(unsigned int8 rec){
....................    sprintf(retData+strlen(retData), "%s,", serialID);
056A0:  MOVLW  04
056A2:  MOVLB  6
056A4:  MOVWF  xB4
056A6:  MOVLW  A7
056A8:  MOVWF  xB3
056AA:  MOVLB  0
056AC:  RCALL  556C
056AE:  MOVFF  02,03
056B2:  MOVF   01,W
056B4:  ADDLW  A7
056B6:  MOVLB  6
056B8:  MOVWF  x7D
056BA:  MOVLW  04
056BC:  ADDWFC 02,W
056BE:  MOVWF  x7E
056C0:  MOVFF  FE8,54B
056C4:  MOVFF  67D,54A
056C8:  MOVLW  3A
056CA:  MOVWF  FF6
056CC:  MOVLW  03
056CE:  MOVWF  FF7
056D0:  MOVLB  0
056D2:  RCALL  563C
056D4:  MOVLW  2C
056D6:  MOVLB  6
056D8:  MOVWF  xC2
056DA:  MOVLB  0
056DC:  RCALL  561C
....................    return SUCCESS;
056DE:  MOVLW  00
056E0:  MOVWF  01
056E2:  RETURN 0
.................... }
.................... 
.................... int8 getOPchMap(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
05BE8:  MOVLB  6
05BEA:  CLRF   xB4
05BEC:  MOVFF  66B,6B3
05BF0:  CLRF   xB6
05BF2:  MOVLW  B5
05BF4:  MOVWF  xB5
05BF6:  MOVLB  0
05BF8:  CALL   082A
05BFC:  MOVFF  02,67F
05C00:  MOVFF  01,67E
05C04:  MOVLW  06
05C06:  MOVLB  6
05C08:  ADDWF  x7E,F
05C0A:  MOVLW  00
05C0C:  ADDWFC x7F,F
05C0E:  MOVLW  32
05C10:  ADDWF  x7E,W
05C12:  MOVWF  01
05C14:  MOVLW  00
05C16:  ADDWFC x7F,W
05C18:  MOVWF  03
05C1A:  MOVF   01,W
05C1C:  ADDLW  D1
05C1E:  MOVWF  01
05C20:  MOVLW  01
05C22:  ADDWFC 03,F
05C24:  MOVFF  01,67E
05C28:  MOVFF  03,67F
05C2C:  MOVFF  03,6A6
05C30:  MOVFF  01,6A5
05C34:  MOVLB  0
05C36:  RCALL  56E4
05C38:  MOVF   01,F
05C3A:  BNZ   5C44
05C3C:  MOVLW  02
05C3E:  MOVWF  01
05C40:  BRA    5D82
05C42:  BRA    5CA0
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
05C44:  MOVLB  6
05C46:  CLRF   xB4
05C48:  MOVFF  66B,6B3
05C4C:  CLRF   xB6
05C4E:  MOVLW  B5
05C50:  MOVWF  xB5
05C52:  MOVLB  0
05C54:  CALL   082A
05C58:  MOVFF  02,67F
05C5C:  MOVFF  01,67E
05C60:  MOVLW  06
05C62:  MOVLB  6
05C64:  ADDWF  x7E,F
05C66:  MOVLW  00
05C68:  ADDWFC x7F,F
05C6A:  MOVLW  32
05C6C:  ADDWF  x7E,W
05C6E:  MOVWF  01
05C70:  MOVLW  00
05C72:  ADDWFC x7F,W
05C74:  MOVWF  03
05C76:  MOVF   01,W
05C78:  ADDLW  D1
05C7A:  MOVWF  01
05C7C:  MOVLW  01
05C7E:  ADDWFC 03,F
05C80:  MOVFF  01,67E
05C84:  MOVFF  03,67F
05C88:  MOVFF  03,6A6
05C8C:  MOVFF  01,6A5
05C90:  CLRF   xA8
05C92:  CLRF   xA7
05C94:  MOVLW  0A
05C96:  MOVWF  xA9
05C98:  MOVLB  0
05C9A:  RCALL  57D4
05C9C:  MOVFF  01,67D
....................    
....................    /*** GET CHANNEL MAP ***************/ 
....................    if      (0 == chMap[arg1-1]) sprintf(retData+strlen(retData), "%d,%c,", arg1, 'X');
05CA0:  MOVLW  01
05CA2:  MOVLB  6
05CA4:  SUBWF  x7D,W
05CA6:  MOVWF  x7F
05CA8:  CLRF   x81
05CAA:  MOVLW  60
05CAC:  MOVWF  x80
05CAE:  MOVLB  0
05CB0:  CALL   4582
05CB4:  BTFSC  01.0
05CB6:  BRA    5D0C
05CB8:  MOVLW  04
05CBA:  MOVLB  6
05CBC:  MOVWF  xB4
05CBE:  MOVLW  A7
05CC0:  MOVWF  xB3
05CC2:  MOVLB  0
05CC4:  RCALL  556C
05CC6:  MOVFF  02,03
05CCA:  MOVF   01,W
05CCC:  ADDLW  A7
05CCE:  MOVLB  6
05CD0:  MOVWF  x7E
05CD2:  MOVLW  04
05CD4:  ADDWFC 02,W
05CD6:  MOVWF  x7F
05CD8:  MOVFF  FE8,54B
05CDC:  MOVFF  67E,54A
05CE0:  MOVFF  67D,6A6
05CE4:  MOVLW  18
05CE6:  MOVWF  xA7
05CE8:  MOVLB  0
05CEA:  RCALL  5B28
05CEC:  MOVLW  2C
05CEE:  MOVLB  6
05CF0:  MOVWF  xC2
05CF2:  MOVLB  0
05CF4:  RCALL  561C
05CF6:  MOVLW  58
05CF8:  MOVLB  6
05CFA:  MOVWF  xC2
05CFC:  MOVLB  0
05CFE:  RCALL  561C
05D00:  MOVLW  2C
05D02:  MOVLB  6
05D04:  MOVWF  xC2
05D06:  MOVLB  0
05D08:  RCALL  561C
05D0A:  BRA    5D7E
....................    else if (1 == chMap[arg1-1]) sprintf(retData+strlen(retData), "%d,%c,", arg1, 'Y');
05D0C:  MOVLW  01
05D0E:  MOVLB  6
05D10:  SUBWF  x7D,W
05D12:  MOVWF  x7F
05D14:  CLRF   x81
05D16:  MOVLW  60
05D18:  MOVWF  x80
05D1A:  MOVLB  0
05D1C:  CALL   4582
05D20:  BTFSS  01.0
05D22:  BRA    5D78
05D24:  MOVLW  04
05D26:  MOVLB  6
05D28:  MOVWF  xB4
05D2A:  MOVLW  A7
05D2C:  MOVWF  xB3
05D2E:  MOVLB  0
05D30:  RCALL  556C
05D32:  MOVFF  02,03
05D36:  MOVF   01,W
05D38:  ADDLW  A7
05D3A:  MOVLB  6
05D3C:  MOVWF  x7E
05D3E:  MOVLW  04
05D40:  ADDWFC 02,W
05D42:  MOVWF  x7F
05D44:  MOVFF  FE8,54B
05D48:  MOVFF  67E,54A
05D4C:  MOVFF  67D,6A6
05D50:  MOVLW  18
05D52:  MOVWF  xA7
05D54:  MOVLB  0
05D56:  RCALL  5B28
05D58:  MOVLW  2C
05D5A:  MOVLB  6
05D5C:  MOVWF  xC2
05D5E:  MOVLB  0
05D60:  RCALL  561C
05D62:  MOVLW  59
05D64:  MOVLB  6
05D66:  MOVWF  xC2
05D68:  MOVLB  0
05D6A:  RCALL  561C
05D6C:  MOVLW  2C
05D6E:  MOVLB  6
05D70:  MOVWF  xC2
05D72:  MOVLB  0
05D74:  RCALL  561C
05D76:  BRA    5D7E
....................    else return INV_PARAM;
05D78:  MOVLW  02
05D7A:  MOVWF  01
05D7C:  BRA    5D82
....................    
....................    return SUCCESS;
05D7E:  MOVLW  00
05D80:  MOVWF  01
05D82:  RETURN 0
.................... }
.................... 
.................... int8 setOPchMap(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
05DC6:  MOVLB  6
05DC8:  CLRF   xB4
05DCA:  MOVFF  66B,6B3
05DCE:  CLRF   xB6
05DD0:  MOVLW  B5
05DD2:  MOVWF  xB5
05DD4:  MOVLB  0
05DD6:  CALL   082A
05DDA:  MOVFF  02,680
05DDE:  MOVFF  01,67F
05DE2:  MOVLW  06
05DE4:  MOVLB  6
05DE6:  ADDWF  x7F,F
05DE8:  MOVLW  00
05DEA:  ADDWFC x80,F
05DEC:  MOVLW  32
05DEE:  ADDWF  x7F,W
05DF0:  MOVWF  01
05DF2:  MOVLW  00
05DF4:  ADDWFC x80,W
05DF6:  MOVWF  03
05DF8:  MOVF   01,W
05DFA:  ADDLW  D1
05DFC:  MOVWF  01
05DFE:  MOVLW  01
05E00:  ADDWFC 03,F
05E02:  MOVFF  01,67F
05E06:  MOVFF  03,680
05E0A:  MOVFF  03,6A6
05E0E:  MOVFF  01,6A5
05E12:  MOVLB  0
05E14:  RCALL  56E4
05E16:  MOVF   01,F
05E18:  BNZ   5E22
05E1A:  MOVLW  02
05E1C:  MOVWF  01
05E1E:  BRA    5F72
05E20:  BRA    5E7E
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
05E22:  MOVLB  6
05E24:  CLRF   xB4
05E26:  MOVFF  66B,6B3
05E2A:  CLRF   xB6
05E2C:  MOVLW  B5
05E2E:  MOVWF  xB5
05E30:  MOVLB  0
05E32:  CALL   082A
05E36:  MOVFF  02,680
05E3A:  MOVFF  01,67F
05E3E:  MOVLW  06
05E40:  MOVLB  6
05E42:  ADDWF  x7F,F
05E44:  MOVLW  00
05E46:  ADDWFC x80,F
05E48:  MOVLW  32
05E4A:  ADDWF  x7F,W
05E4C:  MOVWF  01
05E4E:  MOVLW  00
05E50:  ADDWFC x80,W
05E52:  MOVWF  03
05E54:  MOVF   01,W
05E56:  ADDLW  D1
05E58:  MOVWF  01
05E5A:  MOVLW  01
05E5C:  ADDWFC 03,F
05E5E:  MOVFF  01,67F
05E62:  MOVFF  03,680
05E66:  MOVFF  03,6A6
05E6A:  MOVFF  01,6A5
05E6E:  CLRF   xA8
05E70:  CLRF   xA7
05E72:  MOVLW  0A
05E74:  MOVWF  xA9
05E76:  MOVLB  0
05E78:  RCALL  57D4
05E7A:  MOVFF  01,67D
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
05E7E:  MOVLB  6
05E80:  CLRF   xB4
05E82:  MOVFF  66B,6B3
05E86:  CLRF   xB6
05E88:  MOVLW  B5
05E8A:  MOVWF  xB5
05E8C:  MOVLB  0
05E8E:  CALL   082A
05E92:  MOVFF  02,680
05E96:  MOVFF  01,67F
05E9A:  MOVLW  06
05E9C:  MOVLB  6
05E9E:  ADDWF  x7F,F
05EA0:  MOVLW  00
05EA2:  ADDWFC x80,F
05EA4:  MOVLW  4B
05EA6:  ADDWF  x7F,W
05EA8:  MOVWF  01
05EAA:  MOVLW  00
05EAC:  ADDWFC x80,W
05EAE:  MOVWF  03
05EB0:  MOVF   01,W
05EB2:  ADDLW  D1
05EB4:  MOVWF  01
05EB6:  MOVLW  01
05EB8:  ADDWFC 03,F
05EBA:  MOVFF  01,67F
05EBE:  MOVFF  03,680
05EC2:  MOVFF  03,6B4
05EC6:  MOVFF  01,6B3
05ECA:  MOVLB  0
05ECC:  CALL   556C
05ED0:  MOVFF  02,03
05ED4:  MOVF   01,W
05ED6:  SUBLW  01
05ED8:  BNZ   5EDE
05EDA:  MOVF   03,F
05EDC:  BZ    5EE6
05EDE:  MOVLW  02
05EE0:  MOVWF  01
05EE2:  BRA    5F72
05EE4:  BRA    5F26
....................    else arg2 = SERcmd[rec].p[3][0];
05EE6:  MOVLB  6
05EE8:  CLRF   xB4
05EEA:  MOVFF  66B,6B3
05EEE:  CLRF   xB6
05EF0:  MOVLW  B5
05EF2:  MOVWF  xB5
05EF4:  MOVLB  0
05EF6:  CALL   082A
05EFA:  MOVFF  02,680
05EFE:  MOVFF  01,67F
05F02:  MOVLW  06
05F04:  MOVLB  6
05F06:  ADDWF  x7F,F
05F08:  MOVLW  00
05F0A:  ADDWFC x80,F
05F0C:  MOVLW  4B
05F0E:  ADDWF  x7F,F
05F10:  MOVLW  00
05F12:  ADDWFC x80,F
05F14:  MOVLW  D1
05F16:  ADDWF  x7F,W
05F18:  MOVWF  FE9
05F1A:  MOVLW  01
05F1C:  ADDWFC x80,W
05F1E:  MOVWF  FEA
05F20:  MOVFF  FEF,67E
05F24:  MOVLB  0
....................    
....................    /*** SET CHANNEL MAP ***************/
....................    if      ('X' == arg2) chMap[arg1-1] = chX;
05F26:  MOVLB  6
05F28:  MOVF   x7E,W
05F2A:  SUBLW  58
05F2C:  BNZ   5F46
05F2E:  MOVLW  01
05F30:  SUBWF  x7D,W
05F32:  MOVWF  x7F
05F34:  MOVWF  x94
05F36:  CLRF   x95
05F38:  CLRF   x97
05F3A:  MOVLW  60
05F3C:  MOVWF  x96
05F3E:  MOVLB  0
05F40:  RCALL  5D84
05F42:  BRA    5F6E
05F44:  MOVLB  6
....................    else if ('Y' == arg2) chMap[arg1-1] = chY;
05F46:  MOVF   x7E,W
05F48:  SUBLW  59
05F4A:  BNZ   5F66
05F4C:  MOVLW  01
05F4E:  SUBWF  x7D,W
05F50:  MOVWF  x7F
05F52:  MOVWF  x94
05F54:  MOVLW  01
05F56:  MOVWF  x95
05F58:  CLRF   x97
05F5A:  MOVLW  60
05F5C:  MOVWF  x96
05F5E:  MOVLB  0
05F60:  RCALL  5D84
05F62:  BRA    5F6E
05F64:  MOVLB  6
....................    else return INV_PARAM;
05F66:  MOVLW  02
05F68:  MOVWF  01
05F6A:  MOVLB  0
05F6C:  BRA    5F72
....................    
....................    return SUCCESS;
05F6E:  MOVLW  00
05F70:  MOVWF  01
05F72:  RETURN 0
.................... }
.................... 
.................... int8 getIPchMode(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
05F9E:  MOVLB  6
05FA0:  CLRF   xB4
05FA2:  MOVFF  66B,6B3
05FA6:  CLRF   xB6
05FA8:  MOVLW  B5
05FAA:  MOVWF  xB5
05FAC:  MOVLB  0
05FAE:  CALL   082A
05FB2:  MOVFF  02,67F
05FB6:  MOVFF  01,67E
05FBA:  MOVLW  06
05FBC:  MOVLB  6
05FBE:  ADDWF  x7E,F
05FC0:  MOVLW  00
05FC2:  ADDWFC x7F,F
05FC4:  MOVLW  32
05FC6:  ADDWF  x7E,W
05FC8:  MOVWF  01
05FCA:  MOVLW  00
05FCC:  ADDWFC x7F,W
05FCE:  MOVWF  03
05FD0:  MOVF   01,W
05FD2:  ADDLW  D1
05FD4:  MOVWF  01
05FD6:  MOVLW  01
05FD8:  ADDWFC 03,F
05FDA:  MOVFF  01,67E
05FDE:  MOVFF  03,67F
05FE2:  MOVFF  03,6A6
05FE6:  MOVFF  01,6A5
05FEA:  MOVLB  0
05FEC:  CALL   56E4
05FF0:  MOVF   01,F
05FF2:  BNZ   5FFC
05FF4:  MOVLW  02
05FF6:  MOVWF  01
05FF8:  BRA    6128
05FFA:  BRA    605A
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
05FFC:  MOVLB  6
05FFE:  CLRF   xB4
06000:  MOVFF  66B,6B3
06004:  CLRF   xB6
06006:  MOVLW  B5
06008:  MOVWF  xB5
0600A:  MOVLB  0
0600C:  CALL   082A
06010:  MOVFF  02,67F
06014:  MOVFF  01,67E
06018:  MOVLW  06
0601A:  MOVLB  6
0601C:  ADDWF  x7E,F
0601E:  MOVLW  00
06020:  ADDWFC x7F,F
06022:  MOVLW  32
06024:  ADDWF  x7E,W
06026:  MOVWF  01
06028:  MOVLW  00
0602A:  ADDWFC x7F,W
0602C:  MOVWF  03
0602E:  MOVF   01,W
06030:  ADDLW  D1
06032:  MOVWF  01
06034:  MOVLW  01
06036:  ADDWFC 03,F
06038:  MOVFF  01,67E
0603C:  MOVFF  03,67F
06040:  MOVFF  03,6A6
06044:  MOVFF  01,6A5
06048:  CLRF   xA8
0604A:  CLRF   xA7
0604C:  MOVLW  0A
0604E:  MOVWF  xA9
06050:  MOVLB  0
06052:  CALL   57D4
06056:  MOVFF  01,67D
....................    
....................    /*** GET INPUT MAP *****************/
....................    if      (0 == chMode[arg1-1]) sprintf(retData+strlen(retData), "%d,MANUAL,", arg1);
0605A:  MOVLW  01
0605C:  MOVLB  6
0605E:  SUBWF  x7D,W
06060:  MOVWF  x7F
06062:  CLRF   x81
06064:  MOVLW  61
06066:  MOVWF  x80
06068:  MOVLB  0
0606A:  CALL   4582
0606E:  BTFSC  01.0
06070:  BRA    60BC
06072:  MOVLW  04
06074:  MOVLB  6
06076:  MOVWF  xB4
06078:  MOVLW  A7
0607A:  MOVWF  xB3
0607C:  MOVLB  0
0607E:  CALL   556C
06082:  MOVFF  02,03
06086:  MOVF   01,W
06088:  ADDLW  A7
0608A:  MOVLB  6
0608C:  MOVWF  x7E
0608E:  MOVLW  04
06090:  ADDWFC 02,W
06092:  MOVWF  x7F
06094:  MOVFF  FE8,54B
06098:  MOVFF  67E,54A
0609C:  MOVFF  67D,6A6
060A0:  MOVLW  18
060A2:  MOVWF  xA7
060A4:  MOVLB  0
060A6:  RCALL  5B28
060A8:  MOVLW  42
060AA:  MOVWF  FF6
060AC:  MOVLW  03
060AE:  MOVWF  FF7
060B0:  MOVLW  08
060B2:  MOVLB  6
060B4:  MOVWF  x81
060B6:  MOVLB  0
060B8:  RCALL  5F74
060BA:  BRA    6124
....................    else if (1 == chMode[arg1-1]) sprintf(retData+strlen(retData), "%d,MAGSNS,", arg1);
060BC:  MOVLW  01
060BE:  MOVLB  6
060C0:  SUBWF  x7D,W
060C2:  MOVWF  x7F
060C4:  CLRF   x81
060C6:  MOVLW  61
060C8:  MOVWF  x80
060CA:  MOVLB  0
060CC:  CALL   4582
060D0:  BTFSS  01.0
060D2:  BRA    611E
060D4:  MOVLW  04
060D6:  MOVLB  6
060D8:  MOVWF  xB4
060DA:  MOVLW  A7
060DC:  MOVWF  xB3
060DE:  MOVLB  0
060E0:  CALL   556C
060E4:  MOVFF  02,03
060E8:  MOVF   01,W
060EA:  ADDLW  A7
060EC:  MOVLB  6
060EE:  MOVWF  x7E
060F0:  MOVLW  04
060F2:  ADDWFC 02,W
060F4:  MOVWF  x7F
060F6:  MOVFF  FE8,54B
060FA:  MOVFF  67E,54A
060FE:  MOVFF  67D,6A6
06102:  MOVLW  18
06104:  MOVWF  xA7
06106:  MOVLB  0
06108:  RCALL  5B28
0610A:  MOVLW  4E
0610C:  MOVWF  FF6
0610E:  MOVLW  03
06110:  MOVWF  FF7
06112:  MOVLW  08
06114:  MOVLB  6
06116:  MOVWF  x81
06118:  MOVLB  0
0611A:  RCALL  5F74
0611C:  BRA    6124
....................    else return INV_PARAM;
0611E:  MOVLW  02
06120:  MOVWF  01
06122:  BRA    6128
....................    
....................    return SUCCESS;
06124:  MOVLW  00
06126:  MOVWF  01
06128:  RETURN 0
.................... }
.................... 
.................... int8 setIPchMode(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char *arg2;
....................    char *s_manual = "MANUAL";
0612A:  MOVLW  4D
0612C:  MOVLB  6
0612E:  MOVWF  x82
06130:  MOVLW  41
06132:  MOVWF  x83
06134:  MOVLW  4E
06136:  MOVWF  x84
06138:  MOVLW  55
0613A:  MOVWF  x85
0613C:  MOVLW  41
0613E:  MOVWF  x86
06140:  MOVLW  4C
06142:  MOVWF  x87
06144:  CLRF   x88
06146:  MOVLW  06
06148:  MOVWF  x81
0614A:  MOVLW  82
0614C:  MOVWF  x80
....................    char *s_magsns = "MAGSNS";
0614E:  MOVLW  4D
06150:  MOVWF  x8B
06152:  MOVLW  41
06154:  MOVWF  x8C
06156:  MOVLW  47
06158:  MOVWF  x8D
0615A:  MOVLW  53
0615C:  MOVWF  x8E
0615E:  MOVLW  4E
06160:  MOVWF  x8F
06162:  MOVLW  53
06164:  MOVWF  x90
06166:  CLRF   x91
06168:  MOVLW  06
0616A:  MOVWF  x8A
0616C:  MOVLW  8B
0616E:  MOVWF  x89
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
06170:  CLRF   xB4
06172:  MOVFF  66B,6B3
06176:  CLRF   xB6
06178:  MOVLW  B5
0617A:  MOVWF  xB5
0617C:  MOVLB  0
0617E:  CALL   082A
06182:  MOVFF  02,693
06186:  MOVFF  01,692
0618A:  MOVLW  06
0618C:  MOVLB  6
0618E:  ADDWF  x92,F
06190:  MOVLW  00
06192:  ADDWFC x93,F
06194:  MOVLW  32
06196:  ADDWF  x92,W
06198:  MOVWF  01
0619A:  MOVLW  00
0619C:  ADDWFC x93,W
0619E:  MOVWF  03
061A0:  MOVF   01,W
061A2:  ADDLW  D1
061A4:  MOVWF  01
061A6:  MOVLW  01
061A8:  ADDWFC 03,F
061AA:  MOVFF  01,692
061AE:  MOVFF  03,693
061B2:  MOVFF  03,6A6
061B6:  MOVFF  01,6A5
061BA:  MOVLB  0
061BC:  CALL   56E4
061C0:  MOVF   01,F
061C2:  BNZ   61CC
061C4:  MOVLW  02
061C6:  MOVWF  01
061C8:  BRA    6342
061CA:  BRA    622A
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
061CC:  MOVLB  6
061CE:  CLRF   xB4
061D0:  MOVFF  66B,6B3
061D4:  CLRF   xB6
061D6:  MOVLW  B5
061D8:  MOVWF  xB5
061DA:  MOVLB  0
061DC:  CALL   082A
061E0:  MOVFF  02,693
061E4:  MOVFF  01,692
061E8:  MOVLW  06
061EA:  MOVLB  6
061EC:  ADDWF  x92,F
061EE:  MOVLW  00
061F0:  ADDWFC x93,F
061F2:  MOVLW  32
061F4:  ADDWF  x92,W
061F6:  MOVWF  01
061F8:  MOVLW  00
061FA:  ADDWFC x93,W
061FC:  MOVWF  03
061FE:  MOVF   01,W
06200:  ADDLW  D1
06202:  MOVWF  01
06204:  MOVLW  01
06206:  ADDWFC 03,F
06208:  MOVFF  01,692
0620C:  MOVFF  03,693
06210:  MOVFF  03,6A6
06214:  MOVFF  01,6A5
06218:  CLRF   xA8
0621A:  CLRF   xA7
0621C:  MOVLW  0A
0621E:  MOVWF  xA9
06220:  MOVLB  0
06222:  CALL   57D4
06226:  MOVFF  01,67D
....................    
....................    if (0 == strlen(SERcmd[rec].p[3])) return INV_PARAM;
0622A:  MOVLB  6
0622C:  CLRF   xB4
0622E:  MOVFF  66B,6B3
06232:  CLRF   xB6
06234:  MOVLW  B5
06236:  MOVWF  xB5
06238:  MOVLB  0
0623A:  CALL   082A
0623E:  MOVFF  02,693
06242:  MOVFF  01,692
06246:  MOVLW  06
06248:  MOVLB  6
0624A:  ADDWF  x92,F
0624C:  MOVLW  00
0624E:  ADDWFC x93,F
06250:  MOVLW  4B
06252:  ADDWF  x92,W
06254:  MOVWF  01
06256:  MOVLW  00
06258:  ADDWFC x93,W
0625A:  MOVWF  03
0625C:  MOVF   01,W
0625E:  ADDLW  D1
06260:  MOVWF  01
06262:  MOVLW  01
06264:  ADDWFC 03,F
06266:  MOVFF  01,692
0626A:  MOVFF  03,693
0626E:  MOVFF  03,6B4
06272:  MOVFF  01,6B3
06276:  MOVLB  0
06278:  CALL   556C
0627C:  MOVFF  02,03
06280:  MOVF   01,W
06282:  BNZ   6290
06284:  MOVF   03,F
06286:  BNZ   6290
06288:  MOVLW  02
0628A:  MOVWF  01
0628C:  BRA    6342
0628E:  BRA    62D6
....................    else arg2 = SERcmd[rec].p[3];
06290:  MOVLB  6
06292:  CLRF   xB4
06294:  MOVFF  66B,6B3
06298:  CLRF   xB6
0629A:  MOVLW  B5
0629C:  MOVWF  xB5
0629E:  MOVLB  0
062A0:  CALL   082A
062A4:  MOVFF  02,693
062A8:  MOVFF  01,692
062AC:  MOVLW  06
062AE:  MOVLB  6
062B0:  ADDWF  x92,F
062B2:  MOVLW  00
062B4:  ADDWFC x93,F
062B6:  MOVLW  4B
062B8:  ADDWF  x92,W
062BA:  MOVWF  01
062BC:  MOVLW  00
062BE:  ADDWFC x93,W
062C0:  MOVWF  03
062C2:  MOVF   01,W
062C4:  ADDLW  D1
062C6:  MOVWF  01
062C8:  MOVLW  01
062CA:  ADDWFC 03,F
062CC:  MOVFF  01,67E
062D0:  MOVFF  03,67F
062D4:  MOVLB  0
....................    
....................    /*** SET INPUT MAP *****************/
....................    if      (0 == strcmp(s_manual, arg2)) chMode[arg1-1] = MANUAL;
062D6:  MOVFF  681,6B4
062DA:  MOVFF  680,6B3
062DE:  MOVFF  67F,6B6
062E2:  MOVFF  67E,6B5
062E6:  CALL   55A4
062EA:  MOVF   01,F
062EC:  BNZ   6306
062EE:  MOVLW  01
062F0:  MOVLB  6
062F2:  SUBWF  x7D,W
062F4:  MOVWF  x92
062F6:  MOVWF  x94
062F8:  CLRF   x95
062FA:  CLRF   x97
062FC:  MOVLW  61
062FE:  MOVWF  x96
06300:  MOVLB  0
06302:  RCALL  5D84
06304:  BRA    633E
....................    else if (0 == strcmp(s_magsns, arg2)) chMode[arg1-1] = MAGSNS;
06306:  MOVFF  68A,6B4
0630A:  MOVFF  689,6B3
0630E:  MOVFF  67F,6B6
06312:  MOVFF  67E,6B5
06316:  CALL   55A4
0631A:  MOVF   01,F
0631C:  BNZ   6338
0631E:  MOVLW  01
06320:  MOVLB  6
06322:  SUBWF  x7D,W
06324:  MOVWF  x92
06326:  MOVWF  x94
06328:  MOVLW  01
0632A:  MOVWF  x95
0632C:  CLRF   x97
0632E:  MOVLW  61
06330:  MOVWF  x96
06332:  MOVLB  0
06334:  RCALL  5D84
06336:  BRA    633E
....................    else return INV_PARAM;
06338:  MOVLW  02
0633A:  MOVWF  01
0633C:  BRA    6342
....................    
....................    return SUCCESS;
0633E:  MOVLW  00
06340:  MOVWF  01
06342:  RETURN 0
.................... }
.................... 
.................... int8 getPIDvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/ 
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
065CA:  MOVLB  6
065CC:  CLRF   xB4
065CE:  MOVFF  66B,6B3
065D2:  CLRF   xB6
065D4:  MOVLW  B5
065D6:  MOVWF  xB5
065D8:  MOVLB  0
065DA:  CALL   082A
065DE:  MOVFF  02,680
065E2:  MOVFF  01,67F
065E6:  MOVLW  06
065E8:  MOVLB  6
065EA:  ADDWF  x7F,F
065EC:  MOVLW  00
065EE:  ADDWFC x80,F
065F0:  MOVLW  32
065F2:  ADDWF  x7F,W
065F4:  MOVWF  01
065F6:  MOVLW  00
065F8:  ADDWFC x80,W
065FA:  MOVWF  03
065FC:  MOVF   01,W
065FE:  ADDLW  D1
06600:  MOVWF  01
06602:  MOVLW  01
06604:  ADDWFC 03,F
06606:  MOVFF  01,67F
0660A:  MOVFF  03,680
0660E:  MOVFF  03,6A6
06612:  MOVFF  01,6A5
06616:  MOVLB  0
06618:  CALL   56E4
0661C:  MOVF   01,F
0661E:  BNZ   6628
06620:  MOVLW  02
06622:  MOVWF  01
06624:  BRA    6A7E
06626:  BRA    6686
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06628:  MOVLB  6
0662A:  CLRF   xB4
0662C:  MOVFF  66B,6B3
06630:  CLRF   xB6
06632:  MOVLW  B5
06634:  MOVWF  xB5
06636:  MOVLB  0
06638:  CALL   082A
0663C:  MOVFF  02,680
06640:  MOVFF  01,67F
06644:  MOVLW  06
06646:  MOVLB  6
06648:  ADDWF  x7F,F
0664A:  MOVLW  00
0664C:  ADDWFC x80,F
0664E:  MOVLW  32
06650:  ADDWF  x7F,W
06652:  MOVWF  01
06654:  MOVLW  00
06656:  ADDWFC x80,W
06658:  MOVWF  03
0665A:  MOVF   01,W
0665C:  ADDLW  D1
0665E:  MOVWF  01
06660:  MOVLW  01
06662:  ADDWFC 03,F
06664:  MOVFF  01,67F
06668:  MOVFF  03,680
0666C:  MOVFF  03,6A6
06670:  MOVFF  01,6A5
06674:  CLRF   xA8
06676:  CLRF   xA7
06678:  MOVLW  0A
0667A:  MOVWF  xA9
0667C:  MOVLB  0
0667E:  CALL   57D4
06682:  MOVFF  01,67D
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
06686:  MOVLB  6
06688:  CLRF   xB4
0668A:  MOVFF  66B,6B3
0668E:  CLRF   xB6
06690:  MOVLW  B5
06692:  MOVWF  xB5
06694:  MOVLB  0
06696:  CALL   082A
0669A:  MOVFF  02,680
0669E:  MOVFF  01,67F
066A2:  MOVLW  06
066A4:  MOVLB  6
066A6:  ADDWF  x7F,F
066A8:  MOVLW  00
066AA:  ADDWFC x80,F
066AC:  MOVLW  4B
066AE:  ADDWF  x7F,W
066B0:  MOVWF  01
066B2:  MOVLW  00
066B4:  ADDWFC x80,W
066B6:  MOVWF  03
066B8:  MOVF   01,W
066BA:  ADDLW  D1
066BC:  MOVWF  01
066BE:  MOVLW  01
066C0:  ADDWFC 03,F
066C2:  MOVFF  01,67F
066C6:  MOVFF  03,680
066CA:  MOVFF  03,6B4
066CE:  MOVFF  01,6B3
066D2:  MOVLB  0
066D4:  CALL   556C
066D8:  MOVFF  02,03
066DC:  MOVF   01,W
066DE:  SUBLW  01
066E0:  BNZ   66E6
066E2:  MOVF   03,F
066E4:  BZ    66EE
066E6:  MOVLW  02
066E8:  MOVWF  01
066EA:  BRA    6A7E
066EC:  BRA    672E
....................    else arg2 = SERcmd[rec].p[3][0];
066EE:  MOVLB  6
066F0:  CLRF   xB4
066F2:  MOVFF  66B,6B3
066F6:  CLRF   xB6
066F8:  MOVLW  B5
066FA:  MOVWF  xB5
066FC:  MOVLB  0
066FE:  CALL   082A
06702:  MOVFF  02,680
06706:  MOVFF  01,67F
0670A:  MOVLW  06
0670C:  MOVLB  6
0670E:  ADDWF  x7F,F
06710:  MOVLW  00
06712:  ADDWFC x80,F
06714:  MOVLW  4B
06716:  ADDWF  x7F,F
06718:  MOVLW  00
0671A:  ADDWFC x80,F
0671C:  MOVLW  D1
0671E:  ADDWF  x7F,W
06720:  MOVWF  FE9
06722:  MOVLW  01
06724:  ADDWFC x80,W
06726:  MOVWF  FEA
06728:  MOVFF  FEF,67E
0672C:  MOVLB  0
....................    
....................    /*** GET P, I, D, or A(LL) VALUE **********/
....................    if      ('P' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kP);
0672E:  MOVLB  6
06730:  MOVF   x7E,W
06732:  SUBLW  50
06734:  BNZ   67CE
06736:  MOVLW  04
06738:  MOVWF  xB4
0673A:  MOVLW  A7
0673C:  MOVWF  xB3
0673E:  MOVLB  0
06740:  CALL   556C
06744:  MOVFF  02,03
06748:  MOVF   01,W
0674A:  ADDLW  A7
0674C:  MOVLB  6
0674E:  MOVWF  x7F
06750:  MOVLW  04
06752:  ADDWFC 02,W
06754:  MOVWF  x80
06756:  MOVLW  01
06758:  SUBWF  x7D,W
0675A:  MULLW  20
0675C:  MOVF   FF3,W
0675E:  CLRF   x82
06760:  MOVWF  x81
06762:  MOVLW  20
06764:  ADDWF  x81,W
06766:  MOVWF  FE9
06768:  MOVLW  00
0676A:  ADDWFC x82,W
0676C:  MOVWF  FEA
0676E:  MOVFF  FEF,683
06772:  MOVFF  FEC,684
06776:  MOVFF  FEC,685
0677A:  MOVFF  FEC,686
0677E:  MOVFF  680,54B
06782:  MOVFF  67F,54A
06786:  MOVFF  67D,6A6
0678A:  MOVLW  18
0678C:  MOVWF  xA7
0678E:  MOVLB  0
06790:  CALL   5B28
06794:  MOVLW  2C
06796:  MOVLB  6
06798:  MOVWF  xC2
0679A:  MOVLB  0
0679C:  CALL   561C
067A0:  MOVLW  89
067A2:  MOVWF  FE9
067A4:  MOVFF  686,6B8
067A8:  MOVFF  685,6B7
067AC:  MOVFF  684,6B6
067B0:  MOVFF  683,6B5
067B4:  MOVLW  02
067B6:  MOVLB  6
067B8:  MOVWF  xB9
067BA:  MOVLB  0
067BC:  RCALL  641A
067BE:  MOVLW  2C
067C0:  MOVLB  6
067C2:  MOVWF  xC2
067C4:  MOVLB  0
067C6:  CALL   561C
067CA:  BRA    6A7A
067CC:  MOVLB  6
....................    else if ('I' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kI);
067CE:  MOVF   x7E,W
067D0:  SUBLW  49
067D2:  BNZ   6874
067D4:  MOVLW  04
067D6:  MOVWF  xB4
067D8:  MOVLW  A7
067DA:  MOVWF  xB3
067DC:  MOVLB  0
067DE:  CALL   556C
067E2:  MOVF   01,W
067E4:  ADDLW  A7
067E6:  MOVLB  6
067E8:  MOVWF  x7F
067EA:  MOVLW  04
067EC:  ADDWFC 02,W
067EE:  MOVWF  x80
067F0:  MOVLW  01
067F2:  SUBWF  x7D,W
067F4:  MULLW  20
067F6:  MOVF   FF3,W
067F8:  CLRF   x82
067FA:  MOVWF  x81
067FC:  MOVLW  04
067FE:  ADDWF  x81,W
06800:  MOVWF  01
06802:  MOVLW  00
06804:  ADDWFC x82,W
06806:  MOVWF  03
06808:  MOVF   01,W
0680A:  ADDLW  20
0680C:  MOVWF  FE9
0680E:  MOVLW  00
06810:  ADDWFC 03,W
06812:  MOVWF  FEA
06814:  MOVFF  FEF,681
06818:  MOVFF  FEC,682
0681C:  MOVFF  FEC,683
06820:  MOVFF  FEC,684
06824:  MOVFF  680,54B
06828:  MOVFF  67F,54A
0682C:  MOVFF  67D,6A6
06830:  MOVLW  18
06832:  MOVWF  xA7
06834:  MOVLB  0
06836:  CALL   5B28
0683A:  MOVLW  2C
0683C:  MOVLB  6
0683E:  MOVWF  xC2
06840:  MOVLB  0
06842:  CALL   561C
06846:  MOVLW  89
06848:  MOVWF  FE9
0684A:  MOVFF  684,6B8
0684E:  MOVFF  683,6B7
06852:  MOVFF  682,6B6
06856:  MOVFF  681,6B5
0685A:  MOVLW  02
0685C:  MOVLB  6
0685E:  MOVWF  xB9
06860:  MOVLB  0
06862:  RCALL  641A
06864:  MOVLW  2C
06866:  MOVLB  6
06868:  MOVWF  xC2
0686A:  MOVLB  0
0686C:  CALL   561C
06870:  BRA    6A7A
06872:  MOVLB  6
....................    else if ('D' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kD);
06874:  MOVF   x7E,W
06876:  SUBLW  44
06878:  BNZ   691A
0687A:  MOVLW  04
0687C:  MOVWF  xB4
0687E:  MOVLW  A7
06880:  MOVWF  xB3
06882:  MOVLB  0
06884:  CALL   556C
06888:  MOVF   01,W
0688A:  ADDLW  A7
0688C:  MOVLB  6
0688E:  MOVWF  x7F
06890:  MOVLW  04
06892:  ADDWFC 02,W
06894:  MOVWF  x80
06896:  MOVLW  01
06898:  SUBWF  x7D,W
0689A:  MULLW  20
0689C:  MOVF   FF3,W
0689E:  CLRF   x82
068A0:  MOVWF  x81
068A2:  MOVLW  08
068A4:  ADDWF  x81,W
068A6:  MOVWF  01
068A8:  MOVLW  00
068AA:  ADDWFC x82,W
068AC:  MOVWF  03
068AE:  MOVF   01,W
068B0:  ADDLW  20
068B2:  MOVWF  FE9
068B4:  MOVLW  00
068B6:  ADDWFC 03,W
068B8:  MOVWF  FEA
068BA:  MOVFF  FEF,681
068BE:  MOVFF  FEC,682
068C2:  MOVFF  FEC,683
068C6:  MOVFF  FEC,684
068CA:  MOVFF  680,54B
068CE:  MOVFF  67F,54A
068D2:  MOVFF  67D,6A6
068D6:  MOVLW  18
068D8:  MOVWF  xA7
068DA:  MOVLB  0
068DC:  CALL   5B28
068E0:  MOVLW  2C
068E2:  MOVLB  6
068E4:  MOVWF  xC2
068E6:  MOVLB  0
068E8:  CALL   561C
068EC:  MOVLW  89
068EE:  MOVWF  FE9
068F0:  MOVFF  684,6B8
068F4:  MOVFF  683,6B7
068F8:  MOVFF  682,6B6
068FC:  MOVFF  681,6B5
06900:  MOVLW  02
06902:  MOVLB  6
06904:  MOVWF  xB9
06906:  MOVLB  0
06908:  RCALL  641A
0690A:  MOVLW  2C
0690C:  MOVLB  6
0690E:  MOVWF  xC2
06910:  MOVLB  0
06912:  CALL   561C
06916:  BRA    6A7A
06918:  MOVLB  6
....................    else if ('A' == arg2) sprintf(retData+strlen(retData), "%d,%f,%f,%f,", arg1, PID[arg1-1].kP, PID[arg1-1].kI, PID[arg1-1].kD);
0691A:  MOVF   x7E,W
0691C:  SUBLW  41
0691E:  BTFSS  FD8.2
06920:  BRA    6A72
06922:  MOVLW  04
06924:  MOVWF  xB4
06926:  MOVLW  A7
06928:  MOVWF  xB3
0692A:  MOVLB  0
0692C:  CALL   556C
06930:  MOVF   01,W
06932:  ADDLW  A7
06934:  MOVLB  6
06936:  MOVWF  x7F
06938:  MOVLW  04
0693A:  ADDWFC 02,W
0693C:  MOVWF  x80
0693E:  MOVLW  01
06940:  SUBWF  x7D,W
06942:  MULLW  20
06944:  MOVF   FF3,W
06946:  CLRF   x82
06948:  MOVWF  x81
0694A:  MOVLW  20
0694C:  ADDWF  x81,W
0694E:  MOVWF  FE9
06950:  MOVLW  00
06952:  ADDWFC x82,W
06954:  MOVWF  FEA
06956:  MOVFF  FEF,683
0695A:  MOVFF  FEC,684
0695E:  MOVFF  FEC,685
06962:  MOVFF  FEC,686
06966:  MOVLW  01
06968:  SUBWF  x7D,W
0696A:  MULLW  20
0696C:  MOVF   FF3,W
0696E:  CLRF   x88
06970:  MOVWF  x87
06972:  MOVLW  04
06974:  ADDWF  x87,W
06976:  MOVWF  01
06978:  MOVLW  00
0697A:  ADDWFC x88,W
0697C:  MOVWF  03
0697E:  MOVF   01,W
06980:  ADDLW  20
06982:  MOVWF  FE9
06984:  MOVLW  00
06986:  ADDWFC 03,W
06988:  MOVWF  FEA
0698A:  MOVFF  FEF,687
0698E:  MOVFF  FEC,688
06992:  MOVFF  FEC,689
06996:  MOVFF  FEC,68A
0699A:  MOVLW  01
0699C:  SUBWF  x7D,W
0699E:  MULLW  20
069A0:  MOVF   FF3,W
069A2:  CLRF   x8C
069A4:  MOVWF  x8B
069A6:  MOVLW  08
069A8:  ADDWF  x8B,W
069AA:  MOVWF  01
069AC:  MOVLW  00
069AE:  ADDWFC x8C,W
069B0:  MOVWF  03
069B2:  MOVF   01,W
069B4:  ADDLW  20
069B6:  MOVWF  FE9
069B8:  MOVLW  00
069BA:  ADDWFC 03,W
069BC:  MOVWF  FEA
069BE:  MOVFF  FEF,68B
069C2:  MOVFF  FEC,68C
069C6:  MOVFF  FEC,68D
069CA:  MOVFF  FEC,68E
069CE:  MOVFF  680,54B
069D2:  MOVFF  67F,54A
069D6:  MOVFF  67D,6A6
069DA:  MOVLW  18
069DC:  MOVWF  xA7
069DE:  MOVLB  0
069E0:  CALL   5B28
069E4:  MOVLW  2C
069E6:  MOVLB  6
069E8:  MOVWF  xC2
069EA:  MOVLB  0
069EC:  CALL   561C
069F0:  MOVLW  89
069F2:  MOVWF  FE9
069F4:  MOVFF  686,6B8
069F8:  MOVFF  685,6B7
069FC:  MOVFF  684,6B6
06A00:  MOVFF  683,6B5
06A04:  MOVLW  02
06A06:  MOVLB  6
06A08:  MOVWF  xB9
06A0A:  MOVLB  0
06A0C:  RCALL  641A
06A0E:  MOVLW  2C
06A10:  MOVLB  6
06A12:  MOVWF  xC2
06A14:  MOVLB  0
06A16:  CALL   561C
06A1A:  MOVLW  89
06A1C:  MOVWF  FE9
06A1E:  MOVFF  68A,6B8
06A22:  MOVFF  689,6B7
06A26:  MOVFF  688,6B6
06A2A:  MOVFF  687,6B5
06A2E:  MOVLW  02
06A30:  MOVLB  6
06A32:  MOVWF  xB9
06A34:  MOVLB  0
06A36:  RCALL  641A
06A38:  MOVLW  2C
06A3A:  MOVLB  6
06A3C:  MOVWF  xC2
06A3E:  MOVLB  0
06A40:  CALL   561C
06A44:  MOVLW  89
06A46:  MOVWF  FE9
06A48:  MOVFF  68E,6B8
06A4C:  MOVFF  68D,6B7
06A50:  MOVFF  68C,6B6
06A54:  MOVFF  68B,6B5
06A58:  MOVLW  02
06A5A:  MOVLB  6
06A5C:  MOVWF  xB9
06A5E:  MOVLB  0
06A60:  RCALL  641A
06A62:  MOVLW  2C
06A64:  MOVLB  6
06A66:  MOVWF  xC2
06A68:  MOVLB  0
06A6A:  CALL   561C
06A6E:  BRA    6A7A
06A70:  MOVLB  6
....................    else return INV_PARAM;
06A72:  MOVLW  02
06A74:  MOVWF  01
06A76:  MOVLB  0
06A78:  BRA    6A7E
....................    
....................    return SUCCESS;
06A7A:  MOVLW  00
06A7C:  MOVWF  01
06A7E:  RETURN 0
.................... }
.................... 
.................... int8 setPIDvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char  arg2;
....................    float arg3;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
06D9C:  MOVLB  6
06D9E:  CLRF   xB4
06DA0:  MOVFF  66B,6B3
06DA4:  CLRF   xB6
06DA6:  MOVLW  B5
06DA8:  MOVWF  xB5
06DAA:  MOVLB  0
06DAC:  CALL   082A
06DB0:  MOVFF  02,684
06DB4:  MOVFF  01,683
06DB8:  MOVLW  06
06DBA:  MOVLB  6
06DBC:  ADDWF  x83,F
06DBE:  MOVLW  00
06DC0:  ADDWFC x84,F
06DC2:  MOVLW  32
06DC4:  ADDWF  x83,W
06DC6:  MOVWF  01
06DC8:  MOVLW  00
06DCA:  ADDWFC x84,W
06DCC:  MOVWF  03
06DCE:  MOVF   01,W
06DD0:  ADDLW  D1
06DD2:  MOVWF  01
06DD4:  MOVLW  01
06DD6:  ADDWFC 03,F
06DD8:  MOVFF  01,683
06DDC:  MOVFF  03,684
06DE0:  MOVFF  03,6A6
06DE4:  MOVFF  01,6A5
06DE8:  MOVLB  0
06DEA:  CALL   56E4
06DEE:  MOVF   01,F
06DF0:  BNZ   6DFA
06DF2:  MOVLW  02
06DF4:  MOVWF  01
06DF6:  BRA    707A
06DF8:  BRA    6E58
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06DFA:  MOVLB  6
06DFC:  CLRF   xB4
06DFE:  MOVFF  66B,6B3
06E02:  CLRF   xB6
06E04:  MOVLW  B5
06E06:  MOVWF  xB5
06E08:  MOVLB  0
06E0A:  CALL   082A
06E0E:  MOVFF  02,684
06E12:  MOVFF  01,683
06E16:  MOVLW  06
06E18:  MOVLB  6
06E1A:  ADDWF  x83,F
06E1C:  MOVLW  00
06E1E:  ADDWFC x84,F
06E20:  MOVLW  32
06E22:  ADDWF  x83,W
06E24:  MOVWF  01
06E26:  MOVLW  00
06E28:  ADDWFC x84,W
06E2A:  MOVWF  03
06E2C:  MOVF   01,W
06E2E:  ADDLW  D1
06E30:  MOVWF  01
06E32:  MOVLW  01
06E34:  ADDWFC 03,F
06E36:  MOVFF  01,683
06E3A:  MOVFF  03,684
06E3E:  MOVFF  03,6A6
06E42:  MOVFF  01,6A5
06E46:  CLRF   xA8
06E48:  CLRF   xA7
06E4A:  MOVLW  0A
06E4C:  MOVWF  xA9
06E4E:  MOVLB  0
06E50:  CALL   57D4
06E54:  MOVFF  01,67D
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
06E58:  MOVLB  6
06E5A:  CLRF   xB4
06E5C:  MOVFF  66B,6B3
06E60:  CLRF   xB6
06E62:  MOVLW  B5
06E64:  MOVWF  xB5
06E66:  MOVLB  0
06E68:  CALL   082A
06E6C:  MOVFF  02,684
06E70:  MOVFF  01,683
06E74:  MOVLW  06
06E76:  MOVLB  6
06E78:  ADDWF  x83,F
06E7A:  MOVLW  00
06E7C:  ADDWFC x84,F
06E7E:  MOVLW  4B
06E80:  ADDWF  x83,W
06E82:  MOVWF  01
06E84:  MOVLW  00
06E86:  ADDWFC x84,W
06E88:  MOVWF  03
06E8A:  MOVF   01,W
06E8C:  ADDLW  D1
06E8E:  MOVWF  01
06E90:  MOVLW  01
06E92:  ADDWFC 03,F
06E94:  MOVFF  01,683
06E98:  MOVFF  03,684
06E9C:  MOVFF  03,6B4
06EA0:  MOVFF  01,6B3
06EA4:  MOVLB  0
06EA6:  CALL   556C
06EAA:  MOVFF  02,03
06EAE:  MOVF   01,W
06EB0:  SUBLW  01
06EB2:  BNZ   6EB8
06EB4:  MOVF   03,F
06EB6:  BZ    6EC0
06EB8:  MOVLW  02
06EBA:  MOVWF  01
06EBC:  BRA    707A
06EBE:  BRA    6F00
....................    else arg2 = SERcmd[rec].p[3][0];
06EC0:  MOVLB  6
06EC2:  CLRF   xB4
06EC4:  MOVFF  66B,6B3
06EC8:  CLRF   xB6
06ECA:  MOVLW  B5
06ECC:  MOVWF  xB5
06ECE:  MOVLB  0
06ED0:  CALL   082A
06ED4:  MOVFF  02,684
06ED8:  MOVFF  01,683
06EDC:  MOVLW  06
06EDE:  MOVLB  6
06EE0:  ADDWF  x83,F
06EE2:  MOVLW  00
06EE4:  ADDWFC x84,F
06EE6:  MOVLW  4B
06EE8:  ADDWF  x83,F
06EEA:  MOVLW  00
06EEC:  ADDWFC x84,F
06EEE:  MOVLW  D1
06EF0:  ADDWF  x83,W
06EF2:  MOVWF  FE9
06EF4:  MOVLW  01
06EF6:  ADDWFC x84,W
06EF8:  MOVWF  FEA
06EFA:  MOVFF  FEF,67E
06EFE:  MOVLB  0
....................    
....................    if (!arg_is_float(SERcmd[rec].p[4])) return INV_PARAM;
06F00:  MOVLB  6
06F02:  CLRF   xB4
06F04:  MOVFF  66B,6B3
06F08:  CLRF   xB6
06F0A:  MOVLW  B5
06F0C:  MOVWF  xB5
06F0E:  MOVLB  0
06F10:  CALL   082A
06F14:  MOVFF  02,684
06F18:  MOVFF  01,683
06F1C:  MOVLW  06
06F1E:  MOVLB  6
06F20:  ADDWF  x83,F
06F22:  MOVLW  00
06F24:  ADDWFC x84,F
06F26:  MOVLW  64
06F28:  ADDWF  x83,W
06F2A:  MOVWF  01
06F2C:  MOVLW  00
06F2E:  ADDWFC x84,W
06F30:  MOVWF  03
06F32:  MOVF   01,W
06F34:  ADDLW  D1
06F36:  MOVWF  01
06F38:  MOVLW  01
06F3A:  ADDWFC 03,F
06F3C:  MOVFF  01,683
06F40:  MOVFF  03,684
06F44:  MOVFF  03,687
06F48:  MOVFF  01,686
06F4C:  MOVLB  0
06F4E:  RCALL  6A80
06F50:  MOVF   01,F
06F52:  BNZ   6F5C
06F54:  MOVLW  02
06F56:  MOVWF  01
06F58:  BRA    707A
06F5A:  BRA    6FC0
....................    else arg3 = strtod(SERcmd[rec].p[4], '\0');
06F5C:  MOVLB  6
06F5E:  CLRF   xB4
06F60:  MOVFF  66B,6B3
06F64:  CLRF   xB6
06F66:  MOVLW  B5
06F68:  MOVWF  xB5
06F6A:  MOVLB  0
06F6C:  CALL   082A
06F70:  MOVFF  02,684
06F74:  MOVFF  01,683
06F78:  MOVLW  06
06F7A:  MOVLB  6
06F7C:  ADDWF  x83,F
06F7E:  MOVLW  00
06F80:  ADDWFC x84,F
06F82:  MOVLW  64
06F84:  ADDWF  x83,W
06F86:  MOVWF  01
06F88:  MOVLW  00
06F8A:  ADDWFC x84,W
06F8C:  MOVWF  03
06F8E:  MOVF   01,W
06F90:  ADDLW  D1
06F92:  MOVWF  01
06F94:  MOVLW  01
06F96:  ADDWFC 03,F
06F98:  MOVFF  01,683
06F9C:  MOVFF  03,684
06FA0:  MOVFF  03,687
06FA4:  MOVFF  01,686
06FA8:  CLRF   x89
06FAA:  CLRF   x88
06FAC:  MOVLB  0
06FAE:  RCALL  6B42
06FB0:  MOVFF  03,682
06FB4:  MOVFF  02,681
06FB8:  MOVFF  01,680
06FBC:  MOVFF  00,67F
....................    
....................    /*** SET P, I, or D VALUE **********/
....................    if      ('P' == arg2) PID[arg1-1].kP = arg3;
06FC0:  MOVLB  6
06FC2:  MOVF   x7E,W
06FC4:  SUBLW  50
06FC6:  BNZ   6FF2
06FC8:  MOVLW  01
06FCA:  SUBWF  x7D,W
06FCC:  MULLW  20
06FCE:  MOVF   FF3,W
06FD0:  CLRF   x84
06FD2:  MOVWF  x83
06FD4:  MOVLW  20
06FD6:  ADDWF  x83,W
06FD8:  MOVWF  FE9
06FDA:  MOVLW  00
06FDC:  ADDWFC x84,W
06FDE:  MOVWF  FEA
06FE0:  MOVFF  67F,FEF
06FE4:  MOVFF  680,FEC
06FE8:  MOVFF  681,FEC
06FEC:  MOVFF  682,FEC
06FF0:  BRA    7074
....................    else if ('I' == arg2) PID[arg1-1].kI = arg3;
06FF2:  MOVF   x7E,W
06FF4:  SUBLW  49
06FF6:  BNZ   702E
06FF8:  MOVLW  01
06FFA:  SUBWF  x7D,W
06FFC:  MULLW  20
06FFE:  MOVF   FF3,W
07000:  CLRF   x84
07002:  MOVWF  x83
07004:  MOVLW  04
07006:  ADDWF  x83,W
07008:  MOVWF  01
0700A:  MOVLW  00
0700C:  ADDWFC x84,W
0700E:  MOVWF  03
07010:  MOVF   01,W
07012:  ADDLW  20
07014:  MOVWF  FE9
07016:  MOVLW  00
07018:  ADDWFC 03,W
0701A:  MOVWF  FEA
0701C:  MOVFF  67F,FEF
07020:  MOVFF  680,FEC
07024:  MOVFF  681,FEC
07028:  MOVFF  682,FEC
0702C:  BRA    7074
....................    else if ('D' == arg2) PID[arg1-1].kD = arg3;
0702E:  MOVF   x7E,W
07030:  SUBLW  44
07032:  BNZ   706A
07034:  MOVLW  01
07036:  SUBWF  x7D,W
07038:  MULLW  20
0703A:  MOVF   FF3,W
0703C:  CLRF   x84
0703E:  MOVWF  x83
07040:  MOVLW  08
07042:  ADDWF  x83,W
07044:  MOVWF  01
07046:  MOVLW  00
07048:  ADDWFC x84,W
0704A:  MOVWF  03
0704C:  MOVF   01,W
0704E:  ADDLW  20
07050:  MOVWF  FE9
07052:  MOVLW  00
07054:  ADDWFC 03,W
07056:  MOVWF  FEA
07058:  MOVFF  67F,FEF
0705C:  MOVFF  680,FEC
07060:  MOVFF  681,FEC
07064:  MOVFF  682,FEC
07068:  BRA    7074
....................    else return INV_PARAM;
0706A:  MOVLW  02
0706C:  MOVWF  01
0706E:  MOVLB  0
07070:  BRA    707A
07072:  MOVLB  6
....................    
....................    return SUCCESS;
07074:  MOVLW  00
07076:  MOVWF  01
07078:  MOVLB  0
0707A:  RETURN 0
.................... }
.................... 
.................... //!int8 enablePID(unsigned int8 rec){
.................... //!   /*** ARG CHECKS ********************/
.................... //!   int8  arg1;
.................... //!   
.................... //!   if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
.................... //!   else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
.................... //!   
.................... //!   PID[arg1-1].enable = TRUE;
.................... //!   
.................... //!   return SUCCESS;
.................... //!}
.................... //!
.................... //!int8 disablePID(unsigned int8 rec){
.................... //!   /*** ARG CHECKS ********************/
.................... //!   int8  arg1;
.................... //!   
.................... //!   if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
.................... //!   else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
.................... //!   
.................... //!   PID[arg1-1].enable = FALSE;
.................... //!   
.................... //!   return SUCCESS;
.................... //!}
.................... 
.................... int8 getSetPoint(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0707C:  MOVLB  6
0707E:  CLRF   xB4
07080:  MOVFF  66B,6B3
07084:  CLRF   xB6
07086:  MOVLW  B5
07088:  MOVWF  xB5
0708A:  MOVLB  0
0708C:  CALL   082A
07090:  MOVFF  02,67F
07094:  MOVFF  01,67E
07098:  MOVLW  06
0709A:  MOVLB  6
0709C:  ADDWF  x7E,F
0709E:  MOVLW  00
070A0:  ADDWFC x7F,F
070A2:  MOVLW  32
070A4:  ADDWF  x7E,W
070A6:  MOVWF  01
070A8:  MOVLW  00
070AA:  ADDWFC x7F,W
070AC:  MOVWF  03
070AE:  MOVF   01,W
070B0:  ADDLW  D1
070B2:  MOVWF  01
070B4:  MOVLW  01
070B6:  ADDWFC 03,F
070B8:  MOVFF  01,67E
070BC:  MOVFF  03,67F
070C0:  MOVFF  03,6A6
070C4:  MOVFF  01,6A5
070C8:  MOVLB  0
070CA:  CALL   56E4
070CE:  MOVF   01,F
070D0:  BNZ   70DA
070D2:  MOVLW  02
070D4:  MOVWF  01
070D6:  BRA    71DC
070D8:  BRA    7138
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
070DA:  MOVLB  6
070DC:  CLRF   xB4
070DE:  MOVFF  66B,6B3
070E2:  CLRF   xB6
070E4:  MOVLW  B5
070E6:  MOVWF  xB5
070E8:  MOVLB  0
070EA:  CALL   082A
070EE:  MOVFF  02,67F
070F2:  MOVFF  01,67E
070F6:  MOVLW  06
070F8:  MOVLB  6
070FA:  ADDWF  x7E,F
070FC:  MOVLW  00
070FE:  ADDWFC x7F,F
07100:  MOVLW  32
07102:  ADDWF  x7E,W
07104:  MOVWF  01
07106:  MOVLW  00
07108:  ADDWFC x7F,W
0710A:  MOVWF  03
0710C:  MOVF   01,W
0710E:  ADDLW  D1
07110:  MOVWF  01
07112:  MOVLW  01
07114:  ADDWFC 03,F
07116:  MOVFF  01,67E
0711A:  MOVFF  03,67F
0711E:  MOVFF  03,6A6
07122:  MOVFF  01,6A5
07126:  CLRF   xA8
07128:  CLRF   xA7
0712A:  MOVLW  0A
0712C:  MOVWF  xA9
0712E:  MOVLB  0
07130:  CALL   57D4
07134:  MOVFF  01,67D
....................    
....................    /*** GET SETPOINT ******************/ 
....................    sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].SP);
07138:  MOVLW  04
0713A:  MOVLB  6
0713C:  MOVWF  xB4
0713E:  MOVLW  A7
07140:  MOVWF  xB3
07142:  MOVLB  0
07144:  CALL   556C
07148:  MOVF   01,W
0714A:  ADDLW  A7
0714C:  MOVLB  6
0714E:  MOVWF  x7E
07150:  MOVLW  04
07152:  ADDWFC 02,W
07154:  MOVWF  x7F
07156:  MOVLW  01
07158:  SUBWF  x7D,W
0715A:  MULLW  20
0715C:  MOVF   FF3,W
0715E:  CLRF   x81
07160:  MOVWF  x80
07162:  MOVLW  0C
07164:  ADDWF  x80,W
07166:  MOVWF  01
07168:  MOVLW  00
0716A:  ADDWFC x81,W
0716C:  MOVWF  03
0716E:  MOVF   01,W
07170:  ADDLW  20
07172:  MOVWF  FE9
07174:  MOVLW  00
07176:  ADDWFC 03,W
07178:  MOVWF  FEA
0717A:  MOVFF  FEF,680
0717E:  MOVFF  FEC,681
07182:  MOVFF  FEC,682
07186:  MOVFF  FEC,683
0718A:  MOVFF  67F,54B
0718E:  MOVFF  67E,54A
07192:  MOVFF  67D,6A6
07196:  MOVLW  18
07198:  MOVWF  xA7
0719A:  MOVLB  0
0719C:  CALL   5B28
071A0:  MOVLW  2C
071A2:  MOVLB  6
071A4:  MOVWF  xC2
071A6:  MOVLB  0
071A8:  CALL   561C
071AC:  MOVLW  89
071AE:  MOVWF  FE9
071B0:  MOVFF  683,6B8
071B4:  MOVFF  682,6B7
071B8:  MOVFF  681,6B6
071BC:  MOVFF  680,6B5
071C0:  MOVLW  02
071C2:  MOVLB  6
071C4:  MOVWF  xB9
071C6:  MOVLB  0
071C8:  CALL   641A
071CC:  MOVLW  2C
071CE:  MOVLB  6
071D0:  MOVWF  xC2
071D2:  MOVLB  0
071D4:  CALL   561C
....................    return SUCCESS;
071D8:  MOVLW  00
071DA:  MOVWF  01
071DC:  RETURN 0
.................... }
.................... 
.................... int8 setSetPoint(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/   
....................    int8  arg1;
....................    float arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
071DE:  MOVLB  6
071E0:  CLRF   xB4
071E2:  MOVFF  66B,6B3
071E6:  CLRF   xB6
071E8:  MOVLW  B5
071EA:  MOVWF  xB5
071EC:  MOVLB  0
071EE:  CALL   082A
071F2:  MOVFF  02,683
071F6:  MOVFF  01,682
071FA:  MOVLW  06
071FC:  MOVLB  6
071FE:  ADDWF  x82,F
07200:  MOVLW  00
07202:  ADDWFC x83,F
07204:  MOVLW  32
07206:  ADDWF  x82,W
07208:  MOVWF  01
0720A:  MOVLW  00
0720C:  ADDWFC x83,W
0720E:  MOVWF  03
07210:  MOVF   01,W
07212:  ADDLW  D1
07214:  MOVWF  01
07216:  MOVLW  01
07218:  ADDWFC 03,F
0721A:  MOVFF  01,682
0721E:  MOVFF  03,683
07222:  MOVFF  03,6A6
07226:  MOVFF  01,6A5
0722A:  MOVLB  0
0722C:  CALL   56E4
07230:  MOVF   01,F
07232:  BNZ   723C
07234:  MOVLW  02
07236:  MOVWF  01
07238:  BRA    739A
0723A:  BRA    729A
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
0723C:  MOVLB  6
0723E:  CLRF   xB4
07240:  MOVFF  66B,6B3
07244:  CLRF   xB6
07246:  MOVLW  B5
07248:  MOVWF  xB5
0724A:  MOVLB  0
0724C:  CALL   082A
07250:  MOVFF  02,683
07254:  MOVFF  01,682
07258:  MOVLW  06
0725A:  MOVLB  6
0725C:  ADDWF  x82,F
0725E:  MOVLW  00
07260:  ADDWFC x83,F
07262:  MOVLW  32
07264:  ADDWF  x82,W
07266:  MOVWF  01
07268:  MOVLW  00
0726A:  ADDWFC x83,W
0726C:  MOVWF  03
0726E:  MOVF   01,W
07270:  ADDLW  D1
07272:  MOVWF  01
07274:  MOVLW  01
07276:  ADDWFC 03,F
07278:  MOVFF  01,682
0727C:  MOVFF  03,683
07280:  MOVFF  03,6A6
07284:  MOVFF  01,6A5
07288:  CLRF   xA8
0728A:  CLRF   xA7
0728C:  MOVLW  0A
0728E:  MOVWF  xA9
07290:  MOVLB  0
07292:  CALL   57D4
07296:  MOVFF  01,67D
....................    
....................    if (!arg_is_float(SERcmd[rec].p[3])) return INV_PARAM;
0729A:  MOVLB  6
0729C:  CLRF   xB4
0729E:  MOVFF  66B,6B3
072A2:  CLRF   xB6
072A4:  MOVLW  B5
072A6:  MOVWF  xB5
072A8:  MOVLB  0
072AA:  CALL   082A
072AE:  MOVFF  02,683
072B2:  MOVFF  01,682
072B6:  MOVLW  06
072B8:  MOVLB  6
072BA:  ADDWF  x82,F
072BC:  MOVLW  00
072BE:  ADDWFC x83,F
072C0:  MOVLW  4B
072C2:  ADDWF  x82,W
072C4:  MOVWF  01
072C6:  MOVLW  00
072C8:  ADDWFC x83,W
072CA:  MOVWF  03
072CC:  MOVF   01,W
072CE:  ADDLW  D1
072D0:  MOVWF  01
072D2:  MOVLW  01
072D4:  ADDWFC 03,F
072D6:  MOVFF  01,682
072DA:  MOVFF  03,683
072DE:  MOVFF  03,687
072E2:  MOVFF  01,686
072E6:  MOVLB  0
072E8:  CALL   6A80
072EC:  MOVF   01,F
072EE:  BNZ   72F8
072F0:  MOVLW  02
072F2:  MOVWF  01
072F4:  BRA    739A
072F6:  BRA    735E
....................    else arg2 = strtod(SERcmd[rec].p[3], '\0');
072F8:  MOVLB  6
072FA:  CLRF   xB4
072FC:  MOVFF  66B,6B3
07300:  CLRF   xB6
07302:  MOVLW  B5
07304:  MOVWF  xB5
07306:  MOVLB  0
07308:  CALL   082A
0730C:  MOVFF  02,683
07310:  MOVFF  01,682
07314:  MOVLW  06
07316:  MOVLB  6
07318:  ADDWF  x82,F
0731A:  MOVLW  00
0731C:  ADDWFC x83,F
0731E:  MOVLW  4B
07320:  ADDWF  x82,W
07322:  MOVWF  01
07324:  MOVLW  00
07326:  ADDWFC x83,W
07328:  MOVWF  03
0732A:  MOVF   01,W
0732C:  ADDLW  D1
0732E:  MOVWF  01
07330:  MOVLW  01
07332:  ADDWFC 03,F
07334:  MOVFF  01,682
07338:  MOVFF  03,683
0733C:  MOVFF  03,687
07340:  MOVFF  01,686
07344:  CLRF   x89
07346:  CLRF   x88
07348:  MOVLB  0
0734A:  CALL   6B42
0734E:  MOVFF  03,681
07352:  MOVFF  02,680
07356:  MOVFF  01,67F
0735A:  MOVFF  00,67E
....................    
....................    /*** SET SETPOINT ******************/ 
....................    PID[arg1-1].SP = arg2;
0735E:  MOVLW  01
07360:  MOVLB  6
07362:  SUBWF  x7D,W
07364:  MULLW  20
07366:  MOVF   FF3,W
07368:  CLRF   x83
0736A:  MOVWF  x82
0736C:  MOVLW  0C
0736E:  ADDWF  x82,W
07370:  MOVWF  01
07372:  MOVLW  00
07374:  ADDWFC x83,W
07376:  MOVWF  03
07378:  MOVF   01,W
0737A:  ADDLW  20
0737C:  MOVWF  FE9
0737E:  MOVLW  00
07380:  ADDWFC 03,W
07382:  MOVWF  FEA
07384:  MOVFF  67E,FEF
07388:  MOVFF  67F,FEC
0738C:  MOVFF  680,FEC
07390:  MOVFF  681,FEC
....................    
....................    return SUCCESS;
07394:  MOVLW  00
07396:  MOVWF  01
07398:  MOVLB  0
0739A:  RETURN 0
.................... }
.................... 
.................... int8 getAllSensorCalParams(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0739C:  MOVLB  6
0739E:  CLRF   xB4
073A0:  MOVFF  66B,6B3
073A4:  CLRF   xB6
073A6:  MOVLW  B5
073A8:  MOVWF  xB5
073AA:  MOVLB  0
073AC:  CALL   082A
073B0:  MOVFF  02,67F
073B4:  MOVFF  01,67E
073B8:  MOVLW  06
073BA:  MOVLB  6
073BC:  ADDWF  x7E,F
073BE:  MOVLW  00
073C0:  ADDWFC x7F,F
073C2:  MOVLW  32
073C4:  ADDWF  x7E,W
073C6:  MOVWF  01
073C8:  MOVLW  00
073CA:  ADDWFC x7F,W
073CC:  MOVWF  03
073CE:  MOVF   01,W
073D0:  ADDLW  D1
073D2:  MOVWF  01
073D4:  MOVLW  01
073D6:  ADDWFC 03,F
073D8:  MOVFF  01,67E
073DC:  MOVFF  03,67F
073E0:  MOVFF  03,6A6
073E4:  MOVFF  01,6A5
073E8:  MOVLB  0
073EA:  CALL   56E4
073EE:  MOVF   01,F
073F0:  BNZ   73FA
073F2:  MOVLW  02
073F4:  MOVWF  01
073F6:  BRA    7750
073F8:  BRA    7458
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
073FA:  MOVLB  6
073FC:  CLRF   xB4
073FE:  MOVFF  66B,6B3
07402:  CLRF   xB6
07404:  MOVLW  B5
07406:  MOVWF  xB5
07408:  MOVLB  0
0740A:  CALL   082A
0740E:  MOVFF  02,67F
07412:  MOVFF  01,67E
07416:  MOVLW  06
07418:  MOVLB  6
0741A:  ADDWF  x7E,F
0741C:  MOVLW  00
0741E:  ADDWFC x7F,F
07420:  MOVLW  32
07422:  ADDWF  x7E,W
07424:  MOVWF  01
07426:  MOVLW  00
07428:  ADDWFC x7F,W
0742A:  MOVWF  03
0742C:  MOVF   01,W
0742E:  ADDLW  D1
07430:  MOVWF  01
07432:  MOVLW  01
07434:  ADDWFC 03,F
07436:  MOVFF  01,67E
0743A:  MOVFF  03,67F
0743E:  MOVFF  03,6A6
07442:  MOVFF  01,6A5
07446:  CLRF   xA8
07448:  CLRF   xA7
0744A:  MOVLW  0A
0744C:  MOVWF  xA9
0744E:  MOVLB  0
07450:  CALL   57D4
07454:  MOVFF  01,67D
....................    
....................    /*** GET ALL SENSOR CAL PARAMS *****/
....................    sprintf(retData+strlen(retData), "%d,", arg1);
07458:  MOVLW  04
0745A:  MOVLB  6
0745C:  MOVWF  xB4
0745E:  MOVLW  A7
07460:  MOVWF  xB3
07462:  MOVLB  0
07464:  CALL   556C
07468:  MOVFF  02,03
0746C:  MOVF   01,W
0746E:  ADDLW  A7
07470:  MOVLB  6
07472:  MOVWF  x7E
07474:  MOVLW  04
07476:  ADDWFC 02,W
07478:  MOVWF  x7F
0747A:  MOVFF  FE8,54B
0747E:  MOVFF  67E,54A
07482:  MOVFF  67D,6A6
07486:  MOVLW  18
07488:  MOVWF  xA7
0748A:  MOVLB  0
0748C:  CALL   5B28
07490:  MOVLW  2C
07492:  MOVLB  6
07494:  MOVWF  xC2
07496:  MOVLB  0
07498:  CALL   561C
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c0);
0749C:  MOVLW  04
0749E:  MOVLB  6
074A0:  MOVWF  xB4
074A2:  MOVLW  A7
074A4:  MOVWF  xB3
074A6:  MOVLB  0
074A8:  CALL   556C
074AC:  MOVFF  02,03
074B0:  MOVF   01,W
074B2:  ADDLW  A7
074B4:  MOVLB  6
074B6:  MOVWF  x7E
074B8:  MOVLW  04
074BA:  ADDWFC 02,W
074BC:  MOVWF  x7F
074BE:  MOVLW  01
074C0:  SUBWF  x7D,W
074C2:  MULLW  18
074C4:  MOVF   FF3,W
074C6:  CLRF   x81
074C8:  MOVWF  x80
074CA:  MOVLW  82
074CC:  ADDWF  x80,W
074CE:  MOVWF  FE9
074D0:  MOVLW  00
074D2:  ADDWFC x81,W
074D4:  MOVWF  FEA
074D6:  MOVFF  FEF,6B5
074DA:  MOVFF  FEC,6B6
074DE:  MOVFF  FEC,6B7
074E2:  MOVFF  FEC,6B8
074E6:  MOVFF  67F,54B
074EA:  MOVFF  67E,54A
074EE:  MOVLW  89
074F0:  MOVWF  FE9
074F2:  MOVLW  02
074F4:  MOVWF  xB9
074F6:  MOVLB  0
074F8:  CALL   641A
074FC:  MOVLW  2C
074FE:  MOVLB  6
07500:  MOVWF  xC2
07502:  MOVLB  0
07504:  CALL   561C
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c1);
07508:  MOVLW  04
0750A:  MOVLB  6
0750C:  MOVWF  xB4
0750E:  MOVLW  A7
07510:  MOVWF  xB3
07512:  MOVLB  0
07514:  CALL   556C
07518:  MOVF   01,W
0751A:  ADDLW  A7
0751C:  MOVLB  6
0751E:  MOVWF  x7E
07520:  MOVLW  04
07522:  ADDWFC 02,W
07524:  MOVWF  x7F
07526:  MOVLW  01
07528:  SUBWF  x7D,W
0752A:  MULLW  18
0752C:  MOVF   FF3,W
0752E:  CLRF   x81
07530:  MOVWF  x80
07532:  MOVLW  04
07534:  ADDWF  x80,W
07536:  MOVWF  01
07538:  MOVLW  00
0753A:  ADDWFC x81,W
0753C:  MOVWF  03
0753E:  MOVF   01,W
07540:  ADDLW  82
07542:  MOVWF  FE9
07544:  MOVLW  00
07546:  ADDWFC 03,W
07548:  MOVWF  FEA
0754A:  MOVFF  FEF,6B5
0754E:  MOVFF  FEC,6B6
07552:  MOVFF  FEC,6B7
07556:  MOVFF  FEC,6B8
0755A:  MOVFF  67F,54B
0755E:  MOVFF  67E,54A
07562:  MOVLW  89
07564:  MOVWF  FE9
07566:  MOVLW  02
07568:  MOVWF  xB9
0756A:  MOVLB  0
0756C:  CALL   641A
07570:  MOVLW  2C
07572:  MOVLB  6
07574:  MOVWF  xC2
07576:  MOVLB  0
07578:  CALL   561C
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c2);
0757C:  MOVLW  04
0757E:  MOVLB  6
07580:  MOVWF  xB4
07582:  MOVLW  A7
07584:  MOVWF  xB3
07586:  MOVLB  0
07588:  CALL   556C
0758C:  MOVF   01,W
0758E:  ADDLW  A7
07590:  MOVLB  6
07592:  MOVWF  x7E
07594:  MOVLW  04
07596:  ADDWFC 02,W
07598:  MOVWF  x7F
0759A:  MOVLW  01
0759C:  SUBWF  x7D,W
0759E:  MULLW  18
075A0:  MOVF   FF3,W
075A2:  CLRF   x81
075A4:  MOVWF  x80
075A6:  MOVLW  08
075A8:  ADDWF  x80,W
075AA:  MOVWF  01
075AC:  MOVLW  00
075AE:  ADDWFC x81,W
075B0:  MOVWF  03
075B2:  MOVF   01,W
075B4:  ADDLW  82
075B6:  MOVWF  FE9
075B8:  MOVLW  00
075BA:  ADDWFC 03,W
075BC:  MOVWF  FEA
075BE:  MOVFF  FEF,6B5
075C2:  MOVFF  FEC,6B6
075C6:  MOVFF  FEC,6B7
075CA:  MOVFF  FEC,6B8
075CE:  MOVFF  67F,54B
075D2:  MOVFF  67E,54A
075D6:  MOVLW  89
075D8:  MOVWF  FE9
075DA:  MOVLW  02
075DC:  MOVWF  xB9
075DE:  MOVLB  0
075E0:  CALL   641A
075E4:  MOVLW  2C
075E6:  MOVLB  6
075E8:  MOVWF  xC2
075EA:  MOVLB  0
075EC:  CALL   561C
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c3);
075F0:  MOVLW  04
075F2:  MOVLB  6
075F4:  MOVWF  xB4
075F6:  MOVLW  A7
075F8:  MOVWF  xB3
075FA:  MOVLB  0
075FC:  CALL   556C
07600:  MOVF   01,W
07602:  ADDLW  A7
07604:  MOVLB  6
07606:  MOVWF  x7E
07608:  MOVLW  04
0760A:  ADDWFC 02,W
0760C:  MOVWF  x7F
0760E:  MOVLW  01
07610:  SUBWF  x7D,W
07612:  MULLW  18
07614:  MOVF   FF3,W
07616:  CLRF   x81
07618:  MOVWF  x80
0761A:  MOVLW  0C
0761C:  ADDWF  x80,W
0761E:  MOVWF  01
07620:  MOVLW  00
07622:  ADDWFC x81,W
07624:  MOVWF  03
07626:  MOVF   01,W
07628:  ADDLW  82
0762A:  MOVWF  FE9
0762C:  MOVLW  00
0762E:  ADDWFC 03,W
07630:  MOVWF  FEA
07632:  MOVFF  FEF,6B5
07636:  MOVFF  FEC,6B6
0763A:  MOVFF  FEC,6B7
0763E:  MOVFF  FEC,6B8
07642:  MOVFF  67F,54B
07646:  MOVFF  67E,54A
0764A:  MOVLW  89
0764C:  MOVWF  FE9
0764E:  MOVLW  02
07650:  MOVWF  xB9
07652:  MOVLB  0
07654:  CALL   641A
07658:  MOVLW  2C
0765A:  MOVLB  6
0765C:  MOVWF  xC2
0765E:  MOVLB  0
07660:  CALL   561C
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c4);
07664:  MOVLW  04
07666:  MOVLB  6
07668:  MOVWF  xB4
0766A:  MOVLW  A7
0766C:  MOVWF  xB3
0766E:  MOVLB  0
07670:  CALL   556C
07674:  MOVF   01,W
07676:  ADDLW  A7
07678:  MOVLB  6
0767A:  MOVWF  x7E
0767C:  MOVLW  04
0767E:  ADDWFC 02,W
07680:  MOVWF  x7F
07682:  MOVLW  01
07684:  SUBWF  x7D,W
07686:  MULLW  18
07688:  MOVF   FF3,W
0768A:  CLRF   x81
0768C:  MOVWF  x80
0768E:  MOVLW  10
07690:  ADDWF  x80,W
07692:  MOVWF  01
07694:  MOVLW  00
07696:  ADDWFC x81,W
07698:  MOVWF  03
0769A:  MOVF   01,W
0769C:  ADDLW  82
0769E:  MOVWF  FE9
076A0:  MOVLW  00
076A2:  ADDWFC 03,W
076A4:  MOVWF  FEA
076A6:  MOVFF  FEF,6B5
076AA:  MOVFF  FEC,6B6
076AE:  MOVFF  FEC,6B7
076B2:  MOVFF  FEC,6B8
076B6:  MOVFF  67F,54B
076BA:  MOVFF  67E,54A
076BE:  MOVLW  89
076C0:  MOVWF  FE9
076C2:  MOVLW  02
076C4:  MOVWF  xB9
076C6:  MOVLB  0
076C8:  CALL   641A
076CC:  MOVLW  2C
076CE:  MOVLB  6
076D0:  MOVWF  xC2
076D2:  MOVLB  0
076D4:  CALL   561C
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c5);
076D8:  MOVLW  04
076DA:  MOVLB  6
076DC:  MOVWF  xB4
076DE:  MOVLW  A7
076E0:  MOVWF  xB3
076E2:  MOVLB  0
076E4:  CALL   556C
076E8:  MOVF   01,W
076EA:  ADDLW  A7
076EC:  MOVLB  6
076EE:  MOVWF  x7E
076F0:  MOVLW  04
076F2:  ADDWFC 02,W
076F4:  MOVWF  x7F
076F6:  MOVLW  01
076F8:  SUBWF  x7D,W
076FA:  MULLW  18
076FC:  MOVF   FF3,W
076FE:  CLRF   x81
07700:  MOVWF  x80
07702:  MOVLW  14
07704:  ADDWF  x80,W
07706:  MOVWF  01
07708:  MOVLW  00
0770A:  ADDWFC x81,W
0770C:  MOVWF  03
0770E:  MOVF   01,W
07710:  ADDLW  82
07712:  MOVWF  FE9
07714:  MOVLW  00
07716:  ADDWFC 03,W
07718:  MOVWF  FEA
0771A:  MOVFF  FEF,6B5
0771E:  MOVFF  FEC,6B6
07722:  MOVFF  FEC,6B7
07726:  MOVFF  FEC,6B8
0772A:  MOVFF  67F,54B
0772E:  MOVFF  67E,54A
07732:  MOVLW  89
07734:  MOVWF  FE9
07736:  MOVLW  02
07738:  MOVWF  xB9
0773A:  MOVLB  0
0773C:  CALL   641A
07740:  MOVLW  2C
07742:  MOVLB  6
07744:  MOVWF  xC2
07746:  MOVLB  0
07748:  CALL   561C
....................    
....................    return SUCCESS;
0774C:  MOVLW  00
0774E:  MOVWF  01
07750:  RETURN 0
.................... }
.................... 
.................... int8 getSensorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
07752:  MOVLB  6
07754:  CLRF   xB4
07756:  MOVFF  66B,6B3
0775A:  CLRF   xB6
0775C:  MOVLW  B5
0775E:  MOVWF  xB5
07760:  MOVLB  0
07762:  CALL   082A
07766:  MOVFF  02,680
0776A:  MOVFF  01,67F
0776E:  MOVLW  06
07770:  MOVLB  6
07772:  ADDWF  x7F,F
07774:  MOVLW  00
07776:  ADDWFC x80,F
07778:  MOVLW  32
0777A:  ADDWF  x7F,W
0777C:  MOVWF  01
0777E:  MOVLW  00
07780:  ADDWFC x80,W
07782:  MOVWF  03
07784:  MOVF   01,W
07786:  ADDLW  D1
07788:  MOVWF  01
0778A:  MOVLW  01
0778C:  ADDWFC 03,F
0778E:  MOVFF  01,67F
07792:  MOVFF  03,680
07796:  MOVFF  03,6A6
0779A:  MOVFF  01,6A5
0779E:  MOVLB  0
077A0:  CALL   56E4
077A4:  MOVF   01,F
077A6:  BNZ   77B0
077A8:  MOVLW  02
077AA:  MOVWF  01
077AC:  BRA    7CAC
077AE:  BRA    780E
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
077B0:  MOVLB  6
077B2:  CLRF   xB4
077B4:  MOVFF  66B,6B3
077B8:  CLRF   xB6
077BA:  MOVLW  B5
077BC:  MOVWF  xB5
077BE:  MOVLB  0
077C0:  CALL   082A
077C4:  MOVFF  02,680
077C8:  MOVFF  01,67F
077CC:  MOVLW  06
077CE:  MOVLB  6
077D0:  ADDWF  x7F,F
077D2:  MOVLW  00
077D4:  ADDWFC x80,F
077D6:  MOVLW  32
077D8:  ADDWF  x7F,W
077DA:  MOVWF  01
077DC:  MOVLW  00
077DE:  ADDWFC x80,W
077E0:  MOVWF  03
077E2:  MOVF   01,W
077E4:  ADDLW  D1
077E6:  MOVWF  01
077E8:  MOVLW  01
077EA:  ADDWFC 03,F
077EC:  MOVFF  01,67F
077F0:  MOVFF  03,680
077F4:  MOVFF  03,6A6
077F8:  MOVFF  01,6A5
077FC:  CLRF   xA8
077FE:  CLRF   xA7
07800:  MOVLW  0A
07802:  MOVWF  xA9
07804:  MOVLB  0
07806:  CALL   57D4
0780A:  MOVFF  01,67D
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
0780E:  MOVLB  6
07810:  CLRF   xB4
07812:  MOVFF  66B,6B3
07816:  CLRF   xB6
07818:  MOVLW  B5
0781A:  MOVWF  xB5
0781C:  MOVLB  0
0781E:  CALL   082A
07822:  MOVFF  02,680
07826:  MOVFF  01,67F
0782A:  MOVLW  06
0782C:  MOVLB  6
0782E:  ADDWF  x7F,F
07830:  MOVLW  00
07832:  ADDWFC x80,F
07834:  MOVLW  4B
07836:  ADDWF  x7F,W
07838:  MOVWF  01
0783A:  MOVLW  00
0783C:  ADDWFC x80,W
0783E:  MOVWF  03
07840:  MOVF   01,W
07842:  ADDLW  D1
07844:  MOVWF  01
07846:  MOVLW  01
07848:  ADDWFC 03,F
0784A:  MOVFF  01,67F
0784E:  MOVFF  03,680
07852:  MOVFF  03,6B4
07856:  MOVFF  01,6B3
0785A:  MOVLB  0
0785C:  CALL   556C
07860:  MOVFF  02,03
07864:  MOVF   01,W
07866:  SUBLW  01
07868:  BNZ   786E
0786A:  MOVF   03,F
0786C:  BZ    7876
0786E:  MOVLW  02
07870:  MOVWF  01
07872:  BRA    7CAC
07874:  BRA    78B6
....................    else arg2 = SERcmd[rec].p[3][0];
07876:  MOVLB  6
07878:  CLRF   xB4
0787A:  MOVFF  66B,6B3
0787E:  CLRF   xB6
07880:  MOVLW  B5
07882:  MOVWF  xB5
07884:  MOVLB  0
07886:  CALL   082A
0788A:  MOVFF  02,680
0788E:  MOVFF  01,67F
07892:  MOVLW  06
07894:  MOVLB  6
07896:  ADDWF  x7F,F
07898:  MOVLW  00
0789A:  ADDWFC x80,F
0789C:  MOVLW  4B
0789E:  ADDWF  x7F,F
078A0:  MOVLW  00
078A2:  ADDWFC x80,F
078A4:  MOVLW  D1
078A6:  ADDWF  x7F,W
078A8:  MOVWF  FE9
078AA:  MOVLW  01
078AC:  ADDWFC x80,W
078AE:  MOVWF  FEA
078B0:  MOVFF  FEF,67E
078B4:  MOVLB  0
....................    
....................    /*** GET SENSOR CAL PARAM **********/
....................    if      ('0' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c0);
078B6:  MOVLB  6
078B8:  MOVF   x7E,W
078BA:  SUBLW  30
078BC:  BNZ   7958
078BE:  MOVLW  04
078C0:  MOVWF  xB4
078C2:  MOVLW  A7
078C4:  MOVWF  xB3
078C6:  MOVLB  0
078C8:  CALL   556C
078CC:  MOVFF  02,03
078D0:  MOVF   01,W
078D2:  ADDLW  A7
078D4:  MOVLB  6
078D6:  MOVWF  x7F
078D8:  MOVLW  04
078DA:  ADDWFC 02,W
078DC:  MOVWF  x80
078DE:  MOVLW  01
078E0:  SUBWF  x7D,W
078E2:  MULLW  18
078E4:  MOVF   FF3,W
078E6:  CLRF   x82
078E8:  MOVWF  x81
078EA:  MOVLW  82
078EC:  ADDWF  x81,W
078EE:  MOVWF  FE9
078F0:  MOVLW  00
078F2:  ADDWFC x82,W
078F4:  MOVWF  FEA
078F6:  MOVFF  FEF,683
078FA:  MOVFF  FEC,684
078FE:  MOVFF  FEC,685
07902:  MOVFF  FEC,686
07906:  MOVFF  680,54B
0790A:  MOVFF  67F,54A
0790E:  MOVFF  67D,6A6
07912:  MOVLW  18
07914:  MOVWF  xA7
07916:  MOVLB  0
07918:  CALL   5B28
0791C:  MOVLW  2C
0791E:  MOVLB  6
07920:  MOVWF  xC2
07922:  MOVLB  0
07924:  CALL   561C
07928:  MOVLW  89
0792A:  MOVWF  FE9
0792C:  MOVFF  686,6B8
07930:  MOVFF  685,6B7
07934:  MOVFF  684,6B6
07938:  MOVFF  683,6B5
0793C:  MOVLW  02
0793E:  MOVLB  6
07940:  MOVWF  xB9
07942:  MOVLB  0
07944:  CALL   641A
07948:  MOVLW  2C
0794A:  MOVLB  6
0794C:  MOVWF  xC2
0794E:  MOVLB  0
07950:  CALL   561C
07954:  BRA    7CA8
07956:  MOVLB  6
....................    else if ('1' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c1);
07958:  MOVF   x7E,W
0795A:  SUBLW  31
0795C:  BNZ   7A00
0795E:  MOVLW  04
07960:  MOVWF  xB4
07962:  MOVLW  A7
07964:  MOVWF  xB3
07966:  MOVLB  0
07968:  CALL   556C
0796C:  MOVF   01,W
0796E:  ADDLW  A7
07970:  MOVLB  6
07972:  MOVWF  x7F
07974:  MOVLW  04
07976:  ADDWFC 02,W
07978:  MOVWF  x80
0797A:  MOVLW  01
0797C:  SUBWF  x7D,W
0797E:  MULLW  18
07980:  MOVF   FF3,W
07982:  CLRF   x82
07984:  MOVWF  x81
07986:  MOVLW  04
07988:  ADDWF  x81,W
0798A:  MOVWF  01
0798C:  MOVLW  00
0798E:  ADDWFC x82,W
07990:  MOVWF  03
07992:  MOVF   01,W
07994:  ADDLW  82
07996:  MOVWF  FE9
07998:  MOVLW  00
0799A:  ADDWFC 03,W
0799C:  MOVWF  FEA
0799E:  MOVFF  FEF,681
079A2:  MOVFF  FEC,682
079A6:  MOVFF  FEC,683
079AA:  MOVFF  FEC,684
079AE:  MOVFF  680,54B
079B2:  MOVFF  67F,54A
079B6:  MOVFF  67D,6A6
079BA:  MOVLW  18
079BC:  MOVWF  xA7
079BE:  MOVLB  0
079C0:  CALL   5B28
079C4:  MOVLW  2C
079C6:  MOVLB  6
079C8:  MOVWF  xC2
079CA:  MOVLB  0
079CC:  CALL   561C
079D0:  MOVLW  89
079D2:  MOVWF  FE9
079D4:  MOVFF  684,6B8
079D8:  MOVFF  683,6B7
079DC:  MOVFF  682,6B6
079E0:  MOVFF  681,6B5
079E4:  MOVLW  02
079E6:  MOVLB  6
079E8:  MOVWF  xB9
079EA:  MOVLB  0
079EC:  CALL   641A
079F0:  MOVLW  2C
079F2:  MOVLB  6
079F4:  MOVWF  xC2
079F6:  MOVLB  0
079F8:  CALL   561C
079FC:  BRA    7CA8
079FE:  MOVLB  6
....................    else if ('2' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c2);
07A00:  MOVF   x7E,W
07A02:  SUBLW  32
07A04:  BNZ   7AA8
07A06:  MOVLW  04
07A08:  MOVWF  xB4
07A0A:  MOVLW  A7
07A0C:  MOVWF  xB3
07A0E:  MOVLB  0
07A10:  CALL   556C
07A14:  MOVF   01,W
07A16:  ADDLW  A7
07A18:  MOVLB  6
07A1A:  MOVWF  x7F
07A1C:  MOVLW  04
07A1E:  ADDWFC 02,W
07A20:  MOVWF  x80
07A22:  MOVLW  01
07A24:  SUBWF  x7D,W
07A26:  MULLW  18
07A28:  MOVF   FF3,W
07A2A:  CLRF   x82
07A2C:  MOVWF  x81
07A2E:  MOVLW  08
07A30:  ADDWF  x81,W
07A32:  MOVWF  01
07A34:  MOVLW  00
07A36:  ADDWFC x82,W
07A38:  MOVWF  03
07A3A:  MOVF   01,W
07A3C:  ADDLW  82
07A3E:  MOVWF  FE9
07A40:  MOVLW  00
07A42:  ADDWFC 03,W
07A44:  MOVWF  FEA
07A46:  MOVFF  FEF,681
07A4A:  MOVFF  FEC,682
07A4E:  MOVFF  FEC,683
07A52:  MOVFF  FEC,684
07A56:  MOVFF  680,54B
07A5A:  MOVFF  67F,54A
07A5E:  MOVFF  67D,6A6
07A62:  MOVLW  18
07A64:  MOVWF  xA7
07A66:  MOVLB  0
07A68:  CALL   5B28
07A6C:  MOVLW  2C
07A6E:  MOVLB  6
07A70:  MOVWF  xC2
07A72:  MOVLB  0
07A74:  CALL   561C
07A78:  MOVLW  89
07A7A:  MOVWF  FE9
07A7C:  MOVFF  684,6B8
07A80:  MOVFF  683,6B7
07A84:  MOVFF  682,6B6
07A88:  MOVFF  681,6B5
07A8C:  MOVLW  02
07A8E:  MOVLB  6
07A90:  MOVWF  xB9
07A92:  MOVLB  0
07A94:  CALL   641A
07A98:  MOVLW  2C
07A9A:  MOVLB  6
07A9C:  MOVWF  xC2
07A9E:  MOVLB  0
07AA0:  CALL   561C
07AA4:  BRA    7CA8
07AA6:  MOVLB  6
....................    else if ('3' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c3);
07AA8:  MOVF   x7E,W
07AAA:  SUBLW  33
07AAC:  BNZ   7B50
07AAE:  MOVLW  04
07AB0:  MOVWF  xB4
07AB2:  MOVLW  A7
07AB4:  MOVWF  xB3
07AB6:  MOVLB  0
07AB8:  CALL   556C
07ABC:  MOVF   01,W
07ABE:  ADDLW  A7
07AC0:  MOVLB  6
07AC2:  MOVWF  x7F
07AC4:  MOVLW  04
07AC6:  ADDWFC 02,W
07AC8:  MOVWF  x80
07ACA:  MOVLW  01
07ACC:  SUBWF  x7D,W
07ACE:  MULLW  18
07AD0:  MOVF   FF3,W
07AD2:  CLRF   x82
07AD4:  MOVWF  x81
07AD6:  MOVLW  0C
07AD8:  ADDWF  x81,W
07ADA:  MOVWF  01
07ADC:  MOVLW  00
07ADE:  ADDWFC x82,W
07AE0:  MOVWF  03
07AE2:  MOVF   01,W
07AE4:  ADDLW  82
07AE6:  MOVWF  FE9
07AE8:  MOVLW  00
07AEA:  ADDWFC 03,W
07AEC:  MOVWF  FEA
07AEE:  MOVFF  FEF,681
07AF2:  MOVFF  FEC,682
07AF6:  MOVFF  FEC,683
07AFA:  MOVFF  FEC,684
07AFE:  MOVFF  680,54B
07B02:  MOVFF  67F,54A
07B06:  MOVFF  67D,6A6
07B0A:  MOVLW  18
07B0C:  MOVWF  xA7
07B0E:  MOVLB  0
07B10:  CALL   5B28
07B14:  MOVLW  2C
07B16:  MOVLB  6
07B18:  MOVWF  xC2
07B1A:  MOVLB  0
07B1C:  CALL   561C
07B20:  MOVLW  89
07B22:  MOVWF  FE9
07B24:  MOVFF  684,6B8
07B28:  MOVFF  683,6B7
07B2C:  MOVFF  682,6B6
07B30:  MOVFF  681,6B5
07B34:  MOVLW  02
07B36:  MOVLB  6
07B38:  MOVWF  xB9
07B3A:  MOVLB  0
07B3C:  CALL   641A
07B40:  MOVLW  2C
07B42:  MOVLB  6
07B44:  MOVWF  xC2
07B46:  MOVLB  0
07B48:  CALL   561C
07B4C:  BRA    7CA8
07B4E:  MOVLB  6
....................    else if ('4' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c4);
07B50:  MOVF   x7E,W
07B52:  SUBLW  34
07B54:  BNZ   7BF8
07B56:  MOVLW  04
07B58:  MOVWF  xB4
07B5A:  MOVLW  A7
07B5C:  MOVWF  xB3
07B5E:  MOVLB  0
07B60:  CALL   556C
07B64:  MOVF   01,W
07B66:  ADDLW  A7
07B68:  MOVLB  6
07B6A:  MOVWF  x7F
07B6C:  MOVLW  04
07B6E:  ADDWFC 02,W
07B70:  MOVWF  x80
07B72:  MOVLW  01
07B74:  SUBWF  x7D,W
07B76:  MULLW  18
07B78:  MOVF   FF3,W
07B7A:  CLRF   x82
07B7C:  MOVWF  x81
07B7E:  MOVLW  10
07B80:  ADDWF  x81,W
07B82:  MOVWF  01
07B84:  MOVLW  00
07B86:  ADDWFC x82,W
07B88:  MOVWF  03
07B8A:  MOVF   01,W
07B8C:  ADDLW  82
07B8E:  MOVWF  FE9
07B90:  MOVLW  00
07B92:  ADDWFC 03,W
07B94:  MOVWF  FEA
07B96:  MOVFF  FEF,681
07B9A:  MOVFF  FEC,682
07B9E:  MOVFF  FEC,683
07BA2:  MOVFF  FEC,684
07BA6:  MOVFF  680,54B
07BAA:  MOVFF  67F,54A
07BAE:  MOVFF  67D,6A6
07BB2:  MOVLW  18
07BB4:  MOVWF  xA7
07BB6:  MOVLB  0
07BB8:  CALL   5B28
07BBC:  MOVLW  2C
07BBE:  MOVLB  6
07BC0:  MOVWF  xC2
07BC2:  MOVLB  0
07BC4:  CALL   561C
07BC8:  MOVLW  89
07BCA:  MOVWF  FE9
07BCC:  MOVFF  684,6B8
07BD0:  MOVFF  683,6B7
07BD4:  MOVFF  682,6B6
07BD8:  MOVFF  681,6B5
07BDC:  MOVLW  02
07BDE:  MOVLB  6
07BE0:  MOVWF  xB9
07BE2:  MOVLB  0
07BE4:  CALL   641A
07BE8:  MOVLW  2C
07BEA:  MOVLB  6
07BEC:  MOVWF  xC2
07BEE:  MOVLB  0
07BF0:  CALL   561C
07BF4:  BRA    7CA8
07BF6:  MOVLB  6
....................    else if ('5' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c5);
07BF8:  MOVF   x7E,W
07BFA:  SUBLW  35
07BFC:  BNZ   7CA0
07BFE:  MOVLW  04
07C00:  MOVWF  xB4
07C02:  MOVLW  A7
07C04:  MOVWF  xB3
07C06:  MOVLB  0
07C08:  CALL   556C
07C0C:  MOVF   01,W
07C0E:  ADDLW  A7
07C10:  MOVLB  6
07C12:  MOVWF  x7F
07C14:  MOVLW  04
07C16:  ADDWFC 02,W
07C18:  MOVWF  x80
07C1A:  MOVLW  01
07C1C:  SUBWF  x7D,W
07C1E:  MULLW  18
07C20:  MOVF   FF3,W
07C22:  CLRF   x82
07C24:  MOVWF  x81
07C26:  MOVLW  14
07C28:  ADDWF  x81,W
07C2A:  MOVWF  01
07C2C:  MOVLW  00
07C2E:  ADDWFC x82,W
07C30:  MOVWF  03
07C32:  MOVF   01,W
07C34:  ADDLW  82
07C36:  MOVWF  FE9
07C38:  MOVLW  00
07C3A:  ADDWFC 03,W
07C3C:  MOVWF  FEA
07C3E:  MOVFF  FEF,681
07C42:  MOVFF  FEC,682
07C46:  MOVFF  FEC,683
07C4A:  MOVFF  FEC,684
07C4E:  MOVFF  680,54B
07C52:  MOVFF  67F,54A
07C56:  MOVFF  67D,6A6
07C5A:  MOVLW  18
07C5C:  MOVWF  xA7
07C5E:  MOVLB  0
07C60:  CALL   5B28
07C64:  MOVLW  2C
07C66:  MOVLB  6
07C68:  MOVWF  xC2
07C6A:  MOVLB  0
07C6C:  CALL   561C
07C70:  MOVLW  89
07C72:  MOVWF  FE9
07C74:  MOVFF  684,6B8
07C78:  MOVFF  683,6B7
07C7C:  MOVFF  682,6B6
07C80:  MOVFF  681,6B5
07C84:  MOVLW  02
07C86:  MOVLB  6
07C88:  MOVWF  xB9
07C8A:  MOVLB  0
07C8C:  CALL   641A
07C90:  MOVLW  2C
07C92:  MOVLB  6
07C94:  MOVWF  xC2
07C96:  MOVLB  0
07C98:  CALL   561C
07C9C:  BRA    7CA8
07C9E:  MOVLB  6
....................    else return INV_PARAM;
07CA0:  MOVLW  02
07CA2:  MOVWF  01
07CA4:  MOVLB  0
07CA6:  BRA    7CAC
....................    
....................    return SUCCESS;
07CA8:  MOVLW  00
07CAA:  MOVWF  01
07CAC:  RETURN 0
.................... }
.................... 
.................... int8 setSensorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char  arg2;
....................    float arg3;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
07CAE:  MOVLB  6
07CB0:  CLRF   xB4
07CB2:  MOVFF  66B,6B3
07CB6:  CLRF   xB6
07CB8:  MOVLW  B5
07CBA:  MOVWF  xB5
07CBC:  MOVLB  0
07CBE:  CALL   082A
07CC2:  MOVFF  02,684
07CC6:  MOVFF  01,683
07CCA:  MOVLW  06
07CCC:  MOVLB  6
07CCE:  ADDWF  x83,F
07CD0:  MOVLW  00
07CD2:  ADDWFC x84,F
07CD4:  MOVLW  32
07CD6:  ADDWF  x83,W
07CD8:  MOVWF  01
07CDA:  MOVLW  00
07CDC:  ADDWFC x84,W
07CDE:  MOVWF  03
07CE0:  MOVF   01,W
07CE2:  ADDLW  D1
07CE4:  MOVWF  01
07CE6:  MOVLW  01
07CE8:  ADDWFC 03,F
07CEA:  MOVFF  01,683
07CEE:  MOVFF  03,684
07CF2:  MOVFF  03,6A6
07CF6:  MOVFF  01,6A5
07CFA:  MOVLB  0
07CFC:  CALL   56E4
07D00:  MOVF   01,F
07D02:  BNZ   7D0C
07D04:  MOVLW  02
07D06:  MOVWF  01
07D08:  BRA    8044
07D0A:  BRA    7D6A
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07D0C:  MOVLB  6
07D0E:  CLRF   xB4
07D10:  MOVFF  66B,6B3
07D14:  CLRF   xB6
07D16:  MOVLW  B5
07D18:  MOVWF  xB5
07D1A:  MOVLB  0
07D1C:  CALL   082A
07D20:  MOVFF  02,684
07D24:  MOVFF  01,683
07D28:  MOVLW  06
07D2A:  MOVLB  6
07D2C:  ADDWF  x83,F
07D2E:  MOVLW  00
07D30:  ADDWFC x84,F
07D32:  MOVLW  32
07D34:  ADDWF  x83,W
07D36:  MOVWF  01
07D38:  MOVLW  00
07D3A:  ADDWFC x84,W
07D3C:  MOVWF  03
07D3E:  MOVF   01,W
07D40:  ADDLW  D1
07D42:  MOVWF  01
07D44:  MOVLW  01
07D46:  ADDWFC 03,F
07D48:  MOVFF  01,683
07D4C:  MOVFF  03,684
07D50:  MOVFF  03,6A6
07D54:  MOVFF  01,6A5
07D58:  CLRF   xA8
07D5A:  CLRF   xA7
07D5C:  MOVLW  0A
07D5E:  MOVWF  xA9
07D60:  MOVLB  0
07D62:  CALL   57D4
07D66:  MOVFF  01,67D
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
07D6A:  MOVLB  6
07D6C:  CLRF   xB4
07D6E:  MOVFF  66B,6B3
07D72:  CLRF   xB6
07D74:  MOVLW  B5
07D76:  MOVWF  xB5
07D78:  MOVLB  0
07D7A:  CALL   082A
07D7E:  MOVFF  02,684
07D82:  MOVFF  01,683
07D86:  MOVLW  06
07D88:  MOVLB  6
07D8A:  ADDWF  x83,F
07D8C:  MOVLW  00
07D8E:  ADDWFC x84,F
07D90:  MOVLW  4B
07D92:  ADDWF  x83,W
07D94:  MOVWF  01
07D96:  MOVLW  00
07D98:  ADDWFC x84,W
07D9A:  MOVWF  03
07D9C:  MOVF   01,W
07D9E:  ADDLW  D1
07DA0:  MOVWF  01
07DA2:  MOVLW  01
07DA4:  ADDWFC 03,F
07DA6:  MOVFF  01,683
07DAA:  MOVFF  03,684
07DAE:  MOVFF  03,6B4
07DB2:  MOVFF  01,6B3
07DB6:  MOVLB  0
07DB8:  CALL   556C
07DBC:  MOVFF  02,03
07DC0:  MOVF   01,W
07DC2:  SUBLW  01
07DC4:  BNZ   7DCA
07DC6:  MOVF   03,F
07DC8:  BZ    7DD2
07DCA:  MOVLW  02
07DCC:  MOVWF  01
07DCE:  BRA    8044
07DD0:  BRA    7E12
....................    else arg2 = SERcmd[rec].p[3][0];
07DD2:  MOVLB  6
07DD4:  CLRF   xB4
07DD6:  MOVFF  66B,6B3
07DDA:  CLRF   xB6
07DDC:  MOVLW  B5
07DDE:  MOVWF  xB5
07DE0:  MOVLB  0
07DE2:  CALL   082A
07DE6:  MOVFF  02,684
07DEA:  MOVFF  01,683
07DEE:  MOVLW  06
07DF0:  MOVLB  6
07DF2:  ADDWF  x83,F
07DF4:  MOVLW  00
07DF6:  ADDWFC x84,F
07DF8:  MOVLW  4B
07DFA:  ADDWF  x83,F
07DFC:  MOVLW  00
07DFE:  ADDWFC x84,F
07E00:  MOVLW  D1
07E02:  ADDWF  x83,W
07E04:  MOVWF  FE9
07E06:  MOVLW  01
07E08:  ADDWFC x84,W
07E0A:  MOVWF  FEA
07E0C:  MOVFF  FEF,67E
07E10:  MOVLB  0
....................    
....................    if (!arg_is_float(SERcmd[rec].p[4])) return INV_PARAM;
07E12:  MOVLB  6
07E14:  CLRF   xB4
07E16:  MOVFF  66B,6B3
07E1A:  CLRF   xB6
07E1C:  MOVLW  B5
07E1E:  MOVWF  xB5
07E20:  MOVLB  0
07E22:  CALL   082A
07E26:  MOVFF  02,684
07E2A:  MOVFF  01,683
07E2E:  MOVLW  06
07E30:  MOVLB  6
07E32:  ADDWF  x83,F
07E34:  MOVLW  00
07E36:  ADDWFC x84,F
07E38:  MOVLW  64
07E3A:  ADDWF  x83,W
07E3C:  MOVWF  01
07E3E:  MOVLW  00
07E40:  ADDWFC x84,W
07E42:  MOVWF  03
07E44:  MOVF   01,W
07E46:  ADDLW  D1
07E48:  MOVWF  01
07E4A:  MOVLW  01
07E4C:  ADDWFC 03,F
07E4E:  MOVFF  01,683
07E52:  MOVFF  03,684
07E56:  MOVFF  03,687
07E5A:  MOVFF  01,686
07E5E:  MOVLB  0
07E60:  CALL   6A80
07E64:  MOVF   01,F
07E66:  BNZ   7E70
07E68:  MOVLW  02
07E6A:  MOVWF  01
07E6C:  BRA    8044
07E6E:  BRA    7ED6
....................    else arg3 = strtod(SERcmd[rec].p[4], '\0');
07E70:  MOVLB  6
07E72:  CLRF   xB4
07E74:  MOVFF  66B,6B3
07E78:  CLRF   xB6
07E7A:  MOVLW  B5
07E7C:  MOVWF  xB5
07E7E:  MOVLB  0
07E80:  CALL   082A
07E84:  MOVFF  02,684
07E88:  MOVFF  01,683
07E8C:  MOVLW  06
07E8E:  MOVLB  6
07E90:  ADDWF  x83,F
07E92:  MOVLW  00
07E94:  ADDWFC x84,F
07E96:  MOVLW  64
07E98:  ADDWF  x83,W
07E9A:  MOVWF  01
07E9C:  MOVLW  00
07E9E:  ADDWFC x84,W
07EA0:  MOVWF  03
07EA2:  MOVF   01,W
07EA4:  ADDLW  D1
07EA6:  MOVWF  01
07EA8:  MOVLW  01
07EAA:  ADDWFC 03,F
07EAC:  MOVFF  01,683
07EB0:  MOVFF  03,684
07EB4:  MOVFF  03,687
07EB8:  MOVFF  01,686
07EBC:  CLRF   x89
07EBE:  CLRF   x88
07EC0:  MOVLB  0
07EC2:  CALL   6B42
07EC6:  MOVFF  03,682
07ECA:  MOVFF  02,681
07ECE:  MOVFF  01,680
07ED2:  MOVFF  00,67F
....................    
....................    /*** SET SENSOR CAL PARAM **********/
....................    if      ('0' == arg2) sensorCal[arg1-1].c0 = arg3;
07ED6:  MOVLB  6
07ED8:  MOVF   x7E,W
07EDA:  SUBLW  30
07EDC:  BNZ   7F08
07EDE:  MOVLW  01
07EE0:  SUBWF  x7D,W
07EE2:  MULLW  18
07EE4:  MOVF   FF3,W
07EE6:  CLRF   x84
07EE8:  MOVWF  x83
07EEA:  MOVLW  82
07EEC:  ADDWF  x83,W
07EEE:  MOVWF  FE9
07EF0:  MOVLW  00
07EF2:  ADDWFC x84,W
07EF4:  MOVWF  FEA
07EF6:  MOVFF  67F,FEF
07EFA:  MOVFF  680,FEC
07EFE:  MOVFF  681,FEC
07F02:  MOVFF  682,FEC
07F06:  BRA    803E
....................    else if ('1' == arg2) sensorCal[arg1-1].c1 = arg3;
07F08:  MOVF   x7E,W
07F0A:  SUBLW  31
07F0C:  BNZ   7F44
07F0E:  MOVLW  01
07F10:  SUBWF  x7D,W
07F12:  MULLW  18
07F14:  MOVF   FF3,W
07F16:  CLRF   x84
07F18:  MOVWF  x83
07F1A:  MOVLW  04
07F1C:  ADDWF  x83,W
07F1E:  MOVWF  01
07F20:  MOVLW  00
07F22:  ADDWFC x84,W
07F24:  MOVWF  03
07F26:  MOVF   01,W
07F28:  ADDLW  82
07F2A:  MOVWF  FE9
07F2C:  MOVLW  00
07F2E:  ADDWFC 03,W
07F30:  MOVWF  FEA
07F32:  MOVFF  67F,FEF
07F36:  MOVFF  680,FEC
07F3A:  MOVFF  681,FEC
07F3E:  MOVFF  682,FEC
07F42:  BRA    803E
....................    else if ('2' == arg2) sensorCal[arg1-1].c2 = arg3;
07F44:  MOVF   x7E,W
07F46:  SUBLW  32
07F48:  BNZ   7F80
07F4A:  MOVLW  01
07F4C:  SUBWF  x7D,W
07F4E:  MULLW  18
07F50:  MOVF   FF3,W
07F52:  CLRF   x84
07F54:  MOVWF  x83
07F56:  MOVLW  08
07F58:  ADDWF  x83,W
07F5A:  MOVWF  01
07F5C:  MOVLW  00
07F5E:  ADDWFC x84,W
07F60:  MOVWF  03
07F62:  MOVF   01,W
07F64:  ADDLW  82
07F66:  MOVWF  FE9
07F68:  MOVLW  00
07F6A:  ADDWFC 03,W
07F6C:  MOVWF  FEA
07F6E:  MOVFF  67F,FEF
07F72:  MOVFF  680,FEC
07F76:  MOVFF  681,FEC
07F7A:  MOVFF  682,FEC
07F7E:  BRA    803E
....................    else if ('3' == arg2) sensorCal[arg1-1].c3 = arg3;
07F80:  MOVF   x7E,W
07F82:  SUBLW  33
07F84:  BNZ   7FBC
07F86:  MOVLW  01
07F88:  SUBWF  x7D,W
07F8A:  MULLW  18
07F8C:  MOVF   FF3,W
07F8E:  CLRF   x84
07F90:  MOVWF  x83
07F92:  MOVLW  0C
07F94:  ADDWF  x83,W
07F96:  MOVWF  01
07F98:  MOVLW  00
07F9A:  ADDWFC x84,W
07F9C:  MOVWF  03
07F9E:  MOVF   01,W
07FA0:  ADDLW  82
07FA2:  MOVWF  FE9
07FA4:  MOVLW  00
07FA6:  ADDWFC 03,W
07FA8:  MOVWF  FEA
07FAA:  MOVFF  67F,FEF
07FAE:  MOVFF  680,FEC
07FB2:  MOVFF  681,FEC
07FB6:  MOVFF  682,FEC
07FBA:  BRA    803E
....................    else if ('4' == arg2) sensorCal[arg1-1].c4 = arg3;
07FBC:  MOVF   x7E,W
07FBE:  SUBLW  34
07FC0:  BNZ   7FF8
07FC2:  MOVLW  01
07FC4:  SUBWF  x7D,W
07FC6:  MULLW  18
07FC8:  MOVF   FF3,W
07FCA:  CLRF   x84
07FCC:  MOVWF  x83
07FCE:  MOVLW  10
07FD0:  ADDWF  x83,W
07FD2:  MOVWF  01
07FD4:  MOVLW  00
07FD6:  ADDWFC x84,W
07FD8:  MOVWF  03
07FDA:  MOVF   01,W
07FDC:  ADDLW  82
07FDE:  MOVWF  FE9
07FE0:  MOVLW  00
07FE2:  ADDWFC 03,W
07FE4:  MOVWF  FEA
07FE6:  MOVFF  67F,FEF
07FEA:  MOVFF  680,FEC
07FEE:  MOVFF  681,FEC
07FF2:  MOVFF  682,FEC
07FF6:  BRA    803E
....................    else if ('5' == arg2) sensorCal[arg1-1].c5 = arg3;
07FF8:  MOVF   x7E,W
07FFA:  SUBLW  35
07FFC:  BNZ   8034
07FFE:  MOVLW  01
08000:  SUBWF  x7D,W
08002:  MULLW  18
08004:  MOVF   FF3,W
08006:  CLRF   x84
08008:  MOVWF  x83
0800A:  MOVLW  14
0800C:  ADDWF  x83,W
0800E:  MOVWF  01
08010:  MOVLW  00
08012:  ADDWFC x84,W
08014:  MOVWF  03
08016:  MOVF   01,W
08018:  ADDLW  82
0801A:  MOVWF  FE9
0801C:  MOVLW  00
0801E:  ADDWFC 03,W
08020:  MOVWF  FEA
08022:  MOVFF  67F,FEF
08026:  MOVFF  680,FEC
0802A:  MOVFF  681,FEC
0802E:  MOVFF  682,FEC
08032:  BRA    803E
....................    else return INV_PARAM;
08034:  MOVLW  02
08036:  MOVWF  01
08038:  MOVLB  0
0803A:  BRA    8044
0803C:  MOVLB  6
....................    
....................    return SUCCESS;
0803E:  MOVLW  00
08040:  MOVWF  01
08042:  MOVLB  0
08044:  RETURN 0
.................... }
.................... 
.................... int8 getMonitorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    char *arg1;
....................    char *s_N15 = "N15";
08046:  MOVLW  4E
08048:  MOVLB  6
0804A:  MOVWF  x81
0804C:  MOVLW  31
0804E:  MOVWF  x82
08050:  MOVLW  35
08052:  MOVWF  x83
08054:  CLRF   x84
08056:  MOVLW  06
08058:  MOVWF  x80
0805A:  MOVLW  81
0805C:  MOVWF  x7F
....................    char *s_200 = "200";
0805E:  MOVLW  32
08060:  MOVWF  x87
08062:  MOVLW  30
08064:  MOVWF  x88
08066:  MOVWF  x89
08068:  CLRF   x8A
0806A:  MOVLW  06
0806C:  MOVWF  x86
0806E:  MOVLW  87
08070:  MOVWF  x85
....................    char *s_5V6 = "5V6";
08072:  MOVLW  35
08074:  MOVWF  x8D
08076:  MOVLW  56
08078:  MOVWF  x8E
0807A:  MOVLW  36
0807C:  MOVWF  x8F
0807E:  CLRF   x90
08080:  MOVLW  06
08082:  MOVWF  x8C
08084:  MOVLW  8D
08086:  MOVWF  x8B
....................    char *s_5VA = "5VA";
08088:  MOVLW  35
0808A:  MOVWF  x93
0808C:  MOVLW  56
0808E:  MOVWF  x94
08090:  MOVLW  41
08092:  MOVWF  x95
08094:  CLRF   x96
08096:  MOVLW  06
08098:  MOVWF  x92
0809A:  MOVLW  93
0809C:  MOVWF  x91
....................    char *s_3V6X = "3V6X";
0809E:  MOVLW  33
080A0:  MOVWF  x99
080A2:  MOVLW  56
080A4:  MOVWF  x9A
080A6:  MOVLW  36
080A8:  MOVWF  x9B
080AA:  MOVLW  58
080AC:  MOVWF  x9C
080AE:  CLRF   x9D
080B0:  MOVLW  06
080B2:  MOVWF  x98
080B4:  MOVLW  99
080B6:  MOVWF  x97
....................    char *s_3V3A = "3V3A";
080B8:  MOVLW  33
080BA:  MOVWF  xA0
080BC:  MOVLW  56
080BE:  MOVWF  xA1
080C0:  MOVLW  33
080C2:  MOVWF  xA2
080C4:  MOVLW  41
080C6:  MOVWF  xA3
080C8:  CLRF   xA4
080CA:  MOVLW  06
080CC:  MOVWF  x9F
080CE:  MOVLW  A0
080D0:  MOVWF  x9E
....................    char *s_3V3D = "3V3D";
080D2:  MOVLW  33
080D4:  MOVWF  xA7
080D6:  MOVLW  56
080D8:  MOVWF  xA8
080DA:  MOVLW  33
080DC:  MOVWF  xA9
080DE:  MOVLW  44
080E0:  MOVWF  xAA
080E2:  CLRF   xAB
080E4:  MOVLW  06
080E6:  MOVWF  xA6
080E8:  MOVLW  A7
080EA:  MOVWF  xA5
.................... //!   char *s_all = "all";
....................    
....................    arg1 = SERcmd[rec].p[2];
080EC:  CLRF   xB4
080EE:  MOVFF  66B,6B3
080F2:  CLRF   xB6
080F4:  MOVLW  B5
080F6:  MOVWF  xB5
080F8:  MOVLB  0
080FA:  CALL   082A
080FE:  MOVFF  02,6AD
08102:  MOVFF  01,6AC
08106:  MOVLW  06
08108:  MOVLB  6
0810A:  ADDWF  xAC,F
0810C:  MOVLW  00
0810E:  ADDWFC xAD,F
08110:  MOVLW  32
08112:  ADDWF  xAC,W
08114:  MOVWF  01
08116:  MOVLW  00
08118:  ADDWFC xAD,W
0811A:  MOVWF  03
0811C:  MOVF   01,W
0811E:  ADDLW  D1
08120:  MOVWF  01
08122:  MOVLW  01
08124:  ADDWFC 03,F
08126:  MOVFF  01,67D
0812A:  MOVFF  03,67E
....................    
....................    /*** GET MONITOR VALUES ************/
....................    if      (0 == strcmp(s_N15, arg1)) {
0812E:  MOVFF  680,6B4
08132:  MOVFF  67F,6B3
08136:  MOVFF  67E,6B6
0813A:  MOVFF  67D,6B5
0813E:  MOVLB  0
08140:  CALL   55A4
08144:  MOVF   01,F
08146:  BNZ   81CA
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.vN15[0],monCal.vN15[1]);
08148:  MOVLW  04
0814A:  MOVLB  6
0814C:  MOVWF  xB4
0814E:  MOVLW  A7
08150:  MOVWF  xB3
08152:  MOVLB  0
08154:  CALL   556C
08158:  MOVFF  02,03
0815C:  MOVF   01,W
0815E:  ADDLW  A7
08160:  MOVLB  6
08162:  MOVWF  xAC
08164:  MOVLW  04
08166:  ADDWFC 02,W
08168:  MOVWF  xAD
0816A:  MOVFF  FE8,54B
0816E:  MOVFF  6AC,54A
08172:  MOVLW  89
08174:  MOVWF  FE9
08176:  MOVFF  B5,6B8
0817A:  MOVFF  B4,6B7
0817E:  MOVFF  B3,6B6
08182:  MOVFF  B2,6B5
08186:  MOVLW  02
08188:  MOVWF  xB9
0818A:  MOVLB  0
0818C:  CALL   641A
08190:  MOVLW  2C
08192:  MOVLB  6
08194:  MOVWF  xC2
08196:  MOVLB  0
08198:  CALL   561C
0819C:  MOVLW  89
0819E:  MOVWF  FE9
081A0:  MOVFF  B9,6B8
081A4:  MOVFF  B8,6B7
081A8:  MOVFF  B7,6B6
081AC:  MOVFF  B6,6B5
081B0:  MOVLW  02
081B2:  MOVLB  6
081B4:  MOVWF  xB9
081B6:  MOVLB  0
081B8:  CALL   641A
081BC:  MOVLW  2C
081BE:  MOVLB  6
081C0:  MOVWF  xC2
081C2:  MOVLB  0
081C4:  CALL   561C
....................    }
081C8:  BRA    856C
....................    else if (0 == strcmp(s_200, arg1)) {
081CA:  MOVFF  686,6B4
081CE:  MOVFF  685,6B3
081D2:  MOVFF  67E,6B6
081D6:  MOVFF  67D,6B5
081DA:  CALL   55A4
081DE:  MOVF   01,F
081E0:  BNZ   8264
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v200[0],monCal.v200[1]);
081E2:  MOVLW  04
081E4:  MOVLB  6
081E6:  MOVWF  xB4
081E8:  MOVLW  A7
081EA:  MOVWF  xB3
081EC:  MOVLB  0
081EE:  CALL   556C
081F2:  MOVFF  02,03
081F6:  MOVF   01,W
081F8:  ADDLW  A7
081FA:  MOVLB  6
081FC:  MOVWF  xAC
081FE:  MOVLW  04
08200:  ADDWFC 02,W
08202:  MOVWF  xAD
08204:  MOVFF  FE8,54B
08208:  MOVFF  6AC,54A
0820C:  MOVLW  89
0820E:  MOVWF  FE9
08210:  MOVFF  BD,6B8
08214:  MOVFF  BC,6B7
08218:  MOVFF  BB,6B6
0821C:  MOVFF  BA,6B5
08220:  MOVLW  02
08222:  MOVWF  xB9
08224:  MOVLB  0
08226:  CALL   641A
0822A:  MOVLW  2C
0822C:  MOVLB  6
0822E:  MOVWF  xC2
08230:  MOVLB  0
08232:  CALL   561C
08236:  MOVLW  89
08238:  MOVWF  FE9
0823A:  MOVFF  C1,6B8
0823E:  MOVFF  C0,6B7
08242:  MOVFF  BF,6B6
08246:  MOVFF  BE,6B5
0824A:  MOVLW  02
0824C:  MOVLB  6
0824E:  MOVWF  xB9
08250:  MOVLB  0
08252:  CALL   641A
08256:  MOVLW  2C
08258:  MOVLB  6
0825A:  MOVWF  xC2
0825C:  MOVLB  0
0825E:  CALL   561C
....................    }
08262:  BRA    856C
....................    else if (0 == strcmp(s_5V6, arg1)) {
08264:  MOVFF  68C,6B4
08268:  MOVFF  68B,6B3
0826C:  MOVFF  67E,6B6
08270:  MOVFF  67D,6B5
08274:  CALL   55A4
08278:  MOVF   01,F
0827A:  BNZ   82FE
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v5V6[0],monCal.v5V6[1]);
0827C:  MOVLW  04
0827E:  MOVLB  6
08280:  MOVWF  xB4
08282:  MOVLW  A7
08284:  MOVWF  xB3
08286:  MOVLB  0
08288:  CALL   556C
0828C:  MOVFF  02,03
08290:  MOVF   01,W
08292:  ADDLW  A7
08294:  MOVLB  6
08296:  MOVWF  xAC
08298:  MOVLW  04
0829A:  ADDWFC 02,W
0829C:  MOVWF  xAD
0829E:  MOVFF  FE8,54B
082A2:  MOVFF  6AC,54A
082A6:  MOVLW  89
082A8:  MOVWF  FE9
082AA:  MOVFF  C5,6B8
082AE:  MOVFF  C4,6B7
082B2:  MOVFF  C3,6B6
082B6:  MOVFF  C2,6B5
082BA:  MOVLW  02
082BC:  MOVWF  xB9
082BE:  MOVLB  0
082C0:  CALL   641A
082C4:  MOVLW  2C
082C6:  MOVLB  6
082C8:  MOVWF  xC2
082CA:  MOVLB  0
082CC:  CALL   561C
082D0:  MOVLW  89
082D2:  MOVWF  FE9
082D4:  MOVFF  C9,6B8
082D8:  MOVFF  C8,6B7
082DC:  MOVFF  C7,6B6
082E0:  MOVFF  C6,6B5
082E4:  MOVLW  02
082E6:  MOVLB  6
082E8:  MOVWF  xB9
082EA:  MOVLB  0
082EC:  CALL   641A
082F0:  MOVLW  2C
082F2:  MOVLB  6
082F4:  MOVWF  xC2
082F6:  MOVLB  0
082F8:  CALL   561C
....................    }
082FC:  BRA    856C
....................    else if (0 == strcmp(s_5VA, arg1)) {
082FE:  MOVFF  692,6B4
08302:  MOVFF  691,6B3
08306:  MOVFF  67E,6B6
0830A:  MOVFF  67D,6B5
0830E:  CALL   55A4
08312:  MOVF   01,F
08314:  BNZ   8398
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v5VA[0],monCal.v5VA[1]);
08316:  MOVLW  04
08318:  MOVLB  6
0831A:  MOVWF  xB4
0831C:  MOVLW  A7
0831E:  MOVWF  xB3
08320:  MOVLB  0
08322:  CALL   556C
08326:  MOVFF  02,03
0832A:  MOVF   01,W
0832C:  ADDLW  A7
0832E:  MOVLB  6
08330:  MOVWF  xAC
08332:  MOVLW  04
08334:  ADDWFC 02,W
08336:  MOVWF  xAD
08338:  MOVFF  FE8,54B
0833C:  MOVFF  6AC,54A
08340:  MOVLW  89
08342:  MOVWF  FE9
08344:  MOVFF  CD,6B8
08348:  MOVFF  CC,6B7
0834C:  MOVFF  CB,6B6
08350:  MOVFF  CA,6B5
08354:  MOVLW  02
08356:  MOVWF  xB9
08358:  MOVLB  0
0835A:  CALL   641A
0835E:  MOVLW  2C
08360:  MOVLB  6
08362:  MOVWF  xC2
08364:  MOVLB  0
08366:  CALL   561C
0836A:  MOVLW  89
0836C:  MOVWF  FE9
0836E:  MOVFF  D1,6B8
08372:  MOVFF  D0,6B7
08376:  MOVFF  CF,6B6
0837A:  MOVFF  CE,6B5
0837E:  MOVLW  02
08380:  MOVLB  6
08382:  MOVWF  xB9
08384:  MOVLB  0
08386:  CALL   641A
0838A:  MOVLW  2C
0838C:  MOVLB  6
0838E:  MOVWF  xC2
08390:  MOVLB  0
08392:  CALL   561C
....................    }
08396:  BRA    856C
....................    else if (0 == strcmp(s_3V6X, arg1)) {
08398:  MOVFF  698,6B4
0839C:  MOVFF  697,6B3
083A0:  MOVFF  67E,6B6
083A4:  MOVFF  67D,6B5
083A8:  CALL   55A4
083AC:  MOVF   01,F
083AE:  BNZ   8432
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V6X[0],monCal.v3V6X[1]);
083B0:  MOVLW  04
083B2:  MOVLB  6
083B4:  MOVWF  xB4
083B6:  MOVLW  A7
083B8:  MOVWF  xB3
083BA:  MOVLB  0
083BC:  CALL   556C
083C0:  MOVFF  02,03
083C4:  MOVF   01,W
083C6:  ADDLW  A7
083C8:  MOVLB  6
083CA:  MOVWF  xAC
083CC:  MOVLW  04
083CE:  ADDWFC 02,W
083D0:  MOVWF  xAD
083D2:  MOVFF  FE8,54B
083D6:  MOVFF  6AC,54A
083DA:  MOVLW  89
083DC:  MOVWF  FE9
083DE:  MOVFF  D5,6B8
083E2:  MOVFF  D4,6B7
083E6:  MOVFF  D3,6B6
083EA:  MOVFF  D2,6B5
083EE:  MOVLW  02
083F0:  MOVWF  xB9
083F2:  MOVLB  0
083F4:  CALL   641A
083F8:  MOVLW  2C
083FA:  MOVLB  6
083FC:  MOVWF  xC2
083FE:  MOVLB  0
08400:  CALL   561C
08404:  MOVLW  89
08406:  MOVWF  FE9
08408:  MOVFF  D9,6B8
0840C:  MOVFF  D8,6B7
08410:  MOVFF  D7,6B6
08414:  MOVFF  D6,6B5
08418:  MOVLW  02
0841A:  MOVLB  6
0841C:  MOVWF  xB9
0841E:  MOVLB  0
08420:  CALL   641A
08424:  MOVLW  2C
08426:  MOVLB  6
08428:  MOVWF  xC2
0842A:  MOVLB  0
0842C:  CALL   561C
....................    }
08430:  BRA    856C
....................    else if (0 == strcmp(s_3V3A, arg1)) {
08432:  MOVFF  69F,6B4
08436:  MOVFF  69E,6B3
0843A:  MOVFF  67E,6B6
0843E:  MOVFF  67D,6B5
08442:  CALL   55A4
08446:  MOVF   01,F
08448:  BNZ   84CC
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3A[0],monCal.v3V3A[1]);
0844A:  MOVLW  04
0844C:  MOVLB  6
0844E:  MOVWF  xB4
08450:  MOVLW  A7
08452:  MOVWF  xB3
08454:  MOVLB  0
08456:  CALL   556C
0845A:  MOVFF  02,03
0845E:  MOVF   01,W
08460:  ADDLW  A7
08462:  MOVLB  6
08464:  MOVWF  xAC
08466:  MOVLW  04
08468:  ADDWFC 02,W
0846A:  MOVWF  xAD
0846C:  MOVFF  FE8,54B
08470:  MOVFF  6AC,54A
08474:  MOVLW  89
08476:  MOVWF  FE9
08478:  MOVFF  DD,6B8
0847C:  MOVFF  DC,6B7
08480:  MOVFF  DB,6B6
08484:  MOVFF  DA,6B5
08488:  MOVLW  02
0848A:  MOVWF  xB9
0848C:  MOVLB  0
0848E:  CALL   641A
08492:  MOVLW  2C
08494:  MOVLB  6
08496:  MOVWF  xC2
08498:  MOVLB  0
0849A:  CALL   561C
0849E:  MOVLW  89
084A0:  MOVWF  FE9
084A2:  MOVFF  E1,6B8
084A6:  MOVFF  E0,6B7
084AA:  MOVFF  DF,6B6
084AE:  MOVFF  DE,6B5
084B2:  MOVLW  02
084B4:  MOVLB  6
084B6:  MOVWF  xB9
084B8:  MOVLB  0
084BA:  CALL   641A
084BE:  MOVLW  2C
084C0:  MOVLB  6
084C2:  MOVWF  xC2
084C4:  MOVLB  0
084C6:  CALL   561C
....................    }
084CA:  BRA    856C
....................    else if (0 == strcmp(s_3V3D, arg1)) {
084CC:  MOVFF  6A6,6B4
084D0:  MOVFF  6A5,6B3
084D4:  MOVFF  67E,6B6
084D8:  MOVFF  67D,6B5
084DC:  CALL   55A4
084E0:  MOVF   01,F
084E2:  BNZ   8566
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3D[0],monCal.v3V3D[1]);
084E4:  MOVLW  04
084E6:  MOVLB  6
084E8:  MOVWF  xB4
084EA:  MOVLW  A7
084EC:  MOVWF  xB3
084EE:  MOVLB  0
084F0:  CALL   556C
084F4:  MOVFF  02,03
084F8:  MOVF   01,W
084FA:  ADDLW  A7
084FC:  MOVLB  6
084FE:  MOVWF  xAC
08500:  MOVLW  04
08502:  ADDWFC 02,W
08504:  MOVWF  xAD
08506:  MOVFF  FE8,54B
0850A:  MOVFF  6AC,54A
0850E:  MOVLW  89
08510:  MOVWF  FE9
08512:  MOVFF  E5,6B8
08516:  MOVFF  E4,6B7
0851A:  MOVFF  E3,6B6
0851E:  MOVFF  E2,6B5
08522:  MOVLW  02
08524:  MOVWF  xB9
08526:  MOVLB  0
08528:  CALL   641A
0852C:  MOVLW  2C
0852E:  MOVLB  6
08530:  MOVWF  xC2
08532:  MOVLB  0
08534:  CALL   561C
08538:  MOVLW  89
0853A:  MOVWF  FE9
0853C:  MOVFF  E9,6B8
08540:  MOVFF  E8,6B7
08544:  MOVFF  E7,6B6
08548:  MOVFF  E6,6B5
0854C:  MOVLW  02
0854E:  MOVLB  6
08550:  MOVWF  xB9
08552:  MOVLB  0
08554:  CALL   641A
08558:  MOVLW  2C
0855A:  MOVLB  6
0855C:  MOVWF  xC2
0855E:  MOVLB  0
08560:  CALL   561C
....................    }
08564:  BRA    856C
.................... //!   else if (0 == strcmp(s_all, arg1)) {
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.vN15[0],monCal.vN15[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v200[0],monCal.v200[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v5V6[0],monCal.v5V6[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v5VA[0],monCal.v5VA[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V6X[0],monCal.v3V6X[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3A[0],monCal.v3V3A[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3D[0],monCal.v3V3D[1]);
.................... //!   }
....................    else return INV_PARAM;
08566:  MOVLW  02
08568:  MOVWF  01
0856A:  BRA    8570
....................    
....................    return SUCCESS;
0856C:  MOVLW  00
0856E:  MOVWF  01
08570:  RETURN 0
.................... }
.................... 
.................... int8 setMonitorCalParam(unsigned int8 rec){
.................... 
....................    return SUCCESS;
08572:  MOVLW  00
08574:  MOVWF  01
08576:  RETURN 0
.................... }
.................... 
.................... int8 getMonitorValue(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    char *arg1;
....................    char *s_N15 = "N15";
08578:  MOVLW  4E
0857A:  MOVLB  6
0857C:  MOVWF  x81
0857E:  MOVLW  31
08580:  MOVWF  x82
08582:  MOVLW  35
08584:  MOVWF  x83
08586:  CLRF   x84
08588:  MOVLW  06
0858A:  MOVWF  x80
0858C:  MOVLW  81
0858E:  MOVWF  x7F
....................    char *s_200 = "200";
08590:  MOVLW  32
08592:  MOVWF  x87
08594:  MOVLW  30
08596:  MOVWF  x88
08598:  MOVWF  x89
0859A:  CLRF   x8A
0859C:  MOVLW  06
0859E:  MOVWF  x86
085A0:  MOVLW  87
085A2:  MOVWF  x85
....................    char *s_5V6 = "5V6";
085A4:  MOVLW  35
085A6:  MOVWF  x8D
085A8:  MOVLW  56
085AA:  MOVWF  x8E
085AC:  MOVLW  36
085AE:  MOVWF  x8F
085B0:  CLRF   x90
085B2:  MOVLW  06
085B4:  MOVWF  x8C
085B6:  MOVLW  8D
085B8:  MOVWF  x8B
....................    char *s_5VA = "5VA";
085BA:  MOVLW  35
085BC:  MOVWF  x93
085BE:  MOVLW  56
085C0:  MOVWF  x94
085C2:  MOVLW  41
085C4:  MOVWF  x95
085C6:  CLRF   x96
085C8:  MOVLW  06
085CA:  MOVWF  x92
085CC:  MOVLW  93
085CE:  MOVWF  x91
....................    char *s_3V6X = "3V6X";
085D0:  MOVLW  33
085D2:  MOVWF  x99
085D4:  MOVLW  56
085D6:  MOVWF  x9A
085D8:  MOVLW  36
085DA:  MOVWF  x9B
085DC:  MOVLW  58
085DE:  MOVWF  x9C
085E0:  CLRF   x9D
085E2:  MOVLW  06
085E4:  MOVWF  x98
085E6:  MOVLW  99
085E8:  MOVWF  x97
....................    char *s_3V3A = "3V3A";
085EA:  MOVLW  33
085EC:  MOVWF  xA0
085EE:  MOVLW  56
085F0:  MOVWF  xA1
085F2:  MOVLW  33
085F4:  MOVWF  xA2
085F6:  MOVLW  41
085F8:  MOVWF  xA3
085FA:  CLRF   xA4
085FC:  MOVLW  06
085FE:  MOVWF  x9F
08600:  MOVLW  A0
08602:  MOVWF  x9E
....................    char *s_3V3D = "3V3D";
08604:  MOVLW  33
08606:  MOVWF  xA7
08608:  MOVLW  56
0860A:  MOVWF  xA8
0860C:  MOVLW  33
0860E:  MOVWF  xA9
08610:  MOVLW  44
08612:  MOVWF  xAA
08614:  CLRF   xAB
08616:  MOVLW  06
08618:  MOVWF  xA6
0861A:  MOVLW  A7
0861C:  MOVWF  xA5
....................    char *s_all = "all";
0861E:  MOVLW  61
08620:  MOVWF  xAE
08622:  MOVLW  6C
08624:  MOVWF  xAF
08626:  MOVWF  xB0
08628:  CLRF   xB1
0862A:  MOVLW  06
0862C:  MOVWF  xAD
0862E:  MOVLW  AE
08630:  MOVWF  xAC
....................    
....................    arg1 = SERcmd[rec].p[2];
08632:  CLRF   xB4
08634:  MOVFF  66B,6B3
08638:  CLRF   xB6
0863A:  MOVLW  B5
0863C:  MOVWF  xB5
0863E:  MOVLB  0
08640:  CALL   082A
08644:  MOVFF  02,6B3
08648:  MOVFF  01,6B2
0864C:  MOVLW  06
0864E:  MOVLB  6
08650:  ADDWF  xB2,F
08652:  MOVLW  00
08654:  ADDWFC xB3,F
08656:  MOVLW  32
08658:  ADDWF  xB2,W
0865A:  MOVWF  01
0865C:  MOVLW  00
0865E:  ADDWFC xB3,W
08660:  MOVWF  03
08662:  MOVF   01,W
08664:  ADDLW  D1
08666:  MOVWF  01
08668:  MOVLW  01
0866A:  ADDWFC 03,F
0866C:  MOVFF  01,67D
08670:  MOVFF  03,67E
....................    
....................    /*** GET MONITOR VALUES ************/
....................    if      (0 == strcmp(s_N15, arg1)) {
08674:  MOVFF  680,6B4
08678:  MOVFF  67F,6B3
0867C:  MOVFF  67E,6B6
08680:  MOVFF  67D,6B5
08684:  MOVLB  0
08686:  CALL   55A4
0868A:  MOVF   01,F
0868C:  BNZ   86E4
....................       sprintf(retData+strlen(retData), "%.2f,", monitorVals.vN15);
0868E:  MOVLW  04
08690:  MOVLB  6
08692:  MOVWF  xB4
08694:  MOVLW  A7
08696:  MOVWF  xB3
08698:  MOVLB  0
0869A:  CALL   556C
0869E:  MOVFF  02,03
086A2:  MOVF   01,W
086A4:  ADDLW  A7
086A6:  MOVLB  6
086A8:  MOVWF  xB2
086AA:  MOVLW  04
086AC:  ADDWFC 02,W
086AE:  MOVWF  xB3
086B0:  MOVFF  FE8,54B
086B4:  MOVFF  6B2,54A
086B8:  MOVLW  89
086BA:  MOVWF  FE9
086BC:  MOVFF  EE,6B8
086C0:  MOVFF  ED,6B7
086C4:  MOVFF  EC,6B6
086C8:  MOVFF  EB,6B5
086CC:  MOVLW  02
086CE:  MOVWF  xB9
086D0:  MOVLB  0
086D2:  CALL   641A
086D6:  MOVLW  2C
086D8:  MOVLB  6
086DA:  MOVWF  xC2
086DC:  MOVLB  0
086DE:  CALL   561C
....................    }
086E2:  BRA    8BE6
....................    else if (0 == strcmp(s_200, arg1)) {
086E4:  MOVFF  686,6B4
086E8:  MOVFF  685,6B3
086EC:  MOVFF  67E,6B6
086F0:  MOVFF  67D,6B5
086F4:  CALL   55A4
086F8:  MOVF   01,F
086FA:  BNZ   8752
....................       sprintf(retData+strlen(retData), "%.1f,", monitorVals.v200);
086FC:  MOVLW  04
086FE:  MOVLB  6
08700:  MOVWF  xB4
08702:  MOVLW  A7
08704:  MOVWF  xB3
08706:  MOVLB  0
08708:  CALL   556C
0870C:  MOVFF  02,03
08710:  MOVF   01,W
08712:  ADDLW  A7
08714:  MOVLB  6
08716:  MOVWF  xB2
08718:  MOVLW  04
0871A:  ADDWFC 02,W
0871C:  MOVWF  xB3
0871E:  MOVFF  FE8,54B
08722:  MOVFF  6B2,54A
08726:  MOVLW  89
08728:  MOVWF  FE9
0872A:  MOVFF  F2,6B8
0872E:  MOVFF  F1,6B7
08732:  MOVFF  F0,6B6
08736:  MOVFF  EF,6B5
0873A:  MOVLW  01
0873C:  MOVWF  xB9
0873E:  MOVLB  0
08740:  CALL   641A
08744:  MOVLW  2C
08746:  MOVLB  6
08748:  MOVWF  xC2
0874A:  MOVLB  0
0874C:  CALL   561C
....................    }
08750:  BRA    8BE6
....................    else if (0 == strcmp(s_5V6, arg1)) {
08752:  MOVFF  68C,6B4
08756:  MOVFF  68B,6B3
0875A:  MOVFF  67E,6B6
0875E:  MOVFF  67D,6B5
08762:  CALL   55A4
08766:  MOVF   01,F
08768:  BNZ   87C0
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5V6);
0876A:  MOVLW  04
0876C:  MOVLB  6
0876E:  MOVWF  xB4
08770:  MOVLW  A7
08772:  MOVWF  xB3
08774:  MOVLB  0
08776:  CALL   556C
0877A:  MOVFF  02,03
0877E:  MOVF   01,W
08780:  ADDLW  A7
08782:  MOVLB  6
08784:  MOVWF  xB2
08786:  MOVLW  04
08788:  ADDWFC 02,W
0878A:  MOVWF  xB3
0878C:  MOVFF  FE8,54B
08790:  MOVFF  6B2,54A
08794:  MOVLW  89
08796:  MOVWF  FE9
08798:  MOVFF  F6,6B8
0879C:  MOVFF  F5,6B7
087A0:  MOVFF  F4,6B6
087A4:  MOVFF  F3,6B5
087A8:  MOVLW  03
087AA:  MOVWF  xB9
087AC:  MOVLB  0
087AE:  CALL   641A
087B2:  MOVLW  2C
087B4:  MOVLB  6
087B6:  MOVWF  xC2
087B8:  MOVLB  0
087BA:  CALL   561C
....................    }
087BE:  BRA    8BE6
....................    else if (0 == strcmp(s_5VA, arg1)) {
087C0:  MOVFF  692,6B4
087C4:  MOVFF  691,6B3
087C8:  MOVFF  67E,6B6
087CC:  MOVFF  67D,6B5
087D0:  CALL   55A4
087D4:  MOVF   01,F
087D6:  BNZ   882E
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5VA);
087D8:  MOVLW  04
087DA:  MOVLB  6
087DC:  MOVWF  xB4
087DE:  MOVLW  A7
087E0:  MOVWF  xB3
087E2:  MOVLB  0
087E4:  CALL   556C
087E8:  MOVFF  02,03
087EC:  MOVF   01,W
087EE:  ADDLW  A7
087F0:  MOVLB  6
087F2:  MOVWF  xB2
087F4:  MOVLW  04
087F6:  ADDWFC 02,W
087F8:  MOVWF  xB3
087FA:  MOVFF  FE8,54B
087FE:  MOVFF  6B2,54A
08802:  MOVLW  89
08804:  MOVWF  FE9
08806:  MOVFF  FA,6B8
0880A:  MOVFF  F9,6B7
0880E:  MOVFF  F8,6B6
08812:  MOVFF  F7,6B5
08816:  MOVLW  03
08818:  MOVWF  xB9
0881A:  MOVLB  0
0881C:  CALL   641A
08820:  MOVLW  2C
08822:  MOVLB  6
08824:  MOVWF  xC2
08826:  MOVLB  0
08828:  CALL   561C
....................    }
0882C:  BRA    8BE6
....................    else if (0 == strcmp(s_3V6X, arg1)) {
0882E:  MOVFF  698,6B4
08832:  MOVFF  697,6B3
08836:  MOVFF  67E,6B6
0883A:  MOVFF  67D,6B5
0883E:  CALL   55A4
08842:  MOVF   01,F
08844:  BNZ   889C
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V6X);
08846:  MOVLW  04
08848:  MOVLB  6
0884A:  MOVWF  xB4
0884C:  MOVLW  A7
0884E:  MOVWF  xB3
08850:  MOVLB  0
08852:  CALL   556C
08856:  MOVFF  02,03
0885A:  MOVF   01,W
0885C:  ADDLW  A7
0885E:  MOVLB  6
08860:  MOVWF  xB2
08862:  MOVLW  04
08864:  ADDWFC 02,W
08866:  MOVWF  xB3
08868:  MOVFF  FE8,54B
0886C:  MOVFF  6B2,54A
08870:  MOVLW  89
08872:  MOVWF  FE9
08874:  MOVFF  FE,6B8
08878:  MOVFF  FD,6B7
0887C:  MOVFF  FC,6B6
08880:  MOVFF  FB,6B5
08884:  MOVLW  03
08886:  MOVWF  xB9
08888:  MOVLB  0
0888A:  CALL   641A
0888E:  MOVLW  2C
08890:  MOVLB  6
08892:  MOVWF  xC2
08894:  MOVLB  0
08896:  CALL   561C
....................    }
0889A:  BRA    8BE6
....................    else if (0 == strcmp(s_3V3A, arg1)) {
0889C:  MOVFF  69F,6B4
088A0:  MOVFF  69E,6B3
088A4:  MOVFF  67E,6B6
088A8:  MOVFF  67D,6B5
088AC:  CALL   55A4
088B0:  MOVF   01,F
088B2:  BNZ   890A
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3A);
088B4:  MOVLW  04
088B6:  MOVLB  6
088B8:  MOVWF  xB4
088BA:  MOVLW  A7
088BC:  MOVWF  xB3
088BE:  MOVLB  0
088C0:  CALL   556C
088C4:  MOVFF  02,03
088C8:  MOVF   01,W
088CA:  ADDLW  A7
088CC:  MOVLB  6
088CE:  MOVWF  xB2
088D0:  MOVLW  04
088D2:  ADDWFC 02,W
088D4:  MOVWF  xB3
088D6:  MOVFF  FE8,54B
088DA:  MOVFF  6B2,54A
088DE:  MOVLW  89
088E0:  MOVWF  FE9
088E2:  MOVFF  102,6B8
088E6:  MOVFF  101,6B7
088EA:  MOVFF  100,6B6
088EE:  MOVFF  FF,6B5
088F2:  MOVLW  03
088F4:  MOVWF  xB9
088F6:  MOVLB  0
088F8:  CALL   641A
088FC:  MOVLW  2C
088FE:  MOVLB  6
08900:  MOVWF  xC2
08902:  MOVLB  0
08904:  CALL   561C
....................    }
08908:  BRA    8BE6
....................    else if (0 == strcmp(s_3V3D, arg1)) {
0890A:  MOVFF  6A6,6B4
0890E:  MOVFF  6A5,6B3
08912:  MOVFF  67E,6B6
08916:  MOVFF  67D,6B5
0891A:  CALL   55A4
0891E:  MOVF   01,F
08920:  BNZ   8978
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3D);
08922:  MOVLW  04
08924:  MOVLB  6
08926:  MOVWF  xB4
08928:  MOVLW  A7
0892A:  MOVWF  xB3
0892C:  MOVLB  0
0892E:  CALL   556C
08932:  MOVFF  02,03
08936:  MOVF   01,W
08938:  ADDLW  A7
0893A:  MOVLB  6
0893C:  MOVWF  xB2
0893E:  MOVLW  04
08940:  ADDWFC 02,W
08942:  MOVWF  xB3
08944:  MOVFF  FE8,54B
08948:  MOVFF  6B2,54A
0894C:  MOVLW  89
0894E:  MOVWF  FE9
08950:  MOVFF  106,6B8
08954:  MOVFF  105,6B7
08958:  MOVFF  104,6B6
0895C:  MOVFF  103,6B5
08960:  MOVLW  03
08962:  MOVWF  xB9
08964:  MOVLB  0
08966:  CALL   641A
0896A:  MOVLW  2C
0896C:  MOVLB  6
0896E:  MOVWF  xC2
08970:  MOVLB  0
08972:  CALL   561C
....................    }
08976:  BRA    8BE6
....................    else if (0 == strcmp(s_all, arg1)) {
08978:  MOVFF  6AD,6B4
0897C:  MOVFF  6AC,6B3
08980:  MOVFF  67E,6B6
08984:  MOVFF  67D,6B5
08988:  CALL   55A4
0898C:  MOVF   01,F
0898E:  BTFSS  FD8.2
08990:  BRA    8BE0
....................       sprintf(retData+strlen(retData), "%.2f,", monitorVals.vN15);
08992:  MOVLW  04
08994:  MOVLB  6
08996:  MOVWF  xB4
08998:  MOVLW  A7
0899A:  MOVWF  xB3
0899C:  MOVLB  0
0899E:  CALL   556C
089A2:  MOVFF  02,03
089A6:  MOVF   01,W
089A8:  ADDLW  A7
089AA:  MOVLB  6
089AC:  MOVWF  xB2
089AE:  MOVLW  04
089B0:  ADDWFC 02,W
089B2:  MOVWF  xB3
089B4:  MOVFF  FE8,54B
089B8:  MOVFF  6B2,54A
089BC:  MOVLW  89
089BE:  MOVWF  FE9
089C0:  MOVFF  EE,6B8
089C4:  MOVFF  ED,6B7
089C8:  MOVFF  EC,6B6
089CC:  MOVFF  EB,6B5
089D0:  MOVLW  02
089D2:  MOVWF  xB9
089D4:  MOVLB  0
089D6:  CALL   641A
089DA:  MOVLW  2C
089DC:  MOVLB  6
089DE:  MOVWF  xC2
089E0:  MOVLB  0
089E2:  CALL   561C
....................       sprintf(retData+strlen(retData), "%.1f,", monitorVals.v200);
089E6:  MOVLW  04
089E8:  MOVLB  6
089EA:  MOVWF  xB4
089EC:  MOVLW  A7
089EE:  MOVWF  xB3
089F0:  MOVLB  0
089F2:  CALL   556C
089F6:  MOVFF  02,03
089FA:  MOVF   01,W
089FC:  ADDLW  A7
089FE:  MOVLB  6
08A00:  MOVWF  xB2
08A02:  MOVLW  04
08A04:  ADDWFC 02,W
08A06:  MOVWF  xB3
08A08:  MOVFF  FE8,54B
08A0C:  MOVFF  6B2,54A
08A10:  MOVLW  89
08A12:  MOVWF  FE9
08A14:  MOVFF  F2,6B8
08A18:  MOVFF  F1,6B7
08A1C:  MOVFF  F0,6B6
08A20:  MOVFF  EF,6B5
08A24:  MOVLW  01
08A26:  MOVWF  xB9
08A28:  MOVLB  0
08A2A:  CALL   641A
08A2E:  MOVLW  2C
08A30:  MOVLB  6
08A32:  MOVWF  xC2
08A34:  MOVLB  0
08A36:  CALL   561C
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5V6);
08A3A:  MOVLW  04
08A3C:  MOVLB  6
08A3E:  MOVWF  xB4
08A40:  MOVLW  A7
08A42:  MOVWF  xB3
08A44:  MOVLB  0
08A46:  CALL   556C
08A4A:  MOVFF  02,03
08A4E:  MOVF   01,W
08A50:  ADDLW  A7
08A52:  MOVLB  6
08A54:  MOVWF  xB2
08A56:  MOVLW  04
08A58:  ADDWFC 02,W
08A5A:  MOVWF  xB3
08A5C:  MOVFF  FE8,54B
08A60:  MOVFF  6B2,54A
08A64:  MOVLW  89
08A66:  MOVWF  FE9
08A68:  MOVFF  F6,6B8
08A6C:  MOVFF  F5,6B7
08A70:  MOVFF  F4,6B6
08A74:  MOVFF  F3,6B5
08A78:  MOVLW  03
08A7A:  MOVWF  xB9
08A7C:  MOVLB  0
08A7E:  CALL   641A
08A82:  MOVLW  2C
08A84:  MOVLB  6
08A86:  MOVWF  xC2
08A88:  MOVLB  0
08A8A:  CALL   561C
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5VA);
08A8E:  MOVLW  04
08A90:  MOVLB  6
08A92:  MOVWF  xB4
08A94:  MOVLW  A7
08A96:  MOVWF  xB3
08A98:  MOVLB  0
08A9A:  CALL   556C
08A9E:  MOVFF  02,03
08AA2:  MOVF   01,W
08AA4:  ADDLW  A7
08AA6:  MOVLB  6
08AA8:  MOVWF  xB2
08AAA:  MOVLW  04
08AAC:  ADDWFC 02,W
08AAE:  MOVWF  xB3
08AB0:  MOVFF  FE8,54B
08AB4:  MOVFF  6B2,54A
08AB8:  MOVLW  89
08ABA:  MOVWF  FE9
08ABC:  MOVFF  FA,6B8
08AC0:  MOVFF  F9,6B7
08AC4:  MOVFF  F8,6B6
08AC8:  MOVFF  F7,6B5
08ACC:  MOVLW  03
08ACE:  MOVWF  xB9
08AD0:  MOVLB  0
08AD2:  CALL   641A
08AD6:  MOVLW  2C
08AD8:  MOVLB  6
08ADA:  MOVWF  xC2
08ADC:  MOVLB  0
08ADE:  CALL   561C
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V6X);
08AE2:  MOVLW  04
08AE4:  MOVLB  6
08AE6:  MOVWF  xB4
08AE8:  MOVLW  A7
08AEA:  MOVWF  xB3
08AEC:  MOVLB  0
08AEE:  CALL   556C
08AF2:  MOVFF  02,03
08AF6:  MOVF   01,W
08AF8:  ADDLW  A7
08AFA:  MOVLB  6
08AFC:  MOVWF  xB2
08AFE:  MOVLW  04
08B00:  ADDWFC 02,W
08B02:  MOVWF  xB3
08B04:  MOVFF  FE8,54B
08B08:  MOVFF  6B2,54A
08B0C:  MOVLW  89
08B0E:  MOVWF  FE9
08B10:  MOVFF  FE,6B8
08B14:  MOVFF  FD,6B7
08B18:  MOVFF  FC,6B6
08B1C:  MOVFF  FB,6B5
08B20:  MOVLW  03
08B22:  MOVWF  xB9
08B24:  MOVLB  0
08B26:  CALL   641A
08B2A:  MOVLW  2C
08B2C:  MOVLB  6
08B2E:  MOVWF  xC2
08B30:  MOVLB  0
08B32:  CALL   561C
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3A);
08B36:  MOVLW  04
08B38:  MOVLB  6
08B3A:  MOVWF  xB4
08B3C:  MOVLW  A7
08B3E:  MOVWF  xB3
08B40:  MOVLB  0
08B42:  CALL   556C
08B46:  MOVFF  02,03
08B4A:  MOVF   01,W
08B4C:  ADDLW  A7
08B4E:  MOVLB  6
08B50:  MOVWF  xB2
08B52:  MOVLW  04
08B54:  ADDWFC 02,W
08B56:  MOVWF  xB3
08B58:  MOVFF  FE8,54B
08B5C:  MOVFF  6B2,54A
08B60:  MOVLW  89
08B62:  MOVWF  FE9
08B64:  MOVFF  102,6B8
08B68:  MOVFF  101,6B7
08B6C:  MOVFF  100,6B6
08B70:  MOVFF  FF,6B5
08B74:  MOVLW  03
08B76:  MOVWF  xB9
08B78:  MOVLB  0
08B7A:  CALL   641A
08B7E:  MOVLW  2C
08B80:  MOVLB  6
08B82:  MOVWF  xC2
08B84:  MOVLB  0
08B86:  CALL   561C
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3D);
08B8A:  MOVLW  04
08B8C:  MOVLB  6
08B8E:  MOVWF  xB4
08B90:  MOVLW  A7
08B92:  MOVWF  xB3
08B94:  MOVLB  0
08B96:  CALL   556C
08B9A:  MOVFF  02,03
08B9E:  MOVF   01,W
08BA0:  ADDLW  A7
08BA2:  MOVLB  6
08BA4:  MOVWF  xB2
08BA6:  MOVLW  04
08BA8:  ADDWFC 02,W
08BAA:  MOVWF  xB3
08BAC:  MOVFF  FE8,54B
08BB0:  MOVFF  6B2,54A
08BB4:  MOVLW  89
08BB6:  MOVWF  FE9
08BB8:  MOVFF  106,6B8
08BBC:  MOVFF  105,6B7
08BC0:  MOVFF  104,6B6
08BC4:  MOVFF  103,6B5
08BC8:  MOVLW  03
08BCA:  MOVWF  xB9
08BCC:  MOVLB  0
08BCE:  CALL   641A
08BD2:  MOVLW  2C
08BD4:  MOVLB  6
08BD6:  MOVWF  xC2
08BD8:  MOVLB  0
08BDA:  CALL   561C
....................    }
08BDE:  BRA    8BE6
....................    else return INV_PARAM;
08BE0:  MOVLW  02
08BE2:  MOVWF  01
08BE4:  BRA    8BEA
....................    
....................    return SUCCESS;
08BE6:  MOVLW  00
08BE8:  MOVWF  01
08BEA:  RETURN 0
.................... }
.................... 
.................... int8 getPIDdata(unsigned int8 rec){
....................   /*** ARG CHECKS ********************/ 
....................    int8 arg1;
....................    char *arg2;
....................    char *s_PV = "PV";
08BEC:  MOVLW  50
08BEE:  MOVLB  6
08BF0:  MOVWF  x82
08BF2:  MOVLW  56
08BF4:  MOVWF  x83
08BF6:  CLRF   x84
08BF8:  MOVLW  06
08BFA:  MOVWF  x81
08BFC:  MOVLW  82
08BFE:  MOVWF  x80
....................    char *s_CV = "CV";
08C00:  MOVLW  43
08C02:  MOVWF  x87
08C04:  MOVLW  56
08C06:  MOVWF  x88
08C08:  CLRF   x89
08C0A:  MOVLW  06
08C0C:  MOVWF  x86
08C0E:  MOVLW  87
08C10:  MOVWF  x85
....................    char *s_PVold = "PVold";
08C12:  MOVLW  50
08C14:  MOVWF  x8C
08C16:  MOVLW  56
08C18:  MOVWF  x8D
08C1A:  MOVLW  6F
08C1C:  MOVWF  x8E
08C1E:  MOVLW  6C
08C20:  MOVWF  x8F
08C22:  MOVLW  64
08C24:  MOVWF  x90
08C26:  CLRF   x91
08C28:  MOVLW  06
08C2A:  MOVWF  x8B
08C2C:  MOVLW  8C
08C2E:  MOVWF  x8A
....................    char *s_I = "I";
08C30:  MOVLW  49
08C32:  MOVWF  x94
08C34:  CLRF   x95
08C36:  MOVLW  06
08C38:  MOVWF  x93
08C3A:  MOVLW  94
08C3C:  MOVWF  x92
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
08C3E:  CLRF   xB4
08C40:  MOVFF  66B,6B3
08C44:  CLRF   xB6
08C46:  MOVLW  B5
08C48:  MOVWF  xB5
08C4A:  MOVLB  0
08C4C:  CALL   082A
08C50:  MOVFF  02,697
08C54:  MOVFF  01,696
08C58:  MOVLW  06
08C5A:  MOVLB  6
08C5C:  ADDWF  x96,F
08C5E:  MOVLW  00
08C60:  ADDWFC x97,F
08C62:  MOVLW  32
08C64:  ADDWF  x96,W
08C66:  MOVWF  01
08C68:  MOVLW  00
08C6A:  ADDWFC x97,W
08C6C:  MOVWF  03
08C6E:  MOVF   01,W
08C70:  ADDLW  D1
08C72:  MOVWF  01
08C74:  MOVLW  01
08C76:  ADDWFC 03,F
08C78:  MOVFF  01,696
08C7C:  MOVFF  03,697
08C80:  MOVFF  03,6A6
08C84:  MOVFF  01,6A5
08C88:  MOVLB  0
08C8A:  CALL   56E4
08C8E:  MOVF   01,F
08C90:  BNZ   8C9A
08C92:  MOVLW  02
08C94:  MOVWF  01
08C96:  BRA    9030
08C98:  BRA    8CF8
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
08C9A:  MOVLB  6
08C9C:  CLRF   xB4
08C9E:  MOVFF  66B,6B3
08CA2:  CLRF   xB6
08CA4:  MOVLW  B5
08CA6:  MOVWF  xB5
08CA8:  MOVLB  0
08CAA:  CALL   082A
08CAE:  MOVFF  02,697
08CB2:  MOVFF  01,696
08CB6:  MOVLW  06
08CB8:  MOVLB  6
08CBA:  ADDWF  x96,F
08CBC:  MOVLW  00
08CBE:  ADDWFC x97,F
08CC0:  MOVLW  32
08CC2:  ADDWF  x96,W
08CC4:  MOVWF  01
08CC6:  MOVLW  00
08CC8:  ADDWFC x97,W
08CCA:  MOVWF  03
08CCC:  MOVF   01,W
08CCE:  ADDLW  D1
08CD0:  MOVWF  01
08CD2:  MOVLW  01
08CD4:  ADDWFC 03,F
08CD6:  MOVFF  01,696
08CDA:  MOVFF  03,697
08CDE:  MOVFF  03,6A6
08CE2:  MOVFF  01,6A5
08CE6:  CLRF   xA8
08CE8:  CLRF   xA7
08CEA:  MOVLW  0A
08CEC:  MOVWF  xA9
08CEE:  MOVLB  0
08CF0:  CALL   57D4
08CF4:  MOVFF  01,67D
....................    
....................    arg2 = SERcmd[rec].p[3];
08CF8:  MOVLB  6
08CFA:  CLRF   xB4
08CFC:  MOVFF  66B,6B3
08D00:  CLRF   xB6
08D02:  MOVLW  B5
08D04:  MOVWF  xB5
08D06:  MOVLB  0
08D08:  CALL   082A
08D0C:  MOVFF  02,697
08D10:  MOVFF  01,696
08D14:  MOVLW  06
08D16:  MOVLB  6
08D18:  ADDWF  x96,F
08D1A:  MOVLW  00
08D1C:  ADDWFC x97,F
08D1E:  MOVLW  4B
08D20:  ADDWF  x96,W
08D22:  MOVWF  01
08D24:  MOVLW  00
08D26:  ADDWFC x97,W
08D28:  MOVWF  03
08D2A:  MOVF   01,W
08D2C:  ADDLW  D1
08D2E:  MOVWF  01
08D30:  MOVLW  01
08D32:  ADDWFC 03,F
08D34:  MOVFF  01,67E
08D38:  MOVFF  03,67F
....................    
....................    /*** GET PV, CV, PVold, I, or A(LL) VALUE **********/
....................    if      (0 == strcmp(s_PV, arg2))     sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].PV);
08D3C:  MOVFF  681,6B4
08D40:  MOVFF  680,6B3
08D44:  MOVFF  67F,6B6
08D48:  MOVFF  67E,6B5
08D4C:  MOVLB  0
08D4E:  CALL   55A4
08D52:  MOVF   01,F
08D54:  BNZ   8DF8
08D56:  MOVLW  04
08D58:  MOVLB  6
08D5A:  MOVWF  xB4
08D5C:  MOVLW  A7
08D5E:  MOVWF  xB3
08D60:  MOVLB  0
08D62:  CALL   556C
08D66:  MOVF   01,W
08D68:  ADDLW  A7
08D6A:  MOVLB  6
08D6C:  MOVWF  x96
08D6E:  MOVLW  04
08D70:  ADDWFC 02,W
08D72:  MOVWF  x97
08D74:  MOVLW  01
08D76:  SUBWF  x7D,W
08D78:  MULLW  20
08D7A:  MOVF   FF3,W
08D7C:  CLRF   x99
08D7E:  MOVWF  x98
08D80:  MOVLW  10
08D82:  ADDWF  x98,W
08D84:  MOVWF  01
08D86:  MOVLW  00
08D88:  ADDWFC x99,W
08D8A:  MOVWF  03
08D8C:  MOVF   01,W
08D8E:  ADDLW  20
08D90:  MOVWF  FE9
08D92:  MOVLW  00
08D94:  ADDWFC 03,W
08D96:  MOVWF  FEA
08D98:  MOVFF  FEF,698
08D9C:  MOVFF  FEC,699
08DA0:  MOVFF  FEC,69A
08DA4:  MOVFF  FEC,69B
08DA8:  MOVFF  697,54B
08DAC:  MOVFF  696,54A
08DB0:  MOVFF  67D,6A6
08DB4:  MOVLW  18
08DB6:  MOVWF  xA7
08DB8:  MOVLB  0
08DBA:  CALL   5B28
08DBE:  MOVLW  2C
08DC0:  MOVLB  6
08DC2:  MOVWF  xC2
08DC4:  MOVLB  0
08DC6:  CALL   561C
08DCA:  MOVLW  89
08DCC:  MOVWF  FE9
08DCE:  MOVFF  69B,6B8
08DD2:  MOVFF  69A,6B7
08DD6:  MOVFF  699,6B6
08DDA:  MOVFF  698,6B5
08DDE:  MOVLW  02
08DE0:  MOVLB  6
08DE2:  MOVWF  xB9
08DE4:  MOVLB  0
08DE6:  CALL   641A
08DEA:  MOVLW  2C
08DEC:  MOVLB  6
08DEE:  MOVWF  xC2
08DF0:  MOVLB  0
08DF2:  CALL   561C
08DF6:  BRA    902C
....................    else if (0 == strcmp(s_CV, arg2))     sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].CV);
08DF8:  MOVFF  686,6B4
08DFC:  MOVFF  685,6B3
08E00:  MOVFF  67F,6B6
08E04:  MOVFF  67E,6B5
08E08:  CALL   55A4
08E0C:  MOVF   01,F
08E0E:  BNZ   8EB2
08E10:  MOVLW  04
08E12:  MOVLB  6
08E14:  MOVWF  xB4
08E16:  MOVLW  A7
08E18:  MOVWF  xB3
08E1A:  MOVLB  0
08E1C:  CALL   556C
08E20:  MOVF   01,W
08E22:  ADDLW  A7
08E24:  MOVLB  6
08E26:  MOVWF  x96
08E28:  MOVLW  04
08E2A:  ADDWFC 02,W
08E2C:  MOVWF  x97
08E2E:  MOVLW  01
08E30:  SUBWF  x7D,W
08E32:  MULLW  20
08E34:  MOVF   FF3,W
08E36:  CLRF   x99
08E38:  MOVWF  x98
08E3A:  MOVLW  18
08E3C:  ADDWF  x98,W
08E3E:  MOVWF  01
08E40:  MOVLW  00
08E42:  ADDWFC x99,W
08E44:  MOVWF  03
08E46:  MOVF   01,W
08E48:  ADDLW  20
08E4A:  MOVWF  FE9
08E4C:  MOVLW  00
08E4E:  ADDWFC 03,W
08E50:  MOVWF  FEA
08E52:  MOVFF  FEF,698
08E56:  MOVFF  FEC,699
08E5A:  MOVFF  FEC,69A
08E5E:  MOVFF  FEC,69B
08E62:  MOVFF  697,54B
08E66:  MOVFF  696,54A
08E6A:  MOVFF  67D,6A6
08E6E:  MOVLW  18
08E70:  MOVWF  xA7
08E72:  MOVLB  0
08E74:  CALL   5B28
08E78:  MOVLW  2C
08E7A:  MOVLB  6
08E7C:  MOVWF  xC2
08E7E:  MOVLB  0
08E80:  CALL   561C
08E84:  MOVLW  89
08E86:  MOVWF  FE9
08E88:  MOVFF  69B,6B8
08E8C:  MOVFF  69A,6B7
08E90:  MOVFF  699,6B6
08E94:  MOVFF  698,6B5
08E98:  MOVLW  02
08E9A:  MOVLB  6
08E9C:  MOVWF  xB9
08E9E:  MOVLB  0
08EA0:  CALL   641A
08EA4:  MOVLW  2C
08EA6:  MOVLB  6
08EA8:  MOVWF  xC2
08EAA:  MOVLB  0
08EAC:  CALL   561C
08EB0:  BRA    902C
....................    else if (0 == strcmp(s_PVold, arg2))  sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].PVold);
08EB2:  MOVFF  68B,6B4
08EB6:  MOVFF  68A,6B3
08EBA:  MOVFF  67F,6B6
08EBE:  MOVFF  67E,6B5
08EC2:  CALL   55A4
08EC6:  MOVF   01,F
08EC8:  BNZ   8F6C
08ECA:  MOVLW  04
08ECC:  MOVLB  6
08ECE:  MOVWF  xB4
08ED0:  MOVLW  A7
08ED2:  MOVWF  xB3
08ED4:  MOVLB  0
08ED6:  CALL   556C
08EDA:  MOVF   01,W
08EDC:  ADDLW  A7
08EDE:  MOVLB  6
08EE0:  MOVWF  x96
08EE2:  MOVLW  04
08EE4:  ADDWFC 02,W
08EE6:  MOVWF  x97
08EE8:  MOVLW  01
08EEA:  SUBWF  x7D,W
08EEC:  MULLW  20
08EEE:  MOVF   FF3,W
08EF0:  CLRF   x99
08EF2:  MOVWF  x98
08EF4:  MOVLW  14
08EF6:  ADDWF  x98,W
08EF8:  MOVWF  01
08EFA:  MOVLW  00
08EFC:  ADDWFC x99,W
08EFE:  MOVWF  03
08F00:  MOVF   01,W
08F02:  ADDLW  20
08F04:  MOVWF  FE9
08F06:  MOVLW  00
08F08:  ADDWFC 03,W
08F0A:  MOVWF  FEA
08F0C:  MOVFF  FEF,698
08F10:  MOVFF  FEC,699
08F14:  MOVFF  FEC,69A
08F18:  MOVFF  FEC,69B
08F1C:  MOVFF  697,54B
08F20:  MOVFF  696,54A
08F24:  MOVFF  67D,6A6
08F28:  MOVLW  18
08F2A:  MOVWF  xA7
08F2C:  MOVLB  0
08F2E:  CALL   5B28
08F32:  MOVLW  2C
08F34:  MOVLB  6
08F36:  MOVWF  xC2
08F38:  MOVLB  0
08F3A:  CALL   561C
08F3E:  MOVLW  89
08F40:  MOVWF  FE9
08F42:  MOVFF  69B,6B8
08F46:  MOVFF  69A,6B7
08F4A:  MOVFF  699,6B6
08F4E:  MOVFF  698,6B5
08F52:  MOVLW  02
08F54:  MOVLB  6
08F56:  MOVWF  xB9
08F58:  MOVLB  0
08F5A:  CALL   641A
08F5E:  MOVLW  2C
08F60:  MOVLB  6
08F62:  MOVWF  xC2
08F64:  MOVLB  0
08F66:  CALL   561C
08F6A:  BRA    902C
....................    else if (0 == strcmp(s_I, arg2))      sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].I);
08F6C:  MOVFF  693,6B4
08F70:  MOVFF  692,6B3
08F74:  MOVFF  67F,6B6
08F78:  MOVFF  67E,6B5
08F7C:  CALL   55A4
08F80:  MOVF   01,F
08F82:  BNZ   9026
08F84:  MOVLW  04
08F86:  MOVLB  6
08F88:  MOVWF  xB4
08F8A:  MOVLW  A7
08F8C:  MOVWF  xB3
08F8E:  MOVLB  0
08F90:  CALL   556C
08F94:  MOVF   01,W
08F96:  ADDLW  A7
08F98:  MOVLB  6
08F9A:  MOVWF  x96
08F9C:  MOVLW  04
08F9E:  ADDWFC 02,W
08FA0:  MOVWF  x97
08FA2:  MOVLW  01
08FA4:  SUBWF  x7D,W
08FA6:  MULLW  20
08FA8:  MOVF   FF3,W
08FAA:  CLRF   x99
08FAC:  MOVWF  x98
08FAE:  MOVLW  1C
08FB0:  ADDWF  x98,W
08FB2:  MOVWF  01
08FB4:  MOVLW  00
08FB6:  ADDWFC x99,W
08FB8:  MOVWF  03
08FBA:  MOVF   01,W
08FBC:  ADDLW  20
08FBE:  MOVWF  FE9
08FC0:  MOVLW  00
08FC2:  ADDWFC 03,W
08FC4:  MOVWF  FEA
08FC6:  MOVFF  FEF,698
08FCA:  MOVFF  FEC,699
08FCE:  MOVFF  FEC,69A
08FD2:  MOVFF  FEC,69B
08FD6:  MOVFF  697,54B
08FDA:  MOVFF  696,54A
08FDE:  MOVFF  67D,6A6
08FE2:  MOVLW  18
08FE4:  MOVWF  xA7
08FE6:  MOVLB  0
08FE8:  CALL   5B28
08FEC:  MOVLW  2C
08FEE:  MOVLB  6
08FF0:  MOVWF  xC2
08FF2:  MOVLB  0
08FF4:  CALL   561C
08FF8:  MOVLW  89
08FFA:  MOVWF  FE9
08FFC:  MOVFF  69B,6B8
09000:  MOVFF  69A,6B7
09004:  MOVFF  699,6B6
09008:  MOVFF  698,6B5
0900C:  MOVLW  02
0900E:  MOVLB  6
09010:  MOVWF  xB9
09012:  MOVLB  0
09014:  CALL   641A
09018:  MOVLW  2C
0901A:  MOVLB  6
0901C:  MOVWF  xC2
0901E:  MOVLB  0
09020:  CALL   561C
09024:  BRA    902C
....................    else return INV_PARAM;
09026:  MOVLW  02
09028:  MOVWF  01
0902A:  BRA    9030
....................    
....................    return SUCCESS;
0902C:  MOVLW  00
0902E:  MOVWF  01
09030:  RETURN 0
.................... }
.................... 
.................... int8 getIPdata(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char *arg2;
....................    char *s_raw = "raw";
*
09150:  MOVLW  72
09152:  MOVLB  6
09154:  MOVWF  x82
09156:  MOVLW  61
09158:  MOVWF  x83
0915A:  MOVLW  77
0915C:  MOVWF  x84
0915E:  CLRF   x85
09160:  MOVLW  06
09162:  MOVWF  x81
09164:  MOVLW  82
09166:  MOVWF  x80
....................    char *s_calibrated = "calib";
09168:  MOVLW  63
0916A:  MOVWF  x88
0916C:  MOVLW  61
0916E:  MOVWF  x89
09170:  MOVLW  6C
09172:  MOVWF  x8A
09174:  MOVLW  69
09176:  MOVWF  x8B
09178:  MOVLW  62
0917A:  MOVWF  x8C
0917C:  CLRF   x8D
0917E:  MOVLW  06
09180:  MOVWF  x87
09182:  MOVLW  88
09184:  MOVWF  x86
....................    char *s_p0 = "p0";
09186:  MOVLW  70
09188:  MOVWF  x90
0918A:  MOVLW  30
0918C:  MOVWF  x91
0918E:  CLRF   x92
09190:  MOVLW  06
09192:  MOVWF  x8F
09194:  MOVLW  90
09196:  MOVWF  x8E
....................    char *s_poles = "poles";
09198:  MOVLW  70
0919A:  MOVWF  x95
0919C:  MOVLW  6F
0919E:  MOVWF  x96
091A0:  MOVLW  6C
091A2:  MOVWF  x97
091A4:  MOVLW  65
091A6:  MOVWF  x98
091A8:  MOVLW  73
091AA:  MOVWF  x99
091AC:  CLRF   x9A
091AE:  MOVLW  06
091B0:  MOVWF  x94
091B2:  MOVLW  95
091B4:  MOVWF  x93
....................    char *s_real = "real";
091B6:  MOVLW  72
091B8:  MOVWF  x9D
091BA:  MOVLW  65
091BC:  MOVWF  x9E
091BE:  MOVLW  61
091C0:  MOVWF  x9F
091C2:  MOVLW  6C
091C4:  MOVWF  xA0
091C6:  CLRF   xA1
091C8:  MOVLW  06
091CA:  MOVWF  x9C
091CC:  MOVLW  9D
091CE:  MOVWF  x9B
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
091D0:  CLRF   xB4
091D2:  MOVFF  66B,6B3
091D6:  CLRF   xB6
091D8:  MOVLW  B5
091DA:  MOVWF  xB5
091DC:  MOVLB  0
091DE:  CALL   082A
091E2:  MOVFF  02,6A3
091E6:  MOVFF  01,6A2
091EA:  MOVLW  06
091EC:  MOVLB  6
091EE:  ADDWF  xA2,F
091F0:  MOVLW  00
091F2:  ADDWFC xA3,F
091F4:  MOVLW  32
091F6:  ADDWF  xA2,W
091F8:  MOVWF  01
091FA:  MOVLW  00
091FC:  ADDWFC xA3,W
091FE:  MOVWF  03
09200:  MOVF   01,W
09202:  ADDLW  D1
09204:  MOVWF  01
09206:  MOVLW  01
09208:  ADDWFC 03,F
0920A:  MOVFF  01,6A2
0920E:  MOVFF  03,6A3
09212:  MOVFF  03,6A6
09216:  MOVFF  01,6A5
0921A:  MOVLB  0
0921C:  CALL   56E4
09220:  MOVF   01,F
09222:  BNZ   922C
09224:  MOVLW  02
09226:  MOVWF  01
09228:  BRA    9870
0922A:  BRA    928A
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
0922C:  MOVLB  6
0922E:  CLRF   xB4
09230:  MOVFF  66B,6B3
09234:  CLRF   xB6
09236:  MOVLW  B5
09238:  MOVWF  xB5
0923A:  MOVLB  0
0923C:  CALL   082A
09240:  MOVFF  02,6A3
09244:  MOVFF  01,6A2
09248:  MOVLW  06
0924A:  MOVLB  6
0924C:  ADDWF  xA2,F
0924E:  MOVLW  00
09250:  ADDWFC xA3,F
09252:  MOVLW  32
09254:  ADDWF  xA2,W
09256:  MOVWF  01
09258:  MOVLW  00
0925A:  ADDWFC xA3,W
0925C:  MOVWF  03
0925E:  MOVF   01,W
09260:  ADDLW  D1
09262:  MOVWF  01
09264:  MOVLW  01
09266:  ADDWFC 03,F
09268:  MOVFF  01,6A2
0926C:  MOVFF  03,6A3
09270:  MOVFF  03,6A6
09274:  MOVFF  01,6A5
09278:  CLRF   xA8
0927A:  CLRF   xA7
0927C:  MOVLW  0A
0927E:  MOVWF  xA9
09280:  MOVLB  0
09282:  CALL   57D4
09286:  MOVFF  01,67D
....................    
....................    arg2 = SERcmd[rec].p[3];
0928A:  MOVLB  6
0928C:  CLRF   xB4
0928E:  MOVFF  66B,6B3
09292:  CLRF   xB6
09294:  MOVLW  B5
09296:  MOVWF  xB5
09298:  MOVLB  0
0929A:  CALL   082A
0929E:  MOVFF  02,6A3
092A2:  MOVFF  01,6A2
092A6:  MOVLW  06
092A8:  MOVLB  6
092AA:  ADDWF  xA2,F
092AC:  MOVLW  00
092AE:  ADDWFC xA3,F
092B0:  MOVLW  4B
092B2:  ADDWF  xA2,W
092B4:  MOVWF  01
092B6:  MOVLW  00
092B8:  ADDWFC xA3,W
092BA:  MOVWF  03
092BC:  MOVF   01,W
092BE:  ADDLW  D1
092C0:  MOVWF  01
092C2:  MOVLW  01
092C4:  ADDWFC 03,F
092C6:  MOVFF  01,67E
092CA:  MOVFF  03,67F
....................    
....................    /*** GET INPUT DATA ****************/
....................    if      (0 == strcmp(s_raw, arg2)) {
092CE:  MOVFF  681,6B4
092D2:  MOVFF  680,6B3
092D6:  MOVFF  67F,6B6
092DA:  MOVFF  67E,6B5
092DE:  MOVLB  0
092E0:  CALL   55A4
092E4:  MOVF   01,F
092E6:  BTFSS  FD8.2
092E8:  BRA    9464
....................       sprintf(retData+strlen(retData), "%d,", arg1);
092EA:  MOVLW  04
092EC:  MOVLB  6
092EE:  MOVWF  xB4
092F0:  MOVLW  A7
092F2:  MOVWF  xB3
092F4:  MOVLB  0
092F6:  CALL   556C
092FA:  MOVFF  02,03
092FE:  MOVF   01,W
09300:  ADDLW  A7
09302:  MOVLB  6
09304:  MOVWF  xA2
09306:  MOVLW  04
09308:  ADDWFC 02,W
0930A:  MOVWF  xA3
0930C:  MOVFF  FE8,54B
09310:  MOVFF  6A2,54A
09314:  MOVFF  67D,6A6
09318:  MOVLW  18
0931A:  MOVWF  xA7
0931C:  MOVLB  0
0931E:  CALL   5B28
09322:  MOVLW  2C
09324:  MOVLB  6
09326:  MOVWF  xC2
09328:  MOVLB  0
0932A:  CALL   561C
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].sinRaw);
0932E:  MOVLW  04
09330:  MOVLB  6
09332:  MOVWF  xB4
09334:  MOVLW  A7
09336:  MOVWF  xB3
09338:  MOVLB  0
0933A:  CALL   556C
0933E:  MOVFF  02,03
09342:  MOVF   01,W
09344:  ADDLW  A7
09346:  MOVLB  6
09348:  MOVWF  xA2
0934A:  MOVLW  04
0934C:  ADDWFC 02,W
0934E:  MOVWF  xA3
09350:  MOVLW  01
09352:  SUBWF  x7D,W
09354:  MULLW  21
09356:  MOVF   FF3,W
09358:  CLRF   xA5
0935A:  MOVWF  xA4
0935C:  MOVLW  07
0935E:  ADDWF  xA4,W
09360:  MOVWF  FE9
09362:  MOVLW  01
09364:  ADDWFC xA5,W
09366:  MOVWF  FEA
09368:  MOVFF  FEF,6C2
0936C:  MOVFF  FEC,01
09370:  MOVFF  FEC,02
09374:  MOVFF  FEC,03
09378:  MOVFF  03,6C5
0937C:  MOVFF  02,6C4
09380:  MOVFF  01,6C3
09384:  MOVLB  0
09386:  CALL   6344
0938A:  MOVFF  03,6A9
0938E:  MOVFF  02,6A8
09392:  MOVFF  01,6A7
09396:  MOVFF  00,6A6
0939A:  MOVFF  6A3,54B
0939E:  MOVFF  6A2,54A
093A2:  MOVLW  41
093A4:  MOVWF  FE9
093A6:  MOVFF  03,6AE
093AA:  MOVFF  02,6AD
093AE:  MOVFF  01,6AC
093B2:  MOVFF  00,6AB
093B6:  RCALL  9032
093B8:  MOVLW  2C
093BA:  MOVLB  6
093BC:  MOVWF  xC2
093BE:  MOVLB  0
093C0:  CALL   561C
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].cosRaw);
093C4:  MOVLW  04
093C6:  MOVLB  6
093C8:  MOVWF  xB4
093CA:  MOVLW  A7
093CC:  MOVWF  xB3
093CE:  MOVLB  0
093D0:  CALL   556C
093D4:  MOVF   01,W
093D6:  ADDLW  A7
093D8:  MOVLB  6
093DA:  MOVWF  xA2
093DC:  MOVLW  04
093DE:  ADDWFC 02,W
093E0:  MOVWF  xA3
093E2:  MOVLW  01
093E4:  SUBWF  x7D,W
093E6:  MULLW  21
093E8:  MOVF   FF3,W
093EA:  CLRF   xA5
093EC:  MOVWF  xA4
093EE:  MOVLW  04
093F0:  ADDWF  xA4,W
093F2:  MOVWF  01
093F4:  MOVLW  00
093F6:  ADDWFC xA5,W
093F8:  MOVWF  03
093FA:  MOVF   01,W
093FC:  ADDLW  07
093FE:  MOVWF  FE9
09400:  MOVLW  01
09402:  ADDWFC 03,W
09404:  MOVWF  FEA
09406:  MOVFF  FEF,6C2
0940A:  MOVFF  FEC,01
0940E:  MOVFF  FEC,02
09412:  MOVFF  FEC,03
09416:  MOVFF  03,6C5
0941A:  MOVFF  02,6C4
0941E:  MOVFF  01,6C3
09422:  MOVLB  0
09424:  CALL   6344
09428:  MOVFF  03,6A7
0942C:  MOVFF  02,6A6
09430:  MOVFF  01,6A5
09434:  MOVFF  00,6A4
09438:  MOVFF  6A3,54B
0943C:  MOVFF  6A2,54A
09440:  MOVLW  41
09442:  MOVWF  FE9
09444:  MOVFF  03,6AE
09448:  MOVFF  02,6AD
0944C:  MOVFF  01,6AC
09450:  MOVFF  00,6AB
09454:  RCALL  9032
09456:  MOVLW  2C
09458:  MOVLB  6
0945A:  MOVWF  xC2
0945C:  MOVLB  0
0945E:  CALL   561C
....................    }
09462:  BRA    986C
....................    else if (0 == strcmp(s_calibrated, arg2)) {
09464:  MOVFF  687,6B4
09468:  MOVFF  686,6B3
0946C:  MOVFF  67F,6B6
09470:  MOVFF  67E,6B5
09474:  CALL   55A4
09478:  MOVF   01,F
0947A:  BTFSS  FD8.2
0947C:  BRA    9600
....................       sprintf(retData+strlen(retData), "%d,", arg1);
0947E:  MOVLW  04
09480:  MOVLB  6
09482:  MOVWF  xB4
09484:  MOVLW  A7
09486:  MOVWF  xB3
09488:  MOVLB  0
0948A:  CALL   556C
0948E:  MOVFF  02,03
09492:  MOVF   01,W
09494:  ADDLW  A7
09496:  MOVLB  6
09498:  MOVWF  xA2
0949A:  MOVLW  04
0949C:  ADDWFC 02,W
0949E:  MOVWF  xA3
094A0:  MOVFF  FE8,54B
094A4:  MOVFF  6A2,54A
094A8:  MOVFF  67D,6A6
094AC:  MOVLW  18
094AE:  MOVWF  xA7
094B0:  MOVLB  0
094B2:  CALL   5B28
094B6:  MOVLW  2C
094B8:  MOVLB  6
094BA:  MOVWF  xC2
094BC:  MOVLB  0
094BE:  CALL   561C
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].sinCounts);
094C2:  MOVLW  04
094C4:  MOVLB  6
094C6:  MOVWF  xB4
094C8:  MOVLW  A7
094CA:  MOVWF  xB3
094CC:  MOVLB  0
094CE:  CALL   556C
094D2:  MOVF   01,W
094D4:  ADDLW  A7
094D6:  MOVLB  6
094D8:  MOVWF  xA2
094DA:  MOVLW  04
094DC:  ADDWFC 02,W
094DE:  MOVWF  xA3
094E0:  MOVLW  01
094E2:  SUBWF  x7D,W
094E4:  MULLW  21
094E6:  MOVF   FF3,W
094E8:  CLRF   xA5
094EA:  MOVWF  xA4
094EC:  MOVLW  08
094EE:  ADDWF  xA4,W
094F0:  MOVWF  01
094F2:  MOVLW  00
094F4:  ADDWFC xA5,W
094F6:  MOVWF  03
094F8:  MOVF   01,W
094FA:  ADDLW  07
094FC:  MOVWF  FE9
094FE:  MOVLW  01
09500:  ADDWFC 03,W
09502:  MOVWF  FEA
09504:  MOVFF  FEF,6C2
09508:  MOVFF  FEC,01
0950C:  MOVFF  FEC,02
09510:  MOVFF  FEC,03
09514:  MOVFF  03,6C5
09518:  MOVFF  02,6C4
0951C:  MOVFF  01,6C3
09520:  MOVLB  0
09522:  CALL   6344
09526:  MOVFF  03,6A7
0952A:  MOVFF  02,6A6
0952E:  MOVFF  01,6A5
09532:  MOVFF  00,6A4
09536:  MOVFF  6A3,54B
0953A:  MOVFF  6A2,54A
0953E:  MOVLW  41
09540:  MOVWF  FE9
09542:  MOVFF  03,6AE
09546:  MOVFF  02,6AD
0954A:  MOVFF  01,6AC
0954E:  MOVFF  00,6AB
09552:  RCALL  9032
09554:  MOVLW  2C
09556:  MOVLB  6
09558:  MOVWF  xC2
0955A:  MOVLB  0
0955C:  CALL   561C
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].cosCounts);
09560:  MOVLW  04
09562:  MOVLB  6
09564:  MOVWF  xB4
09566:  MOVLW  A7
09568:  MOVWF  xB3
0956A:  MOVLB  0
0956C:  CALL   556C
09570:  MOVF   01,W
09572:  ADDLW  A7
09574:  MOVLB  6
09576:  MOVWF  xA2
09578:  MOVLW  04
0957A:  ADDWFC 02,W
0957C:  MOVWF  xA3
0957E:  MOVLW  01
09580:  SUBWF  x7D,W
09582:  MULLW  21
09584:  MOVF   FF3,W
09586:  CLRF   xA5
09588:  MOVWF  xA4
0958A:  MOVLW  0C
0958C:  ADDWF  xA4,W
0958E:  MOVWF  01
09590:  MOVLW  00
09592:  ADDWFC xA5,W
09594:  MOVWF  03
09596:  MOVF   01,W
09598:  ADDLW  07
0959A:  MOVWF  FE9
0959C:  MOVLW  01
0959E:  ADDWFC 03,W
095A0:  MOVWF  FEA
095A2:  MOVFF  FEF,6C2
095A6:  MOVFF  FEC,01
095AA:  MOVFF  FEC,02
095AE:  MOVFF  FEC,03
095B2:  MOVFF  03,6C5
095B6:  MOVFF  02,6C4
095BA:  MOVFF  01,6C3
095BE:  MOVLB  0
095C0:  CALL   6344
095C4:  MOVFF  03,6A7
095C8:  MOVFF  02,6A6
095CC:  MOVFF  01,6A5
095D0:  MOVFF  00,6A4
095D4:  MOVFF  6A3,54B
095D8:  MOVFF  6A2,54A
095DC:  MOVLW  41
095DE:  MOVWF  FE9
095E0:  MOVFF  03,6AE
095E4:  MOVFF  02,6AD
095E8:  MOVFF  01,6AC
095EC:  MOVFF  00,6AB
095F0:  RCALL  9032
095F2:  MOVLW  2C
095F4:  MOVLB  6
095F6:  MOVWF  xC2
095F8:  MOVLB  0
095FA:  CALL   561C
....................    }
095FE:  BRA    986C
....................    else if (0 == strcmp(s_p0, arg2)) {
09600:  MOVFF  68F,6B4
09604:  MOVFF  68E,6B3
09608:  MOVFF  67F,6B6
0960C:  MOVFF  67E,6B5
09610:  CALL   55A4
09614:  MOVF   01,F
09616:  BNZ   96D2
....................       sprintf(retData+strlen(retData), "%d,", arg1);
09618:  MOVLW  04
0961A:  MOVLB  6
0961C:  MOVWF  xB4
0961E:  MOVLW  A7
09620:  MOVWF  xB3
09622:  MOVLB  0
09624:  CALL   556C
09628:  MOVFF  02,03
0962C:  MOVF   01,W
0962E:  ADDLW  A7
09630:  MOVLB  6
09632:  MOVWF  xA2
09634:  MOVLW  04
09636:  ADDWFC 02,W
09638:  MOVWF  xA3
0963A:  MOVFF  FE8,54B
0963E:  MOVFF  6A2,54A
09642:  MOVFF  67D,6A6
09646:  MOVLW  18
09648:  MOVWF  xA7
0964A:  MOVLB  0
0964C:  CALL   5B28
09650:  MOVLW  2C
09652:  MOVLB  6
09654:  MOVWF  xC2
09656:  MOVLB  0
09658:  CALL   561C
....................       sprintf(retData+strlen(retData), "%f,", adcVals[arg1-1].p0);
0965C:  MOVLW  04
0965E:  MOVLB  6
09660:  MOVWF  xB4
09662:  MOVLW  A7
09664:  MOVWF  xB3
09666:  MOVLB  0
09668:  CALL   556C
0966C:  MOVF   01,W
0966E:  ADDLW  A7
09670:  MOVLB  6
09672:  MOVWF  xA2
09674:  MOVLW  04
09676:  ADDWFC 02,W
09678:  MOVWF  xA3
0967A:  MOVLW  01
0967C:  SUBWF  x7D,W
0967E:  MULLW  21
09680:  MOVF   FF3,W
09682:  CLRF   xA5
09684:  MOVWF  xA4
09686:  MOVLW  18
09688:  ADDWF  xA4,W
0968A:  MOVWF  01
0968C:  MOVLW  00
0968E:  ADDWFC xA5,W
09690:  MOVWF  03
09692:  MOVF   01,W
09694:  ADDLW  07
09696:  MOVWF  FE9
09698:  MOVLW  01
0969A:  ADDWFC 03,W
0969C:  MOVWF  FEA
0969E:  MOVFF  FEF,6B5
096A2:  MOVFF  FEC,6B6
096A6:  MOVFF  FEC,6B7
096AA:  MOVFF  FEC,6B8
096AE:  MOVFF  6A3,54B
096B2:  MOVFF  6A2,54A
096B6:  MOVLW  89
096B8:  MOVWF  FE9
096BA:  MOVLW  02
096BC:  MOVWF  xB9
096BE:  MOVLB  0
096C0:  CALL   641A
096C4:  MOVLW  2C
096C6:  MOVLB  6
096C8:  MOVWF  xC2
096CA:  MOVLB  0
096CC:  CALL   561C
....................    }
096D0:  BRA    986C
....................    else if (0 == strcmp(s_poles, arg2)) {
096D2:  MOVFF  694,6B4
096D6:  MOVFF  693,6B3
096DA:  MOVFF  67F,6B6
096DE:  MOVFF  67E,6B5
096E2:  CALL   55A4
096E6:  MOVF   01,F
096E8:  BNZ   9794
....................       sprintf(retData+strlen(retData), "%d,", arg1);
096EA:  MOVLW  04
096EC:  MOVLB  6
096EE:  MOVWF  xB4
096F0:  MOVLW  A7
096F2:  MOVWF  xB3
096F4:  MOVLB  0
096F6:  CALL   556C
096FA:  MOVFF  02,03
096FE:  MOVF   01,W
09700:  ADDLW  A7
09702:  MOVLB  6
09704:  MOVWF  xA2
09706:  MOVLW  04
09708:  ADDWFC 02,W
0970A:  MOVWF  xA3
0970C:  MOVFF  FE8,54B
09710:  MOVFF  6A2,54A
09714:  MOVFF  67D,6A6
09718:  MOVLW  18
0971A:  MOVWF  xA7
0971C:  MOVLB  0
0971E:  CALL   5B28
09722:  MOVLW  2C
09724:  MOVLB  6
09726:  MOVWF  xC2
09728:  MOVLB  0
0972A:  CALL   561C
....................       sprintf(retData+strlen(retData), "%d,", adcVals[arg1-1].npoles);
0972E:  MOVLW  04
09730:  MOVLB  6
09732:  MOVWF  xB4
09734:  MOVLW  A7
09736:  MOVWF  xB3
09738:  MOVLB  0
0973A:  CALL   556C
0973E:  MOVF   01,W
09740:  ADDLW  A7
09742:  MOVLB  6
09744:  MOVWF  xA2
09746:  MOVLW  04
09748:  ADDWFC 02,W
0974A:  MOVWF  xA3
0974C:  MOVLW  01
0974E:  SUBWF  x7D,W
09750:  MULLW  21
09752:  MOVF   FF3,W
09754:  CLRF   xA5
09756:  MOVWF  xA4
09758:  MOVLW  1C
0975A:  ADDWF  xA4,W
0975C:  MOVWF  01
0975E:  MOVLW  00
09760:  ADDWFC xA5,W
09762:  MOVWF  03
09764:  MOVF   01,W
09766:  ADDLW  07
09768:  MOVWF  FE9
0976A:  MOVLW  01
0976C:  ADDWFC 03,W
0976E:  MOVWF  FEA
09770:  MOVFF  FEF,6A6
09774:  MOVFF  6A3,54B
09778:  MOVFF  6A2,54A
0977C:  MOVLW  18
0977E:  MOVWF  xA7
09780:  MOVLB  0
09782:  CALL   5B28
09786:  MOVLW  2C
09788:  MOVLB  6
0978A:  MOVWF  xC2
0978C:  MOVLB  0
0978E:  CALL   561C
....................    }
09792:  BRA    986C
....................    else if (0 == strcmp(s_real, arg2)) {
09794:  MOVFF  69C,6B4
09798:  MOVFF  69B,6B3
0979C:  MOVFF  67F,6B6
097A0:  MOVFF  67E,6B5
097A4:  CALL   55A4
097A8:  MOVF   01,F
097AA:  BNZ   9866
....................       sprintf(retData+strlen(retData), "%d,", arg1);
097AC:  MOVLW  04
097AE:  MOVLB  6
097B0:  MOVWF  xB4
097B2:  MOVLW  A7
097B4:  MOVWF  xB3
097B6:  MOVLB  0
097B8:  CALL   556C
097BC:  MOVFF  02,03
097C0:  MOVF   01,W
097C2:  ADDLW  A7
097C4:  MOVLB  6
097C6:  MOVWF  xA2
097C8:  MOVLW  04
097CA:  ADDWFC 02,W
097CC:  MOVWF  xA3
097CE:  MOVFF  FE8,54B
097D2:  MOVFF  6A2,54A
097D6:  MOVFF  67D,6A6
097DA:  MOVLW  18
097DC:  MOVWF  xA7
097DE:  MOVLB  0
097E0:  CALL   5B28
097E4:  MOVLW  2C
097E6:  MOVLB  6
097E8:  MOVWF  xC2
097EA:  MOVLB  0
097EC:  CALL   561C
....................       sprintf(retData+strlen(retData), "%f,", adcVals[arg1-1].pReal);
097F0:  MOVLW  04
097F2:  MOVLB  6
097F4:  MOVWF  xB4
097F6:  MOVLW  A7
097F8:  MOVWF  xB3
097FA:  MOVLB  0
097FC:  CALL   556C
09800:  MOVF   01,W
09802:  ADDLW  A7
09804:  MOVLB  6
09806:  MOVWF  xA2
09808:  MOVLW  04
0980A:  ADDWFC 02,W
0980C:  MOVWF  xA3
0980E:  MOVLW  01
09810:  SUBWF  x7D,W
09812:  MULLW  21
09814:  MOVF   FF3,W
09816:  CLRF   xA5
09818:  MOVWF  xA4
0981A:  MOVLW  1D
0981C:  ADDWF  xA4,W
0981E:  MOVWF  01
09820:  MOVLW  00
09822:  ADDWFC xA5,W
09824:  MOVWF  03
09826:  MOVF   01,W
09828:  ADDLW  07
0982A:  MOVWF  FE9
0982C:  MOVLW  01
0982E:  ADDWFC 03,W
09830:  MOVWF  FEA
09832:  MOVFF  FEF,6B5
09836:  MOVFF  FEC,6B6
0983A:  MOVFF  FEC,6B7
0983E:  MOVFF  FEC,6B8
09842:  MOVFF  6A3,54B
09846:  MOVFF  6A2,54A
0984A:  MOVLW  89
0984C:  MOVWF  FE9
0984E:  MOVLW  02
09850:  MOVWF  xB9
09852:  MOVLB  0
09854:  CALL   641A
09858:  MOVLW  2C
0985A:  MOVLB  6
0985C:  MOVWF  xC2
0985E:  MOVLB  0
09860:  CALL   561C
....................    }
09864:  BRA    986C
....................    else return INV_PARAM;
09866:  MOVLW  02
09868:  MOVWF  01
0986A:  BRA    9870
....................    
....................    return SUCCESS;
0986C:  MOVLW  00
0986E:  MOVWF  01
09870:  RETURN 0
.................... }
.................... 
.................... int8 getManOPvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
09872:  MOVLB  6
09874:  CLRF   xB4
09876:  MOVFF  66B,6B3
0987A:  CLRF   xB6
0987C:  MOVLW  B5
0987E:  MOVWF  xB5
09880:  MOVLB  0
09882:  CALL   082A
09886:  MOVFF  02,67F
0988A:  MOVFF  01,67E
0988E:  MOVLW  06
09890:  MOVLB  6
09892:  ADDWF  x7E,F
09894:  MOVLW  00
09896:  ADDWFC x7F,F
09898:  MOVLW  32
0989A:  ADDWF  x7E,W
0989C:  MOVWF  01
0989E:  MOVLW  00
098A0:  ADDWFC x7F,W
098A2:  MOVWF  03
098A4:  MOVF   01,W
098A6:  ADDLW  D1
098A8:  MOVWF  01
098AA:  MOVLW  01
098AC:  ADDWFC 03,F
098AE:  MOVFF  01,67E
098B2:  MOVFF  03,67F
098B6:  MOVFF  03,6A6
098BA:  MOVFF  01,6A5
098BE:  MOVLB  0
098C0:  CALL   56E4
098C4:  MOVF   01,F
098C6:  BNZ   98D0
098C8:  MOVLW  02
098CA:  MOVWF  01
098CC:  BRA    99C2
098CE:  BRA    992E
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
098D0:  MOVLB  6
098D2:  CLRF   xB4
098D4:  MOVFF  66B,6B3
098D8:  CLRF   xB6
098DA:  MOVLW  B5
098DC:  MOVWF  xB5
098DE:  MOVLB  0
098E0:  CALL   082A
098E4:  MOVFF  02,67F
098E8:  MOVFF  01,67E
098EC:  MOVLW  06
098EE:  MOVLB  6
098F0:  ADDWF  x7E,F
098F2:  MOVLW  00
098F4:  ADDWFC x7F,F
098F6:  MOVLW  32
098F8:  ADDWF  x7E,W
098FA:  MOVWF  01
098FC:  MOVLW  00
098FE:  ADDWFC x7F,W
09900:  MOVWF  03
09902:  MOVF   01,W
09904:  ADDLW  D1
09906:  MOVWF  01
09908:  MOVLW  01
0990A:  ADDWFC 03,F
0990C:  MOVFF  01,67E
09910:  MOVFF  03,67F
09914:  MOVFF  03,6A6
09918:  MOVFF  01,6A5
0991C:  CLRF   xA8
0991E:  CLRF   xA7
09920:  MOVLW  0A
09922:  MOVWF  xA9
09924:  MOVLB  0
09926:  CALL   57D4
0992A:  MOVFF  01,67D
....................    
....................    /*** GET MANUAL OUTPUT VALUE ***************/ 
....................    sprintf(retData+strlen(retData), "%d,%f,", arg1, manualOutputValues[arg1-1]);
0992E:  MOVLW  04
09930:  MOVLB  6
09932:  MOVWF  xB4
09934:  MOVLW  A7
09936:  MOVWF  xB3
09938:  MOVLB  0
0993A:  CALL   556C
0993E:  MOVF   01,W
09940:  ADDLW  A7
09942:  MOVLB  6
09944:  MOVWF  x7E
09946:  MOVLW  04
09948:  ADDWFC 02,W
0994A:  MOVWF  x7F
0994C:  MOVLW  01
0994E:  SUBWF  x7D,W
09950:  MULLW  04
09952:  MOVF   FF3,W
09954:  CLRF   03
09956:  ADDLW  50
09958:  MOVWF  FE9
0995A:  MOVLW  01
0995C:  ADDWFC 03,W
0995E:  MOVWF  FEA
09960:  MOVFF  FEF,680
09964:  MOVFF  FEC,681
09968:  MOVFF  FEC,682
0996C:  MOVFF  FEC,683
09970:  MOVFF  67F,54B
09974:  MOVFF  67E,54A
09978:  MOVFF  67D,6A6
0997C:  MOVLW  18
0997E:  MOVWF  xA7
09980:  MOVLB  0
09982:  CALL   5B28
09986:  MOVLW  2C
09988:  MOVLB  6
0998A:  MOVWF  xC2
0998C:  MOVLB  0
0998E:  CALL   561C
09992:  MOVLW  89
09994:  MOVWF  FE9
09996:  MOVFF  683,6B8
0999A:  MOVFF  682,6B7
0999E:  MOVFF  681,6B6
099A2:  MOVFF  680,6B5
099A6:  MOVLW  02
099A8:  MOVLB  6
099AA:  MOVWF  xB9
099AC:  MOVLB  0
099AE:  CALL   641A
099B2:  MOVLW  2C
099B4:  MOVLB  6
099B6:  MOVWF  xC2
099B8:  MOVLB  0
099BA:  CALL   561C
....................    
....................    return SUCCESS;
099BE:  MOVLW  00
099C0:  MOVWF  01
099C2:  RETURN 0
.................... }
.................... 
.................... int8 setManOPvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    float arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
099C4:  MOVLB  6
099C6:  CLRF   xB4
099C8:  MOVFF  66B,6B3
099CC:  CLRF   xB6
099CE:  MOVLW  B5
099D0:  MOVWF  xB5
099D2:  MOVLB  0
099D4:  CALL   082A
099D8:  MOVFF  02,683
099DC:  MOVFF  01,682
099E0:  MOVLW  06
099E2:  MOVLB  6
099E4:  ADDWF  x82,F
099E6:  MOVLW  00
099E8:  ADDWFC x83,F
099EA:  MOVLW  32
099EC:  ADDWF  x82,W
099EE:  MOVWF  01
099F0:  MOVLW  00
099F2:  ADDWFC x83,W
099F4:  MOVWF  03
099F6:  MOVF   01,W
099F8:  ADDLW  D1
099FA:  MOVWF  01
099FC:  MOVLW  01
099FE:  ADDWFC 03,F
09A00:  MOVFF  01,682
09A04:  MOVFF  03,683
09A08:  MOVFF  03,6A6
09A0C:  MOVFF  01,6A5
09A10:  MOVLB  0
09A12:  CALL   56E4
09A16:  MOVF   01,F
09A18:  BNZ   9A22
09A1A:  MOVLW  02
09A1C:  MOVWF  01
09A1E:  BRA    9C04
09A20:  BRA    9A80
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
09A22:  MOVLB  6
09A24:  CLRF   xB4
09A26:  MOVFF  66B,6B3
09A2A:  CLRF   xB6
09A2C:  MOVLW  B5
09A2E:  MOVWF  xB5
09A30:  MOVLB  0
09A32:  CALL   082A
09A36:  MOVFF  02,683
09A3A:  MOVFF  01,682
09A3E:  MOVLW  06
09A40:  MOVLB  6
09A42:  ADDWF  x82,F
09A44:  MOVLW  00
09A46:  ADDWFC x83,F
09A48:  MOVLW  32
09A4A:  ADDWF  x82,W
09A4C:  MOVWF  01
09A4E:  MOVLW  00
09A50:  ADDWFC x83,W
09A52:  MOVWF  03
09A54:  MOVF   01,W
09A56:  ADDLW  D1
09A58:  MOVWF  01
09A5A:  MOVLW  01
09A5C:  ADDWFC 03,F
09A5E:  MOVFF  01,682
09A62:  MOVFF  03,683
09A66:  MOVFF  03,6A6
09A6A:  MOVFF  01,6A5
09A6E:  CLRF   xA8
09A70:  CLRF   xA7
09A72:  MOVLW  0A
09A74:  MOVWF  xA9
09A76:  MOVLB  0
09A78:  CALL   57D4
09A7C:  MOVFF  01,67D
....................    
....................    if (!arg_is_float(SERcmd[rec].p[3])) return INV_PARAM;
09A80:  MOVLB  6
09A82:  CLRF   xB4
09A84:  MOVFF  66B,6B3
09A88:  CLRF   xB6
09A8A:  MOVLW  B5
09A8C:  MOVWF  xB5
09A8E:  MOVLB  0
09A90:  CALL   082A
09A94:  MOVFF  02,683
09A98:  MOVFF  01,682
09A9C:  MOVLW  06
09A9E:  MOVLB  6
09AA0:  ADDWF  x82,F
09AA2:  MOVLW  00
09AA4:  ADDWFC x83,F
09AA6:  MOVLW  4B
09AA8:  ADDWF  x82,W
09AAA:  MOVWF  01
09AAC:  MOVLW  00
09AAE:  ADDWFC x83,W
09AB0:  MOVWF  03
09AB2:  MOVF   01,W
09AB4:  ADDLW  D1
09AB6:  MOVWF  01
09AB8:  MOVLW  01
09ABA:  ADDWFC 03,F
09ABC:  MOVFF  01,682
09AC0:  MOVFF  03,683
09AC4:  MOVFF  03,687
09AC8:  MOVFF  01,686
09ACC:  MOVLB  0
09ACE:  CALL   6A80
09AD2:  MOVF   01,F
09AD4:  BNZ   9ADE
09AD6:  MOVLW  02
09AD8:  MOVWF  01
09ADA:  BRA    9C04
09ADC:  BRA    9B44
....................    else arg2 = strtod(SERcmd[rec].p[3], '\0');
09ADE:  MOVLB  6
09AE0:  CLRF   xB4
09AE2:  MOVFF  66B,6B3
09AE6:  CLRF   xB6
09AE8:  MOVLW  B5
09AEA:  MOVWF  xB5
09AEC:  MOVLB  0
09AEE:  CALL   082A
09AF2:  MOVFF  02,683
09AF6:  MOVFF  01,682
09AFA:  MOVLW  06
09AFC:  MOVLB  6
09AFE:  ADDWF  x82,F
09B00:  MOVLW  00
09B02:  ADDWFC x83,F
09B04:  MOVLW  4B
09B06:  ADDWF  x82,W
09B08:  MOVWF  01
09B0A:  MOVLW  00
09B0C:  ADDWFC x83,W
09B0E:  MOVWF  03
09B10:  MOVF   01,W
09B12:  ADDLW  D1
09B14:  MOVWF  01
09B16:  MOVLW  01
09B18:  ADDWFC 03,F
09B1A:  MOVFF  01,682
09B1E:  MOVFF  03,683
09B22:  MOVFF  03,687
09B26:  MOVFF  01,686
09B2A:  CLRF   x89
09B2C:  CLRF   x88
09B2E:  MOVLB  0
09B30:  CALL   6B42
09B34:  MOVFF  03,681
09B38:  MOVFF  02,680
09B3C:  MOVFF  01,67F
09B40:  MOVFF  00,67E
....................    
....................    /*** SET MANUAL OUTPUT VALUE ***************/
....................    if (arg2 > op_upper_bound) manualOutputValues[arg1-1] = op_upper_bound;
09B44:  MOVLB  6
09B46:  CLRF   xC0
09B48:  CLRF   xBF
09B4A:  MOVLW  7C
09B4C:  MOVWF  xBE
09B4E:  MOVLW  84
09B50:  MOVWF  xBD
09B52:  MOVFF  681,6C4
09B56:  MOVFF  680,6C3
09B5A:  MOVFF  67F,6C2
09B5E:  MOVFF  67E,6C1
09B62:  MOVLB  0
09B64:  CALL   1C9E
09B68:  BNC   9B8E
09B6A:  MOVLW  01
09B6C:  MOVLB  6
09B6E:  SUBWF  x7D,W
09B70:  MULLW  04
09B72:  MOVF   FF3,W
09B74:  CLRF   03
09B76:  ADDLW  50
09B78:  MOVWF  FE9
09B7A:  MOVLW  01
09B7C:  ADDWFC 03,W
09B7E:  MOVWF  FEA
09B80:  MOVLW  84
09B82:  MOVWF  FEF
09B84:  MOVLW  7C
09B86:  MOVWF  FEC
09B88:  CLRF   FEC
09B8A:  CLRF   FEC
09B8C:  BRA    9BFE
....................    else if (arg2 < op_lower_bound) manualOutputValues[arg1-1] = op_lower_bound;  
09B8E:  MOVFF  681,6C0
09B92:  MOVFF  680,6BF
09B96:  MOVFF  67F,6BE
09B9A:  MOVFF  67E,6BD
09B9E:  MOVLB  6
09BA0:  CLRF   xC4
09BA2:  CLRF   xC3
09BA4:  MOVLW  FC
09BA6:  MOVWF  xC2
09BA8:  MOVLW  84
09BAA:  MOVWF  xC1
09BAC:  MOVLB  0
09BAE:  CALL   1C9E
09BB2:  BNC   9BD8
09BB4:  MOVLW  01
09BB6:  MOVLB  6
09BB8:  SUBWF  x7D,W
09BBA:  MULLW  04
09BBC:  MOVF   FF3,W
09BBE:  CLRF   03
09BC0:  ADDLW  50
09BC2:  MOVWF  FE9
09BC4:  MOVLW  01
09BC6:  ADDWFC 03,W
09BC8:  MOVWF  FEA
09BCA:  MOVLW  84
09BCC:  MOVWF  FEF
09BCE:  MOVLW  FC
09BD0:  MOVWF  FEC
09BD2:  CLRF   FEC
09BD4:  CLRF   FEC
09BD6:  BRA    9BFE
....................    else manualOutputValues[arg1-1] = arg2;
09BD8:  MOVLW  01
09BDA:  MOVLB  6
09BDC:  SUBWF  x7D,W
09BDE:  MULLW  04
09BE0:  MOVF   FF3,W
09BE2:  CLRF   03
09BE4:  ADDLW  50
09BE6:  MOVWF  FE9
09BE8:  MOVLW  01
09BEA:  ADDWFC 03,W
09BEC:  MOVWF  FEA
09BEE:  MOVFF  67E,FEF
09BF2:  MOVFF  67F,FEC
09BF6:  MOVFF  680,FEC
09BFA:  MOVFF  681,FEC
....................    
....................    return SUCCESS;
09BFE:  MOVLW  00
09C00:  MOVWF  01
09C02:  MOVLB  0
09C04:  RETURN 0
.................... }
.................... 
.................... int8 setFilterOn(unsigned int8 rec){
....................    adcFilter = TRUE;
09C06:  MOVLB  1
09C08:  BSF    x49.0
....................    return SUCCESS;
09C0A:  MOVLW  00
09C0C:  MOVWF  01
09C0E:  MOVLB  0
09C10:  RETURN 0
.................... }
.................... 
.................... int8 setFilterOff(unsigned int8 rec){
....................    adcFilter = FALSE;
09C12:  MOVLB  1
09C14:  BCF    x49.0
....................    return SUCCESS;
09C16:  MOVLW  00
09C18:  MOVWF  01
09C1A:  MOVLB  0
09C1C:  RETURN 0
.................... }
.................... 
.................... int8 invalidCmd(unsigned int8 rec){
....................    return INV_CMD;
09C1E:  MOVLW  01
09C20:  MOVWF  01
09C22:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* ARG VALIDATION HELPER FUNCS                                               */
.................... /*****************************************************************************/
.................... BOOLEAN arg_is_float(char *arg){
*
06A80:  MOVLB  6
06A82:  BCF    x88.0
....................    BOOLEAN decimal = FALSE;
....................    for (int i=0; i<strlen(arg); i++){
06A84:  CLRF   x89
06A86:  MOVFF  687,6B4
06A8A:  MOVFF  686,6B3
06A8E:  MOVLB  0
06A90:  CALL   556C
06A94:  MOVFF  02,03
06A98:  MOVF   01,W
06A9A:  MOVF   03,F
06A9C:  BNZ   6AA8
06A9E:  MOVF   01,W
06AA0:  MOVLB  6
06AA2:  SUBWF  x89,W
06AA4:  BC    6B3A
06AA6:  MOVLB  0
....................       if (!isdigit(arg[i])){
06AA8:  MOVLB  6
06AAA:  MOVF   x89,W
06AAC:  ADDWF  x86,W
06AAE:  MOVWF  FE9
06AB0:  MOVLW  00
06AB2:  ADDWFC x87,W
06AB4:  MOVWF  FEA
06AB6:  MOVFF  FEF,68A
06ABA:  MOVF   x8A,W
06ABC:  SUBLW  2F
06ABE:  BC    6AC6
06AC0:  MOVF   x8A,W
06AC2:  SUBLW  39
06AC4:  BC    6B32
....................          // Check for negative sign
....................          if ('-' != arg[i]){
06AC6:  MOVF   x89,W
06AC8:  ADDWF  x86,W
06ACA:  MOVWF  FE9
06ACC:  MOVLW  00
06ACE:  ADDWFC x87,W
06AD0:  MOVWF  FEA
06AD2:  MOVF   FEF,W
06AD4:  SUBLW  2D
06AD6:  BZ    6B02
....................             // Check for decimal
....................             if ('.' != arg[i]) return FALSE;
06AD8:  MOVF   x89,W
06ADA:  ADDWF  x86,W
06ADC:  MOVWF  FE9
06ADE:  MOVLW  00
06AE0:  ADDWFC x87,W
06AE2:  MOVWF  FEA
06AE4:  MOVF   FEF,W
06AE6:  SUBLW  2E
06AE8:  BZ    6AF2
06AEA:  MOVLW  00
06AEC:  MOVWF  01
06AEE:  BRA    6B3E
06AF0:  BRA    6B00
....................             else if  (decimal) return FALSE;
06AF2:  BTFSS  x88.0
06AF4:  BRA    6AFE
06AF6:  MOVLW  00
06AF8:  MOVWF  01
06AFA:  BRA    6B3E
06AFC:  BRA    6B00
....................             else decimal = TRUE;
06AFE:  BSF    x88.0
....................          }
06B00:  BRA    6B32
....................          else if (0 != i) return FALSE;
06B02:  MOVF   x89,F
06B04:  BZ    6B0E
06B06:  MOVLW  00
06B08:  MOVWF  01
06B0A:  BRA    6B3E
06B0C:  BRA    6B32
....................          else if (1 == strlen(arg)) return FALSE;
06B0E:  MOVFF  687,6B4
06B12:  MOVFF  686,6B3
06B16:  MOVLB  0
06B18:  CALL   556C
06B1C:  MOVFF  02,03
06B20:  MOVF   01,W
06B22:  SUBLW  01
06B24:  BNZ   6B34
06B26:  MOVF   03,F
06B28:  BNZ   6B34
06B2A:  MOVLW  00
06B2C:  MOVWF  01
06B2E:  MOVLB  6
06B30:  BRA    6B3E
06B32:  MOVLB  0
....................       }
06B34:  MOVLB  6
06B36:  INCF   x89,F
06B38:  BRA    6A86
....................    }
....................    return TRUE;
06B3A:  MOVLW  01
06B3C:  MOVWF  01
06B3E:  MOVLB  0
06B40:  RETURN 0
.................... }
.................... 
.................... BOOLEAN is_valid_channel(char *arg){
....................     if (1 != strlen(arg)) return FALSE;
*
056E4:  MOVFF  6A6,6B4
056E8:  MOVFF  6A5,6B3
056EC:  RCALL  556C
056EE:  MOVFF  02,03
056F2:  MOVF   01,W
056F4:  SUBLW  01
056F6:  BNZ   56FC
056F8:  MOVF   03,F
056FA:  BZ    5704
056FC:  MOVLW  00
056FE:  MOVWF  01
05700:  BRA    5732
05702:  BRA    572A
....................     else if ('1' != arg[0] && '2' != arg[0]) return FALSE;
05704:  MOVLB  6
05706:  MOVFF  6A5,FE9
0570A:  MOVFF  6A6,FEA
0570E:  MOVF   FEF,W
05710:  SUBLW  31
05712:  BZ    572C
05714:  MOVFF  6A5,FE9
05718:  MOVFF  6A6,FEA
0571C:  MOVF   FEF,W
0571E:  SUBLW  32
05720:  BZ    572C
05722:  MOVLW  00
05724:  MOVWF  01
05726:  MOVLB  0
05728:  BRA    5732
0572A:  MOVLB  6
....................     return TRUE;
0572C:  MOVLW  01
0572E:  MOVWF  01
05730:  MOVLB  0
05732:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* ASCII HEX CHARACTER TO INT                                                */
.................... /*****************************************************************************/
.................... int8 hex_to_int(char ascii){
....................    if (ascii >= '0' && ascii <= '9') return ascii-'0';
*
05532:  MOVLB  6
05534:  MOVF   x7C,W
05536:  SUBLW  2F
05538:  BC    554A
0553A:  MOVF   x7C,W
0553C:  SUBLW  39
0553E:  BNC   554A
05540:  MOVLW  30
05542:  SUBWF  x7C,W
05544:  MOVWF  01
05546:  BRA    5566
05548:  BRA    5566
....................    else if (ascii >= 'A' && ascii <= 'F') return ascii-'A'+10;
0554A:  MOVF   x7C,W
0554C:  SUBLW  40
0554E:  BC    5562
05550:  MOVF   x7C,W
05552:  SUBLW  46
05554:  BNC   5562
05556:  MOVLW  41
05558:  SUBWF  x7C,W
0555A:  ADDLW  0A
0555C:  MOVWF  01
0555E:  BRA    5566
05560:  BRA    5566
....................    else return 0xFF;
05562:  MOVLW  FF
05564:  MOVWF  01
05566:  MOVLB  0
05568:  GOTO   9CC8 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* COMMAND HANDLER/PARSER FUNCS                                              */
.................... /*****************************************************************************/
.................... void echo_cmd(unsigned int8 rec){
....................    fprintf(SERIAL, "%c", SERcmd[rec].t);
....................    while (SERcmd[rec].recReadIndex <= SERcmd[rec].recWriteIndex)
....................    {
....................       if (SERcmd[rec].recReadIndex != 0) fprintf(SERIAL, "%c", delimiter);
....................       fprintf(SERIAL, "%s", SERcmd[rec].p[SERcmd[rec].recReadIndex]);
....................       SERcmd[rec].recReadIndex++;
....................    }
....................    SERcmd[rec].recReadIndex=0;
.................... }
.................... 
.................... int8 command_parser(unsigned int8 rec){
*
09C24:  MOVLB  6
09C26:  CLRF   xB4
09C28:  MOVFF  673,6B3
09C2C:  CLRF   xB6
09C2E:  MOVLW  B5
09C30:  MOVWF  xB5
09C32:  MOVLB  0
09C34:  CALL   082A
09C38:  MOVFF  02,67C
09C3C:  MOVFF  01,67B
09C40:  MOVLW  06
09C42:  MOVLB  6
09C44:  ADDWF  x7B,F
09C46:  MOVLW  00
09C48:  ADDWFC x7C,F
09C4A:  MOVLW  D1
09C4C:  ADDWF  x7B,W
09C4E:  MOVWF  01
09C50:  MOVLW  01
09C52:  ADDWFC x7C,W
09C54:  MOVWF  03
09C56:  MOVFF  01,674
09C5A:  MOVWF  x75
09C5C:  CLRF   xB4
09C5E:  MOVFF  673,6B3
09C62:  CLRF   xB6
09C64:  MOVLW  B5
09C66:  MOVWF  xB5
09C68:  MOVLB  0
09C6A:  CALL   082A
09C6E:  MOVFF  02,67E
09C72:  MOVFF  01,67D
09C76:  MOVLW  06
09C78:  MOVLB  6
09C7A:  ADDWF  x7D,F
09C7C:  MOVLW  00
09C7E:  ADDWFC x7E,F
09C80:  MOVLW  19
09C82:  ADDWF  x7D,W
09C84:  MOVWF  01
09C86:  MOVLW  00
09C88:  ADDWFC x7E,W
09C8A:  MOVWF  03
09C8C:  MOVF   01,W
09C8E:  ADDLW  D1
09C90:  MOVWF  01
09C92:  MOVLW  01
09C94:  ADDWFC 03,F
09C96:  MOVFF  01,676
09C9A:  MOVFF  03,677
09C9E:  CLRF   x78
09CA0:  CLRF   x79
....................    char *cmd_adr = SERcmd[rec].p[0];
....................    char *cmd_str = SERcmd[rec].p[1];
.................... //!   int8 devID = input_a();
....................    int8 devID = 0;
....................    int8 i = 0;
....................    
....................    if (hwID == cmd_adr[0]){
09CA2:  MOVFF  674,FE9
09CA6:  MOVFF  675,FEA
09CAA:  MOVF   FEF,W
09CAC:  SUBLW  44
09CAE:  BTFSS  FD8.2
09CB0:  BRA    9DA0
....................       if (hex_to_int(cmd_adr[1]) == (devID & 0x0F)){
09CB2:  MOVLW  01
09CB4:  ADDWF  x74,W
09CB6:  MOVWF  FE9
09CB8:  MOVLW  00
09CBA:  ADDWFC x75,W
09CBC:  MOVWF  FEA
09CBE:  MOVFF  FEF,67C
09CC2:  MOVLB  0
09CC4:  GOTO   5532
09CC8:  MOVFF  01,67B
09CCC:  MOVLB  6
09CCE:  MOVF   x78,W
09CD0:  ANDLW  0F
09CD2:  SUBWF  01,W
09CD4:  BNZ   9D98
....................          while (0 != strlen(cmd_list[i].cmd_name)){
09CD6:  MOVF   x79,W
09CD8:  MULLW  04
09CDA:  MOVF   FF3,W
09CDC:  CLRF   x7C
09CDE:  MOVWF  x7B
09CE0:  MOVLW  50
09CE2:  ADDWF  x7B,W
09CE4:  MOVWF  FE9
09CE6:  MOVLW  05
09CE8:  ADDWFC x7C,W
09CEA:  MOVWF  FEA
09CEC:  MOVFF  FEC,6B4
09CF0:  MOVF   FED,F
09CF2:  MOVFF  FEF,6B3
09CF6:  MOVLB  0
09CF8:  CALL   556C
09CFC:  MOVFF  02,03
09D00:  MOVF   01,W
09D02:  BNZ   9D08
09D04:  MOVF   03,F
09D06:  BZ    9D8E
....................             if (0 == strcmp(cmd_str, cmd_list[i].cmd_name))
09D08:  MOVLB  6
09D0A:  MOVF   x79,W
09D0C:  MULLW  04
09D0E:  MOVF   FF3,W
09D10:  CLRF   x7C
09D12:  MOVWF  x7B
09D14:  MOVLW  50
09D16:  ADDWF  x7B,W
09D18:  MOVWF  FE9
09D1A:  MOVLW  05
09D1C:  ADDWFC x7C,W
09D1E:  MOVWF  FEA
09D20:  MOVFF  FEC,6B6
09D24:  MOVF   FED,F
09D26:  MOVFF  FEF,6B5
09D2A:  MOVFF  677,6B4
09D2E:  MOVFF  676,6B3
09D32:  MOVLB  0
09D34:  CALL   55A4
09D38:  MOVF   01,F
09D3A:  BNZ   9D86
....................             {
....................                int8 return_code = cmd_list[i].cmd_func(rec);
09D3C:  MOVLB  6
09D3E:  MOVF   x79,W
09D40:  MULLW  04
09D42:  MOVF   FF3,W
09D44:  CLRF   x7C
09D46:  MOVWF  x7B
09D48:  MOVLW  02
09D4A:  ADDWF  x7B,W
09D4C:  MOVWF  01
09D4E:  MOVLW  00
09D50:  ADDWFC x7C,W
09D52:  MOVWF  03
09D54:  MOVF   01,W
09D56:  ADDLW  50
09D58:  MOVWF  01
09D5A:  MOVLW  05
09D5C:  ADDWFC 03,F
09D5E:  MOVFF  01,67B
09D62:  MOVFF  03,67C
09D66:  MOVFF  03,FEA
09D6A:  MOVFF  01,FE9
09D6E:  MOVFF  673,66B
09D72:  MOVLB  0
09D74:  CALL   00BC
09D78:  MOVFF  01,67A
....................                return return_code;
09D7C:  MOVLB  6
09D7E:  MOVFF  67A,01
09D82:  BRA    9DA4
09D84:  MOVLB  0
....................             }
....................             i++;
09D86:  MOVLB  6
09D88:  INCF   x79,F
09D8A:  BRA    9CD6
09D8C:  MOVLB  0
....................          }
....................          return INV_CMD; // INVALID_CMD
09D8E:  MOVLW  01
09D90:  MOVWF  01
09D92:  MOVLB  6
09D94:  BRA    9DA4
....................       } else return 254; // NOT THIS ADDRESS
09D96:  BRA    9D9E
09D98:  MOVLW  FE
09D9A:  MOVWF  01
09D9C:  BRA    9DA4
....................    } else return 255; // NOT THIS DEVICE TYPE
09D9E:  BRA    9DA4
09DA0:  MOVLW  FF
09DA2:  MOVWF  01
09DA4:  MOVLB  0
09DA6:  GOTO   9DE0 (RETURN)
.................... }
.................... 
.................... void command_handler_task(){
....................    while (getNextSERReadIndex())
*
09DD2:  GOTO   54D8
09DD6:  MOVF   01,F
09DD8:  BZ    9EC8
....................    {
....................       int8 return_code = command_parser(SRI);
09DDA:  MOVFF  4A5,673
09DDE:  BRA    9C24
09DE0:  MOVFF  01,672
....................       //echo_cmd(SRI);
....................       sprintf(retData + strlen(retData), "%s", resp_list[return_code].msg);
09DE4:  MOVLW  04
09DE6:  MOVLB  6
09DE8:  MOVWF  xB4
09DEA:  MOVLW  A7
09DEC:  MOVWF  xB3
09DEE:  MOVLB  0
09DF0:  CALL   556C
09DF4:  MOVF   01,W
09DF6:  ADDLW  A7
09DF8:  MOVLB  6
09DFA:  MOVWF  x73
09DFC:  MOVLW  04
09DFE:  ADDWFC 02,W
09E00:  MOVWF  x74
09E02:  MOVF   x72,W
09E04:  MULLW  03
09E06:  MOVF   FF3,W
09E08:  CLRF   x76
09E0A:  MOVWF  x75
09E0C:  MOVLW  01
09E0E:  ADDWF  x75,W
09E10:  MOVWF  01
09E12:  MOVLW  00
09E14:  ADDWFC x76,W
09E16:  MOVWF  03
09E18:  MOVF   01,W
09E1A:  ADDLW  38
09E1C:  MOVWF  FE9
09E1E:  MOVLW  06
09E20:  ADDWFC 03,W
09E22:  MOVWF  FEA
09E24:  MOVFF  FEC,676
09E28:  MOVF   FED,F
09E2A:  MOVFF  FEF,675
09E2E:  MOVFF  674,54B
09E32:  MOVFF  673,54A
09E36:  MOVFF  54B,FEA
09E3A:  MOVFF  54A,FE9
09E3E:  CLRF   FEF
09E40:  MOVFF  676,FEA
09E44:  MOVFF  675,FE9
09E48:  MOVLB  0
09E4A:  BRA    9DAA
....................       fprintf(SERIAL, "$%s,%s\n", SERcmd[SRI].p[0], retData);
09E4C:  MOVLB  6
09E4E:  CLRF   xB4
09E50:  MOVFF  4A5,6B3
09E54:  CLRF   xB6
09E56:  MOVLW  B5
09E58:  MOVWF  xB5
09E5A:  MOVLB  0
09E5C:  CALL   082A
09E60:  MOVFF  02,674
09E64:  MOVFF  01,673
09E68:  MOVLW  06
09E6A:  MOVLB  6
09E6C:  ADDWF  x73,F
09E6E:  MOVLW  00
09E70:  ADDWFC x74,F
09E72:  MOVLW  D1
09E74:  ADDWF  x73,W
09E76:  MOVWF  01
09E78:  MOVLW  01
09E7A:  ADDWFC x74,W
09E7C:  MOVWF  03
09E7E:  MOVFF  01,675
09E82:  MOVWF  x76
09E84:  MOVLW  24
09E86:  MOVWF  x79
09E88:  MOVLB  0
09E8A:  CALL   4F94
09E8E:  MOVFF  676,FEA
09E92:  MOVFF  675,FE9
09E96:  CALL   4FBC
09E9A:  MOVLW  2C
09E9C:  MOVLB  6
09E9E:  MOVWF  x79
09EA0:  MOVLB  0
09EA2:  CALL   4F94
09EA6:  MOVLW  04
09EA8:  MOVWF  FEA
09EAA:  MOVLW  A7
09EAC:  MOVWF  FE9
09EAE:  CALL   4FBC
09EB2:  MOVLW  0A
09EB4:  MOVLB  6
09EB6:  MOVWF  x79
09EB8:  MOVLB  0
09EBA:  CALL   4F94
....................       
....................       resetSERcmd(SRI);
09EBE:  MOVFF  4A5,673
09EC2:  CALL   0B0C
09EC6:  BRA    9DD2
....................    }
09EC8:  GOTO   A2F4 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... //!#define DEBUG_1
.................... 
.................... void main()
09ECC:  CLRF   FF8
09ECE:  BCF    FF2.5
09ED0:  BSF    07.7
09ED2:  MOVLB  E
09ED4:  MOVLW  55
09ED6:  MOVWF  x9B
09ED8:  MOVLW  AA
09EDA:  MOVWF  x9B
09EDC:  BCF    x9B.0
09EDE:  MOVLW  17
09EE0:  MOVWF  xB0
09EE2:  MOVLW  13
09EE4:  MOVWF  xB2
09EE6:  MOVLW  09
09EE8:  MOVWF  x8A
09EEA:  MOVLW  0A
09EEC:  MOVWF  x8B
09EEE:  MOVLW  11
09EF0:  MOVWF  xEB
09EF2:  MOVLW  12
09EF4:  MOVWF  xED
09EF6:  MOVLW  10
09EF8:  MOVWF  xF4
09EFA:  MOVLW  0F
09EFC:  MOVWF  xF5
09EFE:  MOVLW  09
09F00:  MOVWF  xF8
09F02:  MOVLW  55
09F04:  MOVWF  x9B
09F06:  MOVLW  AA
09F08:  MOVWF  x9B
09F0A:  BSF    x9B.0
09F0C:  CLRF   xD8
09F0E:  CLRF   xD5
09F10:  CLRF   xD7
09F12:  MOVLW  08
09F14:  MOVWF  xD9
09F16:  MOVLW  60
09F18:  MOVWF  xD3
09F1A:  MOVLW  AA
09F1C:  MOVLB  0
09F1E:  MOVWF  xEA
09F20:  MOVLB  1
09F22:  BSF    x49.0
09F24:  CLRF   x5B
09F26:  CLRF   x5A
09F28:  CLRF   x59
09F2A:  CLRF   x58
09F2C:  CLRF   x5F
09F2E:  CLRF   x5E
09F30:  CLRF   x5D
09F32:  CLRF   x5C
09F34:  CLRF   x63
09F36:  CLRF   x62
09F38:  CLRF   x61
09F3A:  CLRF   x60
09F3C:  CLRF   x65
09F3E:  CLRF   x64
09F40:  MOVLB  E
09F42:  BCF    x91.5
09F44:  MOVLW  00
09F46:  MOVWF  x90
09F48:  MOVLW  03
09F4A:  MOVWF  x8E
09F4C:  MOVLW  2A
09F4E:  MOVWF  x91
09F50:  MOVLW  C4
09F52:  MOVWF  F88
09F54:  MOVWF  F88
09F56:  MOVWF  F88
09F58:  MOVLB  1
09F5A:  CLRF   xB6
09F5C:  CLRF   xB7
09F5E:  CLRF   xB8
09F60:  CLRF   xB9
09F62:  BCF    F95.5
09F64:  MOVLW  40
09F66:  MOVWF  F94
09F68:  MOVLW  9F
09F6A:  MOVWF  F92
09F6C:  MOVLW  3A
09F6E:  MOVWF  F95
09F70:  MOVLW  93
09F72:  MOVWF  F89
09F74:  MOVWF  F89
09F76:  MOVLB  4
09F78:  CLRF   xA5
09F7A:  CLRF   xA6
09F7C:  MOVLB  5
09F7E:  CLRF   x47
09F80:  CLRF   x48
09F82:  MOVLB  1
09F84:  BCF    x49.1
09F86:  MOVLB  5
09F88:  CLRF   x49
09F8A:  BSF    F9E.3
09F8C:  MOVLW  7C
09F8E:  MOVWF  F9A
09F90:  MOVLW  00
09F92:  MOVWF  F9B
09F94:  MOVLW  A6
09F96:  MOVWF  F9D
09F98:  MOVLW  90
09F9A:  MOVWF  F9C
09F9C:  MOVLW  93
09F9E:  MOVWF  F89
09FA0:  BCF    F84.5
09FA2:  CLRF   x4B
09FA4:  CLRF   x4A
09FA6:  CLRF   x4F
09FA8:  CLRF   x4E
09FAA:  CLRF   x4D
09FAC:  CLRF   x4C
09FAE:  MOVLB  F
09FB0:  CLRF   x0C
09FB2:  CLRF   x14
09FB4:  CLRF   x1C
09FB6:  CLRF   x21
09FB8:  CLRF   x29
09FBA:  CLRF   x35
09FBC:  CLRF   x36
09FBE:  CLRF   x37
09FC0:  CLRF   x34
09FC2:  CLRF   x31
09FC4:  CLRF   x32
09FC6:  CLRF   x33
09FC8:  CLRF   x30
09FCA:  MOVLW  56
09FCC:  MOVLB  5
09FCE:  MOVWF  x53
09FD0:  MOVLW  5C
09FD2:  MOVWF  x52
09FD4:  MOVLW  56
09FD6:  MOVWF  x57
09FD8:  MOVLW  A0
09FDA:  MOVWF  x56
09FDC:  MOVLW  5B
09FDE:  MOVWF  x5B
09FE0:  MOVLW  E8
09FE2:  MOVWF  x5A
09FE4:  MOVLW  5D
09FE6:  MOVWF  x5F
09FE8:  MOVLW  C6
09FEA:  MOVWF  x5E
09FEC:  MOVLW  5F
09FEE:  MOVWF  x63
09FF0:  MOVLW  9E
09FF2:  MOVWF  x62
09FF4:  MOVLW  61
09FF6:  MOVWF  x67
09FF8:  MOVLW  2A
09FFA:  MOVWF  x66
09FFC:  MOVLW  65
09FFE:  MOVWF  x6B
0A000:  MOVLW  CA
0A002:  MOVWF  x6A
0A004:  MOVLW  6D
0A006:  MOVWF  x6F
0A008:  MOVLW  9C
0A00A:  MOVWF  x6E
0A00C:  MOVLW  70
0A00E:  MOVWF  x73
0A010:  MOVLW  7C
0A012:  MOVWF  x72
0A014:  MOVLW  71
0A016:  MOVWF  x77
0A018:  MOVLW  DE
0A01A:  MOVWF  x76
0A01C:  MOVLW  73
0A01E:  MOVWF  x7B
0A020:  MOVLW  9C
0A022:  MOVWF  x7A
0A024:  MOVLW  77
0A026:  MOVWF  x7F
0A028:  MOVLW  52
0A02A:  MOVWF  x7E
0A02C:  MOVLW  7C
0A02E:  MOVWF  x83
0A030:  MOVLW  AE
0A032:  MOVWF  x82
0A034:  MOVLW  80
0A036:  MOVWF  x87
0A038:  MOVLW  46
0A03A:  MOVWF  x86
0A03C:  MOVLW  85
0A03E:  MOVWF  x8B
0A040:  MOVLW  72
0A042:  MOVWF  x8A
0A044:  MOVLW  85
0A046:  MOVWF  x8F
0A048:  MOVLW  78
0A04A:  MOVWF  x8E
0A04C:  MOVLW  8B
0A04E:  MOVWF  x93
0A050:  MOVLW  EC
0A052:  MOVWF  x92
0A054:  MOVLW  91
0A056:  MOVWF  x97
0A058:  MOVLW  50
0A05A:  MOVWF  x96
0A05C:  MOVLW  98
0A05E:  MOVWF  x9B
0A060:  MOVLW  72
0A062:  MOVWF  x9A
0A064:  MOVLW  99
0A066:  MOVWF  x9F
0A068:  MOVLW  C4
0A06A:  MOVWF  x9E
0A06C:  MOVLW  9C
0A06E:  MOVWF  xA3
0A070:  MOVLW  06
0A072:  MOVWF  xA2
0A074:  MOVLW  9C
0A076:  MOVWF  xA7
0A078:  MOVLW  12
0A07A:  MOVWF  xA6
0A07C:  MOVLW  9C
0A07E:  MOVWF  xAB
0A080:  MOVLW  1E
0A082:  MOVWF  xAA
0A084:  BRA    A258
0A086:  DATA 02,00
0A088:  DATA 1A,00
0A08A:  DATA 00,0C
0A08C:  DATA 00,20
0A08E:  DATA 78,23
0A090:  DATA D7,0A
0A092:  DATA 7D,19
0A094:  DATA 99,9A
0A096:  DATA 7B,4C
0A098:  DATA CC,CD
0A09A:  DATA 14,C0
0A09C:  DATA 00,0C
0A09E:  DATA 80,78
0A0A0:  DATA 23,D7
0A0A2:  DATA 0A,7D
0A0A4:  DATA 19,99
0A0A6:  DATA 9A,7B
0A0A8:  DATA 4C,CC
0A0AA:  DATA CD,14
0A0AC:  DATA C0,00
0A0AE:  DATA 01,80
0A0B0:  DATA 02,09
0A0B2:  DATA C0,00
0A0B4:  DATA 05,80
0A0B6:  DATA 7F,00
0A0B8:  DATA 00,00
0A0BA:  DATA 7F,0B
0A0BC:  DATA C0,00
0A0BE:  DATA 05,80
0A0C0:  DATA 7F,00
0A0C2:  DATA 00,00
0A0C4:  DATA 7F,07
0A0C6:  DATA C0,00
0A0C8:  DATA 01,80
0A0CA:  DATA 7F,17
0A0CC:  DATA C0,00
0A0CE:  DATA 01,80
0A0D0:  DATA 7F,17
0A0D2:  DATA C0,00
0A0D4:  DATA 04,80
0A0D6:  DATA 79,B7
0A0D8:  DATA F3,BD
0A0DA:  DATA 04,C0
0A0DC:  DATA 00,04
0A0DE:  DATA 80,7C
0A0E0:  DATA 59,DF
0A0E2:  DATA 4E,04
0A0E4:  DATA C0,00
0A0E6:  DATA 04,80
0A0E8:  DATA 78,0A
0A0EA:  DATA 28,88
0A0EC:  DATA 04,C0
0A0EE:  DATA 00,04
0A0F0:  DATA 80,78
0A0F2:  DATA 05,EA
0A0F4:  DATA 16,04
0A0F6:  DATA C0,00
0A0F8:  DATA 04,80
0A0FA:  DATA 78,1E
0A0FC:  DATA 33,D7
0A0FE:  DATA 04,C0
0A100:  DATA 00,04
0A102:  DATA 80,77
0A104:  DATA 68,7B
0A106:  DATA BB,04
0A108:  DATA C0,00
0A10A:  DATA 04,80
0A10C:  DATA 77,68
0A10E:  DATA 0D,C6
0A110:  DATA 5E,40
0A112:  DATA EB,00
0A114:  DATA 0E,41
0A116:  DATA 4A,00
0A118:  DATA 17,41
0A11A:  DATA BA,00
0A11C:  DATA 3C,45
0A11E:  DATA 0B,00
0A120:  DATA 02,05
0A122:  DATA 50,AC
0A124:  DATA 05,02
0A126:  DATA 05,54
0A128:  DATA AF,05
0A12A:  DATA 02,05
0A12C:  DATA 58,B2
0A12E:  DATA 05,02
0A130:  DATA 05,5C
0A132:  DATA B9,05
0A134:  DATA 02,05
0A136:  DATA 60,C0
0A138:  DATA 05,02
0A13A:  DATA 05,64
0A13C:  DATA C8,05
0A13E:  DATA 02,05
0A140:  DATA 68,D0
0A142:  DATA 05,02
0A144:  DATA 05,6C
0A146:  DATA D5,05
0A148:  DATA 02,05
0A14A:  DATA 70,DA
0A14C:  DATA 05,02
0A14E:  DATA 05,74
0A150:  DATA DE,05
0A152:  DATA 02,05
0A154:  DATA 78,E2
0A156:  DATA 05,02
0A158:  DATA 05,7C
0A15A:  DATA E9,05
0A15C:  DATA 02,05
0A15E:  DATA 80,EF
0A160:  DATA 05,02
0A162:  DATA 05,84
0A164:  DATA F5,05
0A166:  DATA 02,05
0A168:  DATA 88,FB
0A16A:  DATA 05,02
0A16C:  DATA 05,8C
0A16E:  DATA 01,06
0A170:  DATA 02,05
0A172:  DATA 90,06
0A174:  DATA 06,02
0A176:  DATA 05,94
0A178:  DATA 0F,06
0A17A:  DATA 02,05
0A17C:  DATA 98,17
0A17E:  DATA 06,02
0A180:  DATA 05,9C
0A182:  DATA 1E,06
0A184:  DATA 02,05
0A186:  DATA A0,25
0A188:  DATA 06,02
0A18A:  DATA 05,A4
0A18C:  DATA 2D,06
0A18E:  DATA 02,05
0A190:  DATA A8,36
0A192:  DATA 06,89
0A194:  DATA 05,AC
0A196:  DATA 67,72
0A198:  DATA 00,67
0A19A:  DATA 73,00
0A19C:  DATA 67,43
0A19E:  DATA 68,4D
0A1A0:  DATA 61,70
0A1A2:  DATA 00,73
0A1A4:  DATA 43,68
0A1A6:  DATA 4D,61
0A1A8:  DATA 70,00
0A1AA:  DATA 67,43
0A1AC:  DATA 68,4D
0A1AE:  DATA 6F,64
0A1B0:  DATA 65,00
0A1B2:  DATA 73,43
0A1B4:  DATA 68,4D
0A1B6:  DATA 6F,64
0A1B8:  DATA 65,00
0A1BA:  DATA 67,50
0A1BC:  DATA 49,44
0A1BE:  DATA 00,73
0A1C0:  DATA 50,49
0A1C2:  DATA 44,00
0A1C4:  DATA 67,53
0A1C6:  DATA 50,00
0A1C8:  DATA 73,53
0A1CA:  DATA 50,00
0A1CC:  DATA 67,53
0A1CE:  DATA 43,61
0A1D0:  DATA 6C,73
0A1D2:  DATA 00,67
0A1D4:  DATA 53,43
0A1D6:  DATA 61,6C
0A1D8:  DATA 00,73
0A1DA:  DATA 53,43
0A1DC:  DATA 61,6C
0A1DE:  DATA 00,67
0A1E0:  DATA 4D,43
0A1E2:  DATA 61,6C
0A1E4:  DATA 00,73
0A1E6:  DATA 4D,43
0A1E8:  DATA 61,6C
0A1EA:  DATA 00,67
0A1EC:  DATA 4D,6F
0A1EE:  DATA 6E,00
0A1F0:  DATA 67,50
0A1F2:  DATA 49,44
0A1F4:  DATA 64,61
0A1F6:  DATA 74,61
0A1F8:  DATA 00,67
0A1FA:  DATA 49,50
0A1FC:  DATA 64,61
0A1FE:  DATA 74,61
0A200:  DATA 00,67
0A202:  DATA 4D,61
0A204:  DATA 6E,4F
0A206:  DATA 50,00
0A208:  DATA 73,4D
0A20A:  DATA 61,6E
0A20C:  DATA 4F,50
0A20E:  DATA 00,73
0A210:  DATA 46,69
0A212:  DATA 6C,74
0A214:  DATA 4F,6E
0A216:  DATA 00,73
0A218:  DATA 46,69
0A21A:  DATA 6C,74
0A21C:  DATA 4F,66
0A21E:  DATA 66,04
0A220:  DATA C0,00
0A222:  DATA 32,80
0A224:  DATA 41,06
0A226:  DATA 01,49
0A228:  DATA 06,02
0A22A:  DATA 59,06
0A22C:  DATA 53,55
0A22E:  DATA 43,43
0A230:  DATA 45,53
0A232:  DATA 53,00
0A234:  DATA 49,4E
0A236:  DATA 56,41
0A238:  DATA 4C,49
0A23A:  DATA 44,20
0A23C:  DATA 43,4F
0A23E:  DATA 4D,4D
0A240:  DATA 41,4E
0A242:  DATA 44,00
0A244:  DATA 49,4E
0A246:  DATA 56,41
0A248:  DATA 4C,49
0A24A:  DATA 44,20
0A24C:  DATA 50,41
0A24E:  DATA 52,41
0A250:  DATA 4D,45
0A252:  DATA 54,45
0A254:  DATA 52,00
0A256:  DATA 00,00
0A258:  MOVLW  00
0A25A:  MOVWF  FF8
0A25C:  MOVLW  A0
0A25E:  MOVWF  FF7
0A260:  MOVLW  86
0A262:  MOVWF  FF6
0A264:  TBLRD*+
0A266:  MOVF   FF5,W
0A268:  MOVWF  00
0A26A:  XORLW  00
0A26C:  BZ    A294
0A26E:  TBLRD*+
0A270:  MOVF   FF5,W
0A272:  MOVWF  01
0A274:  BTFSC  FE8.7
0A276:  BRA    A282
0A278:  ANDLW  3F
0A27A:  MOVWF  FEA
0A27C:  TBLRD*+
0A27E:  MOVFF  FF5,FE9
0A282:  BTFSC  01.6
0A284:  TBLRD*+
0A286:  BTFSS  01.6
0A288:  TBLRD*+
0A28A:  MOVFF  FF5,FEE
0A28E:  DCFSNZ 00,F
0A290:  BRA    A264
0A292:  BRA    A286
0A294:  CLRF   FF8
0A296:  MOVLB  6
0A298:  CLRF   x6D
0A29A:  MOVLW  64
0A29C:  MOVWF  x6C
0A29E:  CLRF   x6F
0A2A0:  CLRF   x6E
0A2A2:  CLRF   x71
0A2A4:  CLRF   x70
.................... {
....................    int16 loopDelay = 100;
....................    int16 controlCounter = 0;
....................    int16 debugCounter = 0;
....................    
....................    IO_init();                    // set up IO 
0A2A6:  MOVLB  0
0A2A8:  GOTO   0358
....................    params_init();                // load parameters
0A2AC:  GOTO   0600
....................    monitor_init();               // initialize internal ADC for voltage and current telemetry
0A2B0:  GOTO   0A50
....................    control_init();               // initialize the output control DACs
0A2B4:  GOTO   0AE8
....................    serial_init();                // setup the serial port
0A2B8:  GOTO   0C86
....................    event_timer_init();
0A2BC:  GOTO   0CA8
.................... //!   setup_wdt(WDT_512MS);
....................    enable_interrupts(GLOBAL);
0A2C0:  MOVLW  C0
0A2C2:  IORWF  FF2,F
....................    
....................    while(TRUE)
....................    {
.................... //!      restart_wdt();
....................       internal_monitor_task();   //Update monitored voltage and currents etc
0A2C4:  GOTO   1080
....................       sensor_monitor_task();     //get magnetoresistive sensor data
0A2C8:  GOTO   43D0
....................       
....................       if (controlCounter >= 2){
0A2CC:  MOVLB  6
0A2CE:  MOVF   x6F,F
0A2D0:  BNZ   A2D8
0A2D2:  MOVF   x6E,W
0A2D4:  SUBLW  01
0A2D6:  BC    A2E6
....................          control_task();
0A2D8:  MOVLB  0
0A2DA:  GOTO   4F14
....................          controlCounter = 0;
0A2DE:  MOVLB  6
0A2E0:  CLRF   x6F
0A2E2:  CLRF   x6E
....................       }else controlCounter++;
0A2E4:  BRA    A2EC
0A2E6:  INCF   x6E,F
0A2E8:  BTFSC  FD8.2
0A2EA:  INCF   x6F,F
....................       
....................       serial_task();             //serial port
0A2EC:  MOVLB  0
0A2EE:  GOTO   4FE0
....................       
....................       #ifdef DEBUG_1
....................       if (debugCounter >= 0){
....................          static int8 ch = 0;
....................          fprintf(SERIAL, "#D0,CNT,%u,%.0f,%.0f\n", ch+1, adcVals[ch].sinCounts, adcVals[ch].cosCounts);
....................          fprintf(SERIAL, "#D0,POS,%u,%3.3f\n", ch+1, adcVals[ch].pReal);
....................          if ( dacVals[ch].invV ) fprintf(SERIAL, "#D0,OUT,%u,-,%Lu\n", ch+1, dacVals[ch].val);
....................          else                    fprintf(SERIAL, "#D0,OUT,%u,+,%Lu\n", ch+1, dacVals[ch].val);
....................          ch = !ch;
....................          debugCounter = 0;
....................       } else debugCounter++;
....................       #endif
....................       
....................       command_handler_task();    //execute commands
0A2F2:  BRA    9DD2
....................       
....................       delay_ms(loopDelay);
0A2F4:  MOVFF  66D,672
0A2F8:  MOVLB  6
0A2FA:  INCF   x72,F
0A2FC:  DECF   x72,F
0A2FE:  BTFSC  FD8.2
0A300:  BRA    A30E
0A302:  SETF   x78
0A304:  MOVLB  0
0A306:  CALL   03EE
0A30A:  MOVLB  6
0A30C:  BRA    A2FC
0A30E:  MOVFF  66C,678
0A312:  MOVLB  0
0A314:  CALL   03EE
0A318:  BRA    A2C4
....................    }
.................... }
0A31A:  BRA    A31A

Configuration Fuses:
   Word  1: FF8C   NOEXTOSC RSTOSC_HFINTRC_64MHZ NOCLKOUT CKS FCMEN
   Word  2: CF3F   MCLR NOPUT NOLPBOR NOBROWNOUT BORV19 ZCDDIS PPS1WAY NOSTVREN DEBUG NOXINST
   Word  3: FF9F   WDTSW NOWDT WDTWIN_SW WDTCLK_SW
   Word  4: DFFF   NOWRT NOWRTC NOWRTB NOWRTD SCANE NOLVP
   Word  5: FFFF   NOPROTECT NOCPD
   Word  6: FFFF   NOEBTR NOEBTRB

   Some fuses have been forced to be compatible with the ICD debugger.
