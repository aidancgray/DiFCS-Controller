CCS PCH C Compiler, Version 5.117, 2138               12-Dec-25 16:18

               Filename:   C:\Users\Aidan\Documents\GitHub\DiFCS-Controller\src\main.lst

               ROM used:   43790 bytes (67%)
                           Largest free fragment is 21744
               RAM used:   1798 (50%) at main() level
                           1909 (53%) worst case
               Stack used: 6 locations (4 in main + 2 for interrupts)
               Stack size: 31

*
00000:  NOP   
00002:  GOTO   A314
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  MOVLB  E
00056:  BTFSS  xC0.5
00058:  GOTO   0062
0005C:  BTFSC  xC8.5
0005E:  GOTO   010C
00062:  BTFSS  xC1.0
00064:  GOTO   006E
00068:  BTFSC  xC9.0
0006A:  GOTO   0298
0006E:  MOVFF  0E,00
00072:  MOVFF  0F,01
00076:  MOVFF  10,02
0007A:  MOVFF  11,03
0007E:  MOVFF  0C,FE9
00082:  MOVFF  07,FEA
00086:  BSF    07.7
00088:  MOVFF  08,FE1
0008C:  MOVFF  09,FE2
00090:  MOVFF  0A,FD9
00094:  MOVFF  0B,FDA
00098:  MOVFF  12,FF3
0009C:  MOVFF  13,FF4
000A0:  MOVFF  14,FFA
000A4:  MOVFF  15,FF5
000A8:  MOVFF  16,FF6
000AC:  MOVFF  17,FF7
000B0:  MOVF   04,W
000B2:  MOVFF  06,FE0
000B6:  MOVFF  05,FD8
000BA:  RETFIE 0
.................... #include <main.h>
.................... #include <18F46Q10.h>
.................... //////////// Standard Header file for the PIC18F46Q10 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F46Q10
000BC:  MOVFF  FEC,FFA
000C0:  MOVF   FED,F
000C2:  MOVFF  FEF,FE8
000C6:  MOVWF  FF9
000C8:  RETURN 0
*
0036C:  DATA 32,30
0036E:  DATA 32,35
00370:  DATA 31,32
00372:  DATA 30,38
00374:  DATA 00,00
00376:  DATA 30,30
00378:  DATA 30,30
0037A:  DATA 00,00
0037C:  DATA 25,64
0037E:  DATA 2C,4D
00380:  DATA 41,4E
00382:  DATA 55,41
00384:  DATA 4C,2C
00386:  DATA 00,00
00388:  DATA 25,64
0038A:  DATA 2C,4D
0038C:  DATA 41,47
0038E:  DATA 53,4E
00390:  DATA 53,2C
00392:  DATA 00,00
00394:  DATA 43,4E
00396:  DATA 54,2C
00398:  DATA 25,75
0039A:  DATA 2C,25
0039C:  DATA 2E,30
0039E:  DATA 66,2C
003A0:  DATA 25,2E
003A2:  DATA 30,66
003A4:  DATA 3B,00
003A6:  DATA 50,4F
003A8:  DATA 53,2C
003AA:  DATA 25,75
003AC:  DATA 2C,25
003AE:  DATA 33,2E
003B0:  DATA 33,66
003B2:  DATA 3B,00
003B4:  DATA 4F,55
003B6:  DATA 54,2C
003B8:  DATA 25,75
003BA:  DATA 2C,2D
003BC:  DATA 2C,25
003BE:  DATA 4C,75
003C0:  DATA 3B,00
003C2:  DATA 4F,55
003C4:  DATA 54,2C
003C6:  DATA 25,75
003C8:  DATA 2C,2B
003CA:  DATA 2C,25
003CC:  DATA 4C,75
003CE:  DATA 3B,00
*
00714:  ADDWF  FE8,W
00716:  CLRF   FF7
00718:  RLCF   FF7,F
0071A:  ADDLW  2F
0071C:  MOVWF  FF6
0071E:  MOVLW  07
00720:  ADDWFC FF7,F
00722:  TBLRD*-
00724:  MOVF   FF5,W
00726:  MOVWF  FFA
00728:  TBLRD*
0072A:  MOVF   FF5,W
0072C:  MOVWF  FF9
0072E:  DATA DE,06
00730:  DATA E8,06
00732:  DATA F2,06
00734:  DATA FC,06
*
008A6:  MOVLB  7
008A8:  MOVF   x41,W
008AA:  MULWF  x43
008AC:  MOVFF  FF3,01
008B0:  MOVFF  FF4,00
008B4:  MULWF  x44
008B6:  MOVF   FF3,W
008B8:  ADDWF  00,F
008BA:  MOVF   x42,W
008BC:  MULWF  x43
008BE:  MOVF   FF3,W
008C0:  ADDWFC 00,W
008C2:  MOVWF  02
008C4:  MOVLB  0
008C6:  RETURN 0
008C8:  MOVLB  7
008CA:  MOVF   x3B,W
008CC:  CLRF   01
008CE:  SUBWF  x3A,W
008D0:  BC    08D8
008D2:  MOVFF  73A,00
008D6:  BRA    08F0
008D8:  CLRF   00
008DA:  MOVLW  08
008DC:  MOVWF  x3C
008DE:  RLCF   x3A,F
008E0:  RLCF   00,F
008E2:  MOVF   x3B,W
008E4:  SUBWF  00,W
008E6:  BTFSC  FD8.0
008E8:  MOVWF  00
008EA:  RLCF   01,F
008EC:  DECFSZ x3C,F
008EE:  BRA    08DE
008F0:  MOVLB  0
008F2:  RETURN 0
*
00D5A:  MOVLW  8E
00D5C:  MOVWF  00
00D5E:  MOVFF  74B,01
00D62:  MOVFF  74A,02
00D66:  CLRF   03
00D68:  MOVF   01,F
00D6A:  BNZ   0D7E
00D6C:  MOVFF  02,01
00D70:  CLRF   02
00D72:  MOVLW  08
00D74:  SUBWF  00,F
00D76:  MOVF   01,F
00D78:  BNZ   0D7E
00D7A:  CLRF   00
00D7C:  BRA    0D8E
00D7E:  BCF    FD8.0
00D80:  BTFSC  01.7
00D82:  BRA    0D8C
00D84:  RLCF   02,F
00D86:  RLCF   01,F
00D88:  DECF   00,F
00D8A:  BRA    0D7E
00D8C:  BCF    01.7
00D8E:  RETURN 0
00D90:  MOVLB  7
00D92:  MOVF   x50,W
00D94:  BTFSC  FD8.2
00D96:  BRA    0E7A
00D98:  MOVWF  00
00D9A:  MOVF   x54,W
00D9C:  BTFSC  FD8.2
00D9E:  BRA    0E7A
00DA0:  ADDWF  00,F
00DA2:  BNC   0DAC
00DA4:  MOVLW  81
00DA6:  ADDWF  00,F
00DA8:  BC    0E7A
00DAA:  BRA    0DB4
00DAC:  MOVLW  7F
00DAE:  SUBWF  00,F
00DB0:  BNC   0E7A
00DB2:  BZ    0E7A
00DB4:  MOVFF  751,758
00DB8:  MOVF   x55,W
00DBA:  XORWF  x58,F
00DBC:  BSF    x51.7
00DBE:  BSF    x55.7
00DC0:  MOVF   x53,W
00DC2:  MULWF  x57
00DC4:  MOVFF  FF4,75A
00DC8:  MOVF   x52,W
00DCA:  MULWF  x56
00DCC:  MOVFF  FF4,03
00DD0:  MOVFF  FF3,759
00DD4:  MULWF  x57
00DD6:  MOVF   FF3,W
00DD8:  ADDWF  x5A,F
00DDA:  MOVF   FF4,W
00DDC:  ADDWFC x59,F
00DDE:  MOVLW  00
00DE0:  ADDWFC 03,F
00DE2:  MOVF   x53,W
00DE4:  MULWF  x56
00DE6:  MOVF   FF3,W
00DE8:  ADDWF  x5A,F
00DEA:  MOVF   FF4,W
00DEC:  ADDWFC x59,F
00DEE:  MOVLW  00
00DF0:  CLRF   02
00DF2:  ADDWFC 03,F
00DF4:  ADDWFC 02,F
00DF6:  MOVF   x51,W
00DF8:  MULWF  x57
00DFA:  MOVF   FF3,W
00DFC:  ADDWF  x59,F
00DFE:  MOVF   FF4,W
00E00:  ADDWFC 03,F
00E02:  MOVLW  00
00E04:  ADDWFC 02,F
00E06:  MOVF   x51,W
00E08:  MULWF  x56
00E0A:  MOVF   FF3,W
00E0C:  ADDWF  03,F
00E0E:  MOVF   FF4,W
00E10:  ADDWFC 02,F
00E12:  MOVLW  00
00E14:  CLRF   01
00E16:  ADDWFC 01,F
00E18:  MOVF   x53,W
00E1A:  MULWF  x55
00E1C:  MOVF   FF3,W
00E1E:  ADDWF  x59,F
00E20:  MOVF   FF4,W
00E22:  ADDWFC 03,F
00E24:  MOVLW  00
00E26:  ADDWFC 02,F
00E28:  ADDWFC 01,F
00E2A:  MOVF   x52,W
00E2C:  MULWF  x55
00E2E:  MOVF   FF3,W
00E30:  ADDWF  03,F
00E32:  MOVF   FF4,W
00E34:  ADDWFC 02,F
00E36:  MOVLW  00
00E38:  ADDWFC 01,F
00E3A:  MOVF   x51,W
00E3C:  MULWF  x55
00E3E:  MOVF   FF3,W
00E40:  ADDWF  02,F
00E42:  MOVF   FF4,W
00E44:  ADDWFC 01,F
00E46:  INCF   00,F
00E48:  BTFSC  01.7
00E4A:  BRA    0E56
00E4C:  RLCF   x59,F
00E4E:  RLCF   03,F
00E50:  RLCF   02,F
00E52:  RLCF   01,F
00E54:  DECF   00,F
00E56:  MOVLW  00
00E58:  BTFSS  x59.7
00E5A:  BRA    0E70
00E5C:  INCF   03,F
00E5E:  ADDWFC 02,F
00E60:  ADDWFC 01,F
00E62:  MOVF   01,W
00E64:  BNZ   0E70
00E66:  MOVF   02,W
00E68:  BNZ   0E70
00E6A:  MOVF   03,W
00E6C:  BNZ   0E70
00E6E:  INCF   00,F
00E70:  BTFSC  x58.7
00E72:  BSF    01.7
00E74:  BTFSS  x58.7
00E76:  BCF    01.7
00E78:  BRA    0E82
00E7A:  CLRF   00
00E7C:  CLRF   01
00E7E:  CLRF   02
00E80:  CLRF   03
00E82:  MOVLB  0
00E84:  RETURN 0
00E86:  MOVLW  80
00E88:  BTFSS  FD8.1
00E8A:  BRA    0E90
00E8C:  MOVLB  7
00E8E:  XORWF  x4F,F
00E90:  MOVLB  7
00E92:  CLRF   x54
00E94:  CLRF   x55
00E96:  MOVFF  74B,753
00E9A:  MOVF   x4F,W
00E9C:  XORWF  x53,F
00E9E:  MOVF   x4A,W
00EA0:  BTFSC  FD8.2
00EA2:  BRA    1062
00EA4:  MOVWF  x52
00EA6:  MOVWF  00
00EA8:  MOVF   x4E,W
00EAA:  BTFSC  FD8.2
00EAC:  BRA    1074
00EAE:  SUBWF  x52,F
00EB0:  BTFSC  FD8.2
00EB2:  BRA    0FBA
00EB4:  BNC   0F32
00EB6:  MOVFF  74F,758
00EBA:  BSF    x58.7
00EBC:  MOVFF  750,757
00EC0:  MOVFF  751,756
00EC4:  CLRF   x55
00EC6:  BCF    FD8.0
00EC8:  RRCF   x58,F
00ECA:  RRCF   x57,F
00ECC:  RRCF   x56,F
00ECE:  RRCF   x55,F
00ED0:  DECFSZ x52,F
00ED2:  BRA    0EC4
00ED4:  BTFSS  x53.7
00ED6:  BRA    0EDE
00ED8:  BSF    x54.0
00EDA:  BRA    109C
00EDC:  BCF    x54.0
00EDE:  BCF    x52.0
00EE0:  BSF    x54.4
00EE2:  MOVLW  07
00EE4:  MOVWF  FEA
00EE6:  MOVLW  4D
00EE8:  MOVWF  FE9
00EEA:  BRA    10C2
00EEC:  BCF    x54.4
00EEE:  BTFSC  x53.7
00EF0:  BRA    0F06
00EF2:  BTFSS  x52.0
00EF4:  BRA    0F1C
00EF6:  RRCF   x58,F
00EF8:  RRCF   x57,F
00EFA:  RRCF   x56,F
00EFC:  RRCF   x55,F
00EFE:  INCF   00,F
00F00:  BTFSC  FD8.2
00F02:  BRA    1092
00F04:  BRA    0F1C
00F06:  BTFSC  x58.7
00F08:  BRA    0F22
00F0A:  BCF    FD8.0
00F0C:  RLCF   x55,F
00F0E:  RLCF   x56,F
00F10:  RLCF   x57,F
00F12:  RLCF   x58,F
00F14:  DECF   00,F
00F16:  BTFSC  FD8.2
00F18:  BRA    1092
00F1A:  BRA    0F06
00F1C:  BSF    x54.6
00F1E:  BRA    0FFA
00F20:  BCF    x54.6
00F22:  MOVFF  74B,753
00F26:  BTFSS  x4B.7
00F28:  BRA    0F2E
00F2A:  BSF    x58.7
00F2C:  BRA    1084
00F2E:  BCF    x58.7
00F30:  BRA    1084
00F32:  MOVFF  74E,752
00F36:  MOVFF  74E,00
00F3A:  MOVF   x4A,W
00F3C:  SUBWF  x52,F
00F3E:  MOVFF  74B,758
00F42:  BSF    x58.7
00F44:  MOVFF  74C,757
00F48:  MOVFF  74D,756
00F4C:  CLRF   x55
00F4E:  BCF    FD8.0
00F50:  RRCF   x58,F
00F52:  RRCF   x57,F
00F54:  RRCF   x56,F
00F56:  RRCF   x55,F
00F58:  DECFSZ x52,F
00F5A:  BRA    0F4C
00F5C:  BTFSS  x53.7
00F5E:  BRA    0F66
00F60:  BSF    x54.1
00F62:  BRA    109C
00F64:  BCF    x54.1
00F66:  BCF    x52.0
00F68:  BSF    x54.5
00F6A:  MOVLW  07
00F6C:  MOVWF  FEA
00F6E:  MOVLW  51
00F70:  MOVWF  FE9
00F72:  BRA    10C2
00F74:  BCF    x54.5
00F76:  BTFSC  x53.7
00F78:  BRA    0F8E
00F7A:  BTFSS  x52.0
00F7C:  BRA    0FA4
00F7E:  RRCF   x58,F
00F80:  RRCF   x57,F
00F82:  RRCF   x56,F
00F84:  RRCF   x55,F
00F86:  INCF   00,F
00F88:  BTFSC  FD8.2
00F8A:  BRA    1092
00F8C:  BRA    0FA4
00F8E:  BTFSC  x58.7
00F90:  BRA    0FAA
00F92:  BCF    FD8.0
00F94:  RLCF   x55,F
00F96:  RLCF   x56,F
00F98:  RLCF   x57,F
00F9A:  RLCF   x58,F
00F9C:  DECF   00,F
00F9E:  BTFSC  FD8.2
00FA0:  BRA    1092
00FA2:  BRA    0F8E
00FA4:  BSF    x54.7
00FA6:  BRA    0FFA
00FA8:  BCF    x54.7
00FAA:  MOVFF  74F,753
00FAE:  BTFSS  x4F.7
00FB0:  BRA    0FB6
00FB2:  BSF    x58.7
00FB4:  BRA    1084
00FB6:  BCF    x58.7
00FB8:  BRA    1084
00FBA:  MOVFF  74F,758
00FBE:  BSF    x58.7
00FC0:  MOVFF  750,757
00FC4:  MOVFF  751,756
00FC8:  BTFSS  x53.7
00FCA:  BRA    0FD4
00FCC:  BCF    x58.7
00FCE:  BSF    x54.2
00FD0:  BRA    109C
00FD2:  BCF    x54.2
00FD4:  CLRF   x55
00FD6:  BCF    x52.0
00FD8:  MOVLW  07
00FDA:  MOVWF  FEA
00FDC:  MOVLW  4D
00FDE:  MOVWF  FE9
00FE0:  BRA    10C2
00FE2:  BTFSC  x53.7
00FE4:  BRA    101E
00FE6:  MOVFF  74B,753
00FEA:  BTFSS  x52.0
00FEC:  BRA    0FFA
00FEE:  RRCF   x58,F
00FF0:  RRCF   x57,F
00FF2:  RRCF   x56,F
00FF4:  RRCF   x55,F
00FF6:  INCF   00,F
00FF8:  BZ    1092
00FFA:  BTFSS  x55.7
00FFC:  BRA    1014
00FFE:  INCF   x56,F
01000:  BNZ   1014
01002:  INCF   x57,F
01004:  BNZ   1014
01006:  INCF   x58,F
01008:  BNZ   1014
0100A:  RRCF   x58,F
0100C:  RRCF   x57,F
0100E:  RRCF   x56,F
01010:  INCF   00,F
01012:  BZ    1092
01014:  BTFSC  x54.6
01016:  BRA    0F20
01018:  BTFSC  x54.7
0101A:  BRA    0FA8
0101C:  BRA    1056
0101E:  MOVLW  80
01020:  XORWF  x58,F
01022:  BTFSS  x58.7
01024:  BRA    102E
01026:  BRA    109C
01028:  MOVFF  74F,753
0102C:  BRA    1042
0102E:  MOVFF  74B,753
01032:  MOVF   x58,F
01034:  BNZ   1042
01036:  MOVF   x57,F
01038:  BNZ   1042
0103A:  MOVF   x56,F
0103C:  BNZ   1042
0103E:  CLRF   00
01040:  BRA    1084
01042:  BTFSC  x58.7
01044:  BRA    1056
01046:  BCF    FD8.0
01048:  RLCF   x55,F
0104A:  RLCF   x56,F
0104C:  RLCF   x57,F
0104E:  RLCF   x58,F
01050:  DECFSZ 00,F
01052:  BRA    1042
01054:  BRA    1092
01056:  BTFSS  x53.7
01058:  BRA    105E
0105A:  BSF    x58.7
0105C:  BRA    1084
0105E:  BCF    x58.7
01060:  BRA    1084
01062:  MOVFF  74E,00
01066:  MOVFF  74F,758
0106A:  MOVFF  750,757
0106E:  MOVFF  751,756
01072:  BRA    1084
01074:  MOVFF  74A,00
01078:  MOVFF  74B,758
0107C:  MOVFF  74C,757
01080:  MOVFF  74D,756
01084:  MOVFF  758,01
01088:  MOVFF  757,02
0108C:  MOVFF  756,03
01090:  BRA    10FA
01092:  CLRF   00
01094:  CLRF   01
01096:  CLRF   02
01098:  CLRF   03
0109A:  BRA    10FA
0109C:  CLRF   x55
0109E:  COMF   x56,F
010A0:  COMF   x57,F
010A2:  COMF   x58,F
010A4:  COMF   x55,F
010A6:  INCF   x55,F
010A8:  BNZ   10B4
010AA:  INCF   x56,F
010AC:  BNZ   10B4
010AE:  INCF   x57,F
010B0:  BNZ   10B4
010B2:  INCF   x58,F
010B4:  BTFSC  x54.0
010B6:  BRA    0EDC
010B8:  BTFSC  x54.1
010BA:  BRA    0F64
010BC:  BTFSC  x54.2
010BE:  BRA    0FD2
010C0:  BRA    1028
010C2:  MOVF   FEF,W
010C4:  ADDWF  x56,F
010C6:  BNC   10D2
010C8:  INCF   x57,F
010CA:  BNZ   10D2
010CC:  INCF   x58,F
010CE:  BTFSC  FD8.2
010D0:  BSF    x52.0
010D2:  MOVF   FED,F
010D4:  MOVF   FEF,W
010D6:  ADDWF  x57,F
010D8:  BNC   10E0
010DA:  INCF   x58,F
010DC:  BTFSC  FD8.2
010DE:  BSF    x52.0
010E0:  MOVF   FED,F
010E2:  MOVF   FEF,W
010E4:  BTFSC  FEF.7
010E6:  BRA    10EA
010E8:  XORLW  80
010EA:  ADDWF  x58,F
010EC:  BTFSC  FD8.0
010EE:  BSF    x52.0
010F0:  BTFSC  x54.4
010F2:  BRA    0EEC
010F4:  BTFSC  x54.5
010F6:  BRA    0F74
010F8:  BRA    0FE2
010FA:  MOVLB  0
010FC:  RETURN 0
*
01654:  ADDWF  FE8,W
01656:  CLRF   FF7
01658:  RLCF   FF7,F
0165A:  ADDLW  6F
0165C:  MOVWF  FF6
0165E:  MOVLW  16
01660:  ADDWFC FF7,F
01662:  TBLRD*-
01664:  MOVF   FF5,W
01666:  MOVWF  FFA
01668:  TBLRD*
0166A:  MOVF   FF5,W
0166C:  MOVWF  FF9
0166E:  DATA 16,11
01670:  DATA D6,11
01672:  DATA 96,12
01674:  DATA 56,13
01676:  DATA 16,14
01678:  DATA D6,14
0167A:  DATA 96,15
0167C:  BTFSC  FD8.1
0167E:  BRA    1688
01680:  MOVLW  07
01682:  MOVWF  FEA
01684:  MOVLW  39
01686:  MOVWF  FE9
01688:  MOVLB  7
0168A:  MOVF   x34,W
0168C:  XORWF  x38,W
0168E:  ANDLW  80
01690:  MOVWF  x3E
01692:  BTFSS  x34.7
01694:  BRA    16AC
01696:  COMF   x31,F
01698:  COMF   x32,F
0169A:  COMF   x33,F
0169C:  COMF   x34,F
0169E:  INCF   x31,F
016A0:  BTFSC  FD8.2
016A2:  INCF   x32,F
016A4:  BTFSC  FD8.2
016A6:  INCF   x33,F
016A8:  BTFSC  FD8.2
016AA:  INCF   x34,F
016AC:  BTFSS  x38.7
016AE:  BRA    16C6
016B0:  COMF   x35,F
016B2:  COMF   x36,F
016B4:  COMF   x37,F
016B6:  COMF   x38,F
016B8:  INCF   x35,F
016BA:  BTFSC  FD8.2
016BC:  INCF   x36,F
016BE:  BTFSC  FD8.2
016C0:  INCF   x37,F
016C2:  BTFSC  FD8.2
016C4:  INCF   x38,F
016C6:  CLRF   00
016C8:  CLRF   01
016CA:  CLRF   02
016CC:  CLRF   03
016CE:  CLRF   x39
016D0:  CLRF   x3A
016D2:  CLRF   x3B
016D4:  CLRF   x3C
016D6:  MOVF   x38,W
016D8:  IORWF  x37,W
016DA:  IORWF  x36,W
016DC:  IORWF  x35,W
016DE:  BZ    1738
016E0:  MOVLW  20
016E2:  MOVWF  x3D
016E4:  BCF    FD8.0
016E6:  RLCF   x31,F
016E8:  RLCF   x32,F
016EA:  RLCF   x33,F
016EC:  RLCF   x34,F
016EE:  RLCF   x39,F
016F0:  RLCF   x3A,F
016F2:  RLCF   x3B,F
016F4:  RLCF   x3C,F
016F6:  MOVF   x38,W
016F8:  SUBWF  x3C,W
016FA:  BNZ   170C
016FC:  MOVF   x37,W
016FE:  SUBWF  x3B,W
01700:  BNZ   170C
01702:  MOVF   x36,W
01704:  SUBWF  x3A,W
01706:  BNZ   170C
01708:  MOVF   x35,W
0170A:  SUBWF  x39,W
0170C:  BNC   172C
0170E:  MOVF   x35,W
01710:  SUBWF  x39,F
01712:  MOVF   x36,W
01714:  BTFSS  FD8.0
01716:  INCFSZ x36,W
01718:  SUBWF  x3A,F
0171A:  MOVF   x37,W
0171C:  BTFSS  FD8.0
0171E:  INCFSZ x37,W
01720:  SUBWF  x3B,F
01722:  MOVF   x38,W
01724:  BTFSS  FD8.0
01726:  INCFSZ x38,W
01728:  SUBWF  x3C,F
0172A:  BSF    FD8.0
0172C:  RLCF   00,F
0172E:  RLCF   01,F
01730:  RLCF   02,F
01732:  RLCF   03,F
01734:  DECFSZ x3D,F
01736:  BRA    16E4
01738:  BTFSS  x3E.7
0173A:  BRA    1752
0173C:  COMF   00,F
0173E:  COMF   01,F
01740:  COMF   02,F
01742:  COMF   03,F
01744:  INCF   00,F
01746:  BTFSC  FD8.2
01748:  INCF   01,F
0174A:  BTFSC  FD8.2
0174C:  INCF   02,F
0174E:  BTFSC  FD8.2
01750:  INCF   03,F
01752:  MOVFF  739,FEF
01756:  MOVFF  73A,FEC
0175A:  MOVFF  73B,FEC
0175E:  MOVFF  73C,FEC
01762:  MOVLB  0
01764:  RETURN 0
*
01CC2:  MOVLW  B6
01CC4:  MOVWF  00
01CC6:  CLRF   03
01CC8:  CLRF   02
01CCA:  CLRF   01
01CCC:  MOVLB  7
01CCE:  BCF    x14.0
01CD0:  BTFSS  x13.7
01CD2:  BRA    1CEC
01CD4:  BSF    x14.0
01CD6:  COMF   x10,F
01CD8:  COMF   x11,F
01CDA:  COMF   x12,F
01CDC:  COMF   x13,F
01CDE:  INCF   x10,F
01CE0:  BNZ   1CEC
01CE2:  INCF   x11,F
01CE4:  BNZ   1CEC
01CE6:  INCF   x12,F
01CE8:  BTFSC  FD8.2
01CEA:  INCF   x13,F
01CEC:  MOVF   x10,W
01CEE:  IORWF  x11,W
01CF0:  IORWF  x12,W
01CF2:  IORWF  x13,W
01CF4:  BNZ   1CFA
01CF6:  CLRF   00
01CF8:  BRA    1D18
01CFA:  BCF    FD8.0
01CFC:  BTFSC  01.7
01CFE:  BRA    1D12
01D00:  RLCF   x10,F
01D02:  RLCF   x11,F
01D04:  RLCF   x12,F
01D06:  RLCF   x13,F
01D08:  RLCF   03,F
01D0A:  RLCF   02,F
01D0C:  RLCF   01,F
01D0E:  DECFSZ 00,F
01D10:  BRA    1CFA
01D12:  BCF    01.7
01D14:  BTFSC  x14.0
01D16:  BSF    01.7
01D18:  MOVLB  0
01D1A:  RETURN 0
01D1C:  MOVFF  747,74E
01D20:  MOVLB  7
01D22:  MOVF   x4B,W
01D24:  XORWF  x4E,F
01D26:  BTFSS  x4E.7
01D28:  BRA    1D34
01D2A:  BCF    FD8.2
01D2C:  BCF    FD8.0
01D2E:  BTFSC  x47.7
01D30:  BSF    FD8.0
01D32:  BRA    1D92
01D34:  MOVFF  747,74E
01D38:  MOVFF  74A,74F
01D3C:  MOVF   x46,W
01D3E:  SUBWF  x4F,F
01D40:  BZ    1D4E
01D42:  BTFSS  x4E.7
01D44:  BRA    1D92
01D46:  MOVF   FD8,W
01D48:  XORLW  01
01D4A:  MOVWF  FD8
01D4C:  BRA    1D92
01D4E:  MOVFF  74B,74F
01D52:  MOVF   x47,W
01D54:  SUBWF  x4F,F
01D56:  BZ    1D64
01D58:  BTFSS  x4E.7
01D5A:  BRA    1D92
01D5C:  MOVF   FD8,W
01D5E:  XORLW  01
01D60:  MOVWF  FD8
01D62:  BRA    1D92
01D64:  MOVFF  74C,74F
01D68:  MOVF   x48,W
01D6A:  SUBWF  x4F,F
01D6C:  BZ    1D7A
01D6E:  BTFSS  x4E.7
01D70:  BRA    1D92
01D72:  MOVF   FD8,W
01D74:  XORLW  01
01D76:  MOVWF  FD8
01D78:  BRA    1D92
01D7A:  MOVFF  74D,74F
01D7E:  MOVF   x49,W
01D80:  SUBWF  x4F,F
01D82:  BZ    1D90
01D84:  BTFSS  x4E.7
01D86:  BRA    1D92
01D88:  MOVF   FD8,W
01D8A:  XORLW  01
01D8C:  MOVWF  FD8
01D8E:  BRA    1D92
01D90:  BCF    FD8.0
01D92:  MOVLB  0
01D94:  RETURN 0
01D96:  MOVLB  7
01D98:  MOVF   x3F,W
01D9A:  BTFSC  FD8.2
01D9C:  BRA    1EE8
01D9E:  MOVWF  x4B
01DA0:  MOVF   x43,W
01DA2:  BTFSC  FD8.2
01DA4:  BRA    1EE8
01DA6:  SUBWF  x4B,F
01DA8:  BNC   1DB4
01DAA:  MOVLW  7F
01DAC:  ADDWF  x4B,F
01DAE:  BTFSC  FD8.0
01DB0:  BRA    1EE8
01DB2:  BRA    1DC0
01DB4:  MOVLW  81
01DB6:  SUBWF  x4B,F
01DB8:  BTFSS  FD8.0
01DBA:  BRA    1EE8
01DBC:  BTFSC  FD8.2
01DBE:  BRA    1EE8
01DC0:  MOVFF  74B,00
01DC4:  CLRF   01
01DC6:  CLRF   02
01DC8:  CLRF   03
01DCA:  CLRF   x4A
01DCC:  MOVFF  740,749
01DD0:  BSF    x49.7
01DD2:  MOVFF  741,748
01DD6:  MOVFF  742,747
01DDA:  MOVLW  19
01DDC:  MOVWF  x4B
01DDE:  MOVF   x46,W
01DE0:  SUBWF  x47,F
01DE2:  BC    1DFE
01DE4:  MOVLW  01
01DE6:  SUBWF  x48,F
01DE8:  BC    1DFE
01DEA:  SUBWF  x49,F
01DEC:  BC    1DFE
01DEE:  SUBWF  x4A,F
01DF0:  BC    1DFE
01DF2:  INCF   x4A,F
01DF4:  INCF   x49,F
01DF6:  INCF   x48,F
01DF8:  MOVF   x46,W
01DFA:  ADDWF  x47,F
01DFC:  BRA    1E4E
01DFE:  MOVF   x45,W
01E00:  SUBWF  x48,F
01E02:  BC    1E28
01E04:  MOVLW  01
01E06:  SUBWF  x49,F
01E08:  BC    1E28
01E0A:  SUBWF  x4A,F
01E0C:  BC    1E28
01E0E:  INCF   x4A,F
01E10:  INCF   x49,F
01E12:  MOVF   x45,W
01E14:  ADDWF  x48,F
01E16:  MOVF   x46,W
01E18:  ADDWF  x47,F
01E1A:  BNC   1E4E
01E1C:  INCF   x48,F
01E1E:  BNZ   1E4E
01E20:  INCF   x49,F
01E22:  BNZ   1E4E
01E24:  INCF   x4A,F
01E26:  BRA    1E4E
01E28:  MOVF   x44,W
01E2A:  IORLW  80
01E2C:  SUBWF  x49,F
01E2E:  BC    1E4C
01E30:  MOVLW  01
01E32:  SUBWF  x4A,F
01E34:  BC    1E4C
01E36:  INCF   x4A,F
01E38:  MOVF   x44,W
01E3A:  IORLW  80
01E3C:  ADDWF  x49,F
01E3E:  MOVF   x45,W
01E40:  ADDWF  x48,F
01E42:  BNC   1E16
01E44:  INCF   x49,F
01E46:  BNZ   1E16
01E48:  INCF   x4A,F
01E4A:  BRA    1E16
01E4C:  BSF    03.0
01E4E:  DECFSZ x4B,F
01E50:  BRA    1E54
01E52:  BRA    1E6A
01E54:  BCF    FD8.0
01E56:  RLCF   x47,F
01E58:  RLCF   x48,F
01E5A:  RLCF   x49,F
01E5C:  RLCF   x4A,F
01E5E:  BCF    FD8.0
01E60:  RLCF   03,F
01E62:  RLCF   02,F
01E64:  RLCF   01,F
01E66:  RLCF   x4C,F
01E68:  BRA    1DDE
01E6A:  BTFSS  x4C.0
01E6C:  BRA    1E7A
01E6E:  BCF    FD8.0
01E70:  RRCF   01,F
01E72:  RRCF   02,F
01E74:  RRCF   03,F
01E76:  RRCF   x4C,F
01E78:  BRA    1E7E
01E7A:  DECF   00,F
01E7C:  BZ    1EE8
01E7E:  BTFSC  x4C.7
01E80:  BRA    1EBE
01E82:  BCF    FD8.0
01E84:  RLCF   x47,F
01E86:  RLCF   x48,F
01E88:  RLCF   x49,F
01E8A:  RLCF   x4A,F
01E8C:  MOVF   x46,W
01E8E:  SUBWF  x47,F
01E90:  BC    1EA0
01E92:  MOVLW  01
01E94:  SUBWF  x48,F
01E96:  BC    1EA0
01E98:  SUBWF  x49,F
01E9A:  BC    1EA0
01E9C:  SUBWF  x4A,F
01E9E:  BNC   1ED4
01EA0:  MOVF   x45,W
01EA2:  SUBWF  x48,F
01EA4:  BC    1EB0
01EA6:  MOVLW  01
01EA8:  SUBWF  x49,F
01EAA:  BC    1EB0
01EAC:  SUBWF  x4A,F
01EAE:  BNC   1ED4
01EB0:  MOVF   x44,W
01EB2:  IORLW  80
01EB4:  SUBWF  x49,F
01EB6:  BC    1EBE
01EB8:  MOVLW  01
01EBA:  SUBWF  x4A,F
01EBC:  BNC   1ED4
01EBE:  INCF   03,F
01EC0:  BNZ   1ED4
01EC2:  INCF   02,F
01EC4:  BNZ   1ED4
01EC6:  INCF   01,F
01EC8:  BNZ   1ED4
01ECA:  INCF   00,F
01ECC:  BZ    1EE8
01ECE:  RRCF   01,F
01ED0:  RRCF   02,F
01ED2:  RRCF   03,F
01ED4:  MOVFF  740,74B
01ED8:  MOVF   x44,W
01EDA:  XORWF  x4B,F
01EDC:  BTFSS  x4B.7
01EDE:  BRA    1EE4
01EE0:  BSF    01.7
01EE2:  BRA    1EF0
01EE4:  BCF    01.7
01EE6:  BRA    1EF0
01EE8:  CLRF   00
01EEA:  CLRF   01
01EEC:  CLRF   02
01EEE:  CLRF   03
01EF0:  MOVLB  0
01EF2:  RETURN 0
*
0269E:  ADDWF  FE8,W
026A0:  CLRF   FF7
026A2:  RLCF   FF7,F
026A4:  ADDLW  B9
026A6:  MOVWF  FF6
026A8:  MOVLW  26
026AA:  ADDWFC FF7,F
026AC:  TBLRD*-
026AE:  MOVF   FF5,W
026B0:  MOVWF  FFA
026B2:  TBLRD*
026B4:  MOVF   FF5,W
026B6:  MOVWF  FF9
026B8:  DATA A6,25
026BA:  DATA C0,25
026BC:  DATA 14,26
026BE:  DATA 78,26
026C0:  MOVLW  8E
026C2:  MOVWF  00
026C4:  MOVFF  73D,01
026C8:  MOVFF  73C,02
026CC:  CLRF   03
026CE:  BTFSS  01.7
026D0:  BRA    26DC
026D2:  COMF   01,F
026D4:  COMF   02,F
026D6:  INCF   02,F
026D8:  BNZ   26DC
026DA:  INCF   01,F
026DC:  MOVF   01,F
026DE:  BNZ   26F2
026E0:  MOVFF  02,01
026E4:  CLRF   02
026E6:  MOVLW  08
026E8:  SUBWF  00,F
026EA:  MOVF   01,F
026EC:  BNZ   26F2
026EE:  CLRF   00
026F0:  BRA    270E
026F2:  BCF    FD8.0
026F4:  BTFSC  01.7
026F6:  BRA    2700
026F8:  RLCF   02,F
026FA:  RLCF   01,F
026FC:  DECF   00,F
026FE:  BRA    26F2
02700:  MOVLB  7
02702:  BTFSS  x3D.7
02704:  BRA    270A
02706:  MOVLB  0
02708:  BRA    270E
0270A:  BCF    01.7
0270C:  MOVLB  0
0270E:  RETURN 0
02710:  MOVLW  8E
02712:  MOVWF  00
02714:  MOVLB  7
02716:  MOVF   x46,W
02718:  SUBWF  00,F
0271A:  MOVFF  747,02
0271E:  MOVFF  748,01
02722:  BSF    02.7
02724:  MOVF   00,F
02726:  BZ    273A
02728:  BCF    FD8.0
0272A:  MOVF   02,F
0272C:  BNZ   2732
0272E:  MOVF   01,F
02730:  BZ    273A
02732:  RRCF   02,F
02734:  RRCF   01,F
02736:  DECFSZ 00,F
02738:  BRA    2728
0273A:  BTFSS  x47.7
0273C:  BRA    2748
0273E:  COMF   01,F
02740:  COMF   02,F
02742:  INCF   01,F
02744:  BTFSC  FD8.2
02746:  INCF   02,F
02748:  MOVLB  0
0274A:  RETURN 0
*
04604:  MOVLB  7
04606:  MOVF   x0D,W
04608:  ANDLW  07
0460A:  MOVWF  00
0460C:  RRCF   x0D,W
0460E:  MOVWF  01
04610:  RRCF   01,F
04612:  RRCF   01,F
04614:  MOVLW  1F
04616:  ANDWF  01,F
04618:  MOVF   01,W
0461A:  ADDWF  x0E,W
0461C:  MOVWF  FE9
0461E:  MOVLW  00
04620:  ADDWFC x0F,W
04622:  MOVWF  FEA
04624:  MOVFF  FEF,01
04628:  INCF   00,F
0462A:  BRA    462E
0462C:  RRCF   01,F
0462E:  DECFSZ 00,F
04630:  BRA    462C
04632:  MOVLW  01
04634:  ANDWF  01,F
04636:  MOVLB  0
04638:  RETURN 0
*
05046:  MOVF   FEF,F
05048:  BZ    506E
0504A:  MOVFF  FEA,704
0504E:  MOVFF  FE9,703
05052:  MOVF   FEF,W
05054:  MOVLB  E
05056:  BTFSS  xC8.4
05058:  BRA    5056
0505A:  MOVWF  F99
0505C:  MOVFF  704,FEA
05060:  MOVFF  703,FE9
05064:  INCF   FE9,F
05066:  BTFSC  FD8.2
05068:  INCF   FEA,F
0506A:  MOVLB  0
0506C:  BRA    5046
0506E:  RETURN 0
*
055C0:  MOVFF  565,FEA
055C4:  MOVFF  564,FE9
055C8:  MOVFF  750,FEF
055CC:  INCF   FE9,F
055CE:  BTFSC  FD8.2
055D0:  INCF   FEA,F
055D2:  CLRF   FEF
055D4:  MOVLB  5
055D6:  INCF   x64,F
055D8:  BTFSC  FD8.2
055DA:  INCF   x65,F
055DC:  MOVLB  0
055DE:  RETURN 0
055E0:  TBLRD*+
055E2:  MOVFF  FF6,710
055E6:  MOVFF  FF7,711
055EA:  MOVFF  FF5,750
055EE:  RCALL  55C0
055F0:  MOVFF  710,FF6
055F4:  MOVFF  711,FF7
055F8:  MOVLB  7
055FA:  DECFSZ x0F,F
055FC:  BRA    5600
055FE:  BRA    5604
05600:  MOVLB  0
05602:  BRA    55E0
05604:  MOVLB  0
05606:  RETURN 0
05608:  MOVF   01,W
0560A:  MOVFF  706,73A
0560E:  MOVLW  64
05610:  MOVLB  7
05612:  MOVWF  x3B
05614:  MOVLB  0
05616:  CALL   08C8
0561A:  MOVFF  00,706
0561E:  MOVF   01,W
05620:  MOVLW  30
05622:  BNZ   5634
05624:  MOVLB  7
05626:  BTFSS  x07.1
05628:  BRA    5648
0562A:  BTFSC  x07.3
0562C:  BRA    5648
0562E:  BTFSC  x07.4
05630:  MOVLW  20
05632:  BRA    563C
05634:  MOVLB  7
05636:  BCF    x07.3
05638:  BCF    x07.4
0563A:  BSF    x07.0
0563C:  ADDWF  01,F
0563E:  MOVFF  01,750
05642:  MOVLB  0
05644:  RCALL  55C0
05646:  MOVLB  7
05648:  MOVFF  706,73A
0564C:  MOVLW  0A
0564E:  MOVWF  x3B
05650:  MOVLB  0
05652:  CALL   08C8
05656:  MOVFF  00,706
0565A:  MOVF   01,W
0565C:  MOVLW  30
0565E:  BNZ   5670
05660:  MOVLB  7
05662:  BTFSC  x07.3
05664:  BRA    567A
05666:  BTFSS  x07.0
05668:  BRA    567A
0566A:  BTFSC  x07.4
0566C:  MOVLW  20
0566E:  MOVLB  0
05670:  ADDWF  01,F
05672:  MOVFF  01,750
05676:  RCALL  55C0
05678:  MOVLB  7
0567A:  MOVLW  30
0567C:  ADDWF  x06,F
0567E:  MOVFF  706,750
05682:  MOVLB  0
05684:  RCALL  55C0
05686:  RETURN 0
05688:  MOVLB  7
0568A:  MOVF   x50,W
0568C:  SUBLW  B6
0568E:  MOVWF  x50
05690:  CLRF   03
05692:  MOVFF  751,754
05696:  BSF    x51.7
05698:  BCF    FD8.0
0569A:  RRCF   x51,F
0569C:  RRCF   x52,F
0569E:  RRCF   x53,F
056A0:  RRCF   03,F
056A2:  RRCF   02,F
056A4:  RRCF   01,F
056A6:  RRCF   00,F
056A8:  DECFSZ x50,F
056AA:  BRA    5698
056AC:  BTFSS  x54.7
056AE:  BRA    56C6
056B0:  COMF   00,F
056B2:  COMF   01,F
056B4:  COMF   02,F
056B6:  COMF   03,F
056B8:  INCF   00,F
056BA:  BTFSC  FD8.2
056BC:  INCF   01,F
056BE:  BTFSC  FD8.2
056C0:  INCF   02,F
056C2:  BTFSC  FD8.2
056C4:  INCF   03,F
056C6:  MOVLB  0
056C8:  RETURN 0
056CA:  BTFSC  FD8.1
056CC:  BRA    56D6
056CE:  MOVLW  07
056D0:  MOVWF  FEA
056D2:  MOVLW  58
056D4:  MOVWF  FE9
056D6:  CLRF   00
056D8:  CLRF   01
056DA:  CLRF   02
056DC:  CLRF   03
056DE:  MOVLB  7
056E0:  CLRF   x58
056E2:  CLRF   x59
056E4:  CLRF   x5A
056E6:  CLRF   x5B
056E8:  MOVF   x57,W
056EA:  IORWF  x56,W
056EC:  IORWF  x55,W
056EE:  IORWF  x54,W
056F0:  BZ    574A
056F2:  MOVLW  20
056F4:  MOVWF  x5C
056F6:  BCF    FD8.0
056F8:  RLCF   x50,F
056FA:  RLCF   x51,F
056FC:  RLCF   x52,F
056FE:  RLCF   x53,F
05700:  RLCF   x58,F
05702:  RLCF   x59,F
05704:  RLCF   x5A,F
05706:  RLCF   x5B,F
05708:  MOVF   x57,W
0570A:  SUBWF  x5B,W
0570C:  BNZ   571E
0570E:  MOVF   x56,W
05710:  SUBWF  x5A,W
05712:  BNZ   571E
05714:  MOVF   x55,W
05716:  SUBWF  x59,W
05718:  BNZ   571E
0571A:  MOVF   x54,W
0571C:  SUBWF  x58,W
0571E:  BNC   573E
05720:  MOVF   x54,W
05722:  SUBWF  x58,F
05724:  MOVF   x55,W
05726:  BTFSS  FD8.0
05728:  INCFSZ x55,W
0572A:  SUBWF  x59,F
0572C:  MOVF   x56,W
0572E:  BTFSS  FD8.0
05730:  INCFSZ x56,W
05732:  SUBWF  x5A,F
05734:  MOVF   x57,W
05736:  BTFSS  FD8.0
05738:  INCFSZ x57,W
0573A:  SUBWF  x5B,F
0573C:  BSF    FD8.0
0573E:  RLCF   00,F
05740:  RLCF   01,F
05742:  RLCF   02,F
05744:  RLCF   03,F
05746:  DECFSZ x5C,F
05748:  BRA    56F6
0574A:  MOVFF  758,FEF
0574E:  MOVFF  759,FEC
05752:  MOVFF  75A,FEC
05756:  MOVFF  75B,FEC
0575A:  MOVLB  0
0575C:  RETURN 0
0575E:  MOVF   FE9,W
05760:  MOVLB  7
05762:  MOVWF  x48
05764:  MOVF   x47,W
05766:  MOVWF  x4A
05768:  BZ    57A2
0576A:  MOVFF  746,753
0576E:  MOVFF  745,752
05772:  MOVFF  744,751
05776:  MOVFF  743,750
0577A:  CLRF   x57
0577C:  CLRF   x56
0577E:  MOVLW  20
05780:  MOVWF  x55
05782:  MOVLW  82
05784:  MOVWF  x54
05786:  MOVLB  0
05788:  CALL   0D90
0578C:  MOVFF  03,746
05790:  MOVFF  02,745
05794:  MOVFF  01,744
05798:  MOVFF  00,743
0579C:  MOVLB  7
0579E:  DECFSZ x4A,F
057A0:  BRA    576A
057A2:  MOVFF  746,753
057A6:  MOVFF  745,752
057AA:  MOVFF  744,751
057AE:  MOVFF  743,750
057B2:  MOVLB  0
057B4:  RCALL  5688
057B6:  MOVFF  03,746
057BA:  MOVFF  02,745
057BE:  MOVFF  01,744
057C2:  MOVFF  00,743
057C6:  MOVLB  7
057C8:  BTFSS  x46.7
057CA:  BRA    57E6
057CC:  DECF   x48,F
057CE:  BSF    x48.5
057D0:  COMF   x43,F
057D2:  COMF   x44,F
057D4:  COMF   x45,F
057D6:  COMF   x46,F
057D8:  INCF   x43,F
057DA:  BTFSC  FD8.2
057DC:  INCF   x44,F
057DE:  BTFSC  FD8.2
057E0:  INCF   x45,F
057E2:  BTFSC  FD8.2
057E4:  INCF   x46,F
057E6:  MOVLW  3B
057E8:  MOVWF  x4F
057EA:  MOVLW  9A
057EC:  MOVWF  x4E
057EE:  MOVLW  CA
057F0:  MOVWF  x4D
057F2:  CLRF   x4C
057F4:  MOVLW  0A
057F6:  MOVWF  x4A
057F8:  MOVF   x47,W
057FA:  BTFSC  FD8.2
057FC:  INCF   x48,F
057FE:  BSF    FD8.1
05800:  MOVLW  07
05802:  MOVWF  FEA
05804:  MOVLW  43
05806:  MOVWF  FE9
05808:  MOVFF  746,753
0580C:  MOVFF  745,752
05810:  MOVFF  744,751
05814:  MOVFF  743,750
05818:  MOVFF  74F,757
0581C:  MOVFF  74E,756
05820:  MOVFF  74D,755
05824:  MOVFF  74C,754
05828:  MOVLB  0
0582A:  RCALL  56CA
0582C:  MOVF   01,W
0582E:  MOVF   00,F
05830:  BNZ   5858
05832:  MOVLB  7
05834:  INCF   x47,W
05836:  SUBWF  x4A,W
05838:  BTFSS  FD8.2
0583A:  BRA    5840
0583C:  MOVLB  0
0583E:  BRA    5858
05840:  MOVF   x48,W
05842:  BZ    585E
05844:  ANDLW  0F
05846:  SUBWF  x4A,W
05848:  BZ    584C
0584A:  BC    58CC
0584C:  BTFSC  x48.7
0584E:  BRA    58CC
05850:  BTFSC  x48.6
05852:  BRA    585E
05854:  MOVLW  20
05856:  BRA    58C0
05858:  MOVLW  20
0585A:  MOVLB  7
0585C:  ANDWF  x48,F
0585E:  BTFSS  x48.5
05860:  BRA    587E
05862:  BCF    x48.5
05864:  MOVF   x47,W
05866:  BTFSS  FD8.2
05868:  DECF   x48,F
0586A:  MOVF   00,W
0586C:  MOVWF  x48
0586E:  MOVLW  2D
05870:  MOVWF  x50
05872:  MOVLB  0
05874:  RCALL  55C0
05876:  MOVLB  7
05878:  MOVF   x48,W
0587A:  MOVWF  00
0587C:  CLRF   x48
0587E:  MOVF   x47,W
05880:  SUBWF  x4A,W
05882:  BNZ   589C
05884:  MOVF   00,W
05886:  MOVWF  x48
05888:  MOVLW  2E
0588A:  MOVWF  x50
0588C:  MOVLB  0
0588E:  RCALL  55C0
05890:  MOVLB  7
05892:  MOVF   x48,W
05894:  MOVWF  00
05896:  MOVLW  20
05898:  ANDWF  x48,F
0589A:  MOVLW  00
0589C:  MOVLW  30
0589E:  BTFSS  x48.5
058A0:  BRA    58C0
058A2:  BCF    x48.5
058A4:  MOVF   x47,W
058A6:  BTFSS  FD8.2
058A8:  DECF   x48,F
058AA:  MOVF   00,W
058AC:  MOVWF  x48
058AE:  MOVLW  2D
058B0:  MOVWF  x50
058B2:  MOVLB  0
058B4:  RCALL  55C0
058B6:  MOVLB  7
058B8:  MOVF   x48,W
058BA:  MOVWF  00
058BC:  CLRF   x48
058BE:  MOVLW  30
058C0:  ADDWF  00,F
058C2:  MOVFF  00,750
058C6:  MOVLB  0
058C8:  RCALL  55C0
058CA:  MOVLB  7
058CC:  BCF    FD8.1
058CE:  MOVFF  74F,753
058D2:  MOVFF  74E,752
058D6:  MOVFF  74D,751
058DA:  MOVFF  74C,750
058DE:  CLRF   x57
058E0:  CLRF   x56
058E2:  CLRF   x55
058E4:  MOVLW  0A
058E6:  MOVWF  x54
058E8:  MOVLB  0
058EA:  RCALL  56CA
058EC:  MOVFF  03,74F
058F0:  MOVFF  02,74E
058F4:  MOVFF  01,74D
058F8:  MOVFF  00,74C
058FC:  MOVLB  7
058FE:  DECFSZ x4A,F
05900:  BRA    57FE
05902:  MOVLB  0
05904:  RETURN 0
05906:  MOVFF  FEA,708
0590A:  MOVFF  FE9,707
0590E:  MOVLB  7
05910:  SWAPF  x01,W
05912:  IORLW  F0
05914:  MOVWF  x03
05916:  ADDWF  x03,F
05918:  ADDLW  E2
0591A:  MOVWF  x04
0591C:  ADDLW  32
0591E:  MOVWF  x06
05920:  MOVF   x01,W
05922:  ANDLW  0F
05924:  ADDWF  x04,F
05926:  ADDWF  x04,F
05928:  ADDWF  x06,F
0592A:  ADDLW  E9
0592C:  MOVWF  x05
0592E:  ADDWF  x05,F
05930:  ADDWF  x05,F
05932:  SWAPF  x00,W
05934:  ANDLW  0F
05936:  ADDWF  x05,F
05938:  ADDWF  x06,F
0593A:  RLCF   x05,F
0593C:  RLCF   x06,F
0593E:  COMF   x06,F
05940:  RLCF   x06,F
05942:  MOVF   x00,W
05944:  ANDLW  0F
05946:  ADDWF  x06,F
05948:  RLCF   x03,F
0594A:  MOVLW  07
0594C:  MOVWF  x02
0594E:  MOVLW  0A
05950:  DECF   x05,F
05952:  ADDWF  x06,F
05954:  BNC   5950
05956:  DECF   x04,F
05958:  ADDWF  x05,F
0595A:  BNC   5956
0595C:  DECF   x03,F
0595E:  ADDWF  x04,F
05960:  BNC   595C
05962:  DECF   x02,F
05964:  ADDWF  x03,F
05966:  BNC   5962
05968:  MOVLW  07
0596A:  MOVWF  FEA
0596C:  MOVLW  02
0596E:  MOVWF  FE9
05970:  MOVLW  07
05972:  ANDWF  x07,W
05974:  BCF    x07.6
05976:  ADDWF  FE9,F
05978:  MOVLW  00
0597A:  ADDWFC FEA,F
0597C:  MOVF   FE9,W
0597E:  SUBLW  06
05980:  BNZ   598A
05982:  MOVF   FEA,W
05984:  SUBLW  07
05986:  BNZ   598A
05988:  BSF    x07.6
0598A:  MOVF   FEF,W
0598C:  MOVWF  00
0598E:  BNZ   59A0
05990:  BTFSC  x07.6
05992:  BRA    59A0
05994:  BTFSC  x07.4
05996:  BRA    59C2
05998:  BTFSC  x07.3
0599A:  BRA    59A0
0599C:  MOVLW  20
0599E:  BRA    59A6
059A0:  BSF    x07.3
059A2:  BCF    x07.4
059A4:  MOVLW  30
059A6:  ADDWF  00,F
059A8:  MOVFF  FEA,701
059AC:  MOVFF  FE9,700
059B0:  MOVFF  00,750
059B4:  MOVLB  0
059B6:  RCALL  55C0
059B8:  MOVFF  701,FEA
059BC:  MOVFF  700,FE9
059C0:  MOVLB  7
059C2:  MOVF   FEE,W
059C4:  BTFSS  x07.6
059C6:  BRA    597C
059C8:  MOVLB  0
059CA:  RETURN 0
*
05A1E:  MOVF   FEF,F
05A20:  BZ    5A40
05A22:  MOVFF  FEA,6FC
05A26:  MOVFF  FE9,6FB
05A2A:  MOVFF  FEF,6FD
05A2E:  RCALL  59CC
05A30:  MOVFF  6FC,FEA
05A34:  MOVFF  6FB,FE9
05A38:  INCF   FE9,F
05A3A:  BTFSC  FD8.2
05A3C:  INCF   FEA,F
05A3E:  BRA    5A1E
05A40:  GOTO   AAD6 (RETURN)
*
05A9E:  MOVF   FEF,F
05AA0:  BZ    5AC0
05AA2:  MOVFF  FEA,708
05AA6:  MOVFF  FE9,707
05AAA:  MOVFF  FEF,750
05AAE:  RCALL  55C0
05AB0:  MOVFF  708,FEA
05AB4:  MOVFF  707,FE9
05AB8:  INCF   FE9,F
05ABA:  BTFSC  FD8.2
05ABC:  INCF   FEA,F
05ABE:  BRA    5A9E
05AC0:  RETURN 0
*
05B74:  TBLRD*+
05B76:  MOVF   FF5,F
05B78:  BZ    5B92
05B7A:  MOVFF  FF6,70E
05B7E:  MOVFF  FF7,70F
05B82:  MOVFF  FF5,750
05B86:  RCALL  55C0
05B88:  MOVFF  70E,FF6
05B8C:  MOVFF  70F,FF7
05B90:  BRA    5B74
05B92:  RETURN 0
*
05CB6:  MOVLB  7
05CB8:  MOVF   x68,W
05CBA:  XORWF  x6A,W
05CBC:  ANDLW  80
05CBE:  MOVWF  x6C
05CC0:  BTFSS  x68.7
05CC2:  BRA    5CCE
05CC4:  COMF   x67,F
05CC6:  COMF   x68,F
05CC8:  INCF   x67,F
05CCA:  BTFSC  FD8.2
05CCC:  INCF   x68,F
05CCE:  BTFSS  x6A.7
05CD0:  BRA    5CDC
05CD2:  COMF   x69,F
05CD4:  COMF   x6A,F
05CD6:  INCF   x69,F
05CD8:  BTFSC  FD8.2
05CDA:  INCF   x6A,F
05CDC:  MOVF   x67,W
05CDE:  MULWF  x69
05CE0:  MOVFF  FF3,01
05CE4:  MOVFF  FF4,00
05CE8:  MULWF  x6A
05CEA:  MOVF   FF3,W
05CEC:  ADDWF  00,F
05CEE:  MOVF   x68,W
05CF0:  MULWF  x69
05CF2:  MOVF   FF3,W
05CF4:  ADDWFC 00,W
05CF6:  MOVWF  02
05CF8:  BTFSS  x6C.7
05CFA:  BRA    5D06
05CFC:  COMF   01,F
05CFE:  COMF   02,F
05D00:  INCF   01,F
05D02:  BTFSC  FD8.2
05D04:  INCF   02,F
05D06:  MOVLB  0
05D08:  GOTO   5F9C (RETURN)
*
06060:  MOVLW  20
06062:  MOVLB  7
06064:  BTFSS  x35.4
06066:  MOVLW  30
06068:  MOVWF  x36
0606A:  MOVFF  734,00
0606E:  BTFSS  00.7
06070:  BRA    6082
06072:  COMF   00,F
06074:  INCF   00,F
06076:  MOVFF  00,734
0607A:  MOVLW  2D
0607C:  MOVWF  x36
0607E:  BSF    x35.7
06080:  BSF    x35.0
06082:  MOVF   01,W
06084:  MOVFF  734,73A
06088:  MOVLW  64
0608A:  MOVWF  x3B
0608C:  MOVLB  0
0608E:  CALL   08C8
06092:  MOVFF  00,734
06096:  MOVLW  30
06098:  ADDWF  01,W
0609A:  MOVLB  7
0609C:  MOVWF  x37
0609E:  MOVFF  734,73A
060A2:  MOVLW  0A
060A4:  MOVWF  x3B
060A6:  MOVLB  0
060A8:  CALL   08C8
060AC:  MOVLW  30
060AE:  ADDWF  00,W
060B0:  MOVLB  7
060B2:  MOVWF  x39
060B4:  MOVLW  30
060B6:  ADDWF  01,W
060B8:  MOVWF  x38
060BA:  MOVFF  736,00
060BE:  MOVLW  30
060C0:  SUBWF  x37,W
060C2:  BZ    60CC
060C4:  BSF    x35.1
060C6:  BTFSC  x35.7
060C8:  BSF    x35.2
060CA:  BRA    60F0
060CC:  MOVFF  736,737
060D0:  MOVLW  20
060D2:  MOVWF  x36
060D4:  MOVLW  30
060D6:  SUBWF  x38,W
060D8:  BZ    60E2
060DA:  BSF    x35.0
060DC:  BTFSC  x35.7
060DE:  BSF    x35.1
060E0:  BRA    60F0
060E2:  BTFSS  FD8.2
060E4:  BSF    x35.0
060E6:  BNZ   60F0
060E8:  MOVFF  737,738
060EC:  MOVLW  20
060EE:  MOVWF  x37
060F0:  BTFSC  x35.2
060F2:  BRA    60FE
060F4:  BTFSC  x35.1
060F6:  BRA    6108
060F8:  BTFSC  x35.0
060FA:  BRA    6112
060FC:  BRA    611C
060FE:  MOVFF  736,750
06102:  MOVLB  0
06104:  CALL   55C0
06108:  MOVFF  737,750
0610C:  MOVLB  0
0610E:  CALL   55C0
06112:  MOVFF  738,750
06116:  MOVLB  0
06118:  CALL   55C0
0611C:  MOVFF  739,750
06120:  MOVLB  0
06122:  CALL   55C0
06126:  RETURN 0
*
062D4:  MOVLB  7
062D6:  MOVF   x22,W
062D8:  ANDLW  07
062DA:  MOVWF  00
062DC:  RRCF   x22,W
062DE:  MOVWF  01
062E0:  RRCF   01,F
062E2:  RRCF   01,F
062E4:  MOVLW  1F
062E6:  ANDWF  01,F
062E8:  MOVF   01,W
062EA:  ADDWF  x24,W
062EC:  MOVWF  FE9
062EE:  MOVLW  00
062F0:  ADDWFC x25,W
062F2:  MOVWF  FEA
062F4:  CLRF   01
062F6:  INCF   01,F
062F8:  INCF   00,F
062FA:  BRA    62FE
062FC:  RLCF   01,F
062FE:  DECFSZ 00,F
06300:  BRA    62FC
06302:  MOVF   x23,F
06304:  BZ    630C
06306:  MOVF   01,W
06308:  IORWF  FEF,F
0630A:  BRA    6312
0630C:  COMF   01,F
0630E:  MOVF   01,W
06310:  ANDWF  FEF,F
06312:  MOVLB  0
06314:  RETURN 0
*
092E2:  MOVF   FE9,W
092E4:  MOVLB  7
092E6:  MOVWF  x3D
092E8:  BTFSS  x3C.7
092EA:  BRA    9306
092EC:  DECF   x3D,F
092EE:  BSF    x3D.5
092F0:  COMF   x39,F
092F2:  COMF   x3A,F
092F4:  COMF   x3B,F
092F6:  COMF   x3C,F
092F8:  INCF   x39,F
092FA:  BTFSC  FD8.2
092FC:  INCF   x3A,F
092FE:  BTFSC  FD8.2
09300:  INCF   x3B,F
09302:  BTFSC  FD8.2
09304:  INCF   x3C,F
09306:  MOVLW  3B
09308:  MOVWF  x44
0930A:  MOVLW  9A
0930C:  MOVWF  x43
0930E:  MOVLW  CA
09310:  MOVWF  x42
09312:  CLRF   x41
09314:  MOVLW  0A
09316:  MOVWF  x3F
09318:  BSF    FD8.1
0931A:  MOVLW  07
0931C:  MOVWF  FEA
0931E:  MOVLW  39
09320:  MOVWF  FE9
09322:  MOVFF  73C,753
09326:  MOVFF  73B,752
0932A:  MOVFF  73A,751
0932E:  MOVFF  739,750
09332:  MOVFF  744,757
09336:  MOVFF  743,756
0933A:  MOVFF  742,755
0933E:  MOVFF  741,754
09342:  MOVLB  0
09344:  CALL   56CA
09348:  MOVF   01,W
0934A:  MOVF   00,F
0934C:  BNZ   9374
0934E:  MOVLB  7
09350:  MOVF   x3F,W
09352:  XORLW  01
09354:  BTFSS  FD8.2
09356:  BRA    935C
09358:  MOVLB  0
0935A:  BRA    9374
0935C:  MOVF   x3D,W
0935E:  BZ    937A
09360:  ANDLW  0F
09362:  SUBWF  x3F,W
09364:  BZ    9368
09366:  BC    93C4
09368:  BTFSC  x3D.7
0936A:  BRA    93C4
0936C:  BTFSC  x3D.6
0936E:  BRA    937A
09370:  MOVLW  20
09372:  BRA    93B6
09374:  MOVLW  20
09376:  MOVLB  7
09378:  ANDWF  x3D,F
0937A:  BTFSS  x3D.5
0937C:  BRA    9396
0937E:  BCF    x3D.5
09380:  MOVFF  00,73D
09384:  MOVLW  2D
09386:  MOVWF  x50
09388:  MOVLB  0
0938A:  CALL   55C0
0938E:  MOVLB  7
09390:  MOVFF  73D,00
09394:  CLRF   x3D
09396:  MOVLW  30
09398:  BTFSS  x3D.5
0939A:  BRA    93B6
0939C:  BCF    x3D.5
0939E:  MOVFF  00,73D
093A2:  MOVLW  2D
093A4:  MOVWF  x50
093A6:  MOVLB  0
093A8:  CALL   55C0
093AC:  MOVLB  7
093AE:  MOVFF  73D,00
093B2:  CLRF   x3D
093B4:  MOVLW  30
093B6:  ADDWF  00,F
093B8:  MOVFF  00,750
093BC:  MOVLB  0
093BE:  CALL   55C0
093C2:  MOVLB  7
093C4:  BCF    FD8.1
093C6:  MOVFF  744,753
093CA:  MOVFF  743,752
093CE:  MOVFF  742,751
093D2:  MOVFF  741,750
093D6:  CLRF   x57
093D8:  CLRF   x56
093DA:  CLRF   x55
093DC:  MOVLW  0A
093DE:  MOVWF  x54
093E0:  MOVLB  0
093E2:  CALL   56CA
093E6:  MOVFF  03,744
093EA:  MOVFF  02,743
093EE:  MOVFF  01,742
093F2:  MOVFF  00,741
093F6:  MOVLB  7
093F8:  DECFSZ x3F,F
093FA:  BRA    9318
093FC:  MOVLB  0
093FE:  RETURN 0
.................... 
.................... #list
.................... 
.................... 
.................... #device ADC=10
.................... 
.................... //!#FUSES WDT                      //Watch Dog Timer
.................... //!#FUSES WDT4096                  //Watch Dog Timer uses 1:4096 Postscale
.................... 
.................... #use delay(internal=64000000)
*
000CA:  MOVLW  01
000CC:  MOVLB  7
000CE:  SUBWF  x72,F
000D0:  BNC   00EA
000D2:  MOVLW  07
000D4:  MOVWF  FEA
000D6:  MOVLW  72
000D8:  MOVWF  FE9
000DA:  MOVF   FEF,W
000DC:  BZ    00EA
000DE:  MOVLW  04
000E0:  MOVWF  00
000E2:  DECFSZ 00,F
000E4:  BRA    00E2
000E6:  DECFSZ FEF,F
000E8:  BRA    00DE
000EA:  MOVLB  0
000EC:  RETURN 0
*
003D0:  MOVLW  07
003D2:  MOVWF  FEA
003D4:  MOVLW  01
003D6:  MOVWF  FE9
003D8:  MOVF   FEF,W
003DA:  BZ    03F8
003DC:  MOVLW  14
003DE:  MOVWF  01
003E0:  CLRF   00
003E2:  DECFSZ 00,F
003E4:  BRA    03E2
003E6:  DECFSZ 01,F
003E8:  BRA    03E0
003EA:  MOVLW  BF
003EC:  MOVWF  00
003EE:  DECFSZ 00,F
003F0:  BRA    03EE
003F2:  BRA    03F4
003F4:  DECFSZ FEF,F
003F6:  BRA    03DC
003F8:  RETURN 0
.................... #define baudRate 128000
.................... #define numChannels 2
.................... 
.................... #define version  "20251208" // SW Version
.................... #define serialID "0000"     // Unique Serial ID
.................... #define magPP 1             // Magnetoresistive Sensor Pole Pitch in mm   
.................... #define gainLvl 16          // 1, 2, 4, 8, 16, 32, 64, 128
.................... 
.................... 
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B7,PIN_B6,PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
003FA:  MOVLW  CF
003FC:  MOVWF  F87
003FE:  CLRF   F82
....................    output_b(portB_reset);
00400:  MOVLW  04
00402:  MOVWF  F88
00404:  CLRF   F83
....................    output_c(portC_reset);
00406:  MOVLW  93
00408:  MOVWF  F89
0040A:  CLRF   F84
....................    output_d(portD_reset);
0040C:  MOVLW  1F
0040E:  MOVWF  F8A
00410:  CLRF   F85
....................    output_e(portE_reset);
00412:  BCF    F8B.0
00414:  BCF    F8B.1
00416:  BCF    F8B.2
00418:  BCF    F8B.3
0041A:  CLRF   F86
....................    
....................    port_a_pullups(portA_pullups);
0041C:  MOVLB  F
0041E:  SETF   x0B
....................    port_b_pullups(portB_pullups);
00420:  CLRF   x13
....................    port_c_pullups(portC_pullups);
00422:  CLRF   x1B
....................    port_d_pullups(portD_pullups);
00424:  SETF   x20
....................    port_e_pullups(portE_pullups);
00426:  CLRF   x28
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
00428:  MOVLW  40
0042A:  MOVWF  x0C
0042C:  CLRF   x14
0042E:  MOVLW  03
00430:  MOVWF  x1C
00432:  MOVLW  0F
00434:  MOVWF  x21
00436:  CLRF   x29
00438:  MOVLB  0
0043A:  GOTO   A724 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
*
05AFC:  MOVFF  742,FEA
05B00:  MOVLB  7
05B02:  MOVFF  741,FE9
05B06:  MOVFF  FEF,745
05B0A:  MOVFF  744,FEA
05B0E:  MOVFF  743,FE9
05B12:  MOVF   FEF,W
05B14:  SUBWF  x45,W
05B16:  BNZ   5B46
....................       if (*s1 == '\0')
05B18:  MOVFF  742,03
05B1C:  MOVFF  741,FE9
05B20:  MOVFF  03,FEA
05B24:  MOVF   FEF,F
05B26:  BNZ   5B2E
....................          return(0);
05B28:  MOVLW  00
05B2A:  MOVWF  01
05B2C:  BRA    5B70
05B2E:  MOVFF  742,03
05B32:  MOVF   x41,W
05B34:  INCF   x41,F
05B36:  BTFSC  FD8.2
05B38:  INCF   x42,F
05B3A:  INCF   x43,F
05B3C:  BTFSC  FD8.2
05B3E:  INCF   x44,F
05B40:  MOVLB  0
05B42:  BRA    5AFC
05B44:  MOVLB  7
....................    return((*s1 < *s2) ? -1: 1);
05B46:  MOVFF  742,03
05B4A:  MOVFF  741,FE9
05B4E:  MOVFF  03,FEA
05B52:  MOVFF  FEF,745
05B56:  MOVFF  744,03
05B5A:  MOVFF  743,FE9
05B5E:  MOVFF  03,FEA
05B62:  MOVF   FEF,W
05B64:  SUBWF  x45,W
05B66:  BC    5B6C
05B68:  MOVLW  FF
05B6A:  BRA    5B6E
05B6C:  MOVLW  01
05B6E:  MOVWF  01
05B70:  MOVLB  0
05B72:  RETURN 0
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
*
05C6C:  MOVFF  768,76B
....................    for(su=s;0<n;++su,--n)
05C70:  MOVFF  767,76D
05C74:  MOVFF  766,76C
05C78:  MOVLB  7
05C7A:  MOVF   x6A,F
05C7C:  BNZ   5C84
05C7E:  MOVF   x69,W
05C80:  SUBLW  00
05C82:  BC    5CAC
....................       if(*su==uc)
05C84:  MOVFF  76D,FEA
05C88:  MOVFF  76C,FE9
05C8C:  MOVF   x6B,W
05C8E:  SUBWF  FEF,W
05C90:  BNZ   5C9C
....................       return su;
05C92:  MOVFF  76C,01
05C96:  MOVFF  76D,02
05C9A:  BRA    5CB2
05C9C:  INCF   x6C,F
05C9E:  BTFSC  FD8.2
05CA0:  INCF   x6D,F
05CA2:  MOVF   x69,W
05CA4:  BTFSC  FD8.2
05CA6:  DECF   x6A,F
05CA8:  DECF   x69,F
05CAA:  BRA    5C7A
....................    return NULL;
05CAC:  MOVLW  00
05CAE:  MOVWF  01
05CB0:  MOVWF  02
05CB2:  MOVLB  0
05CB4:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
*
05588:  MOVFF  742,744
0558C:  MOVFF  741,743
05590:  MOVFF  744,FEA
05594:  MOVLB  7
05596:  MOVFF  743,FE9
0559A:  MOVF   FEF,F
0559C:  BZ    55AA
0559E:  INCF   x43,F
055A0:  BTFSC  FD8.2
055A2:  INCF   x44,F
055A4:  MOVLB  0
055A6:  BRA    5590
055A8:  MOVLB  7
....................    return(sc - s);
055AA:  MOVF   x41,W
055AC:  SUBWF  x43,W
055AE:  MOVWF  00
055B0:  MOVF   x42,W
055B2:  SUBWFB x44,W
055B4:  MOVWF  03
055B6:  MOVFF  00,01
055BA:  MOVWF  02
055BC:  MOVLB  0
055BE:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
*
06DF2:  MOVLB  7
06DF4:  CLRF   x1B
06DF6:  CLRF   x1A
06DF8:  CLRF   x19
06DFA:  MOVLW  7F
06DFC:  MOVWF  x18
06DFE:  CLRF   x1F
06E00:  CLRF   x1E
06E02:  CLRF   x1D
06E04:  CLRF   x1C
06E06:  BSF    x20.0
06E08:  BCF    x20.1
06E0A:  BCF    x20.2
06E0C:  CLRF   x22
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
06E0E:  MOVF   x14,W
06E10:  IORWF  x15,W
06E12:  BNZ   6E1E
....................       return 0;
06E14:  CLRF   00
06E16:  CLRF   01
06E18:  CLRF   02
06E1A:  CLRF   03
06E1C:  BRA    7048
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
06E1E:  MOVF   x22,W
06E20:  INCF   x22,F
06E22:  ADDWF  x14,W
06E24:  MOVWF  FE9
06E26:  MOVLW  00
06E28:  ADDWFC x15,W
06E2A:  MOVWF  FEA
06E2C:  MOVFF  FEF,721
06E30:  MOVF   x21,F
06E32:  BTFSC  FD8.2
06E34:  BRA    6FCC
....................    {
....................       if (skip && !isspace(c))
06E36:  BTFSS  x20.0
06E38:  BRA    6E58
06E3A:  MOVF   x21,W
06E3C:  SUBLW  20
06E3E:  BZ    6E58
....................       {
....................          skip = 0;
06E40:  BCF    x20.0
....................          if (c == '+')
06E42:  MOVF   x21,W
06E44:  SUBLW  2B
06E46:  BNZ   6E4E
....................          {
....................             sign = 0;
06E48:  BCF    x20.1
....................             continue;
06E4A:  BRA    6FB4
....................          }            
06E4C:  BRA    6E58
....................          else if (c == '-')
06E4E:  MOVF   x21,W
06E50:  SUBLW  2D
06E52:  BNZ   6E58
....................          {
....................             sign = 1;
06E54:  BSF    x20.1
....................             continue;
06E56:  BRA    6FB4
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
06E58:  BTFSC  x20.0
06E5A:  BRA    6E6A
06E5C:  MOVF   x21,W
06E5E:  SUBLW  2E
06E60:  BNZ   6E6A
06E62:  BTFSC  x20.2
06E64:  BRA    6E6A
....................          point = 1;
06E66:  BSF    x20.2
06E68:  BRA    6FB4
....................       else if (!skip && isdigit(c))
06E6A:  BTFSC  x20.0
06E6C:  BRA    6FAE
06E6E:  MOVF   x21,W
06E70:  SUBLW  2F
06E72:  BTFSC  FD8.0
06E74:  BRA    6FAE
06E76:  MOVF   x21,W
06E78:  SUBLW  39
06E7A:  BTFSS  FD8.0
06E7C:  BRA    6FAE
....................       {
....................          c -= '0';
06E7E:  MOVLW  30
06E80:  SUBWF  x21,F
....................          if (point)
06E82:  BTFSS  x20.2
06E84:  BRA    6F34
....................          {
....................             pow10 = pow10 * 10.0;
06E86:  MOVFF  71B,753
06E8A:  MOVFF  71A,752
06E8E:  MOVFF  719,751
06E92:  MOVFF  718,750
06E96:  CLRF   x57
06E98:  CLRF   x56
06E9A:  MOVLW  20
06E9C:  MOVWF  x55
06E9E:  MOVLW  82
06EA0:  MOVWF  x54
06EA2:  MOVLB  0
06EA4:  CALL   0D90
06EA8:  MOVFF  03,71B
06EAC:  MOVFF  02,71A
06EB0:  MOVFF  01,719
06EB4:  MOVFF  00,718
....................             result += (float)c / pow10;   
06EB8:  MOVLB  7
06EBA:  CLRF   x4B
06EBC:  MOVFF  721,74A
06EC0:  MOVLB  0
06EC2:  CALL   0D5A
06EC6:  MOVFF  03,726
06ECA:  MOVFF  02,725
06ECE:  MOVFF  01,724
06ED2:  MOVFF  00,723
06ED6:  MOVFF  03,742
06EDA:  MOVFF  02,741
06EDE:  MOVFF  01,740
06EE2:  MOVFF  00,73F
06EE6:  MOVFF  71B,746
06EEA:  MOVFF  71A,745
06EEE:  MOVFF  719,744
06EF2:  MOVFF  718,743
06EF6:  CALL   1D96
06EFA:  BCF    FD8.1
06EFC:  MOVFF  71F,74D
06F00:  MOVFF  71E,74C
06F04:  MOVFF  71D,74B
06F08:  MOVFF  71C,74A
06F0C:  MOVFF  03,751
06F10:  MOVFF  02,750
06F14:  MOVFF  01,74F
06F18:  MOVFF  00,74E
06F1C:  CALL   0E86
06F20:  MOVFF  03,71F
06F24:  MOVFF  02,71E
06F28:  MOVFF  01,71D
06F2C:  MOVFF  00,71C
....................          }
06F30:  BRA    6FAA
06F32:  MOVLB  7
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
06F34:  CLRF   x53
06F36:  CLRF   x52
06F38:  MOVLW  20
06F3A:  MOVWF  x51
06F3C:  MOVLW  82
06F3E:  MOVWF  x50
06F40:  MOVFF  71F,757
06F44:  MOVFF  71E,756
06F48:  MOVFF  71D,755
06F4C:  MOVFF  71C,754
06F50:  MOVLB  0
06F52:  CALL   0D90
06F56:  MOVFF  03,726
06F5A:  MOVFF  02,725
06F5E:  MOVFF  01,724
06F62:  MOVFF  00,723
06F66:  MOVLB  7
06F68:  CLRF   x4B
06F6A:  MOVFF  721,74A
06F6E:  MOVLB  0
06F70:  CALL   0D5A
06F74:  BCF    FD8.1
06F76:  MOVFF  726,74D
06F7A:  MOVFF  725,74C
06F7E:  MOVFF  724,74B
06F82:  MOVFF  723,74A
06F86:  MOVFF  03,751
06F8A:  MOVFF  02,750
06F8E:  MOVFF  01,74F
06F92:  MOVFF  00,74E
06F96:  CALL   0E86
06F9A:  MOVFF  03,71F
06F9E:  MOVFF  02,71E
06FA2:  MOVFF  01,71D
06FA6:  MOVFF  00,71C
....................          }
....................       }
06FAA:  BRA    6FB6
06FAC:  MOVLB  7
....................       else if (!skip)
06FAE:  BTFSC  x20.0
06FB0:  BRA    6FB4
....................          break;
06FB2:  BRA    6FCC
06FB4:  MOVLB  0
06FB6:  MOVLB  7
06FB8:  MOVF   x22,W
06FBA:  INCF   x22,F
06FBC:  ADDWF  x14,W
06FBE:  MOVWF  FE9
06FC0:  MOVLW  00
06FC2:  ADDWFC x15,W
06FC4:  MOVWF  FEA
06FC6:  MOVFF  FEF,721
06FCA:  BRA    6E30
....................    }
.................... 
....................    if (sign)
06FCC:  BTFSS  x20.1
06FCE:  BRA    7004
....................       result = -1*result;
06FD0:  CLRF   x53
06FD2:  CLRF   x52
06FD4:  MOVLW  80
06FD6:  MOVWF  x51
06FD8:  MOVLW  7F
06FDA:  MOVWF  x50
06FDC:  MOVFF  71F,757
06FE0:  MOVFF  71E,756
06FE4:  MOVFF  71D,755
06FE8:  MOVFF  71C,754
06FEC:  MOVLB  0
06FEE:  CALL   0D90
06FF2:  MOVFF  03,71F
06FF6:  MOVFF  02,71E
06FFA:  MOVFF  01,71D
06FFE:  MOVFF  00,71C
07002:  MOVLB  7
....................       
....................    if(endptr)
07004:  MOVF   x16,W
07006:  IORWF  x17,W
07008:  BZ    7038
....................    {
....................       if (ptr) {
0700A:  MOVF   x22,F
0700C:  BZ    7026
....................          ptr--;
0700E:  DECF   x22,F
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
07010:  MOVFF  717,FEA
07014:  MOVFF  716,FE9
07018:  MOVF   x22,W
0701A:  ADDWF  x14,W
0701C:  MOVWF  FEF
0701E:  MOVLW  00
07020:  ADDWFC x15,W
07022:  MOVWF  FEC
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
07024:  BRA    7038
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
07026:  MOVFF  717,FEA
0702A:  MOVFF  716,FE9
0702E:  MOVFF  715,FEC
07032:  MOVF   FED,F
07034:  MOVFF  714,FEF
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
07038:  MOVFF  71C,00
0703C:  MOVFF  71D,01
07040:  MOVFF  71E,02
07044:  MOVFF  71F,03
07048:  MOVLB  0
0704A:  RETURN 0
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
*
05D0C:  MOVLB  7
05D0E:  CLRF   x3F
05D10:  CLRF   x3E
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
05D12:  MOVLW  30
05D14:  MOVWF  x41
05D16:  MOVLW  31
05D18:  MOVWF  x42
05D1A:  MOVLW  32
05D1C:  MOVWF  x43
05D1E:  MOVLW  33
05D20:  MOVWF  x44
05D22:  MOVLW  34
05D24:  MOVWF  x45
05D26:  MOVLW  35
05D28:  MOVWF  x46
05D2A:  MOVLW  36
05D2C:  MOVWF  x47
05D2E:  MOVLW  37
05D30:  MOVWF  x48
05D32:  MOVLW  38
05D34:  MOVWF  x49
05D36:  MOVLW  39
05D38:  MOVWF  x4A
05D3A:  MOVLW  61
05D3C:  MOVWF  x4B
05D3E:  MOVLW  62
05D40:  MOVWF  x4C
05D42:  MOVLW  63
05D44:  MOVWF  x4D
05D46:  MOVLW  64
05D48:  MOVWF  x4E
05D4A:  MOVLW  65
05D4C:  MOVWF  x4F
05D4E:  MOVLW  66
05D50:  MOVWF  x50
05D52:  MOVLW  67
05D54:  MOVWF  x51
05D56:  MOVLW  68
05D58:  MOVWF  x52
05D5A:  MOVLW  69
05D5C:  MOVWF  x53
05D5E:  MOVLW  6A
05D60:  MOVWF  x54
05D62:  MOVLW  6B
05D64:  MOVWF  x55
05D66:  MOVLW  6C
05D68:  MOVWF  x56
05D6A:  MOVLW  6D
05D6C:  MOVWF  x57
05D6E:  MOVLW  6E
05D70:  MOVWF  x58
05D72:  MOVLW  6F
05D74:  MOVWF  x59
05D76:  MOVLW  70
05D78:  MOVWF  x5A
05D7A:  MOVLW  71
05D7C:  MOVWF  x5B
05D7E:  MOVLW  73
05D80:  MOVWF  x5C
05D82:  MOVLW  74
05D84:  MOVWF  x5D
05D86:  MOVLW  75
05D88:  MOVWF  x5E
05D8A:  MOVLW  76
05D8C:  MOVWF  x5F
05D8E:  MOVLW  77
05D90:  MOVWF  x60
05D92:  MOVLW  78
05D94:  MOVWF  x61
05D96:  MOVLW  79
05D98:  MOVWF  x62
05D9A:  MOVLW  7A
05D9C:  MOVWF  x63
05D9E:  CLRF   x64
....................    for(sc=s;isspace(*sc);++sc);
05DA0:  MOVFF  734,739
05DA4:  MOVFF  733,738
05DA8:  MOVFF  739,FEA
05DAC:  MOVFF  738,FE9
05DB0:  MOVF   FEF,W
05DB2:  SUBLW  20
05DB4:  BNZ   5DBE
05DB6:  INCF   x38,F
05DB8:  BTFSC  FD8.2
05DBA:  INCF   x39,F
05DBC:  BRA    5DA8
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
05DBE:  MOVFF  739,03
05DC2:  MOVFF  738,FE9
05DC6:  MOVFF  03,FEA
05DCA:  MOVF   FEF,W
05DCC:  SUBLW  2D
05DCE:  BZ    5DDE
05DD0:  MOVFF  739,FEA
05DD4:  MOVFF  738,FE9
05DD8:  MOVF   FEF,W
05DDA:  SUBLW  2B
05DDC:  BNZ   5DF0
05DDE:  MOVFF  739,FEA
05DE2:  MOVF   x38,W
05DE4:  INCF   x38,F
05DE6:  BTFSC  FD8.2
05DE8:  INCF   x39,F
05DEA:  MOVWF  FE9
05DEC:  MOVF   FEF,W
05DEE:  BRA    5DF2
05DF0:  MOVLW  2B
05DF2:  MOVWF  x40
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
05DF4:  MOVF   x40,W
05DF6:  SUBLW  2D
05DF8:  BZ    5E0E
05DFA:  BTFSC  x37.7
05DFC:  BRA    5E0E
05DFE:  DECFSZ x37,W
05E00:  BRA    5E04
05E02:  BRA    5E0E
05E04:  BTFSC  x37.7
05E06:  BRA    5E12
05E08:  MOVF   x37,W
05E0A:  SUBLW  24
05E0C:  BC    5E12
....................    goto StrtoulGO;
05E0E:  BRA    601A
05E10:  BRA    5F0A
.................... 
....................    else if (base)
05E12:  MOVF   x37,F
05E14:  BZ    5EA2
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
05E16:  MOVF   x37,W
05E18:  SUBLW  10
05E1A:  BNZ   5E56
05E1C:  MOVFF  739,FEA
05E20:  MOVFF  738,FE9
05E24:  MOVF   FEF,W
05E26:  SUBLW  30
05E28:  BNZ   5E56
05E2A:  MOVLW  01
05E2C:  ADDWF  x38,W
05E2E:  MOVWF  FE9
05E30:  MOVLW  00
05E32:  ADDWFC x39,W
05E34:  MOVWF  FEA
05E36:  MOVF   FEF,W
05E38:  SUBLW  78
05E3A:  BZ    5E4E
05E3C:  MOVLW  01
05E3E:  ADDWF  x38,W
05E40:  MOVWF  FE9
05E42:  MOVLW  00
05E44:  ADDWFC x39,W
05E46:  MOVWF  FEA
05E48:  MOVF   FEF,W
05E4A:  SUBLW  58
05E4C:  BNZ   5E56
....................          sc+=2;
05E4E:  MOVLW  02
05E50:  ADDWF  x38,F
05E52:  MOVLW  00
05E54:  ADDWFC x39,F
....................       if(base==8 && *sc =='0')
05E56:  MOVF   x37,W
05E58:  SUBLW  08
05E5A:  BNZ   5E72
05E5C:  MOVFF  739,FEA
05E60:  MOVFF  738,FE9
05E64:  MOVF   FEF,W
05E66:  SUBLW  30
05E68:  BNZ   5E72
....................          sc+=1;
05E6A:  MOVLW  01
05E6C:  ADDWF  x38,F
05E6E:  MOVLW  00
05E70:  ADDWFC x39,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
05E72:  MOVF   x37,W
05E74:  SUBLW  02
05E76:  BNZ   5EA0
05E78:  MOVFF  739,FEA
05E7C:  MOVFF  738,FE9
05E80:  MOVF   FEF,W
05E82:  SUBLW  30
05E84:  BNZ   5EA0
05E86:  MOVLW  01
05E88:  ADDWF  x38,W
05E8A:  MOVWF  FE9
05E8C:  MOVLW  00
05E8E:  ADDWFC x39,W
05E90:  MOVWF  FEA
05E92:  MOVF   FEF,W
05E94:  SUBLW  62
05E96:  BNZ   5EA0
....................          sc+=2;
05E98:  MOVLW  02
05E9A:  ADDWF  x38,F
05E9C:  MOVLW  00
05E9E:  ADDWFC x39,F
.................... 
....................    }
05EA0:  BRA    5F0A
....................    else if(*sc!='0') // base is 0, find base
05EA2:  MOVFF  739,FEA
05EA6:  MOVFF  738,FE9
05EAA:  MOVF   FEF,W
05EAC:  SUBLW  30
05EAE:  BZ    5EB6
....................       base=10;
05EB0:  MOVLW  0A
05EB2:  MOVWF  x37
05EB4:  BRA    5F0A
....................    else if (sc[1]=='x' || sc[1]=='X')
05EB6:  MOVLW  01
05EB8:  ADDWF  x38,W
05EBA:  MOVWF  FE9
05EBC:  MOVLW  00
05EBE:  ADDWFC x39,W
05EC0:  MOVWF  FEA
05EC2:  MOVF   FEF,W
05EC4:  SUBLW  78
05EC6:  BZ    5EDA
05EC8:  MOVLW  01
05ECA:  ADDWF  x38,W
05ECC:  MOVWF  FE9
05ECE:  MOVLW  00
05ED0:  ADDWFC x39,W
05ED2:  MOVWF  FEA
05ED4:  MOVF   FEF,W
05ED6:  SUBLW  58
05ED8:  BNZ   5EE8
....................       base =16,sc+=2;
05EDA:  MOVLW  10
05EDC:  MOVWF  x37
05EDE:  MOVLW  02
05EE0:  ADDWF  x38,F
05EE2:  MOVLW  00
05EE4:  ADDWFC x39,F
05EE6:  BRA    5F0A
....................    else if(sc[1]=='b')
05EE8:  MOVLW  01
05EEA:  ADDWF  x38,W
05EEC:  MOVWF  FE9
05EEE:  MOVLW  00
05EF0:  ADDWFC x39,W
05EF2:  MOVWF  FEA
05EF4:  MOVF   FEF,W
05EF6:  SUBLW  62
05EF8:  BNZ   5F06
....................       base=2,sc+=2;
05EFA:  MOVLW  02
05EFC:  MOVWF  x37
05EFE:  ADDWF  x38,F
05F00:  MOVLW  00
05F02:  ADDWFC x39,F
05F04:  BRA    5F0A
....................    else
....................       base=8;
05F06:  MOVLW  08
05F08:  MOVWF  x37
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
05F0A:  MOVFF  739,73B
05F0E:  MOVFF  738,73A
05F12:  MOVFF  739,FEA
05F16:  MOVFF  738,FE9
05F1A:  MOVF   FEF,W
05F1C:  SUBLW  30
05F1E:  BNZ   5F28
05F20:  INCF   x38,F
05F22:  BTFSC  FD8.2
05F24:  INCF   x39,F
05F26:  BRA    5F12
....................    sd=memchr(digits,tolower(*sc),base);
05F28:  MOVFF  739,03
05F2C:  MOVFF  738,FE9
05F30:  MOVFF  03,FEA
05F34:  MOVFF  FEF,765
05F38:  MOVF   x65,W
05F3A:  SUBLW  40
05F3C:  BC    5F4A
05F3E:  MOVF   x65,W
05F40:  SUBLW  5A
05F42:  BNC   5F4A
05F44:  MOVF   x65,W
05F46:  IORLW  20
05F48:  BRA    5F4C
05F4A:  MOVF   x65,W
05F4C:  MOVWF  x65
05F4E:  MOVLW  07
05F50:  MOVWF  x67
05F52:  MOVLW  41
05F54:  MOVWF  x66
05F56:  MOVFF  765,768
05F5A:  CLRF   x6A
05F5C:  MOVFF  737,769
05F60:  BTFSC  x69.7
05F62:  DECF   x6A,F
05F64:  MOVLB  0
05F66:  RCALL  5C6C
05F68:  MOVFF  02,73D
05F6C:  MOVFF  01,73C
....................    for(; sd!=0; )
05F70:  MOVLB  7
05F72:  MOVF   x3C,F
05F74:  BNZ   5F7A
05F76:  MOVF   x3D,F
05F78:  BZ    600E
....................    {
....................       x=x*base+(int16)(sd-digits);
05F7A:  CLRF   03
05F7C:  MOVF   x37,W
05F7E:  MOVWF  00
05F80:  BTFSC  FE8.7
05F82:  DECF   03,F
05F84:  MOVWF  x65
05F86:  MOVFF  03,766
05F8A:  MOVFF  73F,768
05F8E:  MOVFF  73E,767
05F92:  MOVFF  03,76A
05F96:  MOVWF  x69
05F98:  MOVLB  0
05F9A:  BRA    5CB6
05F9C:  MOVFF  01,765
05FA0:  MOVLW  41
05FA2:  MOVLB  7
05FA4:  SUBWF  x3C,W
05FA6:  MOVWF  00
05FA8:  MOVLW  07
05FAA:  SUBWFB x3D,W
05FAC:  MOVWF  03
05FAE:  MOVF   00,W
05FB0:  ADDWF  01,W
05FB2:  MOVWF  01
05FB4:  MOVF   02,W
05FB6:  ADDWFC 03,F
05FB8:  MOVFF  01,73E
05FBC:  MOVFF  03,73F
....................       ++sc;
05FC0:  INCF   x38,F
05FC2:  BTFSC  FD8.2
05FC4:  INCF   x39,F
....................       sd=memchr(digits,tolower(*sc),base);
05FC6:  MOVFF  739,FEA
05FCA:  MOVFF  738,FE9
05FCE:  MOVFF  FEF,765
05FD2:  MOVF   x65,W
05FD4:  SUBLW  40
05FD6:  BC    5FE4
05FD8:  MOVF   x65,W
05FDA:  SUBLW  5A
05FDC:  BNC   5FE4
05FDE:  MOVF   x65,W
05FE0:  IORLW  20
05FE2:  BRA    5FE6
05FE4:  MOVF   x65,W
05FE6:  MOVWF  x65
05FE8:  MOVLW  07
05FEA:  MOVWF  x67
05FEC:  MOVLW  41
05FEE:  MOVWF  x66
05FF0:  MOVFF  765,768
05FF4:  CLRF   x6A
05FF6:  MOVFF  737,769
05FFA:  BTFSC  x69.7
05FFC:  DECF   x6A,F
05FFE:  MOVLB  0
06000:  RCALL  5C6C
06002:  MOVFF  02,73D
06006:  MOVFF  01,73C
0600A:  BRA    5F70
0600C:  MOVLB  7
....................    }
....................    if(s1==sc)
0600E:  MOVF   x38,W
06010:  SUBWF  x3A,W
06012:  BNZ   603C
06014:  MOVF   x39,W
06016:  SUBWF  x3B,W
06018:  BNZ   603C
....................    {
....................    StrtoulGO:
....................       if (endptr)
0601A:  MOVLB  7
0601C:  MOVF   x35,W
0601E:  IORWF  x36,W
06020:  BZ    6034
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
06022:  MOVFF  736,FEA
06026:  MOVFF  735,FE9
0602A:  MOVFF  734,FEC
0602E:  MOVF   FED,F
06030:  MOVFF  733,FEF
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
06034:  MOVLW  00
06036:  MOVWF  01
06038:  MOVWF  02
0603A:  BRA    605C
....................    }
....................    if (endptr)
0603C:  MOVF   x35,W
0603E:  IORWF  x36,W
06040:  BZ    6054
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
06042:  MOVFF  736,FEA
06046:  MOVFF  735,FE9
0604A:  MOVFF  739,FEC
0604E:  MOVF   FED,F
06050:  MOVFF  738,FEF
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
06054:  MOVFF  73E,01
06058:  MOVFF  73F,02
0605C:  MOVLB  0
0605E:  RETURN 0
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................     float kP;      // proportional gain
....................     float kI;      // integral gain
....................     float kD;      // derivative gain
....................     float SP;      // set point-- desired output
....................     float PV;      // process variable-- measured output
....................     float PVold;   // oldPV value  
....................     float CV;      // control variable-- output -- 0 to 100%
....................     float I;       // integral value
....................     float maxSP;   // Max setpoint in microns
....................     float minSP;   // Min setpoint in microns
.................... }PID[2] = {
....................    //  P     I     D
....................    //0.01    0.3   0.1
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}, 
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}
....................     };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... //!#define op_upper_bound 63  // CRYO
.................... //!#define op_lower_bound -63 // CRYO
.................... 
.................... #define op_upper_bound 63  // AMBIENT 
.................... #define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    BOOLEAN homeFlag;       // Flag to trigger the homing routine
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,FALSE},
....................    {0,0,0,0,0,0,0,0,0,0,FALSE}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................     BOOLEAN invV;
....................     unsigned int16 ipVal;
....................     float opPcnt;
....................    
.................... }dacVals[2] = 
.................... {
....................     {FALSE,0,0},
....................     {FALSE,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
*
004A0:  MOVLB  7
004A2:  CLRF   x00
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
004A4:  CLRF   x00
004A6:  MOVLB  6
004A8:  MOVF   xFF,W
004AA:  MOVLB  7
004AC:  SUBWF  x00,W
004AE:  BC    0510
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
004B0:  MOVF   x00,W
004B2:  MOVLB  6
004B4:  ADDWF  xFD,W
004B6:  MOVLB  7
004B8:  MOVWF  x01
004BA:  MOVLW  00
004BC:  MOVLB  6
004BE:  ADDWFC xFE,W
004C0:  MOVLB  7
004C2:  MOVWF  x02
004C4:  MOVF   x00,W
004C6:  MOVLB  6
004C8:  ADDWF  xFB,W
004CA:  MOVWF  01
004CC:  MOVLW  00
004CE:  ADDWFC xFC,W
004D0:  MOVWF  03
004D2:  MOVF   01,W
004D4:  MOVWF  FE9
004D6:  MOVFF  03,FEA
004DA:  MOVFF  FEF,703
004DE:  BSF    F7F.7
004E0:  MOVF   FF2,W
004E2:  MOVWF  00
004E4:  BCF    FF2.7
004E6:  MOVFF  702,F7A
004EA:  MOVFF  701,F79
004EE:  MOVLW  31
004F0:  MOVWF  F7B
004F2:  MOVFF  703,F7C
004F6:  MOVLB  F
004F8:  MOVLW  55
004FA:  MOVWF  F81
004FC:  MOVLW  AA
004FE:  MOVWF  F81
00500:  BSF    F80.4
00502:  BTFSC  F80.4
00504:  BRA    0502
00506:  MOVF   00,W
00508:  IORWF  FF2,F
0050A:  MOVLB  7
0050C:  INCF   x00,F
0050E:  BRA    04A6
....................    }
00510:  MOVLB  0
00512:  RETURN 0
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
*
0043E:  MOVLB  7
00440:  CLRF   x00
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
00442:  CLRF   x00
00444:  MOVLB  6
00446:  MOVF   xFF,W
00448:  MOVLB  7
0044A:  SUBWF  x00,W
0044C:  BC    049C
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
0044E:  MOVF   x00,W
00450:  MOVLB  6
00452:  ADDWF  xFB,W
00454:  MOVWF  01
00456:  MOVLW  00
00458:  ADDWFC xFC,W
0045A:  MOVWF  03
0045C:  MOVF   01,W
0045E:  MOVWF  FE9
00460:  MOVFF  03,FEA
00464:  MOVLB  7
00466:  MOVF   x00,W
00468:  MOVLB  6
0046A:  ADDWF  xFD,W
0046C:  MOVLB  7
0046E:  MOVWF  x03
00470:  MOVLW  00
00472:  MOVLB  6
00474:  ADDWFC xFE,W
00476:  MOVLB  7
00478:  MOVWF  x04
0047A:  BSF    F7F.7
0047C:  MOVFF  FF2,705
00480:  BCF    FF2.7
00482:  MOVFF  704,F7A
00486:  MOVFF  703,F79
0048A:  MOVLW  31
0048C:  MOVWF  F7B
0048E:  BSF    F80.0
00490:  MOVF   F7C,W
00492:  BTFSC  x05.7
00494:  BSF    FF2.7
00496:  MOVWF  FEF
00498:  INCF   x00,F
0049A:  BRA    0444
....................    }
0049C:  MOVLB  0
0049E:  RETURN 0
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
*
00514:  MOVLB  6
00516:  CLRF   xFC
00518:  MOVLW  20
0051A:  MOVWF  xFB
0051C:  CLRF   xFE
0051E:  CLRF   xFD
00520:  MOVLW  80
00522:  MOVWF  xFF
00524:  MOVLB  0
00526:  RCALL  04A0
....................    delay_ms(1);
00528:  MOVLW  01
0052A:  MOVLB  7
0052C:  MOVWF  x01
0052E:  MOVLB  0
00530:  RCALL  03D0
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
00532:  MOVLB  6
00534:  CLRF   xFC
00536:  MOVLW  70
00538:  MOVWF  xFB
0053A:  CLRF   xFE
0053C:  MOVLW  80
0053E:  MOVWF  xFD
00540:  MOVLW  02
00542:  MOVWF  xFF
00544:  MOVLB  0
00546:  RCALL  04A0
....................    delay_ms(1);
00548:  MOVLW  01
0054A:  MOVLB  7
0054C:  MOVWF  x01
0054E:  MOVLB  0
00550:  RCALL  03D0
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
00552:  MOVLB  6
00554:  CLRF   xFC
00556:  MOVLW  71
00558:  MOVWF  xFB
0055A:  CLRF   xFE
0055C:  MOVLW  90
0055E:  MOVWF  xFD
00560:  MOVLW  02
00562:  MOVWF  xFF
00564:  MOVLB  0
00566:  RCALL  04A0
....................    delay_ms(1);
00568:  MOVLW  01
0056A:  MOVLB  7
0056C:  MOVWF  x01
0056E:  MOVLB  0
00570:  RCALL  03D0
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
00572:  MOVLB  6
00574:  CLRF   xFC
00576:  MOVLW  72
00578:  MOVWF  xFB
0057A:  CLRF   xFE
0057C:  MOVLW  A0
0057E:  MOVWF  xFD
00580:  MOVLW  20
00582:  MOVWF  xFF
00584:  MOVLB  0
00586:  RCALL  04A0
....................    delay_ms(1);
00588:  MOVLW  01
0058A:  MOVLB  7
0058C:  MOVWF  x01
0058E:  MOVLB  0
00590:  RCALL  03D0
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
00592:  MOVLB  6
00594:  CLRF   xFC
00596:  MOVLW  92
00598:  MOVWF  xFB
0059A:  CLRF   xFE
0059C:  MOVLW  C0
0059E:  MOVWF  xFD
005A0:  MOVLW  30
005A2:  MOVWF  xFF
005A4:  MOVLB  0
005A6:  RCALL  04A0
....................    delay_ms(1);
005A8:  MOVLW  01
005AA:  MOVLB  7
005AC:  MOVWF  x01
005AE:  MOVLB  0
005B0:  RCALL  03D0
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
005B2:  MOVLB  6
005B4:  CLRF   xFC
005B6:  MOVLW  C2
005B8:  MOVWF  xFB
005BA:  CLRF   xFE
005BC:  MOVLW  F0
005BE:  MOVWF  xFD
005C0:  MOVLW  38
005C2:  MOVWF  xFF
005C4:  MOVLB  0
005C6:  RCALL  04A0
....................    delay_ms(1);
005C8:  MOVLW  01
005CA:  MOVLB  7
005CC:  MOVWF  x01
005CE:  MOVLB  0
005D0:  RCALL  03D0
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
005D2:  MOVLB  6
005D4:  CLRF   xFC
005D6:  MOVLW  FA
005D8:  MOVWF  xFB
005DA:  MOVLW  01
005DC:  MOVWF  xFE
005DE:  MOVLW  40
005E0:  MOVWF  xFD
005E2:  MOVLW  01
005E4:  MOVWF  xFF
005E6:  MOVLB  0
005E8:  RCALL  04A0
....................    delay_ms(1);
005EA:  MOVLW  01
005EC:  MOVLB  7
005EE:  MOVWF  x01
005F0:  MOVLB  0
005F2:  RCALL  03D0
005F4:  GOTO   06C4 (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
005F8:  MOVLB  6
005FA:  CLRF   xFC
005FC:  MOVLW  20
005FE:  MOVWF  xFB
00600:  CLRF   xFE
00602:  CLRF   xFD
00604:  MOVLW  80
00606:  MOVWF  xFF
00608:  MOVLB  0
0060A:  RCALL  043E
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
0060C:  MOVLB  6
0060E:  CLRF   xFC
00610:  MOVLW  70
00612:  MOVWF  xFB
00614:  CLRF   xFE
00616:  MOVLW  80
00618:  MOVWF  xFD
0061A:  MOVLW  02
0061C:  MOVWF  xFF
0061E:  MOVLB  0
00620:  RCALL  043E
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
00622:  MOVLB  6
00624:  CLRF   xFC
00626:  MOVLW  71
00628:  MOVWF  xFB
0062A:  CLRF   xFE
0062C:  MOVLW  90
0062E:  MOVWF  xFD
00630:  MOVLW  02
00632:  MOVWF  xFF
00634:  MOVLB  0
00636:  RCALL  043E
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
00638:  MOVLB  6
0063A:  CLRF   xFC
0063C:  MOVLW  72
0063E:  MOVWF  xFB
00640:  CLRF   xFE
00642:  MOVLW  A0
00644:  MOVWF  xFD
00646:  MOVLW  20
00648:  MOVWF  xFF
0064A:  MOVLB  0
0064C:  RCALL  043E
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
0064E:  MOVLB  6
00650:  CLRF   xFC
00652:  MOVLW  92
00654:  MOVWF  xFB
00656:  CLRF   xFE
00658:  MOVLW  C0
0065A:  MOVWF  xFD
0065C:  MOVLW  30
0065E:  MOVWF  xFF
00660:  MOVLB  0
00662:  RCALL  043E
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
00664:  MOVLB  6
00666:  CLRF   xFC
00668:  MOVLW  C2
0066A:  MOVWF  xFB
0066C:  CLRF   xFE
0066E:  MOVLW  F0
00670:  MOVWF  xFD
00672:  MOVLW  38
00674:  MOVWF  xFF
00676:  MOVLB  0
00678:  RCALL  043E
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
0067A:  MOVLB  6
0067C:  CLRF   xFC
0067E:  MOVLW  FA
00680:  MOVWF  xFB
00682:  MOVLW  01
00684:  MOVWF  xFE
00686:  MOVLW  40
00688:  MOVWF  xFD
0068A:  MOVLW  01
0068C:  MOVWF  xFF
0068E:  MOVLB  0
00690:  RCALL  043E
00692:  GOTO   06C8 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
00696:  MOVLB  6
00698:  CLRF   xFC
0069A:  MOVLW  FA
0069C:  MOVWF  xFB
0069E:  MOVLW  01
006A0:  MOVWF  xFE
006A2:  MOVLW  40
006A4:  MOVWF  xFD
006A6:  MOVLW  01
006A8:  MOVWF  xFF
006AA:  MOVLB  0
006AC:  RCALL  043E
....................    delay_ms(1);
006AE:  MOVLW  01
006B0:  MOVLB  7
006B2:  MOVWF  x01
006B4:  MOVLB  0
006B6:  RCALL  03D0
....................    if (paramsValid != isValid)
006B8:  MOVF   xFA,W
006BA:  SUBLW  AA
006BC:  BZ    06C6
....................    {
....................       paramsValid = isValid;
006BE:  MOVLW  AA
006C0:  MOVWF  xFA
....................       params_save_to_ee(); // saves the base parameters on first boot
006C2:  BRA    0514
....................    }
006C4:  BRA    06C8
....................    else
....................    {
....................       params_load_from_ee();
006C6:  BRA    05F8
....................    }
006C8:  GOTO   A728 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <monitor.h>
.................... #ifndef monitor
.................... #define monitor
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B7,PIN_B6,PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
....................    output_b(portB_reset);
....................    output_c(portC_reset);
....................    output_d(portD_reset);
....................    output_e(portE_reset);
....................    
....................    port_a_pullups(portA_pullups);
....................    port_b_pullups(portB_pullups);
....................    port_c_pullups(portC_pullups);
....................    port_d_pullups(portD_pullups);
....................    port_e_pullups(portE_pullups);
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................     float kP;      // proportional gain
....................     float kI;      // integral gain
....................     float kD;      // derivative gain
....................     float SP;      // set point-- desired output
....................     float PV;      // process variable-- measured output
....................     float PVold;   // oldPV value  
....................     float CV;      // control variable-- output -- 0 to 100%
....................     float I;       // integral value
....................     float maxSP;   // Max setpoint in microns
....................     float minSP;   // Min setpoint in microns
.................... }PID[2] = {
....................    //  P     I     D
....................    //0.01    0.3   0.1
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}, 
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}
....................     };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... //!#define op_upper_bound 63  // CRYO
.................... //!#define op_lower_bound -63 // CRYO
.................... 
.................... #define op_upper_bound 63  // AMBIENT 
.................... #define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    BOOLEAN homeFlag;       // Flag to trigger the homing routine
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,FALSE},
....................    {0,0,0,0,0,0,0,0,0,0,FALSE}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................     BOOLEAN invV;
....................     unsigned int16 ipVal;
....................     float opPcnt;
....................    
.................... }dacVals[2] = 
.................... {
....................     {FALSE,0,0},
....................     {FALSE,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <ADS1220.h>
.................... #ifndef ADS1220
.................... #define ADS1220
.................... 
.................... /*****************************************************************************/
.................... /* SET UP PORTS FOR USE WITH DRIVER                                          */
.................... /*****************************************************************************/
.................... #define _CS0  PIN_D5 // chip select pins 
.................... #define _CS1  PIN_D6
.................... #define _CS2  PIN_D7
.................... #define _CS3  PIN_B0
.................... 
.................... #pin_select SCK2=PIN_B1
.................... #pin_select SDI2=PIN_B2
.................... #pin_select SDO2=PIN_B3
.................... #use spi(MASTER, SPI2, BAUD=4096000, MODE=1, STREAM=SPI_mon)
.................... //!setup_spi2(SPI_MASTER | SPI_SCK_IDLE_LOW | SPI_XMIT_H_TO_L | SPI_CLK_DIV_64);
.................... 
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* REGISTER DEFINITIONS                                                      */
.................... /*****************************************************************************/
.................... typedef enum {reg0 = 0x00,reg1 = 0x04 ,reg2 = 0x08, reg3 = 0x0C}adsReg;
.................... 
.................... //REGISTER 0 OPTIONS
.................... 
.................... #define IPp0n1 0x00
.................... #define IPp0n2 0x10
.................... #define IPp0n3 0x20
.................... #define IPp1n2 0x30
.................... #define IPp1n3 0x40
.................... #define IPp2n3 0x50
.................... #define IPp1n0 0x60
.................... #define IPp3n2 0x70
.................... #define IPp0nVss 0x80
.................... #define IPp1nVss 0x90
.................... #define IPp2nVss 0xA0
.................... #define IPp3nVss 0xB0
.................... #define IPVrpVrn 0xC0
.................... #define IPVddVss 0xD0
.................... #define IPhalfRail 0xE0
.................... 
.................... #define g1 0x00
.................... #define g2 0x02
.................... #define g4 0x04
.................... #define g8 0x06
.................... #define g16 0x08
.................... #define g32 0x0A
.................... #define g64 0x0C
.................... #define g128 0x0E
.................... 
.................... #define PGAenabled 0x00
.................... #define PGAbypass 0x01
.................... 
.................... //REGISTER 1 OPTIONS
.................... 
.................... #define DRn20 0x00
.................... #define DRn45 0x20
.................... #define DRn90 0x40
.................... #define DRn175 0x60
.................... #define DRn330 0x80
.................... #define DRn600 0xA0
.................... #define DRn1000 0xC0
.................... 
.................... #define MDnormal 0x00
.................... #define MDduty 0x80
.................... #define MDturbo 0x10
.................... 
.................... #define CMsingle 0x00
.................... #define CMcont 0x40
.................... 
.................... #define TSdisable 0x00
.................... #define TSenable 0x20
.................... 
.................... #define BCSoff 0x00
.................... #define BCSon 0x01
.................... 
.................... //REGISTER 2 OPTIONS
.................... 
.................... #define REFinternal 0x00
.................... #define REFp0n0 0x40
.................... #define REFp1n1 0x80
.................... #define REFVddVss 0xC0
.................... 
.................... #define FIRoff 0x00
.................... #define FIR5060 0x10
.................... #define FIR50 0x20
.................... #define FIR60 0x30
.................... 
.................... #define PSWopen 0x00
.................... #define PSWstart 0x08
.................... 
.................... #define Ioff 0x00
.................... #define Iu10 0x01
.................... #define Iu50 0x02
.................... #define Iu100 0x03
.................... #define Iu250 0x04
.................... #define Iu500 0x05
.................... #define Iu1000 0x06
.................... #define Iu1500 0x07  
.................... 
.................... //REGISTER 3 OPTIONS
.................... 
.................... #define I1disabled 0x00
.................... #define I1a0p1 0x20
.................... #define I1a1 0x40
.................... #define I1a2 0x60
.................... #define I1a3n1 0x80
.................... #define I1p0 0xA0
.................... #define I1n0 0xC0
.................... 
.................... #define I2disabled 0x00
.................... #define I2a0p1 0x04
.................... #define I2a1 0x08
.................... #define I2a2 0x0A
.................... #define I2a3n1 0x10
.................... #define I2p0 0x14
.................... #define I2n0 0x18
.................... 
.................... #define drdyPin 0x00
.................... #define doutPin 0x20
.................... 
.................... // REGISTER CONGIGURATIONS FOR THIS APP
.................... #define reg0config IPp1n2|g1|PGAenabled // 0x30//
.................... #define reg1config DRn20|MDturbo|CMsingle|TSDisable|BCSoff //0x10
.................... #define reg2config REFinternal|FIRoff|PSWopen|Ioff //0x30
.................... #define reg3config I1disabled|I2disabled|drdyPin //0x00
.................... 
.................... //COMMANDS
.................... #define ADSreset 0x06
.................... #define ADSstart 0x08
.................... #define ADSpowerDn 0x02
.................... #define ADSreadData 0x10
.................... #define ADSreadReg 0x20
.................... #define ADSwriteReg 0x40
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* DESELECT ALL ADCs                                                         */
.................... /*****************************************************************************/
.................... void ads_deselect_all()
.................... {   
....................    output_high(_CS0); // deselect all chip select pins
*
00174:  MOVLW  1F
00176:  MOVWF  F8A
00178:  BSF    F85.5
....................    output_high(_CS1);
0017A:  MOVWF  F8A
0017C:  BSF    F85.6
....................    output_high(_CS2);
0017E:  MOVWF  F8A
00180:  BSF    F85.7
....................    output_high(_CS3); 
00182:  MOVLW  04
00184:  MOVWF  F88
00186:  BSF    F83.0
....................    delay_us(10);
00188:  MOVLW  35
0018A:  MOVWF  00
0018C:  DECFSZ 00,F
0018E:  BRA    018C
00190:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT DESIRED ADC                                                        */
.................... /*****************************************************************************/
.................... void ads_select_ch(int8 ch)
.................... {
....................    ads_deselect_all();
*
006CC:  RCALL  0174
....................    switch(ch)
006CE:  MOVLB  7
006D0:  MOVF   x0C,W
006D2:  ADDLW  FC
006D4:  BC    0708
006D6:  ADDLW  04
006D8:  MOVLB  0
006DA:  GOTO   0714
....................    {
....................       case 0:
....................          output_low(_CS0);
006DE:  MOVLW  1F
006E0:  MOVWF  F8A
006E2:  BCF    F85.5
....................       break; 
006E4:  MOVLB  7
006E6:  BRA    0708
....................       case 1:
....................          output_low(_CS1);
006E8:  MOVLW  1F
006EA:  MOVWF  F8A
006EC:  BCF    F85.6
....................       break;   
006EE:  MOVLB  7
006F0:  BRA    0708
....................       case 2:
....................          output_low(_CS2);
006F2:  MOVLW  1F
006F4:  MOVWF  F8A
006F6:  BCF    F85.7
....................       break;
006F8:  MOVLB  7
006FA:  BRA    0708
....................       case 3:
....................          output_low(_CS3);
006FC:  MOVLW  04
006FE:  MOVWF  F88
00700:  BCF    F83.0
....................       break;              
00702:  MOVLB  7
00704:  BRA    0708
00706:  MOVLB  7
....................    }
....................    delay_us(10);
00708:  MOVLW  35
0070A:  MOVWF  00
0070C:  DECFSZ 00,F
0070E:  BRA    070C
00710:  MOVLB  0
00712:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT ADC BLOCK (2 ADCs/BLOCK)                                           */
.................... /*****************************************************************************/
.................... void ads_select_block(int8 block)
.................... {
....................    ads_deselect_all();
*
00192:  RCALL  0174
....................    switch(block)
00194:  MOVLB  7
00196:  MOVF   x74,W
00198:  XORLW  00
0019A:  MOVLB  0
0019C:  BZ    01A4
0019E:  XORLW  01
001A0:  BZ    01B0
001A2:  BRA    01BC
....................    {
....................       case 0:
....................          output_low(_CS0);
001A4:  MOVLW  1F
001A6:  MOVWF  F8A
001A8:  BCF    F85.5
....................          output_low(_CS1);
001AA:  MOVWF  F8A
001AC:  BCF    F85.6
....................       break; 
001AE:  BRA    01BC
....................       case 1:         
....................          output_low(_CS2);
001B0:  MOVLW  1F
001B2:  MOVWF  F8A
001B4:  BCF    F85.7
....................          output_low(_CS3);
001B6:  MOVLW  04
001B8:  MOVWF  F88
001BA:  BCF    F83.0
....................       break;         
....................    }
....................    delay_us(10);
001BC:  MOVLW  35
001BE:  MOVWF  00
001C0:  DECFSZ 00,F
001C2:  BRA    01C0
001C4:  GOTO   01CE (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT ALL ADCs                                                           */
.................... /*****************************************************************************/
.................... void ads_select_all()
.................... {
....................    output_low(_CS0);
*
007E8:  MOVLW  1F
007EA:  MOVWF  F8A
007EC:  BCF    F85.5
....................    output_low(_CS1);
007EE:  MOVWF  F8A
007F0:  BCF    F85.6
....................    output_low(_CS2);
007F2:  MOVWF  F8A
007F4:  BCF    F85.7
....................    output_low(_CS3);
007F6:  MOVLW  04
007F8:  MOVWF  F88
007FA:  BCF    F83.0
....................    delay_us(10);
007FC:  MOVLW  35
007FE:  MOVWF  00
00800:  DECFSZ 00,F
00802:  BRA    0800
00804:  GOTO   080A (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO AN ADC                                          */
.................... /*****************************************************************************/
.................... void ads_write_command(int8 ch, unsigned int8 command)
.................... {
....................    ads_select_ch(ch);
*
00736:  MOVFF  70A,70C
0073A:  RCALL  06CC
....................    spi_write2(command);
0073C:  MOVLB  E
0073E:  MOVF   x8D,W
00740:  MOVFF  70B,E8D
00744:  RRCF   x90,W
00746:  BNC   0744
00748:  MOVLB  0
0074A:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO A BLOCK OF ADCs                                 */
.................... /*****************************************************************************/
.................... void ads_write_command_block(int8 block, unsigned int8 command)
.................... {
....................    ads_select_block(block);
*
001C8:  MOVFF  772,774
001CC:  BRA    0192
....................    spi_write2(command);
001CE:  MOVLB  E
001D0:  MOVF   x8D,W
001D2:  MOVFF  773,E8D
001D6:  RRCF   x90,W
001D8:  BNC   01D6
001DA:  MOVLB  0
001DC:  GOTO   01EE (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO ALL ADCs                                        */
.................... /*****************************************************************************/
.................... void ads_write_command_all(unsigned int8 command)
.................... {
....................    ads_select_all();
*
00808:  BRA    07E8
....................    spi_write2(command);
0080A:  MOVLB  E
0080C:  MOVF   x8D,W
0080E:  MOVFF  701,E8D
00812:  RRCF   x90,W
00814:  BNC   0812
00816:  MOVLB  0
00818:  GOTO   0826 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PREPARE TO READ FROM AN ADC                                               */
.................... /*****************************************************************************/
.................... void ads_read_command(int8 ch, unsigned int8 command)
.................... {
....................    ads_select_ch(ch);
*
00834:  MOVFF  709,70C
00838:  RCALL  06CC
....................    spi_read2(command);
0083A:  MOVLB  E
0083C:  MOVF   x8D,W
0083E:  MOVFF  70A,E8D
00842:  RRCF   x90,W
00844:  BNC   0842
00846:  MOVLB  0
00848:  GOTO   085A (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE TO THE CONFIGURATION REGISTERS                                      */
.................... /*****************************************************************************/
.................... void ads_write_reg(int8 ch, adsReg regID, int8 data)
*
0074C:  MOVLB  7
0074E:  MOVF   x07,W
00750:  IORLW  40
00752:  MOVWF  x09
.................... {
....................    unsigned int8 command = ADSwriteReg | regID | 0; // 0 is numbytes to write-1
....................    ads_write_command(ch, command);
00754:  MOVFF  706,70A
00758:  MOVFF  709,70B
0075C:  MOVLB  0
0075E:  RCALL  0736
....................    spi_write2(data);
00760:  MOVLB  E
00762:  MOVF   x8D,W
00764:  MOVFF  708,E8D
00768:  RRCF   x90,W
0076A:  BNC   0768
....................    ads_deselect_all();
0076C:  MOVLB  0
0076E:  RCALL  0174
00770:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* READ FROM THE CONFIGURATION REGISTERS                                     */
.................... /*****************************************************************************/
.................... unsigned int8 ads_read_reg(int8 ch, adsReg regID)
.................... {
....................    unsigned int8 command = ADSreadReg | regID | 0;
....................    ads_read_command(ch, command);
....................    unsigned int8 data = spi_read2(0);
....................    ads_deselect_all();
....................    return data;
.................... }
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* START BLOCK CONVERSION                                                    */
.................... /*****************************************************************************/
.................... void ads_start_conv_block(int8 block)
.................... {
....................    ads_write_command_block(block, ADSstart);
*
001E0:  MOVFF  771,772
001E4:  MOVLW  08
001E6:  MOVLB  7
001E8:  MOVWF  x73
001EA:  MOVLB  0
001EC:  BRA    01C8
....................    delay_us(10);
001EE:  MOVLW  35
001F0:  MOVWF  00
001F2:  DECFSZ 00,F
001F4:  BRA    01F2
....................    ads_deselect_all();
001F6:  RCALL  0174
001F8:  GOTO   023E (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* START ALL CONVERSION                                                      */
.................... /*****************************************************************************/
.................... void ads_start_conv_all()
.................... {
....................    ads_write_command_all(ADSstart);
*
0081C:  MOVLW  08
0081E:  MOVLB  7
00820:  MOVWF  x01
00822:  MOVLB  0
00824:  BRA    0808
....................    delay_us(10);
00826:  MOVLW  35
00828:  MOVWF  00
0082A:  DECFSZ 00,F
0082C:  BRA    082A
....................    ads_deselect_all();
0082E:  RCALL  0174
00830:  GOTO   09B6 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* READ THE MOST RECENT CONVERSION                                           */
.................... /*****************************************************************************/
.................... signed int32 ads_read_data(int8 ch)
.................... {
....................    union Data
....................    {
....................       unsigned int8 dBytes[4];
....................       signed int32 dWord;
....................    }data;
....................    
....................    ads_read_command(ch, ADSreadData);
*
0084C:  MOVFF  704,709
00850:  MOVLW  10
00852:  MOVLB  7
00854:  MOVWF  x0A
00856:  MOVLB  0
00858:  BRA    0834
....................    data.dBytes[3] = 0;
0085A:  MOVLB  7
0085C:  CLRF   x08
....................    data.dBytes[2] = spi_read2(0);
0085E:  MOVLB  E
00860:  MOVF   x8D,W
00862:  CLRF   x8D
00864:  RRCF   x90,W
00866:  BNC   0864
00868:  MOVFF  E8D,707
....................    data.dBytes[1] = spi_read2(0);
0086C:  MOVF   x8D,W
0086E:  CLRF   x8D
00870:  RRCF   x90,W
00872:  BNC   0870
00874:  MOVFF  E8D,706
....................    data.dBytes[0] = spi_read2(0);
00878:  MOVF   x8D,W
0087A:  CLRF   x8D
0087C:  RRCF   x90,W
0087E:  BNC   087C
00880:  MOVFF  E8D,705
....................    
....................    //convert 24-bit 2's complement to 32-bit 2's complement
....................    if (0x80 & data.dBytes[2]) data.dBytes[3] |= 0xFF;
00884:  MOVLB  7
00886:  MOVF   x07,W
00888:  ANDLW  80
0088A:  BZ    0890
0088C:  MOVLW  FF
0088E:  IORWF  x08,F
....................    
....................    ads_deselect_all();
00890:  MOVLB  0
00892:  RCALL  0174
....................    return data.dWord;
00894:  MOVFF  705,00
00898:  MOVFF  706,01
0089C:  MOVFF  707,02
008A0:  MOVFF  708,03
008A4:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE A CHANNEL                                                      */
.................... /*****************************************************************************/
.................... 
.................... void ADS1220init(int8 ch, rc0=reg0config, rc1=reg1config, rc2=reg2config, rc3=reg3config)
.................... {
....................    ads_write_command(ch, ADSreset);   //reset the device
*
00772:  MOVFF  701,70A
00776:  MOVLW  06
00778:  MOVLB  7
0077A:  MOVWF  x0B
0077C:  MOVLB  0
0077E:  RCALL  0736
....................    delay_us(300);                    
00780:  MOVLW  02
00782:  MOVLB  7
00784:  MOVWF  x06
00786:  CLRF   19
00788:  BTFSC  FF2.7
0078A:  BSF    19.7
0078C:  BCF    FF2.7
0078E:  MOVLW  96
00790:  MOVWF  x72
00792:  MOVLB  0
00794:  RCALL  00CA
00796:  BTFSC  19.7
00798:  BSF    FF2.7
0079A:  MOVLB  7
0079C:  DECFSZ x06,F
0079E:  BRA    0786
....................    ads_write_reg(ch, reg0, rc0);   //send default configurations
007A0:  MOVFF  701,706
007A4:  CLRF   x07
007A6:  MOVFF  702,708
007AA:  MOVLB  0
007AC:  RCALL  074C
....................    ads_write_reg(ch, reg1, rc1);
007AE:  MOVFF  701,706
007B2:  MOVLW  04
007B4:  MOVLB  7
007B6:  MOVWF  x07
007B8:  MOVFF  703,708
007BC:  MOVLB  0
007BE:  RCALL  074C
....................    ads_write_reg(ch, reg2, rc2);
007C0:  MOVFF  701,706
007C4:  MOVLW  08
007C6:  MOVLB  7
007C8:  MOVWF  x07
007CA:  MOVFF  704,708
007CE:  MOVLB  0
007D0:  RCALL  074C
....................    ads_write_reg(ch, reg3, rc3);  
007D2:  MOVFF  701,706
007D6:  MOVLW  0C
007D8:  MOVLB  7
007DA:  MOVWF  x07
007DC:  MOVFF  705,708
007E0:  MOVLB  0
007E2:  RCALL  074C
007E4:  GOTO   0990 (RETURN)
.................... }
.................... #endif 
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
*
0274C:  MOVLB  7
0274E:  BCF    x45.0
....................    y = x;
02750:  MOVFF  739,73E
02754:  MOVFF  738,73D
02758:  MOVFF  737,73C
0275C:  MOVFF  736,73B
.................... 
....................    if (x < 0)
02760:  MOVFF  739,749
02764:  MOVFF  738,748
02768:  MOVFF  737,747
0276C:  MOVFF  736,746
02770:  CLRF   x4D
02772:  CLRF   x4C
02774:  CLRF   x4B
02776:  CLRF   x4A
02778:  MOVLB  0
0277A:  CALL   1D1C
0277E:  BNC   278C
....................    {
....................       s = 1;
02780:  MOVLB  7
02782:  BSF    x45.0
....................       y = -y;
02784:  MOVF   x3C,W
02786:  XORLW  80
02788:  MOVWF  x3C
0278A:  MOVLB  0
....................    }
.................... 
....................    if (y <= 32768.0)
0278C:  MOVFF  73E,749
02790:  MOVFF  73D,748
02794:  MOVFF  73C,747
02798:  MOVFF  73B,746
0279C:  MOVLB  7
0279E:  CLRF   x4D
027A0:  CLRF   x4C
027A2:  CLRF   x4B
027A4:  MOVLW  8E
027A6:  MOVWF  x4A
027A8:  MOVLB  0
027AA:  CALL   1D1C
027AE:  BC    27B2
027B0:  BNZ   27E2
....................       res = (float32)(unsigned int16)y;
027B2:  MOVFF  73E,749
027B6:  MOVFF  73D,748
027BA:  MOVFF  73C,747
027BE:  MOVFF  73B,746
027C2:  RCALL  2710
027C4:  MOVFF  02,74B
027C8:  MOVFF  01,74A
027CC:  CALL   0D5A
027D0:  MOVFF  03,742
027D4:  MOVFF  02,741
027D8:  MOVFF  01,740
027DC:  MOVFF  00,73F
027E0:  BRA    2984
.................... 
....................  else if (y < 10000000.0)
027E2:  MOVFF  73E,749
027E6:  MOVFF  73D,748
027EA:  MOVFF  73C,747
027EE:  MOVFF  73B,746
027F2:  MOVLW  80
027F4:  MOVLB  7
027F6:  MOVWF  x4D
027F8:  MOVLW  96
027FA:  MOVWF  x4C
027FC:  MOVLW  18
027FE:  MOVWF  x4B
02800:  MOVLW  96
02802:  MOVWF  x4A
02804:  MOVLB  0
02806:  CALL   1D1C
0280A:  BTFSS  FD8.0
0280C:  BRA    2974
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
0280E:  MOVFF  73E,753
02812:  MOVFF  73D,752
02816:  MOVFF  73C,751
0281A:  MOVFF  73B,750
0281E:  MOVLB  7
02820:  CLRF   x57
02822:  CLRF   x56
02824:  CLRF   x55
02826:  MOVLW  70
02828:  MOVWF  x54
0282A:  MOVLB  0
0282C:  CALL   0D90
02830:  MOVFF  03,749
02834:  MOVFF  02,748
02838:  MOVFF  01,747
0283C:  MOVFF  00,746
02840:  RCALL  2710
02842:  MOVFF  02,744
02846:  MOVFF  01,743
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
0284A:  MOVFF  73E,753
0284E:  MOVFF  73D,752
02852:  MOVFF  73C,751
02856:  MOVFF  73B,750
0285A:  MOVLB  7
0285C:  CLRF   x57
0285E:  CLRF   x56
02860:  CLRF   x55
02862:  MOVLW  70
02864:  MOVWF  x54
02866:  MOVLB  0
02868:  CALL   0D90
0286C:  MOVFF  03,749
02870:  MOVFF  02,748
02874:  MOVFF  01,747
02878:  MOVFF  00,746
0287C:  MOVFF  744,74B
02880:  MOVFF  743,74A
02884:  CALL   0D5A
02888:  BSF    FD8.1
0288A:  MOVFF  749,74D
0288E:  MOVFF  748,74C
02892:  MOVFF  747,74B
02896:  MOVFF  746,74A
0289A:  MOVFF  03,751
0289E:  MOVFF  02,750
028A2:  MOVFF  01,74F
028A6:  MOVFF  00,74E
028AA:  CALL   0E86
028AE:  MOVLB  7
028B0:  CLRF   x53
028B2:  CLRF   x52
028B4:  CLRF   x51
028B6:  MOVLW  8E
028B8:  MOVWF  x50
028BA:  MOVFF  03,757
028BE:  MOVFF  02,756
028C2:  MOVFF  01,755
028C6:  MOVFF  00,754
028CA:  MOVLB  0
028CC:  CALL   0D90
028D0:  MOVFF  03,73E
028D4:  MOVFF  02,73D
028D8:  MOVFF  01,73C
028DC:  MOVFF  00,73B
....................       res = 32768.0*(float32)l;
028E0:  MOVFF  744,74B
028E4:  MOVFF  743,74A
028E8:  CALL   0D5A
028EC:  MOVLB  7
028EE:  CLRF   x53
028F0:  CLRF   x52
028F2:  CLRF   x51
028F4:  MOVLW  8E
028F6:  MOVWF  x50
028F8:  MOVFF  03,757
028FC:  MOVFF  02,756
02900:  MOVFF  01,755
02904:  MOVFF  00,754
02908:  MOVLB  0
0290A:  CALL   0D90
0290E:  MOVFF  03,742
02912:  MOVFF  02,741
02916:  MOVFF  01,740
0291A:  MOVFF  00,73F
....................       res += (float32)(unsigned int16)y;
0291E:  MOVFF  73E,749
02922:  MOVFF  73D,748
02926:  MOVFF  73C,747
0292A:  MOVFF  73B,746
0292E:  RCALL  2710
02930:  MOVFF  02,74B
02934:  MOVFF  01,74A
02938:  CALL   0D5A
0293C:  BCF    FD8.1
0293E:  MOVFF  742,74D
02942:  MOVFF  741,74C
02946:  MOVFF  740,74B
0294A:  MOVFF  73F,74A
0294E:  MOVFF  03,751
02952:  MOVFF  02,750
02956:  MOVFF  01,74F
0295A:  MOVFF  00,74E
0295E:  CALL   0E86
02962:  MOVFF  03,742
02966:  MOVFF  02,741
0296A:  MOVFF  01,740
0296E:  MOVFF  00,73F
....................    }
02972:  BRA    2984
.................... 
....................  else
....................   res = y;
02974:  MOVFF  73E,742
02978:  MOVFF  73D,741
0297C:  MOVFF  73C,740
02980:  MOVFF  73B,73F
.................... 
....................  y = y - (float32)(unsigned int16)y;
02984:  MOVFF  73E,749
02988:  MOVFF  73D,748
0298C:  MOVFF  73C,747
02990:  MOVFF  73B,746
02994:  RCALL  2710
02996:  MOVFF  02,74B
0299A:  MOVFF  01,74A
0299E:  CALL   0D5A
029A2:  BSF    FD8.1
029A4:  MOVFF  73E,74D
029A8:  MOVFF  73D,74C
029AC:  MOVFF  73C,74B
029B0:  MOVFF  73B,74A
029B4:  MOVFF  03,751
029B8:  MOVFF  02,750
029BC:  MOVFF  01,74F
029C0:  MOVFF  00,74E
029C4:  CALL   0E86
029C8:  MOVFF  03,73E
029CC:  MOVFF  02,73D
029D0:  MOVFF  01,73C
029D4:  MOVFF  00,73B
.................... 
....................  if (s)
029D8:  MOVLB  7
029DA:  BTFSS  x45.0
029DC:  BRA    29E4
....................   res = -res;
029DE:  MOVF   x40,W
029E0:  XORLW  80
029E2:  MOVWF  x40
.................... 
....................  if (y != 0)
029E4:  MOVFF  73E,749
029E8:  MOVFF  73D,748
029EC:  MOVFF  73C,747
029F0:  MOVFF  73B,746
029F4:  CLRF   x4D
029F6:  CLRF   x4C
029F8:  CLRF   x4B
029FA:  CLRF   x4A
029FC:  MOVLB  0
029FE:  CALL   1D1C
02A02:  BZ    2A7C
....................  {
....................   if (s == 1 && n == 0)
02A04:  MOVLB  7
02A06:  BTFSS  x45.0
02A08:  BRA    2A42
02A0A:  MOVF   x3A,F
02A0C:  BNZ   2A42
....................    res -= 1.0;
02A0E:  BSF    FD8.1
02A10:  MOVFF  742,74D
02A14:  MOVFF  741,74C
02A18:  MOVFF  740,74B
02A1C:  MOVFF  73F,74A
02A20:  CLRF   x51
02A22:  CLRF   x50
02A24:  CLRF   x4F
02A26:  MOVLW  7F
02A28:  MOVWF  x4E
02A2A:  MOVLB  0
02A2C:  CALL   0E86
02A30:  MOVFF  03,742
02A34:  MOVFF  02,741
02A38:  MOVFF  01,740
02A3C:  MOVFF  00,73F
02A40:  MOVLB  7
.................... 
....................   if (s == 0 && n == 1)
02A42:  BTFSC  x45.0
02A44:  BRA    2A7E
02A46:  DECFSZ x3A,W
02A48:  BRA    2A7E
....................    res += 1.0;
02A4A:  BCF    FD8.1
02A4C:  MOVFF  742,74D
02A50:  MOVFF  741,74C
02A54:  MOVFF  740,74B
02A58:  MOVFF  73F,74A
02A5C:  CLRF   x51
02A5E:  CLRF   x50
02A60:  CLRF   x4F
02A62:  MOVLW  7F
02A64:  MOVWF  x4E
02A66:  MOVLB  0
02A68:  CALL   0E86
02A6C:  MOVFF  03,742
02A70:  MOVFF  02,741
02A74:  MOVFF  01,740
02A78:  MOVFF  00,73F
02A7C:  MOVLB  7
....................  }
....................  if (x == 0)
02A7E:  MOVFF  739,749
02A82:  MOVFF  738,748
02A86:  MOVFF  737,747
02A8A:  MOVFF  736,746
02A8E:  CLRF   x4D
02A90:  CLRF   x4C
02A92:  CLRF   x4B
02A94:  CLRF   x4A
02A96:  MOVLB  0
02A98:  CALL   1D1C
02A9C:  BNZ   2AAA
....................     res = 0;
02A9E:  MOVLB  7
02AA0:  CLRF   x42
02AA2:  CLRF   x41
02AA4:  CLRF   x40
02AA6:  CLRF   x3F
02AA8:  MOVLB  0
.................... 
....................  return (res);
02AAA:  MOVFF  73F,00
02AAE:  MOVFF  740,01
02AB2:  MOVFF  741,02
02AB6:  MOVFF  742,03
02ABA:  RETURN 0
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
*
02ADA:  MOVFF  735,739
02ADE:  MOVFF  734,738
02AE2:  MOVFF  733,737
02AE6:  MOVFF  732,736
02AEA:  MOVLB  7
02AEC:  CLRF   x3A
02AEE:  MOVLB  0
02AF0:  RCALL  274C
02AF2:  GOTO   2BFE (RETURN)
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
*
02ABC:  MOVFF  735,739
02AC0:  MOVFF  734,738
02AC4:  MOVFF  733,737
02AC8:  MOVFF  732,736
02ACC:  MOVLW  01
02ACE:  MOVLB  7
02AD0:  MOVWF  x3A
02AD2:  MOVLB  0
02AD4:  RCALL  274C
02AD6:  GOTO   2BB6 (RETURN)
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
*
02AF6:  MOVFF  729,749
02AFA:  MOVFF  728,748
02AFE:  MOVFF  727,747
02B02:  MOVFF  726,746
02B06:  MOVLB  7
02B08:  CLRF   x4D
02B0A:  CLRF   x4C
02B0C:  CLRF   x4B
02B0E:  CLRF   x4A
02B10:  MOVLB  0
02B12:  CALL   1D1C
02B16:  BTFSC  FD8.2
02B18:  BRA    2C5A
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
02B1A:  MOVFF  725,742
02B1E:  MOVFF  724,741
02B22:  MOVFF  723,740
02B26:  MOVFF  722,73F
02B2A:  MOVFF  729,746
02B2E:  MOVFF  728,745
02B32:  MOVFF  727,744
02B36:  MOVFF  726,743
02B3A:  CALL   1D96
02B3E:  MOVFF  03,731
02B42:  MOVFF  02,730
02B46:  MOVFF  01,72F
02B4A:  MOVFF  00,72E
02B4E:  MOVFF  03,749
02B52:  MOVFF  02,748
02B56:  MOVFF  01,747
02B5A:  MOVFF  00,746
02B5E:  MOVLB  7
02B60:  CLRF   x4D
02B62:  CLRF   x4C
02B64:  CLRF   x4B
02B66:  CLRF   x4A
02B68:  MOVLB  0
02B6A:  CALL   1D1C
02B6E:  BNC   2BB8
02B70:  MOVFF  725,742
02B74:  MOVFF  724,741
02B78:  MOVFF  723,740
02B7C:  MOVFF  722,73F
02B80:  MOVFF  729,746
02B84:  MOVFF  728,745
02B88:  MOVFF  727,744
02B8C:  MOVFF  726,743
02B90:  CALL   1D96
02B94:  MOVFF  03,731
02B98:  MOVFF  02,730
02B9C:  MOVFF  01,72F
02BA0:  MOVFF  00,72E
02BA4:  MOVFF  03,735
02BA8:  MOVFF  02,734
02BAC:  MOVFF  01,733
02BB0:  MOVFF  00,732
02BB4:  BRA    2ABC
02BB6:  BRA    2BFE
02BB8:  MOVFF  725,742
02BBC:  MOVFF  724,741
02BC0:  MOVFF  723,740
02BC4:  MOVFF  722,73F
02BC8:  MOVFF  729,746
02BCC:  MOVFF  728,745
02BD0:  MOVFF  727,744
02BD4:  MOVFF  726,743
02BD8:  CALL   1D96
02BDC:  MOVFF  03,731
02BE0:  MOVFF  02,730
02BE4:  MOVFF  01,72F
02BE8:  MOVFF  00,72E
02BEC:  MOVFF  03,735
02BF0:  MOVFF  02,734
02BF4:  MOVFF  01,733
02BF8:  MOVFF  00,732
02BFC:  BRA    2ADA
02BFE:  MOVFF  03,72D
02C02:  MOVFF  02,72C
02C06:  MOVFF  01,72B
02C0A:  MOVFF  00,72A
....................       return(x-(i*y));
02C0E:  MOVFF  72D,753
02C12:  MOVFF  72C,752
02C16:  MOVFF  72B,751
02C1A:  MOVFF  72A,750
02C1E:  MOVFF  729,757
02C22:  MOVFF  728,756
02C26:  MOVFF  727,755
02C2A:  MOVFF  726,754
02C2E:  CALL   0D90
02C32:  BSF    FD8.1
02C34:  MOVFF  725,74D
02C38:  MOVFF  724,74C
02C3C:  MOVFF  723,74B
02C40:  MOVFF  722,74A
02C44:  MOVFF  03,751
02C48:  MOVFF  02,750
02C4C:  MOVFF  01,74F
02C50:  MOVFF  00,74E
02C54:  CALL   0E86
02C58:  BRA    2C5A
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
02C5A:  RETURN 0
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
*
02FF0:  MOVFF  729,753
02FF4:  MOVFF  728,752
02FF8:  MOVFF  727,751
02FFC:  MOVFF  726,750
03000:  MOVLW  3B
03002:  MOVLB  7
03004:  MOVWF  x57
03006:  MOVLW  AA
03008:  MOVWF  x56
0300A:  MOVLW  38
0300C:  MOVWF  x55
0300E:  MOVLW  7F
03010:  MOVWF  x54
03012:  MOVLB  0
03014:  CALL   0D90
03018:  MOVFF  03,749
0301C:  MOVFF  02,748
03020:  MOVFF  01,747
03024:  MOVFF  00,746
03028:  CALL   2710
0302C:  MOVFF  01,736
....................    s = 0;
03030:  MOVLB  7
03032:  BCF    x37.0
....................    y = x;
03034:  MOVFF  729,72D
03038:  MOVFF  728,72C
0303C:  MOVFF  727,72B
03040:  MOVFF  726,72A
.................... 
....................    if (x < 0)
03044:  MOVFF  729,749
03048:  MOVFF  728,748
0304C:  MOVFF  727,747
03050:  MOVFF  726,746
03054:  CLRF   x4D
03056:  CLRF   x4C
03058:  CLRF   x4B
0305A:  CLRF   x4A
0305C:  MOVLB  0
0305E:  CALL   1D1C
03062:  BNC   3072
....................    {
....................       s = 1;
03064:  MOVLB  7
03066:  BSF    x37.0
....................       n = -n;
03068:  NEGF   x36
....................       y = -y;
0306A:  MOVF   x2B,W
0306C:  XORLW  80
0306E:  MOVWF  x2B
03070:  MOVLB  0
....................    }
.................... 
....................    res = 0.0;
03072:  MOVLB  7
03074:  CLRF   x31
03076:  CLRF   x30
03078:  CLRF   x2F
0307A:  CLRF   x2E
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
0307C:  MOVLW  07
0307E:  MOVWF  x39
03080:  MOVLW  2E
03082:  MOVFF  739,FEA
03086:  MOVWF  FE9
03088:  MOVLW  7F
0308A:  ADDWF  x36,W
0308C:  MOVWF  FEF
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
0308E:  MOVFF  72D,753
03092:  MOVFF  72C,752
03096:  MOVFF  72B,751
0309A:  MOVFF  72A,750
0309E:  MOVLW  3B
030A0:  MOVWF  x57
030A2:  MOVLW  AA
030A4:  MOVWF  x56
030A6:  MOVLW  38
030A8:  MOVWF  x55
030AA:  MOVLW  7F
030AC:  MOVWF  x54
030AE:  MOVLB  0
030B0:  CALL   0D90
030B4:  MOVFF  03,73B
030B8:  MOVFF  02,73A
030BC:  MOVFF  01,739
030C0:  MOVFF  00,738
030C4:  MOVLB  7
030C6:  CLRF   x3D
030C8:  MOVFF  736,73C
030CC:  BTFSC  x3C.7
030CE:  DECF   x3D,F
030D0:  MOVLB  0
030D2:  CALL   26C0
030D6:  BSF    FD8.1
030D8:  MOVFF  73B,74D
030DC:  MOVFF  73A,74C
030E0:  MOVFF  739,74B
030E4:  MOVFF  738,74A
030E8:  MOVFF  03,751
030EC:  MOVFF  02,750
030F0:  MOVFF  01,74F
030F4:  MOVFF  00,74E
030F8:  CALL   0E86
030FC:  MOVFF  03,72D
03100:  MOVFF  02,72C
03104:  MOVFF  01,72B
03108:  MOVFF  00,72A
.................... 
....................    r = pe[0]*y + pe[1];
0310C:  MOVLW  7C
0310E:  MOVLB  7
03110:  MOVWF  x53
03112:  MOVLW  88
03114:  MOVWF  x52
03116:  MOVLW  59
03118:  MOVWF  x51
0311A:  MOVLW  72
0311C:  MOVWF  x50
0311E:  MOVFF  72D,757
03122:  MOVFF  72C,756
03126:  MOVFF  72B,755
0312A:  MOVFF  72A,754
0312E:  MOVLB  0
03130:  CALL   0D90
03134:  MOVFF  03,73B
03138:  MOVFF  02,73A
0313C:  MOVFF  01,739
03140:  MOVFF  00,738
03144:  BCF    FD8.1
03146:  MOVFF  03,74D
0314A:  MOVFF  02,74C
0314E:  MOVFF  01,74B
03152:  MOVFF  00,74A
03156:  MOVLW  E0
03158:  MOVLB  7
0315A:  MOVWF  x51
0315C:  MOVLW  97
0315E:  MOVWF  x50
03160:  MOVLW  26
03162:  MOVWF  x4F
03164:  MOVLW  75
03166:  MOVWF  x4E
03168:  MOVLB  0
0316A:  CALL   0E86
0316E:  MOVFF  03,735
03172:  MOVFF  02,734
03176:  MOVFF  01,733
0317A:  MOVFF  00,732
....................    r = r*y + pe[2];
0317E:  MOVFF  735,753
03182:  MOVFF  734,752
03186:  MOVFF  733,751
0318A:  MOVFF  732,750
0318E:  MOVFF  72D,757
03192:  MOVFF  72C,756
03196:  MOVFF  72B,755
0319A:  MOVFF  72A,754
0319E:  CALL   0D90
031A2:  MOVFF  03,73B
031A6:  MOVFF  02,73A
031AA:  MOVFF  01,739
031AE:  MOVFF  00,738
031B2:  BCF    FD8.1
031B4:  MOVFF  03,74D
031B8:  MOVFF  02,74C
031BC:  MOVFF  01,74B
031C0:  MOVFF  00,74A
031C4:  MOVLW  C4
031C6:  MOVLB  7
031C8:  MOVWF  x51
031CA:  MOVLW  1D
031CC:  MOVWF  x50
031CE:  MOVLW  1E
031D0:  MOVWF  x4F
031D2:  MOVLW  78
031D4:  MOVWF  x4E
031D6:  MOVLB  0
031D8:  CALL   0E86
031DC:  MOVFF  03,735
031E0:  MOVFF  02,734
031E4:  MOVFF  01,733
031E8:  MOVFF  00,732
....................    r = r*y + pe[3];
031EC:  MOVFF  735,753
031F0:  MOVFF  734,752
031F4:  MOVFF  733,751
031F8:  MOVFF  732,750
031FC:  MOVFF  72D,757
03200:  MOVFF  72C,756
03204:  MOVFF  72B,755
03208:  MOVFF  72A,754
0320C:  CALL   0D90
03210:  MOVFF  03,73B
03214:  MOVFF  02,73A
03218:  MOVFF  01,739
0321C:  MOVFF  00,738
03220:  BCF    FD8.1
03222:  MOVFF  03,74D
03226:  MOVFF  02,74C
0322A:  MOVFF  01,74B
0322E:  MOVFF  00,74A
03232:  MOVLW  5E
03234:  MOVLB  7
03236:  MOVWF  x51
03238:  MOVLW  50
0323A:  MOVWF  x50
0323C:  MOVLW  63
0323E:  MOVWF  x4F
03240:  MOVLW  7A
03242:  MOVWF  x4E
03244:  MOVLB  0
03246:  CALL   0E86
0324A:  MOVFF  03,735
0324E:  MOVFF  02,734
03252:  MOVFF  01,733
03256:  MOVFF  00,732
....................    r = r*y + pe[4];
0325A:  MOVFF  735,753
0325E:  MOVFF  734,752
03262:  MOVFF  733,751
03266:  MOVFF  732,750
0326A:  MOVFF  72D,757
0326E:  MOVFF  72C,756
03272:  MOVFF  72B,755
03276:  MOVFF  72A,754
0327A:  CALL   0D90
0327E:  MOVFF  03,73B
03282:  MOVFF  02,73A
03286:  MOVFF  01,739
0328A:  MOVFF  00,738
0328E:  BCF    FD8.1
03290:  MOVFF  03,74D
03294:  MOVFF  02,74C
03298:  MOVFF  01,74B
0329C:  MOVFF  00,74A
032A0:  MOVLW  1A
032A2:  MOVLB  7
032A4:  MOVWF  x51
032A6:  MOVLW  FE
032A8:  MOVWF  x50
032AA:  MOVLW  75
032AC:  MOVWF  x4F
032AE:  MOVLW  7C
032B0:  MOVWF  x4E
032B2:  MOVLB  0
032B4:  CALL   0E86
032B8:  MOVFF  03,735
032BC:  MOVFF  02,734
032C0:  MOVFF  01,733
032C4:  MOVFF  00,732
....................    r = r*y + pe[5];
032C8:  MOVFF  735,753
032CC:  MOVFF  734,752
032D0:  MOVFF  733,751
032D4:  MOVFF  732,750
032D8:  MOVFF  72D,757
032DC:  MOVFF  72C,756
032E0:  MOVFF  72B,755
032E4:  MOVFF  72A,754
032E8:  CALL   0D90
032EC:  MOVFF  03,73B
032F0:  MOVFF  02,73A
032F4:  MOVFF  01,739
032F8:  MOVFF  00,738
032FC:  BCF    FD8.1
032FE:  MOVFF  03,74D
03302:  MOVFF  02,74C
03306:  MOVFF  01,74B
0330A:  MOVFF  00,74A
0330E:  MOVLW  18
03310:  MOVLB  7
03312:  MOVWF  x51
03314:  MOVLW  72
03316:  MOVWF  x50
03318:  MOVLW  31
0331A:  MOVWF  x4F
0331C:  MOVLW  7E
0331E:  MOVWF  x4E
03320:  MOVLB  0
03322:  CALL   0E86
03326:  MOVFF  03,735
0332A:  MOVFF  02,734
0332E:  MOVFF  01,733
03332:  MOVFF  00,732
.................... 
....................    res = res*(1.0 + y*r);
03336:  MOVFF  72D,753
0333A:  MOVFF  72C,752
0333E:  MOVFF  72B,751
03342:  MOVFF  72A,750
03346:  MOVFF  735,757
0334A:  MOVFF  734,756
0334E:  MOVFF  733,755
03352:  MOVFF  732,754
03356:  CALL   0D90
0335A:  BCF    FD8.1
0335C:  MOVLB  7
0335E:  CLRF   x4D
03360:  CLRF   x4C
03362:  CLRF   x4B
03364:  MOVLW  7F
03366:  MOVWF  x4A
03368:  MOVFF  03,751
0336C:  MOVFF  02,750
03370:  MOVFF  01,74F
03374:  MOVFF  00,74E
03378:  MOVLB  0
0337A:  CALL   0E86
0337E:  MOVFF  731,753
03382:  MOVFF  730,752
03386:  MOVFF  72F,751
0338A:  MOVFF  72E,750
0338E:  MOVFF  03,757
03392:  MOVFF  02,756
03396:  MOVFF  01,755
0339A:  MOVFF  00,754
0339E:  CALL   0D90
033A2:  MOVFF  03,731
033A6:  MOVFF  02,730
033AA:  MOVFF  01,72F
033AE:  MOVFF  00,72E
.................... 
....................    if (s)
033B2:  MOVLB  7
033B4:  BTFSS  x37.0
033B6:  BRA    33EA
....................       res = 1.0/res;
033B8:  CLRF   x42
033BA:  CLRF   x41
033BC:  CLRF   x40
033BE:  MOVLW  7F
033C0:  MOVWF  x3F
033C2:  MOVFF  731,746
033C6:  MOVFF  730,745
033CA:  MOVFF  72F,744
033CE:  MOVFF  72E,743
033D2:  MOVLB  0
033D4:  CALL   1D96
033D8:  MOVFF  03,731
033DC:  MOVFF  02,730
033E0:  MOVFF  01,72F
033E4:  MOVFF  00,72E
033E8:  MOVLB  7
....................    return(res);
033EA:  MOVFF  72E,00
033EE:  MOVFF  72F,01
033F2:  MOVFF  730,02
033F6:  MOVFF  731,03
033FA:  MOVLB  0
033FC:  RETURN 0
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
*
02C5C:  MOVFF  729,72D
02C60:  MOVFF  728,72C
02C64:  MOVFF  727,72B
02C68:  MOVFF  726,72A
.................... 
....................    if (y != 1.0)
02C6C:  MOVFF  72D,749
02C70:  MOVFF  72C,748
02C74:  MOVFF  72B,747
02C78:  MOVFF  72A,746
02C7C:  MOVLB  7
02C7E:  CLRF   x4D
02C80:  CLRF   x4C
02C82:  CLRF   x4B
02C84:  MOVLW  7F
02C86:  MOVWF  x4A
02C88:  MOVLB  0
02C8A:  CALL   1D1C
02C8E:  BTFSC  FD8.2
02C90:  BRA    2FD2
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
02C92:  MOVLW  07
02C94:  MOVLB  7
02C96:  MOVWF  x3C
02C98:  MOVLW  2A
02C9A:  MOVFF  73C,FEA
02C9E:  MOVWF  FE9
02CA0:  MOVLW  7E
02CA2:  MOVWF  FEF
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
02CA4:  BSF    FD8.1
02CA6:  MOVFF  72D,74D
02CAA:  MOVFF  72C,74C
02CAE:  MOVFF  72B,74B
02CB2:  MOVFF  72A,74A
02CB6:  CLRF   x51
02CB8:  CLRF   x50
02CBA:  CLRF   x4F
02CBC:  MOVLW  7F
02CBE:  MOVWF  x4E
02CC0:  MOVLB  0
02CC2:  CALL   0E86
02CC6:  MOVFF  03,73E
02CCA:  MOVFF  02,73D
02CCE:  MOVFF  01,73C
02CD2:  MOVFF  00,73B
02CD6:  BCF    FD8.1
02CD8:  MOVFF  72D,74D
02CDC:  MOVFF  72C,74C
02CE0:  MOVFF  72B,74B
02CE4:  MOVFF  72A,74A
02CE8:  MOVLB  7
02CEA:  CLRF   x51
02CEC:  CLRF   x50
02CEE:  CLRF   x4F
02CF0:  MOVLW  7F
02CF2:  MOVWF  x4E
02CF4:  MOVLB  0
02CF6:  CALL   0E86
02CFA:  MOVFF  73E,742
02CFE:  MOVFF  73D,741
02D02:  MOVFF  73C,740
02D06:  MOVFF  73B,73F
02D0A:  MOVFF  03,746
02D0E:  MOVFF  02,745
02D12:  MOVFF  01,744
02D16:  MOVFF  00,743
02D1A:  CALL   1D96
02D1E:  MOVFF  03,72D
02D22:  MOVFF  02,72C
02D26:  MOVFF  01,72B
02D2A:  MOVFF  00,72A
.................... 
....................       y2=y*y;
02D2E:  MOVFF  72D,753
02D32:  MOVFF  72C,752
02D36:  MOVFF  72B,751
02D3A:  MOVFF  72A,750
02D3E:  MOVFF  72D,757
02D42:  MOVFF  72C,756
02D46:  MOVFF  72B,755
02D4A:  MOVFF  72A,754
02D4E:  CALL   0D90
02D52:  MOVFF  03,739
02D56:  MOVFF  02,738
02D5A:  MOVFF  01,737
02D5E:  MOVFF  00,736
.................... 
....................       res = pl[0]*y2 + pl[1];
02D62:  MOVLW  99
02D64:  MOVLB  7
02D66:  MOVWF  x53
02D68:  MOVLW  47
02D6A:  MOVWF  x52
02D6C:  MOVLW  8A
02D6E:  MOVWF  x51
02D70:  MOVLW  7F
02D72:  MOVWF  x50
02D74:  MOVFF  739,757
02D78:  MOVFF  738,756
02D7C:  MOVFF  737,755
02D80:  MOVFF  736,754
02D84:  MOVLB  0
02D86:  CALL   0D90
02D8A:  MOVFF  03,73E
02D8E:  MOVFF  02,73D
02D92:  MOVFF  01,73C
02D96:  MOVFF  00,73B
02D9A:  BCF    FD8.1
02D9C:  MOVFF  03,74D
02DA0:  MOVFF  02,74C
02DA4:  MOVFF  01,74B
02DA8:  MOVFF  00,74A
02DAC:  MOVLB  7
02DAE:  CLRF   x51
02DB0:  CLRF   x50
02DB2:  CLRF   x4F
02DB4:  MOVLW  80
02DB6:  MOVWF  x4E
02DB8:  MOVLB  0
02DBA:  CALL   0E86
02DBE:  MOVFF  03,731
02DC2:  MOVFF  02,730
02DC6:  MOVFF  01,72F
02DCA:  MOVFF  00,72E
.................... 
....................       r = ql[0]*y2 + ql[1];
02DCE:  MOVLW  4C
02DD0:  MOVLB  7
02DD2:  MOVWF  x53
02DD4:  MOVLW  F3
02DD6:  MOVWF  x52
02DD8:  MOVLW  3A
02DDA:  MOVWF  x51
02DDC:  MOVLW  7B
02DDE:  MOVWF  x50
02DE0:  MOVFF  739,757
02DE4:  MOVFF  738,756
02DE8:  MOVFF  737,755
02DEC:  MOVFF  736,754
02DF0:  MOVLB  0
02DF2:  CALL   0D90
02DF6:  MOVFF  03,73E
02DFA:  MOVFF  02,73D
02DFE:  MOVFF  01,73C
02E02:  MOVFF  00,73B
02E06:  BCF    FD8.1
02E08:  MOVFF  03,74D
02E0C:  MOVFF  02,74C
02E10:  MOVFF  01,74B
02E14:  MOVFF  00,74A
02E18:  MOVLW  2B
02E1A:  MOVLB  7
02E1C:  MOVWF  x51
02E1E:  MOVLW  9D
02E20:  MOVWF  x50
02E22:  MOVLW  DF
02E24:  MOVWF  x4F
02E26:  MOVLW  7E
02E28:  MOVWF  x4E
02E2A:  MOVLB  0
02E2C:  CALL   0E86
02E30:  MOVFF  03,735
02E34:  MOVFF  02,734
02E38:  MOVFF  01,733
02E3C:  MOVFF  00,732
....................       r = r*y2 + 1.0;
02E40:  MOVFF  735,753
02E44:  MOVFF  734,752
02E48:  MOVFF  733,751
02E4C:  MOVFF  732,750
02E50:  MOVFF  739,757
02E54:  MOVFF  738,756
02E58:  MOVFF  737,755
02E5C:  MOVFF  736,754
02E60:  CALL   0D90
02E64:  MOVFF  03,73E
02E68:  MOVFF  02,73D
02E6C:  MOVFF  01,73C
02E70:  MOVFF  00,73B
02E74:  BCF    FD8.1
02E76:  MOVFF  03,74D
02E7A:  MOVFF  02,74C
02E7E:  MOVFF  01,74B
02E82:  MOVFF  00,74A
02E86:  MOVLB  7
02E88:  CLRF   x51
02E8A:  CLRF   x50
02E8C:  CLRF   x4F
02E8E:  MOVLW  7F
02E90:  MOVWF  x4E
02E92:  MOVLB  0
02E94:  CALL   0E86
02E98:  MOVFF  03,735
02E9C:  MOVFF  02,734
02EA0:  MOVFF  01,733
02EA4:  MOVFF  00,732
.................... 
....................       res = y*res/r;
02EA8:  MOVFF  72D,753
02EAC:  MOVFF  72C,752
02EB0:  MOVFF  72B,751
02EB4:  MOVFF  72A,750
02EB8:  MOVFF  731,757
02EBC:  MOVFF  730,756
02EC0:  MOVFF  72F,755
02EC4:  MOVFF  72E,754
02EC8:  CALL   0D90
02ECC:  MOVFF  03,73E
02ED0:  MOVFF  02,73D
02ED4:  MOVFF  01,73C
02ED8:  MOVFF  00,73B
02EDC:  MOVFF  03,742
02EE0:  MOVFF  02,741
02EE4:  MOVFF  01,740
02EE8:  MOVFF  00,73F
02EEC:  MOVFF  735,746
02EF0:  MOVFF  734,745
02EF4:  MOVFF  733,744
02EF8:  MOVFF  732,743
02EFC:  CALL   1D96
02F00:  MOVFF  03,731
02F04:  MOVFF  02,730
02F08:  MOVFF  01,72F
02F0C:  MOVFF  00,72E
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
02F10:  MOVLW  07
02F12:  MOVLB  7
02F14:  MOVWF  x3C
02F16:  MOVLW  26
02F18:  MOVFF  73C,FEA
02F1C:  MOVWF  FE9
02F1E:  MOVLW  7E
02F20:  SUBWF  FEF,W
02F22:  MOVWF  x3A
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
02F24:  BTFSS  x3A.7
02F26:  BRA    2F52
....................          r = -(float32)-n;
02F28:  MOVLW  00
02F2A:  BSF    FD8.0
02F2C:  SUBFWB x3A,W
02F2E:  CLRF   x3D
02F30:  MOVWF  x3C
02F32:  BTFSC  x3C.7
02F34:  DECF   x3D,F
02F36:  MOVLB  0
02F38:  CALL   26C0
02F3C:  MOVFF  00,732
02F40:  MOVF   01,W
02F42:  XORLW  80
02F44:  MOVLB  7
02F46:  MOVWF  x33
02F48:  MOVFF  02,734
02F4C:  MOVFF  03,735
02F50:  BRA    2F74
....................       else
....................          r = (float32)n;
02F52:  CLRF   x3D
02F54:  MOVFF  73A,73C
02F58:  BTFSC  x3C.7
02F5A:  DECF   x3D,F
02F5C:  MOVLB  0
02F5E:  CALL   26C0
02F62:  MOVFF  03,735
02F66:  MOVFF  02,734
02F6A:  MOVFF  01,733
02F6E:  MOVFF  00,732
02F72:  MOVLB  7
.................... 
....................       res += r*LN2;
02F74:  MOVFF  735,753
02F78:  MOVFF  734,752
02F7C:  MOVFF  733,751
02F80:  MOVFF  732,750
02F84:  MOVLW  18
02F86:  MOVWF  x57
02F88:  MOVLW  72
02F8A:  MOVWF  x56
02F8C:  MOVLW  31
02F8E:  MOVWF  x55
02F90:  MOVLW  7E
02F92:  MOVWF  x54
02F94:  MOVLB  0
02F96:  CALL   0D90
02F9A:  BCF    FD8.1
02F9C:  MOVFF  731,74D
02FA0:  MOVFF  730,74C
02FA4:  MOVFF  72F,74B
02FA8:  MOVFF  72E,74A
02FAC:  MOVFF  03,751
02FB0:  MOVFF  02,750
02FB4:  MOVFF  01,74F
02FB8:  MOVFF  00,74E
02FBC:  CALL   0E86
02FC0:  MOVFF  03,731
02FC4:  MOVFF  02,730
02FC8:  MOVFF  01,72F
02FCC:  MOVFF  00,72E
....................    }
02FD0:  BRA    2FDE
.................... 
....................    else
....................       res = 0.0;
02FD2:  MOVLB  7
02FD4:  CLRF   x31
02FD6:  CLRF   x30
02FD8:  CLRF   x2F
02FDA:  CLRF   x2E
02FDC:  MOVLB  0
.................... 
....................    return(res);
02FDE:  MOVFF  72E,00
02FE2:  MOVFF  72F,01
02FE6:  MOVFF  730,02
02FEA:  MOVFF  731,03
02FEE:  RETURN 0
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
*
033FE:  MOVFF  71D,749
03402:  MOVFF  71C,748
03406:  MOVFF  71B,747
0340A:  MOVFF  71A,746
0340E:  MOVLB  7
03410:  CLRF   x4D
03412:  CLRF   x4C
03414:  CLRF   x4B
03416:  CLRF   x4A
03418:  MOVLB  0
0341A:  CALL   1D1C
0341E:  BTFSS  FD8.0
03420:  BRA    35BC
03422:  MOVFF  721,725
03426:  MOVFF  720,724
0342A:  MOVFF  71F,723
0342E:  MOVFF  71E,722
03432:  MOVLB  7
03434:  CLRF   x29
03436:  CLRF   x28
03438:  CLRF   x27
0343A:  MOVLW  7F
0343C:  MOVWF  x26
0343E:  MOVLB  0
03440:  CALL   2AF6
03444:  MOVFF  03,725
03448:  MOVFF  02,724
0344C:  MOVFF  01,723
03450:  MOVFF  00,722
03454:  MOVFF  03,749
03458:  MOVFF  02,748
0345C:  MOVFF  01,747
03460:  MOVFF  00,746
03464:  MOVLB  7
03466:  CLRF   x4D
03468:  CLRF   x4C
0346A:  CLRF   x4B
0346C:  CLRF   x4A
0346E:  MOVLB  0
03470:  CALL   1D1C
03474:  BTFSS  FD8.2
03476:  BRA    35BC
....................       if(fmod(y, 2) == 0) {
03478:  MOVFF  721,725
0347C:  MOVFF  720,724
03480:  MOVFF  71F,723
03484:  MOVFF  71E,722
03488:  MOVLB  7
0348A:  CLRF   x29
0348C:  CLRF   x28
0348E:  CLRF   x27
03490:  MOVLW  80
03492:  MOVWF  x26
03494:  MOVLB  0
03496:  CALL   2AF6
0349A:  MOVFF  03,725
0349E:  MOVFF  02,724
034A2:  MOVFF  01,723
034A6:  MOVFF  00,722
034AA:  MOVFF  03,749
034AE:  MOVFF  02,748
034B2:  MOVFF  01,747
034B6:  MOVFF  00,746
034BA:  MOVLB  7
034BC:  CLRF   x4D
034BE:  CLRF   x4C
034C0:  CLRF   x4B
034C2:  CLRF   x4A
034C4:  MOVLB  0
034C6:  CALL   1D1C
034CA:  BNZ   3542
....................          return (exp(log(-x) * y));
034CC:  MOVLB  7
034CE:  MOVF   x1B,W
034D0:  XORLW  80
034D2:  MOVWF  x23
034D4:  MOVFF  71D,729
034D8:  MOVFF  71C,728
034DC:  MOVWF  x27
034DE:  MOVFF  71A,726
034E2:  MOVLB  0
034E4:  CALL   2C5C
034E8:  MOVFF  03,725
034EC:  MOVFF  02,724
034F0:  MOVFF  01,723
034F4:  MOVFF  00,722
034F8:  MOVFF  03,753
034FC:  MOVFF  02,752
03500:  MOVFF  01,751
03504:  MOVFF  00,750
03508:  MOVFF  721,757
0350C:  MOVFF  720,756
03510:  MOVFF  71F,755
03514:  MOVFF  71E,754
03518:  CALL   0D90
0351C:  MOVFF  03,725
03520:  MOVFF  02,724
03524:  MOVFF  01,723
03528:  MOVFF  00,722
0352C:  MOVFF  03,729
03530:  MOVFF  02,728
03534:  MOVFF  01,727
03538:  MOVFF  00,726
0353C:  RCALL  2FF0
0353E:  BRA    36FA
....................       } else {
03540:  BRA    35BA
....................          return (-exp(log(-x) * y));
03542:  MOVLB  7
03544:  MOVF   x1B,W
03546:  XORLW  80
03548:  MOVWF  x23
0354A:  MOVFF  71D,729
0354E:  MOVFF  71C,728
03552:  MOVWF  x27
03554:  MOVFF  71A,726
03558:  MOVLB  0
0355A:  CALL   2C5C
0355E:  MOVFF  03,725
03562:  MOVFF  02,724
03566:  MOVFF  01,723
0356A:  MOVFF  00,722
0356E:  MOVFF  03,753
03572:  MOVFF  02,752
03576:  MOVFF  01,751
0357A:  MOVFF  00,750
0357E:  MOVFF  721,757
03582:  MOVFF  720,756
03586:  MOVFF  71F,755
0358A:  MOVFF  71E,754
0358E:  CALL   0D90
03592:  MOVFF  03,725
03596:  MOVFF  02,724
0359A:  MOVFF  01,723
0359E:  MOVFF  00,722
035A2:  MOVFF  03,729
035A6:  MOVFF  02,728
035AA:  MOVFF  01,727
035AE:  MOVFF  00,726
035B2:  RCALL  2FF0
035B4:  MOVLW  80
035B6:  XORWF  01,F
035B8:  BRA    36FA
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
035BA:  BRA    36FA
035BC:  MOVFF  71D,749
035C0:  MOVFF  71C,748
035C4:  MOVFF  71B,747
035C8:  MOVFF  71A,746
035CC:  MOVLB  7
035CE:  CLRF   x4D
035D0:  CLRF   x4C
035D2:  CLRF   x4B
035D4:  CLRF   x4A
035D6:  MOVLB  0
035D8:  CALL   1D1C
035DC:  BNC   363E
035DE:  MOVFF  721,725
035E2:  MOVFF  720,724
035E6:  MOVFF  71F,723
035EA:  MOVFF  71E,722
035EE:  MOVLB  7
035F0:  CLRF   x29
035F2:  CLRF   x28
035F4:  CLRF   x27
035F6:  MOVLW  7F
035F8:  MOVWF  x26
035FA:  MOVLB  0
035FC:  CALL   2AF6
03600:  MOVFF  03,725
03604:  MOVFF  02,724
03608:  MOVFF  01,723
0360C:  MOVFF  00,722
03610:  MOVFF  03,749
03614:  MOVFF  02,748
03618:  MOVFF  01,747
0361C:  MOVFF  00,746
03620:  MOVLB  7
03622:  CLRF   x4D
03624:  CLRF   x4C
03626:  CLRF   x4B
03628:  CLRF   x4A
0362A:  MOVLB  0
0362C:  CALL   1D1C
03630:  BZ    363E
....................       return 0;
03632:  CLRF   00
03634:  CLRF   01
03636:  CLRF   02
03638:  CLRF   03
0363A:  BRA    36FA
....................    } else {
0363C:  BRA    36FA
....................       if(x != 0 || 0 >= y) {
0363E:  MOVFF  71D,749
03642:  MOVFF  71C,748
03646:  MOVFF  71B,747
0364A:  MOVFF  71A,746
0364E:  MOVLB  7
03650:  CLRF   x4D
03652:  CLRF   x4C
03654:  CLRF   x4B
03656:  CLRF   x4A
03658:  MOVLB  0
0365A:  CALL   1D1C
0365E:  BNZ   3684
03660:  MOVFF  721,749
03664:  MOVFF  720,748
03668:  MOVFF  71F,747
0366C:  MOVFF  71E,746
03670:  MOVLB  7
03672:  CLRF   x4D
03674:  CLRF   x4C
03676:  CLRF   x4B
03678:  CLRF   x4A
0367A:  MOVLB  0
0367C:  CALL   1D1C
03680:  BC    3684
03682:  BNZ   36F2
....................          return (exp(log(x) * y));
03684:  MOVFF  71D,729
03688:  MOVFF  71C,728
0368C:  MOVFF  71B,727
03690:  MOVFF  71A,726
03694:  CALL   2C5C
03698:  MOVFF  03,725
0369C:  MOVFF  02,724
036A0:  MOVFF  01,723
036A4:  MOVFF  00,722
036A8:  MOVFF  03,753
036AC:  MOVFF  02,752
036B0:  MOVFF  01,751
036B4:  MOVFF  00,750
036B8:  MOVFF  721,757
036BC:  MOVFF  720,756
036C0:  MOVFF  71F,755
036C4:  MOVFF  71E,754
036C8:  CALL   0D90
036CC:  MOVFF  03,725
036D0:  MOVFF  02,724
036D4:  MOVFF  01,723
036D8:  MOVFF  00,722
036DC:  MOVFF  03,729
036E0:  MOVFF  02,728
036E4:  MOVFF  01,727
036E8:  MOVFF  00,726
036EC:  RCALL  2FF0
036EE:  BRA    36FA
....................       } else return 0;
036F0:  BRA    36FA
036F2:  CLRF   00
036F4:  CLRF   01
036F6:  CLRF   02
036F8:  CLRF   03
....................    }
036FA:  RETURN 0
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
*
01EF4:  MOVLB  7
01EF6:  BCF    x38.0
....................    flag = 0;
01EF8:  BCF    x38.1
....................    y = x;
01EFA:  MOVFF  72B,72F
01EFE:  MOVFF  72A,72E
01F02:  MOVFF  729,72D
01F06:  MOVFF  728,72C
.................... 
....................    if (x < 0)
01F0A:  MOVFF  72B,749
01F0E:  MOVFF  72A,748
01F12:  MOVFF  729,747
01F16:  MOVFF  728,746
01F1A:  CLRF   x4D
01F1C:  CLRF   x4C
01F1E:  CLRF   x4B
01F20:  CLRF   x4A
01F22:  MOVLB  0
01F24:  RCALL  1D1C
01F26:  BNC   1F34
....................    {
....................       s = 1;
01F28:  MOVLB  7
01F2A:  BSF    x38.0
....................       y = -y;
01F2C:  MOVF   x2D,W
01F2E:  XORLW  80
01F30:  MOVWF  x2D
01F32:  MOVLB  0
....................    }
.................... 
....................    if (y > 1.0)
01F34:  MOVLB  7
01F36:  CLRF   x49
01F38:  CLRF   x48
01F3A:  CLRF   x47
01F3C:  MOVLW  7F
01F3E:  MOVWF  x46
01F40:  MOVFF  72F,74D
01F44:  MOVFF  72E,74C
01F48:  MOVFF  72D,74B
01F4C:  MOVFF  72C,74A
01F50:  MOVLB  0
01F52:  RCALL  1D1C
01F54:  BNC   1F8C
....................    {
....................       y = 1.0/y;
01F56:  MOVLB  7
01F58:  CLRF   x42
01F5A:  CLRF   x41
01F5C:  CLRF   x40
01F5E:  MOVLW  7F
01F60:  MOVWF  x3F
01F62:  MOVFF  72F,746
01F66:  MOVFF  72E,745
01F6A:  MOVFF  72D,744
01F6E:  MOVFF  72C,743
01F72:  MOVLB  0
01F74:  RCALL  1D96
01F76:  MOVFF  03,72F
01F7A:  MOVFF  02,72E
01F7E:  MOVFF  01,72D
01F82:  MOVFF  00,72C
....................       flag = 1;
01F86:  MOVLB  7
01F88:  BSF    x38.1
01F8A:  MOVLB  0
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
01F8C:  MOVLW  0A
01F8E:  MOVLB  7
01F90:  MOVWF  x53
01F92:  MOVLW  89
01F94:  MOVWF  x52
01F96:  MOVLW  34
01F98:  MOVWF  x51
01F9A:  MOVLW  7C
01F9C:  MOVWF  x50
01F9E:  MOVFF  72F,757
01FA2:  MOVFF  72E,756
01FA6:  MOVFF  72D,755
01FAA:  MOVFF  72C,754
01FAE:  MOVLB  0
01FB0:  CALL   0D90
01FB4:  MOVFF  03,73C
01FB8:  MOVFF  02,73B
01FBC:  MOVFF  01,73A
01FC0:  MOVFF  00,739
01FC4:  MOVFF  03,753
01FC8:  MOVFF  02,752
01FCC:  MOVFF  01,751
01FD0:  MOVFF  00,750
01FD4:  MOVFF  72F,757
01FD8:  MOVFF  72E,756
01FDC:  MOVFF  72D,755
01FE0:  MOVFF  72C,754
01FE4:  CALL   0D90
01FE8:  MOVFF  03,73C
01FEC:  MOVFF  02,73B
01FF0:  MOVFF  01,73A
01FF4:  MOVFF  00,739
01FF8:  BCF    FD8.1
01FFA:  MOVFF  03,74D
01FFE:  MOVFF  02,74C
02002:  MOVFF  01,74B
02006:  MOVFF  00,74A
0200A:  MOVLW  7C
0200C:  MOVLB  7
0200E:  MOVWF  x51
02010:  MOVLW  79
02012:  MOVWF  x50
02014:  MOVLW  35
02016:  MOVWF  x4F
02018:  MOVLW  81
0201A:  MOVWF  x4E
0201C:  MOVLB  0
0201E:  CALL   0E86
02022:  MOVFF  03,733
02026:  MOVFF  02,732
0202A:  MOVFF  01,731
0202E:  MOVFF  00,730
....................    res = res*y*y + pat[2];
02032:  MOVFF  733,753
02036:  MOVFF  732,752
0203A:  MOVFF  731,751
0203E:  MOVFF  730,750
02042:  MOVFF  72F,757
02046:  MOVFF  72E,756
0204A:  MOVFF  72D,755
0204E:  MOVFF  72C,754
02052:  CALL   0D90
02056:  MOVFF  03,73C
0205A:  MOVFF  02,73B
0205E:  MOVFF  01,73A
02062:  MOVFF  00,739
02066:  MOVFF  03,753
0206A:  MOVFF  02,752
0206E:  MOVFF  01,751
02072:  MOVFF  00,750
02076:  MOVFF  72F,757
0207A:  MOVFF  72E,756
0207E:  MOVFF  72D,755
02082:  MOVFF  72C,754
02086:  CALL   0D90
0208A:  MOVFF  03,73C
0208E:  MOVFF  02,73B
02092:  MOVFF  01,73A
02096:  MOVFF  00,739
0209A:  BCF    FD8.1
0209C:  MOVFF  03,74D
020A0:  MOVFF  02,74C
020A4:  MOVFF  01,74B
020A8:  MOVFF  00,74A
020AC:  MOVLW  3F
020AE:  MOVLB  7
020B0:  MOVWF  x51
020B2:  MOVLW  02
020B4:  MOVWF  x50
020B6:  MOVLW  33
020B8:  MOVWF  x4F
020BA:  MOVLW  83
020BC:  MOVWF  x4E
020BE:  MOVLB  0
020C0:  CALL   0E86
020C4:  MOVFF  03,733
020C8:  MOVFF  02,732
020CC:  MOVFF  01,731
020D0:  MOVFF  00,730
....................    res = res*y*y + pat[3];
020D4:  MOVFF  733,753
020D8:  MOVFF  732,752
020DC:  MOVFF  731,751
020E0:  MOVFF  730,750
020E4:  MOVFF  72F,757
020E8:  MOVFF  72E,756
020EC:  MOVFF  72D,755
020F0:  MOVFF  72C,754
020F4:  CALL   0D90
020F8:  MOVFF  03,73C
020FC:  MOVFF  02,73B
02100:  MOVFF  01,73A
02104:  MOVFF  00,739
02108:  MOVFF  03,753
0210C:  MOVFF  02,752
02110:  MOVFF  01,751
02114:  MOVFF  00,750
02118:  MOVFF  72F,757
0211C:  MOVFF  72E,756
02120:  MOVFF  72D,755
02124:  MOVFF  72C,754
02128:  CALL   0D90
0212C:  MOVFF  03,73C
02130:  MOVFF  02,73B
02134:  MOVFF  01,73A
02138:  MOVFF  00,739
0213C:  BCF    FD8.1
0213E:  MOVFF  03,74D
02142:  MOVFF  02,74C
02146:  MOVFF  01,74B
0214A:  MOVFF  00,74A
0214E:  MOVLW  33
02150:  MOVLB  7
02152:  MOVWF  x51
02154:  MOVLW  8C
02156:  MOVWF  x50
02158:  MOVLW  1E
0215A:  MOVWF  x4F
0215C:  MOVLW  83
0215E:  MOVWF  x4E
02160:  MOVLB  0
02162:  CALL   0E86
02166:  MOVFF  03,733
0216A:  MOVFF  02,732
0216E:  MOVFF  01,731
02172:  MOVFF  00,730
.................... 
....................    r = qat[0]*y*y + qat[1];
02176:  MOVLB  7
02178:  CLRF   x53
0217A:  CLRF   x52
0217C:  CLRF   x51
0217E:  MOVLW  7F
02180:  MOVWF  x50
02182:  MOVFF  72F,757
02186:  MOVFF  72E,756
0218A:  MOVFF  72D,755
0218E:  MOVFF  72C,754
02192:  MOVLB  0
02194:  CALL   0D90
02198:  MOVFF  03,73C
0219C:  MOVFF  02,73B
021A0:  MOVFF  01,73A
021A4:  MOVFF  00,739
021A8:  MOVFF  03,753
021AC:  MOVFF  02,752
021B0:  MOVFF  01,751
021B4:  MOVFF  00,750
021B8:  MOVFF  72F,757
021BC:  MOVFF  72E,756
021C0:  MOVFF  72D,755
021C4:  MOVFF  72C,754
021C8:  CALL   0D90
021CC:  MOVFF  03,73C
021D0:  MOVFF  02,73B
021D4:  MOVFF  01,73A
021D8:  MOVFF  00,739
021DC:  BCF    FD8.1
021DE:  MOVFF  03,74D
021E2:  MOVFF  02,74C
021E6:  MOVFF  01,74B
021EA:  MOVFF  00,74A
021EE:  MOVLW  1B
021F0:  MOVLB  7
021F2:  MOVWF  x51
021F4:  MOVLW  E4
021F6:  MOVWF  x50
021F8:  MOVLW  35
021FA:  MOVWF  x4F
021FC:  MOVLW  82
021FE:  MOVWF  x4E
02200:  MOVLB  0
02202:  CALL   0E86
02206:  MOVFF  03,737
0220A:  MOVFF  02,736
0220E:  MOVFF  01,735
02212:  MOVFF  00,734
....................    r = r*y*y + qat[2];
02216:  MOVFF  737,753
0221A:  MOVFF  736,752
0221E:  MOVFF  735,751
02222:  MOVFF  734,750
02226:  MOVFF  72F,757
0222A:  MOVFF  72E,756
0222E:  MOVFF  72D,755
02232:  MOVFF  72C,754
02236:  CALL   0D90
0223A:  MOVFF  03,73C
0223E:  MOVFF  02,73B
02242:  MOVFF  01,73A
02246:  MOVFF  00,739
0224A:  MOVFF  03,753
0224E:  MOVFF  02,752
02252:  MOVFF  01,751
02256:  MOVFF  00,750
0225A:  MOVFF  72F,757
0225E:  MOVFF  72E,756
02262:  MOVFF  72D,755
02266:  MOVFF  72C,754
0226A:  CALL   0D90
0226E:  MOVFF  03,73C
02272:  MOVFF  02,73B
02276:  MOVFF  01,73A
0227A:  MOVFF  00,739
0227E:  BCF    FD8.1
02280:  MOVFF  03,74D
02284:  MOVFF  02,74C
02288:  MOVFF  01,74B
0228C:  MOVFF  00,74A
02290:  MOVLW  A4
02292:  MOVLB  7
02294:  MOVWF  x51
02296:  MOVLW  DB
02298:  MOVWF  x50
0229A:  MOVLW  67
0229C:  MOVWF  x4F
0229E:  MOVLW  83
022A0:  MOVWF  x4E
022A2:  MOVLB  0
022A4:  CALL   0E86
022A8:  MOVFF  03,737
022AC:  MOVFF  02,736
022B0:  MOVFF  01,735
022B4:  MOVFF  00,734
....................    r = r*y*y + qat[3];
022B8:  MOVFF  737,753
022BC:  MOVFF  736,752
022C0:  MOVFF  735,751
022C4:  MOVFF  734,750
022C8:  MOVFF  72F,757
022CC:  MOVFF  72E,756
022D0:  MOVFF  72D,755
022D4:  MOVFF  72C,754
022D8:  CALL   0D90
022DC:  MOVFF  03,73C
022E0:  MOVFF  02,73B
022E4:  MOVFF  01,73A
022E8:  MOVFF  00,739
022EC:  MOVFF  03,753
022F0:  MOVFF  02,752
022F4:  MOVFF  01,751
022F8:  MOVFF  00,750
022FC:  MOVFF  72F,757
02300:  MOVFF  72E,756
02304:  MOVFF  72D,755
02308:  MOVFF  72C,754
0230C:  CALL   0D90
02310:  MOVFF  03,73C
02314:  MOVFF  02,73B
02318:  MOVFF  01,73A
0231C:  MOVFF  00,739
02320:  BCF    FD8.1
02322:  MOVFF  03,74D
02326:  MOVFF  02,74C
0232A:  MOVFF  01,74B
0232E:  MOVFF  00,74A
02332:  MOVLW  33
02334:  MOVLB  7
02336:  MOVWF  x51
02338:  MOVLW  8C
0233A:  MOVWF  x50
0233C:  MOVLW  1E
0233E:  MOVWF  x4F
02340:  MOVLW  83
02342:  MOVWF  x4E
02344:  MOVLB  0
02346:  CALL   0E86
0234A:  MOVFF  03,737
0234E:  MOVFF  02,736
02352:  MOVFF  01,735
02356:  MOVFF  00,734
.................... 
....................    res = y*res/r;
0235A:  MOVFF  72F,753
0235E:  MOVFF  72E,752
02362:  MOVFF  72D,751
02366:  MOVFF  72C,750
0236A:  MOVFF  733,757
0236E:  MOVFF  732,756
02372:  MOVFF  731,755
02376:  MOVFF  730,754
0237A:  CALL   0D90
0237E:  MOVFF  03,73C
02382:  MOVFF  02,73B
02386:  MOVFF  01,73A
0238A:  MOVFF  00,739
0238E:  MOVFF  03,742
02392:  MOVFF  02,741
02396:  MOVFF  01,740
0239A:  MOVFF  00,73F
0239E:  MOVFF  737,746
023A2:  MOVFF  736,745
023A6:  MOVFF  735,744
023AA:  MOVFF  734,743
023AE:  RCALL  1D96
023B0:  MOVFF  03,733
023B4:  MOVFF  02,732
023B8:  MOVFF  01,731
023BC:  MOVFF  00,730
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
023C0:  MOVLB  7
023C2:  BTFSS  x38.1
023C4:  BRA    2400
....................       res = PI_DIV_BY_TWO - res;
023C6:  BSF    FD8.1
023C8:  MOVLW  DB
023CA:  MOVWF  x4D
023CC:  MOVLW  0F
023CE:  MOVWF  x4C
023D0:  MOVLW  49
023D2:  MOVWF  x4B
023D4:  MOVLW  7F
023D6:  MOVWF  x4A
023D8:  MOVFF  733,751
023DC:  MOVFF  732,750
023E0:  MOVFF  731,74F
023E4:  MOVFF  730,74E
023E8:  MOVLB  0
023EA:  CALL   0E86
023EE:  MOVFF  03,733
023F2:  MOVFF  02,732
023F6:  MOVFF  01,731
023FA:  MOVFF  00,730
023FE:  MOVLB  7
....................    if (s)
02400:  BTFSS  x38.0
02402:  BRA    240A
....................       res = -res;
02404:  MOVF   x31,W
02406:  XORLW  80
02408:  MOVWF  x31
.................... 
....................    return(res);
0240A:  MOVFF  730,00
0240E:  MOVFF  731,01
02412:  MOVFF  732,02
02416:  MOVFF  733,03
0241A:  MOVLB  0
0241C:  RETURN 0
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
0241E:  MOVLB  7
02420:  BCF    x26.0
....................    quad=0; //quadrant
02422:  CLRF   x27
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
02424:  MOVFF  71D,749
02428:  MOVFF  71C,748
0242C:  MOVFF  71B,747
02430:  MOVFF  71A,746
02434:  CLRF   x4D
02436:  CLRF   x4C
02438:  CLRF   x4B
0243A:  CLRF   x4A
0243C:  MOVLB  0
0243E:  RCALL  1D1C
02440:  BC    2444
02442:  BNZ   246E
02444:  MOVFF  721,749
02448:  MOVFF  720,748
0244C:  MOVFF  71F,747
02450:  MOVFF  71E,746
02454:  MOVLB  7
02456:  CLRF   x4D
02458:  CLRF   x4C
0245A:  CLRF   x4B
0245C:  CLRF   x4A
0245E:  MOVLB  0
02460:  RCALL  1D1C
02462:  BC    2466
02464:  BNZ   246A
02466:  MOVLW  03
02468:  BRA    246C
0246A:  MOVLW  04
0246C:  BRA    2494
0246E:  MOVFF  721,749
02472:  MOVFF  720,748
02476:  MOVFF  71F,747
0247A:  MOVFF  71E,746
0247E:  MOVLB  7
02480:  CLRF   x4D
02482:  CLRF   x4C
02484:  CLRF   x4B
02486:  CLRF   x4A
02488:  MOVLB  0
0248A:  RCALL  1D1C
0248C:  BNC   2492
0248E:  MOVLW  02
02490:  BRA    2494
02492:  MOVLW  01
02494:  MOVLB  7
02496:  MOVWF  x27
....................    if(y<0.0)
02498:  MOVFF  71D,749
0249C:  MOVFF  71C,748
024A0:  MOVFF  71B,747
024A4:  MOVFF  71A,746
024A8:  CLRF   x4D
024AA:  CLRF   x4C
024AC:  CLRF   x4B
024AE:  CLRF   x4A
024B0:  MOVLB  0
024B2:  RCALL  1D1C
024B4:  BNC   24C2
....................    {
....................       sign=1;
024B6:  MOVLB  7
024B8:  BSF    x26.0
....................       y=-y;
024BA:  MOVF   x1B,W
024BC:  XORLW  80
024BE:  MOVWF  x1B
024C0:  MOVLB  0
....................    }
....................    if(x<0.0)
024C2:  MOVFF  721,749
024C6:  MOVFF  720,748
024CA:  MOVFF  71F,747
024CE:  MOVFF  71E,746
024D2:  MOVLB  7
024D4:  CLRF   x4D
024D6:  CLRF   x4C
024D8:  CLRF   x4B
024DA:  CLRF   x4A
024DC:  MOVLB  0
024DE:  RCALL  1D1C
024E0:  BNC   24EC
....................    {
....................       x=-x;
024E2:  MOVLB  7
024E4:  MOVF   x1F,W
024E6:  XORLW  80
024E8:  MOVWF  x1F
024EA:  MOVLB  0
....................    }
....................    if (x==0.0)
024EC:  MOVFF  721,749
024F0:  MOVFF  720,748
024F4:  MOVFF  71F,747
024F8:  MOVFF  71E,746
024FC:  MOVLB  7
024FE:  CLRF   x4D
02500:  CLRF   x4C
02502:  CLRF   x4B
02504:  CLRF   x4A
02506:  MOVLB  0
02508:  RCALL  1D1C
0250A:  BNZ   2560
....................    {
....................       if(y==0.0)
0250C:  MOVFF  71D,749
02510:  MOVFF  71C,748
02514:  MOVFF  71B,747
02518:  MOVFF  71A,746
0251C:  MOVLB  7
0251E:  CLRF   x4D
02520:  CLRF   x4C
02522:  CLRF   x4B
02524:  CLRF   x4A
02526:  MOVLB  0
02528:  CALL   1D1C
0252C:  BNZ   2530
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
0252E:  BRA    255E
....................       else
....................       {
....................          if(sign)
02530:  MOVLB  7
02532:  BTFSS  x26.0
02534:  BRA    254A
....................          {
....................          return (-(PI_DIV_BY_TWO));
02536:  MOVLW  7F
02538:  MOVWF  00
0253A:  MOVLW  C9
0253C:  MOVWF  01
0253E:  MOVLW  0F
02540:  MOVWF  02
02542:  MOVLW  DB
02544:  MOVWF  03
02546:  BRA    2698
....................          }
02548:  BRA    255C
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
0254A:  MOVLW  7F
0254C:  MOVWF  00
0254E:  MOVLW  49
02550:  MOVWF  01
02552:  MOVLW  0F
02554:  MOVWF  02
02556:  MOVLW  DB
02558:  MOVWF  03
0255A:  BRA    2698
0255C:  MOVLB  0
....................          }
....................       }
....................    }
0255E:  BRA    2696
....................    else
....................    {
....................       z=y/x;
02560:  MOVFF  71D,742
02564:  MOVFF  71C,741
02568:  MOVFF  71B,740
0256C:  MOVFF  71A,73F
02570:  MOVFF  721,746
02574:  MOVFF  720,745
02578:  MOVFF  71F,744
0257C:  MOVFF  71E,743
02580:  RCALL  1D96
02582:  MOVFF  03,725
02586:  MOVFF  02,724
0258A:  MOVFF  01,723
0258E:  MOVFF  00,722
....................       switch(quad)
02592:  MOVLW  01
02594:  MOVLB  7
02596:  SUBWF  x27,W
02598:  ADDLW  FC
0259A:  BTFSC  FD8.0
0259C:  BRA    2698
0259E:  ADDLW  04
025A0:  MOVLB  0
025A2:  GOTO   269E
....................       {
....................          case 1:
....................          {
....................             return atan(z);
025A6:  MOVFF  725,72B
025AA:  MOVFF  724,72A
025AE:  MOVFF  723,729
025B2:  MOVFF  722,728
025B6:  RCALL  1EF4
025B8:  MOVLB  7
025BA:  BRA    2698
....................             break;
025BC:  BRA    2698
025BE:  MOVLB  0
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
025C0:  MOVFF  725,72B
025C4:  MOVFF  724,72A
025C8:  MOVFF  723,729
025CC:  MOVFF  722,728
025D0:  RCALL  1EF4
025D2:  MOVFF  FEA,729
025D6:  MOVFF  FE9,728
025DA:  BSF    FD8.1
025DC:  MOVLW  DB
025DE:  MOVLB  7
025E0:  MOVWF  x4D
025E2:  MOVLW  0F
025E4:  MOVWF  x4C
025E6:  MOVLW  49
025E8:  MOVWF  x4B
025EA:  MOVLW  80
025EC:  MOVWF  x4A
025EE:  MOVFF  03,751
025F2:  MOVFF  02,750
025F6:  MOVFF  01,74F
025FA:  MOVFF  00,74E
025FE:  MOVLB  0
02600:  CALL   0E86
02604:  MOVFF  729,FEA
02608:  MOVFF  728,FE9
0260C:  MOVLB  7
0260E:  BRA    2698
....................             break;
02610:  BRA    2698
02612:  MOVLB  0
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
02614:  MOVFF  725,72B
02618:  MOVFF  724,72A
0261C:  MOVFF  723,729
02620:  MOVFF  722,728
02624:  RCALL  1EF4
02626:  MOVFF  03,72B
0262A:  MOVFF  02,72A
0262E:  MOVFF  01,729
02632:  MOVFF  00,728
02636:  MOVFF  FEA,72D
0263A:  MOVFF  FE9,72C
0263E:  BSF    FD8.1
02640:  MOVFF  03,74D
02644:  MOVFF  02,74C
02648:  MOVFF  01,74B
0264C:  MOVFF  00,74A
02650:  MOVLW  DB
02652:  MOVLB  7
02654:  MOVWF  x51
02656:  MOVLW  0F
02658:  MOVWF  x50
0265A:  MOVLW  49
0265C:  MOVWF  x4F
0265E:  MOVLW  80
02660:  MOVWF  x4E
02662:  MOVLB  0
02664:  CALL   0E86
02668:  MOVFF  72D,FEA
0266C:  MOVFF  72C,FE9
02670:  MOVLB  7
02672:  BRA    2698
....................             break;
02674:  BRA    2698
02676:  MOVLB  0
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
02678:  MOVFF  725,72B
0267C:  MOVFF  724,72A
02680:  MOVFF  723,729
02684:  MOVFF  722,728
02688:  RCALL  1EF4
0268A:  MOVLW  80
0268C:  XORWF  01,F
0268E:  MOVLB  7
02690:  BRA    2698
....................             break;
02692:  BRA    2698
02694:  MOVLB  0
02696:  MOVLB  7
....................          }
....................       }
....................    }
02698:  MOVLB  0
0269A:  GOTO   3DA4 (RETURN)
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... #define sensorSampleRate 50 // 50mS delay between each sensor sample = 100ms cadence 
.................... 
.................... #define maxCount 16777216.0   // ADC max count
.................... #define vRef 2.048            // ADC vRef
.................... 
.................... #define sc sensorCal
.................... 
.................... #define vMonN15   6
.................... #define vMon200   16
.................... #define vMon5V6   24
.................... #define vMon5VA   25
.................... #define vMon3V6X  17
.................... #define vMon3V3A  27
.................... #define vMon3V3D  26
.................... 
.................... #define BUFFER_SIZE 5
.................... 
.................... signed int32 sQ_x[BUFFER_SIZE];
.................... signed int32 cQ_x[BUFFER_SIZE];
.................... signed int32 sQ_y[BUFFER_SIZE];
.................... signed int32 cQ_y[BUFFER_SIZE];
.................... int sIn_x=0;
.................... int cIn_x=0;
.................... int sIn_y=0;
.................... int cIn_y=0;
.................... 
.................... struct sensorMonitorData
.................... {
....................    boolean dataReady;
....................    boolean adcBusy;
....................    signed int32 avgSin;
....................    signed int32 avgCos;
.................... } smData[2] = 
.................... {
....................    {false, false, 0, 0},
....................    {false, false, 0, 0}
.................... };
.................... 
.................... void push(signed int32* buff, int* idx, signed int32 newData) {
....................    buff[*idx]=newData;
*
008F4:  MOVFF  730,FEA
008F8:  MOVLB  7
008FA:  MOVFF  72F,FE9
008FE:  CLRF   x42
00900:  MOVFF  FEF,741
00904:  CLRF   x44
00906:  MOVLW  04
00908:  MOVWF  x43
0090A:  MOVLB  0
0090C:  RCALL  08A6
0090E:  MOVF   01,W
00910:  MOVLB  7
00912:  ADDWF  x2D,W
00914:  MOVWF  FE9
00916:  MOVF   x2E,W
00918:  ADDWFC 02,W
0091A:  MOVWF  FEA
0091C:  MOVFF  731,FEF
00920:  MOVFF  732,FEC
00924:  MOVFF  733,FEC
00928:  MOVFF  734,FEC
....................    *idx=(*idx+1) % BUFFER_SIZE;
0092C:  MOVFF  730,736
00930:  MOVFF  730,FEA
00934:  MOVFF  72F,FE9
00938:  MOVLW  01
0093A:  ADDWF  FEF,W
0093C:  MOVWF  x38
0093E:  MOVWF  x3A
00940:  MOVLW  05
00942:  MOVWF  x3B
00944:  MOVLB  0
00946:  RCALL  08C8
00948:  MOVLB  7
0094A:  MOVFF  736,FEA
0094E:  MOVFF  72F,FE9
00952:  MOVFF  00,FEF
00956:  MOVLB  0
00958:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INTERNAL MONITOR task - gets voltages                                     */
.................... /* gets one value each time the task is run                                  */
.................... /*****************************************************************************/
.................... void internal_monitor_task(){
....................    static int8 state = 0;
....................    if (adc_done()){
*
010FE:  MOVLB  F
01100:  BTFSC  x5B.0
01102:  BRA    164E
....................       switch (state)
01104:  MOVLB  1
01106:  MOVF   xE6,W
01108:  ADDLW  F9
0110A:  BTFSC  FD8.0
0110C:  BRA    164C
0110E:  ADDLW  07
01110:  MOVLB  0
01112:  GOTO   1654
....................       {
....................          case 0:     // vMonN15
....................             monitorVals.vN15 = read_adc(ADC_READ_ONLY) * monCal.vN15[1] + monCal.vN15[0];
01116:  MOVLB  F
01118:  BTFSC  x5B.0
0111A:  BRA    1118
0111C:  MOVFF  F5F,02
01120:  MOVFF  F5E,01
01124:  MOVFF  02,6FC
01128:  MOVFF  01,6FB
0112C:  MOVFF  02,74B
01130:  MOVFF  01,74A
01134:  MOVLB  0
01136:  RCALL  0D5A
01138:  MOVFF  03,753
0113C:  MOVFF  02,752
01140:  MOVFF  01,751
01144:  MOVFF  00,750
01148:  MOVFF  C9,757
0114C:  MOVFF  C8,756
01150:  MOVFF  C7,755
01154:  MOVFF  C6,754
01158:  RCALL  0D90
0115A:  MOVFF  03,6FE
0115E:  MOVFF  02,6FD
01162:  MOVFF  01,6FC
01166:  MOVFF  00,6FB
0116A:  BCF    FD8.1
0116C:  MOVFF  03,74D
01170:  MOVFF  02,74C
01174:  MOVFF  01,74B
01178:  MOVFF  00,74A
0117C:  MOVFF  C5,751
01180:  MOVFF  C4,750
01184:  MOVFF  C3,74F
01188:  MOVFF  C2,74E
0118C:  RCALL  0E86
0118E:  MOVFF  03,FE
01192:  MOVFF  02,FD
01196:  MOVFF  01,FC
0119A:  MOVFF  00,FB
....................             set_adc_channel(vMon200);
0119E:  MOVLB  F
011A0:  MOVF   x5A,W
011A2:  ANDLW  3F
011A4:  MOVWF  01
011A6:  MOVLW  10
011A8:  MOVWF  x5A
011AA:  BTFSS  x5B.7
011AC:  BRA    11BC
011AE:  MOVF   01,W
011B0:  SUBLW  10
011B2:  BZ    11BC
011B4:  BSF    x5B.0
011B6:  NOP   
011B8:  BTFSC  x5B.0
011BA:  BRA    11B8
....................             delay_ms(10);
011BC:  MOVLW  0A
011BE:  MOVLB  7
011C0:  MOVWF  x01
011C2:  MOVLB  0
011C4:  CALL   03D0
....................             read_adc(ADC_START_ONLY);
011C8:  MOVLB  F
011CA:  BSF    x5B.0
011CC:  NOP   
....................             state = 1;
011CE:  MOVLW  01
011D0:  MOVLB  1
011D2:  MOVWF  xE6
....................          break;
011D4:  BRA    164C
....................          
....................          case 1:     // vMon200
....................             monitorVals.v200 = read_adc(ADC_READ_ONLY) * monCal.v200[1] + monCal.v200[0];
011D6:  MOVLB  F
011D8:  BTFSC  x5B.0
011DA:  BRA    11D8
011DC:  MOVFF  F5F,02
011E0:  MOVFF  F5E,01
011E4:  MOVFF  02,6FC
011E8:  MOVFF  01,6FB
011EC:  MOVFF  02,74B
011F0:  MOVFF  01,74A
011F4:  MOVLB  0
011F6:  RCALL  0D5A
011F8:  MOVFF  03,753
011FC:  MOVFF  02,752
01200:  MOVFF  01,751
01204:  MOVFF  00,750
01208:  MOVFF  D1,757
0120C:  MOVFF  D0,756
01210:  MOVFF  CF,755
01214:  MOVFF  CE,754
01218:  RCALL  0D90
0121A:  MOVFF  03,6FE
0121E:  MOVFF  02,6FD
01222:  MOVFF  01,6FC
01226:  MOVFF  00,6FB
0122A:  BCF    FD8.1
0122C:  MOVFF  03,74D
01230:  MOVFF  02,74C
01234:  MOVFF  01,74B
01238:  MOVFF  00,74A
0123C:  MOVFF  CD,751
01240:  MOVFF  CC,750
01244:  MOVFF  CB,74F
01248:  MOVFF  CA,74E
0124C:  RCALL  0E86
0124E:  MOVFF  03,102
01252:  MOVFF  02,101
01256:  MOVFF  01,100
0125A:  MOVFF  00,FF
....................             set_adc_channel(vMon5V6);
0125E:  MOVLB  F
01260:  MOVF   x5A,W
01262:  ANDLW  3F
01264:  MOVWF  01
01266:  MOVLW  18
01268:  MOVWF  x5A
0126A:  BTFSS  x5B.7
0126C:  BRA    127C
0126E:  MOVF   01,W
01270:  SUBLW  18
01272:  BZ    127C
01274:  BSF    x5B.0
01276:  NOP   
01278:  BTFSC  x5B.0
0127A:  BRA    1278
....................             delay_ms(10);
0127C:  MOVLW  0A
0127E:  MOVLB  7
01280:  MOVWF  x01
01282:  MOVLB  0
01284:  CALL   03D0
....................             read_adc(ADC_START_ONLY);
01288:  MOVLB  F
0128A:  BSF    x5B.0
0128C:  NOP   
....................             state = 2;
0128E:  MOVLW  02
01290:  MOVLB  1
01292:  MOVWF  xE6
....................          break;
01294:  BRA    164C
....................          
....................          case 2:     // vMon5V6
....................             monitorVals.v5V6 = read_adc(ADC_READ_ONLY) * monCal.v5V6[1] + monCal.v5V6[0];
01296:  MOVLB  F
01298:  BTFSC  x5B.0
0129A:  BRA    1298
0129C:  MOVFF  F5F,02
012A0:  MOVFF  F5E,01
012A4:  MOVFF  02,6FC
012A8:  MOVFF  01,6FB
012AC:  MOVFF  02,74B
012B0:  MOVFF  01,74A
012B4:  MOVLB  0
012B6:  RCALL  0D5A
012B8:  MOVFF  03,753
012BC:  MOVFF  02,752
012C0:  MOVFF  01,751
012C4:  MOVFF  00,750
012C8:  MOVFF  D9,757
012CC:  MOVFF  D8,756
012D0:  MOVFF  D7,755
012D4:  MOVFF  D6,754
012D8:  RCALL  0D90
012DA:  MOVFF  03,6FE
012DE:  MOVFF  02,6FD
012E2:  MOVFF  01,6FC
012E6:  MOVFF  00,6FB
012EA:  BCF    FD8.1
012EC:  MOVFF  03,74D
012F0:  MOVFF  02,74C
012F4:  MOVFF  01,74B
012F8:  MOVFF  00,74A
012FC:  MOVFF  D5,751
01300:  MOVFF  D4,750
01304:  MOVFF  D3,74F
01308:  MOVFF  D2,74E
0130C:  RCALL  0E86
0130E:  MOVFF  03,106
01312:  MOVFF  02,105
01316:  MOVFF  01,104
0131A:  MOVFF  00,103
....................             set_adc_channel(vMon5VA);
0131E:  MOVLB  F
01320:  MOVF   x5A,W
01322:  ANDLW  3F
01324:  MOVWF  01
01326:  MOVLW  19
01328:  MOVWF  x5A
0132A:  BTFSS  x5B.7
0132C:  BRA    133C
0132E:  MOVF   01,W
01330:  SUBLW  19
01332:  BZ    133C
01334:  BSF    x5B.0
01336:  NOP   
01338:  BTFSC  x5B.0
0133A:  BRA    1338
....................             delay_ms(10);
0133C:  MOVLW  0A
0133E:  MOVLB  7
01340:  MOVWF  x01
01342:  MOVLB  0
01344:  CALL   03D0
....................             read_adc(ADC_START_ONLY);
01348:  MOVLB  F
0134A:  BSF    x5B.0
0134C:  NOP   
....................             state = 3;
0134E:  MOVLW  03
01350:  MOVLB  1
01352:  MOVWF  xE6
....................          break;
01354:  BRA    164C
....................          
....................          case 3:     // vMon5VA
....................             monitorVals.v5VA = read_adc(ADC_READ_ONLY) * monCal.v5VA[1] + monCal.v5VA[0];
01356:  MOVLB  F
01358:  BTFSC  x5B.0
0135A:  BRA    1358
0135C:  MOVFF  F5F,02
01360:  MOVFF  F5E,01
01364:  MOVFF  02,6FC
01368:  MOVFF  01,6FB
0136C:  MOVFF  02,74B
01370:  MOVFF  01,74A
01374:  MOVLB  0
01376:  RCALL  0D5A
01378:  MOVFF  03,753
0137C:  MOVFF  02,752
01380:  MOVFF  01,751
01384:  MOVFF  00,750
01388:  MOVFF  E1,757
0138C:  MOVFF  E0,756
01390:  MOVFF  DF,755
01394:  MOVFF  DE,754
01398:  RCALL  0D90
0139A:  MOVFF  03,6FE
0139E:  MOVFF  02,6FD
013A2:  MOVFF  01,6FC
013A6:  MOVFF  00,6FB
013AA:  BCF    FD8.1
013AC:  MOVFF  03,74D
013B0:  MOVFF  02,74C
013B4:  MOVFF  01,74B
013B8:  MOVFF  00,74A
013BC:  MOVFF  DD,751
013C0:  MOVFF  DC,750
013C4:  MOVFF  DB,74F
013C8:  MOVFF  DA,74E
013CC:  RCALL  0E86
013CE:  MOVFF  03,10A
013D2:  MOVFF  02,109
013D6:  MOVFF  01,108
013DA:  MOVFF  00,107
....................             set_adc_channel(vMon3V6X);
013DE:  MOVLB  F
013E0:  MOVF   x5A,W
013E2:  ANDLW  3F
013E4:  MOVWF  01
013E6:  MOVLW  11
013E8:  MOVWF  x5A
013EA:  BTFSS  x5B.7
013EC:  BRA    13FC
013EE:  MOVF   01,W
013F0:  SUBLW  11
013F2:  BZ    13FC
013F4:  BSF    x5B.0
013F6:  NOP   
013F8:  BTFSC  x5B.0
013FA:  BRA    13F8
....................             delay_ms(10);
013FC:  MOVLW  0A
013FE:  MOVLB  7
01400:  MOVWF  x01
01402:  MOVLB  0
01404:  CALL   03D0
....................             read_adc(ADC_START_ONLY);
01408:  MOVLB  F
0140A:  BSF    x5B.0
0140C:  NOP   
....................             state = 4;
0140E:  MOVLW  04
01410:  MOVLB  1
01412:  MOVWF  xE6
....................          break;
01414:  BRA    164C
....................          
....................          case 4:     // vMon3V6X
....................             monitorVals.v3V6X = read_adc(ADC_READ_ONLY) * monCal.v3V6X[1] + monCal.v3V6X[0];
01416:  MOVLB  F
01418:  BTFSC  x5B.0
0141A:  BRA    1418
0141C:  MOVFF  F5F,02
01420:  MOVFF  F5E,01
01424:  MOVFF  02,6FC
01428:  MOVFF  01,6FB
0142C:  MOVFF  02,74B
01430:  MOVFF  01,74A
01434:  MOVLB  0
01436:  RCALL  0D5A
01438:  MOVFF  03,753
0143C:  MOVFF  02,752
01440:  MOVFF  01,751
01444:  MOVFF  00,750
01448:  MOVFF  E9,757
0144C:  MOVFF  E8,756
01450:  MOVFF  E7,755
01454:  MOVFF  E6,754
01458:  RCALL  0D90
0145A:  MOVFF  03,6FE
0145E:  MOVFF  02,6FD
01462:  MOVFF  01,6FC
01466:  MOVFF  00,6FB
0146A:  BCF    FD8.1
0146C:  MOVFF  03,74D
01470:  MOVFF  02,74C
01474:  MOVFF  01,74B
01478:  MOVFF  00,74A
0147C:  MOVFF  E5,751
01480:  MOVFF  E4,750
01484:  MOVFF  E3,74F
01488:  MOVFF  E2,74E
0148C:  RCALL  0E86
0148E:  MOVFF  03,10E
01492:  MOVFF  02,10D
01496:  MOVFF  01,10C
0149A:  MOVFF  00,10B
....................             set_adc_channel(vMon3V3A);
0149E:  MOVLB  F
014A0:  MOVF   x5A,W
014A2:  ANDLW  3F
014A4:  MOVWF  01
014A6:  MOVLW  1B
014A8:  MOVWF  x5A
014AA:  BTFSS  x5B.7
014AC:  BRA    14BC
014AE:  MOVF   01,W
014B0:  SUBLW  1B
014B2:  BZ    14BC
014B4:  BSF    x5B.0
014B6:  NOP   
014B8:  BTFSC  x5B.0
014BA:  BRA    14B8
....................             delay_ms(10);
014BC:  MOVLW  0A
014BE:  MOVLB  7
014C0:  MOVWF  x01
014C2:  MOVLB  0
014C4:  CALL   03D0
....................             read_adc(ADC_START_ONLY);
014C8:  MOVLB  F
014CA:  BSF    x5B.0
014CC:  NOP   
....................             state = 5;
014CE:  MOVLW  05
014D0:  MOVLB  1
014D2:  MOVWF  xE6
....................          break;
014D4:  BRA    164C
....................          
....................          case 5:     // vMon3V3A
....................             monitorVals.v3V3A = read_adc(ADC_READ_ONLY) * monCal.v3V3A[1] + monCal.v3V3A[0];
014D6:  MOVLB  F
014D8:  BTFSC  x5B.0
014DA:  BRA    14D8
014DC:  MOVFF  F5F,02
014E0:  MOVFF  F5E,01
014E4:  MOVFF  02,6FC
014E8:  MOVFF  01,6FB
014EC:  MOVFF  02,74B
014F0:  MOVFF  01,74A
014F4:  MOVLB  0
014F6:  RCALL  0D5A
014F8:  MOVFF  03,753
014FC:  MOVFF  02,752
01500:  MOVFF  01,751
01504:  MOVFF  00,750
01508:  MOVFF  F1,757
0150C:  MOVFF  F0,756
01510:  MOVFF  EF,755
01514:  MOVFF  EE,754
01518:  RCALL  0D90
0151A:  MOVFF  03,6FE
0151E:  MOVFF  02,6FD
01522:  MOVFF  01,6FC
01526:  MOVFF  00,6FB
0152A:  BCF    FD8.1
0152C:  MOVFF  03,74D
01530:  MOVFF  02,74C
01534:  MOVFF  01,74B
01538:  MOVFF  00,74A
0153C:  MOVFF  ED,751
01540:  MOVFF  EC,750
01544:  MOVFF  EB,74F
01548:  MOVFF  EA,74E
0154C:  RCALL  0E86
0154E:  MOVFF  03,112
01552:  MOVFF  02,111
01556:  MOVFF  01,110
0155A:  MOVFF  00,10F
....................             set_adc_channel(vMon3V3D);
0155E:  MOVLB  F
01560:  MOVF   x5A,W
01562:  ANDLW  3F
01564:  MOVWF  01
01566:  MOVLW  1A
01568:  MOVWF  x5A
0156A:  BTFSS  x5B.7
0156C:  BRA    157C
0156E:  MOVF   01,W
01570:  SUBLW  1A
01572:  BZ    157C
01574:  BSF    x5B.0
01576:  NOP   
01578:  BTFSC  x5B.0
0157A:  BRA    1578
....................             delay_ms(10);
0157C:  MOVLW  0A
0157E:  MOVLB  7
01580:  MOVWF  x01
01582:  MOVLB  0
01584:  CALL   03D0
....................             read_adc(ADC_START_ONLY);
01588:  MOVLB  F
0158A:  BSF    x5B.0
0158C:  NOP   
....................             state = 6;
0158E:  MOVLW  06
01590:  MOVLB  1
01592:  MOVWF  xE6
....................          break;
01594:  BRA    164C
....................          
....................          case 6:    // vMon3V3D
....................             monitorVals.v3V3D = read_adc(ADC_READ_ONLY) * monCal.v3V3D[1] + monCal.v3V3D[0];
01596:  MOVLB  F
01598:  BTFSC  x5B.0
0159A:  BRA    1598
0159C:  MOVFF  F5F,02
015A0:  MOVFF  F5E,01
015A4:  MOVFF  02,6FC
015A8:  MOVFF  01,6FB
015AC:  MOVFF  02,74B
015B0:  MOVFF  01,74A
015B4:  MOVLB  0
015B6:  CALL   0D5A
015BA:  MOVFF  03,753
015BE:  MOVFF  02,752
015C2:  MOVFF  01,751
015C6:  MOVFF  00,750
015CA:  MOVFF  F9,757
015CE:  MOVFF  F8,756
015D2:  MOVFF  F7,755
015D6:  MOVFF  F6,754
015DA:  CALL   0D90
015DE:  MOVFF  03,6FE
015E2:  MOVFF  02,6FD
015E6:  MOVFF  01,6FC
015EA:  MOVFF  00,6FB
015EE:  BCF    FD8.1
015F0:  MOVFF  03,74D
015F4:  MOVFF  02,74C
015F8:  MOVFF  01,74B
015FC:  MOVFF  00,74A
01600:  MOVFF  F5,751
01604:  MOVFF  F4,750
01608:  MOVFF  F3,74F
0160C:  MOVFF  F2,74E
01610:  RCALL  0E86
01612:  MOVFF  03,116
01616:  MOVFF  02,115
0161A:  MOVFF  01,114
0161E:  MOVFF  00,113
....................             set_adc_channel(vMonN15);
01622:  MOVLB  F
01624:  MOVF   x5A,W
01626:  ANDLW  3F
01628:  MOVWF  01
0162A:  MOVLW  06
0162C:  MOVWF  x5A
0162E:  BTFSS  x5B.7
01630:  BRA    1640
01632:  MOVF   01,W
01634:  SUBLW  06
01636:  BZ    1640
01638:  BSF    x5B.0
0163A:  NOP   
0163C:  BTFSC  x5B.0
0163E:  BRA    163C
....................             read_adc(ADC_START_ONLY);
01640:  BSF    x5B.0
01642:  NOP   
....................             state = 0;
01644:  MOVLB  1
01646:  CLRF   xE6
....................          break;   
01648:  BRA    164C
0164A:  MOVLB  1
0164C:  MOVLB  F
....................       }
....................    }
0164E:  MOVLB  0
01650:  GOTO   A746 (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* PROCESS ADC SENSOR DATA                                                   */
.................... /*****************************************************************************/
.................... void sensor_process_data(int8 ch){
....................    adcVals[ch].sinLast = adcVals[ch].sinCounts;
*
036FC:  MOVLB  7
036FE:  MOVF   x03,W
03700:  MULLW  26
03702:  MOVF   FF3,W
03704:  CLRF   x0D
03706:  MOVWF  x0C
03708:  MOVLW  10
0370A:  ADDWF  x0C,W
0370C:  MOVWF  01
0370E:  MOVLW  00
03710:  ADDWFC x0D,W
03712:  MOVWF  03
03714:  MOVF   01,W
03716:  ADDLW  17
03718:  MOVWF  01
0371A:  MOVLW  01
0371C:  ADDWFC 03,F
0371E:  MOVFF  01,70C
03722:  MOVFF  03,70D
03726:  MOVF   x03,W
03728:  MULLW  26
0372A:  MOVF   FF3,W
0372C:  CLRF   x0F
0372E:  MOVWF  x0E
03730:  MOVLW  08
03732:  ADDWF  x0E,W
03734:  MOVWF  01
03736:  MOVLW  00
03738:  ADDWFC x0F,W
0373A:  MOVWF  03
0373C:  MOVF   01,W
0373E:  ADDLW  17
03740:  MOVWF  FE9
03742:  MOVLW  01
03744:  ADDWFC 03,W
03746:  MOVWF  FEA
03748:  MOVFF  FEF,00
0374C:  MOVFF  FEC,01
03750:  MOVFF  FEC,02
03754:  MOVFF  FEC,03
03758:  MOVFF  70D,FEA
0375C:  MOVFF  70C,FE9
03760:  MOVFF  00,FEF
03764:  MOVFF  01,FEC
03768:  MOVFF  02,FEC
0376C:  MOVFF  03,FEC
....................    adcVals[ch].cosLast = adcVals[ch].cosCounts;
03770:  MOVF   x03,W
03772:  MULLW  26
03774:  MOVF   FF3,W
03776:  CLRF   x0D
03778:  MOVWF  x0C
0377A:  MOVLW  14
0377C:  ADDWF  x0C,W
0377E:  MOVWF  01
03780:  MOVLW  00
03782:  ADDWFC x0D,W
03784:  MOVWF  03
03786:  MOVF   01,W
03788:  ADDLW  17
0378A:  MOVWF  01
0378C:  MOVLW  01
0378E:  ADDWFC 03,F
03790:  MOVFF  01,70C
03794:  MOVFF  03,70D
03798:  MOVF   x03,W
0379A:  MULLW  26
0379C:  MOVF   FF3,W
0379E:  CLRF   x0F
037A0:  MOVWF  x0E
037A2:  MOVLW  0C
037A4:  ADDWF  x0E,W
037A6:  MOVWF  01
037A8:  MOVLW  00
037AA:  ADDWFC x0F,W
037AC:  MOVWF  03
037AE:  MOVF   01,W
037B0:  ADDLW  17
037B2:  MOVWF  FE9
037B4:  MOVLW  01
037B6:  ADDWFC 03,W
037B8:  MOVWF  FEA
037BA:  MOVFF  FEF,00
037BE:  MOVFF  FEC,01
037C2:  MOVFF  FEC,02
037C6:  MOVFF  FEC,03
037CA:  MOVFF  70D,FEA
037CE:  MOVFF  70C,FE9
037D2:  MOVFF  00,FEF
037D6:  MOVFF  01,FEC
037DA:  MOVFF  02,FEC
037DE:  MOVFF  03,FEC
....................    
....................    adcVals[ch].sinRaw = (float)smData[ch].avgSin;
037E2:  MOVF   x03,W
037E4:  MULLW  26
037E6:  MOVF   FF3,W
037E8:  CLRF   x0D
037EA:  MOVWF  x0C
037EC:  MOVLW  17
037EE:  ADDWF  x0C,W
037F0:  MOVWF  01
037F2:  MOVLW  01
037F4:  ADDWFC x0D,W
037F6:  MOVWF  03
037F8:  MOVFF  01,70E
037FC:  MOVWF  x0F
037FE:  MOVF   x03,W
03800:  MULLW  09
03802:  MOVF   FF3,W
03804:  CLRF   x11
03806:  MOVWF  x10
03808:  MOVLW  01
0380A:  ADDWF  x10,W
0380C:  MOVWF  01
0380E:  MOVLW  00
03810:  ADDWFC x11,W
03812:  MOVWF  03
03814:  MOVF   01,W
03816:  ADDLW  D4
03818:  MOVWF  FE9
0381A:  MOVLW  01
0381C:  ADDWFC 03,W
0381E:  MOVWF  FEA
03820:  MOVFF  FEF,710
03824:  MOVFF  FEC,01
03828:  MOVFF  FEC,02
0382C:  MOVFF  FEC,03
03830:  MOVFF  03,713
03834:  MOVFF  02,712
03838:  MOVFF  01,711
0383C:  MOVLB  0
0383E:  CALL   1CC2
03842:  MOVFF  70F,FEA
03846:  MOVFF  70E,FE9
0384A:  MOVFF  00,FEF
0384E:  MOVFF  01,FEC
03852:  MOVFF  02,FEC
03856:  MOVFF  03,FEC
....................    adcVals[ch].cosRaw = (float)smData[ch].avgCos;
0385A:  MOVLB  7
0385C:  MOVF   x03,W
0385E:  MULLW  26
03860:  MOVF   FF3,W
03862:  CLRF   x0D
03864:  MOVWF  x0C
03866:  MOVLW  04
03868:  ADDWF  x0C,W
0386A:  MOVWF  01
0386C:  MOVLW  00
0386E:  ADDWFC x0D,W
03870:  MOVWF  03
03872:  MOVF   01,W
03874:  ADDLW  17
03876:  MOVWF  01
03878:  MOVLW  01
0387A:  ADDWFC 03,F
0387C:  MOVFF  01,70C
03880:  MOVFF  03,70D
03884:  MOVF   x03,W
03886:  MULLW  09
03888:  MOVF   FF3,W
0388A:  CLRF   x0F
0388C:  MOVWF  x0E
0388E:  MOVLW  05
03890:  ADDWF  x0E,W
03892:  MOVWF  01
03894:  MOVLW  00
03896:  ADDWFC x0F,W
03898:  MOVWF  03
0389A:  MOVF   01,W
0389C:  ADDLW  D4
0389E:  MOVWF  FE9
038A0:  MOVLW  01
038A2:  ADDWFC 03,W
038A4:  MOVWF  FEA
038A6:  MOVFF  FEF,710
038AA:  MOVFF  FEC,01
038AE:  MOVFF  FEC,02
038B2:  MOVFF  FEC,03
038B6:  MOVFF  03,713
038BA:  MOVFF  02,712
038BE:  MOVFF  01,711
038C2:  MOVLB  0
038C4:  CALL   1CC2
038C8:  MOVFF  70D,FEA
038CC:  MOVFF  70C,FE9
038D0:  MOVFF  00,FEF
038D4:  MOVFF  01,FEC
038D8:  MOVFF  02,FEC
038DC:  MOVFF  03,FEC
....................    
....................    adcVals[ch].sinCounts = adcVals[ch].sinRaw * adcCal[ch].sinGain + adcCal[ch].sinOS;
038E0:  MOVLB  7
038E2:  MOVF   x03,W
038E4:  MULLW  26
038E6:  MOVF   FF3,W
038E8:  CLRF   x0D
038EA:  MOVWF  x0C
038EC:  MOVLW  08
038EE:  ADDWF  x0C,W
038F0:  MOVWF  01
038F2:  MOVLW  00
038F4:  ADDWFC x0D,W
038F6:  MOVWF  03
038F8:  MOVF   01,W
038FA:  ADDLW  17
038FC:  MOVWF  01
038FE:  MOVLW  01
03900:  ADDWFC 03,F
03902:  MOVFF  01,70C
03906:  MOVFF  03,70D
0390A:  MOVF   x03,W
0390C:  MULLW  26
0390E:  MOVF   FF3,W
03910:  CLRF   x0F
03912:  MOVWF  x0E
03914:  MOVLW  17
03916:  ADDWF  x0E,W
03918:  MOVWF  FE9
0391A:  MOVLW  01
0391C:  ADDWFC x0F,W
0391E:  MOVWF  FEA
03920:  MOVFF  FEF,750
03924:  MOVFF  FEC,751
03928:  MOVFF  FEC,752
0392C:  MOVFF  FEC,753
03930:  MOVF   x03,W
03932:  MULLW  10
03934:  MOVF   FF3,W
03936:  CLRF   x15
03938:  MOVWF  x14
0393A:  MOVLW  08
0393C:  ADDWF  x14,W
0393E:  MOVWF  01
03940:  MOVLW  00
03942:  ADDWFC x15,W
03944:  MOVWF  03
03946:  MOVF   01,W
03948:  ADDLW  72
0394A:  MOVWF  FE9
0394C:  MOVLW  00
0394E:  ADDWFC 03,W
03950:  MOVWF  FEA
03952:  MOVFF  FEF,754
03956:  MOVFF  FEC,01
0395A:  MOVFF  FEC,02
0395E:  MOVFF  FEC,03
03962:  MOVFF  03,757
03966:  MOVFF  02,756
0396A:  MOVFF  01,755
0396E:  MOVLB  0
03970:  CALL   0D90
03974:  MOVFF  03,74D
03978:  MOVFF  02,74C
0397C:  MOVFF  01,74B
03980:  MOVFF  00,74A
03984:  MOVLB  7
03986:  MOVF   x03,W
03988:  MULLW  10
0398A:  MOVF   FF3,W
0398C:  CLRF   x15
0398E:  MOVWF  x14
03990:  MOVLW  72
03992:  ADDWF  x14,W
03994:  MOVWF  FE9
03996:  MOVLW  00
03998:  ADDWFC x15,W
0399A:  MOVWF  FEA
0399C:  MOVFF  FEF,74E
039A0:  MOVFF  FEC,01
039A4:  MOVFF  FEC,02
039A8:  MOVFF  FEC,03
039AC:  BCF    FD8.1
039AE:  MOVFF  03,751
039B2:  MOVFF  02,750
039B6:  MOVFF  01,74F
039BA:  MOVLB  0
039BC:  CALL   0E86
039C0:  MOVFF  70D,FEA
039C4:  MOVFF  70C,FE9
039C8:  MOVFF  00,FEF
039CC:  MOVFF  01,FEC
039D0:  MOVFF  02,FEC
039D4:  MOVFF  03,FEC
....................    adcVals[ch].cosCounts = adcVals[ch].cosRaw * adcCal[ch].cosGain + adcCal[ch].cosOS;
039D8:  MOVLB  7
039DA:  MOVF   x03,W
039DC:  MULLW  26
039DE:  MOVF   FF3,W
039E0:  CLRF   x0D
039E2:  MOVWF  x0C
039E4:  MOVLW  0C
039E6:  ADDWF  x0C,W
039E8:  MOVWF  01
039EA:  MOVLW  00
039EC:  ADDWFC x0D,W
039EE:  MOVWF  03
039F0:  MOVF   01,W
039F2:  ADDLW  17
039F4:  MOVWF  01
039F6:  MOVLW  01
039F8:  ADDWFC 03,F
039FA:  MOVFF  01,70C
039FE:  MOVFF  03,70D
03A02:  MOVF   x03,W
03A04:  MULLW  26
03A06:  MOVF   FF3,W
03A08:  CLRF   x0F
03A0A:  MOVWF  x0E
03A0C:  MOVLW  04
03A0E:  ADDWF  x0E,W
03A10:  MOVWF  01
03A12:  MOVLW  00
03A14:  ADDWFC x0F,W
03A16:  MOVWF  03
03A18:  MOVF   01,W
03A1A:  ADDLW  17
03A1C:  MOVWF  FE9
03A1E:  MOVLW  01
03A20:  ADDWFC 03,W
03A22:  MOVWF  FEA
03A24:  MOVFF  FEF,750
03A28:  MOVFF  FEC,751
03A2C:  MOVFF  FEC,752
03A30:  MOVFF  FEC,753
03A34:  MOVF   x03,W
03A36:  MULLW  10
03A38:  MOVF   FF3,W
03A3A:  CLRF   x13
03A3C:  MOVWF  x12
03A3E:  MOVLW  0C
03A40:  ADDWF  x12,W
03A42:  MOVWF  01
03A44:  MOVLW  00
03A46:  ADDWFC x13,W
03A48:  MOVWF  03
03A4A:  MOVF   01,W
03A4C:  ADDLW  72
03A4E:  MOVWF  FE9
03A50:  MOVLW  00
03A52:  ADDWFC 03,W
03A54:  MOVWF  FEA
03A56:  MOVFF  FEF,754
03A5A:  MOVFF  FEC,01
03A5E:  MOVFF  FEC,02
03A62:  MOVFF  FEC,03
03A66:  MOVFF  03,757
03A6A:  MOVFF  02,756
03A6E:  MOVFF  01,755
03A72:  MOVLB  0
03A74:  CALL   0D90
03A78:  MOVFF  03,74D
03A7C:  MOVFF  02,74C
03A80:  MOVFF  01,74B
03A84:  MOVFF  00,74A
03A88:  MOVLB  7
03A8A:  MOVF   x03,W
03A8C:  MULLW  10
03A8E:  MOVF   FF3,W
03A90:  CLRF   x13
03A92:  MOVWF  x12
03A94:  MOVLW  04
03A96:  ADDWF  x12,W
03A98:  MOVWF  01
03A9A:  MOVLW  00
03A9C:  ADDWFC x13,W
03A9E:  MOVWF  03
03AA0:  MOVF   01,W
03AA2:  ADDLW  72
03AA4:  MOVWF  FE9
03AA6:  MOVLW  00
03AA8:  ADDWFC 03,W
03AAA:  MOVWF  FEA
03AAC:  MOVFF  FEF,74E
03AB0:  MOVFF  FEC,01
03AB4:  MOVFF  FEC,02
03AB8:  MOVFF  FEC,03
03ABC:  BCF    FD8.1
03ABE:  MOVFF  03,751
03AC2:  MOVFF  02,750
03AC6:  MOVFF  01,74F
03ACA:  MOVLB  0
03ACC:  CALL   0E86
03AD0:  MOVFF  70D,FEA
03AD4:  MOVFF  70C,FE9
03AD8:  MOVFF  00,FEF
03ADC:  MOVFF  01,FEC
03AE0:  MOVFF  02,FEC
03AE4:  MOVFF  03,FEC
....................    float pTmp = 0;
....................    float polePitch = magPP;
03AE8:  MOVLB  7
03AEA:  CLRF   x07
03AEC:  CLRF   x06
03AEE:  CLRF   x05
03AF0:  CLRF   x04
03AF2:  CLRF   x0B
03AF4:  CLRF   x0A
03AF6:  CLRF   x09
03AF8:  MOVLW  7F
03AFA:  MOVWF  x08
....................    
....................    if (adcVals[ch].cosCounts < 0){
03AFC:  MOVF   x03,W
03AFE:  MULLW  26
03B00:  MOVF   FF3,W
03B02:  CLRF   x0D
03B04:  MOVWF  x0C
03B06:  MOVLW  0C
03B08:  ADDWF  x0C,W
03B0A:  MOVWF  01
03B0C:  MOVLW  00
03B0E:  ADDWFC x0D,W
03B10:  MOVWF  03
03B12:  MOVF   01,W
03B14:  ADDLW  17
03B16:  MOVWF  FE9
03B18:  MOVLW  01
03B1A:  ADDWFC 03,W
03B1C:  MOVWF  FEA
03B1E:  MOVFF  FEF,746
03B22:  MOVFF  FEC,747
03B26:  MOVFF  FEC,748
03B2A:  MOVFF  FEC,749
03B2E:  CLRF   x4D
03B30:  CLRF   x4C
03B32:  CLRF   x4B
03B34:  CLRF   x4A
03B36:  MOVLB  0
03B38:  CALL   1D1C
03B3C:  BTFSS  FD8.0
03B3E:  BRA    3CA8
....................       if ((adcVals[ch].sinCounts > 0) && (adcVals[ch].sinLast < 0)){
03B40:  MOVLB  7
03B42:  MOVF   x03,W
03B44:  MULLW  26
03B46:  MOVF   FF3,W
03B48:  CLRF   x0D
03B4A:  MOVWF  x0C
03B4C:  MOVLW  08
03B4E:  ADDWF  x0C,W
03B50:  MOVWF  01
03B52:  MOVLW  00
03B54:  ADDWFC x0D,W
03B56:  MOVWF  03
03B58:  MOVF   01,W
03B5A:  ADDLW  17
03B5C:  MOVWF  FE9
03B5E:  MOVLW  01
03B60:  ADDWFC 03,W
03B62:  MOVWF  FEA
03B64:  MOVFF  FEF,74A
03B68:  MOVFF  FEC,70D
03B6C:  MOVFF  FEC,74C
03B70:  MOVFF  FEC,74D
03B74:  CLRF   x49
03B76:  CLRF   x48
03B78:  CLRF   x47
03B7A:  CLRF   x46
03B7C:  MOVFF  70D,74B
03B80:  MOVLB  0
03B82:  CALL   1D1C
03B86:  BNC   3BF4
03B88:  MOVLB  7
03B8A:  MOVF   x03,W
03B8C:  MULLW  26
03B8E:  MOVF   FF3,W
03B90:  CLRF   x0D
03B92:  MOVWF  x0C
03B94:  MOVLW  10
03B96:  ADDWF  x0C,W
03B98:  MOVWF  01
03B9A:  MOVLW  00
03B9C:  ADDWFC x0D,W
03B9E:  MOVWF  03
03BA0:  MOVF   01,W
03BA2:  ADDLW  17
03BA4:  MOVWF  FE9
03BA6:  MOVLW  01
03BA8:  ADDWFC 03,W
03BAA:  MOVWF  FEA
03BAC:  MOVFF  FEF,746
03BB0:  MOVFF  FEC,747
03BB4:  MOVFF  FEC,748
03BB8:  MOVFF  FEC,749
03BBC:  CLRF   x4D
03BBE:  CLRF   x4C
03BC0:  CLRF   x4B
03BC2:  CLRF   x4A
03BC4:  MOVLB  0
03BC6:  CALL   1D1C
03BCA:  BNC   3BF4
....................          adcVals[ch].npoles--;
03BCC:  MOVLB  7
03BCE:  MOVF   x03,W
03BD0:  MULLW  26
03BD2:  MOVF   FF3,W
03BD4:  CLRF   x0D
03BD6:  MOVWF  x0C
03BD8:  MOVLW  1C
03BDA:  ADDWF  x0C,W
03BDC:  MOVWF  01
03BDE:  MOVLW  00
03BE0:  ADDWFC x0D,W
03BE2:  MOVWF  03
03BE4:  MOVF   01,W
03BE6:  ADDLW  17
03BE8:  MOVWF  FE9
03BEA:  MOVLW  01
03BEC:  ADDWFC 03,W
03BEE:  MOVWF  FEA
03BF0:  DECF   FEF,F
....................       }
03BF2:  BRA    3CA6
....................       else if ((adcVals[ch].sinCounts < 0) && (adcVals[ch].sinLast > 0)){
03BF4:  MOVLB  7
03BF6:  MOVF   x03,W
03BF8:  MULLW  26
03BFA:  MOVF   FF3,W
03BFC:  CLRF   x0D
03BFE:  MOVWF  x0C
03C00:  MOVLW  08
03C02:  ADDWF  x0C,W
03C04:  MOVWF  01
03C06:  MOVLW  00
03C08:  ADDWFC x0D,W
03C0A:  MOVWF  03
03C0C:  MOVF   01,W
03C0E:  ADDLW  17
03C10:  MOVWF  FE9
03C12:  MOVLW  01
03C14:  ADDWFC 03,W
03C16:  MOVWF  FEA
03C18:  MOVFF  FEF,746
03C1C:  MOVFF  FEC,70D
03C20:  MOVFF  FEC,748
03C24:  MOVFF  FEC,749
03C28:  MOVFF  70D,747
03C2C:  CLRF   x4D
03C2E:  CLRF   x4C
03C30:  CLRF   x4B
03C32:  CLRF   x4A
03C34:  MOVLB  0
03C36:  CALL   1D1C
03C3A:  BNC   3CA8
03C3C:  MOVLB  7
03C3E:  MOVF   x03,W
03C40:  MULLW  26
03C42:  MOVF   FF3,W
03C44:  CLRF   x0D
03C46:  MOVWF  x0C
03C48:  MOVLW  10
03C4A:  ADDWF  x0C,W
03C4C:  MOVWF  01
03C4E:  MOVLW  00
03C50:  ADDWFC x0D,W
03C52:  MOVWF  03
03C54:  MOVF   01,W
03C56:  ADDLW  17
03C58:  MOVWF  FE9
03C5A:  MOVLW  01
03C5C:  ADDWFC 03,W
03C5E:  MOVWF  FEA
03C60:  MOVFF  FEF,74A
03C64:  MOVFF  FEC,74B
03C68:  MOVFF  FEC,74C
03C6C:  MOVFF  FEC,74D
03C70:  CLRF   x49
03C72:  CLRF   x48
03C74:  CLRF   x47
03C76:  CLRF   x46
03C78:  MOVLB  0
03C7A:  CALL   1D1C
03C7E:  BNC   3CA8
....................          adcVals[ch].npoles++;
03C80:  MOVLB  7
03C82:  MOVF   x03,W
03C84:  MULLW  26
03C86:  MOVF   FF3,W
03C88:  CLRF   x0D
03C8A:  MOVWF  x0C
03C8C:  MOVLW  1C
03C8E:  ADDWF  x0C,W
03C90:  MOVWF  01
03C92:  MOVLW  00
03C94:  ADDWFC x0D,W
03C96:  MOVWF  03
03C98:  MOVF   01,W
03C9A:  ADDLW  17
03C9C:  MOVWF  FE9
03C9E:  MOVLW  01
03CA0:  ADDWFC 03,W
03CA2:  MOVWF  FEA
03CA4:  INCF   FEF,F
03CA6:  MOVLB  0
....................       }
....................    }
....................    
....................    adcVals[ch].p0 = polePitch * ( 1000 / (2*PI) ) * atan2( (float)adcVals[ch].sinCounts, (float)adcVals[ch].cosCounts );
03CA8:  MOVLB  7
03CAA:  MOVF   x03,W
03CAC:  MULLW  26
03CAE:  MOVF   FF3,W
03CB0:  CLRF   x0D
03CB2:  MOVWF  x0C
03CB4:  MOVLW  18
03CB6:  ADDWF  x0C,W
03CB8:  MOVWF  01
03CBA:  MOVLW  00
03CBC:  ADDWFC x0D,W
03CBE:  MOVWF  03
03CC0:  MOVF   01,W
03CC2:  ADDLW  17
03CC4:  MOVWF  01
03CC6:  MOVLW  01
03CC8:  ADDWFC 03,F
03CCA:  MOVFF  01,70C
03CCE:  MOVFF  03,70D
03CD2:  MOVFF  70B,753
03CD6:  MOVFF  70A,752
03CDA:  MOVFF  709,751
03CDE:  MOVFF  708,750
03CE2:  MOVLW  AA
03CE4:  MOVWF  x57
03CE6:  MOVLW  27
03CE8:  MOVWF  x56
03CEA:  MOVLW  1F
03CEC:  MOVWF  x55
03CEE:  MOVLW  86
03CF0:  MOVWF  x54
03CF2:  MOVLB  0
03CF4:  CALL   0D90
03CF8:  MOVFF  03,711
03CFC:  MOVFF  02,710
03D00:  MOVFF  01,70F
03D04:  MOVFF  00,70E
03D08:  MOVLB  7
03D0A:  MOVF   x03,W
03D0C:  MULLW  26
03D0E:  MOVF   FF3,W
03D10:  CLRF   x13
03D12:  MOVWF  x12
03D14:  MOVLW  08
03D16:  ADDWF  x12,W
03D18:  MOVWF  01
03D1A:  MOVLW  00
03D1C:  ADDWFC x13,W
03D1E:  MOVWF  03
03D20:  MOVF   01,W
03D22:  ADDLW  17
03D24:  MOVWF  FE9
03D26:  MOVLW  01
03D28:  ADDWFC 03,W
03D2A:  MOVWF  FEA
03D2C:  MOVFF  FEF,712
03D30:  MOVFF  FEC,713
03D34:  MOVFF  FEC,714
03D38:  MOVFF  FEC,715
03D3C:  MOVF   x03,W
03D3E:  MULLW  26
03D40:  MOVF   FF3,W
03D42:  CLRF   x17
03D44:  MOVWF  x16
03D46:  MOVLW  0C
03D48:  ADDWF  x16,W
03D4A:  MOVWF  01
03D4C:  MOVLW  00
03D4E:  ADDWFC x17,W
03D50:  MOVWF  03
03D52:  MOVF   01,W
03D54:  ADDLW  17
03D56:  MOVWF  FE9
03D58:  MOVLW  01
03D5A:  ADDWFC 03,W
03D5C:  MOVWF  FEA
03D5E:  MOVFF  FEF,00
03D62:  MOVFF  FEC,01
03D66:  MOVFF  FEC,02
03D6A:  MOVFF  FEC,03
03D6E:  MOVFF  03,719
03D72:  MOVFF  02,718
03D76:  MOVFF  01,717
03D7A:  MOVFF  00,716
03D7E:  MOVFF  715,71D
03D82:  MOVFF  714,71C
03D86:  MOVFF  713,71B
03D8A:  MOVFF  712,71A
03D8E:  MOVFF  03,721
03D92:  MOVFF  02,720
03D96:  MOVFF  01,71F
03D9A:  MOVFF  00,71E
03D9E:  MOVLB  0
03DA0:  GOTO   241E
03DA4:  MOVFF  711,753
03DA8:  MOVFF  710,752
03DAC:  MOVFF  70F,751
03DB0:  MOVFF  70E,750
03DB4:  MOVFF  03,757
03DB8:  MOVFF  02,756
03DBC:  MOVFF  01,755
03DC0:  MOVFF  00,754
03DC4:  CALL   0D90
03DC8:  MOVFF  70D,FEA
03DCC:  MOVFF  70C,FE9
03DD0:  MOVFF  00,FEF
03DD4:  MOVFF  01,FEC
03DD8:  MOVFF  02,FEC
03DDC:  MOVFF  03,FEC
....................    pTmp = adcVals[ch].p0 + ( 1000 * polePitch * (float)adcVals[ch].npoles );
03DE0:  MOVLB  7
03DE2:  MOVF   x03,W
03DE4:  MULLW  26
03DE6:  MOVF   FF3,W
03DE8:  CLRF   x0D
03DEA:  MOVWF  x0C
03DEC:  MOVLW  18
03DEE:  ADDWF  x0C,W
03DF0:  MOVWF  01
03DF2:  MOVLW  00
03DF4:  ADDWFC x0D,W
03DF6:  MOVWF  03
03DF8:  MOVF   01,W
03DFA:  ADDLW  17
03DFC:  MOVWF  FE9
03DFE:  MOVLW  01
03E00:  ADDWFC 03,W
03E02:  MOVWF  FEA
03E04:  MOVFF  FEF,70C
03E08:  MOVFF  FEC,70D
03E0C:  MOVFF  FEC,70E
03E10:  MOVFF  FEC,70F
03E14:  CLRF   x53
03E16:  CLRF   x52
03E18:  MOVLW  7A
03E1A:  MOVWF  x51
03E1C:  MOVLW  88
03E1E:  MOVWF  x50
03E20:  MOVFF  70B,757
03E24:  MOVFF  70A,756
03E28:  MOVFF  709,755
03E2C:  MOVFF  708,754
03E30:  MOVLB  0
03E32:  CALL   0D90
03E36:  MOVFF  03,713
03E3A:  MOVFF  02,712
03E3E:  MOVFF  01,711
03E42:  MOVFF  00,710
03E46:  MOVLB  7
03E48:  MOVF   x03,W
03E4A:  MULLW  26
03E4C:  MOVF   FF3,W
03E4E:  CLRF   x15
03E50:  MOVWF  x14
03E52:  MOVLW  1C
03E54:  ADDWF  x14,W
03E56:  MOVWF  01
03E58:  MOVLW  00
03E5A:  ADDWFC x15,W
03E5C:  MOVWF  03
03E5E:  MOVF   01,W
03E60:  ADDLW  17
03E62:  MOVWF  FE9
03E64:  MOVLW  01
03E66:  ADDWFC 03,W
03E68:  MOVWF  FEA
03E6A:  MOVF   FEF,W
03E6C:  CLRF   x3D
03E6E:  MOVWF  x3C
03E70:  BTFSC  x3C.7
03E72:  DECF   x3D,F
03E74:  MOVLB  0
03E76:  CALL   26C0
03E7A:  MOVFF  713,753
03E7E:  MOVFF  712,752
03E82:  MOVFF  711,751
03E86:  MOVFF  710,750
03E8A:  MOVFF  03,757
03E8E:  MOVFF  02,756
03E92:  MOVFF  01,755
03E96:  MOVFF  00,754
03E9A:  CALL   0D90
03E9E:  MOVFF  FEA,711
03EA2:  MOVFF  FE9,710
03EA6:  BCF    FD8.1
03EA8:  MOVFF  70F,74D
03EAC:  MOVFF  70E,74C
03EB0:  MOVFF  70D,74B
03EB4:  MOVFF  70C,74A
03EB8:  MOVFF  03,751
03EBC:  MOVFF  02,750
03EC0:  MOVFF  01,74F
03EC4:  MOVFF  00,74E
03EC8:  CALL   0E86
03ECC:  MOVFF  711,FEA
03ED0:  MOVFF  710,FE9
03ED4:  MOVFF  03,707
03ED8:  MOVFF  02,706
03EDC:  MOVFF  01,705
03EE0:  MOVFF  00,704
....................    
....................    adcVals[ch].pReal = (pow(pTmp*sc[ch].c5,5) + pow(pTmp*sc[ch].c4,4) + pow(pTmp*sc[ch].c3,3) + pow(pTmp*sc[ch].c2,2) + pTmp*sc[ch].c1 + sc[ch].c0);
03EE4:  MOVLB  7
03EE6:  MOVF   x03,W
03EE8:  MULLW  26
03EEA:  MOVF   FF3,W
03EEC:  CLRF   x0D
03EEE:  MOVWF  x0C
03EF0:  MOVLW  1D
03EF2:  ADDWF  x0C,W
03EF4:  MOVWF  01
03EF6:  MOVLW  00
03EF8:  ADDWFC x0D,W
03EFA:  MOVWF  03
03EFC:  MOVF   01,W
03EFE:  ADDLW  17
03F00:  MOVWF  01
03F02:  MOVLW  01
03F04:  ADDWFC 03,F
03F06:  MOVFF  01,70C
03F0A:  MOVFF  03,70D
03F0E:  MOVF   x03,W
03F10:  MULLW  18
03F12:  MOVF   FF3,W
03F14:  CLRF   x0F
03F16:  MOVWF  x0E
03F18:  MOVLW  14
03F1A:  ADDWF  x0E,W
03F1C:  MOVWF  01
03F1E:  MOVLW  00
03F20:  ADDWFC x0F,W
03F22:  MOVWF  03
03F24:  MOVF   01,W
03F26:  ADDLW  92
03F28:  MOVWF  FE9
03F2A:  MOVLW  00
03F2C:  ADDWFC 03,W
03F2E:  MOVWF  FEA
03F30:  MOVFF  FEF,754
03F34:  MOVFF  FEC,01
03F38:  MOVFF  FEC,02
03F3C:  MOVFF  FEC,03
03F40:  MOVFF  707,753
03F44:  MOVFF  706,752
03F48:  MOVFF  705,751
03F4C:  MOVFF  704,750
03F50:  MOVFF  03,757
03F54:  MOVFF  02,756
03F58:  MOVFF  01,755
03F5C:  MOVLB  0
03F5E:  CALL   0D90
03F62:  MOVFF  03,711
03F66:  MOVFF  02,710
03F6A:  MOVFF  01,70F
03F6E:  MOVFF  00,70E
03F72:  MOVFF  03,71D
03F76:  MOVFF  02,71C
03F7A:  MOVFF  01,71B
03F7E:  MOVFF  00,71A
03F82:  MOVLB  7
03F84:  CLRF   x21
03F86:  CLRF   x20
03F88:  MOVLW  20
03F8A:  MOVWF  x1F
03F8C:  MOVLW  81
03F8E:  MOVWF  x1E
03F90:  MOVLB  0
03F92:  CALL   33FE
03F96:  MOVFF  03,711
03F9A:  MOVFF  02,710
03F9E:  MOVFF  01,70F
03FA2:  MOVFF  00,70E
03FA6:  MOVLB  7
03FA8:  MOVF   x03,W
03FAA:  MULLW  18
03FAC:  MOVF   FF3,W
03FAE:  CLRF   x13
03FB0:  MOVWF  x12
03FB2:  MOVLW  10
03FB4:  ADDWF  x12,W
03FB6:  MOVWF  01
03FB8:  MOVLW  00
03FBA:  ADDWFC x13,W
03FBC:  MOVWF  03
03FBE:  MOVF   01,W
03FC0:  ADDLW  92
03FC2:  MOVWF  FE9
03FC4:  MOVLW  00
03FC6:  ADDWFC 03,W
03FC8:  MOVWF  FEA
03FCA:  MOVFF  FEF,754
03FCE:  MOVFF  FEC,01
03FD2:  MOVFF  FEC,02
03FD6:  MOVFF  FEC,03
03FDA:  MOVFF  707,753
03FDE:  MOVFF  706,752
03FE2:  MOVFF  705,751
03FE6:  MOVFF  704,750
03FEA:  MOVFF  03,757
03FEE:  MOVFF  02,756
03FF2:  MOVFF  01,755
03FF6:  MOVLB  0
03FF8:  CALL   0D90
03FFC:  MOVFF  03,715
04000:  MOVFF  02,714
04004:  MOVFF  01,713
04008:  MOVFF  00,712
0400C:  MOVFF  03,71D
04010:  MOVFF  02,71C
04014:  MOVFF  01,71B
04018:  MOVFF  00,71A
0401C:  MOVLB  7
0401E:  CLRF   x21
04020:  CLRF   x20
04022:  CLRF   x1F
04024:  MOVLW  81
04026:  MOVWF  x1E
04028:  MOVLB  0
0402A:  CALL   33FE
0402E:  MOVFF  FEA,713
04032:  MOVFF  FE9,712
04036:  BCF    FD8.1
04038:  MOVFF  711,74D
0403C:  MOVFF  710,74C
04040:  MOVFF  70F,74B
04044:  MOVFF  70E,74A
04048:  MOVFF  03,751
0404C:  MOVFF  02,750
04050:  MOVFF  01,74F
04054:  MOVFF  00,74E
04058:  CALL   0E86
0405C:  MOVFF  713,FEA
04060:  MOVFF  712,FE9
04064:  MOVFF  03,711
04068:  MOVFF  02,710
0406C:  MOVFF  01,70F
04070:  MOVFF  00,70E
04074:  MOVLB  7
04076:  MOVF   x03,W
04078:  MULLW  18
0407A:  MOVF   FF3,W
0407C:  CLRF   x15
0407E:  MOVWF  x14
04080:  MOVLW  0C
04082:  ADDWF  x14,W
04084:  MOVWF  01
04086:  MOVLW  00
04088:  ADDWFC x15,W
0408A:  MOVWF  03
0408C:  MOVF   01,W
0408E:  ADDLW  92
04090:  MOVWF  FE9
04092:  MOVLW  00
04094:  ADDWFC 03,W
04096:  MOVWF  FEA
04098:  MOVFF  FEF,754
0409C:  MOVFF  FEC,01
040A0:  MOVFF  FEC,02
040A4:  MOVFF  FEC,03
040A8:  MOVFF  707,753
040AC:  MOVFF  706,752
040B0:  MOVFF  705,751
040B4:  MOVFF  704,750
040B8:  MOVFF  03,757
040BC:  MOVFF  02,756
040C0:  MOVFF  01,755
040C4:  MOVLB  0
040C6:  CALL   0D90
040CA:  MOVFF  03,717
040CE:  MOVFF  02,716
040D2:  MOVFF  01,715
040D6:  MOVFF  00,714
040DA:  MOVFF  03,71D
040DE:  MOVFF  02,71C
040E2:  MOVFF  01,71B
040E6:  MOVFF  00,71A
040EA:  MOVLB  7
040EC:  CLRF   x21
040EE:  CLRF   x20
040F0:  MOVLW  40
040F2:  MOVWF  x1F
040F4:  MOVLW  80
040F6:  MOVWF  x1E
040F8:  MOVLB  0
040FA:  CALL   33FE
040FE:  MOVFF  FEA,715
04102:  MOVFF  FE9,714
04106:  BCF    FD8.1
04108:  MOVFF  711,74D
0410C:  MOVFF  710,74C
04110:  MOVFF  70F,74B
04114:  MOVFF  70E,74A
04118:  MOVFF  03,751
0411C:  MOVFF  02,750
04120:  MOVFF  01,74F
04124:  MOVFF  00,74E
04128:  CALL   0E86
0412C:  MOVFF  715,FEA
04130:  MOVFF  714,FE9
04134:  MOVFF  03,711
04138:  MOVFF  02,710
0413C:  MOVFF  01,70F
04140:  MOVFF  00,70E
04144:  MOVLB  7
04146:  MOVF   x03,W
04148:  MULLW  18
0414A:  MOVF   FF3,W
0414C:  CLRF   x17
0414E:  MOVWF  x16
04150:  MOVLW  08
04152:  ADDWF  x16,W
04154:  MOVWF  01
04156:  MOVLW  00
04158:  ADDWFC x17,W
0415A:  MOVWF  03
0415C:  MOVF   01,W
0415E:  ADDLW  92
04160:  MOVWF  FE9
04162:  MOVLW  00
04164:  ADDWFC 03,W
04166:  MOVWF  FEA
04168:  MOVFF  FEF,754
0416C:  MOVFF  FEC,01
04170:  MOVFF  FEC,02
04174:  MOVFF  FEC,03
04178:  MOVFF  707,753
0417C:  MOVFF  706,752
04180:  MOVFF  705,751
04184:  MOVFF  704,750
04188:  MOVFF  03,757
0418C:  MOVFF  02,756
04190:  MOVFF  01,755
04194:  MOVLB  0
04196:  CALL   0D90
0419A:  MOVFF  03,719
0419E:  MOVFF  02,718
041A2:  MOVFF  01,717
041A6:  MOVFF  00,716
041AA:  MOVFF  03,71D
041AE:  MOVFF  02,71C
041B2:  MOVFF  01,71B
041B6:  MOVFF  00,71A
041BA:  MOVLB  7
041BC:  CLRF   x21
041BE:  CLRF   x20
041C0:  CLRF   x1F
041C2:  MOVLW  80
041C4:  MOVWF  x1E
041C6:  MOVLB  0
041C8:  CALL   33FE
041CC:  MOVFF  FEA,717
041D0:  MOVFF  FE9,716
041D4:  BCF    FD8.1
041D6:  MOVFF  711,74D
041DA:  MOVFF  710,74C
041DE:  MOVFF  70F,74B
041E2:  MOVFF  70E,74A
041E6:  MOVFF  03,751
041EA:  MOVFF  02,750
041EE:  MOVFF  01,74F
041F2:  MOVFF  00,74E
041F6:  CALL   0E86
041FA:  MOVFF  717,FEA
041FE:  MOVFF  716,FE9
04202:  MOVFF  03,711
04206:  MOVFF  02,710
0420A:  MOVFF  01,70F
0420E:  MOVFF  00,70E
04212:  MOVLB  7
04214:  MOVF   x03,W
04216:  MULLW  18
04218:  MOVF   FF3,W
0421A:  CLRF   x19
0421C:  MOVWF  x18
0421E:  MOVLW  04
04220:  ADDWF  x18,W
04222:  MOVWF  01
04224:  MOVLW  00
04226:  ADDWFC x19,W
04228:  MOVWF  03
0422A:  MOVF   01,W
0422C:  ADDLW  92
0422E:  MOVWF  FE9
04230:  MOVLW  00
04232:  ADDWFC 03,W
04234:  MOVWF  FEA
04236:  MOVFF  FEF,754
0423A:  MOVFF  FEC,01
0423E:  MOVFF  FEC,02
04242:  MOVFF  FEC,03
04246:  MOVFF  707,753
0424A:  MOVFF  706,752
0424E:  MOVFF  705,751
04252:  MOVFF  704,750
04256:  MOVFF  03,757
0425A:  MOVFF  02,756
0425E:  MOVFF  01,755
04262:  MOVLB  0
04264:  CALL   0D90
04268:  MOVFF  FEA,719
0426C:  MOVFF  FE9,718
04270:  BCF    FD8.1
04272:  MOVFF  711,74D
04276:  MOVFF  710,74C
0427A:  MOVFF  70F,74B
0427E:  MOVFF  70E,74A
04282:  MOVFF  03,751
04286:  MOVFF  02,750
0428A:  MOVFF  01,74F
0428E:  MOVFF  00,74E
04292:  CALL   0E86
04296:  MOVFF  719,FEA
0429A:  MOVFF  718,FE9
0429E:  MOVFF  03,74D
042A2:  MOVFF  02,74C
042A6:  MOVFF  01,74B
042AA:  MOVFF  00,74A
042AE:  MOVLB  7
042B0:  MOVF   x03,W
042B2:  MULLW  18
042B4:  MOVF   FF3,W
042B6:  CLRF   x1B
042B8:  MOVWF  x1A
042BA:  MOVLW  92
042BC:  ADDWF  x1A,W
042BE:  MOVWF  FE9
042C0:  MOVLW  00
042C2:  ADDWFC x1B,W
042C4:  MOVWF  FEA
042C6:  MOVFF  FEF,74E
042CA:  MOVFF  FEC,01
042CE:  MOVFF  FEC,02
042D2:  MOVFF  FEC,03
042D6:  BCF    FD8.1
042D8:  MOVFF  03,751
042DC:  MOVFF  02,750
042E0:  MOVFF  01,74F
042E4:  MOVLB  0
042E6:  CALL   0E86
042EA:  MOVFF  70D,FEA
042EE:  MOVFF  70C,FE9
042F2:  MOVFF  00,FEF
042F6:  MOVFF  01,FEC
042FA:  MOVFF  02,FEC
042FE:  MOVFF  03,FEC
....................    if (ch == chX) adcVals[ch].pReal *= -1;
04302:  MOVLB  7
04304:  MOVF   x03,F
04306:  BNZ   4364
04308:  MOVF   x03,W
0430A:  MULLW  26
0430C:  MOVF   FF3,W
0430E:  CLRF   x0D
04310:  MOVWF  x0C
04312:  MOVLW  1D
04314:  ADDWF  x0C,W
04316:  MOVWF  01
04318:  MOVLW  00
0431A:  ADDWFC x0D,W
0431C:  MOVWF  03
0431E:  MOVF   01,W
04320:  ADDLW  17
04322:  MOVWF  FE9
04324:  MOVLW  01
04326:  ADDWFC 03,W
04328:  MOVWF  FEA
0432A:  MOVFF  FEF,750
0432E:  MOVFF  FEC,751
04332:  MOVFF  FEC,752
04336:  MOVFF  FEC,753
0433A:  MOVF   FED,F
0433C:  MOVF   FED,F
0433E:  MOVF   FED,F
04340:  CLRF   x57
04342:  CLRF   x56
04344:  MOVLW  80
04346:  MOVWF  x55
04348:  MOVLW  7F
0434A:  MOVWF  x54
0434C:  MOVLB  0
0434E:  CALL   0D90
04352:  MOVFF  00,FEF
04356:  MOVFF  01,FEC
0435A:  MOVFF  02,FEC
0435E:  MOVFF  03,FEC
04362:  MOVLB  7
....................    PID[ch].PVold = PID[ch].PV;
04364:  MOVF   x03,W
04366:  MULLW  28
04368:  MOVF   FF3,W
0436A:  CLRF   x0D
0436C:  MOVWF  x0C
0436E:  MOVLW  14
04370:  ADDWF  x0C,W
04372:  MOVWF  01
04374:  MOVLW  00
04376:  ADDWFC x0D,W
04378:  MOVWF  03
0437A:  MOVF   01,W
0437C:  ADDLW  20
0437E:  MOVWF  01
04380:  MOVLW  00
04382:  ADDWFC 03,F
04384:  MOVFF  01,70C
04388:  MOVFF  03,70D
0438C:  MOVF   x03,W
0438E:  MULLW  28
04390:  MOVF   FF3,W
04392:  CLRF   x0F
04394:  MOVWF  x0E
04396:  MOVLW  10
04398:  ADDWF  x0E,W
0439A:  MOVWF  01
0439C:  MOVLW  00
0439E:  ADDWFC x0F,W
043A0:  MOVWF  03
043A2:  MOVF   01,W
043A4:  ADDLW  20
043A6:  MOVWF  FE9
043A8:  MOVLW  00
043AA:  ADDWFC 03,W
043AC:  MOVWF  FEA
043AE:  MOVFF  FEF,00
043B2:  MOVFF  FEC,01
043B6:  MOVFF  FEC,02
043BA:  MOVFF  FEC,03
043BE:  MOVFF  70D,FEA
043C2:  MOVFF  70C,FE9
043C6:  MOVFF  00,FEF
043CA:  MOVFF  01,FEC
043CE:  MOVFF  02,FEC
043D2:  MOVFF  03,FEC
....................    PID[ch].PV = adcVals[ch].pReal;
043D6:  MOVF   x03,W
043D8:  MULLW  28
043DA:  MOVF   FF3,W
043DC:  CLRF   x0D
043DE:  MOVWF  x0C
043E0:  MOVLW  10
043E2:  ADDWF  x0C,W
043E4:  MOVWF  01
043E6:  MOVLW  00
043E8:  ADDWFC x0D,W
043EA:  MOVWF  03
043EC:  MOVF   01,W
043EE:  ADDLW  20
043F0:  MOVWF  01
043F2:  MOVLW  00
043F4:  ADDWFC 03,F
043F6:  MOVFF  01,70C
043FA:  MOVFF  03,70D
043FE:  MOVF   x03,W
04400:  MULLW  26
04402:  MOVF   FF3,W
04404:  CLRF   x0F
04406:  MOVWF  x0E
04408:  MOVLW  1D
0440A:  ADDWF  x0E,W
0440C:  MOVWF  01
0440E:  MOVLW  00
04410:  ADDWFC x0F,W
04412:  MOVWF  03
04414:  MOVF   01,W
04416:  ADDLW  17
04418:  MOVWF  FE9
0441A:  MOVLW  01
0441C:  ADDWFC 03,W
0441E:  MOVWF  FEA
04420:  MOVFF  FEF,00
04424:  MOVFF  FEC,01
04428:  MOVFF  FEC,02
0442C:  MOVFF  FEC,03
04430:  MOVFF  70D,FEA
04434:  MOVFF  70C,FE9
04438:  MOVFF  00,FEF
0443C:  MOVFF  01,FEC
04440:  MOVFF  02,FEC
04444:  MOVFF  03,FEC
04448:  MOVLB  0
0444A:  GOTO   45AA (RETURN)
.................... }  
.................... 
.................... /*****************************************************************************/
.................... /* SENSOR MONITOR INTERRUPT TASK                                             */
.................... /* starts conversion of the other two ADCs                                   */
.................... /*****************************************************************************/
.................... void sensor_monitor_interrupt_task(){
....................    static int8 ch = 0;
....................    
....................    if (!smData[ch].adcBusy){
*
001FC:  MOVLB  1
001FE:  MOVF   xE7,W
00200:  MULLW  09
00202:  MOVF   FF3,W
00204:  MOVLB  7
00206:  CLRF   x72
00208:  MOVWF  x71
0020A:  MOVLW  D4
0020C:  ADDWF  x71,W
0020E:  MOVWF  FE9
00210:  MOVLW  01
00212:  ADDWFC x72,W
00214:  MOVWF  FEA
00216:  BTFSC  FEF.1
00218:  BRA    0292
....................       smData[ch].adcBusy = true;
0021A:  MOVLB  1
0021C:  MOVF   xE7,W
0021E:  MULLW  09
00220:  MOVF   FF3,W
00222:  MOVLB  7
00224:  CLRF   x72
00226:  MOVWF  x71
00228:  MOVLW  D4
0022A:  ADDWF  x71,W
0022C:  MOVWF  FE9
0022E:  MOVLW  01
00230:  ADDWFC x72,W
00232:  MOVWF  FEA
00234:  BSF    FEF.1
....................          
....................       ads_start_conv_block(ch);
00236:  MOVFF  1E7,771
0023A:  MOVLB  0
0023C:  BRA    01E0
....................       ch = !ch;
0023E:  MOVLB  1
00240:  MOVF   xE7,F
00242:  BZ    0248
00244:  MOVLW  00
00246:  BRA    024A
00248:  MOVLW  01
0024A:  MOVWF  xE7
....................          
....................       smData[!ch].dataReady = true;
0024C:  MOVF   xE7,F
0024E:  BZ    0254
00250:  MOVLW  00
00252:  BRA    0256
00254:  MOVLW  01
00256:  MULLW  09
00258:  MOVF   FF3,W
0025A:  MOVLB  7
0025C:  CLRF   x72
0025E:  MOVWF  x71
00260:  MOVLW  D4
00262:  ADDWF  x71,W
00264:  MOVWF  FE9
00266:  MOVLW  01
00268:  ADDWFC x72,W
0026A:  MOVWF  FEA
0026C:  BSF    FEF.0
....................       smData[!ch].adcBusy = false;
0026E:  MOVLB  1
00270:  MOVF   xE7,F
00272:  BZ    0278
00274:  MOVLW  00
00276:  BRA    027A
00278:  MOVLW  01
0027A:  MULLW  09
0027C:  MOVF   FF3,W
0027E:  MOVLB  7
00280:  CLRF   x72
00282:  MOVWF  x71
00284:  MOVLW  D4
00286:  ADDWF  x71,W
00288:  MOVWF  FE9
0028A:  MOVLW  01
0028C:  ADDWFC x72,W
0028E:  MOVWF  FEA
00290:  BCF    FEF.1
....................    }
00292:  MOVLB  0
00294:  GOTO   0356 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Interquartile Mean Ring Buffer                                            */
.................... /* Filters the ADC data to remove spurious readings                          */
.................... /*****************************************************************************/
.................... void iqm_ring_buffer(int8 ch, signed int32 sinCnts, signed int32 cosCnts){
*
01766:  MOVLB  7
01768:  CLRF   x17
0176A:  CLRF   x16
0176C:  CLRF   x15
0176E:  CLRF   x14
01770:  CLRF   x1B
01772:  CLRF   x1A
01774:  CLRF   x19
01776:  CLRF   x18
01778:  CLRF   x1F
0177A:  CLRF   x1E
0177C:  CLRF   x1D
0177E:  CLRF   x1C
01780:  CLRF   x23
01782:  CLRF   x22
01784:  CLRF   x21
01786:  CLRF   x20
01788:  CLRF   x27
0178A:  CLRF   x26
0178C:  CLRF   x25
0178E:  CLRF   x24
01790:  CLRF   x2B
01792:  CLRF   x2A
01794:  CLRF   x29
01796:  CLRF   x28
....................    signed int32* sQ_ch;
....................    signed int32* cQ_ch;
....................    int* sIn_ch;
....................    int* cIn_ch;
.................... 
....................    signed int32 sumSin=0;
....................    signed int32 sumCos=0;
....................    
....................    signed int32 sinMax=0;
....................    signed int32 sinMin=0;
....................    signed int32 cosMax=0;
....................    signed int32 cosMin=0;
....................    
....................    if (ch==0){
01798:  MOVF   x03,F
0179A:  BNZ   17BE
....................       sQ_ch = sQ_x;
0179C:  MOVLW  01
0179E:  MOVWF  x0D
017A0:  MOVLW  80
017A2:  MOVWF  x0C
....................       cQ_ch = cQ_x;
017A4:  MOVLW  01
017A6:  MOVWF  x0F
017A8:  MOVLW  94
017AA:  MOVWF  x0E
....................       sIn_ch = &sIn_x;
017AC:  MOVLW  01
017AE:  MOVWF  x11
017B0:  MOVLW  D0
017B2:  MOVWF  x10
....................       cIn_ch = &cIn_x;
017B4:  MOVLW  01
017B6:  MOVWF  x13
017B8:  MOVLW  D1
017BA:  MOVWF  x12
....................    }
017BC:  BRA    17E2
....................    else if (ch==1){
017BE:  DECFSZ x03,W
017C0:  BRA    17E2
....................       sQ_ch = sQ_y;
017C2:  MOVLW  01
017C4:  MOVWF  x0D
017C6:  MOVLW  A8
017C8:  MOVWF  x0C
....................       cQ_ch = cQ_y;
017CA:  MOVLW  01
017CC:  MOVWF  x0F
017CE:  MOVLW  BC
017D0:  MOVWF  x0E
....................       sIn_ch = &sIn_y;
017D2:  MOVLW  01
017D4:  MOVWF  x11
017D6:  MOVLW  D2
017D8:  MOVWF  x10
....................       cIn_ch = &cIn_y;
017DA:  MOVLW  01
017DC:  MOVWF  x13
017DE:  MOVLW  D3
017E0:  MOVWF  x12
....................    }
.................... 
....................    push(sQ_ch, sIn_ch, sinCnts); // push new data into queues
017E2:  MOVFF  70D,72E
017E6:  MOVFF  70C,72D
017EA:  MOVFF  711,730
017EE:  MOVFF  710,72F
017F2:  MOVFF  707,734
017F6:  MOVFF  706,733
017FA:  MOVFF  705,732
017FE:  MOVFF  704,731
01802:  MOVLB  0
01804:  CALL   08F4
....................    push(cQ_ch, cIn_ch, cosCnts);
01808:  MOVFF  70F,72E
0180C:  MOVFF  70E,72D
01810:  MOVFF  713,730
01814:  MOVFF  712,72F
01818:  MOVFF  70B,734
0181C:  MOVFF  70A,733
01820:  MOVFF  709,732
01824:  MOVFF  708,731
01828:  CALL   08F4
....................    
....................    // MAX and MIN of the rolling buffer initial vals
....................    sinMax=sQ_ch[0];
0182C:  MOVLB  7
0182E:  MOVFF  70C,FE9
01832:  MOVFF  70D,FEA
01836:  MOVFF  FEF,71C
0183A:  MOVFF  FEC,71D
0183E:  MOVFF  FEC,71E
01842:  MOVFF  FEC,71F
....................    sinMin=sQ_ch[0];
01846:  MOVFF  70C,FE9
0184A:  MOVFF  70D,FEA
0184E:  MOVFF  FEF,720
01852:  MOVFF  FEC,721
01856:  MOVFF  FEC,722
0185A:  MOVFF  FEC,723
....................    cosMax=cQ_ch[0];
0185E:  MOVFF  70E,FE9
01862:  MOVFF  70F,FEA
01866:  MOVFF  FEF,724
0186A:  MOVFF  FEC,725
0186E:  MOVFF  FEC,726
01872:  MOVFF  FEC,727
....................    cosMin=cQ_ch[0];
01876:  MOVFF  70E,FE9
0187A:  MOVFF  70F,FEA
0187E:  MOVFF  FEF,728
01882:  MOVFF  FEC,729
01886:  MOVFF  FEC,72A
0188A:  MOVFF  FEC,72B
....................    
....................    // step thru buffer, adding up all vals and finding MAX and MIN
....................    for (int i=1; i<BUFFER_SIZE; i++){
0188E:  MOVLW  01
01890:  MOVWF  x2C
01892:  MOVF   x2C,W
01894:  SUBLW  04
01896:  BTFSS  FD8.0
01898:  BRA    1BA8
....................       (sinMax < sQ_ch[i]) ? (sinMax=sQ_ch[i]) : (0);
0189A:  CLRF   x42
0189C:  MOVFF  72C,741
018A0:  CLRF   x44
018A2:  MOVLW  04
018A4:  MOVWF  x43
018A6:  MOVLB  0
018A8:  CALL   08A6
018AC:  MOVFF  02,03
018B0:  MOVF   01,W
018B2:  MOVLB  7
018B4:  ADDWF  x0C,W
018B6:  MOVWF  FE9
018B8:  MOVF   x0D,W
018BA:  ADDWFC 02,W
018BC:  MOVWF  FEA
018BE:  MOVFF  FEF,00
018C2:  MOVFF  FEC,01
018C6:  MOVFF  FEC,02
018CA:  MOVFF  FEC,03
018CE:  BTFSS  x1F.7
018D0:  BRA    18D8
018D2:  BTFSS  03.7
018D4:  BRA    18FA
018D6:  BRA    18DC
018D8:  BTFSC  03.7
018DA:  BRA    1930
018DC:  MOVF   x1F,W
018DE:  SUBWF  03,W
018E0:  BNC   1930
018E2:  BNZ   18FA
018E4:  MOVF   x1E,W
018E6:  SUBWF  02,W
018E8:  BNC   1930
018EA:  BNZ   18FA
018EC:  MOVF   x1D,W
018EE:  SUBWF  01,W
018F0:  BNC   1930
018F2:  BNZ   18FA
018F4:  MOVF   00,W
018F6:  SUBWF  x1C,W
018F8:  BC    1930
018FA:  CLRF   x42
018FC:  MOVFF  72C,741
01900:  CLRF   x44
01902:  MOVLW  04
01904:  MOVWF  x43
01906:  MOVLB  0
01908:  CALL   08A6
0190C:  MOVFF  02,03
01910:  MOVF   01,W
01912:  MOVLB  7
01914:  ADDWF  x0C,W
01916:  MOVWF  FE9
01918:  MOVF   x0D,W
0191A:  ADDWFC 02,W
0191C:  MOVWF  FEA
0191E:  MOVFF  FEF,71C
01922:  MOVFF  FEC,71D
01926:  MOVFF  FEC,71E
0192A:  MOVFF  FEC,71F
0192E:  MOVF   x1C,W
....................       (sinMin > sQ_ch[i]) ? (sinMin=sQ_ch[i]) : (0);
01930:  CLRF   x42
01932:  MOVFF  72C,741
01936:  CLRF   x44
01938:  MOVLW  04
0193A:  MOVWF  x43
0193C:  MOVLB  0
0193E:  CALL   08A6
01942:  MOVFF  02,03
01946:  MOVF   01,W
01948:  MOVLB  7
0194A:  ADDWF  x0C,W
0194C:  MOVWF  FE9
0194E:  MOVF   x0D,W
01950:  ADDWFC 02,W
01952:  MOVWF  FEA
01954:  MOVFF  FEF,00
01958:  MOVFF  FEC,01
0195C:  MOVFF  FEC,02
01960:  MOVFF  FEC,03
01964:  BTFSS  03.7
01966:  BRA    196E
01968:  BTFSS  x23.7
0196A:  BRA    1990
0196C:  BRA    1972
0196E:  BTFSC  x23.7
01970:  BRA    19D4
01972:  MOVF   03,W
01974:  SUBWF  x23,W
01976:  BNC   19D4
01978:  BNZ   1990
0197A:  MOVF   02,W
0197C:  SUBWF  x22,W
0197E:  BNC   19D4
01980:  BNZ   1990
01982:  MOVF   01,W
01984:  SUBWF  x21,W
01986:  BNC   19D4
01988:  BNZ   1990
0198A:  MOVF   x20,W
0198C:  SUBWF  00,W
0198E:  BC    19D4
01990:  CLRF   x42
01992:  MOVFF  72C,741
01996:  CLRF   x44
01998:  MOVLW  04
0199A:  MOVWF  x43
0199C:  MOVLB  0
0199E:  CALL   08A6
019A2:  MOVFF  02,03
019A6:  MOVF   01,W
019A8:  MOVLB  7
019AA:  ADDWF  x0C,W
019AC:  MOVWF  FE9
019AE:  MOVF   x0D,W
019B0:  ADDWFC 02,W
019B2:  MOVWF  FEA
019B4:  MOVFF  FEF,720
019B8:  MOVFF  FEC,721
019BC:  MOVFF  FEC,722
019C0:  MOVFF  FEC,723
019C4:  MOVFF  720,00
019C8:  MOVFF  721,01
019CC:  MOVFF  722,02
019D0:  MOVFF  723,03
....................       (cosMax < cQ_ch[i]) ? (cosMax=cQ_ch[i]) : (0);
019D4:  CLRF   x42
019D6:  MOVFF  72C,741
019DA:  CLRF   x44
019DC:  MOVLW  04
019DE:  MOVWF  x43
019E0:  MOVLB  0
019E2:  CALL   08A6
019E6:  MOVFF  02,03
019EA:  MOVF   01,W
019EC:  MOVLB  7
019EE:  ADDWF  x0E,W
019F0:  MOVWF  FE9
019F2:  MOVF   x0F,W
019F4:  ADDWFC 02,W
019F6:  MOVWF  FEA
019F8:  MOVFF  FEF,00
019FC:  MOVFF  FEC,01
01A00:  MOVFF  FEC,02
01A04:  MOVFF  FEC,03
01A08:  BTFSS  x27.7
01A0A:  BRA    1A12
01A0C:  BTFSS  03.7
01A0E:  BRA    1A34
01A10:  BRA    1A16
01A12:  BTFSC  03.7
01A14:  BRA    1A78
01A16:  MOVF   x27,W
01A18:  SUBWF  03,W
01A1A:  BNC   1A78
01A1C:  BNZ   1A34
01A1E:  MOVF   x26,W
01A20:  SUBWF  02,W
01A22:  BNC   1A78
01A24:  BNZ   1A34
01A26:  MOVF   x25,W
01A28:  SUBWF  01,W
01A2A:  BNC   1A78
01A2C:  BNZ   1A34
01A2E:  MOVF   00,W
01A30:  SUBWF  x24,W
01A32:  BC    1A78
01A34:  CLRF   x42
01A36:  MOVFF  72C,741
01A3A:  CLRF   x44
01A3C:  MOVLW  04
01A3E:  MOVWF  x43
01A40:  MOVLB  0
01A42:  CALL   08A6
01A46:  MOVFF  02,03
01A4A:  MOVF   01,W
01A4C:  MOVLB  7
01A4E:  ADDWF  x0E,W
01A50:  MOVWF  FE9
01A52:  MOVF   x0F,W
01A54:  ADDWFC 02,W
01A56:  MOVWF  FEA
01A58:  MOVFF  FEF,724
01A5C:  MOVFF  FEC,725
01A60:  MOVFF  FEC,726
01A64:  MOVFF  FEC,727
01A68:  MOVFF  724,00
01A6C:  MOVFF  725,01
01A70:  MOVFF  726,02
01A74:  MOVFF  727,03
....................       (cosMin > cQ_ch[i]) ? (cosMin=cQ_ch[i]) : (0);
01A78:  CLRF   x42
01A7A:  MOVFF  72C,741
01A7E:  CLRF   x44
01A80:  MOVLW  04
01A82:  MOVWF  x43
01A84:  MOVLB  0
01A86:  CALL   08A6
01A8A:  MOVFF  02,03
01A8E:  MOVF   01,W
01A90:  MOVLB  7
01A92:  ADDWF  x0E,W
01A94:  MOVWF  FE9
01A96:  MOVF   x0F,W
01A98:  ADDWFC 02,W
01A9A:  MOVWF  FEA
01A9C:  MOVFF  FEF,00
01AA0:  MOVFF  FEC,01
01AA4:  MOVFF  FEC,02
01AA8:  MOVFF  FEC,03
01AAC:  BTFSS  03.7
01AAE:  BRA    1AB6
01AB0:  BTFSS  x2B.7
01AB2:  BRA    1AD8
01AB4:  BRA    1ABA
01AB6:  BTFSC  x2B.7
01AB8:  BRA    1B1C
01ABA:  MOVF   03,W
01ABC:  SUBWF  x2B,W
01ABE:  BNC   1B1C
01AC0:  BNZ   1AD8
01AC2:  MOVF   02,W
01AC4:  SUBWF  x2A,W
01AC6:  BNC   1B1C
01AC8:  BNZ   1AD8
01ACA:  MOVF   01,W
01ACC:  SUBWF  x29,W
01ACE:  BNC   1B1C
01AD0:  BNZ   1AD8
01AD2:  MOVF   x28,W
01AD4:  SUBWF  00,W
01AD6:  BC    1B1C
01AD8:  CLRF   x42
01ADA:  MOVFF  72C,741
01ADE:  CLRF   x44
01AE0:  MOVLW  04
01AE2:  MOVWF  x43
01AE4:  MOVLB  0
01AE6:  CALL   08A6
01AEA:  MOVFF  02,03
01AEE:  MOVF   01,W
01AF0:  MOVLB  7
01AF2:  ADDWF  x0E,W
01AF4:  MOVWF  FE9
01AF6:  MOVF   x0F,W
01AF8:  ADDWFC 02,W
01AFA:  MOVWF  FEA
01AFC:  MOVFF  FEF,728
01B00:  MOVFF  FEC,729
01B04:  MOVFF  FEC,72A
01B08:  MOVFF  FEC,72B
01B0C:  MOVFF  728,00
01B10:  MOVFF  729,01
01B14:  MOVFF  72A,02
01B18:  MOVFF  72B,03
....................       sumSin+=sQ_ch[i];
01B1C:  CLRF   x42
01B1E:  MOVFF  72C,741
01B22:  CLRF   x44
01B24:  MOVLW  04
01B26:  MOVWF  x43
01B28:  MOVLB  0
01B2A:  CALL   08A6
01B2E:  MOVFF  02,03
01B32:  MOVF   01,W
01B34:  MOVLB  7
01B36:  ADDWF  x0C,W
01B38:  MOVWF  FE9
01B3A:  MOVF   x0D,W
01B3C:  ADDWFC 02,W
01B3E:  MOVWF  FEA
01B40:  MOVFF  FEF,00
01B44:  MOVFF  FEC,01
01B48:  MOVFF  FEC,02
01B4C:  MOVFF  FEC,03
01B50:  MOVF   00,W
01B52:  ADDWF  x14,F
01B54:  MOVF   01,W
01B56:  ADDWFC x15,F
01B58:  MOVF   02,W
01B5A:  ADDWFC x16,F
01B5C:  MOVF   03,W
01B5E:  ADDWFC x17,F
....................       sumCos+=cQ_ch[i];
01B60:  CLRF   x42
01B62:  MOVFF  72C,741
01B66:  CLRF   x44
01B68:  MOVLW  04
01B6A:  MOVWF  x43
01B6C:  MOVLB  0
01B6E:  CALL   08A6
01B72:  MOVFF  02,03
01B76:  MOVF   01,W
01B78:  MOVLB  7
01B7A:  ADDWF  x0E,W
01B7C:  MOVWF  FE9
01B7E:  MOVF   x0F,W
01B80:  ADDWFC 02,W
01B82:  MOVWF  FEA
01B84:  MOVFF  FEF,00
01B88:  MOVFF  FEC,01
01B8C:  MOVFF  FEC,02
01B90:  MOVFF  FEC,03
01B94:  MOVF   00,W
01B96:  ADDWF  x18,F
01B98:  MOVF   01,W
01B9A:  ADDWFC x19,F
01B9C:  MOVF   02,W
01B9E:  ADDWFC x1A,F
01BA0:  MOVF   03,W
01BA2:  ADDWFC x1B,F
01BA4:  INCF   x2C,F
01BA6:  BRA    1892
....................    }
....................    
....................    // subtract MAX and MIN from sum
....................    sumSin-=(sinMax+sinMin);
01BA8:  MOVF   x20,W
01BAA:  ADDWF  x1C,W
01BAC:  MOVWF  00
01BAE:  MOVF   x21,W
01BB0:  ADDWFC x1D,W
01BB2:  MOVWF  01
01BB4:  MOVF   x22,W
01BB6:  ADDWFC x1E,W
01BB8:  MOVWF  02
01BBA:  MOVF   x23,W
01BBC:  ADDWFC x1F,W
01BBE:  MOVWF  03
01BC0:  MOVF   00,W
01BC2:  SUBWF  x14,F
01BC4:  MOVF   01,W
01BC6:  SUBWFB x15,F
01BC8:  MOVF   02,W
01BCA:  SUBWFB x16,F
01BCC:  MOVF   03,W
01BCE:  SUBWFB x17,F
....................    sumCos-=(cosMax+cosMin);
01BD0:  MOVF   x28,W
01BD2:  ADDWF  x24,W
01BD4:  MOVWF  00
01BD6:  MOVF   x29,W
01BD8:  ADDWFC x25,W
01BDA:  MOVWF  01
01BDC:  MOVF   x2A,W
01BDE:  ADDWFC x26,W
01BE0:  MOVWF  02
01BE2:  MOVF   x2B,W
01BE4:  ADDWFC x27,W
01BE6:  MOVWF  03
01BE8:  MOVF   00,W
01BEA:  SUBWF  x18,F
01BEC:  MOVF   01,W
01BEE:  SUBWFB x19,F
01BF0:  MOVF   02,W
01BF2:  SUBWFB x1A,F
01BF4:  MOVF   03,W
01BF6:  SUBWFB x1B,F
....................    
....................    // calc AVG
....................    smData[ch].avgSin = sumSin / (BUFFER_SIZE-2);
01BF8:  MOVF   x03,W
01BFA:  MULLW  09
01BFC:  MOVF   FF3,W
01BFE:  CLRF   x2E
01C00:  MOVWF  x2D
01C02:  MOVLW  01
01C04:  ADDWF  x2D,W
01C06:  MOVWF  01
01C08:  MOVLW  00
01C0A:  ADDWFC x2E,W
01C0C:  MOVWF  03
01C0E:  MOVF   01,W
01C10:  ADDLW  D4
01C12:  MOVWF  FE9
01C14:  MOVLW  01
01C16:  ADDWFC 03,W
01C18:  MOVWF  FEA
01C1A:  MOVFF  FEA,730
01C1E:  MOVFF  FE9,72F
01C22:  BCF    FD8.1
01C24:  MOVFF  717,734
01C28:  MOVFF  716,733
01C2C:  MOVFF  715,732
01C30:  MOVFF  714,731
01C34:  CLRF   x38
01C36:  CLRF   x37
01C38:  CLRF   x36
01C3A:  MOVLW  03
01C3C:  MOVWF  x35
01C3E:  MOVLB  0
01C40:  RCALL  167C
01C42:  MOVFF  730,FEA
01C46:  MOVFF  72F,FE9
01C4A:  MOVFF  00,FEF
01C4E:  MOVFF  01,FEC
01C52:  MOVFF  02,FEC
01C56:  MOVFF  03,FEC
....................    smData[ch].avgCos = sumCos / (BUFFER_SIZE-2);
01C5A:  MOVLB  7
01C5C:  MOVF   x03,W
01C5E:  MULLW  09
01C60:  MOVF   FF3,W
01C62:  CLRF   x2E
01C64:  MOVWF  x2D
01C66:  MOVLW  05
01C68:  ADDWF  x2D,W
01C6A:  MOVWF  01
01C6C:  MOVLW  00
01C6E:  ADDWFC x2E,W
01C70:  MOVWF  03
01C72:  MOVF   01,W
01C74:  ADDLW  D4
01C76:  MOVWF  FE9
01C78:  MOVLW  01
01C7A:  ADDWFC 03,W
01C7C:  MOVWF  FEA
01C7E:  MOVFF  FEA,730
01C82:  MOVFF  FE9,72F
01C86:  BCF    FD8.1
01C88:  MOVFF  71B,734
01C8C:  MOVFF  71A,733
01C90:  MOVFF  719,732
01C94:  MOVFF  718,731
01C98:  CLRF   x38
01C9A:  CLRF   x37
01C9C:  CLRF   x36
01C9E:  MOVLW  03
01CA0:  MOVWF  x35
01CA2:  MOVLB  0
01CA4:  RCALL  167C
01CA6:  MOVFF  730,FEA
01CAA:  MOVFF  72F,FE9
01CAE:  MOVFF  00,FEF
01CB2:  MOVFF  01,FEC
01CB6:  MOVFF  02,FEC
01CBA:  MOVFF  03,FEC
01CBE:  GOTO   4532 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SENSOR MONITOR task - gets magnetoresistive sensor counts                 */
.................... /* gets two values each time the task is run                                 */
.................... /*****************************************************************************/
.................... void sensor_monitor_task(){
*
0444E:  MOVLB  6
04450:  CLRF   xFE
04452:  CLRF   xFD
04454:  CLRF   xFC
04456:  CLRF   xFB
04458:  MOVLB  7
0445A:  CLRF   x02
0445C:  CLRF   x01
0445E:  CLRF   x00
04460:  MOVLB  6
04462:  CLRF   xFF
....................    static int8 ch = 0;
....................    signed int32 sinNew = 0;
....................    signed int32 cosNew = 0;
....................    
....................    if ( (!smData[ch].adcBusy) && smData[ch].dataReady ){
04464:  MOVLB  1
04466:  MOVF   xE8,W
04468:  MULLW  09
0446A:  MOVF   FF3,W
0446C:  MOVLB  7
0446E:  CLRF   x04
04470:  MOVWF  x03
04472:  MOVLW  D4
04474:  ADDWF  x03,W
04476:  MOVWF  FE9
04478:  MOVLW  01
0447A:  ADDWFC x04,W
0447C:  MOVWF  FEA
0447E:  BTFSC  FEF.1
04480:  BRA    45FE
04482:  MOVLB  1
04484:  MOVF   xE8,W
04486:  MULLW  09
04488:  MOVF   FF3,W
0448A:  MOVLB  7
0448C:  CLRF   x06
0448E:  MOVWF  x05
04490:  MOVLW  D4
04492:  ADDWF  x05,W
04494:  MOVWF  FE9
04496:  MOVLW  01
04498:  ADDWFC x06,W
0449A:  MOVWF  FEA
0449C:  BTFSS  FEF.0
0449E:  BRA    45FE
....................       smData[ch].adcBusy = true;
044A0:  MOVLB  1
044A2:  MOVF   xE8,W
044A4:  MULLW  09
044A6:  MOVF   FF3,W
044A8:  MOVLB  7
044AA:  CLRF   x04
044AC:  MOVWF  x03
044AE:  MOVLW  D4
044B0:  ADDWF  x03,W
044B2:  MOVWF  FE9
044B4:  MOVLW  01
044B6:  ADDWFC x04,W
044B8:  MOVWF  FEA
044BA:  BSF    FEF.1
....................       
....................       sinNew = ads_read_data(ch*2);
044BC:  BCF    FD8.0
044BE:  MOVLB  1
044C0:  RLCF   xE8,W
044C2:  MOVLB  7
044C4:  MOVWF  x03
044C6:  MOVWF  x04
044C8:  MOVLB  0
044CA:  CALL   084C
044CE:  MOVFF  03,6FE
044D2:  MOVFF  02,6FD
044D6:  MOVFF  01,6FC
044DA:  MOVFF  00,6FB
....................       cosNew = ads_read_data(ch*2+1);      
044DE:  BCF    FD8.0
044E0:  MOVLB  1
044E2:  RLCF   xE8,W
044E4:  ADDLW  01
044E6:  MOVLB  7
044E8:  MOVWF  x03
044EA:  MOVWF  x04
044EC:  MOVLB  0
044EE:  CALL   084C
044F2:  MOVFF  03,702
044F6:  MOVFF  02,701
044FA:  MOVFF  01,700
044FE:  MOVFF  00,6FF
....................       
....................       if (adcFilter){
04502:  MOVLB  1
04504:  BTFSS  x63.0
04506:  BRA    4536
....................          iqm_ring_buffer(ch, sinNew, cosNew);
04508:  MOVFF  1E8,703
0450C:  MOVFF  6FE,707
04510:  MOVFF  6FD,706
04514:  MOVFF  6FC,705
04518:  MOVFF  6FB,704
0451C:  MOVFF  702,70B
04520:  MOVFF  701,70A
04524:  MOVFF  700,709
04528:  MOVFF  6FF,708
0452C:  MOVLB  0
0452E:  GOTO   1766
....................       }
04532:  BRA    45A2
04534:  MOVLB  1
....................       else{
....................          smData[ch].avgSin = sinNew;
04536:  MOVF   xE8,W
04538:  MULLW  09
0453A:  MOVF   FF3,W
0453C:  MOVLB  7
0453E:  CLRF   x04
04540:  MOVWF  x03
04542:  MOVLW  01
04544:  ADDWF  x03,W
04546:  MOVWF  01
04548:  MOVLW  00
0454A:  ADDWFC x04,W
0454C:  MOVWF  03
0454E:  MOVF   01,W
04550:  ADDLW  D4
04552:  MOVWF  FE9
04554:  MOVLW  01
04556:  ADDWFC 03,W
04558:  MOVWF  FEA
0455A:  MOVFF  6FB,FEF
0455E:  MOVFF  6FC,FEC
04562:  MOVFF  6FD,FEC
04566:  MOVFF  6FE,FEC
....................          smData[ch].avgCos = cosNew;
0456A:  MOVLB  1
0456C:  MOVF   xE8,W
0456E:  MULLW  09
04570:  MOVF   FF3,W
04572:  MOVLB  7
04574:  CLRF   x04
04576:  MOVWF  x03
04578:  MOVLW  05
0457A:  ADDWF  x03,W
0457C:  MOVWF  01
0457E:  MOVLW  00
04580:  ADDWFC x04,W
04582:  MOVWF  03
04584:  MOVF   01,W
04586:  ADDLW  D4
04588:  MOVWF  FE9
0458A:  MOVLW  01
0458C:  ADDWFC 03,W
0458E:  MOVWF  FEA
04590:  MOVFF  6FF,FEF
04594:  MOVFF  700,FEC
04598:  MOVFF  701,FEC
0459C:  MOVFF  702,FEC
045A0:  MOVLB  0
....................       }
....................       
....................       sensor_process_data(ch);
045A2:  MOVFF  1E8,703
045A6:  GOTO   36FC
....................       ch = !ch;
045AA:  MOVLB  1
045AC:  MOVF   xE8,F
045AE:  BZ    45B4
045B0:  MOVLW  00
045B2:  BRA    45B6
045B4:  MOVLW  01
045B6:  MOVWF  xE8
....................       
....................       smData[!ch].dataReady = false;
045B8:  MOVF   xE8,F
045BA:  BZ    45C0
045BC:  MOVLW  00
045BE:  BRA    45C2
045C0:  MOVLW  01
045C2:  MULLW  09
045C4:  MOVF   FF3,W
045C6:  MOVLB  7
045C8:  CLRF   x04
045CA:  MOVWF  x03
045CC:  MOVLW  D4
045CE:  ADDWF  x03,W
045D0:  MOVWF  FE9
045D2:  MOVLW  01
045D4:  ADDWFC x04,W
045D6:  MOVWF  FEA
045D8:  BCF    FEF.0
....................       smData[!ch].adcBusy = false;
045DA:  MOVLB  1
045DC:  MOVF   xE8,F
045DE:  BZ    45E4
045E0:  MOVLW  00
045E2:  BRA    45E6
045E4:  MOVLW  01
045E6:  MULLW  09
045E8:  MOVF   FF3,W
045EA:  MOVLB  7
045EC:  CLRF   x04
045EE:  MOVWF  x03
045F0:  MOVLW  D4
045F2:  ADDWF  x03,W
045F4:  MOVWF  FE9
045F6:  MOVLW  01
045F8:  ADDWFC x04,W
045FA:  MOVWF  FEA
045FC:  BCF    FEF.1
....................    }
045FE:  MOVLB  0
04600:  GOTO   A74A (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* INITIALIZE ADC's                                                          */
.................... /*****************************************************************************/
.................... void setup_external_ADCs(){
*
0095A:  MOVLB  6
0095C:  CLRF   xFB
0095E:  CLRF   xFC
00960:  CLRF   xFD
00962:  CLRF   xFE
....................    unsigned int8 rc0=0;
....................    unsigned int8 rc1=0;
....................    unsigned int8 rc2=0;
....................    unsigned int8 rc3=0;
....................    
....................    for (int ch = 0; ch < 4; ch++){
00964:  CLRF   xFF
00966:  MOVF   xFF,W
00968:  SUBLW  03
0096A:  BNC   09A0
....................       rc0=reg0config;
0096C:  MOVLW  30
0096E:  MOVWF  xFB
....................       rc1=reg1config;
00970:  MOVLW  10
00972:  MOVWF  xFC
....................       rc2=reg2config;
00974:  CLRF   xFD
....................       rc3=reg3config;
00976:  CLRF   xFE
....................       
....................       ADS1220init(ch, rc0, rc1, rc2, rc3);
00978:  MOVFF  6FF,701
0097C:  MOVFF  6FB,702
00980:  MOVFF  6FC,703
00984:  MOVFF  6FD,704
00988:  MOVFF  6FE,705
0098C:  MOVLB  0
0098E:  BRA    0772
....................       delay_ms(100);
00990:  MOVLW  64
00992:  MOVLB  7
00994:  MOVWF  x01
00996:  MOVLB  0
00998:  RCALL  03D0
0099A:  MOVLB  6
0099C:  INCF   xFF,F
0099E:  BRA    0966
....................    }
....................    
....................    if (adcFilter){
009A0:  MOVLB  1
009A2:  BTFSS  x63.0
009A4:  BRA    0AC6
....................       for (int i = 0; i < BUFFER_SIZE; i++){
009A6:  MOVLB  7
009A8:  CLRF   x00
009AA:  MOVF   x00,W
009AC:  SUBLW  04
009AE:  BTFSS  FD8.0
009B0:  BRA    0AC4
....................          ads_start_conv_all();
009B2:  MOVLB  0
009B4:  BRA    081C
....................          delay_ms(50);
009B6:  MOVLW  32
009B8:  MOVLB  7
009BA:  MOVWF  x01
009BC:  MOVLB  0
009BE:  RCALL  03D0
....................          push(sQ_x, &sIn_x, ads_read_data(0));
009C0:  MOVLB  7
009C2:  CLRF   x04
009C4:  MOVLB  0
009C6:  RCALL  084C
009C8:  MOVFF  03,704
009CC:  MOVFF  02,703
009D0:  MOVFF  01,702
009D4:  MOVFF  00,701
009D8:  MOVLW  01
009DA:  MOVLB  7
009DC:  MOVWF  x2E
009DE:  MOVLW  80
009E0:  MOVWF  x2D
009E2:  MOVLW  01
009E4:  MOVWF  x30
009E6:  MOVLW  D0
009E8:  MOVWF  x2F
009EA:  MOVFF  03,734
009EE:  MOVFF  02,733
009F2:  MOVFF  01,732
009F6:  MOVFF  00,731
009FA:  MOVLB  0
009FC:  RCALL  08F4
....................          push(cQ_x, &cIn_x, ads_read_data(1));      
009FE:  MOVLW  01
00A00:  MOVLB  7
00A02:  MOVWF  x04
00A04:  MOVLB  0
00A06:  RCALL  084C
00A08:  MOVFF  03,704
00A0C:  MOVFF  02,703
00A10:  MOVFF  01,702
00A14:  MOVFF  00,701
00A18:  MOVLW  01
00A1A:  MOVLB  7
00A1C:  MOVWF  x2E
00A1E:  MOVLW  94
00A20:  MOVWF  x2D
00A22:  MOVLW  01
00A24:  MOVWF  x30
00A26:  MOVLW  D1
00A28:  MOVWF  x2F
00A2A:  MOVFF  03,734
00A2E:  MOVFF  02,733
00A32:  MOVFF  01,732
00A36:  MOVFF  00,731
00A3A:  MOVLB  0
00A3C:  RCALL  08F4
....................          push(sQ_y, &sIn_y, ads_read_data(2));
00A3E:  MOVLW  02
00A40:  MOVLB  7
00A42:  MOVWF  x04
00A44:  MOVLB  0
00A46:  RCALL  084C
00A48:  MOVFF  03,704
00A4C:  MOVFF  02,703
00A50:  MOVFF  01,702
00A54:  MOVFF  00,701
00A58:  MOVLW  01
00A5A:  MOVLB  7
00A5C:  MOVWF  x2E
00A5E:  MOVLW  A8
00A60:  MOVWF  x2D
00A62:  MOVLW  01
00A64:  MOVWF  x30
00A66:  MOVLW  D2
00A68:  MOVWF  x2F
00A6A:  MOVFF  03,734
00A6E:  MOVFF  02,733
00A72:  MOVFF  01,732
00A76:  MOVFF  00,731
00A7A:  MOVLB  0
00A7C:  RCALL  08F4
....................          push(cQ_y, &cIn_y, ads_read_data(3));      
00A7E:  MOVLW  03
00A80:  MOVLB  7
00A82:  MOVWF  x04
00A84:  MOVLB  0
00A86:  RCALL  084C
00A88:  MOVFF  03,704
00A8C:  MOVFF  02,703
00A90:  MOVFF  01,702
00A94:  MOVFF  00,701
00A98:  MOVLW  01
00A9A:  MOVLB  7
00A9C:  MOVWF  x2E
00A9E:  MOVLW  BC
00AA0:  MOVWF  x2D
00AA2:  MOVLW  01
00AA4:  MOVWF  x30
00AA6:  MOVLW  D3
00AA8:  MOVWF  x2F
00AAA:  MOVFF  03,734
00AAE:  MOVFF  02,733
00AB2:  MOVFF  01,732
00AB6:  MOVFF  00,731
00ABA:  MOVLB  0
00ABC:  RCALL  08F4
00ABE:  MOVLB  7
00AC0:  INCF   x00,F
00AC2:  BRA    09AA
00AC4:  MOVLB  1
....................       }
....................    }
00AC6:  MOVLB  0
00AC8:  GOTO   0B2C (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE MONITOR -- sets up ADC channels                                */
.................... /*****************************************************************************/
.................... void monitor_init(){
....................    setup_adc_ports(sAN6 | sAN16 | sAN17 | sAN24 | sAN25 | sAN26 | sAN27, NO_ANALOGS_P2, VSS_VDD);
00ACC:  MOVLW  00
00ACE:  MOVLB  F
00AD0:  MOVWF  x53
00AD2:  MOVLW  40
00AD4:  MOVWF  x0C
00AD6:  MOVLW  00
00AD8:  MOVWF  x14
00ADA:  MOVLW  03
00ADC:  MOVWF  x1C
00ADE:  MOVLW  0F
00AE0:  MOVWF  x21
00AE2:  MOVLW  00
00AE4:  MOVWF  x29
....................    setup_adc(ADC_CLOCK_INTERNAL | ADC_TAD_MUL_255 | ADC_LEGACY_MODE | ADC_THRESHOLD_INT_DISABLED);
00AE6:  MOVLW  08
00AE8:  MOVWF  x55
00AEA:  CLRF   x56
00AEC:  CLRF   x52
00AEE:  SETF   x57
00AF0:  CLRF   F61
00AF2:  MOVLW  94
00AF4:  MOVWF  x5B
....................    output_high(EN_EXC);
00AF6:  MOVLW  E8
00AF8:  MOVWF  F8B
00AFA:  BSF    F86.0
....................    set_adc_channel(vMonN15); // internal MUX
00AFC:  MOVF   x5A,W
00AFE:  ANDLW  3F
00B00:  MOVWF  01
00B02:  MOVLW  06
00B04:  MOVWF  x5A
00B06:  BTFSS  x5B.7
00B08:  BRA    0B18
00B0A:  MOVF   01,W
00B0C:  SUBLW  06
00B0E:  BZ    0B18
00B10:  BSF    x5B.0
00B12:  NOP   
00B14:  BTFSC  x5B.0
00B16:  BRA    0B14
....................    delay_ms(10);
00B18:  MOVLW  0A
00B1A:  MOVLB  7
00B1C:  MOVWF  x01
00B1E:  MOVLB  0
00B20:  RCALL  03D0
....................    read_adc(ADC_START_ONLY);
00B22:  MOVLB  F
00B24:  BSF    x5B.0
00B26:  NOP   
....................    setup_external_ADCs();
00B28:  MOVLB  0
00B2A:  BRA    095A
....................    intTimeoutReg = sensorSampleRate;
00B2C:  MOVLB  1
00B2E:  CLRF   x7F
00B30:  MOVLW  32
00B32:  MOVWF  x7E
00B34:  MOVLB  0
00B36:  GOTO   A72C (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <control.h>
.................... #ifndef control
.................... #define control
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................     float kP;      // proportional gain
....................     float kI;      // integral gain
....................     float kD;      // derivative gain
....................     float SP;      // set point-- desired output
....................     float PV;      // process variable-- measured output
....................     float PVold;   // oldPV value  
....................     float CV;      // control variable-- output -- 0 to 100%
....................     float I;       // integral value
....................     float maxSP;   // Max setpoint in microns
....................     float minSP;   // Min setpoint in microns
.................... }PID[2] = {
....................    //  P     I     D
....................    //0.01    0.3   0.1
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}, 
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}
....................     };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... //!#define op_upper_bound 63  // CRYO
.................... //!#define op_lower_bound -63 // CRYO
.................... 
.................... #define op_upper_bound 63  // AMBIENT 
.................... #define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    BOOLEAN homeFlag;       // Flag to trigger the homing routine
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,FALSE},
....................    {0,0,0,0,0,0,0,0,0,0,FALSE}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................     BOOLEAN invV;
....................     unsigned int16 ipVal;
....................     float opPcnt;
....................    
.................... }dacVals[2] = 
.................... {
....................     {FALSE,0,0},
....................     {FALSE,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <pid.h>
.................... #ifndef pidcontroller
.................... #define pidcontroller
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................     float kP;      // proportional gain
....................     float kI;      // integral gain
....................     float kD;      // derivative gain
....................     float SP;      // set point-- desired output
....................     float PV;      // process variable-- measured output
....................     float PVold;   // oldPV value  
....................     float CV;      // control variable-- output -- 0 to 100%
....................     float I;       // integral value
....................     float maxSP;   // Max setpoint in microns
....................     float minSP;   // Min setpoint in microns
.................... }PID[2] = {
....................    //  P     I     D
....................    //0.01    0.3   0.1
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}, 
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}
....................     };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... //!#define op_upper_bound 63  // CRYO
.................... //!#define op_lower_bound -63 // CRYO
.................... 
.................... #define op_upper_bound 63  // AMBIENT 
.................... #define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    BOOLEAN homeFlag;       // Flag to trigger the homing routine
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,FALSE},
....................    {0,0,0,0,0,0,0,0,0,0,FALSE}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................     BOOLEAN invV;
....................     unsigned int16 ipVal;
....................     float opPcnt;
....................    
.................... }dacVals[2] = 
.................... {
....................     {FALSE,0,0},
....................     {FALSE,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float32)(unsigned int16)y;
.................... 
....................  else if (y < 10000000.0)
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
....................       res = 32768.0*(float32)l;
....................       res += (float32)(unsigned int16)y;
....................    }
.................... 
....................  else
....................   res = y;
.................... 
....................  y = y - (float32)(unsigned int16)y;
.................... 
....................  if (s)
....................   res = -res;
.................... 
....................  if (y != 0)
....................  {
....................   if (s == 1 && n == 0)
....................    res -= 1.0;
.................... 
....................   if (s == 0 && n == 1)
....................    res += 1.0;
....................  }
....................  if (x == 0)
....................     res = 0;
.................... 
....................  return (res);
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl[0]*y2 + pl[1];
.................... 
....................       r = ql[0]*y2 + ql[1];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
....................          r = -(float32)-n;
....................       else
....................          r = (float32)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* UPDATE the Control Variable (CV)                                          */
.................... /*****************************************************************************/
.................... void pid_update (channelMap ch){
*
046CC:  MOVLB  7
046CE:  MOVF   x01,W
046D0:  MULLW  28
046D2:  MOVF   FF3,W
046D4:  CLRF   x0F
046D6:  MOVWF  x0E
046D8:  MOVLW  0C
046DA:  ADDWF  x0E,W
046DC:  MOVWF  01
046DE:  MOVLW  00
046E0:  ADDWFC x0F,W
046E2:  MOVWF  03
046E4:  MOVF   01,W
046E6:  ADDLW  20
046E8:  MOVWF  FE9
046EA:  MOVLW  00
046EC:  ADDWFC 03,W
046EE:  MOVWF  FEA
046F0:  MOVFF  FEF,74A
046F4:  MOVFF  FEC,74B
046F8:  MOVFF  FEC,74C
046FC:  MOVFF  FEC,74D
04700:  MOVF   x01,W
04702:  MULLW  28
04704:  MOVF   FF3,W
04706:  CLRF   x13
04708:  MOVWF  x12
0470A:  MOVLW  10
0470C:  ADDWF  x12,W
0470E:  MOVWF  01
04710:  MOVLW  00
04712:  ADDWFC x13,W
04714:  MOVWF  03
04716:  MOVF   01,W
04718:  ADDLW  20
0471A:  MOVWF  FE9
0471C:  MOVLW  00
0471E:  ADDWFC 03,W
04720:  MOVWF  FEA
04722:  MOVFF  FEF,74E
04726:  MOVFF  FEC,01
0472A:  MOVFF  FEC,02
0472E:  MOVFF  FEC,03
04732:  MOVFF  FEA,713
04736:  MOVFF  FE9,712
0473A:  BSF    FD8.1
0473C:  MOVFF  03,751
04740:  MOVFF  02,750
04744:  MOVFF  01,74F
04748:  MOVLB  0
0474A:  CALL   0E86
0474E:  MOVFF  713,FEA
04752:  MOVFF  712,FE9
04756:  MOVFF  03,705
0475A:  MOVFF  02,704
0475E:  MOVFF  01,703
04762:  MOVFF  00,702
....................    float err = PID[ch].SP - PID[ch].PV;  // error = set value - measured
....................    
....................    PID[ch].I += err*PID[ch].kI;
04766:  MOVLB  7
04768:  MOVF   x01,W
0476A:  MULLW  28
0476C:  MOVF   FF3,W
0476E:  CLRF   x0F
04770:  MOVWF  x0E
04772:  MOVLW  1C
04774:  ADDWF  x0E,W
04776:  MOVWF  01
04778:  MOVLW  00
0477A:  ADDWFC x0F,W
0477C:  MOVWF  03
0477E:  MOVF   01,W
04780:  ADDLW  20
04782:  MOVWF  01
04784:  MOVLW  00
04786:  ADDWFC 03,F
04788:  MOVFF  01,70E
0478C:  MOVFF  03,70F
04790:  MOVFF  03,FEA
04794:  MOVFF  01,FE9
04798:  MOVFF  FEF,710
0479C:  MOVFF  FEC,711
047A0:  MOVFF  FEC,712
047A4:  MOVFF  FEC,713
047A8:  MOVF   x01,W
047AA:  MULLW  28
047AC:  MOVF   FF3,W
047AE:  CLRF   x15
047B0:  MOVWF  x14
047B2:  MOVLW  04
047B4:  ADDWF  x14,W
047B6:  MOVWF  01
047B8:  MOVLW  00
047BA:  ADDWFC x15,W
047BC:  MOVWF  03
047BE:  MOVF   01,W
047C0:  ADDLW  20
047C2:  MOVWF  FE9
047C4:  MOVLW  00
047C6:  ADDWFC 03,W
047C8:  MOVWF  FEA
047CA:  MOVFF  FEF,754
047CE:  MOVFF  FEC,01
047D2:  MOVFF  FEC,02
047D6:  MOVFF  FEC,03
047DA:  MOVFF  705,753
047DE:  MOVFF  704,752
047E2:  MOVFF  703,751
047E6:  MOVFF  702,750
047EA:  MOVFF  03,757
047EE:  MOVFF  02,756
047F2:  MOVFF  01,755
047F6:  MOVLB  0
047F8:  CALL   0D90
047FC:  BCF    FD8.1
047FE:  MOVFF  713,74D
04802:  MOVFF  712,74C
04806:  MOVFF  711,74B
0480A:  MOVFF  710,74A
0480E:  MOVFF  03,751
04812:  MOVFF  02,750
04816:  MOVFF  01,74F
0481A:  MOVFF  00,74E
0481E:  CALL   0E86
04822:  MOVFF  70F,FEA
04826:  MOVFF  70E,FE9
0482A:  MOVFF  00,FEF
0482E:  MOVFF  01,FEC
04832:  MOVFF  02,FEC
04836:  MOVFF  03,FEC
....................    if (PID[ch].I > op_upper_bound) PID[ch].I = op_upper_bound; // anti-windup
0483A:  MOVLB  7
0483C:  MOVF   x01,W
0483E:  MULLW  28
04840:  MOVF   FF3,W
04842:  CLRF   x0F
04844:  MOVWF  x0E
04846:  MOVLW  1C
04848:  ADDWF  x0E,W
0484A:  MOVWF  01
0484C:  MOVLW  00
0484E:  ADDWFC x0F,W
04850:  MOVWF  03
04852:  MOVF   01,W
04854:  ADDLW  20
04856:  MOVWF  FE9
04858:  MOVLW  00
0485A:  ADDWFC 03,W
0485C:  MOVWF  FEA
0485E:  MOVFF  FEF,74A
04862:  MOVFF  FEC,70F
04866:  MOVFF  FEC,74C
0486A:  MOVFF  FEC,74D
0486E:  CLRF   x49
04870:  CLRF   x48
04872:  MOVLW  7C
04874:  MOVWF  x47
04876:  MOVLW  84
04878:  MOVWF  x46
0487A:  MOVFF  70F,74B
0487E:  MOVLB  0
04880:  CALL   1D1C
04884:  BNC   48B8
04886:  MOVLB  7
04888:  MOVF   x01,W
0488A:  MULLW  28
0488C:  MOVF   FF3,W
0488E:  CLRF   x0F
04890:  MOVWF  x0E
04892:  MOVLW  1C
04894:  ADDWF  x0E,W
04896:  MOVWF  01
04898:  MOVLW  00
0489A:  ADDWFC x0F,W
0489C:  MOVWF  03
0489E:  MOVF   01,W
048A0:  ADDLW  20
048A2:  MOVWF  FE9
048A4:  MOVLW  00
048A6:  ADDWFC 03,W
048A8:  MOVWF  FEA
048AA:  MOVLW  84
048AC:  MOVWF  FEF
048AE:  MOVLW  7C
048B0:  MOVWF  FEC
048B2:  CLRF   FEC
048B4:  CLRF   FEC
048B6:  BRA    4934
....................    else if (PID[ch].I < op_lower_bound) PID[ch].I = op_lower_bound;
048B8:  MOVLB  7
048BA:  MOVF   x01,W
048BC:  MULLW  28
048BE:  MOVF   FF3,W
048C0:  CLRF   x0F
048C2:  MOVWF  x0E
048C4:  MOVLW  1C
048C6:  ADDWF  x0E,W
048C8:  MOVWF  01
048CA:  MOVLW  00
048CC:  ADDWFC x0F,W
048CE:  MOVWF  03
048D0:  MOVF   01,W
048D2:  ADDLW  20
048D4:  MOVWF  FE9
048D6:  MOVLW  00
048D8:  ADDWFC 03,W
048DA:  MOVWF  FEA
048DC:  MOVFF  FEF,746
048E0:  MOVFF  FEC,70F
048E4:  MOVFF  FEC,748
048E8:  MOVFF  FEC,749
048EC:  MOVFF  70F,747
048F0:  CLRF   x4D
048F2:  CLRF   x4C
048F4:  MOVLW  C0
048F6:  MOVWF  x4B
048F8:  MOVLW  82
048FA:  MOVWF  x4A
048FC:  MOVLB  0
048FE:  CALL   1D1C
04902:  BNC   4936
04904:  MOVLB  7
04906:  MOVF   x01,W
04908:  MULLW  28
0490A:  MOVF   FF3,W
0490C:  CLRF   x0F
0490E:  MOVWF  x0E
04910:  MOVLW  1C
04912:  ADDWF  x0E,W
04914:  MOVWF  01
04916:  MOVLW  00
04918:  ADDWFC x0F,W
0491A:  MOVWF  03
0491C:  MOVF   01,W
0491E:  ADDLW  20
04920:  MOVWF  FE9
04922:  MOVLW  00
04924:  ADDWFC 03,W
04926:  MOVWF  FEA
04928:  MOVLW  82
0492A:  MOVWF  FEF
0492C:  MOVLW  C0
0492E:  MOVWF  FEC
04930:  CLRF   FEC
04932:  CLRF   FEC
04934:  MOVLB  0
....................    
....................    float P = err * PID[ch].kP;  // proportional value
....................    
....................    float D = PID[ch].kD * (PID[ch].PV - PID[ch].PVold);  // derivative value
04936:  MOVLB  7
04938:  MOVF   x01,W
0493A:  MULLW  28
0493C:  MOVF   FF3,W
0493E:  CLRF   x0F
04940:  MOVWF  x0E
04942:  MOVLW  20
04944:  ADDWF  x0E,W
04946:  MOVWF  FE9
04948:  MOVLW  00
0494A:  ADDWFC x0F,W
0494C:  MOVWF  FEA
0494E:  MOVFF  FEF,754
04952:  MOVFF  FEC,01
04956:  MOVFF  FEC,02
0495A:  MOVFF  FEC,03
0495E:  MOVFF  705,753
04962:  MOVFF  704,752
04966:  MOVFF  703,751
0496A:  MOVFF  702,750
0496E:  MOVFF  03,757
04972:  MOVFF  02,756
04976:  MOVFF  01,755
0497A:  MOVLB  0
0497C:  CALL   0D90
04980:  MOVFF  03,709
04984:  MOVFF  02,708
04988:  MOVFF  01,707
0498C:  MOVFF  00,706
04990:  MOVLB  7
04992:  MOVF   x01,W
04994:  MULLW  28
04996:  MOVF   FF3,W
04998:  CLRF   x11
0499A:  MOVWF  x10
0499C:  MOVLW  08
0499E:  ADDWF  x10,W
049A0:  MOVWF  01
049A2:  MOVLW  00
049A4:  ADDWFC x11,W
049A6:  MOVWF  03
049A8:  MOVF   01,W
049AA:  ADDLW  20
049AC:  MOVWF  FE9
049AE:  MOVLW  00
049B0:  ADDWFC 03,W
049B2:  MOVWF  FEA
049B4:  MOVFF  FEF,710
049B8:  MOVFF  FEC,711
049BC:  MOVFF  FEC,712
049C0:  MOVFF  FEC,713
049C4:  MOVF   x01,W
049C6:  MULLW  28
049C8:  MOVF   FF3,W
049CA:  CLRF   x15
049CC:  MOVWF  x14
049CE:  MOVLW  10
049D0:  ADDWF  x14,W
049D2:  MOVWF  01
049D4:  MOVLW  00
049D6:  ADDWFC x15,W
049D8:  MOVWF  03
049DA:  MOVF   01,W
049DC:  ADDLW  20
049DE:  MOVWF  FE9
049E0:  MOVLW  00
049E2:  ADDWFC 03,W
049E4:  MOVWF  FEA
049E6:  MOVFF  FEF,74A
049EA:  MOVFF  FEC,74B
049EE:  MOVFF  FEC,74C
049F2:  MOVFF  FEC,74D
049F6:  MOVF   x01,W
049F8:  MULLW  28
049FA:  MOVF   FF3,W
049FC:  CLRF   x19
049FE:  MOVWF  x18
04A00:  MOVLW  14
04A02:  ADDWF  x18,W
04A04:  MOVWF  01
04A06:  MOVLW  00
04A08:  ADDWFC x19,W
04A0A:  MOVWF  03
04A0C:  MOVF   01,W
04A0E:  ADDLW  20
04A10:  MOVWF  FE9
04A12:  MOVLW  00
04A14:  ADDWFC 03,W
04A16:  MOVWF  FEA
04A18:  MOVFF  FEF,74E
04A1C:  MOVFF  FEC,01
04A20:  MOVFF  FEC,02
04A24:  MOVFF  FEC,03
04A28:  MOVFF  FEA,719
04A2C:  MOVFF  FE9,718
04A30:  BSF    FD8.1
04A32:  MOVFF  03,751
04A36:  MOVFF  02,750
04A3A:  MOVFF  01,74F
04A3E:  MOVLB  0
04A40:  CALL   0E86
04A44:  MOVFF  719,FEA
04A48:  MOVFF  718,FE9
04A4C:  MOVFF  713,753
04A50:  MOVFF  712,752
04A54:  MOVFF  711,751
04A58:  MOVFF  710,750
04A5C:  MOVFF  03,757
04A60:  MOVFF  02,756
04A64:  MOVFF  01,755
04A68:  MOVFF  00,754
04A6C:  CALL   0D90
04A70:  MOVFF  03,70D
04A74:  MOVFF  02,70C
04A78:  MOVFF  01,70B
04A7C:  MOVFF  00,70A
....................    
....................    PID[ch].CV = P + PID[ch].I + D;  // new control variable
04A80:  MOVLB  7
04A82:  MOVF   x01,W
04A84:  MULLW  28
04A86:  MOVF   FF3,W
04A88:  CLRF   x0F
04A8A:  MOVWF  x0E
04A8C:  MOVLW  18
04A8E:  ADDWF  x0E,W
04A90:  MOVWF  01
04A92:  MOVLW  00
04A94:  ADDWFC x0F,W
04A96:  MOVWF  03
04A98:  MOVF   01,W
04A9A:  ADDLW  20
04A9C:  MOVWF  01
04A9E:  MOVLW  00
04AA0:  ADDWFC 03,F
04AA2:  MOVFF  01,70E
04AA6:  MOVFF  03,70F
04AAA:  MOVF   x01,W
04AAC:  MULLW  28
04AAE:  MOVF   FF3,W
04AB0:  CLRF   x11
04AB2:  MOVWF  x10
04AB4:  MOVLW  1C
04AB6:  ADDWF  x10,W
04AB8:  MOVWF  01
04ABA:  MOVLW  00
04ABC:  ADDWFC x11,W
04ABE:  MOVWF  03
04AC0:  MOVF   01,W
04AC2:  ADDLW  20
04AC4:  MOVWF  FE9
04AC6:  MOVLW  00
04AC8:  ADDWFC 03,W
04ACA:  MOVWF  FEA
04ACC:  MOVFF  FEF,74E
04AD0:  MOVFF  FEC,01
04AD4:  MOVFF  FEC,02
04AD8:  MOVFF  FEC,03
04ADC:  MOVFF  FEA,711
04AE0:  MOVFF  FE9,710
04AE4:  BCF    FD8.1
04AE6:  MOVFF  709,74D
04AEA:  MOVFF  708,74C
04AEE:  MOVFF  707,74B
04AF2:  MOVFF  706,74A
04AF6:  MOVFF  03,751
04AFA:  MOVFF  02,750
04AFE:  MOVFF  01,74F
04B02:  MOVLB  0
04B04:  CALL   0E86
04B08:  MOVFF  711,FEA
04B0C:  MOVFF  710,FE9
04B10:  MOVFF  03,715
04B14:  MOVFF  02,714
04B18:  MOVFF  01,713
04B1C:  MOVFF  00,712
04B20:  BCF    FD8.1
04B22:  MOVFF  03,74D
04B26:  MOVFF  02,74C
04B2A:  MOVFF  01,74B
04B2E:  MOVFF  00,74A
04B32:  MOVFF  70D,751
04B36:  MOVFF  70C,750
04B3A:  MOVFF  70B,74F
04B3E:  MOVFF  70A,74E
04B42:  CALL   0E86
04B46:  MOVFF  70F,FEA
04B4A:  MOVFF  70E,FE9
04B4E:  MOVFF  00,FEF
04B52:  MOVFF  01,FEC
04B56:  MOVFF  02,FEC
04B5A:  MOVFF  03,FEC
....................    if (PID[ch].CV > op_upper_bound) PID[ch].CV = op_upper_bound; // limit positive output
04B5E:  MOVLB  7
04B60:  MOVF   x01,W
04B62:  MULLW  28
04B64:  MOVF   FF3,W
04B66:  CLRF   x0F
04B68:  MOVWF  x0E
04B6A:  MOVLW  18
04B6C:  ADDWF  x0E,W
04B6E:  MOVWF  01
04B70:  MOVLW  00
04B72:  ADDWFC x0F,W
04B74:  MOVWF  03
04B76:  MOVF   01,W
04B78:  ADDLW  20
04B7A:  MOVWF  FE9
04B7C:  MOVLW  00
04B7E:  ADDWFC 03,W
04B80:  MOVWF  FEA
04B82:  MOVFF  FEF,74A
04B86:  MOVFF  FEC,70F
04B8A:  MOVFF  FEC,74C
04B8E:  MOVFF  FEC,74D
04B92:  CLRF   x49
04B94:  CLRF   x48
04B96:  MOVLW  7C
04B98:  MOVWF  x47
04B9A:  MOVLW  84
04B9C:  MOVWF  x46
04B9E:  MOVFF  70F,74B
04BA2:  MOVLB  0
04BA4:  CALL   1D1C
04BA8:  BNC   4BDC
04BAA:  MOVLB  7
04BAC:  MOVF   x01,W
04BAE:  MULLW  28
04BB0:  MOVF   FF3,W
04BB2:  CLRF   x0F
04BB4:  MOVWF  x0E
04BB6:  MOVLW  18
04BB8:  ADDWF  x0E,W
04BBA:  MOVWF  01
04BBC:  MOVLW  00
04BBE:  ADDWFC x0F,W
04BC0:  MOVWF  03
04BC2:  MOVF   01,W
04BC4:  ADDLW  20
04BC6:  MOVWF  FE9
04BC8:  MOVLW  00
04BCA:  ADDWFC 03,W
04BCC:  MOVWF  FEA
04BCE:  MOVLW  84
04BD0:  MOVWF  FEF
04BD2:  MOVLW  7C
04BD4:  MOVWF  FEC
04BD6:  CLRF   FEC
04BD8:  CLRF   FEC
04BDA:  BRA    4C58
....................    else if (PID[ch].CV < op_lower_bound) PID[ch].CV = op_lower_bound; // limit negative output
04BDC:  MOVLB  7
04BDE:  MOVF   x01,W
04BE0:  MULLW  28
04BE2:  MOVF   FF3,W
04BE4:  CLRF   x0F
04BE6:  MOVWF  x0E
04BE8:  MOVLW  18
04BEA:  ADDWF  x0E,W
04BEC:  MOVWF  01
04BEE:  MOVLW  00
04BF0:  ADDWFC x0F,W
04BF2:  MOVWF  03
04BF4:  MOVF   01,W
04BF6:  ADDLW  20
04BF8:  MOVWF  FE9
04BFA:  MOVLW  00
04BFC:  ADDWFC 03,W
04BFE:  MOVWF  FEA
04C00:  MOVFF  FEF,746
04C04:  MOVFF  FEC,70F
04C08:  MOVFF  FEC,748
04C0C:  MOVFF  FEC,749
04C10:  MOVFF  70F,747
04C14:  CLRF   x4D
04C16:  CLRF   x4C
04C18:  MOVLW  C0
04C1A:  MOVWF  x4B
04C1C:  MOVLW  82
04C1E:  MOVWF  x4A
04C20:  MOVLB  0
04C22:  CALL   1D1C
04C26:  BNC   4C58
04C28:  MOVLB  7
04C2A:  MOVF   x01,W
04C2C:  MULLW  28
04C2E:  MOVF   FF3,W
04C30:  CLRF   x0F
04C32:  MOVWF  x0E
04C34:  MOVLW  18
04C36:  ADDWF  x0E,W
04C38:  MOVWF  01
04C3A:  MOVLW  00
04C3C:  ADDWFC x0F,W
04C3E:  MOVWF  03
04C40:  MOVF   01,W
04C42:  ADDLW  20
04C44:  MOVWF  FE9
04C46:  MOVLW  00
04C48:  ADDWFC 03,W
04C4A:  MOVWF  FEA
04C4C:  MOVLW  82
04C4E:  MOVWF  FEF
04C50:  MOVLW  C0
04C52:  MOVWF  FEC
04C54:  CLRF   FEC
04C56:  CLRF   FEC
04C58:  MOVLB  0
04C5A:  GOTO   4CD8 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PID Task - looks for change to PV and updates CV                          */
.................... /*****************************************************************************/
.................... void pid_task(channelMap ch){
....................    static int index = 0;
....................    if (PID[ch].SP != PID[ch].PV) pid_update(ch);
04C5E:  MOVLB  6
04C60:  MOVF   xFE,W
04C62:  MULLW  28
04C64:  MOVF   FF3,W
04C66:  MOVLB  7
04C68:  CLRF   x01
04C6A:  MOVWF  x00
04C6C:  MOVLW  0C
04C6E:  ADDWF  x00,W
04C70:  MOVWF  01
04C72:  MOVLW  00
04C74:  ADDWFC x01,W
04C76:  MOVWF  03
04C78:  MOVF   01,W
04C7A:  ADDLW  20
04C7C:  MOVWF  FE9
04C7E:  MOVLW  00
04C80:  ADDWFC 03,W
04C82:  MOVWF  FEA
04C84:  MOVFF  FEF,746
04C88:  MOVFF  FEC,747
04C8C:  MOVFF  FEC,748
04C90:  MOVFF  FEC,749
04C94:  MOVLB  6
04C96:  MOVF   xFE,W
04C98:  MULLW  28
04C9A:  MOVF   FF3,W
04C9C:  MOVLB  7
04C9E:  CLRF   x05
04CA0:  MOVWF  x04
04CA2:  MOVLW  10
04CA4:  ADDWF  x04,W
04CA6:  MOVWF  01
04CA8:  MOVLW  00
04CAA:  ADDWFC x05,W
04CAC:  MOVWF  03
04CAE:  MOVF   01,W
04CB0:  ADDLW  20
04CB2:  MOVWF  FE9
04CB4:  MOVLW  00
04CB6:  ADDWFC 03,W
04CB8:  MOVWF  FEA
04CBA:  MOVFF  FEF,74A
04CBE:  MOVFF  FEC,74B
04CC2:  MOVFF  FEC,74C
04CC6:  MOVFF  FEC,74D
04CCA:  MOVLB  0
04CCC:  CALL   1D1C
04CD0:  BZ    4CD8
04CD2:  MOVFF  6FE,701
04CD6:  BRA    46CC
....................    if ((index++) >= numChannels) index = 0;
04CD8:  MOVLB  1
04CDA:  MOVF   xE9,W
04CDC:  INCF   xE9,F
04CDE:  SUBLW  01
04CE0:  BC    4CE4
04CE2:  CLRF   xE9
04CE4:  MOVLB  0
04CE6:  GOTO   4DF8 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... #pin_select SCK1=PIN_C3
.................... #pin_select SDO1=PIN_C2
.................... #use spi (MASTER, SPI1, BAUD=100000, MODE=2, STREAM=SPI_ctrl)
*
00B3A:  CLRF   03
00B3C:  MOVF   F91,W
00B3E:  MOVFF  700,F91
00B42:  RRCF   F94,W
00B44:  BNC   0B42
00B46:  MOVF   F91,W
00B48:  MOVWF  02
00B4A:  MOVFF  6FF,F91
00B4E:  RRCF   F94,W
00B50:  BNC   0B4E
00B52:  MOVF   F91,W
00B54:  MOVWF  01
00B56:  MOVFF  6FE,F91
00B5A:  RRCF   F94,W
00B5C:  BNC   0B5A
00B5E:  MOVFF  F91,00
00B62:  RETURN 0
.................... 
.................... #define DACfullScale 655.35 // full scale/100 because CV = %
.................... 
.................... /*****************************************************************************/
.................... /*  Inverts the output voltage ( -180V - 0V )                                */ 
.................... /*****************************************************************************/
.................... void invert_voltage(channelMap ch, BOOLEAN inv_v){
....................    if ( inv_v ) {
*
0463A:  MOVLB  6
0463C:  MOVF   xFF,F
0463E:  BZ    4686
....................       if (chMap[0] == ch) output_low(INV_HVX);
04640:  MOVLW  00
04642:  MOVLB  0
04644:  BTFSC  x70.0
04646:  MOVLW  01
04648:  MOVLB  6
0464A:  SUBWF  xFE,W
0464C:  BNZ   4654
0464E:  MOVLW  04
04650:  MOVWF  F88
04652:  BCF    F83.4
....................       if (chMap[1] == ch) output_low(INV_HVY);
04654:  MOVLW  00
04656:  MOVLB  0
04658:  BTFSC  x70.1
0465A:  MOVLW  01
0465C:  MOVLB  6
0465E:  SUBWF  xFE,W
04660:  BNZ   4668
04662:  MOVLW  04
04664:  MOVWF  F88
04666:  BCF    F83.5
....................       dacVals[ch].invV = TRUE;
04668:  MOVF   xFE,W
0466A:  MULLW  07
0466C:  MOVF   FF3,W
0466E:  MOVLB  7
04670:  CLRF   x01
04672:  MOVWF  x00
04674:  MOVLW  64
04676:  ADDWF  x00,W
04678:  MOVWF  FE9
0467A:  MOVLW  01
0467C:  ADDWFC x01,W
0467E:  MOVWF  FEA
04680:  BSF    FEF.0
....................    }
04682:  BRA    46C8
04684:  MOVLB  6
....................    else {
....................       if (chMap[0] == ch) output_high(INV_HVX);
04686:  MOVLW  00
04688:  MOVLB  0
0468A:  BTFSC  x70.0
0468C:  MOVLW  01
0468E:  MOVLB  6
04690:  SUBWF  xFE,W
04692:  BNZ   469A
04694:  MOVLW  04
04696:  MOVWF  F88
04698:  BSF    F83.4
....................       if (chMap[1] == ch) output_high(INV_HVY);
0469A:  MOVLW  00
0469C:  MOVLB  0
0469E:  BTFSC  x70.1
046A0:  MOVLW  01
046A2:  MOVLB  6
046A4:  SUBWF  xFE,W
046A6:  BNZ   46AE
046A8:  MOVLW  04
046AA:  MOVWF  F88
046AC:  BSF    F83.5
....................       dacVals[ch].invV = FALSE;
046AE:  MOVF   xFE,W
046B0:  MULLW  07
046B2:  MOVF   FF3,W
046B4:  MOVLB  7
046B6:  CLRF   x01
046B8:  MOVWF  x00
046BA:  MOVLW  64
046BC:  ADDWF  x00,W
046BE:  MOVWF  FE9
046C0:  MOVLW  01
046C2:  ADDWFC x01,W
046C4:  MOVWF  FEA
046C6:  BCF    FEF.0
....................    }
046C8:  MOVLB  0
046CA:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  Nano DAC's have a 16bit serial shift register. Data is sync'ed to output */ 
.................... /*****************************************************************************/
.................... void set_nanoDAC_outputs(channelMap ch){
*
04CEA:  MOVLB  6
04CEC:  CLRF   xFD
04CEE:  CLRF   xFC
....................     unsigned int16 txData = 0;
....................    
....................     // use dacVals.opPcnt values if channel is manual mode
....................     // else, use PID control variable
....................     if (chMode[ch] == MANUAL){
04CF0:  MOVFF  6FB,70D
04CF4:  MOVLB  7
04CF6:  CLRF   x0F
04CF8:  MOVLW  71
04CFA:  MOVWF  x0E
04CFC:  MOVLB  0
04CFE:  RCALL  4604
04D00:  MOVF   01,F
04D02:  BNZ   4DF2
....................         if ( dacVals[ch].opPcnt < 0) invert_voltage(ch, TRUE); 
04D04:  MOVLB  6
04D06:  MOVF   xFB,W
04D08:  MULLW  07
04D0A:  MOVF   FF3,W
04D0C:  CLRF   xFF
04D0E:  MOVWF  xFE
04D10:  MOVLW  03
04D12:  ADDWF  xFE,W
04D14:  MOVWF  01
04D16:  MOVLW  00
04D18:  ADDWFC xFF,W
04D1A:  MOVWF  03
04D1C:  MOVF   01,W
04D1E:  ADDLW  64
04D20:  MOVWF  FE9
04D22:  MOVLW  01
04D24:  ADDWFC 03,W
04D26:  MOVWF  FEA
04D28:  MOVFF  FEF,746
04D2C:  MOVFF  FEC,747
04D30:  MOVFF  FEC,748
04D34:  MOVFF  FEC,749
04D38:  MOVLB  7
04D3A:  CLRF   x4D
04D3C:  CLRF   x4C
04D3E:  CLRF   x4B
04D40:  CLRF   x4A
04D42:  MOVLB  0
04D44:  CALL   1D1C
04D48:  BNC   4D5A
04D4A:  MOVFF  6FB,6FE
04D4E:  MOVLW  01
04D50:  MOVLB  6
04D52:  MOVWF  xFF
04D54:  MOVLB  0
04D56:  RCALL  463A
04D58:  BRA    4D66
....................         else                         invert_voltage(ch, FALSE);
04D5A:  MOVFF  6FB,6FE
04D5E:  MOVLB  6
04D60:  CLRF   xFF
04D62:  MOVLB  0
04D64:  RCALL  463A
....................       
....................         txData = (unsigned int16)(abs(dacVals[ch].opPcnt) * DACfullScale);
04D66:  MOVLB  6
04D68:  MOVF   xFB,W
04D6A:  MULLW  07
04D6C:  MOVF   FF3,W
04D6E:  CLRF   xFF
04D70:  MOVWF  xFE
04D72:  MOVLW  03
04D74:  ADDWF  xFE,W
04D76:  MOVWF  01
04D78:  MOVLW  00
04D7A:  ADDWFC xFF,W
04D7C:  MOVWF  03
04D7E:  MOVF   01,W
04D80:  ADDLW  64
04D82:  MOVWF  FE9
04D84:  MOVLW  01
04D86:  ADDWFC 03,W
04D88:  MOVWF  FEA
04D8A:  MOVFF  FEF,00
04D8E:  MOVFF  FEC,01
04D92:  MOVFF  FEC,02
04D96:  MOVFF  FEC,03
04D9A:  BCF    01.7
04D9C:  MOVFF  03,701
04DA0:  MOVFF  02,700
04DA4:  MOVFF  01,6FF
04DA8:  MOVFF  00,6FE
04DAC:  MOVFF  03,753
04DB0:  MOVFF  02,752
04DB4:  MOVFF  01,751
04DB8:  MOVFF  00,750
04DBC:  MOVLW  66
04DBE:  MOVLB  7
04DC0:  MOVWF  x57
04DC2:  MOVLW  D6
04DC4:  MOVWF  x56
04DC6:  MOVLW  23
04DC8:  MOVWF  x55
04DCA:  MOVLW  88
04DCC:  MOVWF  x54
04DCE:  MOVLB  0
04DD0:  CALL   0D90
04DD4:  MOVFF  03,749
04DD8:  MOVFF  02,748
04DDC:  MOVFF  01,747
04DE0:  MOVFF  00,746
04DE4:  CALL   2710
04DE8:  MOVFF  02,6FD
04DEC:  MOVFF  01,6FC
....................     }
04DF0:  BRA    4EE8
....................     else {
....................         pid_task(ch);
04DF2:  MOVFF  6FB,6FE
04DF6:  BRA    4C5E
....................         if ( PID[(int)ch].CV < 0 ) invert_voltage(ch, TRUE); 
04DF8:  MOVLB  6
04DFA:  MOVF   xFB,W
04DFC:  MULLW  28
04DFE:  MOVF   FF3,W
04E00:  CLRF   xFF
04E02:  MOVWF  xFE
04E04:  MOVLW  18
04E06:  ADDWF  xFE,W
04E08:  MOVWF  01
04E0A:  MOVLW  00
04E0C:  ADDWFC xFF,W
04E0E:  MOVWF  03
04E10:  MOVF   01,W
04E12:  ADDLW  20
04E14:  MOVWF  FE9
04E16:  MOVLW  00
04E18:  ADDWFC 03,W
04E1A:  MOVWF  FEA
04E1C:  MOVFF  FEF,746
04E20:  MOVFF  FEC,747
04E24:  MOVFF  FEC,748
04E28:  MOVFF  FEC,749
04E2C:  MOVLB  7
04E2E:  CLRF   x4D
04E30:  CLRF   x4C
04E32:  CLRF   x4B
04E34:  CLRF   x4A
04E36:  MOVLB  0
04E38:  CALL   1D1C
04E3C:  BNC   4E50
04E3E:  MOVFF  6FB,6FE
04E42:  MOVLW  01
04E44:  MOVLB  6
04E46:  MOVWF  xFF
04E48:  MOVLB  0
04E4A:  CALL   463A
04E4E:  BRA    4E5E
....................         else                       invert_voltage(ch, FALSE);
04E50:  MOVFF  6FB,6FE
04E54:  MOVLB  6
04E56:  CLRF   xFF
04E58:  MOVLB  0
04E5A:  CALL   463A
....................       
....................         txData = (unsigned int16)(abs(PID[(int)ch].CV) * DACfullScale);
04E5E:  MOVLB  6
04E60:  MOVF   xFB,W
04E62:  MULLW  28
04E64:  MOVF   FF3,W
04E66:  CLRF   xFF
04E68:  MOVWF  xFE
04E6A:  MOVLW  18
04E6C:  ADDWF  xFE,W
04E6E:  MOVWF  01
04E70:  MOVLW  00
04E72:  ADDWFC xFF,W
04E74:  MOVWF  03
04E76:  MOVF   01,W
04E78:  ADDLW  20
04E7A:  MOVWF  FE9
04E7C:  MOVLW  00
04E7E:  ADDWFC 03,W
04E80:  MOVWF  FEA
04E82:  MOVFF  FEF,00
04E86:  MOVFF  FEC,01
04E8A:  MOVFF  FEC,02
04E8E:  MOVFF  FEC,03
04E92:  BCF    01.7
04E94:  MOVFF  03,701
04E98:  MOVFF  02,700
04E9C:  MOVFF  01,6FF
04EA0:  MOVFF  00,6FE
04EA4:  MOVFF  03,753
04EA8:  MOVFF  02,752
04EAC:  MOVFF  01,751
04EB0:  MOVFF  00,750
04EB4:  MOVLW  66
04EB6:  MOVLB  7
04EB8:  MOVWF  x57
04EBA:  MOVLW  D6
04EBC:  MOVWF  x56
04EBE:  MOVLW  23
04EC0:  MOVWF  x55
04EC2:  MOVLW  88
04EC4:  MOVWF  x54
04EC6:  MOVLB  0
04EC8:  CALL   0D90
04ECC:  MOVFF  03,749
04ED0:  MOVFF  02,748
04ED4:  MOVFF  01,747
04ED8:  MOVFF  00,746
04EDC:  CALL   2710
04EE0:  MOVFF  02,6FD
04EE4:  MOVFF  01,6FC
....................     }
....................    
....................     dacVals[ch].ipVal = txData;
04EE8:  MOVLB  6
04EEA:  MOVF   xFB,W
04EEC:  MULLW  07
04EEE:  MOVF   FF3,W
04EF0:  CLRF   xFF
04EF2:  MOVWF  xFE
04EF4:  MOVLW  01
04EF6:  ADDWF  xFE,W
04EF8:  MOVWF  01
04EFA:  MOVLW  00
04EFC:  ADDWFC xFF,W
04EFE:  MOVWF  03
04F00:  MOVF   01,W
04F02:  ADDLW  64
04F04:  MOVWF  FE9
04F06:  MOVLW  01
04F08:  ADDWFC 03,W
04F0A:  MOVWF  FEA
04F0C:  MOVFF  6FD,FEC
04F10:  MOVF   FED,F
04F12:  MOVFF  6FC,FEF
....................    
....................     // use channel map to decide which outputs channels to update
....................     // strobe _sync low to push data to the outputs
....................     if (chMap[0] == ch) output_high(_SYNC_X);
04F16:  MOVLW  00
04F18:  MOVLB  0
04F1A:  BTFSC  x70.0
04F1C:  MOVLW  01
04F1E:  MOVLB  6
04F20:  SUBWF  xFB,W
04F22:  BNZ   4F2A
04F24:  MOVLW  E8
04F26:  MOVWF  F8B
04F28:  BSF    F86.2
....................     if (chMap[1] == ch) output_high(_SYNC_Y);
04F2A:  MOVLW  00
04F2C:  MOVLB  0
04F2E:  BTFSC  x70.1
04F30:  MOVLW  01
04F32:  MOVLB  6
04F34:  SUBWF  xFB,W
04F36:  BNZ   4F3E
04F38:  MOVLW  E8
04F3A:  MOVWF  F8B
04F3C:  BSF    F86.1
....................    
....................     delay_ms(1);
04F3E:  MOVLW  01
04F40:  MOVLB  7
04F42:  MOVWF  x01
04F44:  MOVLB  0
04F46:  CALL   03D0
....................    
....................     if (chMap[0] == ch) output_low(_SYNC_X);
04F4A:  MOVLW  00
04F4C:  BTFSC  x70.0
04F4E:  MOVLW  01
04F50:  MOVLB  6
04F52:  SUBWF  xFB,W
04F54:  BNZ   4F5C
04F56:  MOVLW  E8
04F58:  MOVWF  F8B
04F5A:  BCF    F86.2
....................     if (chMap[1] == ch) output_low(_SYNC_Y);
04F5C:  MOVLW  00
04F5E:  MOVLB  0
04F60:  BTFSC  x70.1
04F62:  MOVLW  01
04F64:  MOVLB  6
04F66:  SUBWF  xFB,W
04F68:  BNZ   4F70
04F6A:  MOVLW  E8
04F6C:  MOVWF  F8B
04F6E:  BCF    F86.1
....................     delay_ms(1);
04F70:  MOVLW  01
04F72:  MOVLB  7
04F74:  MOVWF  x01
04F76:  MOVLB  0
04F78:  CALL   03D0
....................    
....................     // shift 16 bits of data
....................     spi_xfer(SPI_ctrl, txData, 24);
04F7C:  MOVLB  7
04F7E:  CLRF   x01
04F80:  CLRF   x00
04F82:  MOVFF  6FD,6FF
04F86:  MOVFF  6FC,6FE
04F8A:  MOVLB  0
04F8C:  CALL   0B3A
....................     delay_ms(1);
04F90:  MOVLW  01
04F92:  MOVLB  7
04F94:  MOVWF  x01
04F96:  MOVLB  0
04F98:  CALL   03D0
....................    
....................     if (chMap[0] == ch) output_high(_SYNC_X);
04F9C:  MOVLW  00
04F9E:  BTFSC  x70.0
04FA0:  MOVLW  01
04FA2:  MOVLB  6
04FA4:  SUBWF  xFB,W
04FA6:  BNZ   4FAE
04FA8:  MOVLW  E8
04FAA:  MOVWF  F8B
04FAC:  BSF    F86.2
....................     if (chMap[1] == ch) output_high(_SYNC_Y);
04FAE:  MOVLW  00
04FB0:  MOVLB  0
04FB2:  BTFSC  x70.1
04FB4:  MOVLW  01
04FB6:  MOVLB  6
04FB8:  SUBWF  xFB,W
04FBA:  BNZ   4FC2
04FBC:  MOVLW  E8
04FBE:  MOVWF  F8B
04FC0:  BSF    F86.1
04FC2:  MOVLB  0
04FC4:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  Axis homing routines and helper functions                                */ 
.................... /*****************************************************************************/
.................... void slew_to_upper_bound(channelMap ch){
....................     chMode[ch] = MANUAL;        // set channel to manual
....................     
....................     while (dacVals[ch].opPcnt < op_upper_bound){
....................         dacVals[ch].opPcnt += 10;   // increase output by 10%
....................         set_nanoDAC_outputs(ch);
....................         delay_ms(500);
....................     }
....................     dacVals[ch].opPcnt = op_upper_bound;    // set output to upper bound
....................     set_nanoDAC_outputs(ch);
....................     delay_ms(500);
.................... }
.................... 
.................... void slew_to_lower_bound(channelMap ch){
....................     chMode[ch] = MANUAL;        // set channel to manual
....................     
....................     while (dacVals[ch].opPcnt > op_lower_bound){
....................         dacVals[ch].opPcnt -= 10;   // decrease output by 10%
....................         set_nanoDAC_outputs(ch);
....................         delay_ms(500);
....................     }
....................     dacVals[ch].opPcnt = op_lower_bound;    // set output to lower bound
....................     set_nanoDAC_outputs(ch);
....................     delay_ms(500);
.................... }
.................... 
.................... void home_axis(channelMap ch){
....................     float maxSP = 0;
....................     float minSP = 0;
....................     int loops = 3;
....................     
....................     // Slew up and down a couple times then set output to 0 to settle the piezo
....................     slew_to_upper_bound(ch);
....................     slew_to_lower_bound(ch);
....................     slew_to_upper_bound(ch);
....................     slew_to_lower_bound(ch);
....................     dacVals[ch].opPcnt = 0;
....................     set_nanoDAC_outputs(ch);
....................     delay_ms(500);
....................     
....................     for (int i=0; i<loops; i++){
....................         slew_to_upper_bound(ch);
....................         sensor_monitor_task();
....................         maxSP+=adcVals[ch].pReal;
....................         
....................         slew_to_lower_bound(ch);
....................         sensor_monitor_task();
....................         minSP+=adcVals[ch].pReal;
....................     }
....................     
....................     PID[ch].maxSP = maxSP / (float)loops;
....................     PID[ch].minSP = minSP / (float)loops;
....................     adcVals[ch].pHome = (maxSP+minSP) / ((float)loops*2);
....................     adcVals[ch].homeFlag = False;
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  control task sets up the outputs channels                                */ 
.................... /*****************************************************************************/
.................... void control_task(){
....................    static int state = 0;
....................    
....................    switch (state)
04FC6:  MOVLB  1
04FC8:  MOVF   xEA,W
04FCA:  XORLW  00
04FCC:  MOVLB  0
04FCE:  BZ    4FD6
04FD0:  XORLW  01
04FD2:  BZ    4FE8
04FD4:  BRA    4FF8
....................    {
....................       case 0:
....................          set_nanoDAC_outputs(chX);
04FD6:  MOVLB  6
04FD8:  CLRF   xFB
04FDA:  MOVLB  0
04FDC:  RCALL  4CEA
....................          state = 1;
04FDE:  MOVLW  01
04FE0:  MOVLB  1
04FE2:  MOVWF  xEA
....................       break;
04FE4:  MOVLB  0
04FE6:  BRA    4FF8
....................       case 1:
....................          set_nanoDAC_outputs(chY);
04FE8:  MOVLW  01
04FEA:  MOVLB  6
04FEC:  MOVWF  xFB
04FEE:  MOVLB  0
04FF0:  RCALL  4CEA
....................          state = 0;
04FF2:  MOVLB  1
04FF4:  CLRF   xEA
....................       break;
04FF6:  MOVLB  0
....................    }
04FF8:  GOTO   A75C (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  control task sets up the outputs channels                                */ 
.................... /*****************************************************************************/
.................... void control_init(){
....................    spi_xfer(SPI_ctrl, 0, 24);
*
00B64:  MOVLB  7
00B66:  CLRF   x01
00B68:  CLRF   x00
00B6A:  MOVLB  6
00B6C:  CLRF   xFF
00B6E:  CLRF   xFE
00B70:  MOVLB  0
00B72:  RCALL  0B3A
....................    output_low(_SYNC_X);
00B74:  MOVLW  E8
00B76:  MOVWF  F8B
00B78:  BCF    F86.2
....................    output_low(_SYNC_Y);
00B7A:  MOVWF  F8B
00B7C:  BCF    F86.1
....................    output_high(_SYNC_X);
00B7E:  MOVWF  F8B
00B80:  BSF    F86.2
....................    output_high(_SYNC_Y);
00B82:  MOVWF  F8B
00B84:  BSF    F86.1
00B86:  GOTO   A730 (RETURN)
.................... }
.................... #endif
.................... 
.................... #include <serialport.h>
.................... #ifndef serialPort
.................... #define serialPort
.................... #include <cmdBuffer.h>
.................... #ifndef cmd_buffer
.................... #define cmd_buffer
.................... 
.................... /*****************************************************************************/
.................... /* DIFCS COMMAND BUFFER                                                      */
.................... /* The beginning of a message is signified by an address record. The address */
.................... /* is 4 characters. The first 2 are the hardware identifier (TC - temperature*/
.................... /* controller, DC - difics controller, etc..) The second 2 characters dev-   */
.................... /* ice ID... Valid values are 00 thru 0F. A device ID of FF writes to all    */
.................... /* boards. This might be used to feed angles data to all listeners.          */
.................... /*****************************************************************************/
.................... 
.................... // t,p0,p1,p2,p3,p4,p5,p6
.................... // t is the start character, p0 is the address, p1 is command, p2-6 are params
.................... // these characters used for storing messages
.................... 
.................... #define startChr '~' // start character. Also diagnostic command type
.................... #define diagCmdType startChr
.................... #define endChr '\n'
.................... #define delimiter ','
.................... #define ignoreChr1 '\r'
.................... #define ignoreChr2 ' '
.................... #define noRecordFound (char)0xFF
.................... 
.................... #define numRecords 4
.................... #define numParam 7
.................... #define lenParam 25
.................... 
.................... #define useSerial
.................... //#define useTCPIP
.................... 
.................... typedef enum cmdMode {tcp, ser};
.................... 
.................... // this structure holds a command. This is used by the serial routine as well
.................... // as the TCP routine to store an incoming command + parameters
.................... // in the case of TCP socket id is also passed in this structure
.................... typedef struct cmd 
.................... {
....................    BOOLEAN full;        // if full, command is ready to execute
....................    unsigned int8 chrIndex;
....................    unsigned int8 paramIndex;
....................    unsigned int8 recReadIndex;
....................    unsigned int8 recWriteIndex;
....................    #ifdef useTCPIP
....................    TCP_SOCKET s;              // socket ID for TCP commands 
....................    #endif
....................    char t;
....................    char p[numParam][lenParam];   // only used with ~ type command
.................... };
.................... 
.................... #ifdef useSerial
.................... struct cmd SERcmd[numRecords]; // holds serial command 
.................... unsigned int8 SRI = 0; //usb readindex
.................... unsigned int8 SWI = 0; //usb write index
.................... #endif
.................... 
.................... #ifdef useTCPIP
.................... struct cmd TCPcmd[numRecords]; // holds TCP command
.................... unsigned int8 TRI = 0; //usb readindex
.................... unsigned int8 TWI = 0; //usb write index
.................... #endif
.................... 
.................... char retData[100]; // this is used to hold return data 
.................... 
.................... #ifdef useSerial
.................... /*****************************************************************************/
.................... /* RESET SER COMMAND -- ready for a new command                              */
.................... /*****************************************************************************/
.................... void resetSERcmd(unsigned int8 recNum)
.................... {
....................    if (recNum < numRecords)
00B8A:  MOVLB  7
00B8C:  MOVF   x01,W
00B8E:  SUBLW  03
00B90:  BTFSS  FD8.0
00B92:  BRA    0D00
....................    {
....................       for (int i = 0; i <numParam; i ++)
00B94:  CLRF   x02
00B96:  MOVF   x02,W
00B98:  SUBLW  06
00B9A:  BNC   0BEA
....................       {
....................          SERcmd[recNum].p[i][0] = '\0';
00B9C:  CLRF   x42
00B9E:  MOVFF  701,741
00BA2:  CLRF   x44
00BA4:  MOVLW  B5
00BA6:  MOVWF  x43
00BA8:  MOVLB  0
00BAA:  RCALL  08A6
00BAC:  MOVFF  02,704
00BB0:  MOVFF  01,703
00BB4:  MOVLW  06
00BB6:  MOVLB  7
00BB8:  ADDWF  x03,F
00BBA:  MOVLW  00
00BBC:  ADDWFC x04,F
00BBE:  CLRF   x42
00BC0:  MOVFF  702,741
00BC4:  CLRF   x44
00BC6:  MOVLW  19
00BC8:  MOVWF  x43
00BCA:  MOVLB  0
00BCC:  RCALL  08A6
00BCE:  MOVF   01,W
00BD0:  MOVLB  7
00BD2:  ADDWF  x03,F
00BD4:  MOVF   02,W
00BD6:  ADDWFC x04,F
00BD8:  MOVLW  EB
00BDA:  ADDWF  x03,W
00BDC:  MOVWF  FE9
00BDE:  MOVLW  01
00BE0:  ADDWFC x04,W
00BE2:  MOVWF  FEA
00BE4:  CLRF   FEF
00BE6:  INCF   x02,F
00BE8:  BRA    0B96
....................       }
....................       SERcmd[recNum].t = 0;
00BEA:  CLRF   x42
00BEC:  MOVFF  701,741
00BF0:  CLRF   x44
00BF2:  MOVLW  B5
00BF4:  MOVWF  x43
00BF6:  MOVLB  0
00BF8:  RCALL  08A6
00BFA:  MOVFF  01,703
00BFE:  MOVLW  05
00C00:  MOVLB  7
00C02:  ADDWF  01,W
00C04:  MOVWF  01
00C06:  MOVLW  00
00C08:  ADDWFC 02,W
00C0A:  MOVWF  03
00C0C:  MOVF   01,W
00C0E:  ADDLW  EB
00C10:  MOVWF  FE9
00C12:  MOVLW  01
00C14:  ADDWFC 03,W
00C16:  MOVWF  FEA
00C18:  CLRF   FEF
....................       SERcmd[recNum].chrIndex = 0;
00C1A:  CLRF   x42
00C1C:  MOVFF  701,741
00C20:  CLRF   x44
00C22:  MOVLW  B5
00C24:  MOVWF  x43
00C26:  MOVLB  0
00C28:  RCALL  08A6
00C2A:  MOVFF  01,703
00C2E:  MOVLW  01
00C30:  MOVLB  7
00C32:  ADDWF  01,W
00C34:  MOVWF  01
00C36:  MOVLW  00
00C38:  ADDWFC 02,W
00C3A:  MOVWF  03
00C3C:  MOVF   01,W
00C3E:  ADDLW  EB
00C40:  MOVWF  FE9
00C42:  MOVLW  01
00C44:  ADDWFC 03,W
00C46:  MOVWF  FEA
00C48:  CLRF   FEF
....................       SERcmd[recNum].paramIndex = 0;
00C4A:  CLRF   x42
00C4C:  MOVFF  701,741
00C50:  CLRF   x44
00C52:  MOVLW  B5
00C54:  MOVWF  x43
00C56:  MOVLB  0
00C58:  RCALL  08A6
00C5A:  MOVFF  01,703
00C5E:  MOVLW  02
00C60:  MOVLB  7
00C62:  ADDWF  01,W
00C64:  MOVWF  01
00C66:  MOVLW  00
00C68:  ADDWFC 02,W
00C6A:  MOVWF  03
00C6C:  MOVF   01,W
00C6E:  ADDLW  EB
00C70:  MOVWF  FE9
00C72:  MOVLW  01
00C74:  ADDWFC 03,W
00C76:  MOVWF  FEA
00C78:  CLRF   FEF
....................       SERcmd[recNum].recReadIndex = 0;
00C7A:  CLRF   x42
00C7C:  MOVFF  701,741
00C80:  CLRF   x44
00C82:  MOVLW  B5
00C84:  MOVWF  x43
00C86:  MOVLB  0
00C88:  RCALL  08A6
00C8A:  MOVFF  01,703
00C8E:  MOVLW  03
00C90:  MOVLB  7
00C92:  ADDWF  01,W
00C94:  MOVWF  01
00C96:  MOVLW  00
00C98:  ADDWFC 02,W
00C9A:  MOVWF  03
00C9C:  MOVF   01,W
00C9E:  ADDLW  EB
00CA0:  MOVWF  FE9
00CA2:  MOVLW  01
00CA4:  ADDWFC 03,W
00CA6:  MOVWF  FEA
00CA8:  CLRF   FEF
....................       SERcmd[recNum].recWriteIndex = 0;
00CAA:  CLRF   x42
00CAC:  MOVFF  701,741
00CB0:  CLRF   x44
00CB2:  MOVLW  B5
00CB4:  MOVWF  x43
00CB6:  MOVLB  0
00CB8:  RCALL  08A6
00CBA:  MOVFF  01,703
00CBE:  MOVLW  04
00CC0:  MOVLB  7
00CC2:  ADDWF  01,W
00CC4:  MOVWF  01
00CC6:  MOVLW  00
00CC8:  ADDWFC 02,W
00CCA:  MOVWF  03
00CCC:  MOVF   01,W
00CCE:  ADDLW  EB
00CD0:  MOVWF  FE9
00CD2:  MOVLW  01
00CD4:  ADDWFC 03,W
00CD6:  MOVWF  FEA
00CD8:  CLRF   FEF
....................       SERcmd[recNum].full = FALSE;
00CDA:  CLRF   x42
00CDC:  MOVFF  701,741
00CE0:  CLRF   x44
00CE2:  MOVLW  B5
00CE4:  MOVWF  x43
00CE6:  MOVLB  0
00CE8:  RCALL  08A6
00CEA:  MOVLW  EB
00CEC:  MOVLB  7
00CEE:  ADDWF  01,W
00CF0:  MOVWF  FE9
00CF2:  MOVLW  01
00CF4:  ADDWFC 02,W
00CF6:  MOVWF  FEA
00CF8:  BCF    FEF.0
....................       retData[0] = '\0';
00CFA:  MOVLB  4
00CFC:  CLRF   xC1
00CFE:  MOVLB  7
....................    }
00D00:  MOVLB  0
00D02:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next serial read index (SRI)                                          */
.................... /*****************************************************************************/
.................... BOOLEAN getNextSERReadIndex()
.................... {
....................    while (!SERcmd[SRI].full)
*
05A44:  MOVLB  7
05A46:  CLRF   x42
05A48:  MOVFF  4BF,741
05A4C:  CLRF   x44
05A4E:  MOVLW  B5
05A50:  MOVWF  x43
05A52:  MOVLB  0
05A54:  CALL   08A6
05A58:  MOVFF  02,702
05A5C:  MOVFF  01,701
05A60:  MOVLW  EB
05A62:  MOVLB  7
05A64:  ADDWF  01,W
05A66:  MOVWF  FE9
05A68:  MOVLW  01
05A6A:  ADDWFC 02,W
05A6C:  MOVWF  FEA
05A6E:  BTFSC  FEF.0
05A70:  BRA    5A92
....................    {
....................       if (SRI == SWI) return FALSE;
05A72:  MOVLB  4
05A74:  MOVF   xC0,W
05A76:  SUBWF  xBF,W
05A78:  BNZ   5A80
05A7A:  MOVLW  00
05A7C:  MOVWF  01
05A7E:  BRA    5A98
....................       SRI +=1;
05A80:  MOVLW  01
05A82:  ADDWF  xBF,F
....................       if (SRI >= numRecords) SRI=0;
05A84:  MOVF   xBF,W
05A86:  SUBLW  03
05A88:  BC    5A8C
05A8A:  CLRF   xBF
05A8C:  MOVLB  0
05A8E:  BRA    5A44
05A90:  MOVLB  7
....................    }
....................    return TRUE;
05A92:  MOVLW  01
05A94:  MOVWF  01
05A96:  MOVLB  4
05A98:  MOVLB  0
05A9A:  GOTO   A1EE (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next serial write index (SWI)                                         */
.................... /*****************************************************************************/
.................... void setNextSERWriteIndex()
.................... {
....................    SWI +=1;
*
05034:  MOVLW  01
05036:  MOVLB  4
05038:  ADDWF  xC0,F
....................    if (SWI >= numRecords) SWI=0;
0503A:  MOVF   xC0,W
0503C:  SUBLW  03
0503E:  BC    5042
05040:  CLRF   xC0
05042:  MOVLB  0
05044:  RETURN 0
.................... }
.................... #endif
.................... 
.................... #ifdef useTCPIP
.................... /*****************************************************************************/
.................... /* RESET TCP COMMAND -- ready for a new command                              */
.................... /*****************************************************************************/
.................... void resetTCPcmd(unsigned int8 recNum)
.................... {
....................    if(recNum < numRecords)
....................    {
....................       for (int i = 0; i <numParam; i ++)
....................       {
....................          TCPcmd[recNum].p[i][0] = '\0';
....................       }
....................       TCPcmd[recNum].t = 0;
....................       TCPcmd[recNum].chrIndex = 0;
....................       TCPcmd[recNum].paramIndex = 0;
....................       TCPcmd[recNum].full = FALSE;
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next TCP read index (TRI)                                             */
.................... /*****************************************************************************/
.................... BOOLEAN getNextTCPReadIndex()
.................... {
....................    while (!TCPcmd[TRI].full)
....................    {
....................       if (TRI == TWI) return FALSE;
....................       TRI +=1;
....................       if (TRI >= numRecords) TRI=0;
....................    }
....................    return TRUE;
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next TCP write index (TWI)                                            */
.................... /*****************************************************************************/
.................... void setNextTCPWriteIndex()
.................... {
....................    TWI +=1;
....................    if (TWI >= numRecords) TWI=0;
.................... }
.................... #endif
.................... #endif
.................... 
.................... 
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B7,PIN_B6,PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
....................    output_b(portB_reset);
....................    output_c(portC_reset);
....................    output_d(portD_reset);
....................    output_e(portE_reset);
....................    
....................    port_a_pullups(portA_pullups);
....................    port_b_pullups(portB_pullups);
....................    port_c_pullups(portC_pullups);
....................    port_d_pullups(portD_pullups);
....................    port_e_pullups(portE_pullups);
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... #define use_RS485 // adds RX enable pin//
.................... 
.................... #define oneByteCmdTestValue 128
.................... #define UART_BUFFER_SIZE 60
.................... #define UART_EOT_CHAR1 0x0D //Carriage Return
.................... #define UART_EOT_CHAR2 0x0A //Line Feed
.................... #define UART_SOT_CHAR  '~' // START CHARACTER
.................... #define line_turnaround_char 0xFF
.................... 
.................... #bit UART_TXBuffer_Empty = 0x0FAC.1
.................... 
.................... char UART_BUFFER[UART_BUFFER_SIZE] = {0};
.................... unsigned int8 UART_WR_PTR = 0;
.................... unsigned int8 UART_RD_PTR = 0;
.................... boolean BYTES_AVAILABLE= FALSE;
.................... 
.................... //!#use rs232(ICD, DISABLE_INTS, stream=ICD_STREAM)
.................... #use rs232(ICD, stream=ICD_STREAM)
*
059CC:  MOVFF  FF2,03
059D0:  BCF    FF2.7
059D2:  MOVLW  04
059D4:  MOVWF  F88
059D6:  BCF    F83.7
059D8:  MOVLW  08
059DA:  MOVWF  01
059DC:  BRA    59DE
059DE:  NOP   
059E0:  BSF    01.7
059E2:  BRA    5A04
059E4:  BCF    01.7
059E6:  MOVLB  6
059E8:  RRCF   xFD,F
059EA:  MOVLB  0
059EC:  BTFSC  FD8.0
059EE:  BSF    F83.7
059F0:  BTFSS  FD8.0
059F2:  BCF    F83.7
059F4:  BSF    01.6
059F6:  BRA    5A04
059F8:  BCF    01.6
059FA:  DECFSZ 01,F
059FC:  BRA    59E6
059FE:  BRA    5A00
05A00:  NOP   
05A02:  BSF    F83.7
05A04:  MOVLW  84
05A06:  MOVWF  FE9
05A08:  DECFSZ FE9,F
05A0A:  BRA    5A08
05A0C:  BRA    5A0E
05A0E:  NOP   
05A10:  BTFSC  01.7
05A12:  BRA    59E4
05A14:  BTFSC  01.6
05A16:  BRA    59F8
05A18:  BTFSC  03.7
05A1A:  BSF    FF2.7
05A1C:  RETURN 0
.................... 
.................... #ifdef use_RS485
.................... #use rs232(baud=baudRate, UART1, stream=SERIAL, ERRORS)
*
000EE:  MOVLB  E
000F0:  BTFSS  xC8.5
000F2:  BRA    00F0
000F4:  MOVFF  F9C,563
000F8:  MOVLB  5
000FA:  MOVFF  F98,01
000FE:  BTFSS  x63.1
00100:  BRA    0106
00102:  BCF    F9C.4
00104:  BSF    F9C.4
00106:  MOVLB  0
00108:  GOTO   0148 (RETURN)
.................... //!#use rs232(baud=baudRate, xmit=TX_PIN, rcv=RX_PIN, stream=SERIAL, ERRORS)
.................... #else
.................... #use rs232(baud=baudRate, xmit=TX_PIN, rcv=RX_PIN, stream=SERIAL)
.................... #endif
.................... 
.................... // Message format: [SOT]addr ,cmd, arg1, arg2, arg3[EOT]} 
.................... // arguments are optional
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* SERIAL PRINTOUT                                                           */
.................... /*****************************************************************************/
.................... void serial_out(char* printBuffer){
....................     output_high(TX_ENABLE);
*
0A186:  MOVLW  93
0A188:  MOVWF  F89
0A18A:  BSF    F84.5
....................     delay_us(500);
0A18C:  MOVLW  02
0A18E:  MOVLB  7
0A190:  MOVWF  x03
0A192:  CLRF   19
0A194:  BTFSC  FF2.7
0A196:  BSF    19.7
0A198:  BCF    FF2.7
0A19A:  MOVLW  FA
0A19C:  MOVWF  x72
0A19E:  MOVLB  0
0A1A0:  CALL   00CA
0A1A4:  BTFSC  19.7
0A1A6:  BSF    FF2.7
0A1A8:  MOVLB  7
0A1AA:  DECFSZ x03,F
0A1AC:  BRA    A192
....................     
....................     fprintf(SERIAL, "%s", printBuffer);
0A1AE:  MOVFF  702,FEA
0A1B2:  MOVFF  701,FE9
0A1B6:  MOVLB  0
0A1B8:  CALL   5046
....................     delay_us(500);
0A1BC:  MOVLW  02
0A1BE:  MOVLB  7
0A1C0:  MOVWF  x03
0A1C2:  CLRF   19
0A1C4:  BTFSC  FF2.7
0A1C6:  BSF    19.7
0A1C8:  BCF    FF2.7
0A1CA:  MOVLW  FA
0A1CC:  MOVWF  x72
0A1CE:  MOVLB  0
0A1D0:  CALL   00CA
0A1D4:  BTFSC  19.7
0A1D6:  BSF    FF2.7
0A1D8:  MOVLB  7
0A1DA:  DECFSZ x03,F
0A1DC:  BRA    A1C2
....................     
....................     output_low(TX_ENABLE);
0A1DE:  MOVLW  93
0A1E0:  MOVWF  F89
0A1E2:  BCF    F84.5
0A1E4:  MOVLB  0
0A1E6:  GOTO   A306 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SERIAL PORT ISR                                                           */
.................... /*****************************************************************************/
.................... #INT_RDA
.................... void RX_isr()
*
0010C:  MOVLB  0
.................... {
.................... //!    fprintf(ICD_STREAM, "FOO\n");
....................     output_high(TX_ENABLE);
0010E:  MOVLW  93
00110:  MOVWF  F89
00112:  BSF    F84.5
....................     delay_us(500);
00114:  MOVLW  02
00116:  MOVLB  7
00118:  MOVWF  x71
0011A:  MOVLW  FA
0011C:  MOVWF  x72
0011E:  MOVLB  0
00120:  RCALL  00CA
00122:  MOVLB  7
00124:  DECFSZ x71,F
00126:  BRA    011A
....................     while (kbhit())
00128:  BTFSC  F8D.6
0012A:  BRA    016A
....................     {
.................... //!       UART_BUFFER[UART_WR_PTR]=getch();
....................        UART_BUFFER[UART_WR_PTR]=fgetc(SERIAL);
0012C:  CLRF   03
0012E:  MOVLB  5
00130:  MOVF   x61,W
00132:  ADDLW  25
00134:  MOVWF  FE9
00136:  MOVLW  05
00138:  ADDWFC 03,W
0013A:  MOVWF  FEA
0013C:  MOVFF  FEA,774
00140:  MOVFF  FE9,773
00144:  MOVLB  0
00146:  BRA    00EE
00148:  MOVFF  774,FEA
0014C:  MOVFF  773,FE9
00150:  MOVFF  01,FEF
....................        UART_WR_PTR +=1;
00154:  MOVLW  01
00156:  MOVLB  5
00158:  ADDWF  x61,F
....................        if (UART_WR_PTR>=UART_BUFFER_SIZE) UART_WR_PTR=0;
0015A:  MOVF   x61,W
0015C:  SUBLW  3B
0015E:  BC    0162
00160:  CLRF   x61
....................        BYTES_AVAILABLE=TRUE;
00162:  MOVLB  1
00164:  BSF    x63.1
00166:  MOVLB  7
00168:  BRA    0128
....................     }
0016A:  MOVLB  E
0016C:  BCF    xC8.5
0016E:  MOVLB  0
00170:  GOTO   006E
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get character from buffer                                                 */
.................... /*****************************************************************************/
.................... char getchFromBuffer()
*
04FFC:  CLRF   03
04FFE:  MOVLB  5
05000:  MOVF   x62,W
05002:  ADDLW  25
05004:  MOVWF  FE9
05006:  MOVLW  05
05008:  ADDWFC 03,W
0500A:  MOVWF  FEA
0500C:  MOVFF  FEF,6FC
.................... {
....................    char data = UART_BUFFER[UART_RD_PTR];
....................    UART_RD_PTR +=1;
05010:  MOVLW  01
05012:  ADDWF  x62,F
....................    if (UART_RD_PTR>=UART_BUFFER_SIZE) UART_RD_PTR=0;
05014:  MOVF   x62,W
05016:  SUBLW  3B
05018:  BC    501C
0501A:  CLRF   x62
....................    if (UART_RD_PTR == UART_WR_PTR) BYTES_AVAILABLE=FALSE;
0501C:  MOVF   x61,W
0501E:  SUBWF  x62,W
05020:  BNZ   5028
05022:  MOVLB  1
05024:  BCF    x63.1
05026:  MOVLB  5
....................    return data;
05028:  MOVLB  6
0502A:  MOVFF  6FC,01
0502E:  MOVLB  0
05030:  GOTO   50B2 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Serial Task transfers bytes to command buffer                             */
.................... /*****************************************************************************/
.................... void serial_task()
.................... {
....................    while(BYTES_AVAILABLE && SERcmd[SWI].full==FALSE)
*
05070:  MOVLB  1
05072:  BTFSS  x63.1
05074:  BRA    5582
05076:  MOVLB  7
05078:  CLRF   x42
0507A:  MOVFF  4C0,741
0507E:  CLRF   x44
05080:  MOVLW  B5
05082:  MOVWF  x43
05084:  MOVLB  0
05086:  CALL   08A6
0508A:  MOVFF  02,6FD
0508E:  MOVFF  01,6FC
05092:  MOVLW  EB
05094:  MOVLB  6
05096:  ADDWF  01,W
05098:  MOVWF  01
0509A:  MOVLW  01
0509C:  ADDWFC 02,W
0509E:  MOVWF  03
050A0:  MOVFF  01,FE9
050A4:  MOVWF  FEA
050A6:  BTFSS  FEF.0
050A8:  BRA    50AE
050AA:  MOVLB  1
050AC:  BRA    5582
....................    {  
....................       unsigned int8 rxChar = getchFromBuffer();
050AE:  MOVLB  0
050B0:  BRA    4FFC
050B2:  MOVFF  01,6FB
....................       if (rxChar == ignoreChr1 || rxChar == ignoreChr2)
050B6:  MOVLB  6
050B8:  MOVF   xFB,W
050BA:  SUBLW  0D
050BC:  BZ    50C4
050BE:  MOVF   xFB,W
050C0:  SUBLW  20
050C2:  BNZ   50C6
....................       {
....................       }
050C4:  BRA    557C
....................       else if (rxChar == UART_SOT_CHAR)
050C6:  MOVF   xFB,W
050C8:  SUBLW  7E
050CA:  BNZ   510E
....................       {
....................          resetSERcmd(SWI);
050CC:  MOVFF  4C0,701
050D0:  MOVLB  0
050D2:  CALL   0B8A
....................          SERcmd[SWI].t = rxChar;
050D6:  MOVLB  7
050D8:  CLRF   x42
050DA:  MOVFF  4C0,741
050DE:  CLRF   x44
050E0:  MOVLW  B5
050E2:  MOVWF  x43
050E4:  MOVLB  0
050E6:  CALL   08A6
050EA:  MOVFF  01,6FC
050EE:  MOVLW  05
050F0:  MOVLB  6
050F2:  ADDWF  01,W
050F4:  MOVWF  01
050F6:  MOVLW  00
050F8:  ADDWFC 02,W
050FA:  MOVWF  03
050FC:  MOVF   01,W
050FE:  ADDLW  EB
05100:  MOVWF  FE9
05102:  MOVLW  01
05104:  ADDWFC 03,W
05106:  MOVWF  FEA
05108:  MOVFF  6FB,FEF
....................       }
0510C:  BRA    557C
....................       else if (rxChar >= oneByteCmdTestValue)
0510E:  MOVF   xFB,W
05110:  SUBLW  7F
05112:  BC    5180
....................       {
....................          resetSERcmd(SWI);
05114:  MOVFF  4C0,701
05118:  MOVLB  0
0511A:  CALL   0B8A
....................          SERcmd[SWI].t = rxChar;
0511E:  MOVLB  7
05120:  CLRF   x42
05122:  MOVFF  4C0,741
05126:  CLRF   x44
05128:  MOVLW  B5
0512A:  MOVWF  x43
0512C:  MOVLB  0
0512E:  CALL   08A6
05132:  MOVFF  01,6FC
05136:  MOVLW  05
05138:  MOVLB  6
0513A:  ADDWF  01,W
0513C:  MOVWF  01
0513E:  MOVLW  00
05140:  ADDWFC 02,W
05142:  MOVWF  03
05144:  MOVF   01,W
05146:  ADDLW  EB
05148:  MOVWF  FE9
0514A:  MOVLW  01
0514C:  ADDWFC 03,W
0514E:  MOVWF  FEA
05150:  MOVFF  6FB,FEF
....................          SERcmd[SWI].full = TRUE;
05154:  MOVLB  7
05156:  CLRF   x42
05158:  MOVFF  4C0,741
0515C:  CLRF   x44
0515E:  MOVLW  B5
05160:  MOVWF  x43
05162:  MOVLB  0
05164:  CALL   08A6
05168:  MOVLW  EB
0516A:  MOVLB  6
0516C:  ADDWF  01,W
0516E:  MOVWF  FE9
05170:  MOVLW  01
05172:  ADDWFC 02,W
05174:  MOVWF  FEA
05176:  BSF    FEF.0
....................          setNextSERWriteIndex();
05178:  MOVLB  0
0517A:  RCALL  5034
....................       }
0517C:  BRA    557A
0517E:  MOVLB  6
....................       else if (rxChar == UART_EOT_CHAR2)
05180:  MOVF   xFB,W
05182:  SUBLW  0A
05184:  BTFSS  FD8.2
05186:  BRA    5294
....................       {
....................          SERcmd[SWI].full = TRUE;
05188:  MOVLB  7
0518A:  CLRF   x42
0518C:  MOVFF  4C0,741
05190:  CLRF   x44
05192:  MOVLW  B5
05194:  MOVWF  x43
05196:  MOVLB  0
05198:  CALL   08A6
0519C:  MOVLW  EB
0519E:  MOVLB  6
051A0:  ADDWF  01,W
051A2:  MOVWF  FE9
051A4:  MOVLW  01
051A6:  ADDWFC 02,W
051A8:  MOVWF  FEA
051AA:  BSF    FEF.0
....................          SERcmd[SWI].recWriteIndex = SERcmd[SWI].paramIndex;
051AC:  MOVLB  7
051AE:  CLRF   x42
051B0:  MOVFF  4C0,741
051B4:  CLRF   x44
051B6:  MOVLW  B5
051B8:  MOVWF  x43
051BA:  MOVLB  0
051BC:  CALL   08A6
051C0:  MOVFF  01,6FC
051C4:  MOVLW  04
051C6:  ADDWF  01,W
051C8:  MOVWF  01
051CA:  MOVLW  00
051CC:  ADDWFC 02,W
051CE:  MOVWF  03
051D0:  MOVF   01,W
051D2:  ADDLW  EB
051D4:  MOVWF  01
051D6:  MOVLW  01
051D8:  ADDWFC 03,F
051DA:  MOVFF  01,6FC
051DE:  MOVFF  03,6FD
051E2:  MOVLB  7
051E4:  CLRF   x42
051E6:  MOVFF  4C0,741
051EA:  CLRF   x44
051EC:  MOVLW  B5
051EE:  MOVWF  x43
051F0:  MOVLB  0
051F2:  CALL   08A6
051F6:  MOVFF  01,6FE
051FA:  MOVLW  02
051FC:  MOVLB  6
051FE:  ADDWF  01,W
05200:  MOVWF  01
05202:  MOVLW  00
05204:  ADDWFC 02,W
05206:  MOVWF  03
05208:  MOVF   01,W
0520A:  ADDLW  EB
0520C:  MOVWF  FE9
0520E:  MOVLW  01
05210:  ADDWFC 03,W
05212:  MOVWF  FEA
05214:  MOVFF  FEF,6FE
05218:  MOVFF  6FD,FEA
0521C:  MOVFF  6FC,FE9
05220:  MOVFF  6FE,FEF
....................          SERcmd[SWI].chrIndex = 0;
05224:  MOVLB  7
05226:  CLRF   x42
05228:  MOVFF  4C0,741
0522C:  CLRF   x44
0522E:  MOVLW  B5
05230:  MOVWF  x43
05232:  MOVLB  0
05234:  CALL   08A6
05238:  MOVFF  01,6FC
0523C:  MOVLW  01
0523E:  MOVLB  6
05240:  ADDWF  01,W
05242:  MOVWF  01
05244:  MOVLW  00
05246:  ADDWFC 02,W
05248:  MOVWF  03
0524A:  MOVF   01,W
0524C:  ADDLW  EB
0524E:  MOVWF  FE9
05250:  MOVLW  01
05252:  ADDWFC 03,W
05254:  MOVWF  FEA
05256:  CLRF   FEF
....................          SERcmd[SWI].paramIndex = 0;
05258:  MOVLB  7
0525A:  CLRF   x42
0525C:  MOVFF  4C0,741
05260:  CLRF   x44
05262:  MOVLW  B5
05264:  MOVWF  x43
05266:  MOVLB  0
05268:  CALL   08A6
0526C:  MOVFF  01,6FC
05270:  MOVLW  02
05272:  MOVLB  6
05274:  ADDWF  01,W
05276:  MOVWF  01
05278:  MOVLW  00
0527A:  ADDWFC 02,W
0527C:  MOVWF  03
0527E:  MOVF   01,W
05280:  ADDLW  EB
05282:  MOVWF  FE9
05284:  MOVLW  01
05286:  ADDWFC 03,W
05288:  MOVWF  FEA
0528A:  CLRF   FEF
....................          setNextSERWriteIndex();
0528C:  MOVLB  0
0528E:  RCALL  5034
....................       }
05290:  BRA    557A
05292:  MOVLB  6
....................       else if (rxChar == delimiter)
05294:  MOVF   xFB,W
05296:  SUBLW  2C
05298:  BNZ   535C
....................       {
....................          if (SERcmd[SWI].paramIndex < numParam-1)
0529A:  MOVLB  7
0529C:  CLRF   x42
0529E:  MOVFF  4C0,741
052A2:  CLRF   x44
052A4:  MOVLW  B5
052A6:  MOVWF  x43
052A8:  MOVLB  0
052AA:  CALL   08A6
052AE:  MOVFF  02,6FD
052B2:  MOVFF  01,6FC
052B6:  MOVLW  02
052B8:  MOVLB  6
052BA:  ADDWF  01,W
052BC:  MOVWF  01
052BE:  MOVLW  00
052C0:  ADDWFC 02,W
052C2:  MOVWF  03
052C4:  MOVF   01,W
052C6:  ADDLW  EB
052C8:  MOVWF  FE9
052CA:  MOVLW  01
052CC:  ADDWFC 03,W
052CE:  MOVWF  FEA
052D0:  MOVF   FEF,W
052D2:  SUBLW  05
052D4:  BNC   5344
....................          {
....................             SERcmd[SWI].paramIndex +=1;
052D6:  MOVLB  7
052D8:  CLRF   x42
052DA:  MOVFF  4C0,741
052DE:  CLRF   x44
052E0:  MOVLW  B5
052E2:  MOVWF  x43
052E4:  MOVLB  0
052E6:  CALL   08A6
052EA:  MOVFF  01,6FC
052EE:  MOVLW  02
052F0:  MOVLB  6
052F2:  ADDWF  01,W
052F4:  MOVWF  01
052F6:  MOVLW  00
052F8:  ADDWFC 02,W
052FA:  MOVWF  03
052FC:  MOVF   01,W
052FE:  ADDLW  EB
05300:  MOVWF  FE9
05302:  MOVLW  01
05304:  ADDWFC 03,W
05306:  MOVWF  FEA
05308:  MOVLW  01
0530A:  ADDWF  FEF,W
0530C:  MOVWF  FEF
....................             SERcmd[SWI].chrIndex = 0;
0530E:  MOVLB  7
05310:  CLRF   x42
05312:  MOVFF  4C0,741
05316:  CLRF   x44
05318:  MOVLW  B5
0531A:  MOVWF  x43
0531C:  MOVLB  0
0531E:  CALL   08A6
05322:  MOVFF  01,6FC
05326:  MOVLW  01
05328:  MOVLB  6
0532A:  ADDWF  01,W
0532C:  MOVWF  01
0532E:  MOVLW  00
05330:  ADDWFC 02,W
05332:  MOVWF  03
05334:  MOVF   01,W
05336:  ADDLW  EB
05338:  MOVWF  FE9
0533A:  MOVLW  01
0533C:  ADDWFC 03,W
0533E:  MOVWF  FEA
05340:  CLRF   FEF
....................          }
05342:  BRA    535A
....................          else
....................          {
....................             resetSERcmd(SWI); // exceed number of params... reset capture
05344:  MOVFF  4C0,701
05348:  MOVLB  0
0534A:  CALL   0B8A
....................             fprintf(SERIAL, retData);
0534E:  MOVLW  04
05350:  MOVWF  FEA
05352:  MOVLW  C1
05354:  MOVWF  FE9
05356:  RCALL  5046
05358:  MOVLB  6
....................          }
....................       }
0535A:  BRA    557C
....................       
....................       else
....................       {
....................          if (SERcmd[SWI].chrIndex < lenParam)
0535C:  MOVLB  7
0535E:  CLRF   x42
05360:  MOVFF  4C0,741
05364:  CLRF   x44
05366:  MOVLW  B5
05368:  MOVWF  x43
0536A:  MOVLB  0
0536C:  CALL   08A6
05370:  MOVFF  02,6FD
05374:  MOVFF  01,6FC
05378:  MOVLW  01
0537A:  MOVLB  6
0537C:  ADDWF  01,W
0537E:  MOVWF  01
05380:  MOVLW  00
05382:  ADDWFC 02,W
05384:  MOVWF  03
05386:  MOVF   01,W
05388:  ADDLW  EB
0538A:  MOVWF  FE9
0538C:  MOVLW  01
0538E:  ADDWFC 03,W
05390:  MOVWF  FEA
05392:  MOVF   FEF,W
05394:  SUBLW  18
05396:  BTFSS  FD8.0
05398:  BRA    5566
....................          {
....................             SERcmd[SWI].p[SERcmd[SWI].paramIndex][SERcmd[SWI].chrIndex] = rxChar;
0539A:  MOVLB  7
0539C:  CLRF   x42
0539E:  MOVFF  4C0,741
053A2:  CLRF   x44
053A4:  MOVLW  B5
053A6:  MOVWF  x43
053A8:  MOVLB  0
053AA:  CALL   08A6
053AE:  MOVFF  02,6FD
053B2:  MOVFF  01,6FC
053B6:  MOVLW  06
053B8:  MOVLB  6
053BA:  ADDWF  xFC,F
053BC:  MOVLW  00
053BE:  ADDWFC xFD,F
053C0:  MOVLB  7
053C2:  CLRF   x42
053C4:  MOVFF  4C0,741
053C8:  CLRF   x44
053CA:  MOVLW  B5
053CC:  MOVWF  x43
053CE:  MOVLB  0
053D0:  CALL   08A6
053D4:  MOVFF  02,6FF
053D8:  MOVFF  01,6FE
053DC:  MOVLW  02
053DE:  ADDWF  01,W
053E0:  MOVWF  01
053E2:  MOVLW  00
053E4:  ADDWFC 02,W
053E6:  MOVWF  03
053E8:  MOVF   01,W
053EA:  ADDLW  EB
053EC:  MOVWF  FE9
053EE:  MOVLW  01
053F0:  ADDWFC 03,W
053F2:  MOVWF  FEA
053F4:  MOVLB  7
053F6:  CLRF   x42
053F8:  MOVFF  FEF,741
053FC:  CLRF   x44
053FE:  MOVLW  19
05400:  MOVWF  x43
05402:  MOVLB  0
05404:  CALL   08A6
05408:  MOVFF  02,03
0540C:  MOVF   01,W
0540E:  MOVLB  6
05410:  ADDWF  xFC,F
05412:  MOVF   02,W
05414:  ADDWFC xFD,F
05416:  MOVLB  7
05418:  CLRF   x42
0541A:  MOVFF  4C0,741
0541E:  CLRF   x44
05420:  MOVLW  B5
05422:  MOVWF  x43
05424:  MOVLB  0
05426:  CALL   08A6
0542A:  MOVFF  01,6FE
0542E:  MOVLW  01
05430:  MOVLB  6
05432:  ADDWF  01,W
05434:  MOVWF  01
05436:  MOVLW  00
05438:  ADDWFC 02,W
0543A:  MOVWF  03
0543C:  MOVF   01,W
0543E:  ADDLW  EB
05440:  MOVWF  FE9
05442:  MOVLW  01
05444:  ADDWFC 03,W
05446:  MOVWF  FEA
05448:  MOVF   FEF,W
0544A:  ADDWF  xFC,W
0544C:  MOVWF  01
0544E:  MOVLW  00
05450:  ADDWFC xFD,W
05452:  MOVWF  03
05454:  MOVF   01,W
05456:  ADDLW  EB
05458:  MOVWF  FE9
0545A:  MOVLW  01
0545C:  ADDWFC 03,W
0545E:  MOVWF  FEA
05460:  MOVFF  6FB,FEF
....................             SERcmd[SWI].chrIndex += 1;
05464:  MOVLB  7
05466:  CLRF   x42
05468:  MOVFF  4C0,741
0546C:  CLRF   x44
0546E:  MOVLW  B5
05470:  MOVWF  x43
05472:  MOVLB  0
05474:  CALL   08A6
05478:  MOVFF  01,6FC
0547C:  MOVLW  01
0547E:  MOVLB  6
05480:  ADDWF  01,W
05482:  MOVWF  01
05484:  MOVLW  00
05486:  ADDWFC 02,W
05488:  MOVWF  03
0548A:  MOVF   01,W
0548C:  ADDLW  EB
0548E:  MOVWF  FE9
05490:  MOVLW  01
05492:  ADDWFC 03,W
05494:  MOVWF  FEA
05496:  MOVLW  01
05498:  ADDWF  FEF,W
0549A:  MOVWF  FEF
....................             SERcmd[SWI].p[SERcmd[SWI].paramIndex][SERcmd[SWI].chrIndex] = '\0';
0549C:  MOVLB  7
0549E:  CLRF   x42
054A0:  MOVFF  4C0,741
054A4:  CLRF   x44
054A6:  MOVLW  B5
054A8:  MOVWF  x43
054AA:  MOVLB  0
054AC:  CALL   08A6
054B0:  MOVFF  02,6FD
054B4:  MOVFF  01,6FC
054B8:  MOVLW  06
054BA:  MOVLB  6
054BC:  ADDWF  xFC,F
054BE:  MOVLW  00
054C0:  ADDWFC xFD,F
054C2:  MOVLB  7
054C4:  CLRF   x42
054C6:  MOVFF  4C0,741
054CA:  CLRF   x44
054CC:  MOVLW  B5
054CE:  MOVWF  x43
054D0:  MOVLB  0
054D2:  CALL   08A6
054D6:  MOVFF  02,6FF
054DA:  MOVFF  01,6FE
054DE:  MOVLW  02
054E0:  ADDWF  01,W
054E2:  MOVWF  01
054E4:  MOVLW  00
054E6:  ADDWFC 02,W
054E8:  MOVWF  03
054EA:  MOVF   01,W
054EC:  ADDLW  EB
054EE:  MOVWF  FE9
054F0:  MOVLW  01
054F2:  ADDWFC 03,W
054F4:  MOVWF  FEA
054F6:  MOVLB  7
054F8:  CLRF   x42
054FA:  MOVFF  FEF,741
054FE:  CLRF   x44
05500:  MOVLW  19
05502:  MOVWF  x43
05504:  MOVLB  0
05506:  CALL   08A6
0550A:  MOVFF  02,03
0550E:  MOVF   01,W
05510:  MOVLB  6
05512:  ADDWF  xFC,F
05514:  MOVF   02,W
05516:  ADDWFC xFD,F
05518:  MOVLB  7
0551A:  CLRF   x42
0551C:  MOVFF  4C0,741
05520:  CLRF   x44
05522:  MOVLW  B5
05524:  MOVWF  x43
05526:  MOVLB  0
05528:  CALL   08A6
0552C:  MOVFF  01,6FE
05530:  MOVLW  01
05532:  MOVLB  6
05534:  ADDWF  01,W
05536:  MOVWF  01
05538:  MOVLW  00
0553A:  ADDWFC 02,W
0553C:  MOVWF  03
0553E:  MOVF   01,W
05540:  ADDLW  EB
05542:  MOVWF  FE9
05544:  MOVLW  01
05546:  ADDWFC 03,W
05548:  MOVWF  FEA
0554A:  MOVF   FEF,W
0554C:  ADDWF  xFC,W
0554E:  MOVWF  01
05550:  MOVLW  00
05552:  ADDWFC xFD,W
05554:  MOVWF  03
05556:  MOVF   01,W
05558:  ADDLW  EB
0555A:  MOVWF  FE9
0555C:  MOVLW  01
0555E:  ADDWFC 03,W
05560:  MOVWF  FEA
05562:  CLRF   FEF
....................          }
05564:  BRA    557C
....................          else
....................          {
....................             resetSERcmd(SWI); // exceed number of characters... reset capture
05566:  MOVFF  4C0,701
0556A:  MOVLB  0
0556C:  CALL   0B8A
....................             fprintf(SERIAL, retData);
05570:  MOVLW  04
05572:  MOVWF  FEA
05574:  MOVLW  C1
05576:  MOVWF  FE9
05578:  RCALL  5046
0557A:  MOVLB  6
....................          }
....................       }
0557C:  MOVLB  0
0557E:  BRA    5070
05580:  MOVLB  1
....................    }          
05582:  MOVLB  0
05584:  GOTO   A770 (RETURN)
.................... }
....................            
.................... /*****************************************************************************/
.................... /* serialInit ROUTINE  - Sets up serial port                                 */
.................... /*****************************************************************************/ 
.................... void serial_init()
.................... {
....................    for (int i = 0; i < numRecords; i++) 
*
00D04:  MOVLB  6
00D06:  CLRF   xFB
00D08:  MOVF   xFB,W
00D0A:  SUBLW  03
00D0C:  BNC   0D1C
....................    {
....................       resetSERcmd(i);
00D0E:  MOVFF  6FB,701
00D12:  MOVLB  0
00D14:  RCALL  0B8A
00D16:  MOVLB  6
00D18:  INCF   xFB,F
00D1A:  BRA    0D08
....................    }
....................    enable_interrupts(INT_RDA);
00D1C:  MOVLB  E
00D1E:  BSF    xC0.5
00D20:  MOVLB  0
00D22:  GOTO   A734 (RETURN)
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #include <pid.h>
.................... #ifndef pidcontroller
.................... #define pidcontroller
.................... #include <parameters.h>
.................... #include <math.h>
.................... 
.................... /*****************************************************************************/
.................... /* UPDATE the Control Variable (CV)                                          */
.................... /*****************************************************************************/
.................... void pid_update (channelMap ch){
....................    float err = PID[ch].SP - PID[ch].PV;  // error = set value - measured
....................    
....................    PID[ch].I += err*PID[ch].kI;
....................    if (PID[ch].I > op_upper_bound) PID[ch].I = op_upper_bound; // anti-windup
....................    else if (PID[ch].I < op_lower_bound) PID[ch].I = op_lower_bound;
....................    
....................    float P = err * PID[ch].kP;  // proportional value
....................    
....................    float D = PID[ch].kD * (PID[ch].PV - PID[ch].PVold);  // derivative value
....................    
....................    PID[ch].CV = P + PID[ch].I + D;  // new control variable
....................    if (PID[ch].CV > op_upper_bound) PID[ch].CV = op_upper_bound; // limit positive output
....................    else if (PID[ch].CV < op_lower_bound) PID[ch].CV = op_lower_bound; // limit negative output
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PID Task - looks for change to PV and updates CV                          */
.................... /*****************************************************************************/
.................... void pid_task(channelMap ch){
....................    static int index = 0;
....................    if (PID[ch].SP != PID[ch].PV) pid_update(ch);
....................    if ((index++) >= numChannels) index = 0;
.................... }
.................... 
.................... #endif
.................... 
.................... #include <eventTimer.h>
.................... #ifndef timeout
.................... #define timeout
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................     float kP;      // proportional gain
....................     float kI;      // integral gain
....................     float kD;      // derivative gain
....................     float SP;      // set point-- desired output
....................     float PV;      // process variable-- measured output
....................     float PVold;   // oldPV value  
....................     float CV;      // control variable-- output -- 0 to 100%
....................     float I;       // integral value
....................     float maxSP;   // Max setpoint in microns
....................     float minSP;   // Min setpoint in microns
.................... }PID[2] = {
....................    //  P     I     D
....................    //0.01    0.3   0.1
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}, 
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}
....................     };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... //!#define op_upper_bound 63  // CRYO
.................... //!#define op_lower_bound -63 // CRYO
.................... 
.................... #define op_upper_bound 63  // AMBIENT 
.................... #define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    BOOLEAN homeFlag;       // Flag to trigger the homing routine
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,FALSE},
....................    {0,0,0,0,0,0,0,0,0,0,FALSE}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................     BOOLEAN invV;
....................     unsigned int16 ipVal;
....................     float opPcnt;
....................    
.................... }dacVals[2] = 
.................... {
....................     {FALSE,0,0},
....................     {FALSE,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/           
.................... /* Global timers used by all routnes                                         */
.................... /* timeoutReg0-2 are used for timeouts. Other routines monitor the value of  */
.................... /* intTimeoutReg. On boot, they will be loaded from EEProm. Any              */
.................... /* configuration changes will be changed in EEprom, hence will be restored on*/
.................... /* subsequent boot.                                                          */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* Register definitions                                                      */
.................... /*****************************************************************************/
.................... //!unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... //!unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... //!unsigned int32 timeoutReg2 = 0;
.................... //!unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... unsigned int32 timeCounter = 0;
.................... 
.................... /*****************************************************************************/
.................... /* TIMEOUT_INIT initializes the timer                                        */
.................... /*****************************************************************************/
.................... void event_timer_init()
.................... {        
....................    disable_interrupts(INT_TIMER1);
00D26:  MOVLB  E
00D28:  BCF    xC1.0
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_1);
00D2A:  MOVLW  01
00D2C:  MOVWF  FD1
00D2E:  MOVLW  07
00D30:  MOVWF  FCE
00D32:  CLRF   FCF
00D34:  CLRF   FD0
....................    timeoutReg0 = 0;  // clear all the timers
00D36:  MOVLB  1
00D38:  CLRF   x75
00D3A:  CLRF   x74
00D3C:  CLRF   x73
00D3E:  CLRF   x72
....................    timeoutReg1 = 0;
00D40:  CLRF   x79
00D42:  CLRF   x78
00D44:  CLRF   x77
00D46:  CLRF   x76
....................    timeoutReg2 = 0;
00D48:  CLRF   x7D
00D4A:  CLRF   x7C
00D4C:  CLRF   x7B
00D4E:  CLRF   x7A
.................... //!   intTimeoutReg = 50;
....................    enable_interrupts(INT_TIMER1);
00D50:  MOVLB  E
00D52:  BSF    xC1.0
00D54:  MOVLB  0
00D56:  GOTO   A738 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* TIMEOUT INTERRUPT decrements the timeout registers every second           */
.................... /*****************************************************************************/
.................... #INT_TIMER1
.................... void TIMER1_isr(void) 
*
00298:  MOVLB  0
.................... {
....................    set_timer1(0x0BDB); // load timer register to allow 10 millisecond interupts
0029A:  MOVLW  0B
0029C:  MOVWF  FCD
0029E:  MOVLW  DB
002A0:  MOVWF  FCC
002A2:  NOP   
....................    if (timeoutReg0 > 10) timeoutReg0 -= 10; else timeoutReg0 = 0;
002A4:  MOVLB  1
002A6:  MOVF   x75,F
002A8:  BNZ   02B8
002AA:  MOVF   x74,F
002AC:  BNZ   02B8
002AE:  MOVF   x73,F
002B0:  BNZ   02B8
002B2:  MOVF   x72,W
002B4:  SUBLW  0A
002B6:  BC    02C6
002B8:  MOVLW  0A
002BA:  SUBWF  x72,F
002BC:  MOVLW  00
002BE:  SUBWFB x73,F
002C0:  SUBWFB x74,F
002C2:  SUBWFB x75,F
002C4:  BRA    02CE
002C6:  CLRF   x75
002C8:  CLRF   x74
002CA:  CLRF   x73
002CC:  CLRF   x72
....................    if (timeoutReg1 > 10) timeoutReg1 -= 10; else timeoutReg1 = 0;
002CE:  MOVF   x79,F
002D0:  BNZ   02E0
002D2:  MOVF   x78,F
002D4:  BNZ   02E0
002D6:  MOVF   x77,F
002D8:  BNZ   02E0
002DA:  MOVF   x76,W
002DC:  SUBLW  0A
002DE:  BC    02EE
002E0:  MOVLW  0A
002E2:  SUBWF  x76,F
002E4:  MOVLW  00
002E6:  SUBWFB x77,F
002E8:  SUBWFB x78,F
002EA:  SUBWFB x79,F
002EC:  BRA    02F6
002EE:  CLRF   x79
002F0:  CLRF   x78
002F2:  CLRF   x77
002F4:  CLRF   x76
....................    if (timeoutReg2 > 10) timeoutReg2 -= 10; else timeoutReg2 = 0;
002F6:  MOVF   x7D,F
002F8:  BNZ   0308
002FA:  MOVF   x7C,F
002FC:  BNZ   0308
002FE:  MOVF   x7B,F
00300:  BNZ   0308
00302:  MOVF   x7A,W
00304:  SUBLW  0A
00306:  BC    0316
00308:  MOVLW  0A
0030A:  SUBWF  x7A,F
0030C:  MOVLW  00
0030E:  SUBWFB x7B,F
00310:  SUBWFB x7C,F
00312:  SUBWFB x7D,F
00314:  BRA    031E
00316:  CLRF   x7D
00318:  CLRF   x7C
0031A:  CLRF   x7B
0031C:  CLRF   x7A
....................    if (intTimeoutReg != 0) // INTERRUPTING TIMER
0031E:  MOVF   x7E,F
00320:  BNZ   0326
00322:  MOVF   x7F,F
00324:  BZ    0362
....................    {
....................       timeCounter+=10;
00326:  MOVLW  0A
00328:  MOVLB  5
0032A:  ADDWF  x66,F
0032C:  MOVLW  00
0032E:  ADDWFC x67,F
00330:  ADDWFC x68,F
00332:  ADDWFC x69,F
....................       if (timeCounter >= intTimeoutReg)
00334:  MOVF   x69,F
00336:  BNZ   0352
00338:  MOVF   x68,F
0033A:  BNZ   0352
0033C:  MOVLB  1
0033E:  MOVF   x7F,W
00340:  MOVLB  5
00342:  SUBWF  x67,W
00344:  BNC   0360
00346:  BNZ   0352
00348:  MOVLB  1
0034A:  MOVF   x7E,W
0034C:  MOVLB  5
0034E:  SUBWF  x66,W
00350:  BNC   0360
....................       {
....................          sensor_monitor_interrupt_task();
00352:  MOVLB  0
00354:  BRA    01FC
....................          timeCounter = 0;
00356:  MOVLB  5
00358:  CLRF   x69
0035A:  CLRF   x68
0035C:  CLRF   x67
0035E:  CLRF   x66
00360:  MOVLB  1
....................       }
....................    }
.................... }
.................... 
.................... #endif
.................... 
.................... #include <commandHandler.c>
.................... #ifndef cmdHandlerC
.................... #define cmdHandlerC
.................... #include <commandHandler.h>
.................... #ifndef cmdHandler
.................... #define cmdHandler
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................     float kP;      // proportional gain
....................     float kI;      // integral gain
....................     float kD;      // derivative gain
....................     float SP;      // set point-- desired output
....................     float PV;      // process variable-- measured output
....................     float PVold;   // oldPV value  
....................     float CV;      // control variable-- output -- 0 to 100%
....................     float I;       // integral value
....................     float maxSP;   // Max setpoint in microns
....................     float minSP;   // Min setpoint in microns
.................... }PID[2] = {
....................    //  P     I     D
....................    //0.01    0.3   0.1
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}, 
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}
....................     };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... //!#define op_upper_bound 63  // CRYO
.................... //!#define op_lower_bound -63 // CRYO
.................... 
.................... #define op_upper_bound 63  // AMBIENT 
.................... #define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    BOOLEAN homeFlag;       // Flag to trigger the homing routine
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,FALSE},
....................    {0,0,0,0,0,0,0,0,0,0,FALSE}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................     BOOLEAN invV;
....................     unsigned int16 ipVal;
....................     float opPcnt;
....................    
.................... }dacVals[2] = 
.................... {
....................     {FALSE,0,0},
....................     {FALSE,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... 
00362:  MOVLB  E
00364:  BCF    xC9.0
00366:  MOVLB  0
00368:  GOTO   006E
.................... #define hwID 'D'   // DiFCS
.................... 
.................... /*****************************************************************************/
.................... /* RESPONSE MESSAGES                                                         */
.................... /*****************************************************************************/
.................... typedef struct response {
....................     int8 id;
....................     char *msg;
.................... } resp;
.................... 
.................... //!#define INVALID_DATA "error - invalid data"
.................... //!#define invalidTime "error - invalid TO value"
.................... //!#define overrun "error - buffer overrun"
.................... //!#define dcVoltage "VDC:%f1"
.................... //!#define USBVoltage "VUSB:%f"
.................... //!#define USBupstream "VUSBup:%f"
.................... //!#define plus5V "5V Rail:%f"
.................... //!#define plus3V3 "3V3 Rai:%f"
.................... //!#define allVoltages "All Voltages = %f, %f, %f, %f, %f"
.................... //!#define USBdownstream "USB downstream status:\r\nPG:%s\r\nch0:%s\r\nch1:%s"
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC MESSGAGE DUMP                                                  */
.................... /*****************************************************************************/
.................... //!#define voltageMsg "V0:%f\r\nV1:%f\r\nV2:%f\r\nV3:%f\r\nV4:%f"
.................... //!#define TimerMsg "T0:%Lu\r\nT1:%Lu\r\nT2:%Lu\r\Tint:%Lu\r\nTtick:%Lu"
.................... //!#define ioStatusMsg "Inputs:%u\r\nOutputs:%u\r\nStatus:%u"
.................... //!#define diagnosticMsg "V0:%f\r\nV1:%f\r\nV2:%f\r\nV3:%f\r\nV4:%f\r\nT0:%Lu\r\nT1:%Lu\r\nT2:%Lu\r\nTint:%Lu\r\nTtick:%Lu\r\nInputs:%u\r\nOutputs:%u\r\nStatus:%u"
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC COMMAND PROTOTYPES                                             */
.................... /*****************************************************************************/
.................... int8 getRev(unsigned int8);                 // gr 
.................... int8 getSN(unsigned int8);                  // gs
.................... 
.................... int8 getOPchMap(unsigned int8);             // gChMap,   {1|2}
.................... int8 setOPchMap(unsigned int8);             // sChMap,   {1|2}, {X|Y}
.................... 
.................... int8 getIPchMode(unsigned int8);            // gChMode,  {1|2}
.................... int8 setIPchMode(unsigned int8);            // sChMode,  {1|2}, {MANUAL|MAGSNS}
....................    
.................... int8 getPIDvals(unsigned int8);             // gPID,     {1|2}, {P|I|D}
.................... int8 setPIDvals(unsigned int8);             // sPID,     {1|2}, {P|I|D}, <float>
.................... 
.................... int8 enablePID(unsigned int8);              // enaPID,   {1|2}
.................... int8 disablePID(unsigned int8);             // disPID,   {1|2}
.................... 
.................... int8 getSetPoint(unsigned int8);            // gSP,      {1|2}
.................... int8 setSetPoint(unsigned int8);            // sSP,      {1|2}, <float>
.................... 
.................... int8 getAllSensorCalParams(unsigned int8);  // gSCals,   {1|2}
.................... int8 getSensorCalParam(unsigned int8);      // gSCal,    {1|2}, {0|1|2|3|4|5}
.................... int8 setSensorCalParam(unsigned int8);      // sSCal,    {1|2}, {0|1|2|3|4|5}, <float>
.................... 
.................... int8 getMonitorCalParam(unsigned int8);     // gMCal,    {N15|200|5V6|5VA|3V6X|3V3A|3V3D}
.................... int8 setMonitorCalParam(unsigned int8);     // sMCal,    {N15|200|5V6|5VA|3V6X|3V3A|3V3D}, <float>, <float>
.................... int8 getMonitorValue(unsigned int8);        // gMon,     {N15|200|5V6|5VA|3V6X|3V3A|3V3D|all}
.................... 
.................... int8 getPIDdata(unsigned int8);             // gPIDdata, {1|2}, {PV|CV|PVold|I}
.................... 
.................... int8 getIPdata(unsigned int8);              // gIPdata,  {1|2}, {raw|calib|p0|poles|real}
....................    
.................... int8 getManOPvals(unsigned int8);           // gManOP,   {1|2}  
.................... int8 setManOPvals(unsigned int8);           // sManOP,   {1|2}, <float>  
.................... 
.................... int8 setFilterOn(unsigned int8);            // sFiltOn
.................... int8 setFilterOff(unsigned int8);           // sFiltOff
.................... 
.................... int8 setHomeAxis(unsigned int8);            // sHome,    {1|2}      
....................                                                        
.................... int8 invalidCmd(unsigned int8);
.................... 
.................... struct command {
....................     char *cmd_name;
....................     int8 (*cmd_func)(unsigned int8);
.................... };
.................... 
.................... BOOLEAN arg_is_float(char *);
.................... BOOLEAN is_valid_channel(char *);
.................... int8 hex_to_int(char);
.................... void echo_cmd(unsigned int8 rec);
.................... int8 command_parser(unsigned int8 rec);
.................... void command_handler_task();
.................... 
.................... #endif
.................... 
.................... 
.................... /* LIST OF DIAGNOSTIC COMMAND KEYWORDS AND THEIR FUNCTIONS */
.................... struct command cmd_list[] = {
....................     {"gr",       &getRev},
....................     {"gs",       &getSN},
....................     {"gChMap",   &getOPchMap},
....................     {"sChMap",   &setOPchMap},
....................     {"gChMode",  &getIPchMode},
....................     {"sChMode",  &setIPchMode},
....................     {"gPID",     &getPIDvals},
....................     {"sPID",     &setPIDvals},
....................     {"gSP",      &getSetPoint},
....................     {"sSP",      &setSetPoint},
....................     {"gSCals",   &getAllSensorCalParams},
....................     {"gSCal",    &getSensorCalParam},
....................     {"sSCal",    &setSensorCalParam},
....................     {"gMCal",    &getMonitorCalParam},
....................     {"sMCal",    &setMonitorCalParam},
....................     {"gMon",     &getMonitorValue},
....................     {"gPIDdata", &getPIDdata},
....................     {"gIPdata",  &getIPdata},
....................     {"gManOP",   &getManOPvals},
....................     {"sManOP",   &setManOPvals},
....................     {"sFiltOn",  &setFilterOn},
....................     {"sFiltOff", &setFilterOff},
....................     {"sHome",    &setHomeAxis},
....................     {"\0", &invalidCmd}
.................... };
.................... 
.................... /* LIST OF RESPONSE MESSAGES */
.................... enum resp_e { 
....................    SUCCESS,
....................    INV_CMD,
....................    INV_PARAM 
.................... };
.................... 
.................... resp resp_list[] = {
....................    {SUCCESS, "SUCCESS"},
....................    {INV_CMD, "INVALID COMMAND"},
....................    {INV_PARAM, "INVALID PARAMETER"}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC COMMAND DEFINITIONS                                            */
.................... /*****************************************************************************/
....................                           
.................... int8 getRev(unsigned int8 rec){
....................     sprintf(retData+strlen(retData), "%s,", version);
*
05B94:  MOVLW  04
05B96:  MOVLB  7
05B98:  MOVWF  x42
05B9A:  MOVLW  C1
05B9C:  MOVWF  x41
05B9E:  MOVLB  0
05BA0:  RCALL  5588
05BA2:  MOVFF  02,03
05BA6:  MOVF   01,W
05BA8:  ADDLW  C1
05BAA:  MOVLB  7
05BAC:  MOVWF  x0B
05BAE:  MOVLW  04
05BB0:  ADDWFC 02,W
05BB2:  MOVWF  x0C
05BB4:  MOVFF  FE8,565
05BB8:  MOVFF  70B,564
05BBC:  MOVLW  6C
05BBE:  MOVWF  FF6
05BC0:  MOVLW  03
05BC2:  MOVWF  FF7
05BC4:  MOVLB  0
05BC6:  RCALL  5B74
05BC8:  MOVLW  2C
05BCA:  MOVLB  7
05BCC:  MOVWF  x50
05BCE:  MOVLB  0
05BD0:  RCALL  55C0
....................     return SUCCESS;
05BD2:  MOVLW  00
05BD4:  MOVWF  01
05BD6:  RETURN 0
.................... }
.................... 
.................... int8 getSN(unsigned int8 rec){
....................     sprintf(retData+strlen(retData), "%s,", serialID);
05BD8:  MOVLW  04
05BDA:  MOVLB  7
05BDC:  MOVWF  x42
05BDE:  MOVLW  C1
05BE0:  MOVWF  x41
05BE2:  MOVLB  0
05BE4:  RCALL  5588
05BE6:  MOVFF  02,03
05BEA:  MOVF   01,W
05BEC:  ADDLW  C1
05BEE:  MOVLB  7
05BF0:  MOVWF  x0B
05BF2:  MOVLW  04
05BF4:  ADDWFC 02,W
05BF6:  MOVWF  x0C
05BF8:  MOVFF  FE8,565
05BFC:  MOVFF  70B,564
05C00:  MOVLW  76
05C02:  MOVWF  FF6
05C04:  MOVLW  03
05C06:  MOVWF  FF7
05C08:  MOVLB  0
05C0A:  RCALL  5B74
05C0C:  MOVLW  2C
05C0E:  MOVLB  7
05C10:  MOVWF  x50
05C12:  MOVLB  0
05C14:  RCALL  55C0
....................     return SUCCESS;
05C16:  MOVLW  00
05C18:  MOVWF  01
05C1A:  RETURN 0
.................... }
.................... 
.................... int8 getOPchMap(unsigned int8 rec){
....................     /*** ARG CHECKS ********************/
....................     int8 arg1;
....................    
....................     if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
06128:  MOVLB  7
0612A:  CLRF   x42
0612C:  MOVFF  690,741
06130:  CLRF   x44
06132:  MOVLW  B5
06134:  MOVWF  x43
06136:  MOVLB  0
06138:  CALL   08A6
0613C:  MOVFF  02,70D
06140:  MOVFF  01,70C
06144:  MOVLW  06
06146:  MOVLB  7
06148:  ADDWF  x0C,F
0614A:  MOVLW  00
0614C:  ADDWFC x0D,F
0614E:  MOVLW  32
06150:  ADDWF  x0C,W
06152:  MOVWF  01
06154:  MOVLW  00
06156:  ADDWFC x0D,W
06158:  MOVWF  03
0615A:  MOVF   01,W
0615C:  ADDLW  EB
0615E:  MOVWF  01
06160:  MOVLW  01
06162:  ADDWFC 03,F
06164:  MOVFF  01,70C
06168:  MOVFF  03,70D
0616C:  MOVFF  03,734
06170:  MOVFF  01,733
06174:  MOVLB  0
06176:  RCALL  5C1C
06178:  MOVF   01,F
0617A:  BNZ   6184
0617C:  MOVLW  02
0617E:  MOVWF  01
06180:  BRA    62D2
06182:  BRA    61E0
....................     else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06184:  MOVLB  7
06186:  CLRF   x42
06188:  MOVFF  690,741
0618C:  CLRF   x44
0618E:  MOVLW  B5
06190:  MOVWF  x43
06192:  MOVLB  0
06194:  CALL   08A6
06198:  MOVFF  02,70D
0619C:  MOVFF  01,70C
061A0:  MOVLW  06
061A2:  MOVLB  7
061A4:  ADDWF  x0C,F
061A6:  MOVLW  00
061A8:  ADDWFC x0D,F
061AA:  MOVLW  32
061AC:  ADDWF  x0C,W
061AE:  MOVWF  01
061B0:  MOVLW  00
061B2:  ADDWFC x0D,W
061B4:  MOVWF  03
061B6:  MOVF   01,W
061B8:  ADDLW  EB
061BA:  MOVWF  01
061BC:  MOVLW  01
061BE:  ADDWFC 03,F
061C0:  MOVFF  01,70C
061C4:  MOVFF  03,70D
061C8:  MOVFF  03,734
061CC:  MOVFF  01,733
061D0:  CLRF   x36
061D2:  CLRF   x35
061D4:  MOVLW  0A
061D6:  MOVWF  x37
061D8:  MOVLB  0
061DA:  RCALL  5D0C
061DC:  MOVFF  01,70B
....................    
....................     /*** GET CHANNEL MAP ***************/ 
....................     if      (0 == chMap[arg1-1]) sprintf(retData+strlen(retData), "%d,%c,", arg1, 'X');
061E0:  MOVLW  01
061E2:  MOVLB  7
061E4:  SUBWF  x0B,W
061E6:  MOVWF  x0D
061E8:  CLRF   x0F
061EA:  MOVLW  70
061EC:  MOVWF  x0E
061EE:  MOVLB  0
061F0:  CALL   4604
061F4:  BTFSC  01.0
061F6:  BRA    6254
061F8:  MOVLW  04
061FA:  MOVLB  7
061FC:  MOVWF  x42
061FE:  MOVLW  C1
06200:  MOVWF  x41
06202:  MOVLB  0
06204:  CALL   5588
06208:  MOVFF  02,03
0620C:  MOVF   01,W
0620E:  ADDLW  C1
06210:  MOVLB  7
06212:  MOVWF  x0C
06214:  MOVLW  04
06216:  ADDWFC 02,W
06218:  MOVWF  x0D
0621A:  MOVFF  FE8,565
0621E:  MOVFF  70C,564
06222:  MOVFF  70B,734
06226:  MOVLW  18
06228:  MOVWF  x35
0622A:  MOVLB  0
0622C:  RCALL  6060
0622E:  MOVLW  2C
06230:  MOVLB  7
06232:  MOVWF  x50
06234:  MOVLB  0
06236:  CALL   55C0
0623A:  MOVLW  58
0623C:  MOVLB  7
0623E:  MOVWF  x50
06240:  MOVLB  0
06242:  CALL   55C0
06246:  MOVLW  2C
06248:  MOVLB  7
0624A:  MOVWF  x50
0624C:  MOVLB  0
0624E:  CALL   55C0
06252:  BRA    62CE
....................     else if (1 == chMap[arg1-1]) sprintf(retData+strlen(retData), "%d,%c,", arg1, 'Y');
06254:  MOVLW  01
06256:  MOVLB  7
06258:  SUBWF  x0B,W
0625A:  MOVWF  x0D
0625C:  CLRF   x0F
0625E:  MOVLW  70
06260:  MOVWF  x0E
06262:  MOVLB  0
06264:  CALL   4604
06268:  BTFSS  01.0
0626A:  BRA    62C8
0626C:  MOVLW  04
0626E:  MOVLB  7
06270:  MOVWF  x42
06272:  MOVLW  C1
06274:  MOVWF  x41
06276:  MOVLB  0
06278:  CALL   5588
0627C:  MOVFF  02,03
06280:  MOVF   01,W
06282:  ADDLW  C1
06284:  MOVLB  7
06286:  MOVWF  x0C
06288:  MOVLW  04
0628A:  ADDWFC 02,W
0628C:  MOVWF  x0D
0628E:  MOVFF  FE8,565
06292:  MOVFF  70C,564
06296:  MOVFF  70B,734
0629A:  MOVLW  18
0629C:  MOVWF  x35
0629E:  MOVLB  0
062A0:  RCALL  6060
062A2:  MOVLW  2C
062A4:  MOVLB  7
062A6:  MOVWF  x50
062A8:  MOVLB  0
062AA:  CALL   55C0
062AE:  MOVLW  59
062B0:  MOVLB  7
062B2:  MOVWF  x50
062B4:  MOVLB  0
062B6:  CALL   55C0
062BA:  MOVLW  2C
062BC:  MOVLB  7
062BE:  MOVWF  x50
062C0:  MOVLB  0
062C2:  CALL   55C0
062C6:  BRA    62CE
....................     else return INV_PARAM;
062C8:  MOVLW  02
062CA:  MOVWF  01
062CC:  BRA    62D2
....................    
....................     return SUCCESS;
062CE:  MOVLW  00
062D0:  MOVWF  01
062D2:  RETURN 0
.................... }
.................... 
.................... int8 setOPchMap(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
06316:  MOVLB  7
06318:  CLRF   x42
0631A:  MOVFF  690,741
0631E:  CLRF   x44
06320:  MOVLW  B5
06322:  MOVWF  x43
06324:  MOVLB  0
06326:  CALL   08A6
0632A:  MOVFF  02,70E
0632E:  MOVFF  01,70D
06332:  MOVLW  06
06334:  MOVLB  7
06336:  ADDWF  x0D,F
06338:  MOVLW  00
0633A:  ADDWFC x0E,F
0633C:  MOVLW  32
0633E:  ADDWF  x0D,W
06340:  MOVWF  01
06342:  MOVLW  00
06344:  ADDWFC x0E,W
06346:  MOVWF  03
06348:  MOVF   01,W
0634A:  ADDLW  EB
0634C:  MOVWF  01
0634E:  MOVLW  01
06350:  ADDWFC 03,F
06352:  MOVFF  01,70D
06356:  MOVFF  03,70E
0635A:  MOVFF  03,734
0635E:  MOVFF  01,733
06362:  MOVLB  0
06364:  RCALL  5C1C
06366:  MOVF   01,F
06368:  BNZ   6372
0636A:  MOVLW  02
0636C:  MOVWF  01
0636E:  BRA    64C2
06370:  BRA    63CE
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06372:  MOVLB  7
06374:  CLRF   x42
06376:  MOVFF  690,741
0637A:  CLRF   x44
0637C:  MOVLW  B5
0637E:  MOVWF  x43
06380:  MOVLB  0
06382:  CALL   08A6
06386:  MOVFF  02,70E
0638A:  MOVFF  01,70D
0638E:  MOVLW  06
06390:  MOVLB  7
06392:  ADDWF  x0D,F
06394:  MOVLW  00
06396:  ADDWFC x0E,F
06398:  MOVLW  32
0639A:  ADDWF  x0D,W
0639C:  MOVWF  01
0639E:  MOVLW  00
063A0:  ADDWFC x0E,W
063A2:  MOVWF  03
063A4:  MOVF   01,W
063A6:  ADDLW  EB
063A8:  MOVWF  01
063AA:  MOVLW  01
063AC:  ADDWFC 03,F
063AE:  MOVFF  01,70D
063B2:  MOVFF  03,70E
063B6:  MOVFF  03,734
063BA:  MOVFF  01,733
063BE:  CLRF   x36
063C0:  CLRF   x35
063C2:  MOVLW  0A
063C4:  MOVWF  x37
063C6:  MOVLB  0
063C8:  RCALL  5D0C
063CA:  MOVFF  01,70B
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
063CE:  MOVLB  7
063D0:  CLRF   x42
063D2:  MOVFF  690,741
063D6:  CLRF   x44
063D8:  MOVLW  B5
063DA:  MOVWF  x43
063DC:  MOVLB  0
063DE:  CALL   08A6
063E2:  MOVFF  02,70E
063E6:  MOVFF  01,70D
063EA:  MOVLW  06
063EC:  MOVLB  7
063EE:  ADDWF  x0D,F
063F0:  MOVLW  00
063F2:  ADDWFC x0E,F
063F4:  MOVLW  4B
063F6:  ADDWF  x0D,W
063F8:  MOVWF  01
063FA:  MOVLW  00
063FC:  ADDWFC x0E,W
063FE:  MOVWF  03
06400:  MOVF   01,W
06402:  ADDLW  EB
06404:  MOVWF  01
06406:  MOVLW  01
06408:  ADDWFC 03,F
0640A:  MOVFF  01,70D
0640E:  MOVFF  03,70E
06412:  MOVFF  03,742
06416:  MOVFF  01,741
0641A:  MOVLB  0
0641C:  CALL   5588
06420:  MOVFF  02,03
06424:  MOVF   01,W
06426:  SUBLW  01
06428:  BNZ   642E
0642A:  MOVF   03,F
0642C:  BZ    6436
0642E:  MOVLW  02
06430:  MOVWF  01
06432:  BRA    64C2
06434:  BRA    6476
....................    else arg2 = SERcmd[rec].p[3][0];
06436:  MOVLB  7
06438:  CLRF   x42
0643A:  MOVFF  690,741
0643E:  CLRF   x44
06440:  MOVLW  B5
06442:  MOVWF  x43
06444:  MOVLB  0
06446:  CALL   08A6
0644A:  MOVFF  02,70E
0644E:  MOVFF  01,70D
06452:  MOVLW  06
06454:  MOVLB  7
06456:  ADDWF  x0D,F
06458:  MOVLW  00
0645A:  ADDWFC x0E,F
0645C:  MOVLW  4B
0645E:  ADDWF  x0D,F
06460:  MOVLW  00
06462:  ADDWFC x0E,F
06464:  MOVLW  EB
06466:  ADDWF  x0D,W
06468:  MOVWF  FE9
0646A:  MOVLW  01
0646C:  ADDWFC x0E,W
0646E:  MOVWF  FEA
06470:  MOVFF  FEF,70C
06474:  MOVLB  0
....................    
....................    /*** SET CHANNEL MAP ***************/
....................    if      ('X' == arg2) chMap[arg1-1] = chX;
06476:  MOVLB  7
06478:  MOVF   x0C,W
0647A:  SUBLW  58
0647C:  BNZ   6496
0647E:  MOVLW  01
06480:  SUBWF  x0B,W
06482:  MOVWF  x0D
06484:  MOVWF  x22
06486:  CLRF   x23
06488:  CLRF   x25
0648A:  MOVLW  70
0648C:  MOVWF  x24
0648E:  MOVLB  0
06490:  RCALL  62D4
06492:  BRA    64BE
06494:  MOVLB  7
....................    else if ('Y' == arg2) chMap[arg1-1] = chY;
06496:  MOVF   x0C,W
06498:  SUBLW  59
0649A:  BNZ   64B6
0649C:  MOVLW  01
0649E:  SUBWF  x0B,W
064A0:  MOVWF  x0D
064A2:  MOVWF  x22
064A4:  MOVLW  01
064A6:  MOVWF  x23
064A8:  CLRF   x25
064AA:  MOVLW  70
064AC:  MOVWF  x24
064AE:  MOVLB  0
064B0:  RCALL  62D4
064B2:  BRA    64BE
064B4:  MOVLB  7
....................    else return INV_PARAM;
064B6:  MOVLW  02
064B8:  MOVWF  01
064BA:  MOVLB  0
064BC:  BRA    64C2
....................    
....................    return SUCCESS;
064BE:  MOVLW  00
064C0:  MOVWF  01
064C2:  RETURN 0
.................... }
.................... 
.................... int8 getIPchMode(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
064C4:  MOVLB  7
064C6:  CLRF   x42
064C8:  MOVFF  690,741
064CC:  CLRF   x44
064CE:  MOVLW  B5
064D0:  MOVWF  x43
064D2:  MOVLB  0
064D4:  CALL   08A6
064D8:  MOVFF  02,70D
064DC:  MOVFF  01,70C
064E0:  MOVLW  06
064E2:  MOVLB  7
064E4:  ADDWF  x0C,F
064E6:  MOVLW  00
064E8:  ADDWFC x0D,F
064EA:  MOVLW  32
064EC:  ADDWF  x0C,W
064EE:  MOVWF  01
064F0:  MOVLW  00
064F2:  ADDWFC x0D,W
064F4:  MOVWF  03
064F6:  MOVF   01,W
064F8:  ADDLW  EB
064FA:  MOVWF  01
064FC:  MOVLW  01
064FE:  ADDWFC 03,F
06500:  MOVFF  01,70C
06504:  MOVFF  03,70D
06508:  MOVFF  03,734
0650C:  MOVFF  01,733
06510:  MOVLB  0
06512:  CALL   5C1C
06516:  MOVF   01,F
06518:  BNZ   6522
0651A:  MOVLW  02
0651C:  MOVWF  01
0651E:  BRA    6652
06520:  BRA    6580
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06522:  MOVLB  7
06524:  CLRF   x42
06526:  MOVFF  690,741
0652A:  CLRF   x44
0652C:  MOVLW  B5
0652E:  MOVWF  x43
06530:  MOVLB  0
06532:  CALL   08A6
06536:  MOVFF  02,70D
0653A:  MOVFF  01,70C
0653E:  MOVLW  06
06540:  MOVLB  7
06542:  ADDWF  x0C,F
06544:  MOVLW  00
06546:  ADDWFC x0D,F
06548:  MOVLW  32
0654A:  ADDWF  x0C,W
0654C:  MOVWF  01
0654E:  MOVLW  00
06550:  ADDWFC x0D,W
06552:  MOVWF  03
06554:  MOVF   01,W
06556:  ADDLW  EB
06558:  MOVWF  01
0655A:  MOVLW  01
0655C:  ADDWFC 03,F
0655E:  MOVFF  01,70C
06562:  MOVFF  03,70D
06566:  MOVFF  03,734
0656A:  MOVFF  01,733
0656E:  CLRF   x36
06570:  CLRF   x35
06572:  MOVLW  0A
06574:  MOVWF  x37
06576:  MOVLB  0
06578:  CALL   5D0C
0657C:  MOVFF  01,70B
....................    
....................    /*** GET INPUT MAP *****************/
....................    if      (0 == chMode[arg1-1]) sprintf(retData+strlen(retData), "%d,MANUAL,", arg1);
06580:  MOVLW  01
06582:  MOVLB  7
06584:  SUBWF  x0B,W
06586:  MOVWF  x0D
06588:  CLRF   x0F
0658A:  MOVLW  71
0658C:  MOVWF  x0E
0658E:  MOVLB  0
06590:  CALL   4604
06594:  BTFSC  01.0
06596:  BRA    65E4
06598:  MOVLW  04
0659A:  MOVLB  7
0659C:  MOVWF  x42
0659E:  MOVLW  C1
065A0:  MOVWF  x41
065A2:  MOVLB  0
065A4:  CALL   5588
065A8:  MOVFF  02,03
065AC:  MOVF   01,W
065AE:  ADDLW  C1
065B0:  MOVLB  7
065B2:  MOVWF  x0C
065B4:  MOVLW  04
065B6:  ADDWFC 02,W
065B8:  MOVWF  x0D
065BA:  MOVFF  FE8,565
065BE:  MOVFF  70C,564
065C2:  MOVFF  70B,734
065C6:  MOVLW  18
065C8:  MOVWF  x35
065CA:  MOVLB  0
065CC:  RCALL  6060
065CE:  MOVLW  7E
065D0:  MOVWF  FF6
065D2:  MOVLW  03
065D4:  MOVWF  FF7
065D6:  MOVLW  08
065D8:  MOVLB  7
065DA:  MOVWF  x0F
065DC:  MOVLB  0
065DE:  CALL   55E0
065E2:  BRA    664E
....................    else if (1 == chMode[arg1-1]) sprintf(retData+strlen(retData), "%d,MAGSNS,", arg1);
065E4:  MOVLW  01
065E6:  MOVLB  7
065E8:  SUBWF  x0B,W
065EA:  MOVWF  x0D
065EC:  CLRF   x0F
065EE:  MOVLW  71
065F0:  MOVWF  x0E
065F2:  MOVLB  0
065F4:  CALL   4604
065F8:  BTFSS  01.0
065FA:  BRA    6648
065FC:  MOVLW  04
065FE:  MOVLB  7
06600:  MOVWF  x42
06602:  MOVLW  C1
06604:  MOVWF  x41
06606:  MOVLB  0
06608:  CALL   5588
0660C:  MOVFF  02,03
06610:  MOVF   01,W
06612:  ADDLW  C1
06614:  MOVLB  7
06616:  MOVWF  x0C
06618:  MOVLW  04
0661A:  ADDWFC 02,W
0661C:  MOVWF  x0D
0661E:  MOVFF  FE8,565
06622:  MOVFF  70C,564
06626:  MOVFF  70B,734
0662A:  MOVLW  18
0662C:  MOVWF  x35
0662E:  MOVLB  0
06630:  RCALL  6060
06632:  MOVLW  8A
06634:  MOVWF  FF6
06636:  MOVLW  03
06638:  MOVWF  FF7
0663A:  MOVLW  08
0663C:  MOVLB  7
0663E:  MOVWF  x0F
06640:  MOVLB  0
06642:  CALL   55E0
06646:  BRA    664E
....................    else return INV_PARAM;
06648:  MOVLW  02
0664A:  MOVWF  01
0664C:  BRA    6652
....................    
....................    return SUCCESS;
0664E:  MOVLW  00
06650:  MOVWF  01
06652:  RETURN 0
.................... }
.................... 
.................... int8 setIPchMode(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char *arg2;
....................    char *s_manual = "MANUAL";
06654:  MOVLW  4D
06656:  MOVLB  7
06658:  MOVWF  x10
0665A:  MOVLW  41
0665C:  MOVWF  x11
0665E:  MOVLW  4E
06660:  MOVWF  x12
06662:  MOVLW  55
06664:  MOVWF  x13
06666:  MOVLW  41
06668:  MOVWF  x14
0666A:  MOVLW  4C
0666C:  MOVWF  x15
0666E:  CLRF   x16
06670:  MOVLW  07
06672:  MOVWF  x0F
06674:  MOVLW  10
06676:  MOVWF  x0E
....................    char *s_magsns = "MAGSNS";
06678:  MOVLW  4D
0667A:  MOVWF  x19
0667C:  MOVLW  41
0667E:  MOVWF  x1A
06680:  MOVLW  47
06682:  MOVWF  x1B
06684:  MOVLW  53
06686:  MOVWF  x1C
06688:  MOVLW  4E
0668A:  MOVWF  x1D
0668C:  MOVLW  53
0668E:  MOVWF  x1E
06690:  CLRF   x1F
06692:  MOVLW  07
06694:  MOVWF  x18
06696:  MOVLW  19
06698:  MOVWF  x17
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0669A:  CLRF   x42
0669C:  MOVFF  690,741
066A0:  CLRF   x44
066A2:  MOVLW  B5
066A4:  MOVWF  x43
066A6:  MOVLB  0
066A8:  CALL   08A6
066AC:  MOVFF  02,721
066B0:  MOVFF  01,720
066B4:  MOVLW  06
066B6:  MOVLB  7
066B8:  ADDWF  x20,F
066BA:  MOVLW  00
066BC:  ADDWFC x21,F
066BE:  MOVLW  32
066C0:  ADDWF  x20,W
066C2:  MOVWF  01
066C4:  MOVLW  00
066C6:  ADDWFC x21,W
066C8:  MOVWF  03
066CA:  MOVF   01,W
066CC:  ADDLW  EB
066CE:  MOVWF  01
066D0:  MOVLW  01
066D2:  ADDWFC 03,F
066D4:  MOVFF  01,720
066D8:  MOVFF  03,721
066DC:  MOVFF  03,734
066E0:  MOVFF  01,733
066E4:  MOVLB  0
066E6:  CALL   5C1C
066EA:  MOVF   01,F
066EC:  BNZ   66F6
066EE:  MOVLW  02
066F0:  MOVWF  01
066F2:  BRA    686C
066F4:  BRA    6754
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
066F6:  MOVLB  7
066F8:  CLRF   x42
066FA:  MOVFF  690,741
066FE:  CLRF   x44
06700:  MOVLW  B5
06702:  MOVWF  x43
06704:  MOVLB  0
06706:  CALL   08A6
0670A:  MOVFF  02,721
0670E:  MOVFF  01,720
06712:  MOVLW  06
06714:  MOVLB  7
06716:  ADDWF  x20,F
06718:  MOVLW  00
0671A:  ADDWFC x21,F
0671C:  MOVLW  32
0671E:  ADDWF  x20,W
06720:  MOVWF  01
06722:  MOVLW  00
06724:  ADDWFC x21,W
06726:  MOVWF  03
06728:  MOVF   01,W
0672A:  ADDLW  EB
0672C:  MOVWF  01
0672E:  MOVLW  01
06730:  ADDWFC 03,F
06732:  MOVFF  01,720
06736:  MOVFF  03,721
0673A:  MOVFF  03,734
0673E:  MOVFF  01,733
06742:  CLRF   x36
06744:  CLRF   x35
06746:  MOVLW  0A
06748:  MOVWF  x37
0674A:  MOVLB  0
0674C:  CALL   5D0C
06750:  MOVFF  01,70B
....................    
....................    if (0 == strlen(SERcmd[rec].p[3])) return INV_PARAM;
06754:  MOVLB  7
06756:  CLRF   x42
06758:  MOVFF  690,741
0675C:  CLRF   x44
0675E:  MOVLW  B5
06760:  MOVWF  x43
06762:  MOVLB  0
06764:  CALL   08A6
06768:  MOVFF  02,721
0676C:  MOVFF  01,720
06770:  MOVLW  06
06772:  MOVLB  7
06774:  ADDWF  x20,F
06776:  MOVLW  00
06778:  ADDWFC x21,F
0677A:  MOVLW  4B
0677C:  ADDWF  x20,W
0677E:  MOVWF  01
06780:  MOVLW  00
06782:  ADDWFC x21,W
06784:  MOVWF  03
06786:  MOVF   01,W
06788:  ADDLW  EB
0678A:  MOVWF  01
0678C:  MOVLW  01
0678E:  ADDWFC 03,F
06790:  MOVFF  01,720
06794:  MOVFF  03,721
06798:  MOVFF  03,742
0679C:  MOVFF  01,741
067A0:  MOVLB  0
067A2:  CALL   5588
067A6:  MOVFF  02,03
067AA:  MOVF   01,W
067AC:  BNZ   67BA
067AE:  MOVF   03,F
067B0:  BNZ   67BA
067B2:  MOVLW  02
067B4:  MOVWF  01
067B6:  BRA    686C
067B8:  BRA    6800
....................    else arg2 = SERcmd[rec].p[3];
067BA:  MOVLB  7
067BC:  CLRF   x42
067BE:  MOVFF  690,741
067C2:  CLRF   x44
067C4:  MOVLW  B5
067C6:  MOVWF  x43
067C8:  MOVLB  0
067CA:  CALL   08A6
067CE:  MOVFF  02,721
067D2:  MOVFF  01,720
067D6:  MOVLW  06
067D8:  MOVLB  7
067DA:  ADDWF  x20,F
067DC:  MOVLW  00
067DE:  ADDWFC x21,F
067E0:  MOVLW  4B
067E2:  ADDWF  x20,W
067E4:  MOVWF  01
067E6:  MOVLW  00
067E8:  ADDWFC x21,W
067EA:  MOVWF  03
067EC:  MOVF   01,W
067EE:  ADDLW  EB
067F0:  MOVWF  01
067F2:  MOVLW  01
067F4:  ADDWFC 03,F
067F6:  MOVFF  01,70C
067FA:  MOVFF  03,70D
067FE:  MOVLB  0
....................    
....................    /*** SET INPUT MAP *****************/
....................    if      (0 == strcmp(s_manual, arg2)) chMode[arg1-1] = MANUAL;
06800:  MOVFF  70F,742
06804:  MOVFF  70E,741
06808:  MOVFF  70D,744
0680C:  MOVFF  70C,743
06810:  CALL   5AFC
06814:  MOVF   01,F
06816:  BNZ   6830
06818:  MOVLW  01
0681A:  MOVLB  7
0681C:  SUBWF  x0B,W
0681E:  MOVWF  x20
06820:  MOVWF  x22
06822:  CLRF   x23
06824:  CLRF   x25
06826:  MOVLW  71
06828:  MOVWF  x24
0682A:  MOVLB  0
0682C:  RCALL  62D4
0682E:  BRA    6868
....................    else if (0 == strcmp(s_magsns, arg2)) chMode[arg1-1] = MAGSNS;
06830:  MOVFF  718,742
06834:  MOVFF  717,741
06838:  MOVFF  70D,744
0683C:  MOVFF  70C,743
06840:  CALL   5AFC
06844:  MOVF   01,F
06846:  BNZ   6862
06848:  MOVLW  01
0684A:  MOVLB  7
0684C:  SUBWF  x0B,W
0684E:  MOVWF  x20
06850:  MOVWF  x22
06852:  MOVLW  01
06854:  MOVWF  x23
06856:  CLRF   x25
06858:  MOVLW  71
0685A:  MOVWF  x24
0685C:  MOVLB  0
0685E:  RCALL  62D4
06860:  BRA    6868
....................    else return INV_PARAM;
06862:  MOVLW  02
06864:  MOVWF  01
06866:  BRA    686C
....................    
....................    return SUCCESS;
06868:  MOVLW  00
0686A:  MOVWF  01
0686C:  RETURN 0
.................... }
.................... 
.................... int8 getPIDvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/ 
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0686E:  MOVLB  7
06870:  CLRF   x42
06872:  MOVFF  690,741
06876:  CLRF   x44
06878:  MOVLW  B5
0687A:  MOVWF  x43
0687C:  MOVLB  0
0687E:  CALL   08A6
06882:  MOVFF  02,70E
06886:  MOVFF  01,70D
0688A:  MOVLW  06
0688C:  MOVLB  7
0688E:  ADDWF  x0D,F
06890:  MOVLW  00
06892:  ADDWFC x0E,F
06894:  MOVLW  32
06896:  ADDWF  x0D,W
06898:  MOVWF  01
0689A:  MOVLW  00
0689C:  ADDWFC x0E,W
0689E:  MOVWF  03
068A0:  MOVF   01,W
068A2:  ADDLW  EB
068A4:  MOVWF  01
068A6:  MOVLW  01
068A8:  ADDWFC 03,F
068AA:  MOVFF  01,70D
068AE:  MOVFF  03,70E
068B2:  MOVFF  03,734
068B6:  MOVFF  01,733
068BA:  MOVLB  0
068BC:  CALL   5C1C
068C0:  MOVF   01,F
068C2:  BNZ   68CC
068C4:  MOVLW  02
068C6:  MOVWF  01
068C8:  BRA    6D2E
068CA:  BRA    692A
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
068CC:  MOVLB  7
068CE:  CLRF   x42
068D0:  MOVFF  690,741
068D4:  CLRF   x44
068D6:  MOVLW  B5
068D8:  MOVWF  x43
068DA:  MOVLB  0
068DC:  CALL   08A6
068E0:  MOVFF  02,70E
068E4:  MOVFF  01,70D
068E8:  MOVLW  06
068EA:  MOVLB  7
068EC:  ADDWF  x0D,F
068EE:  MOVLW  00
068F0:  ADDWFC x0E,F
068F2:  MOVLW  32
068F4:  ADDWF  x0D,W
068F6:  MOVWF  01
068F8:  MOVLW  00
068FA:  ADDWFC x0E,W
068FC:  MOVWF  03
068FE:  MOVF   01,W
06900:  ADDLW  EB
06902:  MOVWF  01
06904:  MOVLW  01
06906:  ADDWFC 03,F
06908:  MOVFF  01,70D
0690C:  MOVFF  03,70E
06910:  MOVFF  03,734
06914:  MOVFF  01,733
06918:  CLRF   x36
0691A:  CLRF   x35
0691C:  MOVLW  0A
0691E:  MOVWF  x37
06920:  MOVLB  0
06922:  CALL   5D0C
06926:  MOVFF  01,70B
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
0692A:  MOVLB  7
0692C:  CLRF   x42
0692E:  MOVFF  690,741
06932:  CLRF   x44
06934:  MOVLW  B5
06936:  MOVWF  x43
06938:  MOVLB  0
0693A:  CALL   08A6
0693E:  MOVFF  02,70E
06942:  MOVFF  01,70D
06946:  MOVLW  06
06948:  MOVLB  7
0694A:  ADDWF  x0D,F
0694C:  MOVLW  00
0694E:  ADDWFC x0E,F
06950:  MOVLW  4B
06952:  ADDWF  x0D,W
06954:  MOVWF  01
06956:  MOVLW  00
06958:  ADDWFC x0E,W
0695A:  MOVWF  03
0695C:  MOVF   01,W
0695E:  ADDLW  EB
06960:  MOVWF  01
06962:  MOVLW  01
06964:  ADDWFC 03,F
06966:  MOVFF  01,70D
0696A:  MOVFF  03,70E
0696E:  MOVFF  03,742
06972:  MOVFF  01,741
06976:  MOVLB  0
06978:  CALL   5588
0697C:  MOVFF  02,03
06980:  MOVF   01,W
06982:  SUBLW  01
06984:  BNZ   698A
06986:  MOVF   03,F
06988:  BZ    6992
0698A:  MOVLW  02
0698C:  MOVWF  01
0698E:  BRA    6D2E
06990:  BRA    69D2
....................    else arg2 = SERcmd[rec].p[3][0];
06992:  MOVLB  7
06994:  CLRF   x42
06996:  MOVFF  690,741
0699A:  CLRF   x44
0699C:  MOVLW  B5
0699E:  MOVWF  x43
069A0:  MOVLB  0
069A2:  CALL   08A6
069A6:  MOVFF  02,70E
069AA:  MOVFF  01,70D
069AE:  MOVLW  06
069B0:  MOVLB  7
069B2:  ADDWF  x0D,F
069B4:  MOVLW  00
069B6:  ADDWFC x0E,F
069B8:  MOVLW  4B
069BA:  ADDWF  x0D,F
069BC:  MOVLW  00
069BE:  ADDWFC x0E,F
069C0:  MOVLW  EB
069C2:  ADDWF  x0D,W
069C4:  MOVWF  FE9
069C6:  MOVLW  01
069C8:  ADDWFC x0E,W
069CA:  MOVWF  FEA
069CC:  MOVFF  FEF,70C
069D0:  MOVLB  0
....................    
....................    /*** GET P, I, D, or A(LL) VALUE **********/
....................    if      ('P' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kP);
069D2:  MOVLB  7
069D4:  MOVF   x0C,W
069D6:  SUBLW  50
069D8:  BNZ   6A74
069DA:  MOVLW  04
069DC:  MOVWF  x42
069DE:  MOVLW  C1
069E0:  MOVWF  x41
069E2:  MOVLB  0
069E4:  CALL   5588
069E8:  MOVFF  02,03
069EC:  MOVF   01,W
069EE:  ADDLW  C1
069F0:  MOVLB  7
069F2:  MOVWF  x0D
069F4:  MOVLW  04
069F6:  ADDWFC 02,W
069F8:  MOVWF  x0E
069FA:  MOVLW  01
069FC:  SUBWF  x0B,W
069FE:  MULLW  28
06A00:  MOVF   FF3,W
06A02:  CLRF   x10
06A04:  MOVWF  x0F
06A06:  MOVLW  20
06A08:  ADDWF  x0F,W
06A0A:  MOVWF  FE9
06A0C:  MOVLW  00
06A0E:  ADDWFC x10,W
06A10:  MOVWF  FEA
06A12:  MOVFF  FEF,711
06A16:  MOVFF  FEC,712
06A1A:  MOVFF  FEC,713
06A1E:  MOVFF  FEC,714
06A22:  MOVFF  70E,565
06A26:  MOVFF  70D,564
06A2A:  MOVFF  70B,734
06A2E:  MOVLW  18
06A30:  MOVWF  x35
06A32:  MOVLB  0
06A34:  CALL   6060
06A38:  MOVLW  2C
06A3A:  MOVLB  7
06A3C:  MOVWF  x50
06A3E:  MOVLB  0
06A40:  CALL   55C0
06A44:  MOVLW  89
06A46:  MOVWF  FE9
06A48:  MOVFF  714,746
06A4C:  MOVFF  713,745
06A50:  MOVFF  712,744
06A54:  MOVFF  711,743
06A58:  MOVLW  02
06A5A:  MOVLB  7
06A5C:  MOVWF  x47
06A5E:  MOVLB  0
06A60:  CALL   575E
06A64:  MOVLW  2C
06A66:  MOVLB  7
06A68:  MOVWF  x50
06A6A:  MOVLB  0
06A6C:  CALL   55C0
06A70:  BRA    6D2A
06A72:  MOVLB  7
....................    else if ('I' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kI);
06A74:  MOVF   x0C,W
06A76:  SUBLW  49
06A78:  BNZ   6B1C
06A7A:  MOVLW  04
06A7C:  MOVWF  x42
06A7E:  MOVLW  C1
06A80:  MOVWF  x41
06A82:  MOVLB  0
06A84:  CALL   5588
06A88:  MOVF   01,W
06A8A:  ADDLW  C1
06A8C:  MOVLB  7
06A8E:  MOVWF  x0D
06A90:  MOVLW  04
06A92:  ADDWFC 02,W
06A94:  MOVWF  x0E
06A96:  MOVLW  01
06A98:  SUBWF  x0B,W
06A9A:  MULLW  28
06A9C:  MOVF   FF3,W
06A9E:  CLRF   x10
06AA0:  MOVWF  x0F
06AA2:  MOVLW  04
06AA4:  ADDWF  x0F,W
06AA6:  MOVWF  01
06AA8:  MOVLW  00
06AAA:  ADDWFC x10,W
06AAC:  MOVWF  03
06AAE:  MOVF   01,W
06AB0:  ADDLW  20
06AB2:  MOVWF  FE9
06AB4:  MOVLW  00
06AB6:  ADDWFC 03,W
06AB8:  MOVWF  FEA
06ABA:  MOVFF  FEF,70F
06ABE:  MOVFF  FEC,710
06AC2:  MOVFF  FEC,711
06AC6:  MOVFF  FEC,712
06ACA:  MOVFF  70E,565
06ACE:  MOVFF  70D,564
06AD2:  MOVFF  70B,734
06AD6:  MOVLW  18
06AD8:  MOVWF  x35
06ADA:  MOVLB  0
06ADC:  CALL   6060
06AE0:  MOVLW  2C
06AE2:  MOVLB  7
06AE4:  MOVWF  x50
06AE6:  MOVLB  0
06AE8:  CALL   55C0
06AEC:  MOVLW  89
06AEE:  MOVWF  FE9
06AF0:  MOVFF  712,746
06AF4:  MOVFF  711,745
06AF8:  MOVFF  710,744
06AFC:  MOVFF  70F,743
06B00:  MOVLW  02
06B02:  MOVLB  7
06B04:  MOVWF  x47
06B06:  MOVLB  0
06B08:  CALL   575E
06B0C:  MOVLW  2C
06B0E:  MOVLB  7
06B10:  MOVWF  x50
06B12:  MOVLB  0
06B14:  CALL   55C0
06B18:  BRA    6D2A
06B1A:  MOVLB  7
....................    else if ('D' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kD);
06B1C:  MOVF   x0C,W
06B1E:  SUBLW  44
06B20:  BNZ   6BC4
06B22:  MOVLW  04
06B24:  MOVWF  x42
06B26:  MOVLW  C1
06B28:  MOVWF  x41
06B2A:  MOVLB  0
06B2C:  CALL   5588
06B30:  MOVF   01,W
06B32:  ADDLW  C1
06B34:  MOVLB  7
06B36:  MOVWF  x0D
06B38:  MOVLW  04
06B3A:  ADDWFC 02,W
06B3C:  MOVWF  x0E
06B3E:  MOVLW  01
06B40:  SUBWF  x0B,W
06B42:  MULLW  28
06B44:  MOVF   FF3,W
06B46:  CLRF   x10
06B48:  MOVWF  x0F
06B4A:  MOVLW  08
06B4C:  ADDWF  x0F,W
06B4E:  MOVWF  01
06B50:  MOVLW  00
06B52:  ADDWFC x10,W
06B54:  MOVWF  03
06B56:  MOVF   01,W
06B58:  ADDLW  20
06B5A:  MOVWF  FE9
06B5C:  MOVLW  00
06B5E:  ADDWFC 03,W
06B60:  MOVWF  FEA
06B62:  MOVFF  FEF,70F
06B66:  MOVFF  FEC,710
06B6A:  MOVFF  FEC,711
06B6E:  MOVFF  FEC,712
06B72:  MOVFF  70E,565
06B76:  MOVFF  70D,564
06B7A:  MOVFF  70B,734
06B7E:  MOVLW  18
06B80:  MOVWF  x35
06B82:  MOVLB  0
06B84:  CALL   6060
06B88:  MOVLW  2C
06B8A:  MOVLB  7
06B8C:  MOVWF  x50
06B8E:  MOVLB  0
06B90:  CALL   55C0
06B94:  MOVLW  89
06B96:  MOVWF  FE9
06B98:  MOVFF  712,746
06B9C:  MOVFF  711,745
06BA0:  MOVFF  710,744
06BA4:  MOVFF  70F,743
06BA8:  MOVLW  02
06BAA:  MOVLB  7
06BAC:  MOVWF  x47
06BAE:  MOVLB  0
06BB0:  CALL   575E
06BB4:  MOVLW  2C
06BB6:  MOVLB  7
06BB8:  MOVWF  x50
06BBA:  MOVLB  0
06BBC:  CALL   55C0
06BC0:  BRA    6D2A
06BC2:  MOVLB  7
....................    else if ('A' == arg2) sprintf(retData+strlen(retData), "%d,%f,%f,%f,", arg1, PID[arg1-1].kP, PID[arg1-1].kI, PID[arg1-1].kD);
06BC4:  MOVF   x0C,W
06BC6:  SUBLW  41
06BC8:  BTFSS  FD8.2
06BCA:  BRA    6D22
06BCC:  MOVLW  04
06BCE:  MOVWF  x42
06BD0:  MOVLW  C1
06BD2:  MOVWF  x41
06BD4:  MOVLB  0
06BD6:  CALL   5588
06BDA:  MOVF   01,W
06BDC:  ADDLW  C1
06BDE:  MOVLB  7
06BE0:  MOVWF  x0D
06BE2:  MOVLW  04
06BE4:  ADDWFC 02,W
06BE6:  MOVWF  x0E
06BE8:  MOVLW  01
06BEA:  SUBWF  x0B,W
06BEC:  MULLW  28
06BEE:  MOVF   FF3,W
06BF0:  CLRF   x10
06BF2:  MOVWF  x0F
06BF4:  MOVLW  20
06BF6:  ADDWF  x0F,W
06BF8:  MOVWF  FE9
06BFA:  MOVLW  00
06BFC:  ADDWFC x10,W
06BFE:  MOVWF  FEA
06C00:  MOVFF  FEF,711
06C04:  MOVFF  FEC,712
06C08:  MOVFF  FEC,713
06C0C:  MOVFF  FEC,714
06C10:  MOVLW  01
06C12:  SUBWF  x0B,W
06C14:  MULLW  28
06C16:  MOVF   FF3,W
06C18:  CLRF   x16
06C1A:  MOVWF  x15
06C1C:  MOVLW  04
06C1E:  ADDWF  x15,W
06C20:  MOVWF  01
06C22:  MOVLW  00
06C24:  ADDWFC x16,W
06C26:  MOVWF  03
06C28:  MOVF   01,W
06C2A:  ADDLW  20
06C2C:  MOVWF  FE9
06C2E:  MOVLW  00
06C30:  ADDWFC 03,W
06C32:  MOVWF  FEA
06C34:  MOVFF  FEF,715
06C38:  MOVFF  FEC,716
06C3C:  MOVFF  FEC,717
06C40:  MOVFF  FEC,718
06C44:  MOVLW  01
06C46:  SUBWF  x0B,W
06C48:  MULLW  28
06C4A:  MOVF   FF3,W
06C4C:  CLRF   x1A
06C4E:  MOVWF  x19
06C50:  MOVLW  08
06C52:  ADDWF  x19,W
06C54:  MOVWF  01
06C56:  MOVLW  00
06C58:  ADDWFC x1A,W
06C5A:  MOVWF  03
06C5C:  MOVF   01,W
06C5E:  ADDLW  20
06C60:  MOVWF  FE9
06C62:  MOVLW  00
06C64:  ADDWFC 03,W
06C66:  MOVWF  FEA
06C68:  MOVFF  FEF,719
06C6C:  MOVFF  FEC,71A
06C70:  MOVFF  FEC,71B
06C74:  MOVFF  FEC,71C
06C78:  MOVFF  70E,565
06C7C:  MOVFF  70D,564
06C80:  MOVFF  70B,734
06C84:  MOVLW  18
06C86:  MOVWF  x35
06C88:  MOVLB  0
06C8A:  CALL   6060
06C8E:  MOVLW  2C
06C90:  MOVLB  7
06C92:  MOVWF  x50
06C94:  MOVLB  0
06C96:  CALL   55C0
06C9A:  MOVLW  89
06C9C:  MOVWF  FE9
06C9E:  MOVFF  714,746
06CA2:  MOVFF  713,745
06CA6:  MOVFF  712,744
06CAA:  MOVFF  711,743
06CAE:  MOVLW  02
06CB0:  MOVLB  7
06CB2:  MOVWF  x47
06CB4:  MOVLB  0
06CB6:  CALL   575E
06CBA:  MOVLW  2C
06CBC:  MOVLB  7
06CBE:  MOVWF  x50
06CC0:  MOVLB  0
06CC2:  CALL   55C0
06CC6:  MOVLW  89
06CC8:  MOVWF  FE9
06CCA:  MOVFF  718,746
06CCE:  MOVFF  717,745
06CD2:  MOVFF  716,744
06CD6:  MOVFF  715,743
06CDA:  MOVLW  02
06CDC:  MOVLB  7
06CDE:  MOVWF  x47
06CE0:  MOVLB  0
06CE2:  CALL   575E
06CE6:  MOVLW  2C
06CE8:  MOVLB  7
06CEA:  MOVWF  x50
06CEC:  MOVLB  0
06CEE:  CALL   55C0
06CF2:  MOVLW  89
06CF4:  MOVWF  FE9
06CF6:  MOVFF  71C,746
06CFA:  MOVFF  71B,745
06CFE:  MOVFF  71A,744
06D02:  MOVFF  719,743
06D06:  MOVLW  02
06D08:  MOVLB  7
06D0A:  MOVWF  x47
06D0C:  MOVLB  0
06D0E:  CALL   575E
06D12:  MOVLW  2C
06D14:  MOVLB  7
06D16:  MOVWF  x50
06D18:  MOVLB  0
06D1A:  CALL   55C0
06D1E:  BRA    6D2A
06D20:  MOVLB  7
....................    else return INV_PARAM;
06D22:  MOVLW  02
06D24:  MOVWF  01
06D26:  MOVLB  0
06D28:  BRA    6D2E
....................    
....................    return SUCCESS;
06D2A:  MOVLW  00
06D2C:  MOVWF  01
06D2E:  RETURN 0
.................... }
.................... 
.................... int8 setPIDvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char  arg2;
....................    float arg3;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
0704C:  MOVLB  7
0704E:  CLRF   x42
07050:  MOVFF  690,741
07054:  CLRF   x44
07056:  MOVLW  B5
07058:  MOVWF  x43
0705A:  MOVLB  0
0705C:  CALL   08A6
07060:  MOVFF  02,712
07064:  MOVFF  01,711
07068:  MOVLW  06
0706A:  MOVLB  7
0706C:  ADDWF  x11,F
0706E:  MOVLW  00
07070:  ADDWFC x12,F
07072:  MOVLW  32
07074:  ADDWF  x11,W
07076:  MOVWF  01
07078:  MOVLW  00
0707A:  ADDWFC x12,W
0707C:  MOVWF  03
0707E:  MOVF   01,W
07080:  ADDLW  EB
07082:  MOVWF  01
07084:  MOVLW  01
07086:  ADDWFC 03,F
07088:  MOVFF  01,711
0708C:  MOVFF  03,712
07090:  MOVFF  03,734
07094:  MOVFF  01,733
07098:  MOVLB  0
0709A:  CALL   5C1C
0709E:  MOVF   01,F
070A0:  BNZ   70AA
070A2:  MOVLW  02
070A4:  MOVWF  01
070A6:  BRA    732A
070A8:  BRA    7108
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
070AA:  MOVLB  7
070AC:  CLRF   x42
070AE:  MOVFF  690,741
070B2:  CLRF   x44
070B4:  MOVLW  B5
070B6:  MOVWF  x43
070B8:  MOVLB  0
070BA:  CALL   08A6
070BE:  MOVFF  02,712
070C2:  MOVFF  01,711
070C6:  MOVLW  06
070C8:  MOVLB  7
070CA:  ADDWF  x11,F
070CC:  MOVLW  00
070CE:  ADDWFC x12,F
070D0:  MOVLW  32
070D2:  ADDWF  x11,W
070D4:  MOVWF  01
070D6:  MOVLW  00
070D8:  ADDWFC x12,W
070DA:  MOVWF  03
070DC:  MOVF   01,W
070DE:  ADDLW  EB
070E0:  MOVWF  01
070E2:  MOVLW  01
070E4:  ADDWFC 03,F
070E6:  MOVFF  01,711
070EA:  MOVFF  03,712
070EE:  MOVFF  03,734
070F2:  MOVFF  01,733
070F6:  CLRF   x36
070F8:  CLRF   x35
070FA:  MOVLW  0A
070FC:  MOVWF  x37
070FE:  MOVLB  0
07100:  CALL   5D0C
07104:  MOVFF  01,70B
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
07108:  MOVLB  7
0710A:  CLRF   x42
0710C:  MOVFF  690,741
07110:  CLRF   x44
07112:  MOVLW  B5
07114:  MOVWF  x43
07116:  MOVLB  0
07118:  CALL   08A6
0711C:  MOVFF  02,712
07120:  MOVFF  01,711
07124:  MOVLW  06
07126:  MOVLB  7
07128:  ADDWF  x11,F
0712A:  MOVLW  00
0712C:  ADDWFC x12,F
0712E:  MOVLW  4B
07130:  ADDWF  x11,W
07132:  MOVWF  01
07134:  MOVLW  00
07136:  ADDWFC x12,W
07138:  MOVWF  03
0713A:  MOVF   01,W
0713C:  ADDLW  EB
0713E:  MOVWF  01
07140:  MOVLW  01
07142:  ADDWFC 03,F
07144:  MOVFF  01,711
07148:  MOVFF  03,712
0714C:  MOVFF  03,742
07150:  MOVFF  01,741
07154:  MOVLB  0
07156:  CALL   5588
0715A:  MOVFF  02,03
0715E:  MOVF   01,W
07160:  SUBLW  01
07162:  BNZ   7168
07164:  MOVF   03,F
07166:  BZ    7170
07168:  MOVLW  02
0716A:  MOVWF  01
0716C:  BRA    732A
0716E:  BRA    71B0
....................    else arg2 = SERcmd[rec].p[3][0];
07170:  MOVLB  7
07172:  CLRF   x42
07174:  MOVFF  690,741
07178:  CLRF   x44
0717A:  MOVLW  B5
0717C:  MOVWF  x43
0717E:  MOVLB  0
07180:  CALL   08A6
07184:  MOVFF  02,712
07188:  MOVFF  01,711
0718C:  MOVLW  06
0718E:  MOVLB  7
07190:  ADDWF  x11,F
07192:  MOVLW  00
07194:  ADDWFC x12,F
07196:  MOVLW  4B
07198:  ADDWF  x11,F
0719A:  MOVLW  00
0719C:  ADDWFC x12,F
0719E:  MOVLW  EB
071A0:  ADDWF  x11,W
071A2:  MOVWF  FE9
071A4:  MOVLW  01
071A6:  ADDWFC x12,W
071A8:  MOVWF  FEA
071AA:  MOVFF  FEF,70C
071AE:  MOVLB  0
....................    
....................    if (!arg_is_float(SERcmd[rec].p[4])) return INV_PARAM;
071B0:  MOVLB  7
071B2:  CLRF   x42
071B4:  MOVFF  690,741
071B8:  CLRF   x44
071BA:  MOVLW  B5
071BC:  MOVWF  x43
071BE:  MOVLB  0
071C0:  CALL   08A6
071C4:  MOVFF  02,712
071C8:  MOVFF  01,711
071CC:  MOVLW  06
071CE:  MOVLB  7
071D0:  ADDWF  x11,F
071D2:  MOVLW  00
071D4:  ADDWFC x12,F
071D6:  MOVLW  64
071D8:  ADDWF  x11,W
071DA:  MOVWF  01
071DC:  MOVLW  00
071DE:  ADDWFC x12,W
071E0:  MOVWF  03
071E2:  MOVF   01,W
071E4:  ADDLW  EB
071E6:  MOVWF  01
071E8:  MOVLW  01
071EA:  ADDWFC 03,F
071EC:  MOVFF  01,711
071F0:  MOVFF  03,712
071F4:  MOVFF  03,715
071F8:  MOVFF  01,714
071FC:  MOVLB  0
071FE:  RCALL  6D30
07200:  MOVF   01,F
07202:  BNZ   720C
07204:  MOVLW  02
07206:  MOVWF  01
07208:  BRA    732A
0720A:  BRA    7270
....................    else arg3 = strtod(SERcmd[rec].p[4], '\0');
0720C:  MOVLB  7
0720E:  CLRF   x42
07210:  MOVFF  690,741
07214:  CLRF   x44
07216:  MOVLW  B5
07218:  MOVWF  x43
0721A:  MOVLB  0
0721C:  CALL   08A6
07220:  MOVFF  02,712
07224:  MOVFF  01,711
07228:  MOVLW  06
0722A:  MOVLB  7
0722C:  ADDWF  x11,F
0722E:  MOVLW  00
07230:  ADDWFC x12,F
07232:  MOVLW  64
07234:  ADDWF  x11,W
07236:  MOVWF  01
07238:  MOVLW  00
0723A:  ADDWFC x12,W
0723C:  MOVWF  03
0723E:  MOVF   01,W
07240:  ADDLW  EB
07242:  MOVWF  01
07244:  MOVLW  01
07246:  ADDWFC 03,F
07248:  MOVFF  01,711
0724C:  MOVFF  03,712
07250:  MOVFF  03,715
07254:  MOVFF  01,714
07258:  CLRF   x17
0725A:  CLRF   x16
0725C:  MOVLB  0
0725E:  RCALL  6DF2
07260:  MOVFF  03,710
07264:  MOVFF  02,70F
07268:  MOVFF  01,70E
0726C:  MOVFF  00,70D
....................    
....................    /*** SET P, I, or D VALUE **********/
....................    if      ('P' == arg2) PID[arg1-1].kP = arg3;
07270:  MOVLB  7
07272:  MOVF   x0C,W
07274:  SUBLW  50
07276:  BNZ   72A2
07278:  MOVLW  01
0727A:  SUBWF  x0B,W
0727C:  MULLW  28
0727E:  MOVF   FF3,W
07280:  CLRF   x12
07282:  MOVWF  x11
07284:  MOVLW  20
07286:  ADDWF  x11,W
07288:  MOVWF  FE9
0728A:  MOVLW  00
0728C:  ADDWFC x12,W
0728E:  MOVWF  FEA
07290:  MOVFF  70D,FEF
07294:  MOVFF  70E,FEC
07298:  MOVFF  70F,FEC
0729C:  MOVFF  710,FEC
072A0:  BRA    7324
....................    else if ('I' == arg2) PID[arg1-1].kI = arg3;
072A2:  MOVF   x0C,W
072A4:  SUBLW  49
072A6:  BNZ   72DE
072A8:  MOVLW  01
072AA:  SUBWF  x0B,W
072AC:  MULLW  28
072AE:  MOVF   FF3,W
072B0:  CLRF   x12
072B2:  MOVWF  x11
072B4:  MOVLW  04
072B6:  ADDWF  x11,W
072B8:  MOVWF  01
072BA:  MOVLW  00
072BC:  ADDWFC x12,W
072BE:  MOVWF  03
072C0:  MOVF   01,W
072C2:  ADDLW  20
072C4:  MOVWF  FE9
072C6:  MOVLW  00
072C8:  ADDWFC 03,W
072CA:  MOVWF  FEA
072CC:  MOVFF  70D,FEF
072D0:  MOVFF  70E,FEC
072D4:  MOVFF  70F,FEC
072D8:  MOVFF  710,FEC
072DC:  BRA    7324
....................    else if ('D' == arg2) PID[arg1-1].kD = arg3;
072DE:  MOVF   x0C,W
072E0:  SUBLW  44
072E2:  BNZ   731A
072E4:  MOVLW  01
072E6:  SUBWF  x0B,W
072E8:  MULLW  28
072EA:  MOVF   FF3,W
072EC:  CLRF   x12
072EE:  MOVWF  x11
072F0:  MOVLW  08
072F2:  ADDWF  x11,W
072F4:  MOVWF  01
072F6:  MOVLW  00
072F8:  ADDWFC x12,W
072FA:  MOVWF  03
072FC:  MOVF   01,W
072FE:  ADDLW  20
07300:  MOVWF  FE9
07302:  MOVLW  00
07304:  ADDWFC 03,W
07306:  MOVWF  FEA
07308:  MOVFF  70D,FEF
0730C:  MOVFF  70E,FEC
07310:  MOVFF  70F,FEC
07314:  MOVFF  710,FEC
07318:  BRA    7324
....................    else return INV_PARAM;
0731A:  MOVLW  02
0731C:  MOVWF  01
0731E:  MOVLB  0
07320:  BRA    732A
07322:  MOVLB  7
....................    
....................    return SUCCESS;
07324:  MOVLW  00
07326:  MOVWF  01
07328:  MOVLB  0
0732A:  RETURN 0
.................... }
.................... 
.................... int8 getSetPoint(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0732C:  MOVLB  7
0732E:  CLRF   x42
07330:  MOVFF  690,741
07334:  CLRF   x44
07336:  MOVLW  B5
07338:  MOVWF  x43
0733A:  MOVLB  0
0733C:  CALL   08A6
07340:  MOVFF  02,70D
07344:  MOVFF  01,70C
07348:  MOVLW  06
0734A:  MOVLB  7
0734C:  ADDWF  x0C,F
0734E:  MOVLW  00
07350:  ADDWFC x0D,F
07352:  MOVLW  32
07354:  ADDWF  x0C,W
07356:  MOVWF  01
07358:  MOVLW  00
0735A:  ADDWFC x0D,W
0735C:  MOVWF  03
0735E:  MOVF   01,W
07360:  ADDLW  EB
07362:  MOVWF  01
07364:  MOVLW  01
07366:  ADDWFC 03,F
07368:  MOVFF  01,70C
0736C:  MOVFF  03,70D
07370:  MOVFF  03,734
07374:  MOVFF  01,733
07378:  MOVLB  0
0737A:  CALL   5C1C
0737E:  MOVF   01,F
07380:  BNZ   738A
07382:  MOVLW  02
07384:  MOVWF  01
07386:  BRA    748C
07388:  BRA    73E8
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
0738A:  MOVLB  7
0738C:  CLRF   x42
0738E:  MOVFF  690,741
07392:  CLRF   x44
07394:  MOVLW  B5
07396:  MOVWF  x43
07398:  MOVLB  0
0739A:  CALL   08A6
0739E:  MOVFF  02,70D
073A2:  MOVFF  01,70C
073A6:  MOVLW  06
073A8:  MOVLB  7
073AA:  ADDWF  x0C,F
073AC:  MOVLW  00
073AE:  ADDWFC x0D,F
073B0:  MOVLW  32
073B2:  ADDWF  x0C,W
073B4:  MOVWF  01
073B6:  MOVLW  00
073B8:  ADDWFC x0D,W
073BA:  MOVWF  03
073BC:  MOVF   01,W
073BE:  ADDLW  EB
073C0:  MOVWF  01
073C2:  MOVLW  01
073C4:  ADDWFC 03,F
073C6:  MOVFF  01,70C
073CA:  MOVFF  03,70D
073CE:  MOVFF  03,734
073D2:  MOVFF  01,733
073D6:  CLRF   x36
073D8:  CLRF   x35
073DA:  MOVLW  0A
073DC:  MOVWF  x37
073DE:  MOVLB  0
073E0:  CALL   5D0C
073E4:  MOVFF  01,70B
....................    
....................    /*** GET SETPOINT ******************/ 
....................    sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].SP);
073E8:  MOVLW  04
073EA:  MOVLB  7
073EC:  MOVWF  x42
073EE:  MOVLW  C1
073F0:  MOVWF  x41
073F2:  MOVLB  0
073F4:  CALL   5588
073F8:  MOVF   01,W
073FA:  ADDLW  C1
073FC:  MOVLB  7
073FE:  MOVWF  x0C
07400:  MOVLW  04
07402:  ADDWFC 02,W
07404:  MOVWF  x0D
07406:  MOVLW  01
07408:  SUBWF  x0B,W
0740A:  MULLW  28
0740C:  MOVF   FF3,W
0740E:  CLRF   x0F
07410:  MOVWF  x0E
07412:  MOVLW  0C
07414:  ADDWF  x0E,W
07416:  MOVWF  01
07418:  MOVLW  00
0741A:  ADDWFC x0F,W
0741C:  MOVWF  03
0741E:  MOVF   01,W
07420:  ADDLW  20
07422:  MOVWF  FE9
07424:  MOVLW  00
07426:  ADDWFC 03,W
07428:  MOVWF  FEA
0742A:  MOVFF  FEF,70E
0742E:  MOVFF  FEC,70F
07432:  MOVFF  FEC,710
07436:  MOVFF  FEC,711
0743A:  MOVFF  70D,565
0743E:  MOVFF  70C,564
07442:  MOVFF  70B,734
07446:  MOVLW  18
07448:  MOVWF  x35
0744A:  MOVLB  0
0744C:  CALL   6060
07450:  MOVLW  2C
07452:  MOVLB  7
07454:  MOVWF  x50
07456:  MOVLB  0
07458:  CALL   55C0
0745C:  MOVLW  89
0745E:  MOVWF  FE9
07460:  MOVFF  711,746
07464:  MOVFF  710,745
07468:  MOVFF  70F,744
0746C:  MOVFF  70E,743
07470:  MOVLW  02
07472:  MOVLB  7
07474:  MOVWF  x47
07476:  MOVLB  0
07478:  CALL   575E
0747C:  MOVLW  2C
0747E:  MOVLB  7
07480:  MOVWF  x50
07482:  MOVLB  0
07484:  CALL   55C0
....................    return SUCCESS;
07488:  MOVLW  00
0748A:  MOVWF  01
0748C:  RETURN 0
.................... }
.................... 
.................... int8 setSetPoint(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/   
....................    int8  arg1;
....................    float arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0748E:  MOVLB  7
07490:  CLRF   x42
07492:  MOVFF  690,741
07496:  CLRF   x44
07498:  MOVLW  B5
0749A:  MOVWF  x43
0749C:  MOVLB  0
0749E:  CALL   08A6
074A2:  MOVFF  02,711
074A6:  MOVFF  01,710
074AA:  MOVLW  06
074AC:  MOVLB  7
074AE:  ADDWF  x10,F
074B0:  MOVLW  00
074B2:  ADDWFC x11,F
074B4:  MOVLW  32
074B6:  ADDWF  x10,W
074B8:  MOVWF  01
074BA:  MOVLW  00
074BC:  ADDWFC x11,W
074BE:  MOVWF  03
074C0:  MOVF   01,W
074C2:  ADDLW  EB
074C4:  MOVWF  01
074C6:  MOVLW  01
074C8:  ADDWFC 03,F
074CA:  MOVFF  01,710
074CE:  MOVFF  03,711
074D2:  MOVFF  03,734
074D6:  MOVFF  01,733
074DA:  MOVLB  0
074DC:  CALL   5C1C
074E0:  MOVF   01,F
074E2:  BNZ   74EC
074E4:  MOVLW  02
074E6:  MOVWF  01
074E8:  BRA    764A
074EA:  BRA    754A
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
074EC:  MOVLB  7
074EE:  CLRF   x42
074F0:  MOVFF  690,741
074F4:  CLRF   x44
074F6:  MOVLW  B5
074F8:  MOVWF  x43
074FA:  MOVLB  0
074FC:  CALL   08A6
07500:  MOVFF  02,711
07504:  MOVFF  01,710
07508:  MOVLW  06
0750A:  MOVLB  7
0750C:  ADDWF  x10,F
0750E:  MOVLW  00
07510:  ADDWFC x11,F
07512:  MOVLW  32
07514:  ADDWF  x10,W
07516:  MOVWF  01
07518:  MOVLW  00
0751A:  ADDWFC x11,W
0751C:  MOVWF  03
0751E:  MOVF   01,W
07520:  ADDLW  EB
07522:  MOVWF  01
07524:  MOVLW  01
07526:  ADDWFC 03,F
07528:  MOVFF  01,710
0752C:  MOVFF  03,711
07530:  MOVFF  03,734
07534:  MOVFF  01,733
07538:  CLRF   x36
0753A:  CLRF   x35
0753C:  MOVLW  0A
0753E:  MOVWF  x37
07540:  MOVLB  0
07542:  CALL   5D0C
07546:  MOVFF  01,70B
....................    
....................    if (!arg_is_float(SERcmd[rec].p[3])) return INV_PARAM;
0754A:  MOVLB  7
0754C:  CLRF   x42
0754E:  MOVFF  690,741
07552:  CLRF   x44
07554:  MOVLW  B5
07556:  MOVWF  x43
07558:  MOVLB  0
0755A:  CALL   08A6
0755E:  MOVFF  02,711
07562:  MOVFF  01,710
07566:  MOVLW  06
07568:  MOVLB  7
0756A:  ADDWF  x10,F
0756C:  MOVLW  00
0756E:  ADDWFC x11,F
07570:  MOVLW  4B
07572:  ADDWF  x10,W
07574:  MOVWF  01
07576:  MOVLW  00
07578:  ADDWFC x11,W
0757A:  MOVWF  03
0757C:  MOVF   01,W
0757E:  ADDLW  EB
07580:  MOVWF  01
07582:  MOVLW  01
07584:  ADDWFC 03,F
07586:  MOVFF  01,710
0758A:  MOVFF  03,711
0758E:  MOVFF  03,715
07592:  MOVFF  01,714
07596:  MOVLB  0
07598:  CALL   6D30
0759C:  MOVF   01,F
0759E:  BNZ   75A8
075A0:  MOVLW  02
075A2:  MOVWF  01
075A4:  BRA    764A
075A6:  BRA    760E
....................    else arg2 = strtod(SERcmd[rec].p[3], '\0');
075A8:  MOVLB  7
075AA:  CLRF   x42
075AC:  MOVFF  690,741
075B0:  CLRF   x44
075B2:  MOVLW  B5
075B4:  MOVWF  x43
075B6:  MOVLB  0
075B8:  CALL   08A6
075BC:  MOVFF  02,711
075C0:  MOVFF  01,710
075C4:  MOVLW  06
075C6:  MOVLB  7
075C8:  ADDWF  x10,F
075CA:  MOVLW  00
075CC:  ADDWFC x11,F
075CE:  MOVLW  4B
075D0:  ADDWF  x10,W
075D2:  MOVWF  01
075D4:  MOVLW  00
075D6:  ADDWFC x11,W
075D8:  MOVWF  03
075DA:  MOVF   01,W
075DC:  ADDLW  EB
075DE:  MOVWF  01
075E0:  MOVLW  01
075E2:  ADDWFC 03,F
075E4:  MOVFF  01,710
075E8:  MOVFF  03,711
075EC:  MOVFF  03,715
075F0:  MOVFF  01,714
075F4:  CLRF   x17
075F6:  CLRF   x16
075F8:  MOVLB  0
075FA:  CALL   6DF2
075FE:  MOVFF  03,70F
07602:  MOVFF  02,70E
07606:  MOVFF  01,70D
0760A:  MOVFF  00,70C
....................    
....................    /*** SET SETPOINT ******************/ 
....................    PID[arg1-1].SP = arg2;
0760E:  MOVLW  01
07610:  MOVLB  7
07612:  SUBWF  x0B,W
07614:  MULLW  28
07616:  MOVF   FF3,W
07618:  CLRF   x11
0761A:  MOVWF  x10
0761C:  MOVLW  0C
0761E:  ADDWF  x10,W
07620:  MOVWF  01
07622:  MOVLW  00
07624:  ADDWFC x11,W
07626:  MOVWF  03
07628:  MOVF   01,W
0762A:  ADDLW  20
0762C:  MOVWF  FE9
0762E:  MOVLW  00
07630:  ADDWFC 03,W
07632:  MOVWF  FEA
07634:  MOVFF  70C,FEF
07638:  MOVFF  70D,FEC
0763C:  MOVFF  70E,FEC
07640:  MOVFF  70F,FEC
....................    
....................    return SUCCESS;
07644:  MOVLW  00
07646:  MOVWF  01
07648:  MOVLB  0
0764A:  RETURN 0
.................... }
.................... 
.................... int8 getAllSensorCalParams(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0764C:  MOVLB  7
0764E:  CLRF   x42
07650:  MOVFF  690,741
07654:  CLRF   x44
07656:  MOVLW  B5
07658:  MOVWF  x43
0765A:  MOVLB  0
0765C:  CALL   08A6
07660:  MOVFF  02,70D
07664:  MOVFF  01,70C
07668:  MOVLW  06
0766A:  MOVLB  7
0766C:  ADDWF  x0C,F
0766E:  MOVLW  00
07670:  ADDWFC x0D,F
07672:  MOVLW  32
07674:  ADDWF  x0C,W
07676:  MOVWF  01
07678:  MOVLW  00
0767A:  ADDWFC x0D,W
0767C:  MOVWF  03
0767E:  MOVF   01,W
07680:  ADDLW  EB
07682:  MOVWF  01
07684:  MOVLW  01
07686:  ADDWFC 03,F
07688:  MOVFF  01,70C
0768C:  MOVFF  03,70D
07690:  MOVFF  03,734
07694:  MOVFF  01,733
07698:  MOVLB  0
0769A:  CALL   5C1C
0769E:  MOVF   01,F
076A0:  BNZ   76AA
076A2:  MOVLW  02
076A4:  MOVWF  01
076A6:  BRA    7A00
076A8:  BRA    7708
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
076AA:  MOVLB  7
076AC:  CLRF   x42
076AE:  MOVFF  690,741
076B2:  CLRF   x44
076B4:  MOVLW  B5
076B6:  MOVWF  x43
076B8:  MOVLB  0
076BA:  CALL   08A6
076BE:  MOVFF  02,70D
076C2:  MOVFF  01,70C
076C6:  MOVLW  06
076C8:  MOVLB  7
076CA:  ADDWF  x0C,F
076CC:  MOVLW  00
076CE:  ADDWFC x0D,F
076D0:  MOVLW  32
076D2:  ADDWF  x0C,W
076D4:  MOVWF  01
076D6:  MOVLW  00
076D8:  ADDWFC x0D,W
076DA:  MOVWF  03
076DC:  MOVF   01,W
076DE:  ADDLW  EB
076E0:  MOVWF  01
076E2:  MOVLW  01
076E4:  ADDWFC 03,F
076E6:  MOVFF  01,70C
076EA:  MOVFF  03,70D
076EE:  MOVFF  03,734
076F2:  MOVFF  01,733
076F6:  CLRF   x36
076F8:  CLRF   x35
076FA:  MOVLW  0A
076FC:  MOVWF  x37
076FE:  MOVLB  0
07700:  CALL   5D0C
07704:  MOVFF  01,70B
....................    
....................    /*** GET ALL SENSOR CAL PARAMS *****/
....................    sprintf(retData+strlen(retData), "%d,", arg1);
07708:  MOVLW  04
0770A:  MOVLB  7
0770C:  MOVWF  x42
0770E:  MOVLW  C1
07710:  MOVWF  x41
07712:  MOVLB  0
07714:  CALL   5588
07718:  MOVFF  02,03
0771C:  MOVF   01,W
0771E:  ADDLW  C1
07720:  MOVLB  7
07722:  MOVWF  x0C
07724:  MOVLW  04
07726:  ADDWFC 02,W
07728:  MOVWF  x0D
0772A:  MOVFF  FE8,565
0772E:  MOVFF  70C,564
07732:  MOVFF  70B,734
07736:  MOVLW  18
07738:  MOVWF  x35
0773A:  MOVLB  0
0773C:  CALL   6060
07740:  MOVLW  2C
07742:  MOVLB  7
07744:  MOVWF  x50
07746:  MOVLB  0
07748:  CALL   55C0
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c0);
0774C:  MOVLW  04
0774E:  MOVLB  7
07750:  MOVWF  x42
07752:  MOVLW  C1
07754:  MOVWF  x41
07756:  MOVLB  0
07758:  CALL   5588
0775C:  MOVFF  02,03
07760:  MOVF   01,W
07762:  ADDLW  C1
07764:  MOVLB  7
07766:  MOVWF  x0C
07768:  MOVLW  04
0776A:  ADDWFC 02,W
0776C:  MOVWF  x0D
0776E:  MOVLW  01
07770:  SUBWF  x0B,W
07772:  MULLW  18
07774:  MOVF   FF3,W
07776:  CLRF   x0F
07778:  MOVWF  x0E
0777A:  MOVLW  92
0777C:  ADDWF  x0E,W
0777E:  MOVWF  FE9
07780:  MOVLW  00
07782:  ADDWFC x0F,W
07784:  MOVWF  FEA
07786:  MOVFF  FEF,743
0778A:  MOVFF  FEC,744
0778E:  MOVFF  FEC,745
07792:  MOVFF  FEC,746
07796:  MOVFF  70D,565
0779A:  MOVFF  70C,564
0779E:  MOVLW  89
077A0:  MOVWF  FE9
077A2:  MOVLW  02
077A4:  MOVWF  x47
077A6:  MOVLB  0
077A8:  CALL   575E
077AC:  MOVLW  2C
077AE:  MOVLB  7
077B0:  MOVWF  x50
077B2:  MOVLB  0
077B4:  CALL   55C0
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c1);
077B8:  MOVLW  04
077BA:  MOVLB  7
077BC:  MOVWF  x42
077BE:  MOVLW  C1
077C0:  MOVWF  x41
077C2:  MOVLB  0
077C4:  CALL   5588
077C8:  MOVF   01,W
077CA:  ADDLW  C1
077CC:  MOVLB  7
077CE:  MOVWF  x0C
077D0:  MOVLW  04
077D2:  ADDWFC 02,W
077D4:  MOVWF  x0D
077D6:  MOVLW  01
077D8:  SUBWF  x0B,W
077DA:  MULLW  18
077DC:  MOVF   FF3,W
077DE:  CLRF   x0F
077E0:  MOVWF  x0E
077E2:  MOVLW  04
077E4:  ADDWF  x0E,W
077E6:  MOVWF  01
077E8:  MOVLW  00
077EA:  ADDWFC x0F,W
077EC:  MOVWF  03
077EE:  MOVF   01,W
077F0:  ADDLW  92
077F2:  MOVWF  FE9
077F4:  MOVLW  00
077F6:  ADDWFC 03,W
077F8:  MOVWF  FEA
077FA:  MOVFF  FEF,743
077FE:  MOVFF  FEC,744
07802:  MOVFF  FEC,745
07806:  MOVFF  FEC,746
0780A:  MOVFF  70D,565
0780E:  MOVFF  70C,564
07812:  MOVLW  89
07814:  MOVWF  FE9
07816:  MOVLW  02
07818:  MOVWF  x47
0781A:  MOVLB  0
0781C:  CALL   575E
07820:  MOVLW  2C
07822:  MOVLB  7
07824:  MOVWF  x50
07826:  MOVLB  0
07828:  CALL   55C0
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c2);
0782C:  MOVLW  04
0782E:  MOVLB  7
07830:  MOVWF  x42
07832:  MOVLW  C1
07834:  MOVWF  x41
07836:  MOVLB  0
07838:  CALL   5588
0783C:  MOVF   01,W
0783E:  ADDLW  C1
07840:  MOVLB  7
07842:  MOVWF  x0C
07844:  MOVLW  04
07846:  ADDWFC 02,W
07848:  MOVWF  x0D
0784A:  MOVLW  01
0784C:  SUBWF  x0B,W
0784E:  MULLW  18
07850:  MOVF   FF3,W
07852:  CLRF   x0F
07854:  MOVWF  x0E
07856:  MOVLW  08
07858:  ADDWF  x0E,W
0785A:  MOVWF  01
0785C:  MOVLW  00
0785E:  ADDWFC x0F,W
07860:  MOVWF  03
07862:  MOVF   01,W
07864:  ADDLW  92
07866:  MOVWF  FE9
07868:  MOVLW  00
0786A:  ADDWFC 03,W
0786C:  MOVWF  FEA
0786E:  MOVFF  FEF,743
07872:  MOVFF  FEC,744
07876:  MOVFF  FEC,745
0787A:  MOVFF  FEC,746
0787E:  MOVFF  70D,565
07882:  MOVFF  70C,564
07886:  MOVLW  89
07888:  MOVWF  FE9
0788A:  MOVLW  02
0788C:  MOVWF  x47
0788E:  MOVLB  0
07890:  CALL   575E
07894:  MOVLW  2C
07896:  MOVLB  7
07898:  MOVWF  x50
0789A:  MOVLB  0
0789C:  CALL   55C0
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c3);
078A0:  MOVLW  04
078A2:  MOVLB  7
078A4:  MOVWF  x42
078A6:  MOVLW  C1
078A8:  MOVWF  x41
078AA:  MOVLB  0
078AC:  CALL   5588
078B0:  MOVF   01,W
078B2:  ADDLW  C1
078B4:  MOVLB  7
078B6:  MOVWF  x0C
078B8:  MOVLW  04
078BA:  ADDWFC 02,W
078BC:  MOVWF  x0D
078BE:  MOVLW  01
078C0:  SUBWF  x0B,W
078C2:  MULLW  18
078C4:  MOVF   FF3,W
078C6:  CLRF   x0F
078C8:  MOVWF  x0E
078CA:  MOVLW  0C
078CC:  ADDWF  x0E,W
078CE:  MOVWF  01
078D0:  MOVLW  00
078D2:  ADDWFC x0F,W
078D4:  MOVWF  03
078D6:  MOVF   01,W
078D8:  ADDLW  92
078DA:  MOVWF  FE9
078DC:  MOVLW  00
078DE:  ADDWFC 03,W
078E0:  MOVWF  FEA
078E2:  MOVFF  FEF,743
078E6:  MOVFF  FEC,744
078EA:  MOVFF  FEC,745
078EE:  MOVFF  FEC,746
078F2:  MOVFF  70D,565
078F6:  MOVFF  70C,564
078FA:  MOVLW  89
078FC:  MOVWF  FE9
078FE:  MOVLW  02
07900:  MOVWF  x47
07902:  MOVLB  0
07904:  CALL   575E
07908:  MOVLW  2C
0790A:  MOVLB  7
0790C:  MOVWF  x50
0790E:  MOVLB  0
07910:  CALL   55C0
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c4);
07914:  MOVLW  04
07916:  MOVLB  7
07918:  MOVWF  x42
0791A:  MOVLW  C1
0791C:  MOVWF  x41
0791E:  MOVLB  0
07920:  CALL   5588
07924:  MOVF   01,W
07926:  ADDLW  C1
07928:  MOVLB  7
0792A:  MOVWF  x0C
0792C:  MOVLW  04
0792E:  ADDWFC 02,W
07930:  MOVWF  x0D
07932:  MOVLW  01
07934:  SUBWF  x0B,W
07936:  MULLW  18
07938:  MOVF   FF3,W
0793A:  CLRF   x0F
0793C:  MOVWF  x0E
0793E:  MOVLW  10
07940:  ADDWF  x0E,W
07942:  MOVWF  01
07944:  MOVLW  00
07946:  ADDWFC x0F,W
07948:  MOVWF  03
0794A:  MOVF   01,W
0794C:  ADDLW  92
0794E:  MOVWF  FE9
07950:  MOVLW  00
07952:  ADDWFC 03,W
07954:  MOVWF  FEA
07956:  MOVFF  FEF,743
0795A:  MOVFF  FEC,744
0795E:  MOVFF  FEC,745
07962:  MOVFF  FEC,746
07966:  MOVFF  70D,565
0796A:  MOVFF  70C,564
0796E:  MOVLW  89
07970:  MOVWF  FE9
07972:  MOVLW  02
07974:  MOVWF  x47
07976:  MOVLB  0
07978:  CALL   575E
0797C:  MOVLW  2C
0797E:  MOVLB  7
07980:  MOVWF  x50
07982:  MOVLB  0
07984:  CALL   55C0
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c5);
07988:  MOVLW  04
0798A:  MOVLB  7
0798C:  MOVWF  x42
0798E:  MOVLW  C1
07990:  MOVWF  x41
07992:  MOVLB  0
07994:  CALL   5588
07998:  MOVF   01,W
0799A:  ADDLW  C1
0799C:  MOVLB  7
0799E:  MOVWF  x0C
079A0:  MOVLW  04
079A2:  ADDWFC 02,W
079A4:  MOVWF  x0D
079A6:  MOVLW  01
079A8:  SUBWF  x0B,W
079AA:  MULLW  18
079AC:  MOVF   FF3,W
079AE:  CLRF   x0F
079B0:  MOVWF  x0E
079B2:  MOVLW  14
079B4:  ADDWF  x0E,W
079B6:  MOVWF  01
079B8:  MOVLW  00
079BA:  ADDWFC x0F,W
079BC:  MOVWF  03
079BE:  MOVF   01,W
079C0:  ADDLW  92
079C2:  MOVWF  FE9
079C4:  MOVLW  00
079C6:  ADDWFC 03,W
079C8:  MOVWF  FEA
079CA:  MOVFF  FEF,743
079CE:  MOVFF  FEC,744
079D2:  MOVFF  FEC,745
079D6:  MOVFF  FEC,746
079DA:  MOVFF  70D,565
079DE:  MOVFF  70C,564
079E2:  MOVLW  89
079E4:  MOVWF  FE9
079E6:  MOVLW  02
079E8:  MOVWF  x47
079EA:  MOVLB  0
079EC:  CALL   575E
079F0:  MOVLW  2C
079F2:  MOVLB  7
079F4:  MOVWF  x50
079F6:  MOVLB  0
079F8:  CALL   55C0
....................    
....................    return SUCCESS;
079FC:  MOVLW  00
079FE:  MOVWF  01
07A00:  RETURN 0
.................... }
.................... 
.................... int8 getSensorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
07A02:  MOVLB  7
07A04:  CLRF   x42
07A06:  MOVFF  690,741
07A0A:  CLRF   x44
07A0C:  MOVLW  B5
07A0E:  MOVWF  x43
07A10:  MOVLB  0
07A12:  CALL   08A6
07A16:  MOVFF  02,70E
07A1A:  MOVFF  01,70D
07A1E:  MOVLW  06
07A20:  MOVLB  7
07A22:  ADDWF  x0D,F
07A24:  MOVLW  00
07A26:  ADDWFC x0E,F
07A28:  MOVLW  32
07A2A:  ADDWF  x0D,W
07A2C:  MOVWF  01
07A2E:  MOVLW  00
07A30:  ADDWFC x0E,W
07A32:  MOVWF  03
07A34:  MOVF   01,W
07A36:  ADDLW  EB
07A38:  MOVWF  01
07A3A:  MOVLW  01
07A3C:  ADDWFC 03,F
07A3E:  MOVFF  01,70D
07A42:  MOVFF  03,70E
07A46:  MOVFF  03,734
07A4A:  MOVFF  01,733
07A4E:  MOVLB  0
07A50:  CALL   5C1C
07A54:  MOVF   01,F
07A56:  BNZ   7A60
07A58:  MOVLW  02
07A5A:  MOVWF  01
07A5C:  BRA    7F5C
07A5E:  BRA    7ABE
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07A60:  MOVLB  7
07A62:  CLRF   x42
07A64:  MOVFF  690,741
07A68:  CLRF   x44
07A6A:  MOVLW  B5
07A6C:  MOVWF  x43
07A6E:  MOVLB  0
07A70:  CALL   08A6
07A74:  MOVFF  02,70E
07A78:  MOVFF  01,70D
07A7C:  MOVLW  06
07A7E:  MOVLB  7
07A80:  ADDWF  x0D,F
07A82:  MOVLW  00
07A84:  ADDWFC x0E,F
07A86:  MOVLW  32
07A88:  ADDWF  x0D,W
07A8A:  MOVWF  01
07A8C:  MOVLW  00
07A8E:  ADDWFC x0E,W
07A90:  MOVWF  03
07A92:  MOVF   01,W
07A94:  ADDLW  EB
07A96:  MOVWF  01
07A98:  MOVLW  01
07A9A:  ADDWFC 03,F
07A9C:  MOVFF  01,70D
07AA0:  MOVFF  03,70E
07AA4:  MOVFF  03,734
07AA8:  MOVFF  01,733
07AAC:  CLRF   x36
07AAE:  CLRF   x35
07AB0:  MOVLW  0A
07AB2:  MOVWF  x37
07AB4:  MOVLB  0
07AB6:  CALL   5D0C
07ABA:  MOVFF  01,70B
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
07ABE:  MOVLB  7
07AC0:  CLRF   x42
07AC2:  MOVFF  690,741
07AC6:  CLRF   x44
07AC8:  MOVLW  B5
07ACA:  MOVWF  x43
07ACC:  MOVLB  0
07ACE:  CALL   08A6
07AD2:  MOVFF  02,70E
07AD6:  MOVFF  01,70D
07ADA:  MOVLW  06
07ADC:  MOVLB  7
07ADE:  ADDWF  x0D,F
07AE0:  MOVLW  00
07AE2:  ADDWFC x0E,F
07AE4:  MOVLW  4B
07AE6:  ADDWF  x0D,W
07AE8:  MOVWF  01
07AEA:  MOVLW  00
07AEC:  ADDWFC x0E,W
07AEE:  MOVWF  03
07AF0:  MOVF   01,W
07AF2:  ADDLW  EB
07AF4:  MOVWF  01
07AF6:  MOVLW  01
07AF8:  ADDWFC 03,F
07AFA:  MOVFF  01,70D
07AFE:  MOVFF  03,70E
07B02:  MOVFF  03,742
07B06:  MOVFF  01,741
07B0A:  MOVLB  0
07B0C:  CALL   5588
07B10:  MOVFF  02,03
07B14:  MOVF   01,W
07B16:  SUBLW  01
07B18:  BNZ   7B1E
07B1A:  MOVF   03,F
07B1C:  BZ    7B26
07B1E:  MOVLW  02
07B20:  MOVWF  01
07B22:  BRA    7F5C
07B24:  BRA    7B66
....................    else arg2 = SERcmd[rec].p[3][0];
07B26:  MOVLB  7
07B28:  CLRF   x42
07B2A:  MOVFF  690,741
07B2E:  CLRF   x44
07B30:  MOVLW  B5
07B32:  MOVWF  x43
07B34:  MOVLB  0
07B36:  CALL   08A6
07B3A:  MOVFF  02,70E
07B3E:  MOVFF  01,70D
07B42:  MOVLW  06
07B44:  MOVLB  7
07B46:  ADDWF  x0D,F
07B48:  MOVLW  00
07B4A:  ADDWFC x0E,F
07B4C:  MOVLW  4B
07B4E:  ADDWF  x0D,F
07B50:  MOVLW  00
07B52:  ADDWFC x0E,F
07B54:  MOVLW  EB
07B56:  ADDWF  x0D,W
07B58:  MOVWF  FE9
07B5A:  MOVLW  01
07B5C:  ADDWFC x0E,W
07B5E:  MOVWF  FEA
07B60:  MOVFF  FEF,70C
07B64:  MOVLB  0
....................    
....................    /*** GET SENSOR CAL PARAM **********/
....................    if      ('0' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c0);
07B66:  MOVLB  7
07B68:  MOVF   x0C,W
07B6A:  SUBLW  30
07B6C:  BNZ   7C08
07B6E:  MOVLW  04
07B70:  MOVWF  x42
07B72:  MOVLW  C1
07B74:  MOVWF  x41
07B76:  MOVLB  0
07B78:  CALL   5588
07B7C:  MOVFF  02,03
07B80:  MOVF   01,W
07B82:  ADDLW  C1
07B84:  MOVLB  7
07B86:  MOVWF  x0D
07B88:  MOVLW  04
07B8A:  ADDWFC 02,W
07B8C:  MOVWF  x0E
07B8E:  MOVLW  01
07B90:  SUBWF  x0B,W
07B92:  MULLW  18
07B94:  MOVF   FF3,W
07B96:  CLRF   x10
07B98:  MOVWF  x0F
07B9A:  MOVLW  92
07B9C:  ADDWF  x0F,W
07B9E:  MOVWF  FE9
07BA0:  MOVLW  00
07BA2:  ADDWFC x10,W
07BA4:  MOVWF  FEA
07BA6:  MOVFF  FEF,711
07BAA:  MOVFF  FEC,712
07BAE:  MOVFF  FEC,713
07BB2:  MOVFF  FEC,714
07BB6:  MOVFF  70E,565
07BBA:  MOVFF  70D,564
07BBE:  MOVFF  70B,734
07BC2:  MOVLW  18
07BC4:  MOVWF  x35
07BC6:  MOVLB  0
07BC8:  CALL   6060
07BCC:  MOVLW  2C
07BCE:  MOVLB  7
07BD0:  MOVWF  x50
07BD2:  MOVLB  0
07BD4:  CALL   55C0
07BD8:  MOVLW  89
07BDA:  MOVWF  FE9
07BDC:  MOVFF  714,746
07BE0:  MOVFF  713,745
07BE4:  MOVFF  712,744
07BE8:  MOVFF  711,743
07BEC:  MOVLW  02
07BEE:  MOVLB  7
07BF0:  MOVWF  x47
07BF2:  MOVLB  0
07BF4:  CALL   575E
07BF8:  MOVLW  2C
07BFA:  MOVLB  7
07BFC:  MOVWF  x50
07BFE:  MOVLB  0
07C00:  CALL   55C0
07C04:  BRA    7F58
07C06:  MOVLB  7
....................    else if ('1' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c1);
07C08:  MOVF   x0C,W
07C0A:  SUBLW  31
07C0C:  BNZ   7CB0
07C0E:  MOVLW  04
07C10:  MOVWF  x42
07C12:  MOVLW  C1
07C14:  MOVWF  x41
07C16:  MOVLB  0
07C18:  CALL   5588
07C1C:  MOVF   01,W
07C1E:  ADDLW  C1
07C20:  MOVLB  7
07C22:  MOVWF  x0D
07C24:  MOVLW  04
07C26:  ADDWFC 02,W
07C28:  MOVWF  x0E
07C2A:  MOVLW  01
07C2C:  SUBWF  x0B,W
07C2E:  MULLW  18
07C30:  MOVF   FF3,W
07C32:  CLRF   x10
07C34:  MOVWF  x0F
07C36:  MOVLW  04
07C38:  ADDWF  x0F,W
07C3A:  MOVWF  01
07C3C:  MOVLW  00
07C3E:  ADDWFC x10,W
07C40:  MOVWF  03
07C42:  MOVF   01,W
07C44:  ADDLW  92
07C46:  MOVWF  FE9
07C48:  MOVLW  00
07C4A:  ADDWFC 03,W
07C4C:  MOVWF  FEA
07C4E:  MOVFF  FEF,70F
07C52:  MOVFF  FEC,710
07C56:  MOVFF  FEC,711
07C5A:  MOVFF  FEC,712
07C5E:  MOVFF  70E,565
07C62:  MOVFF  70D,564
07C66:  MOVFF  70B,734
07C6A:  MOVLW  18
07C6C:  MOVWF  x35
07C6E:  MOVLB  0
07C70:  CALL   6060
07C74:  MOVLW  2C
07C76:  MOVLB  7
07C78:  MOVWF  x50
07C7A:  MOVLB  0
07C7C:  CALL   55C0
07C80:  MOVLW  89
07C82:  MOVWF  FE9
07C84:  MOVFF  712,746
07C88:  MOVFF  711,745
07C8C:  MOVFF  710,744
07C90:  MOVFF  70F,743
07C94:  MOVLW  02
07C96:  MOVLB  7
07C98:  MOVWF  x47
07C9A:  MOVLB  0
07C9C:  CALL   575E
07CA0:  MOVLW  2C
07CA2:  MOVLB  7
07CA4:  MOVWF  x50
07CA6:  MOVLB  0
07CA8:  CALL   55C0
07CAC:  BRA    7F58
07CAE:  MOVLB  7
....................    else if ('2' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c2);
07CB0:  MOVF   x0C,W
07CB2:  SUBLW  32
07CB4:  BNZ   7D58
07CB6:  MOVLW  04
07CB8:  MOVWF  x42
07CBA:  MOVLW  C1
07CBC:  MOVWF  x41
07CBE:  MOVLB  0
07CC0:  CALL   5588
07CC4:  MOVF   01,W
07CC6:  ADDLW  C1
07CC8:  MOVLB  7
07CCA:  MOVWF  x0D
07CCC:  MOVLW  04
07CCE:  ADDWFC 02,W
07CD0:  MOVWF  x0E
07CD2:  MOVLW  01
07CD4:  SUBWF  x0B,W
07CD6:  MULLW  18
07CD8:  MOVF   FF3,W
07CDA:  CLRF   x10
07CDC:  MOVWF  x0F
07CDE:  MOVLW  08
07CE0:  ADDWF  x0F,W
07CE2:  MOVWF  01
07CE4:  MOVLW  00
07CE6:  ADDWFC x10,W
07CE8:  MOVWF  03
07CEA:  MOVF   01,W
07CEC:  ADDLW  92
07CEE:  MOVWF  FE9
07CF0:  MOVLW  00
07CF2:  ADDWFC 03,W
07CF4:  MOVWF  FEA
07CF6:  MOVFF  FEF,70F
07CFA:  MOVFF  FEC,710
07CFE:  MOVFF  FEC,711
07D02:  MOVFF  FEC,712
07D06:  MOVFF  70E,565
07D0A:  MOVFF  70D,564
07D0E:  MOVFF  70B,734
07D12:  MOVLW  18
07D14:  MOVWF  x35
07D16:  MOVLB  0
07D18:  CALL   6060
07D1C:  MOVLW  2C
07D1E:  MOVLB  7
07D20:  MOVWF  x50
07D22:  MOVLB  0
07D24:  CALL   55C0
07D28:  MOVLW  89
07D2A:  MOVWF  FE9
07D2C:  MOVFF  712,746
07D30:  MOVFF  711,745
07D34:  MOVFF  710,744
07D38:  MOVFF  70F,743
07D3C:  MOVLW  02
07D3E:  MOVLB  7
07D40:  MOVWF  x47
07D42:  MOVLB  0
07D44:  CALL   575E
07D48:  MOVLW  2C
07D4A:  MOVLB  7
07D4C:  MOVWF  x50
07D4E:  MOVLB  0
07D50:  CALL   55C0
07D54:  BRA    7F58
07D56:  MOVLB  7
....................    else if ('3' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c3);
07D58:  MOVF   x0C,W
07D5A:  SUBLW  33
07D5C:  BNZ   7E00
07D5E:  MOVLW  04
07D60:  MOVWF  x42
07D62:  MOVLW  C1
07D64:  MOVWF  x41
07D66:  MOVLB  0
07D68:  CALL   5588
07D6C:  MOVF   01,W
07D6E:  ADDLW  C1
07D70:  MOVLB  7
07D72:  MOVWF  x0D
07D74:  MOVLW  04
07D76:  ADDWFC 02,W
07D78:  MOVWF  x0E
07D7A:  MOVLW  01
07D7C:  SUBWF  x0B,W
07D7E:  MULLW  18
07D80:  MOVF   FF3,W
07D82:  CLRF   x10
07D84:  MOVWF  x0F
07D86:  MOVLW  0C
07D88:  ADDWF  x0F,W
07D8A:  MOVWF  01
07D8C:  MOVLW  00
07D8E:  ADDWFC x10,W
07D90:  MOVWF  03
07D92:  MOVF   01,W
07D94:  ADDLW  92
07D96:  MOVWF  FE9
07D98:  MOVLW  00
07D9A:  ADDWFC 03,W
07D9C:  MOVWF  FEA
07D9E:  MOVFF  FEF,70F
07DA2:  MOVFF  FEC,710
07DA6:  MOVFF  FEC,711
07DAA:  MOVFF  FEC,712
07DAE:  MOVFF  70E,565
07DB2:  MOVFF  70D,564
07DB6:  MOVFF  70B,734
07DBA:  MOVLW  18
07DBC:  MOVWF  x35
07DBE:  MOVLB  0
07DC0:  CALL   6060
07DC4:  MOVLW  2C
07DC6:  MOVLB  7
07DC8:  MOVWF  x50
07DCA:  MOVLB  0
07DCC:  CALL   55C0
07DD0:  MOVLW  89
07DD2:  MOVWF  FE9
07DD4:  MOVFF  712,746
07DD8:  MOVFF  711,745
07DDC:  MOVFF  710,744
07DE0:  MOVFF  70F,743
07DE4:  MOVLW  02
07DE6:  MOVLB  7
07DE8:  MOVWF  x47
07DEA:  MOVLB  0
07DEC:  CALL   575E
07DF0:  MOVLW  2C
07DF2:  MOVLB  7
07DF4:  MOVWF  x50
07DF6:  MOVLB  0
07DF8:  CALL   55C0
07DFC:  BRA    7F58
07DFE:  MOVLB  7
....................    else if ('4' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c4);
07E00:  MOVF   x0C,W
07E02:  SUBLW  34
07E04:  BNZ   7EA8
07E06:  MOVLW  04
07E08:  MOVWF  x42
07E0A:  MOVLW  C1
07E0C:  MOVWF  x41
07E0E:  MOVLB  0
07E10:  CALL   5588
07E14:  MOVF   01,W
07E16:  ADDLW  C1
07E18:  MOVLB  7
07E1A:  MOVWF  x0D
07E1C:  MOVLW  04
07E1E:  ADDWFC 02,W
07E20:  MOVWF  x0E
07E22:  MOVLW  01
07E24:  SUBWF  x0B,W
07E26:  MULLW  18
07E28:  MOVF   FF3,W
07E2A:  CLRF   x10
07E2C:  MOVWF  x0F
07E2E:  MOVLW  10
07E30:  ADDWF  x0F,W
07E32:  MOVWF  01
07E34:  MOVLW  00
07E36:  ADDWFC x10,W
07E38:  MOVWF  03
07E3A:  MOVF   01,W
07E3C:  ADDLW  92
07E3E:  MOVWF  FE9
07E40:  MOVLW  00
07E42:  ADDWFC 03,W
07E44:  MOVWF  FEA
07E46:  MOVFF  FEF,70F
07E4A:  MOVFF  FEC,710
07E4E:  MOVFF  FEC,711
07E52:  MOVFF  FEC,712
07E56:  MOVFF  70E,565
07E5A:  MOVFF  70D,564
07E5E:  MOVFF  70B,734
07E62:  MOVLW  18
07E64:  MOVWF  x35
07E66:  MOVLB  0
07E68:  CALL   6060
07E6C:  MOVLW  2C
07E6E:  MOVLB  7
07E70:  MOVWF  x50
07E72:  MOVLB  0
07E74:  CALL   55C0
07E78:  MOVLW  89
07E7A:  MOVWF  FE9
07E7C:  MOVFF  712,746
07E80:  MOVFF  711,745
07E84:  MOVFF  710,744
07E88:  MOVFF  70F,743
07E8C:  MOVLW  02
07E8E:  MOVLB  7
07E90:  MOVWF  x47
07E92:  MOVLB  0
07E94:  CALL   575E
07E98:  MOVLW  2C
07E9A:  MOVLB  7
07E9C:  MOVWF  x50
07E9E:  MOVLB  0
07EA0:  CALL   55C0
07EA4:  BRA    7F58
07EA6:  MOVLB  7
....................    else if ('5' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c5);
07EA8:  MOVF   x0C,W
07EAA:  SUBLW  35
07EAC:  BNZ   7F50
07EAE:  MOVLW  04
07EB0:  MOVWF  x42
07EB2:  MOVLW  C1
07EB4:  MOVWF  x41
07EB6:  MOVLB  0
07EB8:  CALL   5588
07EBC:  MOVF   01,W
07EBE:  ADDLW  C1
07EC0:  MOVLB  7
07EC2:  MOVWF  x0D
07EC4:  MOVLW  04
07EC6:  ADDWFC 02,W
07EC8:  MOVWF  x0E
07ECA:  MOVLW  01
07ECC:  SUBWF  x0B,W
07ECE:  MULLW  18
07ED0:  MOVF   FF3,W
07ED2:  CLRF   x10
07ED4:  MOVWF  x0F
07ED6:  MOVLW  14
07ED8:  ADDWF  x0F,W
07EDA:  MOVWF  01
07EDC:  MOVLW  00
07EDE:  ADDWFC x10,W
07EE0:  MOVWF  03
07EE2:  MOVF   01,W
07EE4:  ADDLW  92
07EE6:  MOVWF  FE9
07EE8:  MOVLW  00
07EEA:  ADDWFC 03,W
07EEC:  MOVWF  FEA
07EEE:  MOVFF  FEF,70F
07EF2:  MOVFF  FEC,710
07EF6:  MOVFF  FEC,711
07EFA:  MOVFF  FEC,712
07EFE:  MOVFF  70E,565
07F02:  MOVFF  70D,564
07F06:  MOVFF  70B,734
07F0A:  MOVLW  18
07F0C:  MOVWF  x35
07F0E:  MOVLB  0
07F10:  CALL   6060
07F14:  MOVLW  2C
07F16:  MOVLB  7
07F18:  MOVWF  x50
07F1A:  MOVLB  0
07F1C:  CALL   55C0
07F20:  MOVLW  89
07F22:  MOVWF  FE9
07F24:  MOVFF  712,746
07F28:  MOVFF  711,745
07F2C:  MOVFF  710,744
07F30:  MOVFF  70F,743
07F34:  MOVLW  02
07F36:  MOVLB  7
07F38:  MOVWF  x47
07F3A:  MOVLB  0
07F3C:  CALL   575E
07F40:  MOVLW  2C
07F42:  MOVLB  7
07F44:  MOVWF  x50
07F46:  MOVLB  0
07F48:  CALL   55C0
07F4C:  BRA    7F58
07F4E:  MOVLB  7
....................    else return INV_PARAM;
07F50:  MOVLW  02
07F52:  MOVWF  01
07F54:  MOVLB  0
07F56:  BRA    7F5C
....................    
....................    return SUCCESS;
07F58:  MOVLW  00
07F5A:  MOVWF  01
07F5C:  RETURN 0
.................... }
.................... 
.................... int8 setSensorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char  arg2;
....................    float arg3;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
07F5E:  MOVLB  7
07F60:  CLRF   x42
07F62:  MOVFF  690,741
07F66:  CLRF   x44
07F68:  MOVLW  B5
07F6A:  MOVWF  x43
07F6C:  MOVLB  0
07F6E:  CALL   08A6
07F72:  MOVFF  02,712
07F76:  MOVFF  01,711
07F7A:  MOVLW  06
07F7C:  MOVLB  7
07F7E:  ADDWF  x11,F
07F80:  MOVLW  00
07F82:  ADDWFC x12,F
07F84:  MOVLW  32
07F86:  ADDWF  x11,W
07F88:  MOVWF  01
07F8A:  MOVLW  00
07F8C:  ADDWFC x12,W
07F8E:  MOVWF  03
07F90:  MOVF   01,W
07F92:  ADDLW  EB
07F94:  MOVWF  01
07F96:  MOVLW  01
07F98:  ADDWFC 03,F
07F9A:  MOVFF  01,711
07F9E:  MOVFF  03,712
07FA2:  MOVFF  03,734
07FA6:  MOVFF  01,733
07FAA:  MOVLB  0
07FAC:  CALL   5C1C
07FB0:  MOVF   01,F
07FB2:  BNZ   7FBC
07FB4:  MOVLW  02
07FB6:  MOVWF  01
07FB8:  BRA    82F4
07FBA:  BRA    801A
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07FBC:  MOVLB  7
07FBE:  CLRF   x42
07FC0:  MOVFF  690,741
07FC4:  CLRF   x44
07FC6:  MOVLW  B5
07FC8:  MOVWF  x43
07FCA:  MOVLB  0
07FCC:  CALL   08A6
07FD0:  MOVFF  02,712
07FD4:  MOVFF  01,711
07FD8:  MOVLW  06
07FDA:  MOVLB  7
07FDC:  ADDWF  x11,F
07FDE:  MOVLW  00
07FE0:  ADDWFC x12,F
07FE2:  MOVLW  32
07FE4:  ADDWF  x11,W
07FE6:  MOVWF  01
07FE8:  MOVLW  00
07FEA:  ADDWFC x12,W
07FEC:  MOVWF  03
07FEE:  MOVF   01,W
07FF0:  ADDLW  EB
07FF2:  MOVWF  01
07FF4:  MOVLW  01
07FF6:  ADDWFC 03,F
07FF8:  MOVFF  01,711
07FFC:  MOVFF  03,712
08000:  MOVFF  03,734
08004:  MOVFF  01,733
08008:  CLRF   x36
0800A:  CLRF   x35
0800C:  MOVLW  0A
0800E:  MOVWF  x37
08010:  MOVLB  0
08012:  CALL   5D0C
08016:  MOVFF  01,70B
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
0801A:  MOVLB  7
0801C:  CLRF   x42
0801E:  MOVFF  690,741
08022:  CLRF   x44
08024:  MOVLW  B5
08026:  MOVWF  x43
08028:  MOVLB  0
0802A:  CALL   08A6
0802E:  MOVFF  02,712
08032:  MOVFF  01,711
08036:  MOVLW  06
08038:  MOVLB  7
0803A:  ADDWF  x11,F
0803C:  MOVLW  00
0803E:  ADDWFC x12,F
08040:  MOVLW  4B
08042:  ADDWF  x11,W
08044:  MOVWF  01
08046:  MOVLW  00
08048:  ADDWFC x12,W
0804A:  MOVWF  03
0804C:  MOVF   01,W
0804E:  ADDLW  EB
08050:  MOVWF  01
08052:  MOVLW  01
08054:  ADDWFC 03,F
08056:  MOVFF  01,711
0805A:  MOVFF  03,712
0805E:  MOVFF  03,742
08062:  MOVFF  01,741
08066:  MOVLB  0
08068:  CALL   5588
0806C:  MOVFF  02,03
08070:  MOVF   01,W
08072:  SUBLW  01
08074:  BNZ   807A
08076:  MOVF   03,F
08078:  BZ    8082
0807A:  MOVLW  02
0807C:  MOVWF  01
0807E:  BRA    82F4
08080:  BRA    80C2
....................    else arg2 = SERcmd[rec].p[3][0];
08082:  MOVLB  7
08084:  CLRF   x42
08086:  MOVFF  690,741
0808A:  CLRF   x44
0808C:  MOVLW  B5
0808E:  MOVWF  x43
08090:  MOVLB  0
08092:  CALL   08A6
08096:  MOVFF  02,712
0809A:  MOVFF  01,711
0809E:  MOVLW  06
080A0:  MOVLB  7
080A2:  ADDWF  x11,F
080A4:  MOVLW  00
080A6:  ADDWFC x12,F
080A8:  MOVLW  4B
080AA:  ADDWF  x11,F
080AC:  MOVLW  00
080AE:  ADDWFC x12,F
080B0:  MOVLW  EB
080B2:  ADDWF  x11,W
080B4:  MOVWF  FE9
080B6:  MOVLW  01
080B8:  ADDWFC x12,W
080BA:  MOVWF  FEA
080BC:  MOVFF  FEF,70C
080C0:  MOVLB  0
....................    
....................    if (!arg_is_float(SERcmd[rec].p[4])) return INV_PARAM;
080C2:  MOVLB  7
080C4:  CLRF   x42
080C6:  MOVFF  690,741
080CA:  CLRF   x44
080CC:  MOVLW  B5
080CE:  MOVWF  x43
080D0:  MOVLB  0
080D2:  CALL   08A6
080D6:  MOVFF  02,712
080DA:  MOVFF  01,711
080DE:  MOVLW  06
080E0:  MOVLB  7
080E2:  ADDWF  x11,F
080E4:  MOVLW  00
080E6:  ADDWFC x12,F
080E8:  MOVLW  64
080EA:  ADDWF  x11,W
080EC:  MOVWF  01
080EE:  MOVLW  00
080F0:  ADDWFC x12,W
080F2:  MOVWF  03
080F4:  MOVF   01,W
080F6:  ADDLW  EB
080F8:  MOVWF  01
080FA:  MOVLW  01
080FC:  ADDWFC 03,F
080FE:  MOVFF  01,711
08102:  MOVFF  03,712
08106:  MOVFF  03,715
0810A:  MOVFF  01,714
0810E:  MOVLB  0
08110:  CALL   6D30
08114:  MOVF   01,F
08116:  BNZ   8120
08118:  MOVLW  02
0811A:  MOVWF  01
0811C:  BRA    82F4
0811E:  BRA    8186
....................    else arg3 = strtod(SERcmd[rec].p[4], '\0');
08120:  MOVLB  7
08122:  CLRF   x42
08124:  MOVFF  690,741
08128:  CLRF   x44
0812A:  MOVLW  B5
0812C:  MOVWF  x43
0812E:  MOVLB  0
08130:  CALL   08A6
08134:  MOVFF  02,712
08138:  MOVFF  01,711
0813C:  MOVLW  06
0813E:  MOVLB  7
08140:  ADDWF  x11,F
08142:  MOVLW  00
08144:  ADDWFC x12,F
08146:  MOVLW  64
08148:  ADDWF  x11,W
0814A:  MOVWF  01
0814C:  MOVLW  00
0814E:  ADDWFC x12,W
08150:  MOVWF  03
08152:  MOVF   01,W
08154:  ADDLW  EB
08156:  MOVWF  01
08158:  MOVLW  01
0815A:  ADDWFC 03,F
0815C:  MOVFF  01,711
08160:  MOVFF  03,712
08164:  MOVFF  03,715
08168:  MOVFF  01,714
0816C:  CLRF   x17
0816E:  CLRF   x16
08170:  MOVLB  0
08172:  CALL   6DF2
08176:  MOVFF  03,710
0817A:  MOVFF  02,70F
0817E:  MOVFF  01,70E
08182:  MOVFF  00,70D
....................    
....................    /*** SET SENSOR CAL PARAM **********/
....................    if      ('0' == arg2) sensorCal[arg1-1].c0 = arg3;
08186:  MOVLB  7
08188:  MOVF   x0C,W
0818A:  SUBLW  30
0818C:  BNZ   81B8
0818E:  MOVLW  01
08190:  SUBWF  x0B,W
08192:  MULLW  18
08194:  MOVF   FF3,W
08196:  CLRF   x12
08198:  MOVWF  x11
0819A:  MOVLW  92
0819C:  ADDWF  x11,W
0819E:  MOVWF  FE9
081A0:  MOVLW  00
081A2:  ADDWFC x12,W
081A4:  MOVWF  FEA
081A6:  MOVFF  70D,FEF
081AA:  MOVFF  70E,FEC
081AE:  MOVFF  70F,FEC
081B2:  MOVFF  710,FEC
081B6:  BRA    82EE
....................    else if ('1' == arg2) sensorCal[arg1-1].c1 = arg3;
081B8:  MOVF   x0C,W
081BA:  SUBLW  31
081BC:  BNZ   81F4
081BE:  MOVLW  01
081C0:  SUBWF  x0B,W
081C2:  MULLW  18
081C4:  MOVF   FF3,W
081C6:  CLRF   x12
081C8:  MOVWF  x11
081CA:  MOVLW  04
081CC:  ADDWF  x11,W
081CE:  MOVWF  01
081D0:  MOVLW  00
081D2:  ADDWFC x12,W
081D4:  MOVWF  03
081D6:  MOVF   01,W
081D8:  ADDLW  92
081DA:  MOVWF  FE9
081DC:  MOVLW  00
081DE:  ADDWFC 03,W
081E0:  MOVWF  FEA
081E2:  MOVFF  70D,FEF
081E6:  MOVFF  70E,FEC
081EA:  MOVFF  70F,FEC
081EE:  MOVFF  710,FEC
081F2:  BRA    82EE
....................    else if ('2' == arg2) sensorCal[arg1-1].c2 = arg3;
081F4:  MOVF   x0C,W
081F6:  SUBLW  32
081F8:  BNZ   8230
081FA:  MOVLW  01
081FC:  SUBWF  x0B,W
081FE:  MULLW  18
08200:  MOVF   FF3,W
08202:  CLRF   x12
08204:  MOVWF  x11
08206:  MOVLW  08
08208:  ADDWF  x11,W
0820A:  MOVWF  01
0820C:  MOVLW  00
0820E:  ADDWFC x12,W
08210:  MOVWF  03
08212:  MOVF   01,W
08214:  ADDLW  92
08216:  MOVWF  FE9
08218:  MOVLW  00
0821A:  ADDWFC 03,W
0821C:  MOVWF  FEA
0821E:  MOVFF  70D,FEF
08222:  MOVFF  70E,FEC
08226:  MOVFF  70F,FEC
0822A:  MOVFF  710,FEC
0822E:  BRA    82EE
....................    else if ('3' == arg2) sensorCal[arg1-1].c3 = arg3;
08230:  MOVF   x0C,W
08232:  SUBLW  33
08234:  BNZ   826C
08236:  MOVLW  01
08238:  SUBWF  x0B,W
0823A:  MULLW  18
0823C:  MOVF   FF3,W
0823E:  CLRF   x12
08240:  MOVWF  x11
08242:  MOVLW  0C
08244:  ADDWF  x11,W
08246:  MOVWF  01
08248:  MOVLW  00
0824A:  ADDWFC x12,W
0824C:  MOVWF  03
0824E:  MOVF   01,W
08250:  ADDLW  92
08252:  MOVWF  FE9
08254:  MOVLW  00
08256:  ADDWFC 03,W
08258:  MOVWF  FEA
0825A:  MOVFF  70D,FEF
0825E:  MOVFF  70E,FEC
08262:  MOVFF  70F,FEC
08266:  MOVFF  710,FEC
0826A:  BRA    82EE
....................    else if ('4' == arg2) sensorCal[arg1-1].c4 = arg3;
0826C:  MOVF   x0C,W
0826E:  SUBLW  34
08270:  BNZ   82A8
08272:  MOVLW  01
08274:  SUBWF  x0B,W
08276:  MULLW  18
08278:  MOVF   FF3,W
0827A:  CLRF   x12
0827C:  MOVWF  x11
0827E:  MOVLW  10
08280:  ADDWF  x11,W
08282:  MOVWF  01
08284:  MOVLW  00
08286:  ADDWFC x12,W
08288:  MOVWF  03
0828A:  MOVF   01,W
0828C:  ADDLW  92
0828E:  MOVWF  FE9
08290:  MOVLW  00
08292:  ADDWFC 03,W
08294:  MOVWF  FEA
08296:  MOVFF  70D,FEF
0829A:  MOVFF  70E,FEC
0829E:  MOVFF  70F,FEC
082A2:  MOVFF  710,FEC
082A6:  BRA    82EE
....................    else if ('5' == arg2) sensorCal[arg1-1].c5 = arg3;
082A8:  MOVF   x0C,W
082AA:  SUBLW  35
082AC:  BNZ   82E4
082AE:  MOVLW  01
082B0:  SUBWF  x0B,W
082B2:  MULLW  18
082B4:  MOVF   FF3,W
082B6:  CLRF   x12
082B8:  MOVWF  x11
082BA:  MOVLW  14
082BC:  ADDWF  x11,W
082BE:  MOVWF  01
082C0:  MOVLW  00
082C2:  ADDWFC x12,W
082C4:  MOVWF  03
082C6:  MOVF   01,W
082C8:  ADDLW  92
082CA:  MOVWF  FE9
082CC:  MOVLW  00
082CE:  ADDWFC 03,W
082D0:  MOVWF  FEA
082D2:  MOVFF  70D,FEF
082D6:  MOVFF  70E,FEC
082DA:  MOVFF  70F,FEC
082DE:  MOVFF  710,FEC
082E2:  BRA    82EE
....................    else return INV_PARAM;
082E4:  MOVLW  02
082E6:  MOVWF  01
082E8:  MOVLB  0
082EA:  BRA    82F4
082EC:  MOVLB  7
....................    
....................    return SUCCESS;
082EE:  MOVLW  00
082F0:  MOVWF  01
082F2:  MOVLB  0
082F4:  RETURN 0
.................... }
.................... 
.................... int8 getMonitorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    char *arg1;
....................    char *s_N15 = "N15";
082F6:  MOVLW  4E
082F8:  MOVLB  7
082FA:  MOVWF  x0F
082FC:  MOVLW  31
082FE:  MOVWF  x10
08300:  MOVLW  35
08302:  MOVWF  x11
08304:  CLRF   x12
08306:  MOVLW  07
08308:  MOVWF  x0E
0830A:  MOVLW  0F
0830C:  MOVWF  x0D
....................    char *s_200 = "200";
0830E:  MOVLW  32
08310:  MOVWF  x15
08312:  MOVLW  30
08314:  MOVWF  x16
08316:  MOVWF  x17
08318:  CLRF   x18
0831A:  MOVLW  07
0831C:  MOVWF  x14
0831E:  MOVLW  15
08320:  MOVWF  x13
....................    char *s_5V6 = "5V6";
08322:  MOVLW  35
08324:  MOVWF  x1B
08326:  MOVLW  56
08328:  MOVWF  x1C
0832A:  MOVLW  36
0832C:  MOVWF  x1D
0832E:  CLRF   x1E
08330:  MOVLW  07
08332:  MOVWF  x1A
08334:  MOVLW  1B
08336:  MOVWF  x19
....................    char *s_5VA = "5VA";
08338:  MOVLW  35
0833A:  MOVWF  x21
0833C:  MOVLW  56
0833E:  MOVWF  x22
08340:  MOVLW  41
08342:  MOVWF  x23
08344:  CLRF   x24
08346:  MOVLW  07
08348:  MOVWF  x20
0834A:  MOVLW  21
0834C:  MOVWF  x1F
....................    char *s_3V6X = "3V6X";
0834E:  MOVLW  33
08350:  MOVWF  x27
08352:  MOVLW  56
08354:  MOVWF  x28
08356:  MOVLW  36
08358:  MOVWF  x29
0835A:  MOVLW  58
0835C:  MOVWF  x2A
0835E:  CLRF   x2B
08360:  MOVLW  07
08362:  MOVWF  x26
08364:  MOVLW  27
08366:  MOVWF  x25
....................    char *s_3V3A = "3V3A";
08368:  MOVLW  33
0836A:  MOVWF  x2E
0836C:  MOVLW  56
0836E:  MOVWF  x2F
08370:  MOVLW  33
08372:  MOVWF  x30
08374:  MOVLW  41
08376:  MOVWF  x31
08378:  CLRF   x32
0837A:  MOVLW  07
0837C:  MOVWF  x2D
0837E:  MOVLW  2E
08380:  MOVWF  x2C
....................    char *s_3V3D = "3V3D";
08382:  MOVLW  33
08384:  MOVWF  x35
08386:  MOVLW  56
08388:  MOVWF  x36
0838A:  MOVLW  33
0838C:  MOVWF  x37
0838E:  MOVLW  44
08390:  MOVWF  x38
08392:  CLRF   x39
08394:  MOVLW  07
08396:  MOVWF  x34
08398:  MOVLW  35
0839A:  MOVWF  x33
.................... //!   char *s_all = "all";
....................    
....................    arg1 = SERcmd[rec].p[2];
0839C:  CLRF   x42
0839E:  MOVFF  690,741
083A2:  CLRF   x44
083A4:  MOVLW  B5
083A6:  MOVWF  x43
083A8:  MOVLB  0
083AA:  CALL   08A6
083AE:  MOVFF  02,73B
083B2:  MOVFF  01,73A
083B6:  MOVLW  06
083B8:  MOVLB  7
083BA:  ADDWF  x3A,F
083BC:  MOVLW  00
083BE:  ADDWFC x3B,F
083C0:  MOVLW  32
083C2:  ADDWF  x3A,W
083C4:  MOVWF  01
083C6:  MOVLW  00
083C8:  ADDWFC x3B,W
083CA:  MOVWF  03
083CC:  MOVF   01,W
083CE:  ADDLW  EB
083D0:  MOVWF  01
083D2:  MOVLW  01
083D4:  ADDWFC 03,F
083D6:  MOVFF  01,70B
083DA:  MOVFF  03,70C
....................    
....................    /*** GET MONITOR VALUES ************/
....................    if      (0 == strcmp(s_N15, arg1)) {
083DE:  MOVFF  70E,742
083E2:  MOVFF  70D,741
083E6:  MOVFF  70C,744
083EA:  MOVFF  70B,743
083EE:  MOVLB  0
083F0:  CALL   5AFC
083F4:  MOVF   01,F
083F6:  BNZ   847A
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.vN15[0],monCal.vN15[1]);
083F8:  MOVLW  04
083FA:  MOVLB  7
083FC:  MOVWF  x42
083FE:  MOVLW  C1
08400:  MOVWF  x41
08402:  MOVLB  0
08404:  CALL   5588
08408:  MOVFF  02,03
0840C:  MOVF   01,W
0840E:  ADDLW  C1
08410:  MOVLB  7
08412:  MOVWF  x3A
08414:  MOVLW  04
08416:  ADDWFC 02,W
08418:  MOVWF  x3B
0841A:  MOVFF  FE8,565
0841E:  MOVFF  73A,564
08422:  MOVLW  89
08424:  MOVWF  FE9
08426:  MOVFF  C5,746
0842A:  MOVFF  C4,745
0842E:  MOVFF  C3,744
08432:  MOVFF  C2,743
08436:  MOVLW  02
08438:  MOVWF  x47
0843A:  MOVLB  0
0843C:  CALL   575E
08440:  MOVLW  2C
08442:  MOVLB  7
08444:  MOVWF  x50
08446:  MOVLB  0
08448:  CALL   55C0
0844C:  MOVLW  89
0844E:  MOVWF  FE9
08450:  MOVFF  C9,746
08454:  MOVFF  C8,745
08458:  MOVFF  C7,744
0845C:  MOVFF  C6,743
08460:  MOVLW  02
08462:  MOVLB  7
08464:  MOVWF  x47
08466:  MOVLB  0
08468:  CALL   575E
0846C:  MOVLW  2C
0846E:  MOVLB  7
08470:  MOVWF  x50
08472:  MOVLB  0
08474:  CALL   55C0
....................    }
08478:  BRA    881C
....................    else if (0 == strcmp(s_200, arg1)) {
0847A:  MOVFF  714,742
0847E:  MOVFF  713,741
08482:  MOVFF  70C,744
08486:  MOVFF  70B,743
0848A:  CALL   5AFC
0848E:  MOVF   01,F
08490:  BNZ   8514
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v200[0],monCal.v200[1]);
08492:  MOVLW  04
08494:  MOVLB  7
08496:  MOVWF  x42
08498:  MOVLW  C1
0849A:  MOVWF  x41
0849C:  MOVLB  0
0849E:  CALL   5588
084A2:  MOVFF  02,03
084A6:  MOVF   01,W
084A8:  ADDLW  C1
084AA:  MOVLB  7
084AC:  MOVWF  x3A
084AE:  MOVLW  04
084B0:  ADDWFC 02,W
084B2:  MOVWF  x3B
084B4:  MOVFF  FE8,565
084B8:  MOVFF  73A,564
084BC:  MOVLW  89
084BE:  MOVWF  FE9
084C0:  MOVFF  CD,746
084C4:  MOVFF  CC,745
084C8:  MOVFF  CB,744
084CC:  MOVFF  CA,743
084D0:  MOVLW  02
084D2:  MOVWF  x47
084D4:  MOVLB  0
084D6:  CALL   575E
084DA:  MOVLW  2C
084DC:  MOVLB  7
084DE:  MOVWF  x50
084E0:  MOVLB  0
084E2:  CALL   55C0
084E6:  MOVLW  89
084E8:  MOVWF  FE9
084EA:  MOVFF  D1,746
084EE:  MOVFF  D0,745
084F2:  MOVFF  CF,744
084F6:  MOVFF  CE,743
084FA:  MOVLW  02
084FC:  MOVLB  7
084FE:  MOVWF  x47
08500:  MOVLB  0
08502:  CALL   575E
08506:  MOVLW  2C
08508:  MOVLB  7
0850A:  MOVWF  x50
0850C:  MOVLB  0
0850E:  CALL   55C0
....................    }
08512:  BRA    881C
....................    else if (0 == strcmp(s_5V6, arg1)) {
08514:  MOVFF  71A,742
08518:  MOVFF  719,741
0851C:  MOVFF  70C,744
08520:  MOVFF  70B,743
08524:  CALL   5AFC
08528:  MOVF   01,F
0852A:  BNZ   85AE
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v5V6[0],monCal.v5V6[1]);
0852C:  MOVLW  04
0852E:  MOVLB  7
08530:  MOVWF  x42
08532:  MOVLW  C1
08534:  MOVWF  x41
08536:  MOVLB  0
08538:  CALL   5588
0853C:  MOVFF  02,03
08540:  MOVF   01,W
08542:  ADDLW  C1
08544:  MOVLB  7
08546:  MOVWF  x3A
08548:  MOVLW  04
0854A:  ADDWFC 02,W
0854C:  MOVWF  x3B
0854E:  MOVFF  FE8,565
08552:  MOVFF  73A,564
08556:  MOVLW  89
08558:  MOVWF  FE9
0855A:  MOVFF  D5,746
0855E:  MOVFF  D4,745
08562:  MOVFF  D3,744
08566:  MOVFF  D2,743
0856A:  MOVLW  02
0856C:  MOVWF  x47
0856E:  MOVLB  0
08570:  CALL   575E
08574:  MOVLW  2C
08576:  MOVLB  7
08578:  MOVWF  x50
0857A:  MOVLB  0
0857C:  CALL   55C0
08580:  MOVLW  89
08582:  MOVWF  FE9
08584:  MOVFF  D9,746
08588:  MOVFF  D8,745
0858C:  MOVFF  D7,744
08590:  MOVFF  D6,743
08594:  MOVLW  02
08596:  MOVLB  7
08598:  MOVWF  x47
0859A:  MOVLB  0
0859C:  CALL   575E
085A0:  MOVLW  2C
085A2:  MOVLB  7
085A4:  MOVWF  x50
085A6:  MOVLB  0
085A8:  CALL   55C0
....................    }
085AC:  BRA    881C
....................    else if (0 == strcmp(s_5VA, arg1)) {
085AE:  MOVFF  720,742
085B2:  MOVFF  71F,741
085B6:  MOVFF  70C,744
085BA:  MOVFF  70B,743
085BE:  CALL   5AFC
085C2:  MOVF   01,F
085C4:  BNZ   8648
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v5VA[0],monCal.v5VA[1]);
085C6:  MOVLW  04
085C8:  MOVLB  7
085CA:  MOVWF  x42
085CC:  MOVLW  C1
085CE:  MOVWF  x41
085D0:  MOVLB  0
085D2:  CALL   5588
085D6:  MOVFF  02,03
085DA:  MOVF   01,W
085DC:  ADDLW  C1
085DE:  MOVLB  7
085E0:  MOVWF  x3A
085E2:  MOVLW  04
085E4:  ADDWFC 02,W
085E6:  MOVWF  x3B
085E8:  MOVFF  FE8,565
085EC:  MOVFF  73A,564
085F0:  MOVLW  89
085F2:  MOVWF  FE9
085F4:  MOVFF  DD,746
085F8:  MOVFF  DC,745
085FC:  MOVFF  DB,744
08600:  MOVFF  DA,743
08604:  MOVLW  02
08606:  MOVWF  x47
08608:  MOVLB  0
0860A:  CALL   575E
0860E:  MOVLW  2C
08610:  MOVLB  7
08612:  MOVWF  x50
08614:  MOVLB  0
08616:  CALL   55C0
0861A:  MOVLW  89
0861C:  MOVWF  FE9
0861E:  MOVFF  E1,746
08622:  MOVFF  E0,745
08626:  MOVFF  DF,744
0862A:  MOVFF  DE,743
0862E:  MOVLW  02
08630:  MOVLB  7
08632:  MOVWF  x47
08634:  MOVLB  0
08636:  CALL   575E
0863A:  MOVLW  2C
0863C:  MOVLB  7
0863E:  MOVWF  x50
08640:  MOVLB  0
08642:  CALL   55C0
....................    }
08646:  BRA    881C
....................    else if (0 == strcmp(s_3V6X, arg1)) {
08648:  MOVFF  726,742
0864C:  MOVFF  725,741
08650:  MOVFF  70C,744
08654:  MOVFF  70B,743
08658:  CALL   5AFC
0865C:  MOVF   01,F
0865E:  BNZ   86E2
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V6X[0],monCal.v3V6X[1]);
08660:  MOVLW  04
08662:  MOVLB  7
08664:  MOVWF  x42
08666:  MOVLW  C1
08668:  MOVWF  x41
0866A:  MOVLB  0
0866C:  CALL   5588
08670:  MOVFF  02,03
08674:  MOVF   01,W
08676:  ADDLW  C1
08678:  MOVLB  7
0867A:  MOVWF  x3A
0867C:  MOVLW  04
0867E:  ADDWFC 02,W
08680:  MOVWF  x3B
08682:  MOVFF  FE8,565
08686:  MOVFF  73A,564
0868A:  MOVLW  89
0868C:  MOVWF  FE9
0868E:  MOVFF  E5,746
08692:  MOVFF  E4,745
08696:  MOVFF  E3,744
0869A:  MOVFF  E2,743
0869E:  MOVLW  02
086A0:  MOVWF  x47
086A2:  MOVLB  0
086A4:  CALL   575E
086A8:  MOVLW  2C
086AA:  MOVLB  7
086AC:  MOVWF  x50
086AE:  MOVLB  0
086B0:  CALL   55C0
086B4:  MOVLW  89
086B6:  MOVWF  FE9
086B8:  MOVFF  E9,746
086BC:  MOVFF  E8,745
086C0:  MOVFF  E7,744
086C4:  MOVFF  E6,743
086C8:  MOVLW  02
086CA:  MOVLB  7
086CC:  MOVWF  x47
086CE:  MOVLB  0
086D0:  CALL   575E
086D4:  MOVLW  2C
086D6:  MOVLB  7
086D8:  MOVWF  x50
086DA:  MOVLB  0
086DC:  CALL   55C0
....................    }
086E0:  BRA    881C
....................    else if (0 == strcmp(s_3V3A, arg1)) {
086E2:  MOVFF  72D,742
086E6:  MOVFF  72C,741
086EA:  MOVFF  70C,744
086EE:  MOVFF  70B,743
086F2:  CALL   5AFC
086F6:  MOVF   01,F
086F8:  BNZ   877C
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3A[0],monCal.v3V3A[1]);
086FA:  MOVLW  04
086FC:  MOVLB  7
086FE:  MOVWF  x42
08700:  MOVLW  C1
08702:  MOVWF  x41
08704:  MOVLB  0
08706:  CALL   5588
0870A:  MOVFF  02,03
0870E:  MOVF   01,W
08710:  ADDLW  C1
08712:  MOVLB  7
08714:  MOVWF  x3A
08716:  MOVLW  04
08718:  ADDWFC 02,W
0871A:  MOVWF  x3B
0871C:  MOVFF  FE8,565
08720:  MOVFF  73A,564
08724:  MOVLW  89
08726:  MOVWF  FE9
08728:  MOVFF  ED,746
0872C:  MOVFF  EC,745
08730:  MOVFF  EB,744
08734:  MOVFF  EA,743
08738:  MOVLW  02
0873A:  MOVWF  x47
0873C:  MOVLB  0
0873E:  CALL   575E
08742:  MOVLW  2C
08744:  MOVLB  7
08746:  MOVWF  x50
08748:  MOVLB  0
0874A:  CALL   55C0
0874E:  MOVLW  89
08750:  MOVWF  FE9
08752:  MOVFF  F1,746
08756:  MOVFF  F0,745
0875A:  MOVFF  EF,744
0875E:  MOVFF  EE,743
08762:  MOVLW  02
08764:  MOVLB  7
08766:  MOVWF  x47
08768:  MOVLB  0
0876A:  CALL   575E
0876E:  MOVLW  2C
08770:  MOVLB  7
08772:  MOVWF  x50
08774:  MOVLB  0
08776:  CALL   55C0
....................    }
0877A:  BRA    881C
....................    else if (0 == strcmp(s_3V3D, arg1)) {
0877C:  MOVFF  734,742
08780:  MOVFF  733,741
08784:  MOVFF  70C,744
08788:  MOVFF  70B,743
0878C:  CALL   5AFC
08790:  MOVF   01,F
08792:  BNZ   8816
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3D[0],monCal.v3V3D[1]);
08794:  MOVLW  04
08796:  MOVLB  7
08798:  MOVWF  x42
0879A:  MOVLW  C1
0879C:  MOVWF  x41
0879E:  MOVLB  0
087A0:  CALL   5588
087A4:  MOVFF  02,03
087A8:  MOVF   01,W
087AA:  ADDLW  C1
087AC:  MOVLB  7
087AE:  MOVWF  x3A
087B0:  MOVLW  04
087B2:  ADDWFC 02,W
087B4:  MOVWF  x3B
087B6:  MOVFF  FE8,565
087BA:  MOVFF  73A,564
087BE:  MOVLW  89
087C0:  MOVWF  FE9
087C2:  MOVFF  F5,746
087C6:  MOVFF  F4,745
087CA:  MOVFF  F3,744
087CE:  MOVFF  F2,743
087D2:  MOVLW  02
087D4:  MOVWF  x47
087D6:  MOVLB  0
087D8:  CALL   575E
087DC:  MOVLW  2C
087DE:  MOVLB  7
087E0:  MOVWF  x50
087E2:  MOVLB  0
087E4:  CALL   55C0
087E8:  MOVLW  89
087EA:  MOVWF  FE9
087EC:  MOVFF  F9,746
087F0:  MOVFF  F8,745
087F4:  MOVFF  F7,744
087F8:  MOVFF  F6,743
087FC:  MOVLW  02
087FE:  MOVLB  7
08800:  MOVWF  x47
08802:  MOVLB  0
08804:  CALL   575E
08808:  MOVLW  2C
0880A:  MOVLB  7
0880C:  MOVWF  x50
0880E:  MOVLB  0
08810:  CALL   55C0
....................    }
08814:  BRA    881C
....................    else return INV_PARAM;
08816:  MOVLW  02
08818:  MOVWF  01
0881A:  BRA    8820
....................    
....................    return SUCCESS;
0881C:  MOVLW  00
0881E:  MOVWF  01
08820:  RETURN 0
.................... }
.................... 
.................... int8 setMonitorCalParam(unsigned int8 rec){
....................    return SUCCESS;
08822:  MOVLW  00
08824:  MOVWF  01
08826:  RETURN 0
.................... }
.................... 
.................... int8 getMonitorValue(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    char *arg1;
....................    char *s_N15 = "N15";
08828:  MOVLW  4E
0882A:  MOVLB  7
0882C:  MOVWF  x0F
0882E:  MOVLW  31
08830:  MOVWF  x10
08832:  MOVLW  35
08834:  MOVWF  x11
08836:  CLRF   x12
08838:  MOVLW  07
0883A:  MOVWF  x0E
0883C:  MOVLW  0F
0883E:  MOVWF  x0D
....................    char *s_200 = "200";
08840:  MOVLW  32
08842:  MOVWF  x15
08844:  MOVLW  30
08846:  MOVWF  x16
08848:  MOVWF  x17
0884A:  CLRF   x18
0884C:  MOVLW  07
0884E:  MOVWF  x14
08850:  MOVLW  15
08852:  MOVWF  x13
....................    char *s_5V6 = "5V6";
08854:  MOVLW  35
08856:  MOVWF  x1B
08858:  MOVLW  56
0885A:  MOVWF  x1C
0885C:  MOVLW  36
0885E:  MOVWF  x1D
08860:  CLRF   x1E
08862:  MOVLW  07
08864:  MOVWF  x1A
08866:  MOVLW  1B
08868:  MOVWF  x19
....................    char *s_5VA = "5VA";
0886A:  MOVLW  35
0886C:  MOVWF  x21
0886E:  MOVLW  56
08870:  MOVWF  x22
08872:  MOVLW  41
08874:  MOVWF  x23
08876:  CLRF   x24
08878:  MOVLW  07
0887A:  MOVWF  x20
0887C:  MOVLW  21
0887E:  MOVWF  x1F
....................    char *s_3V6X = "3V6X";
08880:  MOVLW  33
08882:  MOVWF  x27
08884:  MOVLW  56
08886:  MOVWF  x28
08888:  MOVLW  36
0888A:  MOVWF  x29
0888C:  MOVLW  58
0888E:  MOVWF  x2A
08890:  CLRF   x2B
08892:  MOVLW  07
08894:  MOVWF  x26
08896:  MOVLW  27
08898:  MOVWF  x25
....................    char *s_3V3A = "3V3A";
0889A:  MOVLW  33
0889C:  MOVWF  x2E
0889E:  MOVLW  56
088A0:  MOVWF  x2F
088A2:  MOVLW  33
088A4:  MOVWF  x30
088A6:  MOVLW  41
088A8:  MOVWF  x31
088AA:  CLRF   x32
088AC:  MOVLW  07
088AE:  MOVWF  x2D
088B0:  MOVLW  2E
088B2:  MOVWF  x2C
....................    char *s_3V3D = "3V3D";
088B4:  MOVLW  33
088B6:  MOVWF  x35
088B8:  MOVLW  56
088BA:  MOVWF  x36
088BC:  MOVLW  33
088BE:  MOVWF  x37
088C0:  MOVLW  44
088C2:  MOVWF  x38
088C4:  CLRF   x39
088C6:  MOVLW  07
088C8:  MOVWF  x34
088CA:  MOVLW  35
088CC:  MOVWF  x33
....................    char *s_all = "all";
088CE:  MOVLW  61
088D0:  MOVWF  x3C
088D2:  MOVLW  6C
088D4:  MOVWF  x3D
088D6:  MOVWF  x3E
088D8:  CLRF   x3F
088DA:  MOVLW  07
088DC:  MOVWF  x3B
088DE:  MOVLW  3C
088E0:  MOVWF  x3A
....................    
....................    arg1 = SERcmd[rec].p[2];
088E2:  CLRF   x42
088E4:  MOVFF  690,741
088E8:  CLRF   x44
088EA:  MOVLW  B5
088EC:  MOVWF  x43
088EE:  MOVLB  0
088F0:  CALL   08A6
088F4:  MOVFF  02,741
088F8:  MOVFF  01,740
088FC:  MOVLW  06
088FE:  MOVLB  7
08900:  ADDWF  x40,F
08902:  MOVLW  00
08904:  ADDWFC x41,F
08906:  MOVLW  32
08908:  ADDWF  x40,W
0890A:  MOVWF  01
0890C:  MOVLW  00
0890E:  ADDWFC x41,W
08910:  MOVWF  03
08912:  MOVF   01,W
08914:  ADDLW  EB
08916:  MOVWF  01
08918:  MOVLW  01
0891A:  ADDWFC 03,F
0891C:  MOVFF  01,70B
08920:  MOVFF  03,70C
....................    
....................    /*** GET MONITOR VALUES ************/
....................    if      (0 == strcmp(s_N15, arg1)) {
08924:  MOVFF  70E,742
08928:  MOVFF  70D,741
0892C:  MOVFF  70C,744
08930:  MOVFF  70B,743
08934:  MOVLB  0
08936:  CALL   5AFC
0893A:  MOVF   01,F
0893C:  BNZ   8994
....................       sprintf(retData+strlen(retData), "%.2f,", monitorVals.vN15);
0893E:  MOVLW  04
08940:  MOVLB  7
08942:  MOVWF  x42
08944:  MOVLW  C1
08946:  MOVWF  x41
08948:  MOVLB  0
0894A:  CALL   5588
0894E:  MOVFF  02,03
08952:  MOVF   01,W
08954:  ADDLW  C1
08956:  MOVLB  7
08958:  MOVWF  x40
0895A:  MOVLW  04
0895C:  ADDWFC 02,W
0895E:  MOVWF  x41
08960:  MOVFF  FE8,565
08964:  MOVFF  740,564
08968:  MOVLW  89
0896A:  MOVWF  FE9
0896C:  MOVFF  FE,746
08970:  MOVFF  FD,745
08974:  MOVFF  FC,744
08978:  MOVFF  FB,743
0897C:  MOVLW  02
0897E:  MOVWF  x47
08980:  MOVLB  0
08982:  CALL   575E
08986:  MOVLW  2C
08988:  MOVLB  7
0898A:  MOVWF  x50
0898C:  MOVLB  0
0898E:  CALL   55C0
....................    }
08992:  BRA    8E96
....................    else if (0 == strcmp(s_200, arg1)) {
08994:  MOVFF  714,742
08998:  MOVFF  713,741
0899C:  MOVFF  70C,744
089A0:  MOVFF  70B,743
089A4:  CALL   5AFC
089A8:  MOVF   01,F
089AA:  BNZ   8A02
....................       sprintf(retData+strlen(retData), "%.1f,", monitorVals.v200);
089AC:  MOVLW  04
089AE:  MOVLB  7
089B0:  MOVWF  x42
089B2:  MOVLW  C1
089B4:  MOVWF  x41
089B6:  MOVLB  0
089B8:  CALL   5588
089BC:  MOVFF  02,03
089C0:  MOVF   01,W
089C2:  ADDLW  C1
089C4:  MOVLB  7
089C6:  MOVWF  x40
089C8:  MOVLW  04
089CA:  ADDWFC 02,W
089CC:  MOVWF  x41
089CE:  MOVFF  FE8,565
089D2:  MOVFF  740,564
089D6:  MOVLW  89
089D8:  MOVWF  FE9
089DA:  MOVFF  102,746
089DE:  MOVFF  101,745
089E2:  MOVFF  100,744
089E6:  MOVFF  FF,743
089EA:  MOVLW  01
089EC:  MOVWF  x47
089EE:  MOVLB  0
089F0:  CALL   575E
089F4:  MOVLW  2C
089F6:  MOVLB  7
089F8:  MOVWF  x50
089FA:  MOVLB  0
089FC:  CALL   55C0
....................    }
08A00:  BRA    8E96
....................    else if (0 == strcmp(s_5V6, arg1)) {
08A02:  MOVFF  71A,742
08A06:  MOVFF  719,741
08A0A:  MOVFF  70C,744
08A0E:  MOVFF  70B,743
08A12:  CALL   5AFC
08A16:  MOVF   01,F
08A18:  BNZ   8A70
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5V6);
08A1A:  MOVLW  04
08A1C:  MOVLB  7
08A1E:  MOVWF  x42
08A20:  MOVLW  C1
08A22:  MOVWF  x41
08A24:  MOVLB  0
08A26:  CALL   5588
08A2A:  MOVFF  02,03
08A2E:  MOVF   01,W
08A30:  ADDLW  C1
08A32:  MOVLB  7
08A34:  MOVWF  x40
08A36:  MOVLW  04
08A38:  ADDWFC 02,W
08A3A:  MOVWF  x41
08A3C:  MOVFF  FE8,565
08A40:  MOVFF  740,564
08A44:  MOVLW  89
08A46:  MOVWF  FE9
08A48:  MOVFF  106,746
08A4C:  MOVFF  105,745
08A50:  MOVFF  104,744
08A54:  MOVFF  103,743
08A58:  MOVLW  03
08A5A:  MOVWF  x47
08A5C:  MOVLB  0
08A5E:  CALL   575E
08A62:  MOVLW  2C
08A64:  MOVLB  7
08A66:  MOVWF  x50
08A68:  MOVLB  0
08A6A:  CALL   55C0
....................    }
08A6E:  BRA    8E96
....................    else if (0 == strcmp(s_5VA, arg1)) {
08A70:  MOVFF  720,742
08A74:  MOVFF  71F,741
08A78:  MOVFF  70C,744
08A7C:  MOVFF  70B,743
08A80:  CALL   5AFC
08A84:  MOVF   01,F
08A86:  BNZ   8ADE
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5VA);
08A88:  MOVLW  04
08A8A:  MOVLB  7
08A8C:  MOVWF  x42
08A8E:  MOVLW  C1
08A90:  MOVWF  x41
08A92:  MOVLB  0
08A94:  CALL   5588
08A98:  MOVFF  02,03
08A9C:  MOVF   01,W
08A9E:  ADDLW  C1
08AA0:  MOVLB  7
08AA2:  MOVWF  x40
08AA4:  MOVLW  04
08AA6:  ADDWFC 02,W
08AA8:  MOVWF  x41
08AAA:  MOVFF  FE8,565
08AAE:  MOVFF  740,564
08AB2:  MOVLW  89
08AB4:  MOVWF  FE9
08AB6:  MOVFF  10A,746
08ABA:  MOVFF  109,745
08ABE:  MOVFF  108,744
08AC2:  MOVFF  107,743
08AC6:  MOVLW  03
08AC8:  MOVWF  x47
08ACA:  MOVLB  0
08ACC:  CALL   575E
08AD0:  MOVLW  2C
08AD2:  MOVLB  7
08AD4:  MOVWF  x50
08AD6:  MOVLB  0
08AD8:  CALL   55C0
....................    }
08ADC:  BRA    8E96
....................    else if (0 == strcmp(s_3V6X, arg1)) {
08ADE:  MOVFF  726,742
08AE2:  MOVFF  725,741
08AE6:  MOVFF  70C,744
08AEA:  MOVFF  70B,743
08AEE:  CALL   5AFC
08AF2:  MOVF   01,F
08AF4:  BNZ   8B4C
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V6X);
08AF6:  MOVLW  04
08AF8:  MOVLB  7
08AFA:  MOVWF  x42
08AFC:  MOVLW  C1
08AFE:  MOVWF  x41
08B00:  MOVLB  0
08B02:  CALL   5588
08B06:  MOVFF  02,03
08B0A:  MOVF   01,W
08B0C:  ADDLW  C1
08B0E:  MOVLB  7
08B10:  MOVWF  x40
08B12:  MOVLW  04
08B14:  ADDWFC 02,W
08B16:  MOVWF  x41
08B18:  MOVFF  FE8,565
08B1C:  MOVFF  740,564
08B20:  MOVLW  89
08B22:  MOVWF  FE9
08B24:  MOVFF  10E,746
08B28:  MOVFF  10D,745
08B2C:  MOVFF  10C,744
08B30:  MOVFF  10B,743
08B34:  MOVLW  03
08B36:  MOVWF  x47
08B38:  MOVLB  0
08B3A:  CALL   575E
08B3E:  MOVLW  2C
08B40:  MOVLB  7
08B42:  MOVWF  x50
08B44:  MOVLB  0
08B46:  CALL   55C0
....................    }
08B4A:  BRA    8E96
....................    else if (0 == strcmp(s_3V3A, arg1)) {
08B4C:  MOVFF  72D,742
08B50:  MOVFF  72C,741
08B54:  MOVFF  70C,744
08B58:  MOVFF  70B,743
08B5C:  CALL   5AFC
08B60:  MOVF   01,F
08B62:  BNZ   8BBA
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3A);
08B64:  MOVLW  04
08B66:  MOVLB  7
08B68:  MOVWF  x42
08B6A:  MOVLW  C1
08B6C:  MOVWF  x41
08B6E:  MOVLB  0
08B70:  CALL   5588
08B74:  MOVFF  02,03
08B78:  MOVF   01,W
08B7A:  ADDLW  C1
08B7C:  MOVLB  7
08B7E:  MOVWF  x40
08B80:  MOVLW  04
08B82:  ADDWFC 02,W
08B84:  MOVWF  x41
08B86:  MOVFF  FE8,565
08B8A:  MOVFF  740,564
08B8E:  MOVLW  89
08B90:  MOVWF  FE9
08B92:  MOVFF  112,746
08B96:  MOVFF  111,745
08B9A:  MOVFF  110,744
08B9E:  MOVFF  10F,743
08BA2:  MOVLW  03
08BA4:  MOVWF  x47
08BA6:  MOVLB  0
08BA8:  CALL   575E
08BAC:  MOVLW  2C
08BAE:  MOVLB  7
08BB0:  MOVWF  x50
08BB2:  MOVLB  0
08BB4:  CALL   55C0
....................    }
08BB8:  BRA    8E96
....................    else if (0 == strcmp(s_3V3D, arg1)) {
08BBA:  MOVFF  734,742
08BBE:  MOVFF  733,741
08BC2:  MOVFF  70C,744
08BC6:  MOVFF  70B,743
08BCA:  CALL   5AFC
08BCE:  MOVF   01,F
08BD0:  BNZ   8C28
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3D);
08BD2:  MOVLW  04
08BD4:  MOVLB  7
08BD6:  MOVWF  x42
08BD8:  MOVLW  C1
08BDA:  MOVWF  x41
08BDC:  MOVLB  0
08BDE:  CALL   5588
08BE2:  MOVFF  02,03
08BE6:  MOVF   01,W
08BE8:  ADDLW  C1
08BEA:  MOVLB  7
08BEC:  MOVWF  x40
08BEE:  MOVLW  04
08BF0:  ADDWFC 02,W
08BF2:  MOVWF  x41
08BF4:  MOVFF  FE8,565
08BF8:  MOVFF  740,564
08BFC:  MOVLW  89
08BFE:  MOVWF  FE9
08C00:  MOVFF  116,746
08C04:  MOVFF  115,745
08C08:  MOVFF  114,744
08C0C:  MOVFF  113,743
08C10:  MOVLW  03
08C12:  MOVWF  x47
08C14:  MOVLB  0
08C16:  CALL   575E
08C1A:  MOVLW  2C
08C1C:  MOVLB  7
08C1E:  MOVWF  x50
08C20:  MOVLB  0
08C22:  CALL   55C0
....................    }
08C26:  BRA    8E96
....................    else if (0 == strcmp(s_all, arg1)) {
08C28:  MOVFF  73B,742
08C2C:  MOVFF  73A,741
08C30:  MOVFF  70C,744
08C34:  MOVFF  70B,743
08C38:  CALL   5AFC
08C3C:  MOVF   01,F
08C3E:  BTFSS  FD8.2
08C40:  BRA    8E90
....................       sprintf(retData+strlen(retData), "%.2f,", monitorVals.vN15);
08C42:  MOVLW  04
08C44:  MOVLB  7
08C46:  MOVWF  x42
08C48:  MOVLW  C1
08C4A:  MOVWF  x41
08C4C:  MOVLB  0
08C4E:  CALL   5588
08C52:  MOVFF  02,03
08C56:  MOVF   01,W
08C58:  ADDLW  C1
08C5A:  MOVLB  7
08C5C:  MOVWF  x40
08C5E:  MOVLW  04
08C60:  ADDWFC 02,W
08C62:  MOVWF  x41
08C64:  MOVFF  FE8,565
08C68:  MOVFF  740,564
08C6C:  MOVLW  89
08C6E:  MOVWF  FE9
08C70:  MOVFF  FE,746
08C74:  MOVFF  FD,745
08C78:  MOVFF  FC,744
08C7C:  MOVFF  FB,743
08C80:  MOVLW  02
08C82:  MOVWF  x47
08C84:  MOVLB  0
08C86:  CALL   575E
08C8A:  MOVLW  2C
08C8C:  MOVLB  7
08C8E:  MOVWF  x50
08C90:  MOVLB  0
08C92:  CALL   55C0
....................       sprintf(retData+strlen(retData), "%.1f,", monitorVals.v200);
08C96:  MOVLW  04
08C98:  MOVLB  7
08C9A:  MOVWF  x42
08C9C:  MOVLW  C1
08C9E:  MOVWF  x41
08CA0:  MOVLB  0
08CA2:  CALL   5588
08CA6:  MOVFF  02,03
08CAA:  MOVF   01,W
08CAC:  ADDLW  C1
08CAE:  MOVLB  7
08CB0:  MOVWF  x40
08CB2:  MOVLW  04
08CB4:  ADDWFC 02,W
08CB6:  MOVWF  x41
08CB8:  MOVFF  FE8,565
08CBC:  MOVFF  740,564
08CC0:  MOVLW  89
08CC2:  MOVWF  FE9
08CC4:  MOVFF  102,746
08CC8:  MOVFF  101,745
08CCC:  MOVFF  100,744
08CD0:  MOVFF  FF,743
08CD4:  MOVLW  01
08CD6:  MOVWF  x47
08CD8:  MOVLB  0
08CDA:  CALL   575E
08CDE:  MOVLW  2C
08CE0:  MOVLB  7
08CE2:  MOVWF  x50
08CE4:  MOVLB  0
08CE6:  CALL   55C0
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5V6);
08CEA:  MOVLW  04
08CEC:  MOVLB  7
08CEE:  MOVWF  x42
08CF0:  MOVLW  C1
08CF2:  MOVWF  x41
08CF4:  MOVLB  0
08CF6:  CALL   5588
08CFA:  MOVFF  02,03
08CFE:  MOVF   01,W
08D00:  ADDLW  C1
08D02:  MOVLB  7
08D04:  MOVWF  x40
08D06:  MOVLW  04
08D08:  ADDWFC 02,W
08D0A:  MOVWF  x41
08D0C:  MOVFF  FE8,565
08D10:  MOVFF  740,564
08D14:  MOVLW  89
08D16:  MOVWF  FE9
08D18:  MOVFF  106,746
08D1C:  MOVFF  105,745
08D20:  MOVFF  104,744
08D24:  MOVFF  103,743
08D28:  MOVLW  03
08D2A:  MOVWF  x47
08D2C:  MOVLB  0
08D2E:  CALL   575E
08D32:  MOVLW  2C
08D34:  MOVLB  7
08D36:  MOVWF  x50
08D38:  MOVLB  0
08D3A:  CALL   55C0
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5VA);
08D3E:  MOVLW  04
08D40:  MOVLB  7
08D42:  MOVWF  x42
08D44:  MOVLW  C1
08D46:  MOVWF  x41
08D48:  MOVLB  0
08D4A:  CALL   5588
08D4E:  MOVFF  02,03
08D52:  MOVF   01,W
08D54:  ADDLW  C1
08D56:  MOVLB  7
08D58:  MOVWF  x40
08D5A:  MOVLW  04
08D5C:  ADDWFC 02,W
08D5E:  MOVWF  x41
08D60:  MOVFF  FE8,565
08D64:  MOVFF  740,564
08D68:  MOVLW  89
08D6A:  MOVWF  FE9
08D6C:  MOVFF  10A,746
08D70:  MOVFF  109,745
08D74:  MOVFF  108,744
08D78:  MOVFF  107,743
08D7C:  MOVLW  03
08D7E:  MOVWF  x47
08D80:  MOVLB  0
08D82:  CALL   575E
08D86:  MOVLW  2C
08D88:  MOVLB  7
08D8A:  MOVWF  x50
08D8C:  MOVLB  0
08D8E:  CALL   55C0
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V6X);
08D92:  MOVLW  04
08D94:  MOVLB  7
08D96:  MOVWF  x42
08D98:  MOVLW  C1
08D9A:  MOVWF  x41
08D9C:  MOVLB  0
08D9E:  CALL   5588
08DA2:  MOVFF  02,03
08DA6:  MOVF   01,W
08DA8:  ADDLW  C1
08DAA:  MOVLB  7
08DAC:  MOVWF  x40
08DAE:  MOVLW  04
08DB0:  ADDWFC 02,W
08DB2:  MOVWF  x41
08DB4:  MOVFF  FE8,565
08DB8:  MOVFF  740,564
08DBC:  MOVLW  89
08DBE:  MOVWF  FE9
08DC0:  MOVFF  10E,746
08DC4:  MOVFF  10D,745
08DC8:  MOVFF  10C,744
08DCC:  MOVFF  10B,743
08DD0:  MOVLW  03
08DD2:  MOVWF  x47
08DD4:  MOVLB  0
08DD6:  CALL   575E
08DDA:  MOVLW  2C
08DDC:  MOVLB  7
08DDE:  MOVWF  x50
08DE0:  MOVLB  0
08DE2:  CALL   55C0
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3A);
08DE6:  MOVLW  04
08DE8:  MOVLB  7
08DEA:  MOVWF  x42
08DEC:  MOVLW  C1
08DEE:  MOVWF  x41
08DF0:  MOVLB  0
08DF2:  CALL   5588
08DF6:  MOVFF  02,03
08DFA:  MOVF   01,W
08DFC:  ADDLW  C1
08DFE:  MOVLB  7
08E00:  MOVWF  x40
08E02:  MOVLW  04
08E04:  ADDWFC 02,W
08E06:  MOVWF  x41
08E08:  MOVFF  FE8,565
08E0C:  MOVFF  740,564
08E10:  MOVLW  89
08E12:  MOVWF  FE9
08E14:  MOVFF  112,746
08E18:  MOVFF  111,745
08E1C:  MOVFF  110,744
08E20:  MOVFF  10F,743
08E24:  MOVLW  03
08E26:  MOVWF  x47
08E28:  MOVLB  0
08E2A:  CALL   575E
08E2E:  MOVLW  2C
08E30:  MOVLB  7
08E32:  MOVWF  x50
08E34:  MOVLB  0
08E36:  CALL   55C0
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3D);
08E3A:  MOVLW  04
08E3C:  MOVLB  7
08E3E:  MOVWF  x42
08E40:  MOVLW  C1
08E42:  MOVWF  x41
08E44:  MOVLB  0
08E46:  CALL   5588
08E4A:  MOVFF  02,03
08E4E:  MOVF   01,W
08E50:  ADDLW  C1
08E52:  MOVLB  7
08E54:  MOVWF  x40
08E56:  MOVLW  04
08E58:  ADDWFC 02,W
08E5A:  MOVWF  x41
08E5C:  MOVFF  FE8,565
08E60:  MOVFF  740,564
08E64:  MOVLW  89
08E66:  MOVWF  FE9
08E68:  MOVFF  116,746
08E6C:  MOVFF  115,745
08E70:  MOVFF  114,744
08E74:  MOVFF  113,743
08E78:  MOVLW  03
08E7A:  MOVWF  x47
08E7C:  MOVLB  0
08E7E:  CALL   575E
08E82:  MOVLW  2C
08E84:  MOVLB  7
08E86:  MOVWF  x50
08E88:  MOVLB  0
08E8A:  CALL   55C0
....................    }
08E8E:  BRA    8E96
....................    else return INV_PARAM;
08E90:  MOVLW  02
08E92:  MOVWF  01
08E94:  BRA    8E9A
....................    
....................    return SUCCESS;
08E96:  MOVLW  00
08E98:  MOVWF  01
08E9A:  RETURN 0
.................... }
.................... 
.................... int8 getPIDdata(unsigned int8 rec){
....................   /*** ARG CHECKS ********************/ 
....................    int8 arg1;
....................    char *arg2;
....................    char *s_PV = "PV";
08E9C:  MOVLW  50
08E9E:  MOVLB  7
08EA0:  MOVWF  x10
08EA2:  MOVLW  56
08EA4:  MOVWF  x11
08EA6:  CLRF   x12
08EA8:  MOVLW  07
08EAA:  MOVWF  x0F
08EAC:  MOVLW  10
08EAE:  MOVWF  x0E
....................    char *s_CV = "CV";
08EB0:  MOVLW  43
08EB2:  MOVWF  x15
08EB4:  MOVLW  56
08EB6:  MOVWF  x16
08EB8:  CLRF   x17
08EBA:  MOVLW  07
08EBC:  MOVWF  x14
08EBE:  MOVLW  15
08EC0:  MOVWF  x13
....................    char *s_PVold = "PVold";
08EC2:  MOVLW  50
08EC4:  MOVWF  x1A
08EC6:  MOVLW  56
08EC8:  MOVWF  x1B
08ECA:  MOVLW  6F
08ECC:  MOVWF  x1C
08ECE:  MOVLW  6C
08ED0:  MOVWF  x1D
08ED2:  MOVLW  64
08ED4:  MOVWF  x1E
08ED6:  CLRF   x1F
08ED8:  MOVLW  07
08EDA:  MOVWF  x19
08EDC:  MOVLW  1A
08EDE:  MOVWF  x18
....................    char *s_I = "I";
08EE0:  MOVLW  49
08EE2:  MOVWF  x22
08EE4:  CLRF   x23
08EE6:  MOVLW  07
08EE8:  MOVWF  x21
08EEA:  MOVLW  22
08EEC:  MOVWF  x20
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
08EEE:  CLRF   x42
08EF0:  MOVFF  690,741
08EF4:  CLRF   x44
08EF6:  MOVLW  B5
08EF8:  MOVWF  x43
08EFA:  MOVLB  0
08EFC:  CALL   08A6
08F00:  MOVFF  02,725
08F04:  MOVFF  01,724
08F08:  MOVLW  06
08F0A:  MOVLB  7
08F0C:  ADDWF  x24,F
08F0E:  MOVLW  00
08F10:  ADDWFC x25,F
08F12:  MOVLW  32
08F14:  ADDWF  x24,W
08F16:  MOVWF  01
08F18:  MOVLW  00
08F1A:  ADDWFC x25,W
08F1C:  MOVWF  03
08F1E:  MOVF   01,W
08F20:  ADDLW  EB
08F22:  MOVWF  01
08F24:  MOVLW  01
08F26:  ADDWFC 03,F
08F28:  MOVFF  01,724
08F2C:  MOVFF  03,725
08F30:  MOVFF  03,734
08F34:  MOVFF  01,733
08F38:  MOVLB  0
08F3A:  CALL   5C1C
08F3E:  MOVF   01,F
08F40:  BNZ   8F4A
08F42:  MOVLW  02
08F44:  MOVWF  01
08F46:  BRA    92E0
08F48:  BRA    8FA8
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
08F4A:  MOVLB  7
08F4C:  CLRF   x42
08F4E:  MOVFF  690,741
08F52:  CLRF   x44
08F54:  MOVLW  B5
08F56:  MOVWF  x43
08F58:  MOVLB  0
08F5A:  CALL   08A6
08F5E:  MOVFF  02,725
08F62:  MOVFF  01,724
08F66:  MOVLW  06
08F68:  MOVLB  7
08F6A:  ADDWF  x24,F
08F6C:  MOVLW  00
08F6E:  ADDWFC x25,F
08F70:  MOVLW  32
08F72:  ADDWF  x24,W
08F74:  MOVWF  01
08F76:  MOVLW  00
08F78:  ADDWFC x25,W
08F7A:  MOVWF  03
08F7C:  MOVF   01,W
08F7E:  ADDLW  EB
08F80:  MOVWF  01
08F82:  MOVLW  01
08F84:  ADDWFC 03,F
08F86:  MOVFF  01,724
08F8A:  MOVFF  03,725
08F8E:  MOVFF  03,734
08F92:  MOVFF  01,733
08F96:  CLRF   x36
08F98:  CLRF   x35
08F9A:  MOVLW  0A
08F9C:  MOVWF  x37
08F9E:  MOVLB  0
08FA0:  CALL   5D0C
08FA4:  MOVFF  01,70B
....................    
....................    arg2 = SERcmd[rec].p[3];
08FA8:  MOVLB  7
08FAA:  CLRF   x42
08FAC:  MOVFF  690,741
08FB0:  CLRF   x44
08FB2:  MOVLW  B5
08FB4:  MOVWF  x43
08FB6:  MOVLB  0
08FB8:  CALL   08A6
08FBC:  MOVFF  02,725
08FC0:  MOVFF  01,724
08FC4:  MOVLW  06
08FC6:  MOVLB  7
08FC8:  ADDWF  x24,F
08FCA:  MOVLW  00
08FCC:  ADDWFC x25,F
08FCE:  MOVLW  4B
08FD0:  ADDWF  x24,W
08FD2:  MOVWF  01
08FD4:  MOVLW  00
08FD6:  ADDWFC x25,W
08FD8:  MOVWF  03
08FDA:  MOVF   01,W
08FDC:  ADDLW  EB
08FDE:  MOVWF  01
08FE0:  MOVLW  01
08FE2:  ADDWFC 03,F
08FE4:  MOVFF  01,70C
08FE8:  MOVFF  03,70D
....................    
....................    /*** GET PV, CV, PVold, I, or A(LL) VALUE **********/
....................    if      (0 == strcmp(s_PV, arg2))     sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].PV);
08FEC:  MOVFF  70F,742
08FF0:  MOVFF  70E,741
08FF4:  MOVFF  70D,744
08FF8:  MOVFF  70C,743
08FFC:  MOVLB  0
08FFE:  CALL   5AFC
09002:  MOVF   01,F
09004:  BNZ   90A8
09006:  MOVLW  04
09008:  MOVLB  7
0900A:  MOVWF  x42
0900C:  MOVLW  C1
0900E:  MOVWF  x41
09010:  MOVLB  0
09012:  CALL   5588
09016:  MOVF   01,W
09018:  ADDLW  C1
0901A:  MOVLB  7
0901C:  MOVWF  x24
0901E:  MOVLW  04
09020:  ADDWFC 02,W
09022:  MOVWF  x25
09024:  MOVLW  01
09026:  SUBWF  x0B,W
09028:  MULLW  28
0902A:  MOVF   FF3,W
0902C:  CLRF   x27
0902E:  MOVWF  x26
09030:  MOVLW  10
09032:  ADDWF  x26,W
09034:  MOVWF  01
09036:  MOVLW  00
09038:  ADDWFC x27,W
0903A:  MOVWF  03
0903C:  MOVF   01,W
0903E:  ADDLW  20
09040:  MOVWF  FE9
09042:  MOVLW  00
09044:  ADDWFC 03,W
09046:  MOVWF  FEA
09048:  MOVFF  FEF,726
0904C:  MOVFF  FEC,727
09050:  MOVFF  FEC,728
09054:  MOVFF  FEC,729
09058:  MOVFF  725,565
0905C:  MOVFF  724,564
09060:  MOVFF  70B,734
09064:  MOVLW  18
09066:  MOVWF  x35
09068:  MOVLB  0
0906A:  CALL   6060
0906E:  MOVLW  2C
09070:  MOVLB  7
09072:  MOVWF  x50
09074:  MOVLB  0
09076:  CALL   55C0
0907A:  MOVLW  89
0907C:  MOVWF  FE9
0907E:  MOVFF  729,746
09082:  MOVFF  728,745
09086:  MOVFF  727,744
0908A:  MOVFF  726,743
0908E:  MOVLW  02
09090:  MOVLB  7
09092:  MOVWF  x47
09094:  MOVLB  0
09096:  CALL   575E
0909A:  MOVLW  2C
0909C:  MOVLB  7
0909E:  MOVWF  x50
090A0:  MOVLB  0
090A2:  CALL   55C0
090A6:  BRA    92DC
....................    else if (0 == strcmp(s_CV, arg2))     sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].CV);
090A8:  MOVFF  714,742
090AC:  MOVFF  713,741
090B0:  MOVFF  70D,744
090B4:  MOVFF  70C,743
090B8:  CALL   5AFC
090BC:  MOVF   01,F
090BE:  BNZ   9162
090C0:  MOVLW  04
090C2:  MOVLB  7
090C4:  MOVWF  x42
090C6:  MOVLW  C1
090C8:  MOVWF  x41
090CA:  MOVLB  0
090CC:  CALL   5588
090D0:  MOVF   01,W
090D2:  ADDLW  C1
090D4:  MOVLB  7
090D6:  MOVWF  x24
090D8:  MOVLW  04
090DA:  ADDWFC 02,W
090DC:  MOVWF  x25
090DE:  MOVLW  01
090E0:  SUBWF  x0B,W
090E2:  MULLW  28
090E4:  MOVF   FF3,W
090E6:  CLRF   x27
090E8:  MOVWF  x26
090EA:  MOVLW  18
090EC:  ADDWF  x26,W
090EE:  MOVWF  01
090F0:  MOVLW  00
090F2:  ADDWFC x27,W
090F4:  MOVWF  03
090F6:  MOVF   01,W
090F8:  ADDLW  20
090FA:  MOVWF  FE9
090FC:  MOVLW  00
090FE:  ADDWFC 03,W
09100:  MOVWF  FEA
09102:  MOVFF  FEF,726
09106:  MOVFF  FEC,727
0910A:  MOVFF  FEC,728
0910E:  MOVFF  FEC,729
09112:  MOVFF  725,565
09116:  MOVFF  724,564
0911A:  MOVFF  70B,734
0911E:  MOVLW  18
09120:  MOVWF  x35
09122:  MOVLB  0
09124:  CALL   6060
09128:  MOVLW  2C
0912A:  MOVLB  7
0912C:  MOVWF  x50
0912E:  MOVLB  0
09130:  CALL   55C0
09134:  MOVLW  89
09136:  MOVWF  FE9
09138:  MOVFF  729,746
0913C:  MOVFF  728,745
09140:  MOVFF  727,744
09144:  MOVFF  726,743
09148:  MOVLW  02
0914A:  MOVLB  7
0914C:  MOVWF  x47
0914E:  MOVLB  0
09150:  CALL   575E
09154:  MOVLW  2C
09156:  MOVLB  7
09158:  MOVWF  x50
0915A:  MOVLB  0
0915C:  CALL   55C0
09160:  BRA    92DC
....................    else if (0 == strcmp(s_PVold, arg2))  sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].PVold);
09162:  MOVFF  719,742
09166:  MOVFF  718,741
0916A:  MOVFF  70D,744
0916E:  MOVFF  70C,743
09172:  CALL   5AFC
09176:  MOVF   01,F
09178:  BNZ   921C
0917A:  MOVLW  04
0917C:  MOVLB  7
0917E:  MOVWF  x42
09180:  MOVLW  C1
09182:  MOVWF  x41
09184:  MOVLB  0
09186:  CALL   5588
0918A:  MOVF   01,W
0918C:  ADDLW  C1
0918E:  MOVLB  7
09190:  MOVWF  x24
09192:  MOVLW  04
09194:  ADDWFC 02,W
09196:  MOVWF  x25
09198:  MOVLW  01
0919A:  SUBWF  x0B,W
0919C:  MULLW  28
0919E:  MOVF   FF3,W
091A0:  CLRF   x27
091A2:  MOVWF  x26
091A4:  MOVLW  14
091A6:  ADDWF  x26,W
091A8:  MOVWF  01
091AA:  MOVLW  00
091AC:  ADDWFC x27,W
091AE:  MOVWF  03
091B0:  MOVF   01,W
091B2:  ADDLW  20
091B4:  MOVWF  FE9
091B6:  MOVLW  00
091B8:  ADDWFC 03,W
091BA:  MOVWF  FEA
091BC:  MOVFF  FEF,726
091C0:  MOVFF  FEC,727
091C4:  MOVFF  FEC,728
091C8:  MOVFF  FEC,729
091CC:  MOVFF  725,565
091D0:  MOVFF  724,564
091D4:  MOVFF  70B,734
091D8:  MOVLW  18
091DA:  MOVWF  x35
091DC:  MOVLB  0
091DE:  CALL   6060
091E2:  MOVLW  2C
091E4:  MOVLB  7
091E6:  MOVWF  x50
091E8:  MOVLB  0
091EA:  CALL   55C0
091EE:  MOVLW  89
091F0:  MOVWF  FE9
091F2:  MOVFF  729,746
091F6:  MOVFF  728,745
091FA:  MOVFF  727,744
091FE:  MOVFF  726,743
09202:  MOVLW  02
09204:  MOVLB  7
09206:  MOVWF  x47
09208:  MOVLB  0
0920A:  CALL   575E
0920E:  MOVLW  2C
09210:  MOVLB  7
09212:  MOVWF  x50
09214:  MOVLB  0
09216:  CALL   55C0
0921A:  BRA    92DC
....................    else if (0 == strcmp(s_I, arg2))      sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].I);
0921C:  MOVFF  721,742
09220:  MOVFF  720,741
09224:  MOVFF  70D,744
09228:  MOVFF  70C,743
0922C:  CALL   5AFC
09230:  MOVF   01,F
09232:  BNZ   92D6
09234:  MOVLW  04
09236:  MOVLB  7
09238:  MOVWF  x42
0923A:  MOVLW  C1
0923C:  MOVWF  x41
0923E:  MOVLB  0
09240:  CALL   5588
09244:  MOVF   01,W
09246:  ADDLW  C1
09248:  MOVLB  7
0924A:  MOVWF  x24
0924C:  MOVLW  04
0924E:  ADDWFC 02,W
09250:  MOVWF  x25
09252:  MOVLW  01
09254:  SUBWF  x0B,W
09256:  MULLW  28
09258:  MOVF   FF3,W
0925A:  CLRF   x27
0925C:  MOVWF  x26
0925E:  MOVLW  1C
09260:  ADDWF  x26,W
09262:  MOVWF  01
09264:  MOVLW  00
09266:  ADDWFC x27,W
09268:  MOVWF  03
0926A:  MOVF   01,W
0926C:  ADDLW  20
0926E:  MOVWF  FE9
09270:  MOVLW  00
09272:  ADDWFC 03,W
09274:  MOVWF  FEA
09276:  MOVFF  FEF,726
0927A:  MOVFF  FEC,727
0927E:  MOVFF  FEC,728
09282:  MOVFF  FEC,729
09286:  MOVFF  725,565
0928A:  MOVFF  724,564
0928E:  MOVFF  70B,734
09292:  MOVLW  18
09294:  MOVWF  x35
09296:  MOVLB  0
09298:  CALL   6060
0929C:  MOVLW  2C
0929E:  MOVLB  7
092A0:  MOVWF  x50
092A2:  MOVLB  0
092A4:  CALL   55C0
092A8:  MOVLW  89
092AA:  MOVWF  FE9
092AC:  MOVFF  729,746
092B0:  MOVFF  728,745
092B4:  MOVFF  727,744
092B8:  MOVFF  726,743
092BC:  MOVLW  02
092BE:  MOVLB  7
092C0:  MOVWF  x47
092C2:  MOVLB  0
092C4:  CALL   575E
092C8:  MOVLW  2C
092CA:  MOVLB  7
092CC:  MOVWF  x50
092CE:  MOVLB  0
092D0:  CALL   55C0
092D4:  BRA    92DC
....................    else return INV_PARAM;
092D6:  MOVLW  02
092D8:  MOVWF  01
092DA:  BRA    92E0
....................    
....................    return SUCCESS;
092DC:  MOVLW  00
092DE:  MOVWF  01
092E0:  RETURN 0
.................... }
.................... 
.................... int8 getIPdata(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char *arg2;
....................    char *s_raw = "raw";
*
09400:  MOVLW  72
09402:  MOVLB  7
09404:  MOVWF  x10
09406:  MOVLW  61
09408:  MOVWF  x11
0940A:  MOVLW  77
0940C:  MOVWF  x12
0940E:  CLRF   x13
09410:  MOVLW  07
09412:  MOVWF  x0F
09414:  MOVLW  10
09416:  MOVWF  x0E
....................    char *s_calibrated = "calib";
09418:  MOVLW  63
0941A:  MOVWF  x16
0941C:  MOVLW  61
0941E:  MOVWF  x17
09420:  MOVLW  6C
09422:  MOVWF  x18
09424:  MOVLW  69
09426:  MOVWF  x19
09428:  MOVLW  62
0942A:  MOVWF  x1A
0942C:  CLRF   x1B
0942E:  MOVLW  07
09430:  MOVWF  x15
09432:  MOVLW  16
09434:  MOVWF  x14
....................    char *s_p0 = "p0";
09436:  MOVLW  70
09438:  MOVWF  x1E
0943A:  MOVLW  30
0943C:  MOVWF  x1F
0943E:  CLRF   x20
09440:  MOVLW  07
09442:  MOVWF  x1D
09444:  MOVLW  1E
09446:  MOVWF  x1C
....................    char *s_poles = "poles";
09448:  MOVLW  70
0944A:  MOVWF  x23
0944C:  MOVLW  6F
0944E:  MOVWF  x24
09450:  MOVLW  6C
09452:  MOVWF  x25
09454:  MOVLW  65
09456:  MOVWF  x26
09458:  MOVLW  73
0945A:  MOVWF  x27
0945C:  CLRF   x28
0945E:  MOVLW  07
09460:  MOVWF  x22
09462:  MOVLW  23
09464:  MOVWF  x21
....................    char *s_real = "real";
09466:  MOVLW  72
09468:  MOVWF  x2B
0946A:  MOVLW  65
0946C:  MOVWF  x2C
0946E:  MOVLW  61
09470:  MOVWF  x2D
09472:  MOVLW  6C
09474:  MOVWF  x2E
09476:  CLRF   x2F
09478:  MOVLW  07
0947A:  MOVWF  x2A
0947C:  MOVLW  2B
0947E:  MOVWF  x29
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
09480:  CLRF   x42
09482:  MOVFF  690,741
09486:  CLRF   x44
09488:  MOVLW  B5
0948A:  MOVWF  x43
0948C:  MOVLB  0
0948E:  CALL   08A6
09492:  MOVFF  02,731
09496:  MOVFF  01,730
0949A:  MOVLW  06
0949C:  MOVLB  7
0949E:  ADDWF  x30,F
094A0:  MOVLW  00
094A2:  ADDWFC x31,F
094A4:  MOVLW  32
094A6:  ADDWF  x30,W
094A8:  MOVWF  01
094AA:  MOVLW  00
094AC:  ADDWFC x31,W
094AE:  MOVWF  03
094B0:  MOVF   01,W
094B2:  ADDLW  EB
094B4:  MOVWF  01
094B6:  MOVLW  01
094B8:  ADDWFC 03,F
094BA:  MOVFF  01,730
094BE:  MOVFF  03,731
094C2:  MOVFF  03,734
094C6:  MOVFF  01,733
094CA:  MOVLB  0
094CC:  CALL   5C1C
094D0:  MOVF   01,F
094D2:  BNZ   94DC
094D4:  MOVLW  02
094D6:  MOVWF  01
094D8:  BRA    9B20
094DA:  BRA    953A
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
094DC:  MOVLB  7
094DE:  CLRF   x42
094E0:  MOVFF  690,741
094E4:  CLRF   x44
094E6:  MOVLW  B5
094E8:  MOVWF  x43
094EA:  MOVLB  0
094EC:  CALL   08A6
094F0:  MOVFF  02,731
094F4:  MOVFF  01,730
094F8:  MOVLW  06
094FA:  MOVLB  7
094FC:  ADDWF  x30,F
094FE:  MOVLW  00
09500:  ADDWFC x31,F
09502:  MOVLW  32
09504:  ADDWF  x30,W
09506:  MOVWF  01
09508:  MOVLW  00
0950A:  ADDWFC x31,W
0950C:  MOVWF  03
0950E:  MOVF   01,W
09510:  ADDLW  EB
09512:  MOVWF  01
09514:  MOVLW  01
09516:  ADDWFC 03,F
09518:  MOVFF  01,730
0951C:  MOVFF  03,731
09520:  MOVFF  03,734
09524:  MOVFF  01,733
09528:  CLRF   x36
0952A:  CLRF   x35
0952C:  MOVLW  0A
0952E:  MOVWF  x37
09530:  MOVLB  0
09532:  CALL   5D0C
09536:  MOVFF  01,70B
....................    
....................    arg2 = SERcmd[rec].p[3];
0953A:  MOVLB  7
0953C:  CLRF   x42
0953E:  MOVFF  690,741
09542:  CLRF   x44
09544:  MOVLW  B5
09546:  MOVWF  x43
09548:  MOVLB  0
0954A:  CALL   08A6
0954E:  MOVFF  02,731
09552:  MOVFF  01,730
09556:  MOVLW  06
09558:  MOVLB  7
0955A:  ADDWF  x30,F
0955C:  MOVLW  00
0955E:  ADDWFC x31,F
09560:  MOVLW  4B
09562:  ADDWF  x30,W
09564:  MOVWF  01
09566:  MOVLW  00
09568:  ADDWFC x31,W
0956A:  MOVWF  03
0956C:  MOVF   01,W
0956E:  ADDLW  EB
09570:  MOVWF  01
09572:  MOVLW  01
09574:  ADDWFC 03,F
09576:  MOVFF  01,70C
0957A:  MOVFF  03,70D
....................    
....................    /*** GET INPUT DATA ****************/
....................    if      (0 == strcmp(s_raw, arg2)) {
0957E:  MOVFF  70F,742
09582:  MOVFF  70E,741
09586:  MOVFF  70D,744
0958A:  MOVFF  70C,743
0958E:  MOVLB  0
09590:  CALL   5AFC
09594:  MOVF   01,F
09596:  BTFSS  FD8.2
09598:  BRA    9714
....................       sprintf(retData+strlen(retData), "%d,", arg1);
0959A:  MOVLW  04
0959C:  MOVLB  7
0959E:  MOVWF  x42
095A0:  MOVLW  C1
095A2:  MOVWF  x41
095A4:  MOVLB  0
095A6:  CALL   5588
095AA:  MOVFF  02,03
095AE:  MOVF   01,W
095B0:  ADDLW  C1
095B2:  MOVLB  7
095B4:  MOVWF  x30
095B6:  MOVLW  04
095B8:  ADDWFC 02,W
095BA:  MOVWF  x31
095BC:  MOVFF  FE8,565
095C0:  MOVFF  730,564
095C4:  MOVFF  70B,734
095C8:  MOVLW  18
095CA:  MOVWF  x35
095CC:  MOVLB  0
095CE:  CALL   6060
095D2:  MOVLW  2C
095D4:  MOVLB  7
095D6:  MOVWF  x50
095D8:  MOVLB  0
095DA:  CALL   55C0
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].sinRaw);
095DE:  MOVLW  04
095E0:  MOVLB  7
095E2:  MOVWF  x42
095E4:  MOVLW  C1
095E6:  MOVWF  x41
095E8:  MOVLB  0
095EA:  CALL   5588
095EE:  MOVFF  02,03
095F2:  MOVF   01,W
095F4:  ADDLW  C1
095F6:  MOVLB  7
095F8:  MOVWF  x30
095FA:  MOVLW  04
095FC:  ADDWFC 02,W
095FE:  MOVWF  x31
09600:  MOVLW  01
09602:  SUBWF  x0B,W
09604:  MULLW  26
09606:  MOVF   FF3,W
09608:  CLRF   x33
0960A:  MOVWF  x32
0960C:  MOVLW  17
0960E:  ADDWF  x32,W
09610:  MOVWF  FE9
09612:  MOVLW  01
09614:  ADDWFC x33,W
09616:  MOVWF  FEA
09618:  MOVFF  FEF,750
0961C:  MOVFF  FEC,01
09620:  MOVFF  FEC,02
09624:  MOVFF  FEC,03
09628:  MOVFF  03,753
0962C:  MOVFF  02,752
09630:  MOVFF  01,751
09634:  MOVLB  0
09636:  CALL   5688
0963A:  MOVFF  03,737
0963E:  MOVFF  02,736
09642:  MOVFF  01,735
09646:  MOVFF  00,734
0964A:  MOVFF  731,565
0964E:  MOVFF  730,564
09652:  MOVLW  41
09654:  MOVWF  FE9
09656:  MOVFF  03,73C
0965A:  MOVFF  02,73B
0965E:  MOVFF  01,73A
09662:  MOVFF  00,739
09666:  RCALL  92E2
09668:  MOVLW  2C
0966A:  MOVLB  7
0966C:  MOVWF  x50
0966E:  MOVLB  0
09670:  CALL   55C0
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].cosRaw);
09674:  MOVLW  04
09676:  MOVLB  7
09678:  MOVWF  x42
0967A:  MOVLW  C1
0967C:  MOVWF  x41
0967E:  MOVLB  0
09680:  CALL   5588
09684:  MOVF   01,W
09686:  ADDLW  C1
09688:  MOVLB  7
0968A:  MOVWF  x30
0968C:  MOVLW  04
0968E:  ADDWFC 02,W
09690:  MOVWF  x31
09692:  MOVLW  01
09694:  SUBWF  x0B,W
09696:  MULLW  26
09698:  MOVF   FF3,W
0969A:  CLRF   x33
0969C:  MOVWF  x32
0969E:  MOVLW  04
096A0:  ADDWF  x32,W
096A2:  MOVWF  01
096A4:  MOVLW  00
096A6:  ADDWFC x33,W
096A8:  MOVWF  03
096AA:  MOVF   01,W
096AC:  ADDLW  17
096AE:  MOVWF  FE9
096B0:  MOVLW  01
096B2:  ADDWFC 03,W
096B4:  MOVWF  FEA
096B6:  MOVFF  FEF,750
096BA:  MOVFF  FEC,01
096BE:  MOVFF  FEC,02
096C2:  MOVFF  FEC,03
096C6:  MOVFF  03,753
096CA:  MOVFF  02,752
096CE:  MOVFF  01,751
096D2:  MOVLB  0
096D4:  CALL   5688
096D8:  MOVFF  03,735
096DC:  MOVFF  02,734
096E0:  MOVFF  01,733
096E4:  MOVFF  00,732
096E8:  MOVFF  731,565
096EC:  MOVFF  730,564
096F0:  MOVLW  41
096F2:  MOVWF  FE9
096F4:  MOVFF  03,73C
096F8:  MOVFF  02,73B
096FC:  MOVFF  01,73A
09700:  MOVFF  00,739
09704:  RCALL  92E2
09706:  MOVLW  2C
09708:  MOVLB  7
0970A:  MOVWF  x50
0970C:  MOVLB  0
0970E:  CALL   55C0
....................    }
09712:  BRA    9B1C
....................    else if (0 == strcmp(s_calibrated, arg2)) {
09714:  MOVFF  715,742
09718:  MOVFF  714,741
0971C:  MOVFF  70D,744
09720:  MOVFF  70C,743
09724:  CALL   5AFC
09728:  MOVF   01,F
0972A:  BTFSS  FD8.2
0972C:  BRA    98B0
....................       sprintf(retData+strlen(retData), "%d,", arg1);
0972E:  MOVLW  04
09730:  MOVLB  7
09732:  MOVWF  x42
09734:  MOVLW  C1
09736:  MOVWF  x41
09738:  MOVLB  0
0973A:  CALL   5588
0973E:  MOVFF  02,03
09742:  MOVF   01,W
09744:  ADDLW  C1
09746:  MOVLB  7
09748:  MOVWF  x30
0974A:  MOVLW  04
0974C:  ADDWFC 02,W
0974E:  MOVWF  x31
09750:  MOVFF  FE8,565
09754:  MOVFF  730,564
09758:  MOVFF  70B,734
0975C:  MOVLW  18
0975E:  MOVWF  x35
09760:  MOVLB  0
09762:  CALL   6060
09766:  MOVLW  2C
09768:  MOVLB  7
0976A:  MOVWF  x50
0976C:  MOVLB  0
0976E:  CALL   55C0
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].sinCounts);
09772:  MOVLW  04
09774:  MOVLB  7
09776:  MOVWF  x42
09778:  MOVLW  C1
0977A:  MOVWF  x41
0977C:  MOVLB  0
0977E:  CALL   5588
09782:  MOVF   01,W
09784:  ADDLW  C1
09786:  MOVLB  7
09788:  MOVWF  x30
0978A:  MOVLW  04
0978C:  ADDWFC 02,W
0978E:  MOVWF  x31
09790:  MOVLW  01
09792:  SUBWF  x0B,W
09794:  MULLW  26
09796:  MOVF   FF3,W
09798:  CLRF   x33
0979A:  MOVWF  x32
0979C:  MOVLW  08
0979E:  ADDWF  x32,W
097A0:  MOVWF  01
097A2:  MOVLW  00
097A4:  ADDWFC x33,W
097A6:  MOVWF  03
097A8:  MOVF   01,W
097AA:  ADDLW  17
097AC:  MOVWF  FE9
097AE:  MOVLW  01
097B0:  ADDWFC 03,W
097B2:  MOVWF  FEA
097B4:  MOVFF  FEF,750
097B8:  MOVFF  FEC,01
097BC:  MOVFF  FEC,02
097C0:  MOVFF  FEC,03
097C4:  MOVFF  03,753
097C8:  MOVFF  02,752
097CC:  MOVFF  01,751
097D0:  MOVLB  0
097D2:  CALL   5688
097D6:  MOVFF  03,735
097DA:  MOVFF  02,734
097DE:  MOVFF  01,733
097E2:  MOVFF  00,732
097E6:  MOVFF  731,565
097EA:  MOVFF  730,564
097EE:  MOVLW  41
097F0:  MOVWF  FE9
097F2:  MOVFF  03,73C
097F6:  MOVFF  02,73B
097FA:  MOVFF  01,73A
097FE:  MOVFF  00,739
09802:  RCALL  92E2
09804:  MOVLW  2C
09806:  MOVLB  7
09808:  MOVWF  x50
0980A:  MOVLB  0
0980C:  CALL   55C0
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].cosCounts);
09810:  MOVLW  04
09812:  MOVLB  7
09814:  MOVWF  x42
09816:  MOVLW  C1
09818:  MOVWF  x41
0981A:  MOVLB  0
0981C:  CALL   5588
09820:  MOVF   01,W
09822:  ADDLW  C1
09824:  MOVLB  7
09826:  MOVWF  x30
09828:  MOVLW  04
0982A:  ADDWFC 02,W
0982C:  MOVWF  x31
0982E:  MOVLW  01
09830:  SUBWF  x0B,W
09832:  MULLW  26
09834:  MOVF   FF3,W
09836:  CLRF   x33
09838:  MOVWF  x32
0983A:  MOVLW  0C
0983C:  ADDWF  x32,W
0983E:  MOVWF  01
09840:  MOVLW  00
09842:  ADDWFC x33,W
09844:  MOVWF  03
09846:  MOVF   01,W
09848:  ADDLW  17
0984A:  MOVWF  FE9
0984C:  MOVLW  01
0984E:  ADDWFC 03,W
09850:  MOVWF  FEA
09852:  MOVFF  FEF,750
09856:  MOVFF  FEC,01
0985A:  MOVFF  FEC,02
0985E:  MOVFF  FEC,03
09862:  MOVFF  03,753
09866:  MOVFF  02,752
0986A:  MOVFF  01,751
0986E:  MOVLB  0
09870:  CALL   5688
09874:  MOVFF  03,735
09878:  MOVFF  02,734
0987C:  MOVFF  01,733
09880:  MOVFF  00,732
09884:  MOVFF  731,565
09888:  MOVFF  730,564
0988C:  MOVLW  41
0988E:  MOVWF  FE9
09890:  MOVFF  03,73C
09894:  MOVFF  02,73B
09898:  MOVFF  01,73A
0989C:  MOVFF  00,739
098A0:  RCALL  92E2
098A2:  MOVLW  2C
098A4:  MOVLB  7
098A6:  MOVWF  x50
098A8:  MOVLB  0
098AA:  CALL   55C0
....................    }
098AE:  BRA    9B1C
....................    else if (0 == strcmp(s_p0, arg2)) {
098B0:  MOVFF  71D,742
098B4:  MOVFF  71C,741
098B8:  MOVFF  70D,744
098BC:  MOVFF  70C,743
098C0:  CALL   5AFC
098C4:  MOVF   01,F
098C6:  BNZ   9982
....................       sprintf(retData+strlen(retData), "%d,", arg1);
098C8:  MOVLW  04
098CA:  MOVLB  7
098CC:  MOVWF  x42
098CE:  MOVLW  C1
098D0:  MOVWF  x41
098D2:  MOVLB  0
098D4:  CALL   5588
098D8:  MOVFF  02,03
098DC:  MOVF   01,W
098DE:  ADDLW  C1
098E0:  MOVLB  7
098E2:  MOVWF  x30
098E4:  MOVLW  04
098E6:  ADDWFC 02,W
098E8:  MOVWF  x31
098EA:  MOVFF  FE8,565
098EE:  MOVFF  730,564
098F2:  MOVFF  70B,734
098F6:  MOVLW  18
098F8:  MOVWF  x35
098FA:  MOVLB  0
098FC:  CALL   6060
09900:  MOVLW  2C
09902:  MOVLB  7
09904:  MOVWF  x50
09906:  MOVLB  0
09908:  CALL   55C0
....................       sprintf(retData+strlen(retData), "%f,", adcVals[arg1-1].p0);
0990C:  MOVLW  04
0990E:  MOVLB  7
09910:  MOVWF  x42
09912:  MOVLW  C1
09914:  MOVWF  x41
09916:  MOVLB  0
09918:  CALL   5588
0991C:  MOVF   01,W
0991E:  ADDLW  C1
09920:  MOVLB  7
09922:  MOVWF  x30
09924:  MOVLW  04
09926:  ADDWFC 02,W
09928:  MOVWF  x31
0992A:  MOVLW  01
0992C:  SUBWF  x0B,W
0992E:  MULLW  26
09930:  MOVF   FF3,W
09932:  CLRF   x33
09934:  MOVWF  x32
09936:  MOVLW  18
09938:  ADDWF  x32,W
0993A:  MOVWF  01
0993C:  MOVLW  00
0993E:  ADDWFC x33,W
09940:  MOVWF  03
09942:  MOVF   01,W
09944:  ADDLW  17
09946:  MOVWF  FE9
09948:  MOVLW  01
0994A:  ADDWFC 03,W
0994C:  MOVWF  FEA
0994E:  MOVFF  FEF,743
09952:  MOVFF  FEC,744
09956:  MOVFF  FEC,745
0995A:  MOVFF  FEC,746
0995E:  MOVFF  731,565
09962:  MOVFF  730,564
09966:  MOVLW  89
09968:  MOVWF  FE9
0996A:  MOVLW  02
0996C:  MOVWF  x47
0996E:  MOVLB  0
09970:  CALL   575E
09974:  MOVLW  2C
09976:  MOVLB  7
09978:  MOVWF  x50
0997A:  MOVLB  0
0997C:  CALL   55C0
....................    }
09980:  BRA    9B1C
....................    else if (0 == strcmp(s_poles, arg2)) {
09982:  MOVFF  722,742
09986:  MOVFF  721,741
0998A:  MOVFF  70D,744
0998E:  MOVFF  70C,743
09992:  CALL   5AFC
09996:  MOVF   01,F
09998:  BNZ   9A44
....................       sprintf(retData+strlen(retData), "%d,", arg1);
0999A:  MOVLW  04
0999C:  MOVLB  7
0999E:  MOVWF  x42
099A0:  MOVLW  C1
099A2:  MOVWF  x41
099A4:  MOVLB  0
099A6:  CALL   5588
099AA:  MOVFF  02,03
099AE:  MOVF   01,W
099B0:  ADDLW  C1
099B2:  MOVLB  7
099B4:  MOVWF  x30
099B6:  MOVLW  04
099B8:  ADDWFC 02,W
099BA:  MOVWF  x31
099BC:  MOVFF  FE8,565
099C0:  MOVFF  730,564
099C4:  MOVFF  70B,734
099C8:  MOVLW  18
099CA:  MOVWF  x35
099CC:  MOVLB  0
099CE:  CALL   6060
099D2:  MOVLW  2C
099D4:  MOVLB  7
099D6:  MOVWF  x50
099D8:  MOVLB  0
099DA:  CALL   55C0
....................       sprintf(retData+strlen(retData), "%d,", adcVals[arg1-1].npoles);
099DE:  MOVLW  04
099E0:  MOVLB  7
099E2:  MOVWF  x42
099E4:  MOVLW  C1
099E6:  MOVWF  x41
099E8:  MOVLB  0
099EA:  CALL   5588
099EE:  MOVF   01,W
099F0:  ADDLW  C1
099F2:  MOVLB  7
099F4:  MOVWF  x30
099F6:  MOVLW  04
099F8:  ADDWFC 02,W
099FA:  MOVWF  x31
099FC:  MOVLW  01
099FE:  SUBWF  x0B,W
09A00:  MULLW  26
09A02:  MOVF   FF3,W
09A04:  CLRF   x33
09A06:  MOVWF  x32
09A08:  MOVLW  1C
09A0A:  ADDWF  x32,W
09A0C:  MOVWF  01
09A0E:  MOVLW  00
09A10:  ADDWFC x33,W
09A12:  MOVWF  03
09A14:  MOVF   01,W
09A16:  ADDLW  17
09A18:  MOVWF  FE9
09A1A:  MOVLW  01
09A1C:  ADDWFC 03,W
09A1E:  MOVWF  FEA
09A20:  MOVFF  FEF,734
09A24:  MOVFF  731,565
09A28:  MOVFF  730,564
09A2C:  MOVLW  18
09A2E:  MOVWF  x35
09A30:  MOVLB  0
09A32:  CALL   6060
09A36:  MOVLW  2C
09A38:  MOVLB  7
09A3A:  MOVWF  x50
09A3C:  MOVLB  0
09A3E:  CALL   55C0
....................    }
09A42:  BRA    9B1C
....................    else if (0 == strcmp(s_real, arg2)) {
09A44:  MOVFF  72A,742
09A48:  MOVFF  729,741
09A4C:  MOVFF  70D,744
09A50:  MOVFF  70C,743
09A54:  CALL   5AFC
09A58:  MOVF   01,F
09A5A:  BNZ   9B16
....................       sprintf(retData+strlen(retData), "%d,", arg1);
09A5C:  MOVLW  04
09A5E:  MOVLB  7
09A60:  MOVWF  x42
09A62:  MOVLW  C1
09A64:  MOVWF  x41
09A66:  MOVLB  0
09A68:  CALL   5588
09A6C:  MOVFF  02,03
09A70:  MOVF   01,W
09A72:  ADDLW  C1
09A74:  MOVLB  7
09A76:  MOVWF  x30
09A78:  MOVLW  04
09A7A:  ADDWFC 02,W
09A7C:  MOVWF  x31
09A7E:  MOVFF  FE8,565
09A82:  MOVFF  730,564
09A86:  MOVFF  70B,734
09A8A:  MOVLW  18
09A8C:  MOVWF  x35
09A8E:  MOVLB  0
09A90:  CALL   6060
09A94:  MOVLW  2C
09A96:  MOVLB  7
09A98:  MOVWF  x50
09A9A:  MOVLB  0
09A9C:  CALL   55C0
....................       sprintf(retData+strlen(retData), "%f,", adcVals[arg1-1].pReal);
09AA0:  MOVLW  04
09AA2:  MOVLB  7
09AA4:  MOVWF  x42
09AA6:  MOVLW  C1
09AA8:  MOVWF  x41
09AAA:  MOVLB  0
09AAC:  CALL   5588
09AB0:  MOVF   01,W
09AB2:  ADDLW  C1
09AB4:  MOVLB  7
09AB6:  MOVWF  x30
09AB8:  MOVLW  04
09ABA:  ADDWFC 02,W
09ABC:  MOVWF  x31
09ABE:  MOVLW  01
09AC0:  SUBWF  x0B,W
09AC2:  MULLW  26
09AC4:  MOVF   FF3,W
09AC6:  CLRF   x33
09AC8:  MOVWF  x32
09ACA:  MOVLW  1D
09ACC:  ADDWF  x32,W
09ACE:  MOVWF  01
09AD0:  MOVLW  00
09AD2:  ADDWFC x33,W
09AD4:  MOVWF  03
09AD6:  MOVF   01,W
09AD8:  ADDLW  17
09ADA:  MOVWF  FE9
09ADC:  MOVLW  01
09ADE:  ADDWFC 03,W
09AE0:  MOVWF  FEA
09AE2:  MOVFF  FEF,743
09AE6:  MOVFF  FEC,744
09AEA:  MOVFF  FEC,745
09AEE:  MOVFF  FEC,746
09AF2:  MOVFF  731,565
09AF6:  MOVFF  730,564
09AFA:  MOVLW  89
09AFC:  MOVWF  FE9
09AFE:  MOVLW  02
09B00:  MOVWF  x47
09B02:  MOVLB  0
09B04:  CALL   575E
09B08:  MOVLW  2C
09B0A:  MOVLB  7
09B0C:  MOVWF  x50
09B0E:  MOVLB  0
09B10:  CALL   55C0
....................    }
09B14:  BRA    9B1C
....................    else return INV_PARAM;
09B16:  MOVLW  02
09B18:  MOVWF  01
09B1A:  BRA    9B20
....................    
....................    return SUCCESS;
09B1C:  MOVLW  00
09B1E:  MOVWF  01
09B20:  RETURN 0
.................... }
.................... 
.................... int8 getManOPvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
09B22:  MOVLB  7
09B24:  CLRF   x42
09B26:  MOVFF  690,741
09B2A:  CLRF   x44
09B2C:  MOVLW  B5
09B2E:  MOVWF  x43
09B30:  MOVLB  0
09B32:  CALL   08A6
09B36:  MOVFF  02,70D
09B3A:  MOVFF  01,70C
09B3E:  MOVLW  06
09B40:  MOVLB  7
09B42:  ADDWF  x0C,F
09B44:  MOVLW  00
09B46:  ADDWFC x0D,F
09B48:  MOVLW  32
09B4A:  ADDWF  x0C,W
09B4C:  MOVWF  01
09B4E:  MOVLW  00
09B50:  ADDWFC x0D,W
09B52:  MOVWF  03
09B54:  MOVF   01,W
09B56:  ADDLW  EB
09B58:  MOVWF  01
09B5A:  MOVLW  01
09B5C:  ADDWFC 03,F
09B5E:  MOVFF  01,70C
09B62:  MOVFF  03,70D
09B66:  MOVFF  03,734
09B6A:  MOVFF  01,733
09B6E:  MOVLB  0
09B70:  CALL   5C1C
09B74:  MOVF   01,F
09B76:  BNZ   9B80
09B78:  MOVLW  02
09B7A:  MOVWF  01
09B7C:  BRA    9C82
09B7E:  BRA    9BDE
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
09B80:  MOVLB  7
09B82:  CLRF   x42
09B84:  MOVFF  690,741
09B88:  CLRF   x44
09B8A:  MOVLW  B5
09B8C:  MOVWF  x43
09B8E:  MOVLB  0
09B90:  CALL   08A6
09B94:  MOVFF  02,70D
09B98:  MOVFF  01,70C
09B9C:  MOVLW  06
09B9E:  MOVLB  7
09BA0:  ADDWF  x0C,F
09BA2:  MOVLW  00
09BA4:  ADDWFC x0D,F
09BA6:  MOVLW  32
09BA8:  ADDWF  x0C,W
09BAA:  MOVWF  01
09BAC:  MOVLW  00
09BAE:  ADDWFC x0D,W
09BB0:  MOVWF  03
09BB2:  MOVF   01,W
09BB4:  ADDLW  EB
09BB6:  MOVWF  01
09BB8:  MOVLW  01
09BBA:  ADDWFC 03,F
09BBC:  MOVFF  01,70C
09BC0:  MOVFF  03,70D
09BC4:  MOVFF  03,734
09BC8:  MOVFF  01,733
09BCC:  CLRF   x36
09BCE:  CLRF   x35
09BD0:  MOVLW  0A
09BD2:  MOVWF  x37
09BD4:  MOVLB  0
09BD6:  CALL   5D0C
09BDA:  MOVFF  01,70B
....................    
....................    /*** GET MANUAL OUTPUT VALUE ***************/ 
....................    sprintf(retData+strlen(retData), "%d,%f,", arg1, dacVals[arg1-1].opPcnt);
09BDE:  MOVLW  04
09BE0:  MOVLB  7
09BE2:  MOVWF  x42
09BE4:  MOVLW  C1
09BE6:  MOVWF  x41
09BE8:  MOVLB  0
09BEA:  CALL   5588
09BEE:  MOVF   01,W
09BF0:  ADDLW  C1
09BF2:  MOVLB  7
09BF4:  MOVWF  x0C
09BF6:  MOVLW  04
09BF8:  ADDWFC 02,W
09BFA:  MOVWF  x0D
09BFC:  MOVLW  01
09BFE:  SUBWF  x0B,W
09C00:  MULLW  07
09C02:  MOVF   FF3,W
09C04:  CLRF   x0F
09C06:  MOVWF  x0E
09C08:  MOVLW  03
09C0A:  ADDWF  x0E,W
09C0C:  MOVWF  01
09C0E:  MOVLW  00
09C10:  ADDWFC x0F,W
09C12:  MOVWF  03
09C14:  MOVF   01,W
09C16:  ADDLW  64
09C18:  MOVWF  FE9
09C1A:  MOVLW  01
09C1C:  ADDWFC 03,W
09C1E:  MOVWF  FEA
09C20:  MOVFF  FEF,70E
09C24:  MOVFF  FEC,70F
09C28:  MOVFF  FEC,710
09C2C:  MOVFF  FEC,711
09C30:  MOVFF  70D,565
09C34:  MOVFF  70C,564
09C38:  MOVFF  70B,734
09C3C:  MOVLW  18
09C3E:  MOVWF  x35
09C40:  MOVLB  0
09C42:  CALL   6060
09C46:  MOVLW  2C
09C48:  MOVLB  7
09C4A:  MOVWF  x50
09C4C:  MOVLB  0
09C4E:  CALL   55C0
09C52:  MOVLW  89
09C54:  MOVWF  FE9
09C56:  MOVFF  711,746
09C5A:  MOVFF  710,745
09C5E:  MOVFF  70F,744
09C62:  MOVFF  70E,743
09C66:  MOVLW  02
09C68:  MOVLB  7
09C6A:  MOVWF  x47
09C6C:  MOVLB  0
09C6E:  CALL   575E
09C72:  MOVLW  2C
09C74:  MOVLB  7
09C76:  MOVWF  x50
09C78:  MOVLB  0
09C7A:  CALL   55C0
....................    
....................    return SUCCESS;
09C7E:  MOVLW  00
09C80:  MOVWF  01
09C82:  RETURN 0
.................... }
.................... 
.................... int8 setManOPvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    float arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
09C84:  MOVLB  7
09C86:  CLRF   x42
09C88:  MOVFF  690,741
09C8C:  CLRF   x44
09C8E:  MOVLW  B5
09C90:  MOVWF  x43
09C92:  MOVLB  0
09C94:  CALL   08A6
09C98:  MOVFF  02,711
09C9C:  MOVFF  01,710
09CA0:  MOVLW  06
09CA2:  MOVLB  7
09CA4:  ADDWF  x10,F
09CA6:  MOVLW  00
09CA8:  ADDWFC x11,F
09CAA:  MOVLW  32
09CAC:  ADDWF  x10,W
09CAE:  MOVWF  01
09CB0:  MOVLW  00
09CB2:  ADDWFC x11,W
09CB4:  MOVWF  03
09CB6:  MOVF   01,W
09CB8:  ADDLW  EB
09CBA:  MOVWF  01
09CBC:  MOVLW  01
09CBE:  ADDWFC 03,F
09CC0:  MOVFF  01,710
09CC4:  MOVFF  03,711
09CC8:  MOVFF  03,734
09CCC:  MOVFF  01,733
09CD0:  MOVLB  0
09CD2:  CALL   5C1C
09CD6:  MOVF   01,F
09CD8:  BNZ   9CE2
09CDA:  MOVLW  02
09CDC:  MOVWF  01
09CDE:  BRA    9EF4
09CE0:  BRA    9D40
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
09CE2:  MOVLB  7
09CE4:  CLRF   x42
09CE6:  MOVFF  690,741
09CEA:  CLRF   x44
09CEC:  MOVLW  B5
09CEE:  MOVWF  x43
09CF0:  MOVLB  0
09CF2:  CALL   08A6
09CF6:  MOVFF  02,711
09CFA:  MOVFF  01,710
09CFE:  MOVLW  06
09D00:  MOVLB  7
09D02:  ADDWF  x10,F
09D04:  MOVLW  00
09D06:  ADDWFC x11,F
09D08:  MOVLW  32
09D0A:  ADDWF  x10,W
09D0C:  MOVWF  01
09D0E:  MOVLW  00
09D10:  ADDWFC x11,W
09D12:  MOVWF  03
09D14:  MOVF   01,W
09D16:  ADDLW  EB
09D18:  MOVWF  01
09D1A:  MOVLW  01
09D1C:  ADDWFC 03,F
09D1E:  MOVFF  01,710
09D22:  MOVFF  03,711
09D26:  MOVFF  03,734
09D2A:  MOVFF  01,733
09D2E:  CLRF   x36
09D30:  CLRF   x35
09D32:  MOVLW  0A
09D34:  MOVWF  x37
09D36:  MOVLB  0
09D38:  CALL   5D0C
09D3C:  MOVFF  01,70B
....................    
....................    if (!arg_is_float(SERcmd[rec].p[3])) return INV_PARAM;
09D40:  MOVLB  7
09D42:  CLRF   x42
09D44:  MOVFF  690,741
09D48:  CLRF   x44
09D4A:  MOVLW  B5
09D4C:  MOVWF  x43
09D4E:  MOVLB  0
09D50:  CALL   08A6
09D54:  MOVFF  02,711
09D58:  MOVFF  01,710
09D5C:  MOVLW  06
09D5E:  MOVLB  7
09D60:  ADDWF  x10,F
09D62:  MOVLW  00
09D64:  ADDWFC x11,F
09D66:  MOVLW  4B
09D68:  ADDWF  x10,W
09D6A:  MOVWF  01
09D6C:  MOVLW  00
09D6E:  ADDWFC x11,W
09D70:  MOVWF  03
09D72:  MOVF   01,W
09D74:  ADDLW  EB
09D76:  MOVWF  01
09D78:  MOVLW  01
09D7A:  ADDWFC 03,F
09D7C:  MOVFF  01,710
09D80:  MOVFF  03,711
09D84:  MOVFF  03,715
09D88:  MOVFF  01,714
09D8C:  MOVLB  0
09D8E:  CALL   6D30
09D92:  MOVF   01,F
09D94:  BNZ   9D9E
09D96:  MOVLW  02
09D98:  MOVWF  01
09D9A:  BRA    9EF4
09D9C:  BRA    9E04
....................    else arg2 = strtod(SERcmd[rec].p[3], '\0');
09D9E:  MOVLB  7
09DA0:  CLRF   x42
09DA2:  MOVFF  690,741
09DA6:  CLRF   x44
09DA8:  MOVLW  B5
09DAA:  MOVWF  x43
09DAC:  MOVLB  0
09DAE:  CALL   08A6
09DB2:  MOVFF  02,711
09DB6:  MOVFF  01,710
09DBA:  MOVLW  06
09DBC:  MOVLB  7
09DBE:  ADDWF  x10,F
09DC0:  MOVLW  00
09DC2:  ADDWFC x11,F
09DC4:  MOVLW  4B
09DC6:  ADDWF  x10,W
09DC8:  MOVWF  01
09DCA:  MOVLW  00
09DCC:  ADDWFC x11,W
09DCE:  MOVWF  03
09DD0:  MOVF   01,W
09DD2:  ADDLW  EB
09DD4:  MOVWF  01
09DD6:  MOVLW  01
09DD8:  ADDWFC 03,F
09DDA:  MOVFF  01,710
09DDE:  MOVFF  03,711
09DE2:  MOVFF  03,715
09DE6:  MOVFF  01,714
09DEA:  CLRF   x17
09DEC:  CLRF   x16
09DEE:  MOVLB  0
09DF0:  CALL   6DF2
09DF4:  MOVFF  03,70F
09DF8:  MOVFF  02,70E
09DFC:  MOVFF  01,70D
09E00:  MOVFF  00,70C
....................    
....................    /*** SET MANUAL OUTPUT VALUE ***************/
....................    if (arg2 > op_upper_bound) dacVals[arg1-1].opPcnt = op_upper_bound;
09E04:  MOVLB  7
09E06:  CLRF   x49
09E08:  CLRF   x48
09E0A:  MOVLW  7C
09E0C:  MOVWF  x47
09E0E:  MOVLW  84
09E10:  MOVWF  x46
09E12:  MOVFF  70F,74D
09E16:  MOVFF  70E,74C
09E1A:  MOVFF  70D,74B
09E1E:  MOVFF  70C,74A
09E22:  MOVLB  0
09E24:  CALL   1D1C
09E28:  BNC   9E5E
09E2A:  MOVLW  01
09E2C:  MOVLB  7
09E2E:  SUBWF  x0B,W
09E30:  MULLW  07
09E32:  MOVF   FF3,W
09E34:  CLRF   x11
09E36:  MOVWF  x10
09E38:  MOVLW  03
09E3A:  ADDWF  x10,W
09E3C:  MOVWF  01
09E3E:  MOVLW  00
09E40:  ADDWFC x11,W
09E42:  MOVWF  03
09E44:  MOVF   01,W
09E46:  ADDLW  64
09E48:  MOVWF  FE9
09E4A:  MOVLW  01
09E4C:  ADDWFC 03,W
09E4E:  MOVWF  FEA
09E50:  MOVLW  84
09E52:  MOVWF  FEF
09E54:  MOVLW  7C
09E56:  MOVWF  FEC
09E58:  CLRF   FEC
09E5A:  CLRF   FEC
09E5C:  BRA    9EEE
....................    else if (arg2 < op_lower_bound) dacVals[arg1-1].opPcnt = op_lower_bound;  
09E5E:  MOVFF  70F,749
09E62:  MOVFF  70E,748
09E66:  MOVFF  70D,747
09E6A:  MOVFF  70C,746
09E6E:  MOVLB  7
09E70:  CLRF   x4D
09E72:  CLRF   x4C
09E74:  MOVLW  C0
09E76:  MOVWF  x4B
09E78:  MOVLW  82
09E7A:  MOVWF  x4A
09E7C:  MOVLB  0
09E7E:  CALL   1D1C
09E82:  BNC   9EB8
09E84:  MOVLW  01
09E86:  MOVLB  7
09E88:  SUBWF  x0B,W
09E8A:  MULLW  07
09E8C:  MOVF   FF3,W
09E8E:  CLRF   x11
09E90:  MOVWF  x10
09E92:  MOVLW  03
09E94:  ADDWF  x10,W
09E96:  MOVWF  01
09E98:  MOVLW  00
09E9A:  ADDWFC x11,W
09E9C:  MOVWF  03
09E9E:  MOVF   01,W
09EA0:  ADDLW  64
09EA2:  MOVWF  FE9
09EA4:  MOVLW  01
09EA6:  ADDWFC 03,W
09EA8:  MOVWF  FEA
09EAA:  MOVLW  82
09EAC:  MOVWF  FEF
09EAE:  MOVLW  C0
09EB0:  MOVWF  FEC
09EB2:  CLRF   FEC
09EB4:  CLRF   FEC
09EB6:  BRA    9EEE
....................    else dacVals[arg1-1].opPcnt = arg2;
09EB8:  MOVLW  01
09EBA:  MOVLB  7
09EBC:  SUBWF  x0B,W
09EBE:  MULLW  07
09EC0:  MOVF   FF3,W
09EC2:  CLRF   x11
09EC4:  MOVWF  x10
09EC6:  MOVLW  03
09EC8:  ADDWF  x10,W
09ECA:  MOVWF  01
09ECC:  MOVLW  00
09ECE:  ADDWFC x11,W
09ED0:  MOVWF  03
09ED2:  MOVF   01,W
09ED4:  ADDLW  64
09ED6:  MOVWF  FE9
09ED8:  MOVLW  01
09EDA:  ADDWFC 03,W
09EDC:  MOVWF  FEA
09EDE:  MOVFF  70C,FEF
09EE2:  MOVFF  70D,FEC
09EE6:  MOVFF  70E,FEC
09EEA:  MOVFF  70F,FEC
....................    
....................    return SUCCESS;
09EEE:  MOVLW  00
09EF0:  MOVWF  01
09EF2:  MOVLB  0
09EF4:  RETURN 0
.................... }
.................... 
.................... int8 setFilterOn(unsigned int8 rec){
....................    adcFilter = TRUE;
09EF6:  MOVLB  1
09EF8:  BSF    x63.0
....................    return SUCCESS;
09EFA:  MOVLW  00
09EFC:  MOVWF  01
09EFE:  MOVLB  0
09F00:  RETURN 0
.................... }
.................... 
.................... int8 setFilterOff(unsigned int8 rec){
....................    adcFilter = FALSE;
09F02:  MOVLB  1
09F04:  BCF    x63.0
....................    return SUCCESS;
09F06:  MOVLW  00
09F08:  MOVWF  01
09F0A:  MOVLB  0
09F0C:  RETURN 0
.................... }
.................... 
.................... int8 setHomeAxis(unsigned int8 rec){
....................     /*** ARG CHECKS ********************/
....................     int8 arg1;
....................     
....................     if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
09F0E:  MOVLB  7
09F10:  CLRF   x42
09F12:  MOVFF  690,741
09F16:  CLRF   x44
09F18:  MOVLW  B5
09F1A:  MOVWF  x43
09F1C:  MOVLB  0
09F1E:  CALL   08A6
09F22:  MOVFF  02,70D
09F26:  MOVFF  01,70C
09F2A:  MOVLW  06
09F2C:  MOVLB  7
09F2E:  ADDWF  x0C,F
09F30:  MOVLW  00
09F32:  ADDWFC x0D,F
09F34:  MOVLW  32
09F36:  ADDWF  x0C,W
09F38:  MOVWF  01
09F3A:  MOVLW  00
09F3C:  ADDWFC x0D,W
09F3E:  MOVWF  03
09F40:  MOVF   01,W
09F42:  ADDLW  EB
09F44:  MOVWF  01
09F46:  MOVLW  01
09F48:  ADDWFC 03,F
09F4A:  MOVFF  01,70C
09F4E:  MOVFF  03,70D
09F52:  MOVFF  03,734
09F56:  MOVFF  01,733
09F5A:  MOVLB  0
09F5C:  CALL   5C1C
09F60:  MOVF   01,F
09F62:  BNZ   9F6C
09F64:  MOVLW  02
09F66:  MOVWF  01
09F68:  BRA    9FF8
09F6A:  BRA    9FCA
....................     else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
09F6C:  MOVLB  7
09F6E:  CLRF   x42
09F70:  MOVFF  690,741
09F74:  CLRF   x44
09F76:  MOVLW  B5
09F78:  MOVWF  x43
09F7A:  MOVLB  0
09F7C:  CALL   08A6
09F80:  MOVFF  02,70D
09F84:  MOVFF  01,70C
09F88:  MOVLW  06
09F8A:  MOVLB  7
09F8C:  ADDWF  x0C,F
09F8E:  MOVLW  00
09F90:  ADDWFC x0D,F
09F92:  MOVLW  32
09F94:  ADDWF  x0C,W
09F96:  MOVWF  01
09F98:  MOVLW  00
09F9A:  ADDWFC x0D,W
09F9C:  MOVWF  03
09F9E:  MOVF   01,W
09FA0:  ADDLW  EB
09FA2:  MOVWF  01
09FA4:  MOVLW  01
09FA6:  ADDWFC 03,F
09FA8:  MOVFF  01,70C
09FAC:  MOVFF  03,70D
09FB0:  MOVFF  03,734
09FB4:  MOVFF  01,733
09FB8:  CLRF   x36
09FBA:  CLRF   x35
09FBC:  MOVLW  0A
09FBE:  MOVWF  x37
09FC0:  MOVLB  0
09FC2:  CALL   5D0C
09FC6:  MOVFF  01,70B
....................     
....................     adcVals[arg1-1].homeFlag = TRUE;
09FCA:  MOVLW  01
09FCC:  MOVLB  7
09FCE:  SUBWF  x0B,W
09FD0:  MULLW  26
09FD2:  MOVF   FF3,W
09FD4:  CLRF   x0D
09FD6:  MOVWF  x0C
09FD8:  MOVLW  25
09FDA:  ADDWF  x0C,W
09FDC:  MOVWF  01
09FDE:  MOVLW  00
09FE0:  ADDWFC x0D,W
09FE2:  MOVWF  03
09FE4:  MOVF   01,W
09FE6:  ADDLW  17
09FE8:  MOVWF  FE9
09FEA:  MOVLW  01
09FEC:  ADDWFC 03,W
09FEE:  MOVWF  FEA
09FF0:  BSF    FEF.0
....................     
....................     return SUCCESS;
09FF2:  MOVLW  00
09FF4:  MOVWF  01
09FF6:  MOVLB  0
09FF8:  RETURN 0
.................... }
.................... 
.................... int8 invalidCmd(unsigned int8 rec){
....................    return INV_CMD;
09FFA:  MOVLW  01
09FFC:  MOVWF  01
09FFE:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* ARG VALIDATION HELPER FUNCS                                               */
.................... /*****************************************************************************/
.................... BOOLEAN arg_is_float(char *arg){
*
06D30:  MOVLB  7
06D32:  BCF    x16.0
....................    BOOLEAN decimal = FALSE;
....................    for (int i=0; i<strlen(arg); i++){
06D34:  CLRF   x17
06D36:  MOVFF  715,742
06D3A:  MOVFF  714,741
06D3E:  MOVLB  0
06D40:  CALL   5588
06D44:  MOVFF  02,03
06D48:  MOVF   01,W
06D4A:  MOVF   03,F
06D4C:  BNZ   6D58
06D4E:  MOVF   01,W
06D50:  MOVLB  7
06D52:  SUBWF  x17,W
06D54:  BC    6DEA
06D56:  MOVLB  0
....................       if (!isdigit(arg[i])){
06D58:  MOVLB  7
06D5A:  MOVF   x17,W
06D5C:  ADDWF  x14,W
06D5E:  MOVWF  FE9
06D60:  MOVLW  00
06D62:  ADDWFC x15,W
06D64:  MOVWF  FEA
06D66:  MOVFF  FEF,718
06D6A:  MOVF   x18,W
06D6C:  SUBLW  2F
06D6E:  BC    6D76
06D70:  MOVF   x18,W
06D72:  SUBLW  39
06D74:  BC    6DE2
....................          // Check for negative sign
....................          if ('-' != arg[i]){
06D76:  MOVF   x17,W
06D78:  ADDWF  x14,W
06D7A:  MOVWF  FE9
06D7C:  MOVLW  00
06D7E:  ADDWFC x15,W
06D80:  MOVWF  FEA
06D82:  MOVF   FEF,W
06D84:  SUBLW  2D
06D86:  BZ    6DB2
....................             // Check for decimal
....................             if ('.' != arg[i]) return FALSE;
06D88:  MOVF   x17,W
06D8A:  ADDWF  x14,W
06D8C:  MOVWF  FE9
06D8E:  MOVLW  00
06D90:  ADDWFC x15,W
06D92:  MOVWF  FEA
06D94:  MOVF   FEF,W
06D96:  SUBLW  2E
06D98:  BZ    6DA2
06D9A:  MOVLW  00
06D9C:  MOVWF  01
06D9E:  BRA    6DEE
06DA0:  BRA    6DB0
....................             else if  (decimal) return FALSE;
06DA2:  BTFSS  x16.0
06DA4:  BRA    6DAE
06DA6:  MOVLW  00
06DA8:  MOVWF  01
06DAA:  BRA    6DEE
06DAC:  BRA    6DB0
....................             else decimal = TRUE;
06DAE:  BSF    x16.0
....................          }
06DB0:  BRA    6DE2
....................          else if (0 != i) return FALSE;
06DB2:  MOVF   x17,F
06DB4:  BZ    6DBE
06DB6:  MOVLW  00
06DB8:  MOVWF  01
06DBA:  BRA    6DEE
06DBC:  BRA    6DE2
....................          else if (1 == strlen(arg)) return FALSE;
06DBE:  MOVFF  715,742
06DC2:  MOVFF  714,741
06DC6:  MOVLB  0
06DC8:  CALL   5588
06DCC:  MOVFF  02,03
06DD0:  MOVF   01,W
06DD2:  SUBLW  01
06DD4:  BNZ   6DE4
06DD6:  MOVF   03,F
06DD8:  BNZ   6DE4
06DDA:  MOVLW  00
06DDC:  MOVWF  01
06DDE:  MOVLB  7
06DE0:  BRA    6DEE
06DE2:  MOVLB  0
....................       }
06DE4:  MOVLB  7
06DE6:  INCF   x17,F
06DE8:  BRA    6D36
....................    }
....................    return TRUE;
06DEA:  MOVLW  01
06DEC:  MOVWF  01
06DEE:  MOVLB  0
06DF0:  RETURN 0
.................... }
.................... 
.................... BOOLEAN is_valid_channel(char *arg){
....................     if (1 != strlen(arg)) return FALSE;
*
05C1C:  MOVFF  734,742
05C20:  MOVFF  733,741
05C24:  RCALL  5588
05C26:  MOVFF  02,03
05C2A:  MOVF   01,W
05C2C:  SUBLW  01
05C2E:  BNZ   5C34
05C30:  MOVF   03,F
05C32:  BZ    5C3C
05C34:  MOVLW  00
05C36:  MOVWF  01
05C38:  BRA    5C6A
05C3A:  BRA    5C62
....................     else if ('1' != arg[0] && '2' != arg[0]) return FALSE;
05C3C:  MOVLB  7
05C3E:  MOVFF  733,FE9
05C42:  MOVFF  734,FEA
05C46:  MOVF   FEF,W
05C48:  SUBLW  31
05C4A:  BZ    5C64
05C4C:  MOVFF  733,FE9
05C50:  MOVFF  734,FEA
05C54:  MOVF   FEF,W
05C56:  SUBLW  32
05C58:  BZ    5C64
05C5A:  MOVLW  00
05C5C:  MOVWF  01
05C5E:  MOVLB  0
05C60:  BRA    5C6A
05C62:  MOVLB  7
....................     return TRUE;
05C64:  MOVLW  01
05C66:  MOVWF  01
05C68:  MOVLB  0
05C6A:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* ASCII HEX CHARACTER TO INT                                                */
.................... /*****************************************************************************/
.................... int8 hex_to_int(char ascii){
....................    if (ascii >= '0' && ascii <= '9') return ascii-'0';
*
05AC2:  MOVLB  7
05AC4:  MOVF   x0A,W
05AC6:  SUBLW  2F
05AC8:  BC    5ADA
05ACA:  MOVF   x0A,W
05ACC:  SUBLW  39
05ACE:  BNC   5ADA
05AD0:  MOVLW  30
05AD2:  SUBWF  x0A,W
05AD4:  MOVWF  01
05AD6:  BRA    5AF6
05AD8:  BRA    5AF6
....................    else if (ascii >= 'A' && ascii <= 'F') return ascii-'A'+10;
05ADA:  MOVF   x0A,W
05ADC:  SUBLW  40
05ADE:  BC    5AF2
05AE0:  MOVF   x0A,W
05AE2:  SUBLW  46
05AE4:  BNC   5AF2
05AE6:  MOVLW  41
05AE8:  SUBWF  x0A,W
05AEA:  ADDLW  0A
05AEC:  MOVWF  01
05AEE:  BRA    5AF6
05AF0:  BRA    5AF6
....................    else return 0xFF;
05AF2:  MOVLW  FF
05AF4:  MOVWF  01
05AF6:  MOVLB  0
05AF8:  GOTO   A0A4 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* COMMAND HANDLER/PARSER FUNCS                                              */
.................... /*****************************************************************************/
.................... void echo_cmd(unsigned int8 rec){
....................    fprintf(SERIAL, "%c", SERcmd[rec].t);
....................    while (SERcmd[rec].recReadIndex <= SERcmd[rec].recWriteIndex)
....................    {
....................       if (SERcmd[rec].recReadIndex != 0) fprintf(SERIAL, "%c", delimiter);
....................       fprintf(SERIAL, "%s", SERcmd[rec].p[SERcmd[rec].recReadIndex]);
....................       SERcmd[rec].recReadIndex++;
....................    }
....................    SERcmd[rec].recReadIndex=0;
.................... }
.................... 
.................... int8 command_parser(unsigned int8 rec){
*
0A000:  MOVLB  7
0A002:  CLRF   x42
0A004:  MOVFF  701,741
0A008:  CLRF   x44
0A00A:  MOVLW  B5
0A00C:  MOVWF  x43
0A00E:  MOVLB  0
0A010:  CALL   08A6
0A014:  MOVFF  02,70A
0A018:  MOVFF  01,709
0A01C:  MOVLW  06
0A01E:  MOVLB  7
0A020:  ADDWF  x09,F
0A022:  MOVLW  00
0A024:  ADDWFC x0A,F
0A026:  MOVLW  EB
0A028:  ADDWF  x09,W
0A02A:  MOVWF  01
0A02C:  MOVLW  01
0A02E:  ADDWFC x0A,W
0A030:  MOVWF  03
0A032:  MOVFF  01,702
0A036:  MOVWF  x03
0A038:  CLRF   x42
0A03A:  MOVFF  701,741
0A03E:  CLRF   x44
0A040:  MOVLW  B5
0A042:  MOVWF  x43
0A044:  MOVLB  0
0A046:  CALL   08A6
0A04A:  MOVFF  02,70C
0A04E:  MOVFF  01,70B
0A052:  MOVLW  06
0A054:  MOVLB  7
0A056:  ADDWF  x0B,F
0A058:  MOVLW  00
0A05A:  ADDWFC x0C,F
0A05C:  MOVLW  19
0A05E:  ADDWF  x0B,W
0A060:  MOVWF  01
0A062:  MOVLW  00
0A064:  ADDWFC x0C,W
0A066:  MOVWF  03
0A068:  MOVF   01,W
0A06A:  ADDLW  EB
0A06C:  MOVWF  01
0A06E:  MOVLW  01
0A070:  ADDWFC 03,F
0A072:  MOVFF  01,704
0A076:  MOVFF  03,705
0A07A:  CLRF   x06
0A07C:  CLRF   x07
....................    char *cmd_adr = SERcmd[rec].p[0];
....................    char *cmd_str = SERcmd[rec].p[1];
.................... //!   int8 devID = input_a();
....................    int8 devID = 0;
....................    int8 i = 0;
....................    
....................    if (hwID == cmd_adr[0]){
0A07E:  MOVFF  702,FE9
0A082:  MOVFF  703,FEA
0A086:  MOVF   FEF,W
0A088:  SUBLW  44
0A08A:  BTFSS  FD8.2
0A08C:  BRA    A17C
....................       if (hex_to_int(cmd_adr[1]) == (devID & 0x0F)){
0A08E:  MOVLW  01
0A090:  ADDWF  x02,W
0A092:  MOVWF  FE9
0A094:  MOVLW  00
0A096:  ADDWFC x03,W
0A098:  MOVWF  FEA
0A09A:  MOVFF  FEF,70A
0A09E:  MOVLB  0
0A0A0:  GOTO   5AC2
0A0A4:  MOVFF  01,709
0A0A8:  MOVLB  7
0A0AA:  MOVF   x06,W
0A0AC:  ANDLW  0F
0A0AE:  SUBWF  01,W
0A0B0:  BNZ   A174
....................          while (0 != strlen(cmd_list[i].cmd_name)){
0A0B2:  MOVF   x07,W
0A0B4:  MULLW  04
0A0B6:  MOVF   FF3,W
0A0B8:  CLRF   x0A
0A0BA:  MOVWF  x09
0A0BC:  MOVLW  6A
0A0BE:  ADDWF  x09,W
0A0C0:  MOVWF  FE9
0A0C2:  MOVLW  05
0A0C4:  ADDWFC x0A,W
0A0C6:  MOVWF  FEA
0A0C8:  MOVFF  FEC,742
0A0CC:  MOVF   FED,F
0A0CE:  MOVFF  FEF,741
0A0D2:  MOVLB  0
0A0D4:  CALL   5588
0A0D8:  MOVFF  02,03
0A0DC:  MOVF   01,W
0A0DE:  BNZ   A0E4
0A0E0:  MOVF   03,F
0A0E2:  BZ    A16A
....................             if (0 == strcmp(cmd_str, cmd_list[i].cmd_name))
0A0E4:  MOVLB  7
0A0E6:  MOVF   x07,W
0A0E8:  MULLW  04
0A0EA:  MOVF   FF3,W
0A0EC:  CLRF   x0A
0A0EE:  MOVWF  x09
0A0F0:  MOVLW  6A
0A0F2:  ADDWF  x09,W
0A0F4:  MOVWF  FE9
0A0F6:  MOVLW  05
0A0F8:  ADDWFC x0A,W
0A0FA:  MOVWF  FEA
0A0FC:  MOVFF  FEC,744
0A100:  MOVF   FED,F
0A102:  MOVFF  FEF,743
0A106:  MOVFF  705,742
0A10A:  MOVFF  704,741
0A10E:  MOVLB  0
0A110:  CALL   5AFC
0A114:  MOVF   01,F
0A116:  BNZ   A162
....................             {
....................                int8 return_code = cmd_list[i].cmd_func(rec);
0A118:  MOVLB  7
0A11A:  MOVF   x07,W
0A11C:  MULLW  04
0A11E:  MOVF   FF3,W
0A120:  CLRF   x0A
0A122:  MOVWF  x09
0A124:  MOVLW  02
0A126:  ADDWF  x09,W
0A128:  MOVWF  01
0A12A:  MOVLW  00
0A12C:  ADDWFC x0A,W
0A12E:  MOVWF  03
0A130:  MOVF   01,W
0A132:  ADDLW  6A
0A134:  MOVWF  01
0A136:  MOVLW  05
0A138:  ADDWFC 03,F
0A13A:  MOVFF  01,709
0A13E:  MOVFF  03,70A
0A142:  MOVFF  03,FEA
0A146:  MOVFF  01,FE9
0A14A:  MOVFF  701,690
0A14E:  MOVLB  0
0A150:  CALL   00BC
0A154:  MOVFF  01,708
....................                return return_code;
0A158:  MOVLB  7
0A15A:  MOVFF  708,01
0A15E:  BRA    A180
0A160:  MOVLB  0
....................             }
....................             i++;
0A162:  MOVLB  7
0A164:  INCF   x07,F
0A166:  BRA    A0B2
0A168:  MOVLB  0
....................          }
....................          return INV_CMD; // INVALID_CMD
0A16A:  MOVLW  01
0A16C:  MOVWF  01
0A16E:  MOVLB  7
0A170:  BRA    A180
....................       } else return 254; // NOT THIS ADDRESS
0A172:  BRA    A17A
0A174:  MOVLW  FE
0A176:  MOVWF  01
0A178:  BRA    A180
....................    } else return 255; // NOT THIS DEVICE TYPE
0A17A:  BRA    A180
0A17C:  MOVLW  FF
0A17E:  MOVWF  01
0A180:  MOVLB  0
0A182:  GOTO   A286 (RETURN)
.................... }
.................... 
.................... void command_handler_task(){
....................    while (getNextSERReadIndex())
*
0A1EA:  GOTO   5A44
0A1EE:  MOVF   01,F
0A1F0:  BTFSC  FD8.2
0A1F2:  BRA    A310
....................    {
....................       int8 return_code;
....................       //echo_cmd(SRI);
....................       sprintf(retData + strlen(retData), "$%s,", SERcmd[SRI].p[0]);
0A1F4:  MOVLW  04
0A1F6:  MOVLB  7
0A1F8:  MOVWF  x42
0A1FA:  MOVLW  C1
0A1FC:  MOVWF  x41
0A1FE:  MOVLB  0
0A200:  CALL   5588
0A204:  MOVFF  02,03
0A208:  MOVF   01,W
0A20A:  ADDLW  C1
0A20C:  MOVLB  7
0A20E:  MOVWF  x00
0A210:  MOVLW  04
0A212:  ADDWFC 02,W
0A214:  MOVWF  x01
0A216:  CLRF   x42
0A218:  MOVFF  4BF,741
0A21C:  CLRF   x44
0A21E:  MOVLW  B5
0A220:  MOVWF  x43
0A222:  MOVLB  0
0A224:  CALL   08A6
0A228:  MOVFF  02,703
0A22C:  MOVFF  01,702
0A230:  MOVLW  06
0A232:  MOVLB  7
0A234:  ADDWF  x02,F
0A236:  MOVLW  00
0A238:  ADDWFC x03,F
0A23A:  MOVLW  EB
0A23C:  ADDWF  x02,W
0A23E:  MOVWF  01
0A240:  MOVLW  01
0A242:  ADDWFC x03,W
0A244:  MOVWF  03
0A246:  MOVFF  01,704
0A24A:  MOVWF  x05
0A24C:  MOVFF  701,565
0A250:  MOVFF  700,564
0A254:  MOVLW  24
0A256:  MOVWF  x50
0A258:  MOVLB  0
0A25A:  CALL   55C0
0A25E:  MOVFF  565,FEA
0A262:  MOVFF  564,FE9
0A266:  CLRF   FEF
0A268:  MOVFF  705,FEA
0A26C:  MOVFF  704,FE9
0A270:  CALL   5A9E
0A274:  MOVLW  2C
0A276:  MOVLB  7
0A278:  MOVWF  x50
0A27A:  MOVLB  0
0A27C:  CALL   55C0
....................       
....................       return_code = command_parser(SRI);
0A280:  MOVFF  4BF,701
0A284:  BRA    A000
0A286:  MOVFF  01,6FB
....................       
....................       sprintf(retData + strlen(retData), "%s", resp_list[return_code].msg);
0A28A:  MOVLW  04
0A28C:  MOVLB  7
0A28E:  MOVWF  x42
0A290:  MOVLW  C1
0A292:  MOVWF  x41
0A294:  MOVLB  0
0A296:  CALL   5588
0A29A:  MOVF   01,W
0A29C:  ADDLW  C1
0A29E:  MOVLB  7
0A2A0:  MOVWF  x00
0A2A2:  MOVLW  04
0A2A4:  ADDWFC 02,W
0A2A6:  MOVWF  x01
0A2A8:  MOVLB  6
0A2AA:  MOVF   xFB,W
0A2AC:  MULLW  03
0A2AE:  MOVF   FF3,W
0A2B0:  MOVLB  7
0A2B2:  CLRF   x03
0A2B4:  MOVWF  x02
0A2B6:  MOVLW  01
0A2B8:  ADDWF  x02,W
0A2BA:  MOVWF  01
0A2BC:  MOVLW  00
0A2BE:  ADDWFC x03,W
0A2C0:  MOVWF  03
0A2C2:  MOVF   01,W
0A2C4:  ADDLW  5C
0A2C6:  MOVWF  FE9
0A2C8:  MOVLW  06
0A2CA:  ADDWFC 03,W
0A2CC:  MOVWF  FEA
0A2CE:  MOVFF  FEC,703
0A2D2:  MOVF   FED,F
0A2D4:  MOVFF  FEF,702
0A2D8:  MOVFF  701,565
0A2DC:  MOVFF  700,564
0A2E0:  MOVFF  565,FEA
0A2E4:  MOVFF  564,FE9
0A2E8:  CLRF   FEF
0A2EA:  MOVFF  703,FEA
0A2EE:  MOVFF  702,FE9
0A2F2:  MOVLB  0
0A2F4:  CALL   5A9E
....................       serial_out(retData);
0A2F8:  MOVLW  04
0A2FA:  MOVLB  7
0A2FC:  MOVWF  x02
0A2FE:  MOVLW  C1
0A300:  MOVWF  x01
0A302:  MOVLB  0
0A304:  BRA    A186
....................       resetSERcmd(SRI);
0A306:  MOVFF  4BF,701
0A30A:  CALL   0B8A
0A30E:  BRA    A1EA
....................    }
0A310:  GOTO   AAE6 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... #define DEBUG_1
.................... 
.................... void main()
0A314:  CLRF   FF8
0A316:  BCF    FF2.5
0A318:  BSF    07.7
0A31A:  MOVLB  E
0A31C:  MOVLW  55
0A31E:  MOVWF  x9B
0A320:  MOVLW  AA
0A322:  MOVWF  x9B
0A324:  BCF    x9B.0
0A326:  MOVLW  17
0A328:  MOVWF  xB0
0A32A:  MOVLW  13
0A32C:  MOVWF  xB2
0A32E:  MOVLW  09
0A330:  MOVWF  x8A
0A332:  MOVLW  0A
0A334:  MOVWF  x8B
0A336:  MOVLW  11
0A338:  MOVWF  xEB
0A33A:  MOVLW  12
0A33C:  MOVWF  xED
0A33E:  MOVLW  10
0A340:  MOVWF  xF4
0A342:  MOVLW  0F
0A344:  MOVWF  xF5
0A346:  MOVLW  09
0A348:  MOVWF  xF8
0A34A:  MOVLW  55
0A34C:  MOVWF  x9B
0A34E:  MOVLW  AA
0A350:  MOVWF  x9B
0A352:  BSF    x9B.0
0A354:  CLRF   xD8
0A356:  CLRF   xD5
0A358:  CLRF   xD7
0A35A:  MOVLW  08
0A35C:  MOVWF  xD9
0A35E:  MOVLW  60
0A360:  MOVWF  xD3
0A362:  MOVLW  AA
0A364:  MOVLB  0
0A366:  MOVWF  xFA
0A368:  MOVLB  1
0A36A:  BCF    x63.0
0A36C:  CLRF   x75
0A36E:  CLRF   x74
0A370:  CLRF   x73
0A372:  CLRF   x72
0A374:  CLRF   x79
0A376:  CLRF   x78
0A378:  CLRF   x77
0A37A:  CLRF   x76
0A37C:  CLRF   x7D
0A37E:  CLRF   x7C
0A380:  CLRF   x7B
0A382:  CLRF   x7A
0A384:  CLRF   x7F
0A386:  CLRF   x7E
0A388:  MOVLB  E
0A38A:  BCF    x91.5
0A38C:  MOVLW  00
0A38E:  MOVWF  x90
0A390:  MOVLW  03
0A392:  MOVWF  x8E
0A394:  MOVLW  2A
0A396:  MOVWF  x91
0A398:  MOVLW  04
0A39A:  MOVWF  F88
0A39C:  MOVWF  F88
0A39E:  MOVWF  F88
0A3A0:  MOVLB  1
0A3A2:  CLRF   xD0
0A3A4:  CLRF   xD1
0A3A6:  CLRF   xD2
0A3A8:  CLRF   xD3
0A3AA:  BCF    F95.5
0A3AC:  MOVLW  40
0A3AE:  MOVWF  F94
0A3B0:  MOVLW  9F
0A3B2:  MOVWF  F92
0A3B4:  MOVLW  3A
0A3B6:  MOVWF  F95
0A3B8:  MOVLW  93
0A3BA:  MOVWF  F89
0A3BC:  MOVWF  F89
0A3BE:  MOVLB  4
0A3C0:  CLRF   xBF
0A3C2:  CLRF   xC0
0A3C4:  MOVLB  5
0A3C6:  CLRF   x61
0A3C8:  CLRF   x62
0A3CA:  MOVLB  1
0A3CC:  BCF    x63.1
0A3CE:  MOVLW  04
0A3D0:  MOVWF  F88
0A3D2:  BSF    F83.7
0A3D4:  MOVLW  12
0A3D6:  MOVWF  03
0A3D8:  MOVLW  FA
0A3DA:  MOVLB  7
0A3DC:  MOVWF  x01
0A3DE:  MOVLB  0
0A3E0:  CALL   03D0
0A3E4:  DECFSZ 03,F
0A3E6:  BRA    A3EA
0A3E8:  BRA    A3EE
0A3EA:  MOVLB  1
0A3EC:  BRA    A3D8
0A3EE:  MOVLB  5
0A3F0:  CLRF   x63
0A3F2:  BSF    F9E.3
0A3F4:  MOVLW  7C
0A3F6:  MOVWF  F9A
0A3F8:  MOVLW  00
0A3FA:  MOVWF  F9B
0A3FC:  MOVLW  A6
0A3FE:  MOVWF  F9D
0A400:  MOVLW  90
0A402:  MOVWF  F9C
0A404:  CLRF   x65
0A406:  CLRF   x64
0A408:  CLRF   x69
0A40A:  CLRF   x68
0A40C:  CLRF   x67
0A40E:  CLRF   x66
0A410:  MOVLB  F
0A412:  CLRF   x0C
0A414:  CLRF   x14
0A416:  CLRF   x1C
0A418:  CLRF   x21
0A41A:  CLRF   x29
0A41C:  CLRF   x35
0A41E:  CLRF   x36
0A420:  CLRF   x37
0A422:  CLRF   x34
0A424:  CLRF   x31
0A426:  CLRF   x32
0A428:  CLRF   x33
0A42A:  CLRF   x30
0A42C:  MOVLW  5B
0A42E:  MOVLB  5
0A430:  MOVWF  x6D
0A432:  MOVLW  94
0A434:  MOVWF  x6C
0A436:  MOVLW  5B
0A438:  MOVWF  x71
0A43A:  MOVLW  D8
0A43C:  MOVWF  x70
0A43E:  MOVLW  61
0A440:  MOVWF  x75
0A442:  MOVLW  28
0A444:  MOVWF  x74
0A446:  MOVLW  63
0A448:  MOVWF  x79
0A44A:  MOVLW  16
0A44C:  MOVWF  x78
0A44E:  MOVLW  64
0A450:  MOVWF  x7D
0A452:  MOVLW  C4
0A454:  MOVWF  x7C
0A456:  MOVLW  66
0A458:  MOVWF  x81
0A45A:  MOVLW  54
0A45C:  MOVWF  x80
0A45E:  MOVLW  68
0A460:  MOVWF  x85
0A462:  MOVLW  6E
0A464:  MOVWF  x84
0A466:  MOVLW  70
0A468:  MOVWF  x89
0A46A:  MOVLW  4C
0A46C:  MOVWF  x88
0A46E:  MOVLW  73
0A470:  MOVWF  x8D
0A472:  MOVLW  2C
0A474:  MOVWF  x8C
0A476:  MOVLW  74
0A478:  MOVWF  x91
0A47A:  MOVLW  8E
0A47C:  MOVWF  x90
0A47E:  MOVLW  76
0A480:  MOVWF  x95
0A482:  MOVLW  4C
0A484:  MOVWF  x94
0A486:  MOVLW  7A
0A488:  MOVWF  x99
0A48A:  MOVLW  02
0A48C:  MOVWF  x98
0A48E:  MOVLW  7F
0A490:  MOVWF  x9D
0A492:  MOVLW  5E
0A494:  MOVWF  x9C
0A496:  MOVLW  82
0A498:  MOVWF  xA1
0A49A:  MOVLW  F6
0A49C:  MOVWF  xA0
0A49E:  MOVLW  88
0A4A0:  MOVWF  xA5
0A4A2:  MOVLW  22
0A4A4:  MOVWF  xA4
0A4A6:  MOVLW  88
0A4A8:  MOVWF  xA9
0A4AA:  MOVLW  28
0A4AC:  MOVWF  xA8
0A4AE:  MOVLW  8E
0A4B0:  MOVWF  xAD
0A4B2:  MOVLW  9C
0A4B4:  MOVWF  xAC
0A4B6:  MOVLW  94
0A4B8:  MOVWF  xB1
0A4BA:  MOVLW  00
0A4BC:  MOVWF  xB0
0A4BE:  MOVLW  9B
0A4C0:  MOVWF  xB5
0A4C2:  MOVLW  22
0A4C4:  MOVWF  xB4
0A4C6:  MOVLW  9C
0A4C8:  MOVWF  xB9
0A4CA:  MOVLW  84
0A4CC:  MOVWF  xB8
0A4CE:  MOVLW  9E
0A4D0:  MOVWF  xBD
0A4D2:  MOVLW  F6
0A4D4:  MOVWF  xBC
0A4D6:  MOVLW  9F
0A4D8:  MOVWF  xC1
0A4DA:  MOVLW  02
0A4DC:  MOVWF  xC0
0A4DE:  MOVLW  9F
0A4E0:  MOVWF  xC5
0A4E2:  MOVLW  0E
0A4E4:  MOVWF  xC4
0A4E6:  MOVLW  9F
0A4E8:  MOVWF  xC9
0A4EA:  MOVLW  FA
0A4EC:  MOVWF  xC8
0A4EE:  BRA    A6CE
0A4F0:  DATA 02,00
0A4F2:  DATA 1A,00
0A4F4:  DATA 00,0C
0A4F6:  DATA 00,20
0A4F8:  DATA 78,23
0A4FA:  DATA D7,0A
0A4FC:  DATA 7D,19
0A4FE:  DATA 99,9A
0A500:  DATA 7B,4C
0A502:  DATA CC,CD
0A504:  DATA 1C,C0
0A506:  DATA 00,0C
0A508:  DATA 80,78
0A50A:  DATA 23,D7
0A50C:  DATA 0A,7D
0A50E:  DATA 19,99
0A510:  DATA 9A,7B
0A512:  DATA 4C,CC
0A514:  DATA CD,1C
0A516:  DATA C0,00
0A518:  DATA 01,80
0A51A:  DATA 02,09
0A51C:  DATA C0,00
0A51E:  DATA 05,80
0A520:  DATA 7F,00
0A522:  DATA 00,00
0A524:  DATA 7F,0B
0A526:  DATA C0,00
0A528:  DATA 05,80
0A52A:  DATA 7F,00
0A52C:  DATA 00,00
0A52E:  DATA 7F,07
0A530:  DATA C0,00
0A532:  DATA 01,80
0A534:  DATA 7F,17
0A536:  DATA C0,00
0A538:  DATA 01,80
0A53A:  DATA 7F,17
0A53C:  DATA C0,00
0A53E:  DATA 04,80
0A540:  DATA 79,B7
0A542:  DATA F3,BD
0A544:  DATA 04,C0
0A546:  DATA 00,04
0A548:  DATA 80,7C
0A54A:  DATA 59,DF
0A54C:  DATA 4E,04
0A54E:  DATA C0,00
0A550:  DATA 04,80
0A552:  DATA 78,0A
0A554:  DATA 28,88
0A556:  DATA 04,C0
0A558:  DATA 00,04
0A55A:  DATA 80,78
0A55C:  DATA 05,EA
0A55E:  DATA 16,04
0A560:  DATA C0,00
0A562:  DATA 04,80
0A564:  DATA 78,1E
0A566:  DATA 33,D7
0A568:  DATA 04,C0
0A56A:  DATA 00,04
0A56C:  DATA 80,77
0A56E:  DATA 68,7B
0A570:  DATA BB,04
0A572:  DATA C0,00
0A574:  DATA 04,80
0A576:  DATA 77,68
0A578:  DATA 0D,C6
0A57A:  DATA 68,40
0A57C:  DATA FB,00
0A57E:  DATA 0E,41
0A580:  DATA 64,00
0A582:  DATA 17,41
0A584:  DATA D4,00
0A586:  DATA 3C,45
0A588:  DATA 25,00
0A58A:  DATA 02,05
0A58C:  DATA 6A,CA
0A58E:  DATA 05,02
0A590:  DATA 05,6E
0A592:  DATA CD,05
0A594:  DATA 02,05
0A596:  DATA 72,D0
0A598:  DATA 05,02
0A59A:  DATA 05,76
0A59C:  DATA D7,05
0A59E:  DATA 02,05
0A5A0:  DATA 7A,DE
0A5A2:  DATA 05,02
0A5A4:  DATA 05,7E
0A5A6:  DATA E6,05
0A5A8:  DATA 02,05
0A5AA:  DATA 82,EE
0A5AC:  DATA 05,02
0A5AE:  DATA 05,86
0A5B0:  DATA F3,05
0A5B2:  DATA 02,05
0A5B4:  DATA 8A,F8
0A5B6:  DATA 05,02
0A5B8:  DATA 05,8E
0A5BA:  DATA FC,05
0A5BC:  DATA 02,05
0A5BE:  DATA 92,00
0A5C0:  DATA 06,02
0A5C2:  DATA 05,96
0A5C4:  DATA 07,06
0A5C6:  DATA 02,05
0A5C8:  DATA 9A,0D
0A5CA:  DATA 06,02
0A5CC:  DATA 05,9E
0A5CE:  DATA 13,06
0A5D0:  DATA 02,05
0A5D2:  DATA A2,19
0A5D4:  DATA 06,02
0A5D6:  DATA 05,A6
0A5D8:  DATA 1F,06
0A5DA:  DATA 02,05
0A5DC:  DATA AA,24
0A5DE:  DATA 06,02
0A5E0:  DATA 05,AE
0A5E2:  DATA 2D,06
0A5E4:  DATA 02,05
0A5E6:  DATA B2,35
0A5E8:  DATA 06,02
0A5EA:  DATA 05,B6
0A5EC:  DATA 3C,06
0A5EE:  DATA 02,05
0A5F0:  DATA BA,43
0A5F2:  DATA 06,02
0A5F4:  DATA 05,BE
0A5F6:  DATA 4B,06
0A5F8:  DATA 02,05
0A5FA:  DATA C2,54
0A5FC:  DATA 06,02
0A5FE:  DATA 05,C6
0A600:  DATA 5A,06
0A602:  DATA 8F,05
0A604:  DATA CA,67
0A606:  DATA 72,00
0A608:  DATA 67,73
0A60A:  DATA 00,67
0A60C:  DATA 43,68
0A60E:  DATA 4D,61
0A610:  DATA 70,00
0A612:  DATA 73,43
0A614:  DATA 68,4D
0A616:  DATA 61,70
0A618:  DATA 00,67
0A61A:  DATA 43,68
0A61C:  DATA 4D,6F
0A61E:  DATA 64,65
0A620:  DATA 00,73
0A622:  DATA 43,68
0A624:  DATA 4D,6F
0A626:  DATA 64,65
0A628:  DATA 00,67
0A62A:  DATA 50,49
0A62C:  DATA 44,00
0A62E:  DATA 73,50
0A630:  DATA 49,44
0A632:  DATA 00,67
0A634:  DATA 53,50
0A636:  DATA 00,73
0A638:  DATA 53,50
0A63A:  DATA 00,67
0A63C:  DATA 53,43
0A63E:  DATA 61,6C
0A640:  DATA 73,00
0A642:  DATA 67,53
0A644:  DATA 43,61
0A646:  DATA 6C,00
0A648:  DATA 73,53
0A64A:  DATA 43,61
0A64C:  DATA 6C,00
0A64E:  DATA 67,4D
0A650:  DATA 43,61
0A652:  DATA 6C,00
0A654:  DATA 73,4D
0A656:  DATA 43,61
0A658:  DATA 6C,00
0A65A:  DATA 67,4D
0A65C:  DATA 6F,6E
0A65E:  DATA 00,67
0A660:  DATA 50,49
0A662:  DATA 44,64
0A664:  DATA 61,74
0A666:  DATA 61,00
0A668:  DATA 67,49
0A66A:  DATA 50,64
0A66C:  DATA 61,74
0A66E:  DATA 61,00
0A670:  DATA 67,4D
0A672:  DATA 61,6E
0A674:  DATA 4F,50
0A676:  DATA 00,73
0A678:  DATA 4D,61
0A67A:  DATA 6E,4F
0A67C:  DATA 50,00
0A67E:  DATA 73,46
0A680:  DATA 69,6C
0A682:  DATA 74,4F
0A684:  DATA 6E,00
0A686:  DATA 73,46
0A688:  DATA 69,6C
0A68A:  DATA 74,4F
0A68C:  DATA 66,66
0A68E:  DATA 00,73
0A690:  DATA 48,6F
0A692:  DATA 6D,65
0A694:  DATA 04,C0
0A696:  DATA 00,33
0A698:  DATA 80,65
0A69A:  DATA 06,01
0A69C:  DATA 6D,06
0A69E:  DATA 02,7D
0A6A0:  DATA 06,53
0A6A2:  DATA 55,43
0A6A4:  DATA 43,45
0A6A6:  DATA 53,53
0A6A8:  DATA 00,49
0A6AA:  DATA 4E,56
0A6AC:  DATA 41,4C
0A6AE:  DATA 49,44
0A6B0:  DATA 20,43
0A6B2:  DATA 4F,4D
0A6B4:  DATA 4D,41
0A6B6:  DATA 4E,44
0A6B8:  DATA 00,49
0A6BA:  DATA 4E,56
0A6BC:  DATA 41,4C
0A6BE:  DATA 49,44
0A6C0:  DATA 20,50
0A6C2:  DATA 41,52
0A6C4:  DATA 41,4D
0A6C6:  DATA 45,54
0A6C8:  DATA 45,52
0A6CA:  DATA 00,00
0A6CC:  DATA 00,00
0A6CE:  MOVLW  00
0A6D0:  MOVWF  FF8
0A6D2:  MOVLW  A4
0A6D4:  MOVWF  FF7
0A6D6:  MOVLW  F0
0A6D8:  MOVWF  FF6
0A6DA:  TBLRD*+
0A6DC:  MOVF   FF5,W
0A6DE:  MOVWF  00
0A6E0:  XORLW  00
0A6E2:  BZ    A70A
0A6E4:  TBLRD*+
0A6E6:  MOVF   FF5,W
0A6E8:  MOVWF  01
0A6EA:  BTFSC  FE8.7
0A6EC:  BRA    A6F8
0A6EE:  ANDLW  3F
0A6F0:  MOVWF  FEA
0A6F2:  TBLRD*+
0A6F4:  MOVFF  FF5,FE9
0A6F8:  BTFSC  01.6
0A6FA:  TBLRD*+
0A6FC:  BTFSS  01.6
0A6FE:  TBLRD*+
0A700:  MOVFF  FF5,FEE
0A704:  DCFSNZ 00,F
0A706:  BRA    A6DA
0A708:  BRA    A6FC
0A70A:  CLRF   FF8
0A70C:  MOVLW  03
0A70E:  MOVLB  6
0A710:  MOVWF  x92
0A712:  MOVLW  E8
0A714:  MOVWF  x91
0A716:  CLRF   x94
0A718:  CLRF   x93
0A71A:  CLRF   x96
0A71C:  CLRF   x95
.................... {
....................     int16 loopDelay = 1000;
....................     int16 controlCounter = 0;
....................     int16 debugCounter = 0;
....................    
....................     char pBuff[100];
....................     
....................     IO_init();                    // set up IO 
0A71E:  MOVLB  0
0A720:  GOTO   03FA
....................     params_init();                // load parameters
0A724:  GOTO   0696
....................     monitor_init();               // initialize internal ADC for voltage and current telemetry
0A728:  GOTO   0ACC
....................     control_init();               // initialize the output control DACs
0A72C:  GOTO   0B64
....................     serial_init();                // setup the serial port
0A730:  GOTO   0D04
....................     event_timer_init();
0A734:  GOTO   0D26
.................... //!    setup_wdt(WDT_512MS);
....................     enable_interrupts(GLOBAL);
0A738:  MOVLW  C0
0A73A:  IORWF  FF2,F
....................     
....................     while(TRUE)
....................     {
.................... //!        restart_wdt();
....................         pBuff[0] = '\0';
0A73C:  MOVLB  6
0A73E:  CLRF   x97
....................         
.................... //!        if (adcVals[chX].homeFlag) home_axis(chX);
.................... //!        if (adcVals[chY].homeFlag) home_axis(chY);
....................                 
....................         internal_monitor_task();   //Update monitored voltage and currents etc
0A740:  MOVLB  0
0A742:  GOTO   10FE
....................         sensor_monitor_task();     //get magnetoresistive sensor data
0A746:  GOTO   444E
....................       
....................         if (controlCounter >= 2){
0A74A:  MOVLB  6
0A74C:  MOVF   x94,F
0A74E:  BNZ   A756
0A750:  MOVF   x93,W
0A752:  SUBLW  01
0A754:  BC    A764
....................             control_task();
0A756:  MOVLB  0
0A758:  GOTO   4FC6
....................             controlCounter = 0;
0A75C:  MOVLB  6
0A75E:  CLRF   x94
0A760:  CLRF   x93
....................         }else controlCounter++;
0A762:  BRA    A76A
0A764:  INCF   x93,F
0A766:  BTFSC  FD8.2
0A768:  INCF   x94,F
....................       
....................         serial_task();             
0A76A:  MOVLB  0
0A76C:  GOTO   5070
....................       
....................         #ifdef DEBUG_1
....................         if (debugCounter >= 0){
....................             static int8 ch = 0;
....................             sprintf(pBuff+strlen(pBuff), "CNT,%u,%.0f,%.0f;", ch+1, adcVals[ch].sinCounts, adcVals[ch].cosCounts);
0A770:  MOVLW  06
0A772:  MOVLB  7
0A774:  MOVWF  x42
0A776:  MOVLW  97
0A778:  MOVWF  x41
0A77A:  MOVLB  0
0A77C:  CALL   5588
0A780:  MOVF   01,W
0A782:  ADDLW  97
0A784:  MOVLB  6
0A786:  MOVWF  xFB
0A788:  MOVLW  06
0A78A:  ADDWFC 02,W
0A78C:  MOVWF  xFC
0A78E:  MOVLW  01
0A790:  ADDWF  x8F,W
0A792:  MOVWF  xFD
0A794:  MOVF   x8F,W
0A796:  MULLW  26
0A798:  MOVF   FF3,W
0A79A:  CLRF   xFF
0A79C:  MOVWF  xFE
0A79E:  MOVLW  08
0A7A0:  ADDWF  xFE,W
0A7A2:  MOVWF  01
0A7A4:  MOVLW  00
0A7A6:  ADDWFC xFF,W
0A7A8:  MOVWF  03
0A7AA:  MOVF   01,W
0A7AC:  ADDLW  17
0A7AE:  MOVWF  FE9
0A7B0:  MOVLW  01
0A7B2:  ADDWFC 03,W
0A7B4:  MOVWF  FEA
0A7B6:  MOVFF  FEF,6FE
0A7BA:  MOVFF  FEC,6FF
0A7BE:  MOVFF  FEC,700
0A7C2:  MOVFF  FEC,701
0A7C6:  MOVF   x8F,W
0A7C8:  MULLW  26
0A7CA:  MOVF   FF3,W
0A7CC:  MOVLB  7
0A7CE:  CLRF   x03
0A7D0:  MOVWF  x02
0A7D2:  MOVLW  0C
0A7D4:  ADDWF  x02,W
0A7D6:  MOVWF  01
0A7D8:  MOVLW  00
0A7DA:  ADDWFC x03,W
0A7DC:  MOVWF  03
0A7DE:  MOVF   01,W
0A7E0:  ADDLW  17
0A7E2:  MOVWF  FE9
0A7E4:  MOVLW  01
0A7E6:  ADDWFC 03,W
0A7E8:  MOVWF  FEA
0A7EA:  MOVFF  FEF,702
0A7EE:  MOVFF  FEC,703
0A7F2:  MOVFF  FEC,704
0A7F6:  MOVFF  FEC,705
0A7FA:  MOVFF  6FC,565
0A7FE:  MOVFF  6FB,564
0A802:  MOVLW  94
0A804:  MOVWF  FF6
0A806:  MOVLW  03
0A808:  MOVWF  FF7
0A80A:  MOVLW  04
0A80C:  MOVWF  x0F
0A80E:  MOVLB  0
0A810:  CALL   55E0
0A814:  MOVFF  6FD,706
0A818:  MOVLW  1B
0A81A:  MOVLB  7
0A81C:  MOVWF  x07
0A81E:  MOVLB  0
0A820:  CALL   5608
0A824:  MOVLW  2C
0A826:  MOVLB  7
0A828:  MOVWF  x50
0A82A:  MOVLB  0
0A82C:  CALL   55C0
0A830:  MOVLW  89
0A832:  MOVWF  FE9
0A834:  MOVFF  701,746
0A838:  MOVFF  700,745
0A83C:  MOVFF  6FF,744
0A840:  MOVFF  6FE,743
0A844:  MOVLB  7
0A846:  CLRF   x47
0A848:  MOVLB  0
0A84A:  CALL   575E
0A84E:  MOVLW  2C
0A850:  MOVLB  7
0A852:  MOVWF  x50
0A854:  MOVLB  0
0A856:  CALL   55C0
0A85A:  MOVLW  89
0A85C:  MOVWF  FE9
0A85E:  MOVFF  705,746
0A862:  MOVFF  704,745
0A866:  MOVFF  703,744
0A86A:  MOVFF  702,743
0A86E:  MOVLB  7
0A870:  CLRF   x47
0A872:  MOVLB  0
0A874:  CALL   575E
0A878:  MOVLW  3B
0A87A:  MOVLB  7
0A87C:  MOVWF  x50
0A87E:  MOVLB  0
0A880:  CALL   55C0
....................             sprintf(pBuff+strlen(pBuff), "POS,%u,%3.3f;", ch+1, adcVals[ch].pReal);
0A884:  MOVLW  06
0A886:  MOVLB  7
0A888:  MOVWF  x42
0A88A:  MOVLW  97
0A88C:  MOVWF  x41
0A88E:  MOVLB  0
0A890:  CALL   5588
0A894:  MOVF   01,W
0A896:  ADDLW  97
0A898:  MOVLB  6
0A89A:  MOVWF  xFB
0A89C:  MOVLW  06
0A89E:  ADDWFC 02,W
0A8A0:  MOVWF  xFC
0A8A2:  MOVLW  01
0A8A4:  ADDWF  x8F,W
0A8A6:  MOVWF  xFD
0A8A8:  MOVF   x8F,W
0A8AA:  MULLW  26
0A8AC:  MOVF   FF3,W
0A8AE:  CLRF   xFF
0A8B0:  MOVWF  xFE
0A8B2:  MOVLW  1D
0A8B4:  ADDWF  xFE,W
0A8B6:  MOVWF  01
0A8B8:  MOVLW  00
0A8BA:  ADDWFC xFF,W
0A8BC:  MOVWF  03
0A8BE:  MOVF   01,W
0A8C0:  ADDLW  17
0A8C2:  MOVWF  FE9
0A8C4:  MOVLW  01
0A8C6:  ADDWFC 03,W
0A8C8:  MOVWF  FEA
0A8CA:  MOVFF  FEF,6FE
0A8CE:  MOVFF  FEC,6FF
0A8D2:  MOVFF  FEC,700
0A8D6:  MOVFF  FEC,701
0A8DA:  MOVFF  6FC,565
0A8DE:  MOVFF  6FB,564
0A8E2:  MOVLW  A6
0A8E4:  MOVWF  FF6
0A8E6:  MOVLW  03
0A8E8:  MOVWF  FF7
0A8EA:  MOVLW  04
0A8EC:  MOVLB  7
0A8EE:  MOVWF  x0F
0A8F0:  MOVLB  0
0A8F2:  CALL   55E0
0A8F6:  MOVFF  6FD,706
0A8FA:  MOVLW  1B
0A8FC:  MOVLB  7
0A8FE:  MOVWF  x07
0A900:  MOVLB  0
0A902:  CALL   5608
0A906:  MOVLW  2C
0A908:  MOVLB  7
0A90A:  MOVWF  x50
0A90C:  MOVLB  0
0A90E:  CALL   55C0
0A912:  MOVLW  89
0A914:  MOVWF  FE9
0A916:  MOVFF  701,746
0A91A:  MOVFF  700,745
0A91E:  MOVFF  6FF,744
0A922:  MOVFF  6FE,743
0A926:  MOVLW  03
0A928:  MOVLB  7
0A92A:  MOVWF  x47
0A92C:  MOVLB  0
0A92E:  CALL   575E
0A932:  MOVLW  3B
0A934:  MOVLB  7
0A936:  MOVWF  x50
0A938:  MOVLB  0
0A93A:  CALL   55C0
....................             if ( dacVals[ch].invV ) sprintf(pBuff+strlen(pBuff), "OUT,%u,-,%Lu;", ch+1, dacVals[ch].ipVal);
0A93E:  MOVLB  6
0A940:  MOVF   x8F,W
0A942:  MULLW  07
0A944:  MOVF   FF3,W
0A946:  CLRF   xFC
0A948:  MOVWF  xFB
0A94A:  MOVLW  64
0A94C:  ADDWF  xFB,W
0A94E:  MOVWF  FE9
0A950:  MOVLW  01
0A952:  ADDWFC xFC,W
0A954:  MOVWF  FEA
0A956:  BTFSS  FEF.0
0A958:  BRA    AA08
0A95A:  MOVLW  06
0A95C:  MOVLB  7
0A95E:  MOVWF  x42
0A960:  MOVLW  97
0A962:  MOVWF  x41
0A964:  MOVLB  0
0A966:  CALL   5588
0A96A:  MOVF   01,W
0A96C:  ADDLW  97
0A96E:  MOVLB  6
0A970:  MOVWF  xFB
0A972:  MOVLW  06
0A974:  ADDWFC 02,W
0A976:  MOVWF  xFC
0A978:  MOVLW  01
0A97A:  ADDWF  x8F,W
0A97C:  MOVWF  xFD
0A97E:  MOVF   x8F,W
0A980:  MULLW  07
0A982:  MOVF   FF3,W
0A984:  CLRF   xFF
0A986:  MOVWF  xFE
0A988:  MOVLW  01
0A98A:  ADDWF  xFE,W
0A98C:  MOVWF  01
0A98E:  MOVLW  00
0A990:  ADDWFC xFF,W
0A992:  MOVWF  03
0A994:  MOVF   01,W
0A996:  ADDLW  64
0A998:  MOVWF  FE9
0A99A:  MOVLW  01
0A99C:  ADDWFC 03,W
0A99E:  MOVWF  FEA
0A9A0:  MOVFF  FEC,6FF
0A9A4:  MOVF   FED,F
0A9A6:  MOVFF  FEF,6FE
0A9AA:  MOVFF  6FC,565
0A9AE:  MOVFF  6FB,564
0A9B2:  MOVLW  B4
0A9B4:  MOVWF  FF6
0A9B6:  MOVLW  03
0A9B8:  MOVWF  FF7
0A9BA:  MOVLW  04
0A9BC:  MOVLB  7
0A9BE:  MOVWF  x0F
0A9C0:  MOVLB  0
0A9C2:  CALL   55E0
0A9C6:  MOVFF  6FD,706
0A9CA:  MOVLW  1B
0A9CC:  MOVLB  7
0A9CE:  MOVWF  x07
0A9D0:  MOVLB  0
0A9D2:  CALL   5608
0A9D6:  MOVLW  BA
0A9D8:  MOVWF  FF6
0A9DA:  MOVLW  03
0A9DC:  MOVWF  FF7
0A9DE:  MOVLW  03
0A9E0:  MOVLB  7
0A9E2:  MOVWF  x0F
0A9E4:  MOVLB  0
0A9E6:  CALL   55E0
0A9EA:  MOVLW  10
0A9EC:  MOVWF  FE9
0A9EE:  MOVFF  6FF,701
0A9F2:  MOVFF  6FE,700
0A9F6:  CALL   5906
0A9FA:  MOVLW  3B
0A9FC:  MOVLB  7
0A9FE:  MOVWF  x50
0AA00:  MOVLB  0
0AA02:  CALL   55C0
0AA06:  BRA    AAB4
....................             else                    sprintf(pBuff+strlen(pBuff), "OUT,%u,+,%Lu;", ch+1, dacVals[ch].ipVal);
0AA08:  MOVLW  06
0AA0A:  MOVLB  7
0AA0C:  MOVWF  x42
0AA0E:  MOVLW  97
0AA10:  MOVWF  x41
0AA12:  MOVLB  0
0AA14:  CALL   5588
0AA18:  MOVF   01,W
0AA1A:  ADDLW  97
0AA1C:  MOVLB  6
0AA1E:  MOVWF  xFB
0AA20:  MOVLW  06
0AA22:  ADDWFC 02,W
0AA24:  MOVWF  xFC
0AA26:  MOVLW  01
0AA28:  ADDWF  x8F,W
0AA2A:  MOVWF  xFD
0AA2C:  MOVF   x8F,W
0AA2E:  MULLW  07
0AA30:  MOVF   FF3,W
0AA32:  CLRF   xFF
0AA34:  MOVWF  xFE
0AA36:  MOVLW  01
0AA38:  ADDWF  xFE,W
0AA3A:  MOVWF  01
0AA3C:  MOVLW  00
0AA3E:  ADDWFC xFF,W
0AA40:  MOVWF  03
0AA42:  MOVF   01,W
0AA44:  ADDLW  64
0AA46:  MOVWF  FE9
0AA48:  MOVLW  01
0AA4A:  ADDWFC 03,W
0AA4C:  MOVWF  FEA
0AA4E:  MOVFF  FEC,6FF
0AA52:  MOVF   FED,F
0AA54:  MOVFF  FEF,6FE
0AA58:  MOVFF  6FC,565
0AA5C:  MOVFF  6FB,564
0AA60:  MOVLW  C2
0AA62:  MOVWF  FF6
0AA64:  MOVLW  03
0AA66:  MOVWF  FF7
0AA68:  MOVLW  04
0AA6A:  MOVLB  7
0AA6C:  MOVWF  x0F
0AA6E:  MOVLB  0
0AA70:  CALL   55E0
0AA74:  MOVFF  6FD,706
0AA78:  MOVLW  1B
0AA7A:  MOVLB  7
0AA7C:  MOVWF  x07
0AA7E:  MOVLB  0
0AA80:  CALL   5608
0AA84:  MOVLW  C8
0AA86:  MOVWF  FF6
0AA88:  MOVLW  03
0AA8A:  MOVWF  FF7
0AA8C:  MOVLW  03
0AA8E:  MOVLB  7
0AA90:  MOVWF  x0F
0AA92:  MOVLB  0
0AA94:  CALL   55E0
0AA98:  MOVLW  10
0AA9A:  MOVWF  FE9
0AA9C:  MOVFF  6FF,701
0AAA0:  MOVFF  6FE,700
0AAA4:  CALL   5906
0AAA8:  MOVLW  3B
0AAAA:  MOVLB  7
0AAAC:  MOVWF  x50
0AAAE:  MOVLB  0
0AAB0:  CALL   55C0
....................             ch = !ch;
0AAB4:  MOVLB  6
0AAB6:  MOVF   x8F,F
0AAB8:  BTFSC  FD8.2
0AABA:  BRA    AAC0
0AABC:  MOVLW  00
0AABE:  BRA    AAC2
0AAC0:  MOVLW  01
0AAC2:  MOVWF  x8F
....................             debugCounter = 0;
0AAC4:  CLRF   x96
0AAC6:  CLRF   x95
....................         }else debugCounter++;
....................         fprintf(ICD_STREAM, "%s\n", pBuff);
0AAC8:  MOVLW  06
0AACA:  MOVWF  FEA
0AACC:  MOVLW  97
0AACE:  MOVWF  FE9
0AAD0:  MOVLB  0
0AAD2:  GOTO   5A1E
0AAD6:  MOVLW  0A
0AAD8:  MOVLB  6
0AADA:  MOVWF  xFD
0AADC:  MOVLB  0
0AADE:  CALL   59CC
....................         #endif
....................       
....................         command_handler_task();    //execute commands
0AAE2:  GOTO   A1EA
....................       
....................         delay_ms(loopDelay);
0AAE6:  MOVFF  692,6FB
0AAEA:  MOVLB  6
0AAEC:  INCF   xFB,F
0AAEE:  DECF   xFB,F
0AAF0:  BTFSC  FD8.2
0AAF2:  BRA    AB02
0AAF4:  MOVLB  7
0AAF6:  SETF   x01
0AAF8:  MOVLB  0
0AAFA:  CALL   03D0
0AAFE:  MOVLB  6
0AB00:  BRA    AAEE
0AB02:  MOVFF  691,701
0AB06:  MOVLB  0
0AB08:  CALL   03D0
0AB0C:  BRA    A73C
....................     }
.................... }
0AB0E:  SLEEP 

Configuration Fuses:
   Word  1: FF8C   NOEXTOSC RSTOSC_HFINTRC_64MHZ NOCLKOUT CKS FCMEN
   Word  2: FFFD   MCLR PUT NOLPBOR BROWNOUT BORV19 ZCDDIS PPS1WAY STVREN NODEBUG NOXINST
   Word  3: FF9F   WDTSW NOWDT WDTWIN_SW WDTCLK_SW
   Word  4: DFFF   NOWRT NOWRTC NOWRTB NOWRTD SCANE NOLVP
   Word  5: FFFF   NOPROTECT NOCPD
   Word  6: FFFF   NOEBTR NOEBTRB
