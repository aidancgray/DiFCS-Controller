CCS PCH C Compiler, Version 5.117, 2138               17-Nov-25 20:15

               Filename:   C:\Users\Aidan\Documents\GitHub\DiFCS-Controller\src\main.lst

               ROM used:   40896 bytes (62%)
                           Largest free fragment is 24638
               RAM used:   1523 (42%) at main() level
                           1640 (45%) worst case
               Stack used: 6 locations (4 in main + 2 for interrupts)
               Stack size: 31

*
00000:  NOP   
00002:  GOTO   9AE4
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  MOVLB  E
00056:  BTFSS  xC0.5
00058:  GOTO   0062
0005C:  BTFSC  xC8.5
0005E:  GOTO   00E8
00062:  BTFSS  xC1.0
00064:  GOTO   006E
00068:  BTFSC  xC9.0
0006A:  GOTO   0246
0006E:  MOVFF  0E,00
00072:  MOVFF  0F,01
00076:  MOVFF  10,02
0007A:  MOVFF  11,03
0007E:  MOVFF  0C,FE9
00082:  MOVFF  07,FEA
00086:  BSF    07.7
00088:  MOVFF  08,FE1
0008C:  MOVFF  09,FE2
00090:  MOVFF  0A,FD9
00094:  MOVFF  0B,FDA
00098:  MOVFF  12,FF3
0009C:  MOVFF  13,FF4
000A0:  MOVFF  14,FFA
000A4:  MOVFF  15,FF5
000A8:  MOVFF  16,FF6
000AC:  MOVFF  17,FF7
000B0:  MOVF   04,W
000B2:  MOVFF  06,FE0
000B6:  MOVFF  05,FD8
000BA:  RETFIE 0
.................... #include <main.h>
.................... #include <18F46Q10.h>
.................... //////////// Standard Header file for the PIC18F46Q10 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F46Q10
000BC:  MOVFF  FEC,FFA
000C0:  MOVF   FED,F
000C2:  MOVFF  FEF,FE8
000C6:  MOVWF  FF9
000C8:  RETURN 0
*
0031A:  DATA 32,30
0031C:  DATA 32,35
0031E:  DATA 31,31
00320:  DATA 30,34
00322:  DATA 00,00
00324:  DATA 30,30
00326:  DATA 30,30
00328:  DATA 00,00
0032A:  DATA 25,64
0032C:  DATA 2C,4D
0032E:  DATA 41,4E
00330:  DATA 55,41
00332:  DATA 4C,2C
00334:  DATA 00,00
00336:  DATA 25,64
00338:  DATA 2C,4D
0033A:  DATA 41,47
0033C:  DATA 53,4E
0033E:  DATA 53,2C
00340:  DATA 00,00
00342:  DATA 23,44
00344:  DATA 30,2C
00346:  DATA 25,75
00348:  DATA 2C,25
0034A:  DATA 33,2E
0034C:  DATA 33,66
0034E:  DATA 0A,00
00350:  DATA 23,44
00352:  DATA 30,2C
00354:  DATA 4F,50
00356:  DATA 2C,25
00358:  DATA 75,2C
0035A:  DATA 25,4C
0035C:  DATA 75,0A
0035E:  DATA 00,00
*
00686:  ADDWF  FE8,W
00688:  CLRF   FF7
0068A:  RLCF   FF7,F
0068C:  ADDLW  A1
0068E:  MOVWF  FF6
00690:  MOVLW  06
00692:  ADDWFC FF7,F
00694:  TBLRD*-
00696:  MOVF   FF5,W
00698:  MOVWF  FFA
0069A:  TBLRD*
0069C:  MOVF   FF5,W
0069E:  MOVWF  FF9
006A0:  DATA 50,06
006A2:  DATA 5A,06
006A4:  DATA 64,06
006A6:  DATA 6E,06
*
0087E:  MOVLB  6
00880:  MOVF   x2F,W
00882:  MULWF  x31
00884:  MOVFF  FF3,01
00888:  MOVFF  FF4,00
0088C:  MULWF  x32
0088E:  MOVF   FF3,W
00890:  ADDWF  00,F
00892:  MOVF   x30,W
00894:  MULWF  x31
00896:  MOVF   FF3,W
00898:  ADDWFC 00,W
0089A:  MOVWF  02
0089C:  MOVLB  0
0089E:  RETURN 0
*
00A86:  MOVLW  8E
00A88:  MOVWF  00
00A8A:  MOVFF  650,01
00A8E:  MOVFF  64F,02
00A92:  CLRF   03
00A94:  MOVF   01,F
00A96:  BNZ   0AAA
00A98:  MOVFF  02,01
00A9C:  CLRF   02
00A9E:  MOVLW  08
00AA0:  SUBWF  00,F
00AA2:  MOVF   01,F
00AA4:  BNZ   0AAA
00AA6:  CLRF   00
00AA8:  BRA    0ABA
00AAA:  BCF    FD8.0
00AAC:  BTFSC  01.7
00AAE:  BRA    0AB8
00AB0:  RLCF   02,F
00AB2:  RLCF   01,F
00AB4:  DECF   00,F
00AB6:  BRA    0AAA
00AB8:  BCF    01.7
00ABA:  RETURN 0
00ABC:  MOVLB  6
00ABE:  MOVF   x4B,W
00AC0:  BTFSC  FD8.2
00AC2:  BRA    0BA6
00AC4:  MOVWF  00
00AC6:  MOVF   x4F,W
00AC8:  BTFSC  FD8.2
00ACA:  BRA    0BA6
00ACC:  ADDWF  00,F
00ACE:  BNC   0AD8
00AD0:  MOVLW  81
00AD2:  ADDWF  00,F
00AD4:  BC    0BA6
00AD6:  BRA    0AE0
00AD8:  MOVLW  7F
00ADA:  SUBWF  00,F
00ADC:  BNC   0BA6
00ADE:  BZ    0BA6
00AE0:  MOVFF  64C,653
00AE4:  MOVF   x50,W
00AE6:  XORWF  x53,F
00AE8:  BSF    x4C.7
00AEA:  BSF    x50.7
00AEC:  MOVF   x4E,W
00AEE:  MULWF  x52
00AF0:  MOVFF  FF4,655
00AF4:  MOVF   x4D,W
00AF6:  MULWF  x51
00AF8:  MOVFF  FF4,03
00AFC:  MOVFF  FF3,654
00B00:  MULWF  x52
00B02:  MOVF   FF3,W
00B04:  ADDWF  x55,F
00B06:  MOVF   FF4,W
00B08:  ADDWFC x54,F
00B0A:  MOVLW  00
00B0C:  ADDWFC 03,F
00B0E:  MOVF   x4E,W
00B10:  MULWF  x51
00B12:  MOVF   FF3,W
00B14:  ADDWF  x55,F
00B16:  MOVF   FF4,W
00B18:  ADDWFC x54,F
00B1A:  MOVLW  00
00B1C:  CLRF   02
00B1E:  ADDWFC 03,F
00B20:  ADDWFC 02,F
00B22:  MOVF   x4C,W
00B24:  MULWF  x52
00B26:  MOVF   FF3,W
00B28:  ADDWF  x54,F
00B2A:  MOVF   FF4,W
00B2C:  ADDWFC 03,F
00B2E:  MOVLW  00
00B30:  ADDWFC 02,F
00B32:  MOVF   x4C,W
00B34:  MULWF  x51
00B36:  MOVF   FF3,W
00B38:  ADDWF  03,F
00B3A:  MOVF   FF4,W
00B3C:  ADDWFC 02,F
00B3E:  MOVLW  00
00B40:  CLRF   01
00B42:  ADDWFC 01,F
00B44:  MOVF   x4E,W
00B46:  MULWF  x50
00B48:  MOVF   FF3,W
00B4A:  ADDWF  x54,F
00B4C:  MOVF   FF4,W
00B4E:  ADDWFC 03,F
00B50:  MOVLW  00
00B52:  ADDWFC 02,F
00B54:  ADDWFC 01,F
00B56:  MOVF   x4D,W
00B58:  MULWF  x50
00B5A:  MOVF   FF3,W
00B5C:  ADDWF  03,F
00B5E:  MOVF   FF4,W
00B60:  ADDWFC 02,F
00B62:  MOVLW  00
00B64:  ADDWFC 01,F
00B66:  MOVF   x4C,W
00B68:  MULWF  x50
00B6A:  MOVF   FF3,W
00B6C:  ADDWF  02,F
00B6E:  MOVF   FF4,W
00B70:  ADDWFC 01,F
00B72:  INCF   00,F
00B74:  BTFSC  01.7
00B76:  BRA    0B82
00B78:  RLCF   x54,F
00B7A:  RLCF   03,F
00B7C:  RLCF   02,F
00B7E:  RLCF   01,F
00B80:  DECF   00,F
00B82:  MOVLW  00
00B84:  BTFSS  x54.7
00B86:  BRA    0B9C
00B88:  INCF   03,F
00B8A:  ADDWFC 02,F
00B8C:  ADDWFC 01,F
00B8E:  MOVF   01,W
00B90:  BNZ   0B9C
00B92:  MOVF   02,W
00B94:  BNZ   0B9C
00B96:  MOVF   03,W
00B98:  BNZ   0B9C
00B9A:  INCF   00,F
00B9C:  BTFSC  x53.7
00B9E:  BSF    01.7
00BA0:  BTFSS  x53.7
00BA2:  BCF    01.7
00BA4:  BRA    0BAE
00BA6:  CLRF   00
00BA8:  CLRF   01
00BAA:  CLRF   02
00BAC:  CLRF   03
00BAE:  MOVLB  0
00BB0:  RETURN 0
00BB2:  MOVLW  80
00BB4:  BTFSS  FD8.1
00BB6:  BRA    0BBC
00BB8:  MOVLB  6
00BBA:  XORWF  x54,F
00BBC:  MOVLB  6
00BBE:  CLRF   x59
00BC0:  CLRF   x5A
00BC2:  MOVFF  650,658
00BC6:  MOVF   x54,W
00BC8:  XORWF  x58,F
00BCA:  MOVF   x4F,W
00BCC:  BTFSC  FD8.2
00BCE:  BRA    0D8E
00BD0:  MOVWF  x57
00BD2:  MOVWF  00
00BD4:  MOVF   x53,W
00BD6:  BTFSC  FD8.2
00BD8:  BRA    0DA0
00BDA:  SUBWF  x57,F
00BDC:  BTFSC  FD8.2
00BDE:  BRA    0CE6
00BE0:  BNC   0C5E
00BE2:  MOVFF  654,65D
00BE6:  BSF    x5D.7
00BE8:  MOVFF  655,65C
00BEC:  MOVFF  656,65B
00BF0:  CLRF   x5A
00BF2:  BCF    FD8.0
00BF4:  RRCF   x5D,F
00BF6:  RRCF   x5C,F
00BF8:  RRCF   x5B,F
00BFA:  RRCF   x5A,F
00BFC:  DECFSZ x57,F
00BFE:  BRA    0BF0
00C00:  BTFSS  x58.7
00C02:  BRA    0C0A
00C04:  BSF    x59.0
00C06:  BRA    0DC8
00C08:  BCF    x59.0
00C0A:  BCF    x57.0
00C0C:  BSF    x59.4
00C0E:  MOVLW  06
00C10:  MOVWF  FEA
00C12:  MOVLW  52
00C14:  MOVWF  FE9
00C16:  BRA    0DEE
00C18:  BCF    x59.4
00C1A:  BTFSC  x58.7
00C1C:  BRA    0C32
00C1E:  BTFSS  x57.0
00C20:  BRA    0C48
00C22:  RRCF   x5D,F
00C24:  RRCF   x5C,F
00C26:  RRCF   x5B,F
00C28:  RRCF   x5A,F
00C2A:  INCF   00,F
00C2C:  BTFSC  FD8.2
00C2E:  BRA    0DBE
00C30:  BRA    0C48
00C32:  BTFSC  x5D.7
00C34:  BRA    0C4E
00C36:  BCF    FD8.0
00C38:  RLCF   x5A,F
00C3A:  RLCF   x5B,F
00C3C:  RLCF   x5C,F
00C3E:  RLCF   x5D,F
00C40:  DECF   00,F
00C42:  BTFSC  FD8.2
00C44:  BRA    0DBE
00C46:  BRA    0C32
00C48:  BSF    x59.6
00C4A:  BRA    0D26
00C4C:  BCF    x59.6
00C4E:  MOVFF  650,658
00C52:  BTFSS  x50.7
00C54:  BRA    0C5A
00C56:  BSF    x5D.7
00C58:  BRA    0DB0
00C5A:  BCF    x5D.7
00C5C:  BRA    0DB0
00C5E:  MOVFF  653,657
00C62:  MOVFF  653,00
00C66:  MOVF   x4F,W
00C68:  SUBWF  x57,F
00C6A:  MOVFF  650,65D
00C6E:  BSF    x5D.7
00C70:  MOVFF  651,65C
00C74:  MOVFF  652,65B
00C78:  CLRF   x5A
00C7A:  BCF    FD8.0
00C7C:  RRCF   x5D,F
00C7E:  RRCF   x5C,F
00C80:  RRCF   x5B,F
00C82:  RRCF   x5A,F
00C84:  DECFSZ x57,F
00C86:  BRA    0C78
00C88:  BTFSS  x58.7
00C8A:  BRA    0C92
00C8C:  BSF    x59.1
00C8E:  BRA    0DC8
00C90:  BCF    x59.1
00C92:  BCF    x57.0
00C94:  BSF    x59.5
00C96:  MOVLW  06
00C98:  MOVWF  FEA
00C9A:  MOVLW  56
00C9C:  MOVWF  FE9
00C9E:  BRA    0DEE
00CA0:  BCF    x59.5
00CA2:  BTFSC  x58.7
00CA4:  BRA    0CBA
00CA6:  BTFSS  x57.0
00CA8:  BRA    0CD0
00CAA:  RRCF   x5D,F
00CAC:  RRCF   x5C,F
00CAE:  RRCF   x5B,F
00CB0:  RRCF   x5A,F
00CB2:  INCF   00,F
00CB4:  BTFSC  FD8.2
00CB6:  BRA    0DBE
00CB8:  BRA    0CD0
00CBA:  BTFSC  x5D.7
00CBC:  BRA    0CD6
00CBE:  BCF    FD8.0
00CC0:  RLCF   x5A,F
00CC2:  RLCF   x5B,F
00CC4:  RLCF   x5C,F
00CC6:  RLCF   x5D,F
00CC8:  DECF   00,F
00CCA:  BTFSC  FD8.2
00CCC:  BRA    0DBE
00CCE:  BRA    0CBA
00CD0:  BSF    x59.7
00CD2:  BRA    0D26
00CD4:  BCF    x59.7
00CD6:  MOVFF  654,658
00CDA:  BTFSS  x54.7
00CDC:  BRA    0CE2
00CDE:  BSF    x5D.7
00CE0:  BRA    0DB0
00CE2:  BCF    x5D.7
00CE4:  BRA    0DB0
00CE6:  MOVFF  654,65D
00CEA:  BSF    x5D.7
00CEC:  MOVFF  655,65C
00CF0:  MOVFF  656,65B
00CF4:  BTFSS  x58.7
00CF6:  BRA    0D00
00CF8:  BCF    x5D.7
00CFA:  BSF    x59.2
00CFC:  BRA    0DC8
00CFE:  BCF    x59.2
00D00:  CLRF   x5A
00D02:  BCF    x57.0
00D04:  MOVLW  06
00D06:  MOVWF  FEA
00D08:  MOVLW  52
00D0A:  MOVWF  FE9
00D0C:  BRA    0DEE
00D0E:  BTFSC  x58.7
00D10:  BRA    0D4A
00D12:  MOVFF  650,658
00D16:  BTFSS  x57.0
00D18:  BRA    0D26
00D1A:  RRCF   x5D,F
00D1C:  RRCF   x5C,F
00D1E:  RRCF   x5B,F
00D20:  RRCF   x5A,F
00D22:  INCF   00,F
00D24:  BZ    0DBE
00D26:  BTFSS  x5A.7
00D28:  BRA    0D40
00D2A:  INCF   x5B,F
00D2C:  BNZ   0D40
00D2E:  INCF   x5C,F
00D30:  BNZ   0D40
00D32:  INCF   x5D,F
00D34:  BNZ   0D40
00D36:  RRCF   x5D,F
00D38:  RRCF   x5C,F
00D3A:  RRCF   x5B,F
00D3C:  INCF   00,F
00D3E:  BZ    0DBE
00D40:  BTFSC  x59.6
00D42:  BRA    0C4C
00D44:  BTFSC  x59.7
00D46:  BRA    0CD4
00D48:  BRA    0D82
00D4A:  MOVLW  80
00D4C:  XORWF  x5D,F
00D4E:  BTFSS  x5D.7
00D50:  BRA    0D5A
00D52:  BRA    0DC8
00D54:  MOVFF  654,658
00D58:  BRA    0D6E
00D5A:  MOVFF  650,658
00D5E:  MOVF   x5D,F
00D60:  BNZ   0D6E
00D62:  MOVF   x5C,F
00D64:  BNZ   0D6E
00D66:  MOVF   x5B,F
00D68:  BNZ   0D6E
00D6A:  CLRF   00
00D6C:  BRA    0DB0
00D6E:  BTFSC  x5D.7
00D70:  BRA    0D82
00D72:  BCF    FD8.0
00D74:  RLCF   x5A,F
00D76:  RLCF   x5B,F
00D78:  RLCF   x5C,F
00D7A:  RLCF   x5D,F
00D7C:  DECFSZ 00,F
00D7E:  BRA    0D6E
00D80:  BRA    0DBE
00D82:  BTFSS  x58.7
00D84:  BRA    0D8A
00D86:  BSF    x5D.7
00D88:  BRA    0DB0
00D8A:  BCF    x5D.7
00D8C:  BRA    0DB0
00D8E:  MOVFF  653,00
00D92:  MOVFF  654,65D
00D96:  MOVFF  655,65C
00D9A:  MOVFF  656,65B
00D9E:  BRA    0DB0
00DA0:  MOVFF  64F,00
00DA4:  MOVFF  650,65D
00DA8:  MOVFF  651,65C
00DAC:  MOVFF  652,65B
00DB0:  MOVFF  65D,01
00DB4:  MOVFF  65C,02
00DB8:  MOVFF  65B,03
00DBC:  BRA    0E26
00DBE:  CLRF   00
00DC0:  CLRF   01
00DC2:  CLRF   02
00DC4:  CLRF   03
00DC6:  BRA    0E26
00DC8:  CLRF   x5A
00DCA:  COMF   x5B,F
00DCC:  COMF   x5C,F
00DCE:  COMF   x5D,F
00DD0:  COMF   x5A,F
00DD2:  INCF   x5A,F
00DD4:  BNZ   0DE0
00DD6:  INCF   x5B,F
00DD8:  BNZ   0DE0
00DDA:  INCF   x5C,F
00DDC:  BNZ   0DE0
00DDE:  INCF   x5D,F
00DE0:  BTFSC  x59.0
00DE2:  BRA    0C08
00DE4:  BTFSC  x59.1
00DE6:  BRA    0C90
00DE8:  BTFSC  x59.2
00DEA:  BRA    0CFE
00DEC:  BRA    0D54
00DEE:  MOVF   FEF,W
00DF0:  ADDWF  x5B,F
00DF2:  BNC   0DFE
00DF4:  INCF   x5C,F
00DF6:  BNZ   0DFE
00DF8:  INCF   x5D,F
00DFA:  BTFSC  FD8.2
00DFC:  BSF    x57.0
00DFE:  MOVF   FED,F
00E00:  MOVF   FEF,W
00E02:  ADDWF  x5C,F
00E04:  BNC   0E0C
00E06:  INCF   x5D,F
00E08:  BTFSC  FD8.2
00E0A:  BSF    x57.0
00E0C:  MOVF   FED,F
00E0E:  MOVF   FEF,W
00E10:  BTFSC  FEF.7
00E12:  BRA    0E16
00E14:  XORLW  80
00E16:  ADDWF  x5D,F
00E18:  BTFSC  FD8.0
00E1A:  BSF    x57.0
00E1C:  BTFSC  x59.4
00E1E:  BRA    0C18
00E20:  BTFSC  x59.5
00E22:  BRA    0CA0
00E24:  BRA    0D0E
00E26:  MOVLB  0
00E28:  RETURN 0
*
01380:  ADDWF  FE8,W
01382:  CLRF   FF7
01384:  RLCF   FF7,F
01386:  ADDLW  9B
01388:  MOVWF  FF6
0138A:  MOVLW  13
0138C:  ADDWFC FF7,F
0138E:  TBLRD*-
01390:  MOVF   FF5,W
01392:  MOVWF  FFA
01394:  TBLRD*
01396:  MOVF   FF5,W
01398:  MOVWF  FF9
0139A:  DATA 42,0E
0139C:  DATA 02,0F
0139E:  DATA C2,0F
013A0:  DATA 82,10
013A2:  DATA 42,11
013A4:  DATA 02,12
013A6:  DATA C2,12
*
01412:  MOVLW  B6
01414:  MOVWF  00
01416:  CLRF   03
01418:  CLRF   02
0141A:  CLRF   01
0141C:  MOVLB  6
0141E:  BCF    x19.0
01420:  BTFSS  x18.7
01422:  BRA    143C
01424:  BSF    x19.0
01426:  COMF   x15,F
01428:  COMF   x16,F
0142A:  COMF   x17,F
0142C:  COMF   x18,F
0142E:  INCF   x15,F
01430:  BNZ   143C
01432:  INCF   x16,F
01434:  BNZ   143C
01436:  INCF   x17,F
01438:  BTFSC  FD8.2
0143A:  INCF   x18,F
0143C:  MOVF   x15,W
0143E:  IORWF  x16,W
01440:  IORWF  x17,W
01442:  IORWF  x18,W
01444:  BNZ   144A
01446:  CLRF   00
01448:  BRA    1468
0144A:  BCF    FD8.0
0144C:  BTFSC  01.7
0144E:  BRA    1462
01450:  RLCF   x15,F
01452:  RLCF   x16,F
01454:  RLCF   x17,F
01456:  RLCF   x18,F
01458:  RLCF   03,F
0145A:  RLCF   02,F
0145C:  RLCF   01,F
0145E:  DECFSZ 00,F
01460:  BRA    144A
01462:  BCF    01.7
01464:  BTFSC  x19.0
01466:  BSF    01.7
01468:  MOVLB  0
0146A:  RETURN 0
0146C:  MOVFF  64C,653
01470:  MOVLB  6
01472:  MOVF   x50,W
01474:  XORWF  x53,F
01476:  BTFSS  x53.7
01478:  BRA    1484
0147A:  BCF    FD8.2
0147C:  BCF    FD8.0
0147E:  BTFSC  x4C.7
01480:  BSF    FD8.0
01482:  BRA    14E2
01484:  MOVFF  64C,653
01488:  MOVFF  64F,654
0148C:  MOVF   x4B,W
0148E:  SUBWF  x54,F
01490:  BZ    149E
01492:  BTFSS  x53.7
01494:  BRA    14E2
01496:  MOVF   FD8,W
01498:  XORLW  01
0149A:  MOVWF  FD8
0149C:  BRA    14E2
0149E:  MOVFF  650,654
014A2:  MOVF   x4C,W
014A4:  SUBWF  x54,F
014A6:  BZ    14B4
014A8:  BTFSS  x53.7
014AA:  BRA    14E2
014AC:  MOVF   FD8,W
014AE:  XORLW  01
014B0:  MOVWF  FD8
014B2:  BRA    14E2
014B4:  MOVFF  651,654
014B8:  MOVF   x4D,W
014BA:  SUBWF  x54,F
014BC:  BZ    14CA
014BE:  BTFSS  x53.7
014C0:  BRA    14E2
014C2:  MOVF   FD8,W
014C4:  XORLW  01
014C6:  MOVWF  FD8
014C8:  BRA    14E2
014CA:  MOVFF  652,654
014CE:  MOVF   x4E,W
014D0:  SUBWF  x54,F
014D2:  BZ    14E0
014D4:  BTFSS  x53.7
014D6:  BRA    14E2
014D8:  MOVF   FD8,W
014DA:  XORLW  01
014DC:  MOVWF  FD8
014DE:  BRA    14E2
014E0:  BCF    FD8.0
014E2:  MOVLB  0
014E4:  RETURN 0
014E6:  MOVLB  6
014E8:  MOVF   x44,W
014EA:  BTFSC  FD8.2
014EC:  BRA    1638
014EE:  MOVWF  x50
014F0:  MOVF   x48,W
014F2:  BTFSC  FD8.2
014F4:  BRA    1638
014F6:  SUBWF  x50,F
014F8:  BNC   1504
014FA:  MOVLW  7F
014FC:  ADDWF  x50,F
014FE:  BTFSC  FD8.0
01500:  BRA    1638
01502:  BRA    1510
01504:  MOVLW  81
01506:  SUBWF  x50,F
01508:  BTFSS  FD8.0
0150A:  BRA    1638
0150C:  BTFSC  FD8.2
0150E:  BRA    1638
01510:  MOVFF  650,00
01514:  CLRF   01
01516:  CLRF   02
01518:  CLRF   03
0151A:  CLRF   x4F
0151C:  MOVFF  645,64E
01520:  BSF    x4E.7
01522:  MOVFF  646,64D
01526:  MOVFF  647,64C
0152A:  MOVLW  19
0152C:  MOVWF  x50
0152E:  MOVF   x4B,W
01530:  SUBWF  x4C,F
01532:  BC    154E
01534:  MOVLW  01
01536:  SUBWF  x4D,F
01538:  BC    154E
0153A:  SUBWF  x4E,F
0153C:  BC    154E
0153E:  SUBWF  x4F,F
01540:  BC    154E
01542:  INCF   x4F,F
01544:  INCF   x4E,F
01546:  INCF   x4D,F
01548:  MOVF   x4B,W
0154A:  ADDWF  x4C,F
0154C:  BRA    159E
0154E:  MOVF   x4A,W
01550:  SUBWF  x4D,F
01552:  BC    1578
01554:  MOVLW  01
01556:  SUBWF  x4E,F
01558:  BC    1578
0155A:  SUBWF  x4F,F
0155C:  BC    1578
0155E:  INCF   x4F,F
01560:  INCF   x4E,F
01562:  MOVF   x4A,W
01564:  ADDWF  x4D,F
01566:  MOVF   x4B,W
01568:  ADDWF  x4C,F
0156A:  BNC   159E
0156C:  INCF   x4D,F
0156E:  BNZ   159E
01570:  INCF   x4E,F
01572:  BNZ   159E
01574:  INCF   x4F,F
01576:  BRA    159E
01578:  MOVF   x49,W
0157A:  IORLW  80
0157C:  SUBWF  x4E,F
0157E:  BC    159C
01580:  MOVLW  01
01582:  SUBWF  x4F,F
01584:  BC    159C
01586:  INCF   x4F,F
01588:  MOVF   x49,W
0158A:  IORLW  80
0158C:  ADDWF  x4E,F
0158E:  MOVF   x4A,W
01590:  ADDWF  x4D,F
01592:  BNC   1566
01594:  INCF   x4E,F
01596:  BNZ   1566
01598:  INCF   x4F,F
0159A:  BRA    1566
0159C:  BSF    03.0
0159E:  DECFSZ x50,F
015A0:  BRA    15A4
015A2:  BRA    15BA
015A4:  BCF    FD8.0
015A6:  RLCF   x4C,F
015A8:  RLCF   x4D,F
015AA:  RLCF   x4E,F
015AC:  RLCF   x4F,F
015AE:  BCF    FD8.0
015B0:  RLCF   03,F
015B2:  RLCF   02,F
015B4:  RLCF   01,F
015B6:  RLCF   x51,F
015B8:  BRA    152E
015BA:  BTFSS  x51.0
015BC:  BRA    15CA
015BE:  BCF    FD8.0
015C0:  RRCF   01,F
015C2:  RRCF   02,F
015C4:  RRCF   03,F
015C6:  RRCF   x51,F
015C8:  BRA    15CE
015CA:  DECF   00,F
015CC:  BZ    1638
015CE:  BTFSC  x51.7
015D0:  BRA    160E
015D2:  BCF    FD8.0
015D4:  RLCF   x4C,F
015D6:  RLCF   x4D,F
015D8:  RLCF   x4E,F
015DA:  RLCF   x4F,F
015DC:  MOVF   x4B,W
015DE:  SUBWF  x4C,F
015E0:  BC    15F0
015E2:  MOVLW  01
015E4:  SUBWF  x4D,F
015E6:  BC    15F0
015E8:  SUBWF  x4E,F
015EA:  BC    15F0
015EC:  SUBWF  x4F,F
015EE:  BNC   1624
015F0:  MOVF   x4A,W
015F2:  SUBWF  x4D,F
015F4:  BC    1600
015F6:  MOVLW  01
015F8:  SUBWF  x4E,F
015FA:  BC    1600
015FC:  SUBWF  x4F,F
015FE:  BNC   1624
01600:  MOVF   x49,W
01602:  IORLW  80
01604:  SUBWF  x4E,F
01606:  BC    160E
01608:  MOVLW  01
0160A:  SUBWF  x4F,F
0160C:  BNC   1624
0160E:  INCF   03,F
01610:  BNZ   1624
01612:  INCF   02,F
01614:  BNZ   1624
01616:  INCF   01,F
01618:  BNZ   1624
0161A:  INCF   00,F
0161C:  BZ    1638
0161E:  RRCF   01,F
01620:  RRCF   02,F
01622:  RRCF   03,F
01624:  MOVFF  645,650
01628:  MOVF   x49,W
0162A:  XORWF  x50,F
0162C:  BTFSS  x50.7
0162E:  BRA    1634
01630:  BSF    01.7
01632:  BRA    1640
01634:  BCF    01.7
01636:  BRA    1640
01638:  CLRF   00
0163A:  CLRF   01
0163C:  CLRF   02
0163E:  CLRF   03
01640:  MOVLB  0
01642:  RETURN 0
*
01DEE:  ADDWF  FE8,W
01DF0:  CLRF   FF7
01DF2:  RLCF   FF7,F
01DF4:  ADDLW  09
01DF6:  MOVWF  FF6
01DF8:  MOVLW  1E
01DFA:  ADDWFC FF7,F
01DFC:  TBLRD*-
01DFE:  MOVF   FF5,W
01E00:  MOVWF  FFA
01E02:  TBLRD*
01E04:  MOVF   FF5,W
01E06:  MOVWF  FF9
01E08:  DATA F6,1C
01E0A:  DATA 10,1D
01E0C:  DATA 64,1D
01E0E:  DATA C8,1D
01E10:  MOVLW  8E
01E12:  MOVWF  00
01E14:  MOVFF  642,01
01E18:  MOVFF  641,02
01E1C:  CLRF   03
01E1E:  BTFSS  01.7
01E20:  BRA    1E2C
01E22:  COMF   01,F
01E24:  COMF   02,F
01E26:  INCF   02,F
01E28:  BNZ   1E2C
01E2A:  INCF   01,F
01E2C:  MOVF   01,F
01E2E:  BNZ   1E42
01E30:  MOVFF  02,01
01E34:  CLRF   02
01E36:  MOVLW  08
01E38:  SUBWF  00,F
01E3A:  MOVF   01,F
01E3C:  BNZ   1E42
01E3E:  CLRF   00
01E40:  BRA    1E5E
01E42:  BCF    FD8.0
01E44:  BTFSC  01.7
01E46:  BRA    1E50
01E48:  RLCF   02,F
01E4A:  RLCF   01,F
01E4C:  DECF   00,F
01E4E:  BRA    1E42
01E50:  MOVLB  6
01E52:  BTFSS  x42.7
01E54:  BRA    1E5A
01E56:  MOVLB  0
01E58:  BRA    1E5E
01E5A:  BCF    01.7
01E5C:  MOVLB  0
01E5E:  RETURN 0
01E60:  MOVLW  8E
01E62:  MOVWF  00
01E64:  MOVLB  6
01E66:  MOVF   x4B,W
01E68:  SUBWF  00,F
01E6A:  MOVFF  64C,02
01E6E:  MOVFF  64D,01
01E72:  BSF    02.7
01E74:  MOVF   00,F
01E76:  BZ    1E8A
01E78:  BCF    FD8.0
01E7A:  MOVF   02,F
01E7C:  BNZ   1E82
01E7E:  MOVF   01,F
01E80:  BZ    1E8A
01E82:  RRCF   02,F
01E84:  RRCF   01,F
01E86:  DECFSZ 00,F
01E88:  BRA    1E78
01E8A:  BTFSS  x4C.7
01E8C:  BRA    1E98
01E8E:  COMF   01,F
01E90:  COMF   02,F
01E92:  INCF   01,F
01E94:  BTFSC  FD8.2
01E96:  INCF   02,F
01E98:  MOVLB  0
01E9A:  RETURN 0
*
03CA4:  MOVLB  5
03CA6:  MOVF   xFB,W
03CA8:  ANDLW  07
03CAA:  MOVWF  00
03CAC:  RRCF   xFB,W
03CAE:  MOVWF  01
03CB0:  RRCF   01,F
03CB2:  RRCF   01,F
03CB4:  MOVLW  1F
03CB6:  ANDWF  01,F
03CB8:  MOVF   01,W
03CBA:  ADDWF  xFC,W
03CBC:  MOVWF  FE9
03CBE:  MOVLW  00
03CC0:  ADDWFC xFD,W
03CC2:  MOVWF  FEA
03CC4:  MOVFF  FEF,01
03CC8:  INCF   00,F
03CCA:  BRA    3CCE
03CCC:  RRCF   01,F
03CCE:  DECFSZ 00,F
03CD0:  BRA    3CCC
03CD2:  MOVLW  01
03CD4:  ANDWF  01,F
03CD6:  MOVLB  0
03CD8:  RETURN 0
*
046F4:  MOVF   FEF,F
046F6:  BZ    4716
046F8:  MOVFF  FEA,5F4
046FC:  MOVFF  FE9,5F3
04700:  MOVFF  FEF,600
04704:  RCALL  46CC
04706:  MOVFF  5F4,FEA
0470A:  MOVFF  5F3,FE9
0470E:  INCF   FE9,F
04710:  BTFSC  FD8.2
04712:  INCF   FEA,F
04714:  BRA    46F4
04716:  RETURN 0
*
04C30:  TBLRD*+
04C32:  MOVFF  FF6,5F4
04C36:  MOVFF  FF7,5F5
04C3A:  MOVFF  FF5,600
04C3E:  RCALL  46CC
04C40:  MOVFF  5F4,FF6
04C44:  MOVFF  5F5,FF7
04C48:  MOVLB  5
04C4A:  DECFSZ xF3,F
04C4C:  BRA    4C50
04C4E:  BRA    4C54
04C50:  MOVLB  0
04C52:  BRA    4C30
04C54:  MOVLB  0
04C56:  RETURN 0
04C58:  MOVLB  6
04C5A:  MOVF   x30,W
04C5C:  CLRF   01
04C5E:  SUBWF  x2F,W
04C60:  BC    4C68
04C62:  MOVFF  62F,00
04C66:  BRA    4C80
04C68:  CLRF   00
04C6A:  MOVLW  08
04C6C:  MOVWF  x31
04C6E:  RLCF   x2F,F
04C70:  RLCF   00,F
04C72:  MOVF   x30,W
04C74:  SUBWF  00,W
04C76:  BTFSC  FD8.0
04C78:  MOVWF  00
04C7A:  RLCF   01,F
04C7C:  DECFSZ x31,F
04C7E:  BRA    4C6E
04C80:  MOVLB  0
04C82:  RETURN 0
04C84:  MOVF   01,W
04C86:  MOVFF  5F3,62F
04C8A:  MOVLW  64
04C8C:  MOVLB  6
04C8E:  MOVWF  x30
04C90:  MOVLB  0
04C92:  RCALL  4C58
04C94:  MOVFF  00,5F3
04C98:  MOVF   01,W
04C9A:  MOVLW  30
04C9C:  BNZ   4CAE
04C9E:  MOVLB  5
04CA0:  BTFSS  xF4.1
04CA2:  BRA    4CC0
04CA4:  BTFSC  xF4.3
04CA6:  BRA    4CC0
04CA8:  BTFSC  xF4.4
04CAA:  MOVLW  20
04CAC:  BRA    4CB6
04CAE:  MOVLB  5
04CB0:  BCF    xF4.3
04CB2:  BCF    xF4.4
04CB4:  BSF    xF4.0
04CB6:  ADDWF  01,F
04CB8:  MOVFF  01,600
04CBC:  MOVLB  0
04CBE:  RCALL  46CC
04CC0:  MOVFF  5F3,62F
04CC4:  MOVLW  0A
04CC6:  MOVLB  6
04CC8:  MOVWF  x30
04CCA:  MOVLB  0
04CCC:  RCALL  4C58
04CCE:  MOVFF  00,5F3
04CD2:  MOVF   01,W
04CD4:  MOVLW  30
04CD6:  BNZ   4CE8
04CD8:  MOVLB  5
04CDA:  BTFSC  xF4.3
04CDC:  BRA    4CF2
04CDE:  BTFSS  xF4.0
04CE0:  BRA    4CF2
04CE2:  BTFSC  xF4.4
04CE4:  MOVLW  20
04CE6:  MOVLB  0
04CE8:  ADDWF  01,F
04CEA:  MOVFF  01,600
04CEE:  RCALL  46CC
04CF0:  MOVLB  5
04CF2:  MOVLW  30
04CF4:  ADDWF  xF3,F
04CF6:  MOVFF  5F3,600
04CFA:  MOVLB  0
04CFC:  RCALL  46CC
04CFE:  RETURN 0
04D00:  MOVLB  6
04D02:  MOVF   x3E,W
04D04:  SUBLW  B6
04D06:  MOVWF  x3E
04D08:  CLRF   03
04D0A:  MOVFF  63F,642
04D0E:  BSF    x3F.7
04D10:  BCF    FD8.0
04D12:  RRCF   x3F,F
04D14:  RRCF   x40,F
04D16:  RRCF   x41,F
04D18:  RRCF   03,F
04D1A:  RRCF   02,F
04D1C:  RRCF   01,F
04D1E:  RRCF   00,F
04D20:  DECFSZ x3E,F
04D22:  BRA    4D10
04D24:  BTFSS  x42.7
04D26:  BRA    4D3E
04D28:  COMF   00,F
04D2A:  COMF   01,F
04D2C:  COMF   02,F
04D2E:  COMF   03,F
04D30:  INCF   00,F
04D32:  BTFSC  FD8.2
04D34:  INCF   01,F
04D36:  BTFSC  FD8.2
04D38:  INCF   02,F
04D3A:  BTFSC  FD8.2
04D3C:  INCF   03,F
04D3E:  MOVLB  0
04D40:  RETURN 0
04D42:  BTFSC  FD8.1
04D44:  BRA    4D4E
04D46:  MOVLW  06
04D48:  MOVWF  FEA
04D4A:  MOVLW  46
04D4C:  MOVWF  FE9
04D4E:  CLRF   00
04D50:  CLRF   01
04D52:  CLRF   02
04D54:  CLRF   03
04D56:  MOVLB  6
04D58:  CLRF   x46
04D5A:  CLRF   x47
04D5C:  CLRF   x48
04D5E:  CLRF   x49
04D60:  MOVF   x45,W
04D62:  IORWF  x44,W
04D64:  IORWF  x43,W
04D66:  IORWF  x42,W
04D68:  BZ    4DC2
04D6A:  MOVLW  20
04D6C:  MOVWF  x4A
04D6E:  BCF    FD8.0
04D70:  RLCF   x3E,F
04D72:  RLCF   x3F,F
04D74:  RLCF   x40,F
04D76:  RLCF   x41,F
04D78:  RLCF   x46,F
04D7A:  RLCF   x47,F
04D7C:  RLCF   x48,F
04D7E:  RLCF   x49,F
04D80:  MOVF   x45,W
04D82:  SUBWF  x49,W
04D84:  BNZ   4D96
04D86:  MOVF   x44,W
04D88:  SUBWF  x48,W
04D8A:  BNZ   4D96
04D8C:  MOVF   x43,W
04D8E:  SUBWF  x47,W
04D90:  BNZ   4D96
04D92:  MOVF   x42,W
04D94:  SUBWF  x46,W
04D96:  BNC   4DB6
04D98:  MOVF   x42,W
04D9A:  SUBWF  x46,F
04D9C:  MOVF   x43,W
04D9E:  BTFSS  FD8.0
04DA0:  INCFSZ x43,W
04DA2:  SUBWF  x47,F
04DA4:  MOVF   x44,W
04DA6:  BTFSS  FD8.0
04DA8:  INCFSZ x44,W
04DAA:  SUBWF  x48,F
04DAC:  MOVF   x45,W
04DAE:  BTFSS  FD8.0
04DB0:  INCFSZ x45,W
04DB2:  SUBWF  x49,F
04DB4:  BSF    FD8.0
04DB6:  RLCF   00,F
04DB8:  RLCF   01,F
04DBA:  RLCF   02,F
04DBC:  RLCF   03,F
04DBE:  DECFSZ x4A,F
04DC0:  BRA    4D6E
04DC2:  MOVFF  646,FEF
04DC6:  MOVFF  647,FEC
04DCA:  MOVFF  648,FEC
04DCE:  MOVFF  649,FEC
04DD2:  MOVLB  0
04DD4:  RETURN 0
04DD6:  MOVF   FE9,W
04DD8:  MOVLB  5
04DDA:  MOVWF  xF8
04DDC:  MOVF   xF7,W
04DDE:  MOVWF  xFA
04DE0:  BZ    4E1C
04DE2:  MOVFF  5F6,64E
04DE6:  MOVFF  5F5,64D
04DEA:  MOVFF  5F4,64C
04DEE:  MOVFF  5F3,64B
04DF2:  MOVLB  6
04DF4:  CLRF   x52
04DF6:  CLRF   x51
04DF8:  MOVLW  20
04DFA:  MOVWF  x50
04DFC:  MOVLW  82
04DFE:  MOVWF  x4F
04E00:  MOVLB  0
04E02:  CALL   0ABC
04E06:  MOVFF  03,5F6
04E0A:  MOVFF  02,5F5
04E0E:  MOVFF  01,5F4
04E12:  MOVFF  00,5F3
04E16:  MOVLB  5
04E18:  DECFSZ xFA,F
04E1A:  BRA    4DE2
04E1C:  MOVFF  5F6,641
04E20:  MOVFF  5F5,640
04E24:  MOVFF  5F4,63F
04E28:  MOVFF  5F3,63E
04E2C:  MOVLB  0
04E2E:  RCALL  4D00
04E30:  MOVFF  03,5F6
04E34:  MOVFF  02,5F5
04E38:  MOVFF  01,5F4
04E3C:  MOVFF  00,5F3
04E40:  MOVLB  5
04E42:  BTFSS  xF6.7
04E44:  BRA    4E60
04E46:  DECF   xF8,F
04E48:  BSF    xF8.5
04E4A:  COMF   xF3,F
04E4C:  COMF   xF4,F
04E4E:  COMF   xF5,F
04E50:  COMF   xF6,F
04E52:  INCF   xF3,F
04E54:  BTFSC  FD8.2
04E56:  INCF   xF4,F
04E58:  BTFSC  FD8.2
04E5A:  INCF   xF5,F
04E5C:  BTFSC  FD8.2
04E5E:  INCF   xF6,F
04E60:  MOVLW  3B
04E62:  MOVWF  xFF
04E64:  MOVLW  9A
04E66:  MOVWF  xFE
04E68:  MOVLW  CA
04E6A:  MOVWF  xFD
04E6C:  CLRF   xFC
04E6E:  MOVLW  0A
04E70:  MOVWF  xFA
04E72:  MOVF   xF7,W
04E74:  BTFSC  FD8.2
04E76:  INCF   xF8,F
04E78:  BSF    FD8.1
04E7A:  MOVLW  05
04E7C:  MOVWF  FEA
04E7E:  MOVLW  F3
04E80:  MOVWF  FE9
04E82:  MOVFF  5F6,641
04E86:  MOVFF  5F5,640
04E8A:  MOVFF  5F4,63F
04E8E:  MOVFF  5F3,63E
04E92:  MOVFF  5FF,645
04E96:  MOVFF  5FE,644
04E9A:  MOVFF  5FD,643
04E9E:  MOVFF  5FC,642
04EA2:  MOVLB  0
04EA4:  RCALL  4D42
04EA6:  MOVF   01,W
04EA8:  MOVF   00,F
04EAA:  BNZ   4ED2
04EAC:  MOVLB  5
04EAE:  INCF   xF7,W
04EB0:  SUBWF  xFA,W
04EB2:  BTFSS  FD8.2
04EB4:  BRA    4EBA
04EB6:  MOVLB  0
04EB8:  BRA    4ED2
04EBA:  MOVF   xF8,W
04EBC:  BZ    4ED8
04EBE:  ANDLW  0F
04EC0:  SUBWF  xFA,W
04EC2:  BZ    4EC6
04EC4:  BC    4F54
04EC6:  BTFSC  xF8.7
04EC8:  BRA    4F54
04ECA:  BTFSC  xF8.6
04ECC:  BRA    4ED8
04ECE:  MOVLW  20
04ED0:  BRA    4F46
04ED2:  MOVLW  20
04ED4:  MOVLB  5
04ED6:  ANDWF  xF8,F
04ED8:  BTFSS  xF8.5
04EDA:  BRA    4EFC
04EDC:  BCF    xF8.5
04EDE:  MOVF   xF7,W
04EE0:  BTFSS  FD8.2
04EE2:  DECF   xF8,F
04EE4:  MOVF   00,W
04EE6:  MOVWF  xF8
04EE8:  MOVLW  2D
04EEA:  MOVLB  6
04EEC:  MOVWF  x00
04EEE:  MOVLB  0
04EF0:  CALL   46CC
04EF4:  MOVLB  5
04EF6:  MOVF   xF8,W
04EF8:  MOVWF  00
04EFA:  CLRF   xF8
04EFC:  MOVF   xF7,W
04EFE:  SUBWF  xFA,W
04F00:  BNZ   4F1E
04F02:  MOVF   00,W
04F04:  MOVWF  xF8
04F06:  MOVLW  2E
04F08:  MOVLB  6
04F0A:  MOVWF  x00
04F0C:  MOVLB  0
04F0E:  CALL   46CC
04F12:  MOVLB  5
04F14:  MOVF   xF8,W
04F16:  MOVWF  00
04F18:  MOVLW  20
04F1A:  ANDWF  xF8,F
04F1C:  MOVLW  00
04F1E:  MOVLW  30
04F20:  BTFSS  xF8.5
04F22:  BRA    4F46
04F24:  BCF    xF8.5
04F26:  MOVF   xF7,W
04F28:  BTFSS  FD8.2
04F2A:  DECF   xF8,F
04F2C:  MOVF   00,W
04F2E:  MOVWF  xF8
04F30:  MOVLW  2D
04F32:  MOVLB  6
04F34:  MOVWF  x00
04F36:  MOVLB  0
04F38:  CALL   46CC
04F3C:  MOVLB  5
04F3E:  MOVF   xF8,W
04F40:  MOVWF  00
04F42:  CLRF   xF8
04F44:  MOVLW  30
04F46:  ADDWF  00,F
04F48:  MOVFF  00,600
04F4C:  MOVLB  0
04F4E:  CALL   46CC
04F52:  MOVLB  5
04F54:  BCF    FD8.1
04F56:  MOVFF  5FF,641
04F5A:  MOVFF  5FE,640
04F5E:  MOVFF  5FD,63F
04F62:  MOVFF  5FC,63E
04F66:  MOVLB  6
04F68:  CLRF   x45
04F6A:  CLRF   x44
04F6C:  CLRF   x43
04F6E:  MOVLW  0A
04F70:  MOVWF  x42
04F72:  MOVLB  0
04F74:  RCALL  4D42
04F76:  MOVFF  03,5FF
04F7A:  MOVFF  02,5FE
04F7E:  MOVFF  01,5FD
04F82:  MOVFF  00,5FC
04F86:  MOVLB  5
04F88:  DECFSZ xFA,F
04F8A:  BRA    4E78
04F8C:  MOVLB  0
04F8E:  GOTO   9F28 (RETURN)
04F92:  MOVFF  FEA,5F9
04F96:  MOVFF  FE9,5F8
04F9A:  MOVLB  5
04F9C:  SWAPF  xF2,W
04F9E:  IORLW  F0
04FA0:  MOVWF  xF4
04FA2:  ADDWF  xF4,F
04FA4:  ADDLW  E2
04FA6:  MOVWF  xF5
04FA8:  ADDLW  32
04FAA:  MOVWF  xF7
04FAC:  MOVF   xF2,W
04FAE:  ANDLW  0F
04FB0:  ADDWF  xF5,F
04FB2:  ADDWF  xF5,F
04FB4:  ADDWF  xF7,F
04FB6:  ADDLW  E9
04FB8:  MOVWF  xF6
04FBA:  ADDWF  xF6,F
04FBC:  ADDWF  xF6,F
04FBE:  SWAPF  xF1,W
04FC0:  ANDLW  0F
04FC2:  ADDWF  xF6,F
04FC4:  ADDWF  xF7,F
04FC6:  RLCF   xF6,F
04FC8:  RLCF   xF7,F
04FCA:  COMF   xF7,F
04FCC:  RLCF   xF7,F
04FCE:  MOVF   xF1,W
04FD0:  ANDLW  0F
04FD2:  ADDWF  xF7,F
04FD4:  RLCF   xF4,F
04FD6:  MOVLW  07
04FD8:  MOVWF  xF3
04FDA:  MOVLW  0A
04FDC:  DECF   xF6,F
04FDE:  ADDWF  xF7,F
04FE0:  BNC   4FDC
04FE2:  DECF   xF5,F
04FE4:  ADDWF  xF6,F
04FE6:  BNC   4FE2
04FE8:  DECF   xF4,F
04FEA:  ADDWF  xF5,F
04FEC:  BNC   4FE8
04FEE:  DECF   xF3,F
04FF0:  ADDWF  xF4,F
04FF2:  BNC   4FEE
04FF4:  MOVLW  05
04FF6:  MOVWF  FEA
04FF8:  MOVLW  F3
04FFA:  MOVWF  FE9
04FFC:  MOVLW  07
04FFE:  ANDWF  xF8,W
05000:  BCF    xF8.6
05002:  ADDWF  FE9,F
05004:  MOVLW  00
05006:  ADDWFC FEA,F
05008:  MOVF   FE9,W
0500A:  SUBLW  F7
0500C:  BNZ   5016
0500E:  MOVF   FEA,W
05010:  SUBLW  05
05012:  BNZ   5016
05014:  BSF    xF8.6
05016:  MOVF   FEF,W
05018:  MOVWF  00
0501A:  BNZ   502C
0501C:  BTFSC  xF8.6
0501E:  BRA    502C
05020:  BTFSC  xF8.4
05022:  BRA    5050
05024:  BTFSC  xF8.3
05026:  BRA    502C
05028:  MOVLW  20
0502A:  BRA    5032
0502C:  BSF    xF8.3
0502E:  BCF    xF8.4
05030:  MOVLW  30
05032:  ADDWF  00,F
05034:  MOVFF  FEA,5F2
05038:  MOVFF  FE9,5F1
0503C:  MOVFF  00,600
05040:  MOVLB  0
05042:  CALL   46CC
05046:  MOVFF  5F2,FEA
0504A:  MOVFF  5F1,FE9
0504E:  MOVLB  5
05050:  MOVF   FEE,W
05052:  BTFSS  xF8.6
05054:  BRA    5008
05056:  MOVLB  0
05058:  GOTO   9F94 (RETURN)
*
051A0:  MOVFF  4E5,FEA
051A4:  MOVFF  4E4,FE9
051A8:  MOVFF  63E,FEF
051AC:  INCF   FE9,F
051AE:  BTFSC  FD8.2
051B0:  INCF   FEA,F
051B2:  CLRF   FEF
051B4:  MOVLB  4
051B6:  INCF   xE4,F
051B8:  BTFSC  FD8.2
051BA:  INCF   xE5,F
051BC:  MOVLB  0
051BE:  RETURN 0
051C0:  TBLRD*+
051C2:  MOVF   FF5,F
051C4:  BZ    51DE
051C6:  MOVFF  FF6,5FC
051CA:  MOVFF  FF7,5FD
051CE:  MOVFF  FF5,63E
051D2:  RCALL  51A0
051D4:  MOVFF  5FC,FF6
051D8:  MOVFF  5FD,FF7
051DC:  BRA    51C0
051DE:  RETURN 0
*
05302:  MOVLB  6
05304:  MOVF   x5D,W
05306:  XORWF  x5F,W
05308:  ANDLW  80
0530A:  MOVWF  x61
0530C:  BTFSS  x5D.7
0530E:  BRA    531A
05310:  COMF   x5C,F
05312:  COMF   x5D,F
05314:  INCF   x5C,F
05316:  BTFSC  FD8.2
05318:  INCF   x5D,F
0531A:  BTFSS  x5F.7
0531C:  BRA    5328
0531E:  COMF   x5E,F
05320:  COMF   x5F,F
05322:  INCF   x5E,F
05324:  BTFSC  FD8.2
05326:  INCF   x5F,F
05328:  MOVF   x5C,W
0532A:  MULWF  x5E
0532C:  MOVFF  FF3,01
05330:  MOVFF  FF4,00
05334:  MULWF  x5F
05336:  MOVF   FF3,W
05338:  ADDWF  00,F
0533A:  MOVF   x5D,W
0533C:  MULWF  x5E
0533E:  MOVF   FF3,W
05340:  ADDWFC 00,W
05342:  MOVWF  02
05344:  BTFSS  x61.7
05346:  BRA    5352
05348:  COMF   01,F
0534A:  COMF   02,F
0534C:  INCF   01,F
0534E:  BTFSC  FD8.2
05350:  INCF   02,F
05352:  MOVLB  0
05354:  GOTO   55E8 (RETURN)
*
056AC:  MOVLW  20
056AE:  MOVLB  6
056B0:  BTFSS  x2A.4
056B2:  MOVLW  30
056B4:  MOVWF  x2B
056B6:  MOVFF  629,00
056BA:  BTFSS  00.7
056BC:  BRA    56CE
056BE:  COMF   00,F
056C0:  INCF   00,F
056C2:  MOVFF  00,629
056C6:  MOVLW  2D
056C8:  MOVWF  x2B
056CA:  BSF    x2A.7
056CC:  BSF    x2A.0
056CE:  MOVF   01,W
056D0:  MOVFF  629,62F
056D4:  MOVLW  64
056D6:  MOVWF  x30
056D8:  MOVLB  0
056DA:  CALL   4C58
056DE:  MOVFF  00,629
056E2:  MOVLW  30
056E4:  ADDWF  01,W
056E6:  MOVLB  6
056E8:  MOVWF  x2C
056EA:  MOVFF  629,62F
056EE:  MOVLW  0A
056F0:  MOVWF  x30
056F2:  MOVLB  0
056F4:  CALL   4C58
056F8:  MOVLW  30
056FA:  ADDWF  00,W
056FC:  MOVLB  6
056FE:  MOVWF  x2E
05700:  MOVLW  30
05702:  ADDWF  01,W
05704:  MOVWF  x2D
05706:  MOVFF  62B,00
0570A:  MOVLW  30
0570C:  SUBWF  x2C,W
0570E:  BZ    5718
05710:  BSF    x2A.1
05712:  BTFSC  x2A.7
05714:  BSF    x2A.2
05716:  BRA    573C
05718:  MOVFF  62B,62C
0571C:  MOVLW  20
0571E:  MOVWF  x2B
05720:  MOVLW  30
05722:  SUBWF  x2D,W
05724:  BZ    572E
05726:  BSF    x2A.0
05728:  BTFSC  x2A.7
0572A:  BSF    x2A.1
0572C:  BRA    573C
0572E:  BTFSS  FD8.2
05730:  BSF    x2A.0
05732:  BNZ   573C
05734:  MOVFF  62C,62D
05738:  MOVLW  20
0573A:  MOVWF  x2C
0573C:  BTFSC  x2A.2
0573E:  BRA    574A
05740:  BTFSC  x2A.1
05742:  BRA    5752
05744:  BTFSC  x2A.0
05746:  BRA    575A
05748:  BRA    5762
0574A:  MOVFF  62B,63E
0574E:  MOVLB  0
05750:  RCALL  51A0
05752:  MOVFF  62C,63E
05756:  MOVLB  0
05758:  RCALL  51A0
0575A:  MOVFF  62D,63E
0575E:  MOVLB  0
05760:  RCALL  51A0
05762:  MOVFF  62E,63E
05766:  MOVLB  0
05768:  RCALL  51A0
0576A:  RETURN 0
*
0590E:  MOVLB  6
05910:  MOVF   x10,W
05912:  ANDLW  07
05914:  MOVWF  00
05916:  RRCF   x10,W
05918:  MOVWF  01
0591A:  RRCF   01,F
0591C:  RRCF   01,F
0591E:  MOVLW  1F
05920:  ANDWF  01,F
05922:  MOVF   01,W
05924:  ADDWF  x12,W
05926:  MOVWF  FE9
05928:  MOVLW  00
0592A:  ADDWFC x13,W
0592C:  MOVWF  FEA
0592E:  CLRF   01
05930:  INCF   01,F
05932:  INCF   00,F
05934:  BRA    5938
05936:  RLCF   01,F
05938:  DECFSZ 00,F
0593A:  BRA    5936
0593C:  MOVF   x11,F
0593E:  BZ    5946
05940:  MOVF   01,W
05942:  IORWF  FEF,F
05944:  BRA    594C
05946:  COMF   01,F
05948:  MOVF   01,W
0594A:  ANDWF  FEF,F
0594C:  MOVLB  0
0594E:  RETURN 0
*
05B08:  TBLRD*+
05B0A:  MOVFF  FF6,5FE
05B0E:  MOVFF  FF7,5FF
05B12:  MOVFF  FF5,63E
05B16:  CALL   51A0
05B1A:  MOVFF  5FE,FF6
05B1E:  MOVFF  5FF,FF7
05B22:  MOVLB  5
05B24:  DECFSZ xFD,F
05B26:  BRA    5B2A
05B28:  BRA    5B2E
05B2A:  MOVLB  0
05B2C:  BRA    5B08
05B2E:  MOVLB  0
05B30:  RETURN 0
*
05EE8:  MOVF   FE9,W
05EEA:  MOVLB  6
05EEC:  MOVWF  x36
05EEE:  MOVF   x35,W
05EF0:  MOVWF  x38
05EF2:  BZ    5F2C
05EF4:  MOVFF  634,64E
05EF8:  MOVFF  633,64D
05EFC:  MOVFF  632,64C
05F00:  MOVFF  631,64B
05F04:  CLRF   x52
05F06:  CLRF   x51
05F08:  MOVLW  20
05F0A:  MOVWF  x50
05F0C:  MOVLW  82
05F0E:  MOVWF  x4F
05F10:  MOVLB  0
05F12:  CALL   0ABC
05F16:  MOVFF  03,634
05F1A:  MOVFF  02,633
05F1E:  MOVFF  01,632
05F22:  MOVFF  00,631
05F26:  MOVLB  6
05F28:  DECFSZ x38,F
05F2A:  BRA    5EF4
05F2C:  MOVFF  634,641
05F30:  MOVFF  633,640
05F34:  MOVFF  632,63F
05F38:  MOVFF  631,63E
05F3C:  MOVLB  0
05F3E:  CALL   4D00
05F42:  MOVFF  03,634
05F46:  MOVFF  02,633
05F4A:  MOVFF  01,632
05F4E:  MOVFF  00,631
05F52:  MOVLB  6
05F54:  BTFSS  x34.7
05F56:  BRA    5F72
05F58:  DECF   x36,F
05F5A:  BSF    x36.5
05F5C:  COMF   x31,F
05F5E:  COMF   x32,F
05F60:  COMF   x33,F
05F62:  COMF   x34,F
05F64:  INCF   x31,F
05F66:  BTFSC  FD8.2
05F68:  INCF   x32,F
05F6A:  BTFSC  FD8.2
05F6C:  INCF   x33,F
05F6E:  BTFSC  FD8.2
05F70:  INCF   x34,F
05F72:  MOVLW  3B
05F74:  MOVWF  x3D
05F76:  MOVLW  9A
05F78:  MOVWF  x3C
05F7A:  MOVLW  CA
05F7C:  MOVWF  x3B
05F7E:  CLRF   x3A
05F80:  MOVLW  0A
05F82:  MOVWF  x38
05F84:  MOVF   x35,W
05F86:  BTFSC  FD8.2
05F88:  INCF   x36,F
05F8A:  BSF    FD8.1
05F8C:  MOVLW  06
05F8E:  MOVWF  FEA
05F90:  MOVLW  31
05F92:  MOVWF  FE9
05F94:  MOVFF  634,641
05F98:  MOVFF  633,640
05F9C:  MOVFF  632,63F
05FA0:  MOVFF  631,63E
05FA4:  MOVFF  63D,645
05FA8:  MOVFF  63C,644
05FAC:  MOVFF  63B,643
05FB0:  MOVFF  63A,642
05FB4:  MOVLB  0
05FB6:  CALL   4D42
05FBA:  MOVF   01,W
05FBC:  MOVF   00,F
05FBE:  BNZ   5FE6
05FC0:  MOVLB  6
05FC2:  INCF   x35,W
05FC4:  SUBWF  x38,W
05FC6:  BTFSS  FD8.2
05FC8:  BRA    5FCE
05FCA:  MOVLB  0
05FCC:  BRA    5FE6
05FCE:  MOVF   x36,W
05FD0:  BZ    5FEC
05FD2:  ANDLW  0F
05FD4:  SUBWF  x38,W
05FD6:  BZ    5FDA
05FD8:  BC    6062
05FDA:  BTFSC  x36.7
05FDC:  BRA    6062
05FDE:  BTFSC  x36.6
05FE0:  BRA    5FEC
05FE2:  MOVLW  20
05FE4:  BRA    6054
05FE6:  MOVLW  20
05FE8:  MOVLB  6
05FEA:  ANDWF  x36,F
05FEC:  BTFSS  x36.5
05FEE:  BRA    600E
05FF0:  BCF    x36.5
05FF2:  MOVF   x35,W
05FF4:  BTFSS  FD8.2
05FF6:  DECF   x36,F
05FF8:  MOVF   00,W
05FFA:  MOVWF  x36
05FFC:  MOVLW  2D
05FFE:  MOVWF  x3E
06000:  MOVLB  0
06002:  CALL   51A0
06006:  MOVLB  6
06008:  MOVF   x36,W
0600A:  MOVWF  00
0600C:  CLRF   x36
0600E:  MOVF   x35,W
06010:  SUBWF  x38,W
06012:  BNZ   602E
06014:  MOVF   00,W
06016:  MOVWF  x36
06018:  MOVLW  2E
0601A:  MOVWF  x3E
0601C:  MOVLB  0
0601E:  CALL   51A0
06022:  MOVLB  6
06024:  MOVF   x36,W
06026:  MOVWF  00
06028:  MOVLW  20
0602A:  ANDWF  x36,F
0602C:  MOVLW  00
0602E:  MOVLW  30
06030:  BTFSS  x36.5
06032:  BRA    6054
06034:  BCF    x36.5
06036:  MOVF   x35,W
06038:  BTFSS  FD8.2
0603A:  DECF   x36,F
0603C:  MOVF   00,W
0603E:  MOVWF  x36
06040:  MOVLW  2D
06042:  MOVWF  x3E
06044:  MOVLB  0
06046:  CALL   51A0
0604A:  MOVLB  6
0604C:  MOVF   x36,W
0604E:  MOVWF  00
06050:  CLRF   x36
06052:  MOVLW  30
06054:  ADDWF  00,F
06056:  MOVFF  00,63E
0605A:  MOVLB  0
0605C:  CALL   51A0
06060:  MOVLB  6
06062:  BCF    FD8.1
06064:  MOVFF  63D,641
06068:  MOVFF  63C,640
0606C:  MOVFF  63B,63F
06070:  MOVFF  63A,63E
06074:  CLRF   x45
06076:  CLRF   x44
06078:  CLRF   x43
0607A:  MOVLW  0A
0607C:  MOVWF  x42
0607E:  MOVLB  0
06080:  CALL   4D42
06084:  MOVFF  03,63D
06088:  MOVFF  02,63C
0608C:  MOVFF  01,63B
06090:  MOVFF  00,63A
06094:  MOVLB  6
06096:  DECFSZ x38,F
06098:  BRA    5F8A
0609A:  MOVLB  0
0609C:  RETURN 0
*
08C32:  MOVF   FE9,W
08C34:  MOVLB  6
08C36:  MOVWF  x32
08C38:  BTFSS  x31.7
08C3A:  BRA    8C56
08C3C:  DECF   x32,F
08C3E:  BSF    x32.5
08C40:  COMF   x2E,F
08C42:  COMF   x2F,F
08C44:  COMF   x30,F
08C46:  COMF   x31,F
08C48:  INCF   x2E,F
08C4A:  BTFSC  FD8.2
08C4C:  INCF   x2F,F
08C4E:  BTFSC  FD8.2
08C50:  INCF   x30,F
08C52:  BTFSC  FD8.2
08C54:  INCF   x31,F
08C56:  MOVLW  3B
08C58:  MOVWF  x39
08C5A:  MOVLW  9A
08C5C:  MOVWF  x38
08C5E:  MOVLW  CA
08C60:  MOVWF  x37
08C62:  CLRF   x36
08C64:  MOVLW  0A
08C66:  MOVWF  x34
08C68:  BSF    FD8.1
08C6A:  MOVLW  06
08C6C:  MOVWF  FEA
08C6E:  MOVLW  2E
08C70:  MOVWF  FE9
08C72:  MOVFF  631,641
08C76:  MOVFF  630,640
08C7A:  MOVFF  62F,63F
08C7E:  MOVFF  62E,63E
08C82:  MOVFF  639,645
08C86:  MOVFF  638,644
08C8A:  MOVFF  637,643
08C8E:  MOVFF  636,642
08C92:  MOVLB  0
08C94:  CALL   4D42
08C98:  MOVF   01,W
08C9A:  MOVF   00,F
08C9C:  BNZ   8CC4
08C9E:  MOVLB  6
08CA0:  MOVF   x34,W
08CA2:  XORLW  01
08CA4:  BTFSS  FD8.2
08CA6:  BRA    8CAC
08CA8:  MOVLB  0
08CAA:  BRA    8CC4
08CAC:  MOVF   x32,W
08CAE:  BZ    8CCA
08CB0:  ANDLW  0F
08CB2:  SUBWF  x34,W
08CB4:  BZ    8CB8
08CB6:  BC    8D14
08CB8:  BTFSC  x32.7
08CBA:  BRA    8D14
08CBC:  BTFSC  x32.6
08CBE:  BRA    8CCA
08CC0:  MOVLW  20
08CC2:  BRA    8D06
08CC4:  MOVLW  20
08CC6:  MOVLB  6
08CC8:  ANDWF  x32,F
08CCA:  BTFSS  x32.5
08CCC:  BRA    8CE6
08CCE:  BCF    x32.5
08CD0:  MOVFF  00,632
08CD4:  MOVLW  2D
08CD6:  MOVWF  x3E
08CD8:  MOVLB  0
08CDA:  CALL   51A0
08CDE:  MOVLB  6
08CE0:  MOVFF  632,00
08CE4:  CLRF   x32
08CE6:  MOVLW  30
08CE8:  BTFSS  x32.5
08CEA:  BRA    8D06
08CEC:  BCF    x32.5
08CEE:  MOVFF  00,632
08CF2:  MOVLW  2D
08CF4:  MOVWF  x3E
08CF6:  MOVLB  0
08CF8:  CALL   51A0
08CFC:  MOVLB  6
08CFE:  MOVFF  632,00
08D02:  CLRF   x32
08D04:  MOVLW  30
08D06:  ADDWF  00,F
08D08:  MOVFF  00,63E
08D0C:  MOVLB  0
08D0E:  CALL   51A0
08D12:  MOVLB  6
08D14:  BCF    FD8.1
08D16:  MOVFF  639,641
08D1A:  MOVFF  638,640
08D1E:  MOVFF  637,63F
08D22:  MOVFF  636,63E
08D26:  CLRF   x45
08D28:  CLRF   x44
08D2A:  CLRF   x43
08D2C:  MOVLW  0A
08D2E:  MOVWF  x42
08D30:  MOVLB  0
08D32:  CALL   4D42
08D36:  MOVFF  03,639
08D3A:  MOVFF  02,638
08D3E:  MOVFF  01,637
08D42:  MOVFF  00,636
08D46:  MOVLB  6
08D48:  DECFSZ x34,F
08D4A:  BRA    8C68
08D4C:  MOVLB  0
08D4E:  RETURN 0
*
099C0:  MOVF   FEF,F
099C2:  BZ    99E4
099C4:  MOVFF  FEA,5F4
099C8:  MOVFF  FE9,5F3
099CC:  MOVFF  FEF,63E
099D0:  CALL   51A0
099D4:  MOVFF  5F4,FEA
099D8:  MOVFF  5F3,FE9
099DC:  INCF   FE9,F
099DE:  BTFSC  FD8.2
099E0:  INCF   FEA,F
099E2:  BRA    99C0
099E4:  GOTO   9A62 (RETURN)
.................... 
.................... #list
.................... 
.................... 
.................... #device ADC=10
.................... 
.................... //!#FUSES WDT                      //Watch Dog Timer
.................... //!#FUSES WDT4096                  //Watch Dog Timer uses 1:4096 Postscale
.................... 
.................... #use delay(internal=64000000)
*
003F6:  MOVLW  05
003F8:  MOVWF  FEA
003FA:  MOVLW  F3
003FC:  MOVWF  FE9
003FE:  MOVF   FEF,W
00400:  BZ    041E
00402:  MOVLW  14
00404:  MOVWF  01
00406:  CLRF   00
00408:  DECFSZ 00,F
0040A:  BRA    0408
0040C:  DECFSZ 01,F
0040E:  BRA    0406
00410:  MOVLW  BF
00412:  MOVWF  00
00414:  DECFSZ 00,F
00416:  BRA    0414
00418:  BRA    041A
0041A:  DECFSZ FEF,F
0041C:  BRA    0402
0041E:  RETURN 0
*
006BE:  MOVLW  01
006C0:  MOVLB  5
006C2:  SUBWF  xF9,F
006C4:  BNC   06DE
006C6:  MOVLW  05
006C8:  MOVWF  FEA
006CA:  MOVLW  F9
006CC:  MOVWF  FE9
006CE:  MOVF   FEF,W
006D0:  BZ    06DE
006D2:  MOVLW  04
006D4:  MOVWF  00
006D6:  DECFSZ 00,F
006D8:  BRA    06D6
006DA:  DECFSZ FEF,F
006DC:  BRA    06D2
006DE:  MOVLB  0
006E0:  GOTO   0726 (RETURN)
.................... #define baudRate 128000
.................... #define numChannels 2
.................... 
.................... #define version  "20251104" // SW Version
.................... #define serialID "0000"     // Unique Serial ID
.................... #define magPP 1             // Magnetoresistive Sensor Pole Pitch in mm   
.................... #define gainLvl 16          // 1, 2, 4, 8, 16, 32, 64, 128
.................... 
.................... 
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
*
00360:  MOVLW  CF
00362:  MOVWF  F87
00364:  CLRF   F82
....................    output_b(portB_reset);
00366:  MOVLW  C4
00368:  MOVWF  F88
0036A:  CLRF   F83
....................    output_c(portC_reset);
0036C:  MOVLW  93
0036E:  MOVWF  F89
00370:  CLRF   F84
....................    output_d(portD_reset);
00372:  MOVLW  1F
00374:  MOVWF  F8A
00376:  CLRF   F85
....................    output_e(portE_reset);
00378:  BCF    F8B.0
0037A:  BCF    F8B.1
0037C:  BCF    F8B.2
0037E:  BCF    F8B.3
00380:  CLRF   F86
....................    
....................    port_a_pullups(portA_pullups);
00382:  MOVLB  F
00384:  SETF   x0B
....................    port_b_pullups(portB_pullups);
00386:  CLRF   x13
....................    port_c_pullups(portC_pullups);
00388:  CLRF   x1B
....................    port_d_pullups(portD_pullups);
0038A:  SETF   x20
....................    port_e_pullups(portE_pullups);
0038C:  CLRF   x28
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
0038E:  MOVLW  40
00390:  MOVWF  x0C
00392:  CLRF   x14
00394:  MOVLW  03
00396:  MOVWF  x1C
00398:  MOVLW  0F
0039A:  MOVWF  x21
0039C:  CLRF   x29
0039E:  MOVLB  0
003A0:  GOTO   9E78 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
*
05128:  MOVFF  630,FEA
0512C:  MOVLB  6
0512E:  MOVFF  62F,FE9
05132:  MOVFF  FEF,633
05136:  MOVFF  632,FEA
0513A:  MOVFF  631,FE9
0513E:  MOVF   FEF,W
05140:  SUBWF  x33,W
05142:  BNZ   5172
....................       if (*s1 == '\0')
05144:  MOVFF  630,03
05148:  MOVFF  62F,FE9
0514C:  MOVFF  03,FEA
05150:  MOVF   FEF,F
05152:  BNZ   515A
....................          return(0);
05154:  MOVLW  00
05156:  MOVWF  01
05158:  BRA    519C
0515A:  MOVFF  630,03
0515E:  MOVF   x2F,W
05160:  INCF   x2F,F
05162:  BTFSC  FD8.2
05164:  INCF   x30,F
05166:  INCF   x31,F
05168:  BTFSC  FD8.2
0516A:  INCF   x32,F
0516C:  MOVLB  0
0516E:  BRA    5128
05170:  MOVLB  6
....................    return((*s1 < *s2) ? -1: 1);
05172:  MOVFF  630,03
05176:  MOVFF  62F,FE9
0517A:  MOVFF  03,FEA
0517E:  MOVFF  FEF,633
05182:  MOVFF  632,03
05186:  MOVFF  631,FE9
0518A:  MOVFF  03,FEA
0518E:  MOVF   FEF,W
05190:  SUBWF  x33,W
05192:  BC    5198
05194:  MOVLW  FF
05196:  BRA    519A
05198:  MOVLW  01
0519A:  MOVWF  01
0519C:  MOVLB  0
0519E:  RETURN 0
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
*
052B8:  MOVFF  65D,660
....................    for(su=s;0<n;++su,--n)
052BC:  MOVFF  65C,662
052C0:  MOVFF  65B,661
052C4:  MOVLB  6
052C6:  MOVF   x5F,F
052C8:  BNZ   52D0
052CA:  MOVF   x5E,W
052CC:  SUBLW  00
052CE:  BC    52F8
....................       if(*su==uc)
052D0:  MOVFF  662,FEA
052D4:  MOVFF  661,FE9
052D8:  MOVF   x60,W
052DA:  SUBWF  FEF,W
052DC:  BNZ   52E8
....................       return su;
052DE:  MOVFF  661,01
052E2:  MOVFF  662,02
052E6:  BRA    52FE
052E8:  INCF   x61,F
052EA:  BTFSC  FD8.2
052EC:  INCF   x62,F
052EE:  MOVF   x5E,W
052F0:  BTFSC  FD8.2
052F2:  DECF   x5F,F
052F4:  DECF   x5E,F
052F6:  BRA    52C6
....................    return NULL;
052F8:  MOVLW  00
052FA:  MOVWF  01
052FC:  MOVWF  02
052FE:  MOVLB  0
05300:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
*
050F0:  MOVFF  630,632
050F4:  MOVFF  62F,631
050F8:  MOVFF  632,FEA
050FC:  MOVLB  6
050FE:  MOVFF  631,FE9
05102:  MOVF   FEF,F
05104:  BZ    5112
05106:  INCF   x31,F
05108:  BTFSC  FD8.2
0510A:  INCF   x32,F
0510C:  MOVLB  0
0510E:  BRA    50F8
05110:  MOVLB  6
....................    return(sc - s);
05112:  MOVF   x2F,W
05114:  SUBWF  x31,W
05116:  MOVWF  00
05118:  MOVF   x30,W
0511A:  SUBWFB x32,W
0511C:  MOVWF  03
0511E:  MOVFF  00,01
05122:  MOVWF  02
05124:  MOVLB  0
05126:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
*
06636:  MOVLB  6
06638:  CLRF   x09
0663A:  CLRF   x08
0663C:  CLRF   x07
0663E:  MOVLW  7F
06640:  MOVWF  x06
06642:  CLRF   x0D
06644:  CLRF   x0C
06646:  CLRF   x0B
06648:  CLRF   x0A
0664A:  BSF    x0E.0
0664C:  BCF    x0E.1
0664E:  BCF    x0E.2
06650:  CLRF   x10
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
06652:  MOVF   x02,W
06654:  IORWF  x03,W
06656:  BNZ   6662
....................       return 0;
06658:  CLRF   00
0665A:  CLRF   01
0665C:  CLRF   02
0665E:  CLRF   03
06660:  BRA    688C
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
06662:  MOVF   x10,W
06664:  INCF   x10,F
06666:  ADDWF  x02,W
06668:  MOVWF  FE9
0666A:  MOVLW  00
0666C:  ADDWFC x03,W
0666E:  MOVWF  FEA
06670:  MOVFF  FEF,60F
06674:  MOVF   x0F,F
06676:  BTFSC  FD8.2
06678:  BRA    6810
....................    {
....................       if (skip && !isspace(c))
0667A:  BTFSS  x0E.0
0667C:  BRA    669C
0667E:  MOVF   x0F,W
06680:  SUBLW  20
06682:  BZ    669C
....................       {
....................          skip = 0;
06684:  BCF    x0E.0
....................          if (c == '+')
06686:  MOVF   x0F,W
06688:  SUBLW  2B
0668A:  BNZ   6692
....................          {
....................             sign = 0;
0668C:  BCF    x0E.1
....................             continue;
0668E:  BRA    67F8
....................          }            
06690:  BRA    669C
....................          else if (c == '-')
06692:  MOVF   x0F,W
06694:  SUBLW  2D
06696:  BNZ   669C
....................          {
....................             sign = 1;
06698:  BSF    x0E.1
....................             continue;
0669A:  BRA    67F8
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
0669C:  BTFSC  x0E.0
0669E:  BRA    66AE
066A0:  MOVF   x0F,W
066A2:  SUBLW  2E
066A4:  BNZ   66AE
066A6:  BTFSC  x0E.2
066A8:  BRA    66AE
....................          point = 1;
066AA:  BSF    x0E.2
066AC:  BRA    67F8
....................       else if (!skip && isdigit(c))
066AE:  BTFSC  x0E.0
066B0:  BRA    67F2
066B2:  MOVF   x0F,W
066B4:  SUBLW  2F
066B6:  BTFSC  FD8.0
066B8:  BRA    67F2
066BA:  MOVF   x0F,W
066BC:  SUBLW  39
066BE:  BTFSS  FD8.0
066C0:  BRA    67F2
....................       {
....................          c -= '0';
066C2:  MOVLW  30
066C4:  SUBWF  x0F,F
....................          if (point)
066C6:  BTFSS  x0E.2
066C8:  BRA    6778
....................          {
....................             pow10 = pow10 * 10.0;
066CA:  MOVFF  609,64E
066CE:  MOVFF  608,64D
066D2:  MOVFF  607,64C
066D6:  MOVFF  606,64B
066DA:  CLRF   x52
066DC:  CLRF   x51
066DE:  MOVLW  20
066E0:  MOVWF  x50
066E2:  MOVLW  82
066E4:  MOVWF  x4F
066E6:  MOVLB  0
066E8:  CALL   0ABC
066EC:  MOVFF  03,609
066F0:  MOVFF  02,608
066F4:  MOVFF  01,607
066F8:  MOVFF  00,606
....................             result += (float)c / pow10;   
066FC:  MOVLB  6
066FE:  CLRF   x50
06700:  MOVFF  60F,64F
06704:  MOVLB  0
06706:  CALL   0A86
0670A:  MOVFF  03,614
0670E:  MOVFF  02,613
06712:  MOVFF  01,612
06716:  MOVFF  00,611
0671A:  MOVFF  03,647
0671E:  MOVFF  02,646
06722:  MOVFF  01,645
06726:  MOVFF  00,644
0672A:  MOVFF  609,64B
0672E:  MOVFF  608,64A
06732:  MOVFF  607,649
06736:  MOVFF  606,648
0673A:  CALL   14E6
0673E:  BCF    FD8.1
06740:  MOVFF  60D,652
06744:  MOVFF  60C,651
06748:  MOVFF  60B,650
0674C:  MOVFF  60A,64F
06750:  MOVFF  03,656
06754:  MOVFF  02,655
06758:  MOVFF  01,654
0675C:  MOVFF  00,653
06760:  CALL   0BB2
06764:  MOVFF  03,60D
06768:  MOVFF  02,60C
0676C:  MOVFF  01,60B
06770:  MOVFF  00,60A
....................          }
06774:  BRA    67EE
06776:  MOVLB  6
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
06778:  CLRF   x4E
0677A:  CLRF   x4D
0677C:  MOVLW  20
0677E:  MOVWF  x4C
06780:  MOVLW  82
06782:  MOVWF  x4B
06784:  MOVFF  60D,652
06788:  MOVFF  60C,651
0678C:  MOVFF  60B,650
06790:  MOVFF  60A,64F
06794:  MOVLB  0
06796:  CALL   0ABC
0679A:  MOVFF  03,614
0679E:  MOVFF  02,613
067A2:  MOVFF  01,612
067A6:  MOVFF  00,611
067AA:  MOVLB  6
067AC:  CLRF   x50
067AE:  MOVFF  60F,64F
067B2:  MOVLB  0
067B4:  CALL   0A86
067B8:  BCF    FD8.1
067BA:  MOVFF  614,652
067BE:  MOVFF  613,651
067C2:  MOVFF  612,650
067C6:  MOVFF  611,64F
067CA:  MOVFF  03,656
067CE:  MOVFF  02,655
067D2:  MOVFF  01,654
067D6:  MOVFF  00,653
067DA:  CALL   0BB2
067DE:  MOVFF  03,60D
067E2:  MOVFF  02,60C
067E6:  MOVFF  01,60B
067EA:  MOVFF  00,60A
....................          }
....................       }
067EE:  BRA    67FA
067F0:  MOVLB  6
....................       else if (!skip)
067F2:  BTFSC  x0E.0
067F4:  BRA    67F8
....................          break;
067F6:  BRA    6810
067F8:  MOVLB  0
067FA:  MOVLB  6
067FC:  MOVF   x10,W
067FE:  INCF   x10,F
06800:  ADDWF  x02,W
06802:  MOVWF  FE9
06804:  MOVLW  00
06806:  ADDWFC x03,W
06808:  MOVWF  FEA
0680A:  MOVFF  FEF,60F
0680E:  BRA    6674
....................    }
.................... 
....................    if (sign)
06810:  BTFSS  x0E.1
06812:  BRA    6848
....................       result = -1*result;
06814:  CLRF   x4E
06816:  CLRF   x4D
06818:  MOVLW  80
0681A:  MOVWF  x4C
0681C:  MOVLW  7F
0681E:  MOVWF  x4B
06820:  MOVFF  60D,652
06824:  MOVFF  60C,651
06828:  MOVFF  60B,650
0682C:  MOVFF  60A,64F
06830:  MOVLB  0
06832:  CALL   0ABC
06836:  MOVFF  03,60D
0683A:  MOVFF  02,60C
0683E:  MOVFF  01,60B
06842:  MOVFF  00,60A
06846:  MOVLB  6
....................       
....................    if(endptr)
06848:  MOVF   x04,W
0684A:  IORWF  x05,W
0684C:  BZ    687C
....................    {
....................       if (ptr) {
0684E:  MOVF   x10,F
06850:  BZ    686A
....................          ptr--;
06852:  DECF   x10,F
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
06854:  MOVFF  605,FEA
06858:  MOVFF  604,FE9
0685C:  MOVF   x10,W
0685E:  ADDWF  x02,W
06860:  MOVWF  FEF
06862:  MOVLW  00
06864:  ADDWFC x03,W
06866:  MOVWF  FEC
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
06868:  BRA    687C
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
0686A:  MOVFF  605,FEA
0686E:  MOVFF  604,FE9
06872:  MOVFF  603,FEC
06876:  MOVF   FED,F
06878:  MOVFF  602,FEF
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
0687C:  MOVFF  60A,00
06880:  MOVFF  60B,01
06884:  MOVFF  60C,02
06888:  MOVFF  60D,03
0688C:  MOVLB  0
0688E:  RETURN 0
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
*
05358:  MOVLB  6
0535A:  CLRF   x34
0535C:  CLRF   x33
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
0535E:  MOVLW  30
05360:  MOVWF  x36
05362:  MOVLW  31
05364:  MOVWF  x37
05366:  MOVLW  32
05368:  MOVWF  x38
0536A:  MOVLW  33
0536C:  MOVWF  x39
0536E:  MOVLW  34
05370:  MOVWF  x3A
05372:  MOVLW  35
05374:  MOVWF  x3B
05376:  MOVLW  36
05378:  MOVWF  x3C
0537A:  MOVLW  37
0537C:  MOVWF  x3D
0537E:  MOVLW  38
05380:  MOVWF  x3E
05382:  MOVLW  39
05384:  MOVWF  x3F
05386:  MOVLW  61
05388:  MOVWF  x40
0538A:  MOVLW  62
0538C:  MOVWF  x41
0538E:  MOVLW  63
05390:  MOVWF  x42
05392:  MOVLW  64
05394:  MOVWF  x43
05396:  MOVLW  65
05398:  MOVWF  x44
0539A:  MOVLW  66
0539C:  MOVWF  x45
0539E:  MOVLW  67
053A0:  MOVWF  x46
053A2:  MOVLW  68
053A4:  MOVWF  x47
053A6:  MOVLW  69
053A8:  MOVWF  x48
053AA:  MOVLW  6A
053AC:  MOVWF  x49
053AE:  MOVLW  6B
053B0:  MOVWF  x4A
053B2:  MOVLW  6C
053B4:  MOVWF  x4B
053B6:  MOVLW  6D
053B8:  MOVWF  x4C
053BA:  MOVLW  6E
053BC:  MOVWF  x4D
053BE:  MOVLW  6F
053C0:  MOVWF  x4E
053C2:  MOVLW  70
053C4:  MOVWF  x4F
053C6:  MOVLW  71
053C8:  MOVWF  x50
053CA:  MOVLW  73
053CC:  MOVWF  x51
053CE:  MOVLW  74
053D0:  MOVWF  x52
053D2:  MOVLW  75
053D4:  MOVWF  x53
053D6:  MOVLW  76
053D8:  MOVWF  x54
053DA:  MOVLW  77
053DC:  MOVWF  x55
053DE:  MOVLW  78
053E0:  MOVWF  x56
053E2:  MOVLW  79
053E4:  MOVWF  x57
053E6:  MOVLW  7A
053E8:  MOVWF  x58
053EA:  CLRF   x59
....................    for(sc=s;isspace(*sc);++sc);
053EC:  MOVFF  629,62E
053F0:  MOVFF  628,62D
053F4:  MOVFF  62E,FEA
053F8:  MOVFF  62D,FE9
053FC:  MOVF   FEF,W
053FE:  SUBLW  20
05400:  BNZ   540A
05402:  INCF   x2D,F
05404:  BTFSC  FD8.2
05406:  INCF   x2E,F
05408:  BRA    53F4
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
0540A:  MOVFF  62E,03
0540E:  MOVFF  62D,FE9
05412:  MOVFF  03,FEA
05416:  MOVF   FEF,W
05418:  SUBLW  2D
0541A:  BZ    542A
0541C:  MOVFF  62E,FEA
05420:  MOVFF  62D,FE9
05424:  MOVF   FEF,W
05426:  SUBLW  2B
05428:  BNZ   543C
0542A:  MOVFF  62E,FEA
0542E:  MOVF   x2D,W
05430:  INCF   x2D,F
05432:  BTFSC  FD8.2
05434:  INCF   x2E,F
05436:  MOVWF  FE9
05438:  MOVF   FEF,W
0543A:  BRA    543E
0543C:  MOVLW  2B
0543E:  MOVWF  x35
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
05440:  MOVF   x35,W
05442:  SUBLW  2D
05444:  BZ    545A
05446:  BTFSC  x2C.7
05448:  BRA    545A
0544A:  DECFSZ x2C,W
0544C:  BRA    5450
0544E:  BRA    545A
05450:  BTFSC  x2C.7
05452:  BRA    545E
05454:  MOVF   x2C,W
05456:  SUBLW  24
05458:  BC    545E
....................    goto StrtoulGO;
0545A:  BRA    5666
0545C:  BRA    5556
.................... 
....................    else if (base)
0545E:  MOVF   x2C,F
05460:  BZ    54EE
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
05462:  MOVF   x2C,W
05464:  SUBLW  10
05466:  BNZ   54A2
05468:  MOVFF  62E,FEA
0546C:  MOVFF  62D,FE9
05470:  MOVF   FEF,W
05472:  SUBLW  30
05474:  BNZ   54A2
05476:  MOVLW  01
05478:  ADDWF  x2D,W
0547A:  MOVWF  FE9
0547C:  MOVLW  00
0547E:  ADDWFC x2E,W
05480:  MOVWF  FEA
05482:  MOVF   FEF,W
05484:  SUBLW  78
05486:  BZ    549A
05488:  MOVLW  01
0548A:  ADDWF  x2D,W
0548C:  MOVWF  FE9
0548E:  MOVLW  00
05490:  ADDWFC x2E,W
05492:  MOVWF  FEA
05494:  MOVF   FEF,W
05496:  SUBLW  58
05498:  BNZ   54A2
....................          sc+=2;
0549A:  MOVLW  02
0549C:  ADDWF  x2D,F
0549E:  MOVLW  00
054A0:  ADDWFC x2E,F
....................       if(base==8 && *sc =='0')
054A2:  MOVF   x2C,W
054A4:  SUBLW  08
054A6:  BNZ   54BE
054A8:  MOVFF  62E,FEA
054AC:  MOVFF  62D,FE9
054B0:  MOVF   FEF,W
054B2:  SUBLW  30
054B4:  BNZ   54BE
....................          sc+=1;
054B6:  MOVLW  01
054B8:  ADDWF  x2D,F
054BA:  MOVLW  00
054BC:  ADDWFC x2E,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
054BE:  MOVF   x2C,W
054C0:  SUBLW  02
054C2:  BNZ   54EC
054C4:  MOVFF  62E,FEA
054C8:  MOVFF  62D,FE9
054CC:  MOVF   FEF,W
054CE:  SUBLW  30
054D0:  BNZ   54EC
054D2:  MOVLW  01
054D4:  ADDWF  x2D,W
054D6:  MOVWF  FE9
054D8:  MOVLW  00
054DA:  ADDWFC x2E,W
054DC:  MOVWF  FEA
054DE:  MOVF   FEF,W
054E0:  SUBLW  62
054E2:  BNZ   54EC
....................          sc+=2;
054E4:  MOVLW  02
054E6:  ADDWF  x2D,F
054E8:  MOVLW  00
054EA:  ADDWFC x2E,F
.................... 
....................    }
054EC:  BRA    5556
....................    else if(*sc!='0') // base is 0, find base
054EE:  MOVFF  62E,FEA
054F2:  MOVFF  62D,FE9
054F6:  MOVF   FEF,W
054F8:  SUBLW  30
054FA:  BZ    5502
....................       base=10;
054FC:  MOVLW  0A
054FE:  MOVWF  x2C
05500:  BRA    5556
....................    else if (sc[1]=='x' || sc[1]=='X')
05502:  MOVLW  01
05504:  ADDWF  x2D,W
05506:  MOVWF  FE9
05508:  MOVLW  00
0550A:  ADDWFC x2E,W
0550C:  MOVWF  FEA
0550E:  MOVF   FEF,W
05510:  SUBLW  78
05512:  BZ    5526
05514:  MOVLW  01
05516:  ADDWF  x2D,W
05518:  MOVWF  FE9
0551A:  MOVLW  00
0551C:  ADDWFC x2E,W
0551E:  MOVWF  FEA
05520:  MOVF   FEF,W
05522:  SUBLW  58
05524:  BNZ   5534
....................       base =16,sc+=2;
05526:  MOVLW  10
05528:  MOVWF  x2C
0552A:  MOVLW  02
0552C:  ADDWF  x2D,F
0552E:  MOVLW  00
05530:  ADDWFC x2E,F
05532:  BRA    5556
....................    else if(sc[1]=='b')
05534:  MOVLW  01
05536:  ADDWF  x2D,W
05538:  MOVWF  FE9
0553A:  MOVLW  00
0553C:  ADDWFC x2E,W
0553E:  MOVWF  FEA
05540:  MOVF   FEF,W
05542:  SUBLW  62
05544:  BNZ   5552
....................       base=2,sc+=2;
05546:  MOVLW  02
05548:  MOVWF  x2C
0554A:  ADDWF  x2D,F
0554C:  MOVLW  00
0554E:  ADDWFC x2E,F
05550:  BRA    5556
....................    else
....................       base=8;
05552:  MOVLW  08
05554:  MOVWF  x2C
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
05556:  MOVFF  62E,630
0555A:  MOVFF  62D,62F
0555E:  MOVFF  62E,FEA
05562:  MOVFF  62D,FE9
05566:  MOVF   FEF,W
05568:  SUBLW  30
0556A:  BNZ   5574
0556C:  INCF   x2D,F
0556E:  BTFSC  FD8.2
05570:  INCF   x2E,F
05572:  BRA    555E
....................    sd=memchr(digits,tolower(*sc),base);
05574:  MOVFF  62E,03
05578:  MOVFF  62D,FE9
0557C:  MOVFF  03,FEA
05580:  MOVFF  FEF,65A
05584:  MOVF   x5A,W
05586:  SUBLW  40
05588:  BC    5596
0558A:  MOVF   x5A,W
0558C:  SUBLW  5A
0558E:  BNC   5596
05590:  MOVF   x5A,W
05592:  IORLW  20
05594:  BRA    5598
05596:  MOVF   x5A,W
05598:  MOVWF  x5A
0559A:  MOVLW  06
0559C:  MOVWF  x5C
0559E:  MOVLW  36
055A0:  MOVWF  x5B
055A2:  MOVFF  65A,65D
055A6:  CLRF   x5F
055A8:  MOVFF  62C,65E
055AC:  BTFSC  x5E.7
055AE:  DECF   x5F,F
055B0:  MOVLB  0
055B2:  RCALL  52B8
055B4:  MOVFF  02,632
055B8:  MOVFF  01,631
....................    for(; sd!=0; )
055BC:  MOVLB  6
055BE:  MOVF   x31,F
055C0:  BNZ   55C6
055C2:  MOVF   x32,F
055C4:  BZ    565A
....................    {
....................       x=x*base+(int16)(sd-digits);
055C6:  CLRF   03
055C8:  MOVF   x2C,W
055CA:  MOVWF  00
055CC:  BTFSC  FE8.7
055CE:  DECF   03,F
055D0:  MOVWF  x5A
055D2:  MOVFF  03,65B
055D6:  MOVFF  634,65D
055DA:  MOVFF  633,65C
055DE:  MOVFF  03,65F
055E2:  MOVWF  x5E
055E4:  MOVLB  0
055E6:  BRA    5302
055E8:  MOVFF  01,65A
055EC:  MOVLW  36
055EE:  MOVLB  6
055F0:  SUBWF  x31,W
055F2:  MOVWF  00
055F4:  MOVLW  06
055F6:  SUBWFB x32,W
055F8:  MOVWF  03
055FA:  MOVF   00,W
055FC:  ADDWF  01,W
055FE:  MOVWF  01
05600:  MOVF   02,W
05602:  ADDWFC 03,F
05604:  MOVFF  01,633
05608:  MOVFF  03,634
....................       ++sc;
0560C:  INCF   x2D,F
0560E:  BTFSC  FD8.2
05610:  INCF   x2E,F
....................       sd=memchr(digits,tolower(*sc),base);
05612:  MOVFF  62E,FEA
05616:  MOVFF  62D,FE9
0561A:  MOVFF  FEF,65A
0561E:  MOVF   x5A,W
05620:  SUBLW  40
05622:  BC    5630
05624:  MOVF   x5A,W
05626:  SUBLW  5A
05628:  BNC   5630
0562A:  MOVF   x5A,W
0562C:  IORLW  20
0562E:  BRA    5632
05630:  MOVF   x5A,W
05632:  MOVWF  x5A
05634:  MOVLW  06
05636:  MOVWF  x5C
05638:  MOVLW  36
0563A:  MOVWF  x5B
0563C:  MOVFF  65A,65D
05640:  CLRF   x5F
05642:  MOVFF  62C,65E
05646:  BTFSC  x5E.7
05648:  DECF   x5F,F
0564A:  MOVLB  0
0564C:  RCALL  52B8
0564E:  MOVFF  02,632
05652:  MOVFF  01,631
05656:  BRA    55BC
05658:  MOVLB  6
....................    }
....................    if(s1==sc)
0565A:  MOVF   x2D,W
0565C:  SUBWF  x2F,W
0565E:  BNZ   5688
05660:  MOVF   x2E,W
05662:  SUBWF  x30,W
05664:  BNZ   5688
....................    {
....................    StrtoulGO:
....................       if (endptr)
05666:  MOVLB  6
05668:  MOVF   x2A,W
0566A:  IORWF  x2B,W
0566C:  BZ    5680
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
0566E:  MOVFF  62B,FEA
05672:  MOVFF  62A,FE9
05676:  MOVFF  629,FEC
0567A:  MOVF   FED,F
0567C:  MOVFF  628,FEF
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
05680:  MOVLW  00
05682:  MOVWF  01
05684:  MOVWF  02
05686:  BRA    56A8
....................    }
....................    if (endptr)
05688:  MOVF   x2A,W
0568A:  IORWF  x2B,W
0568C:  BZ    56A0
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
0568E:  MOVFF  62B,FEA
05692:  MOVFF  62A,FE9
05696:  MOVFF  62E,FEC
0569A:  MOVF   FED,F
0569C:  MOVFF  62D,FEF
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
056A0:  MOVFF  633,01
056A4:  MOVFF  634,02
056A8:  MOVLB  0
056AA:  RETURN 0
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0.3,0.1,0,0,0,0,0},
....................    {0.01,0.3,0.1,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;           // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... unsigned int16 dacVals[2] = {0,0};
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
*
00420:  MOVLB  5
00422:  CLRF   xF3
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
00424:  CLRF   xF3
00426:  MOVF   xF2,W
00428:  SUBWF  xF3,W
0042A:  BC    0482
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
0042C:  MOVF   xF3,W
0042E:  ADDWF  xF0,W
00430:  MOVWF  xF4
00432:  MOVLW  00
00434:  ADDWFC xF1,W
00436:  MOVWF  xF5
00438:  MOVF   xF3,W
0043A:  ADDWF  xEE,W
0043C:  MOVWF  01
0043E:  MOVLW  00
00440:  ADDWFC xEF,W
00442:  MOVWF  03
00444:  MOVF   01,W
00446:  MOVWF  FE9
00448:  MOVFF  03,FEA
0044C:  MOVFF  FEF,5F6
00450:  BSF    F7F.7
00452:  MOVF   FF2,W
00454:  MOVWF  00
00456:  BCF    FF2.7
00458:  MOVFF  5F5,F7A
0045C:  MOVFF  5F4,F79
00460:  MOVLW  31
00462:  MOVWF  F7B
00464:  MOVFF  5F6,F7C
00468:  MOVLB  F
0046A:  MOVLW  55
0046C:  MOVWF  F81
0046E:  MOVLW  AA
00470:  MOVWF  F81
00472:  BSF    F80.4
00474:  BTFSC  F80.4
00476:  BRA    0474
00478:  MOVF   00,W
0047A:  IORWF  FF2,F
0047C:  MOVLB  5
0047E:  INCF   xF3,F
00480:  BRA    0426
....................    }
00482:  MOVLB  0
00484:  RETURN 0
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
*
003A4:  MOVLB  5
003A6:  CLRF   xF3
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
003A8:  CLRF   xF3
003AA:  MOVF   xF2,W
003AC:  SUBWF  xF3,W
003AE:  BC    03F2
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
003B0:  MOVF   xF3,W
003B2:  ADDWF  xEE,W
003B4:  MOVWF  01
003B6:  MOVLW  00
003B8:  ADDWFC xEF,W
003BA:  MOVWF  03
003BC:  MOVF   01,W
003BE:  MOVWF  FE9
003C0:  MOVFF  03,FEA
003C4:  MOVF   xF3,W
003C6:  ADDWF  xF0,W
003C8:  MOVWF  xF6
003CA:  MOVLW  00
003CC:  ADDWFC xF1,W
003CE:  MOVWF  xF7
003D0:  BSF    F7F.7
003D2:  MOVFF  FF2,5F8
003D6:  BCF    FF2.7
003D8:  MOVFF  5F7,F7A
003DC:  MOVFF  5F6,F79
003E0:  MOVLW  31
003E2:  MOVWF  F7B
003E4:  BSF    F80.0
003E6:  MOVF   F7C,W
003E8:  BTFSC  xF8.7
003EA:  BSF    FF2.7
003EC:  MOVWF  FEF
003EE:  INCF   xF3,F
003F0:  BRA    03AA
....................    }
003F2:  MOVLB  0
003F4:  RETURN 0
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
*
00486:  MOVLB  5
00488:  CLRF   xEF
0048A:  MOVLW  20
0048C:  MOVWF  xEE
0048E:  CLRF   xF1
00490:  CLRF   xF0
00492:  MOVLW  80
00494:  MOVWF  xF2
00496:  MOVLB  0
00498:  RCALL  0420
....................    delay_ms(1);
0049A:  MOVLW  01
0049C:  MOVLB  5
0049E:  MOVWF  xF3
004A0:  MOVLB  0
004A2:  RCALL  03F6
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
004A4:  MOVLB  5
004A6:  CLRF   xEF
004A8:  MOVLW  60
004AA:  MOVWF  xEE
004AC:  CLRF   xF1
004AE:  MOVLW  80
004B0:  MOVWF  xF0
004B2:  MOVLW  02
004B4:  MOVWF  xF2
004B6:  MOVLB  0
004B8:  RCALL  0420
....................    delay_ms(1);
004BA:  MOVLW  01
004BC:  MOVLB  5
004BE:  MOVWF  xF3
004C0:  MOVLB  0
004C2:  RCALL  03F6
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
004C4:  MOVLB  5
004C6:  CLRF   xEF
004C8:  MOVLW  61
004CA:  MOVWF  xEE
004CC:  CLRF   xF1
004CE:  MOVLW  90
004D0:  MOVWF  xF0
004D2:  MOVLW  02
004D4:  MOVWF  xF2
004D6:  MOVLB  0
004D8:  RCALL  0420
....................    delay_ms(1);
004DA:  MOVLW  01
004DC:  MOVLB  5
004DE:  MOVWF  xF3
004E0:  MOVLB  0
004E2:  RCALL  03F6
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
004E4:  MOVLB  5
004E6:  CLRF   xEF
004E8:  MOVLW  62
004EA:  MOVWF  xEE
004EC:  CLRF   xF1
004EE:  MOVLW  A0
004F0:  MOVWF  xF0
004F2:  MOVLW  20
004F4:  MOVWF  xF2
004F6:  MOVLB  0
004F8:  RCALL  0420
....................    delay_ms(1);
004FA:  MOVLW  01
004FC:  MOVLB  5
004FE:  MOVWF  xF3
00500:  MOVLB  0
00502:  RCALL  03F6
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
00504:  MOVLB  5
00506:  CLRF   xEF
00508:  MOVLW  82
0050A:  MOVWF  xEE
0050C:  CLRF   xF1
0050E:  MOVLW  C0
00510:  MOVWF  xF0
00512:  MOVLW  30
00514:  MOVWF  xF2
00516:  MOVLB  0
00518:  RCALL  0420
....................    delay_ms(1);
0051A:  MOVLW  01
0051C:  MOVLB  5
0051E:  MOVWF  xF3
00520:  MOVLB  0
00522:  RCALL  03F6
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
00524:  MOVLB  5
00526:  CLRF   xEF
00528:  MOVLW  B2
0052A:  MOVWF  xEE
0052C:  CLRF   xF1
0052E:  MOVLW  F0
00530:  MOVWF  xF0
00532:  MOVLW  38
00534:  MOVWF  xF2
00536:  MOVLB  0
00538:  RCALL  0420
....................    delay_ms(1);
0053A:  MOVLW  01
0053C:  MOVLB  5
0053E:  MOVWF  xF3
00540:  MOVLB  0
00542:  RCALL  03F6
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
00544:  MOVLB  5
00546:  CLRF   xEF
00548:  MOVLW  F2
0054A:  MOVWF  xEE
0054C:  MOVLW  01
0054E:  MOVWF  xF1
00550:  MOVLW  40
00552:  MOVWF  xF0
00554:  MOVLW  01
00556:  MOVWF  xF2
00558:  MOVLB  0
0055A:  RCALL  0420
....................    delay_ms(1);
0055C:  MOVLW  01
0055E:  MOVLB  5
00560:  MOVWF  xF3
00562:  MOVLB  0
00564:  RCALL  03F6
00566:  GOTO   0636 (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
0056A:  MOVLB  5
0056C:  CLRF   xEF
0056E:  MOVLW  20
00570:  MOVWF  xEE
00572:  CLRF   xF1
00574:  CLRF   xF0
00576:  MOVLW  80
00578:  MOVWF  xF2
0057A:  MOVLB  0
0057C:  RCALL  03A4
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
0057E:  MOVLB  5
00580:  CLRF   xEF
00582:  MOVLW  60
00584:  MOVWF  xEE
00586:  CLRF   xF1
00588:  MOVLW  80
0058A:  MOVWF  xF0
0058C:  MOVLW  02
0058E:  MOVWF  xF2
00590:  MOVLB  0
00592:  RCALL  03A4
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
00594:  MOVLB  5
00596:  CLRF   xEF
00598:  MOVLW  61
0059A:  MOVWF  xEE
0059C:  CLRF   xF1
0059E:  MOVLW  90
005A0:  MOVWF  xF0
005A2:  MOVLW  02
005A4:  MOVWF  xF2
005A6:  MOVLB  0
005A8:  RCALL  03A4
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
005AA:  MOVLB  5
005AC:  CLRF   xEF
005AE:  MOVLW  62
005B0:  MOVWF  xEE
005B2:  CLRF   xF1
005B4:  MOVLW  A0
005B6:  MOVWF  xF0
005B8:  MOVLW  20
005BA:  MOVWF  xF2
005BC:  MOVLB  0
005BE:  RCALL  03A4
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
005C0:  MOVLB  5
005C2:  CLRF   xEF
005C4:  MOVLW  82
005C6:  MOVWF  xEE
005C8:  CLRF   xF1
005CA:  MOVLW  C0
005CC:  MOVWF  xF0
005CE:  MOVLW  30
005D0:  MOVWF  xF2
005D2:  MOVLB  0
005D4:  RCALL  03A4
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
005D6:  MOVLB  5
005D8:  CLRF   xEF
005DA:  MOVLW  B2
005DC:  MOVWF  xEE
005DE:  CLRF   xF1
005E0:  MOVLW  F0
005E2:  MOVWF  xF0
005E4:  MOVLW  38
005E6:  MOVWF  xF2
005E8:  MOVLB  0
005EA:  RCALL  03A4
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
005EC:  MOVLB  5
005EE:  CLRF   xEF
005F0:  MOVLW  F2
005F2:  MOVWF  xEE
005F4:  MOVLW  01
005F6:  MOVWF  xF1
005F8:  MOVLW  40
005FA:  MOVWF  xF0
005FC:  MOVLW  01
005FE:  MOVWF  xF2
00600:  MOVLB  0
00602:  RCALL  03A4
00604:  GOTO   063A (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
00608:  MOVLB  5
0060A:  CLRF   xEF
0060C:  MOVLW  F2
0060E:  MOVWF  xEE
00610:  MOVLW  01
00612:  MOVWF  xF1
00614:  MOVLW  40
00616:  MOVWF  xF0
00618:  MOVLW  01
0061A:  MOVWF  xF2
0061C:  MOVLB  0
0061E:  RCALL  03A4
....................    delay_ms(1);
00620:  MOVLW  01
00622:  MOVLB  5
00624:  MOVWF  xF3
00626:  MOVLB  0
00628:  RCALL  03F6
....................    if (paramsValid != isValid)
0062A:  MOVF   xF2,W
0062C:  SUBLW  AA
0062E:  BZ    0638
....................    {
....................       paramsValid = isValid;
00630:  MOVLW  AA
00632:  MOVWF  xF2
....................       params_save_to_ee(); // saves the base parameters on first boot
00634:  BRA    0486
....................    }
00636:  BRA    063A
....................    else
....................    {
....................       params_load_from_ee();
00638:  BRA    056A
....................    }
0063A:  GOTO   9E7C (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <monitor.h>
.................... #ifndef monitor
.................... #define monitor
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
....................    output_b(portB_reset);
....................    output_c(portC_reset);
....................    output_d(portD_reset);
....................    output_e(portE_reset);
....................    
....................    port_a_pullups(portA_pullups);
....................    port_b_pullups(portB_pullups);
....................    port_c_pullups(portC_pullups);
....................    port_d_pullups(portD_pullups);
....................    port_e_pullups(portE_pullups);
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0.3,0.1,0,0,0,0,0},
....................    {0.01,0.3,0.1,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;           // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... unsigned int16 dacVals[2] = {0,0};
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <ADS1220.h>
.................... #ifndef ADS1220
.................... #define ADS1220
.................... 
.................... /*****************************************************************************/
.................... /* SET UP PORTS FOR USE WITH DRIVER                                          */
.................... /*****************************************************************************/
.................... #define _CS0  PIN_D5 // chip select pins 
.................... #define _CS1  PIN_D6
.................... #define _CS2  PIN_D7
.................... #define _CS3  PIN_B0
.................... 
.................... #pin_select SCK2=PIN_B1
.................... #pin_select SDI2=PIN_B2
.................... #pin_select SDO2=PIN_B3
.................... #use spi(MASTER, SPI2, BAUD=1000000, MODE=1, STREAM=SPI_mon)
.................... //!setup_spi2(SPI_MASTER | SPI_SCK_IDLE_LOW | SPI_XMIT_H_TO_L | SPI_CLK_DIV_64);
.................... 
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* REGISTER DEFINITIONS                                                      */
.................... /*****************************************************************************/
.................... typedef enum {reg0 = 0x00,reg1 = 0x04 ,reg2 = 0x08, reg3 = 0x0C}adsReg;
.................... 
.................... //REGISTER 0 OPTIONS
.................... 
.................... #define IPp0n1 0x00
.................... #define IPp0n2 0x10
.................... #define IPp0n3 0x20
.................... #define IPp1n2 0x30
.................... #define IPp1n3 0x40
.................... #define IPp2n3 0x50
.................... #define IPp1n0 0x60
.................... #define IPp3n2 0x70
.................... #define IPp0nVss 0x80
.................... #define IPp1nVss 0x90
.................... #define IPp2nVss 0xA0
.................... #define IPp3nVss 0xB0
.................... #define IPVrpVrn 0xC0
.................... #define IPVddVss 0xD0
.................... #define IPhalfRail 0xE0
.................... 
.................... #define g1 0x00
.................... #define g2 0x02
.................... #define g4 0x04
.................... #define g8 0x06
.................... #define g16 0x08
.................... #define g32 0x0A
.................... #define g64 0x0C
.................... #define g128 0x0E
.................... 
.................... #define PGAenabled 0x00
.................... #define PGAbypass 0x01
.................... 
.................... //REGISTER 1 OPTIONS
.................... 
.................... #define DRn20 0x00
.................... #define DRn45 0x20
.................... #define DRn90 0x40
.................... #define DRn175 0x60
.................... #define DRn330 0x80
.................... #define DRn600 0xA0
.................... #define DRn1000 0xC0
.................... 
.................... #define MDnormal 0x00
.................... #define MDduty 0x80
.................... #define MDturbo 0x10
.................... 
.................... #define CMsingle 0x00
.................... #define CMcont 0x40
.................... 
.................... #define TSdisable 0x00
.................... #define TSenable 0x20
.................... 
.................... #define BCSoff 0x00
.................... #define BCSon 0x01
.................... 
.................... //REGISTER 2 OPTIONS
.................... 
.................... #define REFinternal 0x00
.................... #define REFp0n0 0x40
.................... #define REFp1n1 0x80
.................... #define REFVddVss 0xC0
.................... 
.................... #define FIRoff 0x00
.................... #define FIR5060 0x10
.................... #define FIR50 0x20
.................... #define FIR60 0x30
.................... 
.................... #define PSWopen 0x00
.................... #define PSWstart 0x08
.................... 
.................... #define Ioff 0x00
.................... #define Iu10 0x01
.................... #define Iu50 0x02
.................... #define Iu100 0x03
.................... #define Iu250 0x04
.................... #define Iu500 0x05
.................... #define Iu1000 0x06
.................... #define Iu1500 0x07  
.................... 
.................... //REGISTER 3 OPTIONS
.................... 
.................... #define I1disabled 0x00
.................... #define I1a0p1 0x20
.................... #define I1a1 0x40
.................... #define I1a2 0x60
.................... #define I1a3n1 0x80
.................... #define I1p0 0xA0
.................... #define I1n0 0xC0
.................... 
.................... #define I2disabled 0x00
.................... #define I2a0p1 0x04
.................... #define I2a1 0x08
.................... #define I2a2 0x0A
.................... #define I2a3n1 0x10
.................... #define I2p0 0x14
.................... #define I2n0 0x18
.................... 
.................... #define drdyPin 0x00
.................... #define doutPin 0x20
.................... 
.................... // REGISTER CONGIGURATIONS FOR THIS APP
.................... #define reg0config IPp1n2|g1|PGAenabled // 0x30//
.................... #define reg1config DRn20|MDturbo|CMsingle|TSDisable|BCSoff //0x10
.................... #define reg2config REFinternal|FIR60|PSWopen|Ioff //0x30
.................... #define reg3config I1disabled|I2disabled|drdyPin //0x00
.................... 
.................... //COMMANDS
.................... #define ADSreset 0x06
.................... #define ADSstart 0x08
.................... #define ADSpowerDn 0x02
.................... #define ADSreadData 0x10
.................... #define ADSreadReg 0x20
.................... #define ADSwriteReg 0x40
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* DESELECT ALL ADCs                                                         */
.................... /*****************************************************************************/
.................... void ads_deselect_all()
.................... {   
....................    output_high(_CS0); // deselect all chip select pins
*
00136:  MOVLW  1F
00138:  MOVWF  F8A
0013A:  BSF    F85.5
....................    output_high(_CS1);
0013C:  MOVWF  F8A
0013E:  BSF    F85.6
....................    output_high(_CS2);
00140:  MOVWF  F8A
00142:  BSF    F85.7
....................    output_high(_CS3); 
00144:  MOVLW  C4
00146:  MOVWF  F88
00148:  BSF    F83.0
....................    delay_us(10);
0014A:  MOVLW  35
0014C:  MOVWF  00
0014E:  DECFSZ 00,F
00150:  BRA    014E
00152:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT DESIRED ADC                                                        */
.................... /*****************************************************************************/
.................... void ads_select_ch(int8 ch)
.................... {
....................    ads_deselect_all();
*
0063E:  RCALL  0136
....................    switch(ch)
00640:  MOVLB  5
00642:  MOVF   xFE,W
00644:  ADDLW  FC
00646:  BC    067A
00648:  ADDLW  04
0064A:  MOVLB  0
0064C:  GOTO   0686
....................    {
....................       case 0:
....................          output_low(_CS0);
00650:  MOVLW  1F
00652:  MOVWF  F8A
00654:  BCF    F85.5
....................       break; 
00656:  MOVLB  5
00658:  BRA    067A
....................       case 1:
....................          output_low(_CS1);
0065A:  MOVLW  1F
0065C:  MOVWF  F8A
0065E:  BCF    F85.6
....................       break;   
00660:  MOVLB  5
00662:  BRA    067A
....................       case 2:
....................          output_low(_CS2);
00664:  MOVLW  1F
00666:  MOVWF  F8A
00668:  BCF    F85.7
....................       break;
0066A:  MOVLB  5
0066C:  BRA    067A
....................       case 3:
....................          output_low(_CS3);
0066E:  MOVLW  C4
00670:  MOVWF  F88
00672:  BCF    F83.0
....................       break;              
00674:  MOVLB  5
00676:  BRA    067A
00678:  MOVLB  5
....................    }
....................    delay_us(10);
0067A:  MOVLW  35
0067C:  MOVWF  00
0067E:  DECFSZ 00,F
00680:  BRA    067E
00682:  MOVLB  0
00684:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT ADC BLOCK (2 ADCs/BLOCK)                                           */
.................... /*****************************************************************************/
.................... void ads_select_block(int8 block)
.................... {
....................    ads_deselect_all();
*
00154:  RCALL  0136
....................    switch(block)
00156:  MOVLB  6
00158:  MOVF   x67,W
0015A:  XORLW  00
0015C:  MOVLB  0
0015E:  BZ    0166
00160:  XORLW  01
00162:  BZ    0172
00164:  BRA    017E
....................    {
....................       case 0:
....................          output_low(_CS0);
00166:  MOVLW  1F
00168:  MOVWF  F8A
0016A:  BCF    F85.5
....................          output_low(_CS1);
0016C:  MOVWF  F8A
0016E:  BCF    F85.6
....................       break; 
00170:  BRA    017E
....................       case 1:         
....................          output_low(_CS2);
00172:  MOVLW  1F
00174:  MOVWF  F8A
00176:  BCF    F85.7
....................          output_low(_CS3);
00178:  MOVLW  C4
0017A:  MOVWF  F88
0017C:  BCF    F83.0
....................       break;         
....................    }
....................    delay_us(10);
0017E:  MOVLW  35
00180:  MOVWF  00
00182:  DECFSZ 00,F
00184:  BRA    0182
00186:  GOTO   0190 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO AN ADC                                          */
.................... /*****************************************************************************/
.................... void ads_write_command(int8 ch, unsigned int8 command)
.................... {
....................    ads_select_ch(ch);
*
006A8:  MOVFF  5FC,5FE
006AC:  RCALL  063E
....................    spi_write2(command);
006AE:  MOVLB  E
006B0:  MOVF   x8D,W
006B2:  MOVFF  5FD,E8D
006B6:  RRCF   x90,W
006B8:  BNC   06B6
006BA:  MOVLB  0
006BC:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO A BLOCK OF ADCs                                 */
.................... /*****************************************************************************/
.................... void ads_write_command_block(int8 block, unsigned int8 command)
.................... {
....................    ads_select_block(block);
*
0018A:  MOVFF  665,667
0018E:  BRA    0154
....................    spi_write2(command);
00190:  MOVLB  E
00192:  MOVF   x8D,W
00194:  MOVFF  666,E8D
00198:  RRCF   x90,W
0019A:  BNC   0198
0019C:  MOVLB  0
0019E:  GOTO   01B0 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PREPARE TO READ FROM AN ADC                                               */
.................... /*****************************************************************************/
.................... void ads_read_command(int8 ch, unsigned int8 command)
.................... {
....................    ads_select_ch(ch);
*
013A8:  MOVFF  5FC,5FE
013AC:  CALL   063E
....................    spi_read2(command);
013B0:  MOVLB  E
013B2:  MOVF   x8D,W
013B4:  MOVFF  5FD,E8D
013B8:  RRCF   x90,W
013BA:  BNC   13B8
013BC:  MOVLB  0
013BE:  GOTO   13D0 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE TO THE CONFIGURATION REGISTERS                                      */
.................... /*****************************************************************************/
.................... void ads_write_reg(int8 ch, adsReg regID, int8 data)
*
006E4:  MOVLB  5
006E6:  MOVF   xF9,W
006E8:  IORLW  40
006EA:  MOVWF  xFB
.................... {
....................    unsigned int8 command = ADSwriteReg | regID | 0; // 0 is numbytes to write-1
....................    ads_write_command(ch, command);
006EC:  MOVFF  5F8,5FC
006F0:  MOVFF  5FB,5FD
006F4:  MOVLB  0
006F6:  RCALL  06A8
....................    spi_write2(data);
006F8:  MOVLB  E
006FA:  MOVF   x8D,W
006FC:  MOVFF  5FA,E8D
00700:  RRCF   x90,W
00702:  BNC   0700
....................    ads_deselect_all();
00704:  MOVLB  0
00706:  RCALL  0136
00708:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* READ FROM THE CONFIGURATION REGISTERS                                     */
.................... /*****************************************************************************/
.................... unsigned int8 ads_read_reg(int8 ch, adsReg regID)
.................... {
....................    unsigned int8 command = ADSreadReg | regID | 0;
....................    ads_read_command(ch, command);
....................    unsigned int8 data = spi_read2(0);
....................    ads_deselect_all();
....................    return data;
.................... }
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* START BLOCK CONVERSION                                                    */
.................... /*****************************************************************************/
.................... void ads_start_conv_block(int8 block)
.................... {
....................    ads_write_command_block(block, ADSstart);
*
001A2:  MOVFF  664,665
001A6:  MOVLW  08
001A8:  MOVLB  6
001AA:  MOVWF  x66
001AC:  MOVLB  0
001AE:  BRA    018A
....................    delay_us(20);
001B0:  MOVLW  6A
001B2:  MOVWF  00
001B4:  DECFSZ 00,F
001B6:  BRA    01B4
001B8:  NOP   
....................    ads_deselect_all();
001BA:  RCALL  0136
001BC:  GOTO   01F4 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* READ THE MOST RECENT CONVERSION                                           */
.................... /*****************************************************************************/
.................... signed int32 ads_read_data(int8 ch)
.................... {
....................    union Data
....................    {
....................       unsigned int8 dBytes[4];
....................       signed int32 dWord;
....................    }data;
....................    
....................    ads_read_command(ch, ADSreadData);
*
013C2:  MOVFF  5F7,5FC
013C6:  MOVLW  10
013C8:  MOVLB  5
013CA:  MOVWF  xFD
013CC:  MOVLB  0
013CE:  BRA    13A8
....................    data.dBytes[0] = 0;
013D0:  MOVLB  5
013D2:  CLRF   xF8
....................    data.dBytes[3] = spi_read2(0);
013D4:  MOVLB  E
013D6:  MOVF   x8D,W
013D8:  CLRF   x8D
013DA:  RRCF   x90,W
013DC:  BNC   13DA
013DE:  MOVFF  E8D,5FB
....................    data.dBytes[2] = spi_read2(0);
013E2:  MOVF   x8D,W
013E4:  CLRF   x8D
013E6:  RRCF   x90,W
013E8:  BNC   13E6
013EA:  MOVFF  E8D,5FA
....................    data.dBytes[1] = spi_read2(0);
013EE:  MOVF   x8D,W
013F0:  CLRF   x8D
013F2:  RRCF   x90,W
013F4:  BNC   13F2
013F6:  MOVFF  E8D,5F9
....................    
....................    ads_deselect_all();
013FA:  MOVLB  0
013FC:  CALL   0136
....................    return data.dWord;
01400:  MOVFF  5F8,00
01404:  MOVFF  5F9,01
01408:  MOVFF  5FA,02
0140C:  MOVFF  5FB,03
01410:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE A CHANNEL                                                      */
.................... /*****************************************************************************/
.................... 
.................... void ADS1220init(int8 ch, rc0=reg0config, rc1=reg1config, rc2=reg2config, rc3=reg3config)
.................... {
....................    ads_write_command(ch, ADSreset);   //reset the device
*
0070A:  MOVFF  5F3,5FC
0070E:  MOVLW  06
00710:  MOVLB  5
00712:  MOVWF  xFD
00714:  MOVLB  0
00716:  RCALL  06A8
....................    delay_us(300);                    
00718:  MOVLW  02
0071A:  MOVLB  5
0071C:  MOVWF  xF8
0071E:  MOVLW  96
00720:  MOVWF  xF9
00722:  MOVLB  0
00724:  BRA    06BE
00726:  MOVLB  5
00728:  DECFSZ xF8,F
0072A:  BRA    071E
....................    ads_write_reg(ch, reg0, rc0);   //send default configurations
0072C:  MOVFF  5F3,5F8
00730:  CLRF   xF9
00732:  MOVFF  5F4,5FA
00736:  MOVLB  0
00738:  RCALL  06E4
....................    ads_write_reg(ch, reg1, rc1);
0073A:  MOVFF  5F3,5F8
0073E:  MOVLW  04
00740:  MOVLB  5
00742:  MOVWF  xF9
00744:  MOVFF  5F5,5FA
00748:  MOVLB  0
0074A:  RCALL  06E4
....................    ads_write_reg(ch, reg2, rc2);
0074C:  MOVFF  5F3,5F8
00750:  MOVLW  08
00752:  MOVLB  5
00754:  MOVWF  xF9
00756:  MOVFF  5F6,5FA
0075A:  MOVLB  0
0075C:  RCALL  06E4
....................    ads_write_reg(ch, reg3, rc3);  
0075E:  MOVFF  5F3,5F8
00762:  MOVLW  0C
00764:  MOVLB  5
00766:  MOVWF  xF9
00768:  MOVFF  5F7,5FA
0076C:  MOVLB  0
0076E:  RCALL  06E4
00770:  GOTO   07AC (RETURN)
.................... }
.................... #endif 
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
*
01E9C:  MOVLB  6
01E9E:  BCF    x4A.0
....................    y = x;
01EA0:  MOVFF  63E,643
01EA4:  MOVFF  63D,642
01EA8:  MOVFF  63C,641
01EAC:  MOVFF  63B,640
.................... 
....................    if (x < 0)
01EB0:  MOVFF  63E,64E
01EB4:  MOVFF  63D,64D
01EB8:  MOVFF  63C,64C
01EBC:  MOVFF  63B,64B
01EC0:  CLRF   x52
01EC2:  CLRF   x51
01EC4:  CLRF   x50
01EC6:  CLRF   x4F
01EC8:  MOVLB  0
01ECA:  CALL   146C
01ECE:  BNC   1EDC
....................    {
....................       s = 1;
01ED0:  MOVLB  6
01ED2:  BSF    x4A.0
....................       y = -y;
01ED4:  MOVF   x41,W
01ED6:  XORLW  80
01ED8:  MOVWF  x41
01EDA:  MOVLB  0
....................    }
.................... 
....................    if (y <= 32768.0)
01EDC:  MOVFF  643,64E
01EE0:  MOVFF  642,64D
01EE4:  MOVFF  641,64C
01EE8:  MOVFF  640,64B
01EEC:  MOVLB  6
01EEE:  CLRF   x52
01EF0:  CLRF   x51
01EF2:  CLRF   x50
01EF4:  MOVLW  8E
01EF6:  MOVWF  x4F
01EF8:  MOVLB  0
01EFA:  CALL   146C
01EFE:  BC    1F02
01F00:  BNZ   1F32
....................       res = (float32)(unsigned int16)y;
01F02:  MOVFF  643,64E
01F06:  MOVFF  642,64D
01F0A:  MOVFF  641,64C
01F0E:  MOVFF  640,64B
01F12:  RCALL  1E60
01F14:  MOVFF  02,650
01F18:  MOVFF  01,64F
01F1C:  CALL   0A86
01F20:  MOVFF  03,647
01F24:  MOVFF  02,646
01F28:  MOVFF  01,645
01F2C:  MOVFF  00,644
01F30:  BRA    20D4
.................... 
....................  else if (y < 10000000.0)
01F32:  MOVFF  643,64E
01F36:  MOVFF  642,64D
01F3A:  MOVFF  641,64C
01F3E:  MOVFF  640,64B
01F42:  MOVLW  80
01F44:  MOVLB  6
01F46:  MOVWF  x52
01F48:  MOVLW  96
01F4A:  MOVWF  x51
01F4C:  MOVLW  18
01F4E:  MOVWF  x50
01F50:  MOVLW  96
01F52:  MOVWF  x4F
01F54:  MOVLB  0
01F56:  CALL   146C
01F5A:  BTFSS  FD8.0
01F5C:  BRA    20C4
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
01F5E:  MOVFF  643,64E
01F62:  MOVFF  642,64D
01F66:  MOVFF  641,64C
01F6A:  MOVFF  640,64B
01F6E:  MOVLB  6
01F70:  CLRF   x52
01F72:  CLRF   x51
01F74:  CLRF   x50
01F76:  MOVLW  70
01F78:  MOVWF  x4F
01F7A:  MOVLB  0
01F7C:  CALL   0ABC
01F80:  MOVFF  03,64E
01F84:  MOVFF  02,64D
01F88:  MOVFF  01,64C
01F8C:  MOVFF  00,64B
01F90:  RCALL  1E60
01F92:  MOVFF  02,649
01F96:  MOVFF  01,648
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
01F9A:  MOVFF  643,64E
01F9E:  MOVFF  642,64D
01FA2:  MOVFF  641,64C
01FA6:  MOVFF  640,64B
01FAA:  MOVLB  6
01FAC:  CLRF   x52
01FAE:  CLRF   x51
01FB0:  CLRF   x50
01FB2:  MOVLW  70
01FB4:  MOVWF  x4F
01FB6:  MOVLB  0
01FB8:  CALL   0ABC
01FBC:  MOVFF  03,64E
01FC0:  MOVFF  02,64D
01FC4:  MOVFF  01,64C
01FC8:  MOVFF  00,64B
01FCC:  MOVFF  649,650
01FD0:  MOVFF  648,64F
01FD4:  CALL   0A86
01FD8:  BSF    FD8.1
01FDA:  MOVFF  64E,652
01FDE:  MOVFF  64D,651
01FE2:  MOVFF  64C,650
01FE6:  MOVFF  64B,64F
01FEA:  MOVFF  03,656
01FEE:  MOVFF  02,655
01FF2:  MOVFF  01,654
01FF6:  MOVFF  00,653
01FFA:  CALL   0BB2
01FFE:  MOVLB  6
02000:  CLRF   x4E
02002:  CLRF   x4D
02004:  CLRF   x4C
02006:  MOVLW  8E
02008:  MOVWF  x4B
0200A:  MOVFF  03,652
0200E:  MOVFF  02,651
02012:  MOVFF  01,650
02016:  MOVFF  00,64F
0201A:  MOVLB  0
0201C:  CALL   0ABC
02020:  MOVFF  03,643
02024:  MOVFF  02,642
02028:  MOVFF  01,641
0202C:  MOVFF  00,640
....................       res = 32768.0*(float32)l;
02030:  MOVFF  649,650
02034:  MOVFF  648,64F
02038:  CALL   0A86
0203C:  MOVLB  6
0203E:  CLRF   x4E
02040:  CLRF   x4D
02042:  CLRF   x4C
02044:  MOVLW  8E
02046:  MOVWF  x4B
02048:  MOVFF  03,652
0204C:  MOVFF  02,651
02050:  MOVFF  01,650
02054:  MOVFF  00,64F
02058:  MOVLB  0
0205A:  CALL   0ABC
0205E:  MOVFF  03,647
02062:  MOVFF  02,646
02066:  MOVFF  01,645
0206A:  MOVFF  00,644
....................       res += (float32)(unsigned int16)y;
0206E:  MOVFF  643,64E
02072:  MOVFF  642,64D
02076:  MOVFF  641,64C
0207A:  MOVFF  640,64B
0207E:  RCALL  1E60
02080:  MOVFF  02,650
02084:  MOVFF  01,64F
02088:  CALL   0A86
0208C:  BCF    FD8.1
0208E:  MOVFF  647,652
02092:  MOVFF  646,651
02096:  MOVFF  645,650
0209A:  MOVFF  644,64F
0209E:  MOVFF  03,656
020A2:  MOVFF  02,655
020A6:  MOVFF  01,654
020AA:  MOVFF  00,653
020AE:  CALL   0BB2
020B2:  MOVFF  03,647
020B6:  MOVFF  02,646
020BA:  MOVFF  01,645
020BE:  MOVFF  00,644
....................    }
020C2:  BRA    20D4
.................... 
....................  else
....................   res = y;
020C4:  MOVFF  643,647
020C8:  MOVFF  642,646
020CC:  MOVFF  641,645
020D0:  MOVFF  640,644
.................... 
....................  y = y - (float32)(unsigned int16)y;
020D4:  MOVFF  643,64E
020D8:  MOVFF  642,64D
020DC:  MOVFF  641,64C
020E0:  MOVFF  640,64B
020E4:  RCALL  1E60
020E6:  MOVFF  02,650
020EA:  MOVFF  01,64F
020EE:  CALL   0A86
020F2:  BSF    FD8.1
020F4:  MOVFF  643,652
020F8:  MOVFF  642,651
020FC:  MOVFF  641,650
02100:  MOVFF  640,64F
02104:  MOVFF  03,656
02108:  MOVFF  02,655
0210C:  MOVFF  01,654
02110:  MOVFF  00,653
02114:  CALL   0BB2
02118:  MOVFF  03,643
0211C:  MOVFF  02,642
02120:  MOVFF  01,641
02124:  MOVFF  00,640
.................... 
....................  if (s)
02128:  MOVLB  6
0212A:  BTFSS  x4A.0
0212C:  BRA    2134
....................   res = -res;
0212E:  MOVF   x45,W
02130:  XORLW  80
02132:  MOVWF  x45
.................... 
....................  if (y != 0)
02134:  MOVFF  643,64E
02138:  MOVFF  642,64D
0213C:  MOVFF  641,64C
02140:  MOVFF  640,64B
02144:  CLRF   x52
02146:  CLRF   x51
02148:  CLRF   x50
0214A:  CLRF   x4F
0214C:  MOVLB  0
0214E:  CALL   146C
02152:  BZ    21CC
....................  {
....................   if (s == 1 && n == 0)
02154:  MOVLB  6
02156:  BTFSS  x4A.0
02158:  BRA    2192
0215A:  MOVF   x3F,F
0215C:  BNZ   2192
....................    res -= 1.0;
0215E:  BSF    FD8.1
02160:  MOVFF  647,652
02164:  MOVFF  646,651
02168:  MOVFF  645,650
0216C:  MOVFF  644,64F
02170:  CLRF   x56
02172:  CLRF   x55
02174:  CLRF   x54
02176:  MOVLW  7F
02178:  MOVWF  x53
0217A:  MOVLB  0
0217C:  CALL   0BB2
02180:  MOVFF  03,647
02184:  MOVFF  02,646
02188:  MOVFF  01,645
0218C:  MOVFF  00,644
02190:  MOVLB  6
.................... 
....................   if (s == 0 && n == 1)
02192:  BTFSC  x4A.0
02194:  BRA    21CE
02196:  DECFSZ x3F,W
02198:  BRA    21CE
....................    res += 1.0;
0219A:  BCF    FD8.1
0219C:  MOVFF  647,652
021A0:  MOVFF  646,651
021A4:  MOVFF  645,650
021A8:  MOVFF  644,64F
021AC:  CLRF   x56
021AE:  CLRF   x55
021B0:  CLRF   x54
021B2:  MOVLW  7F
021B4:  MOVWF  x53
021B6:  MOVLB  0
021B8:  CALL   0BB2
021BC:  MOVFF  03,647
021C0:  MOVFF  02,646
021C4:  MOVFF  01,645
021C8:  MOVFF  00,644
021CC:  MOVLB  6
....................  }
....................  if (x == 0)
021CE:  MOVFF  63E,64E
021D2:  MOVFF  63D,64D
021D6:  MOVFF  63C,64C
021DA:  MOVFF  63B,64B
021DE:  CLRF   x52
021E0:  CLRF   x51
021E2:  CLRF   x50
021E4:  CLRF   x4F
021E6:  MOVLB  0
021E8:  CALL   146C
021EC:  BNZ   21FA
....................     res = 0;
021EE:  MOVLB  6
021F0:  CLRF   x47
021F2:  CLRF   x46
021F4:  CLRF   x45
021F6:  CLRF   x44
021F8:  MOVLB  0
.................... 
....................  return (res);
021FA:  MOVFF  644,00
021FE:  MOVFF  645,01
02202:  MOVFF  646,02
02206:  MOVFF  647,03
0220A:  RETURN 0
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
*
0222A:  MOVFF  63A,63E
0222E:  MOVFF  639,63D
02232:  MOVFF  638,63C
02236:  MOVFF  637,63B
0223A:  MOVLB  6
0223C:  CLRF   x3F
0223E:  MOVLB  0
02240:  RCALL  1E9C
02242:  GOTO   234E (RETURN)
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
*
0220C:  MOVFF  63A,63E
02210:  MOVFF  639,63D
02214:  MOVFF  638,63C
02218:  MOVFF  637,63B
0221C:  MOVLW  01
0221E:  MOVLB  6
02220:  MOVWF  x3F
02222:  MOVLB  0
02224:  RCALL  1E9C
02226:  GOTO   2306 (RETURN)
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
*
02246:  MOVFF  62E,64E
0224A:  MOVFF  62D,64D
0224E:  MOVFF  62C,64C
02252:  MOVFF  62B,64B
02256:  MOVLB  6
02258:  CLRF   x52
0225A:  CLRF   x51
0225C:  CLRF   x50
0225E:  CLRF   x4F
02260:  MOVLB  0
02262:  CALL   146C
02266:  BTFSC  FD8.2
02268:  BRA    23AA
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
0226A:  MOVFF  62A,647
0226E:  MOVFF  629,646
02272:  MOVFF  628,645
02276:  MOVFF  627,644
0227A:  MOVFF  62E,64B
0227E:  MOVFF  62D,64A
02282:  MOVFF  62C,649
02286:  MOVFF  62B,648
0228A:  CALL   14E6
0228E:  MOVFF  03,636
02292:  MOVFF  02,635
02296:  MOVFF  01,634
0229A:  MOVFF  00,633
0229E:  MOVFF  03,64E
022A2:  MOVFF  02,64D
022A6:  MOVFF  01,64C
022AA:  MOVFF  00,64B
022AE:  MOVLB  6
022B0:  CLRF   x52
022B2:  CLRF   x51
022B4:  CLRF   x50
022B6:  CLRF   x4F
022B8:  MOVLB  0
022BA:  CALL   146C
022BE:  BNC   2308
022C0:  MOVFF  62A,647
022C4:  MOVFF  629,646
022C8:  MOVFF  628,645
022CC:  MOVFF  627,644
022D0:  MOVFF  62E,64B
022D4:  MOVFF  62D,64A
022D8:  MOVFF  62C,649
022DC:  MOVFF  62B,648
022E0:  CALL   14E6
022E4:  MOVFF  03,636
022E8:  MOVFF  02,635
022EC:  MOVFF  01,634
022F0:  MOVFF  00,633
022F4:  MOVFF  03,63A
022F8:  MOVFF  02,639
022FC:  MOVFF  01,638
02300:  MOVFF  00,637
02304:  BRA    220C
02306:  BRA    234E
02308:  MOVFF  62A,647
0230C:  MOVFF  629,646
02310:  MOVFF  628,645
02314:  MOVFF  627,644
02318:  MOVFF  62E,64B
0231C:  MOVFF  62D,64A
02320:  MOVFF  62C,649
02324:  MOVFF  62B,648
02328:  CALL   14E6
0232C:  MOVFF  03,636
02330:  MOVFF  02,635
02334:  MOVFF  01,634
02338:  MOVFF  00,633
0233C:  MOVFF  03,63A
02340:  MOVFF  02,639
02344:  MOVFF  01,638
02348:  MOVFF  00,637
0234C:  BRA    222A
0234E:  MOVFF  03,632
02352:  MOVFF  02,631
02356:  MOVFF  01,630
0235A:  MOVFF  00,62F
....................       return(x-(i*y));
0235E:  MOVFF  632,64E
02362:  MOVFF  631,64D
02366:  MOVFF  630,64C
0236A:  MOVFF  62F,64B
0236E:  MOVFF  62E,652
02372:  MOVFF  62D,651
02376:  MOVFF  62C,650
0237A:  MOVFF  62B,64F
0237E:  CALL   0ABC
02382:  BSF    FD8.1
02384:  MOVFF  62A,652
02388:  MOVFF  629,651
0238C:  MOVFF  628,650
02390:  MOVFF  627,64F
02394:  MOVFF  03,656
02398:  MOVFF  02,655
0239C:  MOVFF  01,654
023A0:  MOVFF  00,653
023A4:  CALL   0BB2
023A8:  BRA    23AA
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
023AA:  RETURN 0
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
*
02740:  MOVFF  62E,64E
02744:  MOVFF  62D,64D
02748:  MOVFF  62C,64C
0274C:  MOVFF  62B,64B
02750:  MOVLW  3B
02752:  MOVLB  6
02754:  MOVWF  x52
02756:  MOVLW  AA
02758:  MOVWF  x51
0275A:  MOVLW  38
0275C:  MOVWF  x50
0275E:  MOVLW  7F
02760:  MOVWF  x4F
02762:  MOVLB  0
02764:  CALL   0ABC
02768:  MOVFF  03,64E
0276C:  MOVFF  02,64D
02770:  MOVFF  01,64C
02774:  MOVFF  00,64B
02778:  CALL   1E60
0277C:  MOVFF  01,63B
....................    s = 0;
02780:  MOVLB  6
02782:  BCF    x3C.0
....................    y = x;
02784:  MOVFF  62E,632
02788:  MOVFF  62D,631
0278C:  MOVFF  62C,630
02790:  MOVFF  62B,62F
.................... 
....................    if (x < 0)
02794:  MOVFF  62E,64E
02798:  MOVFF  62D,64D
0279C:  MOVFF  62C,64C
027A0:  MOVFF  62B,64B
027A4:  CLRF   x52
027A6:  CLRF   x51
027A8:  CLRF   x50
027AA:  CLRF   x4F
027AC:  MOVLB  0
027AE:  CALL   146C
027B2:  BNC   27C2
....................    {
....................       s = 1;
027B4:  MOVLB  6
027B6:  BSF    x3C.0
....................       n = -n;
027B8:  NEGF   x3B
....................       y = -y;
027BA:  MOVF   x30,W
027BC:  XORLW  80
027BE:  MOVWF  x30
027C0:  MOVLB  0
....................    }
.................... 
....................    res = 0.0;
027C2:  MOVLB  6
027C4:  CLRF   x36
027C6:  CLRF   x35
027C8:  CLRF   x34
027CA:  CLRF   x33
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
027CC:  MOVLW  06
027CE:  MOVWF  x3E
027D0:  MOVLW  33
027D2:  MOVFF  63E,FEA
027D6:  MOVWF  FE9
027D8:  MOVLW  7F
027DA:  ADDWF  x3B,W
027DC:  MOVWF  FEF
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
027DE:  MOVFF  632,64E
027E2:  MOVFF  631,64D
027E6:  MOVFF  630,64C
027EA:  MOVFF  62F,64B
027EE:  MOVLW  3B
027F0:  MOVWF  x52
027F2:  MOVLW  AA
027F4:  MOVWF  x51
027F6:  MOVLW  38
027F8:  MOVWF  x50
027FA:  MOVLW  7F
027FC:  MOVWF  x4F
027FE:  MOVLB  0
02800:  CALL   0ABC
02804:  MOVFF  03,640
02808:  MOVFF  02,63F
0280C:  MOVFF  01,63E
02810:  MOVFF  00,63D
02814:  MOVLB  6
02816:  CLRF   x42
02818:  MOVFF  63B,641
0281C:  BTFSC  x41.7
0281E:  DECF   x42,F
02820:  MOVLB  0
02822:  CALL   1E10
02826:  BSF    FD8.1
02828:  MOVFF  640,652
0282C:  MOVFF  63F,651
02830:  MOVFF  63E,650
02834:  MOVFF  63D,64F
02838:  MOVFF  03,656
0283C:  MOVFF  02,655
02840:  MOVFF  01,654
02844:  MOVFF  00,653
02848:  CALL   0BB2
0284C:  MOVFF  03,632
02850:  MOVFF  02,631
02854:  MOVFF  01,630
02858:  MOVFF  00,62F
.................... 
....................    r = pe[0]*y + pe[1];
0285C:  MOVLW  7C
0285E:  MOVLB  6
02860:  MOVWF  x4E
02862:  MOVLW  88
02864:  MOVWF  x4D
02866:  MOVLW  59
02868:  MOVWF  x4C
0286A:  MOVLW  72
0286C:  MOVWF  x4B
0286E:  MOVFF  632,652
02872:  MOVFF  631,651
02876:  MOVFF  630,650
0287A:  MOVFF  62F,64F
0287E:  MOVLB  0
02880:  CALL   0ABC
02884:  MOVFF  03,640
02888:  MOVFF  02,63F
0288C:  MOVFF  01,63E
02890:  MOVFF  00,63D
02894:  BCF    FD8.1
02896:  MOVFF  03,652
0289A:  MOVFF  02,651
0289E:  MOVFF  01,650
028A2:  MOVFF  00,64F
028A6:  MOVLW  E0
028A8:  MOVLB  6
028AA:  MOVWF  x56
028AC:  MOVLW  97
028AE:  MOVWF  x55
028B0:  MOVLW  26
028B2:  MOVWF  x54
028B4:  MOVLW  75
028B6:  MOVWF  x53
028B8:  MOVLB  0
028BA:  CALL   0BB2
028BE:  MOVFF  03,63A
028C2:  MOVFF  02,639
028C6:  MOVFF  01,638
028CA:  MOVFF  00,637
....................    r = r*y + pe[2];
028CE:  MOVFF  63A,64E
028D2:  MOVFF  639,64D
028D6:  MOVFF  638,64C
028DA:  MOVFF  637,64B
028DE:  MOVFF  632,652
028E2:  MOVFF  631,651
028E6:  MOVFF  630,650
028EA:  MOVFF  62F,64F
028EE:  CALL   0ABC
028F2:  MOVFF  03,640
028F6:  MOVFF  02,63F
028FA:  MOVFF  01,63E
028FE:  MOVFF  00,63D
02902:  BCF    FD8.1
02904:  MOVFF  03,652
02908:  MOVFF  02,651
0290C:  MOVFF  01,650
02910:  MOVFF  00,64F
02914:  MOVLW  C4
02916:  MOVLB  6
02918:  MOVWF  x56
0291A:  MOVLW  1D
0291C:  MOVWF  x55
0291E:  MOVLW  1E
02920:  MOVWF  x54
02922:  MOVLW  78
02924:  MOVWF  x53
02926:  MOVLB  0
02928:  CALL   0BB2
0292C:  MOVFF  03,63A
02930:  MOVFF  02,639
02934:  MOVFF  01,638
02938:  MOVFF  00,637
....................    r = r*y + pe[3];
0293C:  MOVFF  63A,64E
02940:  MOVFF  639,64D
02944:  MOVFF  638,64C
02948:  MOVFF  637,64B
0294C:  MOVFF  632,652
02950:  MOVFF  631,651
02954:  MOVFF  630,650
02958:  MOVFF  62F,64F
0295C:  CALL   0ABC
02960:  MOVFF  03,640
02964:  MOVFF  02,63F
02968:  MOVFF  01,63E
0296C:  MOVFF  00,63D
02970:  BCF    FD8.1
02972:  MOVFF  03,652
02976:  MOVFF  02,651
0297A:  MOVFF  01,650
0297E:  MOVFF  00,64F
02982:  MOVLW  5E
02984:  MOVLB  6
02986:  MOVWF  x56
02988:  MOVLW  50
0298A:  MOVWF  x55
0298C:  MOVLW  63
0298E:  MOVWF  x54
02990:  MOVLW  7A
02992:  MOVWF  x53
02994:  MOVLB  0
02996:  CALL   0BB2
0299A:  MOVFF  03,63A
0299E:  MOVFF  02,639
029A2:  MOVFF  01,638
029A6:  MOVFF  00,637
....................    r = r*y + pe[4];
029AA:  MOVFF  63A,64E
029AE:  MOVFF  639,64D
029B2:  MOVFF  638,64C
029B6:  MOVFF  637,64B
029BA:  MOVFF  632,652
029BE:  MOVFF  631,651
029C2:  MOVFF  630,650
029C6:  MOVFF  62F,64F
029CA:  CALL   0ABC
029CE:  MOVFF  03,640
029D2:  MOVFF  02,63F
029D6:  MOVFF  01,63E
029DA:  MOVFF  00,63D
029DE:  BCF    FD8.1
029E0:  MOVFF  03,652
029E4:  MOVFF  02,651
029E8:  MOVFF  01,650
029EC:  MOVFF  00,64F
029F0:  MOVLW  1A
029F2:  MOVLB  6
029F4:  MOVWF  x56
029F6:  MOVLW  FE
029F8:  MOVWF  x55
029FA:  MOVLW  75
029FC:  MOVWF  x54
029FE:  MOVLW  7C
02A00:  MOVWF  x53
02A02:  MOVLB  0
02A04:  CALL   0BB2
02A08:  MOVFF  03,63A
02A0C:  MOVFF  02,639
02A10:  MOVFF  01,638
02A14:  MOVFF  00,637
....................    r = r*y + pe[5];
02A18:  MOVFF  63A,64E
02A1C:  MOVFF  639,64D
02A20:  MOVFF  638,64C
02A24:  MOVFF  637,64B
02A28:  MOVFF  632,652
02A2C:  MOVFF  631,651
02A30:  MOVFF  630,650
02A34:  MOVFF  62F,64F
02A38:  CALL   0ABC
02A3C:  MOVFF  03,640
02A40:  MOVFF  02,63F
02A44:  MOVFF  01,63E
02A48:  MOVFF  00,63D
02A4C:  BCF    FD8.1
02A4E:  MOVFF  03,652
02A52:  MOVFF  02,651
02A56:  MOVFF  01,650
02A5A:  MOVFF  00,64F
02A5E:  MOVLW  18
02A60:  MOVLB  6
02A62:  MOVWF  x56
02A64:  MOVLW  72
02A66:  MOVWF  x55
02A68:  MOVLW  31
02A6A:  MOVWF  x54
02A6C:  MOVLW  7E
02A6E:  MOVWF  x53
02A70:  MOVLB  0
02A72:  CALL   0BB2
02A76:  MOVFF  03,63A
02A7A:  MOVFF  02,639
02A7E:  MOVFF  01,638
02A82:  MOVFF  00,637
.................... 
....................    res = res*(1.0 + y*r);
02A86:  MOVFF  632,64E
02A8A:  MOVFF  631,64D
02A8E:  MOVFF  630,64C
02A92:  MOVFF  62F,64B
02A96:  MOVFF  63A,652
02A9A:  MOVFF  639,651
02A9E:  MOVFF  638,650
02AA2:  MOVFF  637,64F
02AA6:  CALL   0ABC
02AAA:  BCF    FD8.1
02AAC:  MOVLB  6
02AAE:  CLRF   x52
02AB0:  CLRF   x51
02AB2:  CLRF   x50
02AB4:  MOVLW  7F
02AB6:  MOVWF  x4F
02AB8:  MOVFF  03,656
02ABC:  MOVFF  02,655
02AC0:  MOVFF  01,654
02AC4:  MOVFF  00,653
02AC8:  MOVLB  0
02ACA:  CALL   0BB2
02ACE:  MOVFF  636,64E
02AD2:  MOVFF  635,64D
02AD6:  MOVFF  634,64C
02ADA:  MOVFF  633,64B
02ADE:  MOVFF  03,652
02AE2:  MOVFF  02,651
02AE6:  MOVFF  01,650
02AEA:  MOVFF  00,64F
02AEE:  CALL   0ABC
02AF2:  MOVFF  03,636
02AF6:  MOVFF  02,635
02AFA:  MOVFF  01,634
02AFE:  MOVFF  00,633
.................... 
....................    if (s)
02B02:  MOVLB  6
02B04:  BTFSS  x3C.0
02B06:  BRA    2B3A
....................       res = 1.0/res;
02B08:  CLRF   x47
02B0A:  CLRF   x46
02B0C:  CLRF   x45
02B0E:  MOVLW  7F
02B10:  MOVWF  x44
02B12:  MOVFF  636,64B
02B16:  MOVFF  635,64A
02B1A:  MOVFF  634,649
02B1E:  MOVFF  633,648
02B22:  MOVLB  0
02B24:  CALL   14E6
02B28:  MOVFF  03,636
02B2C:  MOVFF  02,635
02B30:  MOVFF  01,634
02B34:  MOVFF  00,633
02B38:  MOVLB  6
....................    return(res);
02B3A:  MOVFF  633,00
02B3E:  MOVFF  634,01
02B42:  MOVFF  635,02
02B46:  MOVFF  636,03
02B4A:  MOVLB  0
02B4C:  RETURN 0
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
*
023AC:  MOVFF  62E,632
023B0:  MOVFF  62D,631
023B4:  MOVFF  62C,630
023B8:  MOVFF  62B,62F
.................... 
....................    if (y != 1.0)
023BC:  MOVFF  632,64E
023C0:  MOVFF  631,64D
023C4:  MOVFF  630,64C
023C8:  MOVFF  62F,64B
023CC:  MOVLB  6
023CE:  CLRF   x52
023D0:  CLRF   x51
023D2:  CLRF   x50
023D4:  MOVLW  7F
023D6:  MOVWF  x4F
023D8:  MOVLB  0
023DA:  CALL   146C
023DE:  BTFSC  FD8.2
023E0:  BRA    2722
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
023E2:  MOVLW  06
023E4:  MOVLB  6
023E6:  MOVWF  x41
023E8:  MOVLW  2F
023EA:  MOVFF  641,FEA
023EE:  MOVWF  FE9
023F0:  MOVLW  7E
023F2:  MOVWF  FEF
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
023F4:  BSF    FD8.1
023F6:  MOVFF  632,652
023FA:  MOVFF  631,651
023FE:  MOVFF  630,650
02402:  MOVFF  62F,64F
02406:  CLRF   x56
02408:  CLRF   x55
0240A:  CLRF   x54
0240C:  MOVLW  7F
0240E:  MOVWF  x53
02410:  MOVLB  0
02412:  CALL   0BB2
02416:  MOVFF  03,643
0241A:  MOVFF  02,642
0241E:  MOVFF  01,641
02422:  MOVFF  00,640
02426:  BCF    FD8.1
02428:  MOVFF  632,652
0242C:  MOVFF  631,651
02430:  MOVFF  630,650
02434:  MOVFF  62F,64F
02438:  MOVLB  6
0243A:  CLRF   x56
0243C:  CLRF   x55
0243E:  CLRF   x54
02440:  MOVLW  7F
02442:  MOVWF  x53
02444:  MOVLB  0
02446:  CALL   0BB2
0244A:  MOVFF  643,647
0244E:  MOVFF  642,646
02452:  MOVFF  641,645
02456:  MOVFF  640,644
0245A:  MOVFF  03,64B
0245E:  MOVFF  02,64A
02462:  MOVFF  01,649
02466:  MOVFF  00,648
0246A:  CALL   14E6
0246E:  MOVFF  03,632
02472:  MOVFF  02,631
02476:  MOVFF  01,630
0247A:  MOVFF  00,62F
.................... 
....................       y2=y*y;
0247E:  MOVFF  632,64E
02482:  MOVFF  631,64D
02486:  MOVFF  630,64C
0248A:  MOVFF  62F,64B
0248E:  MOVFF  632,652
02492:  MOVFF  631,651
02496:  MOVFF  630,650
0249A:  MOVFF  62F,64F
0249E:  CALL   0ABC
024A2:  MOVFF  03,63E
024A6:  MOVFF  02,63D
024AA:  MOVFF  01,63C
024AE:  MOVFF  00,63B
.................... 
....................       res = pl[0]*y2 + pl[1];
024B2:  MOVLW  99
024B4:  MOVLB  6
024B6:  MOVWF  x4E
024B8:  MOVLW  47
024BA:  MOVWF  x4D
024BC:  MOVLW  8A
024BE:  MOVWF  x4C
024C0:  MOVLW  7F
024C2:  MOVWF  x4B
024C4:  MOVFF  63E,652
024C8:  MOVFF  63D,651
024CC:  MOVFF  63C,650
024D0:  MOVFF  63B,64F
024D4:  MOVLB  0
024D6:  CALL   0ABC
024DA:  MOVFF  03,643
024DE:  MOVFF  02,642
024E2:  MOVFF  01,641
024E6:  MOVFF  00,640
024EA:  BCF    FD8.1
024EC:  MOVFF  03,652
024F0:  MOVFF  02,651
024F4:  MOVFF  01,650
024F8:  MOVFF  00,64F
024FC:  MOVLB  6
024FE:  CLRF   x56
02500:  CLRF   x55
02502:  CLRF   x54
02504:  MOVLW  80
02506:  MOVWF  x53
02508:  MOVLB  0
0250A:  CALL   0BB2
0250E:  MOVFF  03,636
02512:  MOVFF  02,635
02516:  MOVFF  01,634
0251A:  MOVFF  00,633
.................... 
....................       r = ql[0]*y2 + ql[1];
0251E:  MOVLW  4C
02520:  MOVLB  6
02522:  MOVWF  x4E
02524:  MOVLW  F3
02526:  MOVWF  x4D
02528:  MOVLW  3A
0252A:  MOVWF  x4C
0252C:  MOVLW  7B
0252E:  MOVWF  x4B
02530:  MOVFF  63E,652
02534:  MOVFF  63D,651
02538:  MOVFF  63C,650
0253C:  MOVFF  63B,64F
02540:  MOVLB  0
02542:  CALL   0ABC
02546:  MOVFF  03,643
0254A:  MOVFF  02,642
0254E:  MOVFF  01,641
02552:  MOVFF  00,640
02556:  BCF    FD8.1
02558:  MOVFF  03,652
0255C:  MOVFF  02,651
02560:  MOVFF  01,650
02564:  MOVFF  00,64F
02568:  MOVLW  2B
0256A:  MOVLB  6
0256C:  MOVWF  x56
0256E:  MOVLW  9D
02570:  MOVWF  x55
02572:  MOVLW  DF
02574:  MOVWF  x54
02576:  MOVLW  7E
02578:  MOVWF  x53
0257A:  MOVLB  0
0257C:  CALL   0BB2
02580:  MOVFF  03,63A
02584:  MOVFF  02,639
02588:  MOVFF  01,638
0258C:  MOVFF  00,637
....................       r = r*y2 + 1.0;
02590:  MOVFF  63A,64E
02594:  MOVFF  639,64D
02598:  MOVFF  638,64C
0259C:  MOVFF  637,64B
025A0:  MOVFF  63E,652
025A4:  MOVFF  63D,651
025A8:  MOVFF  63C,650
025AC:  MOVFF  63B,64F
025B0:  CALL   0ABC
025B4:  MOVFF  03,643
025B8:  MOVFF  02,642
025BC:  MOVFF  01,641
025C0:  MOVFF  00,640
025C4:  BCF    FD8.1
025C6:  MOVFF  03,652
025CA:  MOVFF  02,651
025CE:  MOVFF  01,650
025D2:  MOVFF  00,64F
025D6:  MOVLB  6
025D8:  CLRF   x56
025DA:  CLRF   x55
025DC:  CLRF   x54
025DE:  MOVLW  7F
025E0:  MOVWF  x53
025E2:  MOVLB  0
025E4:  CALL   0BB2
025E8:  MOVFF  03,63A
025EC:  MOVFF  02,639
025F0:  MOVFF  01,638
025F4:  MOVFF  00,637
.................... 
....................       res = y*res/r;
025F8:  MOVFF  632,64E
025FC:  MOVFF  631,64D
02600:  MOVFF  630,64C
02604:  MOVFF  62F,64B
02608:  MOVFF  636,652
0260C:  MOVFF  635,651
02610:  MOVFF  634,650
02614:  MOVFF  633,64F
02618:  CALL   0ABC
0261C:  MOVFF  03,643
02620:  MOVFF  02,642
02624:  MOVFF  01,641
02628:  MOVFF  00,640
0262C:  MOVFF  03,647
02630:  MOVFF  02,646
02634:  MOVFF  01,645
02638:  MOVFF  00,644
0263C:  MOVFF  63A,64B
02640:  MOVFF  639,64A
02644:  MOVFF  638,649
02648:  MOVFF  637,648
0264C:  CALL   14E6
02650:  MOVFF  03,636
02654:  MOVFF  02,635
02658:  MOVFF  01,634
0265C:  MOVFF  00,633
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
02660:  MOVLW  06
02662:  MOVLB  6
02664:  MOVWF  x41
02666:  MOVLW  2B
02668:  MOVFF  641,FEA
0266C:  MOVWF  FE9
0266E:  MOVLW  7E
02670:  SUBWF  FEF,W
02672:  MOVWF  x3F
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
02674:  BTFSS  x3F.7
02676:  BRA    26A2
....................          r = -(float32)-n;
02678:  MOVLW  00
0267A:  BSF    FD8.0
0267C:  SUBFWB x3F,W
0267E:  CLRF   x42
02680:  MOVWF  x41
02682:  BTFSC  x41.7
02684:  DECF   x42,F
02686:  MOVLB  0
02688:  CALL   1E10
0268C:  MOVFF  00,637
02690:  MOVF   01,W
02692:  XORLW  80
02694:  MOVLB  6
02696:  MOVWF  x38
02698:  MOVFF  02,639
0269C:  MOVFF  03,63A
026A0:  BRA    26C4
....................       else
....................          r = (float32)n;
026A2:  CLRF   x42
026A4:  MOVFF  63F,641
026A8:  BTFSC  x41.7
026AA:  DECF   x42,F
026AC:  MOVLB  0
026AE:  CALL   1E10
026B2:  MOVFF  03,63A
026B6:  MOVFF  02,639
026BA:  MOVFF  01,638
026BE:  MOVFF  00,637
026C2:  MOVLB  6
.................... 
....................       res += r*LN2;
026C4:  MOVFF  63A,64E
026C8:  MOVFF  639,64D
026CC:  MOVFF  638,64C
026D0:  MOVFF  637,64B
026D4:  MOVLW  18
026D6:  MOVWF  x52
026D8:  MOVLW  72
026DA:  MOVWF  x51
026DC:  MOVLW  31
026DE:  MOVWF  x50
026E0:  MOVLW  7E
026E2:  MOVWF  x4F
026E4:  MOVLB  0
026E6:  CALL   0ABC
026EA:  BCF    FD8.1
026EC:  MOVFF  636,652
026F0:  MOVFF  635,651
026F4:  MOVFF  634,650
026F8:  MOVFF  633,64F
026FC:  MOVFF  03,656
02700:  MOVFF  02,655
02704:  MOVFF  01,654
02708:  MOVFF  00,653
0270C:  CALL   0BB2
02710:  MOVFF  03,636
02714:  MOVFF  02,635
02718:  MOVFF  01,634
0271C:  MOVFF  00,633
....................    }
02720:  BRA    272E
.................... 
....................    else
....................       res = 0.0;
02722:  MOVLB  6
02724:  CLRF   x36
02726:  CLRF   x35
02728:  CLRF   x34
0272A:  CLRF   x33
0272C:  MOVLB  0
.................... 
....................    return(res);
0272E:  MOVFF  633,00
02732:  MOVFF  634,01
02736:  MOVFF  635,02
0273A:  MOVFF  636,03
0273E:  RETURN 0
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
*
02B4E:  MOVFF  622,64E
02B52:  MOVFF  621,64D
02B56:  MOVFF  620,64C
02B5A:  MOVFF  61F,64B
02B5E:  MOVLB  6
02B60:  CLRF   x52
02B62:  CLRF   x51
02B64:  CLRF   x50
02B66:  CLRF   x4F
02B68:  MOVLB  0
02B6A:  CALL   146C
02B6E:  BTFSS  FD8.0
02B70:  BRA    2D0C
02B72:  MOVFF  626,62A
02B76:  MOVFF  625,629
02B7A:  MOVFF  624,628
02B7E:  MOVFF  623,627
02B82:  MOVLB  6
02B84:  CLRF   x2E
02B86:  CLRF   x2D
02B88:  CLRF   x2C
02B8A:  MOVLW  7F
02B8C:  MOVWF  x2B
02B8E:  MOVLB  0
02B90:  CALL   2246
02B94:  MOVFF  03,62A
02B98:  MOVFF  02,629
02B9C:  MOVFF  01,628
02BA0:  MOVFF  00,627
02BA4:  MOVFF  03,64E
02BA8:  MOVFF  02,64D
02BAC:  MOVFF  01,64C
02BB0:  MOVFF  00,64B
02BB4:  MOVLB  6
02BB6:  CLRF   x52
02BB8:  CLRF   x51
02BBA:  CLRF   x50
02BBC:  CLRF   x4F
02BBE:  MOVLB  0
02BC0:  CALL   146C
02BC4:  BTFSS  FD8.2
02BC6:  BRA    2D0C
....................       if(fmod(y, 2) == 0) {
02BC8:  MOVFF  626,62A
02BCC:  MOVFF  625,629
02BD0:  MOVFF  624,628
02BD4:  MOVFF  623,627
02BD8:  MOVLB  6
02BDA:  CLRF   x2E
02BDC:  CLRF   x2D
02BDE:  CLRF   x2C
02BE0:  MOVLW  80
02BE2:  MOVWF  x2B
02BE4:  MOVLB  0
02BE6:  CALL   2246
02BEA:  MOVFF  03,62A
02BEE:  MOVFF  02,629
02BF2:  MOVFF  01,628
02BF6:  MOVFF  00,627
02BFA:  MOVFF  03,64E
02BFE:  MOVFF  02,64D
02C02:  MOVFF  01,64C
02C06:  MOVFF  00,64B
02C0A:  MOVLB  6
02C0C:  CLRF   x52
02C0E:  CLRF   x51
02C10:  CLRF   x50
02C12:  CLRF   x4F
02C14:  MOVLB  0
02C16:  CALL   146C
02C1A:  BNZ   2C92
....................          return (exp(log(-x) * y));
02C1C:  MOVLB  6
02C1E:  MOVF   x20,W
02C20:  XORLW  80
02C22:  MOVWF  x28
02C24:  MOVFF  622,62E
02C28:  MOVFF  621,62D
02C2C:  MOVWF  x2C
02C2E:  MOVFF  61F,62B
02C32:  MOVLB  0
02C34:  CALL   23AC
02C38:  MOVFF  03,62A
02C3C:  MOVFF  02,629
02C40:  MOVFF  01,628
02C44:  MOVFF  00,627
02C48:  MOVFF  03,64E
02C4C:  MOVFF  02,64D
02C50:  MOVFF  01,64C
02C54:  MOVFF  00,64B
02C58:  MOVFF  626,652
02C5C:  MOVFF  625,651
02C60:  MOVFF  624,650
02C64:  MOVFF  623,64F
02C68:  CALL   0ABC
02C6C:  MOVFF  03,62A
02C70:  MOVFF  02,629
02C74:  MOVFF  01,628
02C78:  MOVFF  00,627
02C7C:  MOVFF  03,62E
02C80:  MOVFF  02,62D
02C84:  MOVFF  01,62C
02C88:  MOVFF  00,62B
02C8C:  RCALL  2740
02C8E:  BRA    2E4A
....................       } else {
02C90:  BRA    2D0A
....................          return (-exp(log(-x) * y));
02C92:  MOVLB  6
02C94:  MOVF   x20,W
02C96:  XORLW  80
02C98:  MOVWF  x28
02C9A:  MOVFF  622,62E
02C9E:  MOVFF  621,62D
02CA2:  MOVWF  x2C
02CA4:  MOVFF  61F,62B
02CA8:  MOVLB  0
02CAA:  CALL   23AC
02CAE:  MOVFF  03,62A
02CB2:  MOVFF  02,629
02CB6:  MOVFF  01,628
02CBA:  MOVFF  00,627
02CBE:  MOVFF  03,64E
02CC2:  MOVFF  02,64D
02CC6:  MOVFF  01,64C
02CCA:  MOVFF  00,64B
02CCE:  MOVFF  626,652
02CD2:  MOVFF  625,651
02CD6:  MOVFF  624,650
02CDA:  MOVFF  623,64F
02CDE:  CALL   0ABC
02CE2:  MOVFF  03,62A
02CE6:  MOVFF  02,629
02CEA:  MOVFF  01,628
02CEE:  MOVFF  00,627
02CF2:  MOVFF  03,62E
02CF6:  MOVFF  02,62D
02CFA:  MOVFF  01,62C
02CFE:  MOVFF  00,62B
02D02:  RCALL  2740
02D04:  MOVLW  80
02D06:  XORWF  01,F
02D08:  BRA    2E4A
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
02D0A:  BRA    2E4A
02D0C:  MOVFF  622,64E
02D10:  MOVFF  621,64D
02D14:  MOVFF  620,64C
02D18:  MOVFF  61F,64B
02D1C:  MOVLB  6
02D1E:  CLRF   x52
02D20:  CLRF   x51
02D22:  CLRF   x50
02D24:  CLRF   x4F
02D26:  MOVLB  0
02D28:  CALL   146C
02D2C:  BNC   2D8E
02D2E:  MOVFF  626,62A
02D32:  MOVFF  625,629
02D36:  MOVFF  624,628
02D3A:  MOVFF  623,627
02D3E:  MOVLB  6
02D40:  CLRF   x2E
02D42:  CLRF   x2D
02D44:  CLRF   x2C
02D46:  MOVLW  7F
02D48:  MOVWF  x2B
02D4A:  MOVLB  0
02D4C:  CALL   2246
02D50:  MOVFF  03,62A
02D54:  MOVFF  02,629
02D58:  MOVFF  01,628
02D5C:  MOVFF  00,627
02D60:  MOVFF  03,64E
02D64:  MOVFF  02,64D
02D68:  MOVFF  01,64C
02D6C:  MOVFF  00,64B
02D70:  MOVLB  6
02D72:  CLRF   x52
02D74:  CLRF   x51
02D76:  CLRF   x50
02D78:  CLRF   x4F
02D7A:  MOVLB  0
02D7C:  CALL   146C
02D80:  BZ    2D8E
....................       return 0;
02D82:  CLRF   00
02D84:  CLRF   01
02D86:  CLRF   02
02D88:  CLRF   03
02D8A:  BRA    2E4A
....................    } else {
02D8C:  BRA    2E4A
....................       if(x != 0 || 0 >= y) {
02D8E:  MOVFF  622,64E
02D92:  MOVFF  621,64D
02D96:  MOVFF  620,64C
02D9A:  MOVFF  61F,64B
02D9E:  MOVLB  6
02DA0:  CLRF   x52
02DA2:  CLRF   x51
02DA4:  CLRF   x50
02DA6:  CLRF   x4F
02DA8:  MOVLB  0
02DAA:  CALL   146C
02DAE:  BNZ   2DD4
02DB0:  MOVFF  626,64E
02DB4:  MOVFF  625,64D
02DB8:  MOVFF  624,64C
02DBC:  MOVFF  623,64B
02DC0:  MOVLB  6
02DC2:  CLRF   x52
02DC4:  CLRF   x51
02DC6:  CLRF   x50
02DC8:  CLRF   x4F
02DCA:  MOVLB  0
02DCC:  CALL   146C
02DD0:  BC    2DD4
02DD2:  BNZ   2E42
....................          return (exp(log(x) * y));
02DD4:  MOVFF  622,62E
02DD8:  MOVFF  621,62D
02DDC:  MOVFF  620,62C
02DE0:  MOVFF  61F,62B
02DE4:  CALL   23AC
02DE8:  MOVFF  03,62A
02DEC:  MOVFF  02,629
02DF0:  MOVFF  01,628
02DF4:  MOVFF  00,627
02DF8:  MOVFF  03,64E
02DFC:  MOVFF  02,64D
02E00:  MOVFF  01,64C
02E04:  MOVFF  00,64B
02E08:  MOVFF  626,652
02E0C:  MOVFF  625,651
02E10:  MOVFF  624,650
02E14:  MOVFF  623,64F
02E18:  CALL   0ABC
02E1C:  MOVFF  03,62A
02E20:  MOVFF  02,629
02E24:  MOVFF  01,628
02E28:  MOVFF  00,627
02E2C:  MOVFF  03,62E
02E30:  MOVFF  02,62D
02E34:  MOVFF  01,62C
02E38:  MOVFF  00,62B
02E3C:  RCALL  2740
02E3E:  BRA    2E4A
....................       } else return 0;
02E40:  BRA    2E4A
02E42:  CLRF   00
02E44:  CLRF   01
02E46:  CLRF   02
02E48:  CLRF   03
....................    }
02E4A:  RETURN 0
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
*
01644:  MOVLB  6
01646:  BCF    x3D.0
....................    flag = 0;
01648:  BCF    x3D.1
....................    y = x;
0164A:  MOVFF  630,634
0164E:  MOVFF  62F,633
01652:  MOVFF  62E,632
01656:  MOVFF  62D,631
.................... 
....................    if (x < 0)
0165A:  MOVFF  630,64E
0165E:  MOVFF  62F,64D
01662:  MOVFF  62E,64C
01666:  MOVFF  62D,64B
0166A:  CLRF   x52
0166C:  CLRF   x51
0166E:  CLRF   x50
01670:  CLRF   x4F
01672:  MOVLB  0
01674:  RCALL  146C
01676:  BNC   1684
....................    {
....................       s = 1;
01678:  MOVLB  6
0167A:  BSF    x3D.0
....................       y = -y;
0167C:  MOVF   x32,W
0167E:  XORLW  80
01680:  MOVWF  x32
01682:  MOVLB  0
....................    }
.................... 
....................    if (y > 1.0)
01684:  MOVLB  6
01686:  CLRF   x4E
01688:  CLRF   x4D
0168A:  CLRF   x4C
0168C:  MOVLW  7F
0168E:  MOVWF  x4B
01690:  MOVFF  634,652
01694:  MOVFF  633,651
01698:  MOVFF  632,650
0169C:  MOVFF  631,64F
016A0:  MOVLB  0
016A2:  RCALL  146C
016A4:  BNC   16DC
....................    {
....................       y = 1.0/y;
016A6:  MOVLB  6
016A8:  CLRF   x47
016AA:  CLRF   x46
016AC:  CLRF   x45
016AE:  MOVLW  7F
016B0:  MOVWF  x44
016B2:  MOVFF  634,64B
016B6:  MOVFF  633,64A
016BA:  MOVFF  632,649
016BE:  MOVFF  631,648
016C2:  MOVLB  0
016C4:  RCALL  14E6
016C6:  MOVFF  03,634
016CA:  MOVFF  02,633
016CE:  MOVFF  01,632
016D2:  MOVFF  00,631
....................       flag = 1;
016D6:  MOVLB  6
016D8:  BSF    x3D.1
016DA:  MOVLB  0
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
016DC:  MOVLW  0A
016DE:  MOVLB  6
016E0:  MOVWF  x4E
016E2:  MOVLW  89
016E4:  MOVWF  x4D
016E6:  MOVLW  34
016E8:  MOVWF  x4C
016EA:  MOVLW  7C
016EC:  MOVWF  x4B
016EE:  MOVFF  634,652
016F2:  MOVFF  633,651
016F6:  MOVFF  632,650
016FA:  MOVFF  631,64F
016FE:  MOVLB  0
01700:  CALL   0ABC
01704:  MOVFF  03,641
01708:  MOVFF  02,640
0170C:  MOVFF  01,63F
01710:  MOVFF  00,63E
01714:  MOVFF  03,64E
01718:  MOVFF  02,64D
0171C:  MOVFF  01,64C
01720:  MOVFF  00,64B
01724:  MOVFF  634,652
01728:  MOVFF  633,651
0172C:  MOVFF  632,650
01730:  MOVFF  631,64F
01734:  CALL   0ABC
01738:  MOVFF  03,641
0173C:  MOVFF  02,640
01740:  MOVFF  01,63F
01744:  MOVFF  00,63E
01748:  BCF    FD8.1
0174A:  MOVFF  03,652
0174E:  MOVFF  02,651
01752:  MOVFF  01,650
01756:  MOVFF  00,64F
0175A:  MOVLW  7C
0175C:  MOVLB  6
0175E:  MOVWF  x56
01760:  MOVLW  79
01762:  MOVWF  x55
01764:  MOVLW  35
01766:  MOVWF  x54
01768:  MOVLW  81
0176A:  MOVWF  x53
0176C:  MOVLB  0
0176E:  CALL   0BB2
01772:  MOVFF  03,638
01776:  MOVFF  02,637
0177A:  MOVFF  01,636
0177E:  MOVFF  00,635
....................    res = res*y*y + pat[2];
01782:  MOVFF  638,64E
01786:  MOVFF  637,64D
0178A:  MOVFF  636,64C
0178E:  MOVFF  635,64B
01792:  MOVFF  634,652
01796:  MOVFF  633,651
0179A:  MOVFF  632,650
0179E:  MOVFF  631,64F
017A2:  CALL   0ABC
017A6:  MOVFF  03,641
017AA:  MOVFF  02,640
017AE:  MOVFF  01,63F
017B2:  MOVFF  00,63E
017B6:  MOVFF  03,64E
017BA:  MOVFF  02,64D
017BE:  MOVFF  01,64C
017C2:  MOVFF  00,64B
017C6:  MOVFF  634,652
017CA:  MOVFF  633,651
017CE:  MOVFF  632,650
017D2:  MOVFF  631,64F
017D6:  CALL   0ABC
017DA:  MOVFF  03,641
017DE:  MOVFF  02,640
017E2:  MOVFF  01,63F
017E6:  MOVFF  00,63E
017EA:  BCF    FD8.1
017EC:  MOVFF  03,652
017F0:  MOVFF  02,651
017F4:  MOVFF  01,650
017F8:  MOVFF  00,64F
017FC:  MOVLW  3F
017FE:  MOVLB  6
01800:  MOVWF  x56
01802:  MOVLW  02
01804:  MOVWF  x55
01806:  MOVLW  33
01808:  MOVWF  x54
0180A:  MOVLW  83
0180C:  MOVWF  x53
0180E:  MOVLB  0
01810:  CALL   0BB2
01814:  MOVFF  03,638
01818:  MOVFF  02,637
0181C:  MOVFF  01,636
01820:  MOVFF  00,635
....................    res = res*y*y + pat[3];
01824:  MOVFF  638,64E
01828:  MOVFF  637,64D
0182C:  MOVFF  636,64C
01830:  MOVFF  635,64B
01834:  MOVFF  634,652
01838:  MOVFF  633,651
0183C:  MOVFF  632,650
01840:  MOVFF  631,64F
01844:  CALL   0ABC
01848:  MOVFF  03,641
0184C:  MOVFF  02,640
01850:  MOVFF  01,63F
01854:  MOVFF  00,63E
01858:  MOVFF  03,64E
0185C:  MOVFF  02,64D
01860:  MOVFF  01,64C
01864:  MOVFF  00,64B
01868:  MOVFF  634,652
0186C:  MOVFF  633,651
01870:  MOVFF  632,650
01874:  MOVFF  631,64F
01878:  CALL   0ABC
0187C:  MOVFF  03,641
01880:  MOVFF  02,640
01884:  MOVFF  01,63F
01888:  MOVFF  00,63E
0188C:  BCF    FD8.1
0188E:  MOVFF  03,652
01892:  MOVFF  02,651
01896:  MOVFF  01,650
0189A:  MOVFF  00,64F
0189E:  MOVLW  33
018A0:  MOVLB  6
018A2:  MOVWF  x56
018A4:  MOVLW  8C
018A6:  MOVWF  x55
018A8:  MOVLW  1E
018AA:  MOVWF  x54
018AC:  MOVLW  83
018AE:  MOVWF  x53
018B0:  MOVLB  0
018B2:  CALL   0BB2
018B6:  MOVFF  03,638
018BA:  MOVFF  02,637
018BE:  MOVFF  01,636
018C2:  MOVFF  00,635
.................... 
....................    r = qat[0]*y*y + qat[1];
018C6:  MOVLB  6
018C8:  CLRF   x4E
018CA:  CLRF   x4D
018CC:  CLRF   x4C
018CE:  MOVLW  7F
018D0:  MOVWF  x4B
018D2:  MOVFF  634,652
018D6:  MOVFF  633,651
018DA:  MOVFF  632,650
018DE:  MOVFF  631,64F
018E2:  MOVLB  0
018E4:  CALL   0ABC
018E8:  MOVFF  03,641
018EC:  MOVFF  02,640
018F0:  MOVFF  01,63F
018F4:  MOVFF  00,63E
018F8:  MOVFF  03,64E
018FC:  MOVFF  02,64D
01900:  MOVFF  01,64C
01904:  MOVFF  00,64B
01908:  MOVFF  634,652
0190C:  MOVFF  633,651
01910:  MOVFF  632,650
01914:  MOVFF  631,64F
01918:  CALL   0ABC
0191C:  MOVFF  03,641
01920:  MOVFF  02,640
01924:  MOVFF  01,63F
01928:  MOVFF  00,63E
0192C:  BCF    FD8.1
0192E:  MOVFF  03,652
01932:  MOVFF  02,651
01936:  MOVFF  01,650
0193A:  MOVFF  00,64F
0193E:  MOVLW  1B
01940:  MOVLB  6
01942:  MOVWF  x56
01944:  MOVLW  E4
01946:  MOVWF  x55
01948:  MOVLW  35
0194A:  MOVWF  x54
0194C:  MOVLW  82
0194E:  MOVWF  x53
01950:  MOVLB  0
01952:  CALL   0BB2
01956:  MOVFF  03,63C
0195A:  MOVFF  02,63B
0195E:  MOVFF  01,63A
01962:  MOVFF  00,639
....................    r = r*y*y + qat[2];
01966:  MOVFF  63C,64E
0196A:  MOVFF  63B,64D
0196E:  MOVFF  63A,64C
01972:  MOVFF  639,64B
01976:  MOVFF  634,652
0197A:  MOVFF  633,651
0197E:  MOVFF  632,650
01982:  MOVFF  631,64F
01986:  CALL   0ABC
0198A:  MOVFF  03,641
0198E:  MOVFF  02,640
01992:  MOVFF  01,63F
01996:  MOVFF  00,63E
0199A:  MOVFF  03,64E
0199E:  MOVFF  02,64D
019A2:  MOVFF  01,64C
019A6:  MOVFF  00,64B
019AA:  MOVFF  634,652
019AE:  MOVFF  633,651
019B2:  MOVFF  632,650
019B6:  MOVFF  631,64F
019BA:  CALL   0ABC
019BE:  MOVFF  03,641
019C2:  MOVFF  02,640
019C6:  MOVFF  01,63F
019CA:  MOVFF  00,63E
019CE:  BCF    FD8.1
019D0:  MOVFF  03,652
019D4:  MOVFF  02,651
019D8:  MOVFF  01,650
019DC:  MOVFF  00,64F
019E0:  MOVLW  A4
019E2:  MOVLB  6
019E4:  MOVWF  x56
019E6:  MOVLW  DB
019E8:  MOVWF  x55
019EA:  MOVLW  67
019EC:  MOVWF  x54
019EE:  MOVLW  83
019F0:  MOVWF  x53
019F2:  MOVLB  0
019F4:  CALL   0BB2
019F8:  MOVFF  03,63C
019FC:  MOVFF  02,63B
01A00:  MOVFF  01,63A
01A04:  MOVFF  00,639
....................    r = r*y*y + qat[3];
01A08:  MOVFF  63C,64E
01A0C:  MOVFF  63B,64D
01A10:  MOVFF  63A,64C
01A14:  MOVFF  639,64B
01A18:  MOVFF  634,652
01A1C:  MOVFF  633,651
01A20:  MOVFF  632,650
01A24:  MOVFF  631,64F
01A28:  CALL   0ABC
01A2C:  MOVFF  03,641
01A30:  MOVFF  02,640
01A34:  MOVFF  01,63F
01A38:  MOVFF  00,63E
01A3C:  MOVFF  03,64E
01A40:  MOVFF  02,64D
01A44:  MOVFF  01,64C
01A48:  MOVFF  00,64B
01A4C:  MOVFF  634,652
01A50:  MOVFF  633,651
01A54:  MOVFF  632,650
01A58:  MOVFF  631,64F
01A5C:  CALL   0ABC
01A60:  MOVFF  03,641
01A64:  MOVFF  02,640
01A68:  MOVFF  01,63F
01A6C:  MOVFF  00,63E
01A70:  BCF    FD8.1
01A72:  MOVFF  03,652
01A76:  MOVFF  02,651
01A7A:  MOVFF  01,650
01A7E:  MOVFF  00,64F
01A82:  MOVLW  33
01A84:  MOVLB  6
01A86:  MOVWF  x56
01A88:  MOVLW  8C
01A8A:  MOVWF  x55
01A8C:  MOVLW  1E
01A8E:  MOVWF  x54
01A90:  MOVLW  83
01A92:  MOVWF  x53
01A94:  MOVLB  0
01A96:  CALL   0BB2
01A9A:  MOVFF  03,63C
01A9E:  MOVFF  02,63B
01AA2:  MOVFF  01,63A
01AA6:  MOVFF  00,639
.................... 
....................    res = y*res/r;
01AAA:  MOVFF  634,64E
01AAE:  MOVFF  633,64D
01AB2:  MOVFF  632,64C
01AB6:  MOVFF  631,64B
01ABA:  MOVFF  638,652
01ABE:  MOVFF  637,651
01AC2:  MOVFF  636,650
01AC6:  MOVFF  635,64F
01ACA:  CALL   0ABC
01ACE:  MOVFF  03,641
01AD2:  MOVFF  02,640
01AD6:  MOVFF  01,63F
01ADA:  MOVFF  00,63E
01ADE:  MOVFF  03,647
01AE2:  MOVFF  02,646
01AE6:  MOVFF  01,645
01AEA:  MOVFF  00,644
01AEE:  MOVFF  63C,64B
01AF2:  MOVFF  63B,64A
01AF6:  MOVFF  63A,649
01AFA:  MOVFF  639,648
01AFE:  RCALL  14E6
01B00:  MOVFF  03,638
01B04:  MOVFF  02,637
01B08:  MOVFF  01,636
01B0C:  MOVFF  00,635
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
01B10:  MOVLB  6
01B12:  BTFSS  x3D.1
01B14:  BRA    1B50
....................       res = PI_DIV_BY_TWO - res;
01B16:  BSF    FD8.1
01B18:  MOVLW  DB
01B1A:  MOVWF  x52
01B1C:  MOVLW  0F
01B1E:  MOVWF  x51
01B20:  MOVLW  49
01B22:  MOVWF  x50
01B24:  MOVLW  7F
01B26:  MOVWF  x4F
01B28:  MOVFF  638,656
01B2C:  MOVFF  637,655
01B30:  MOVFF  636,654
01B34:  MOVFF  635,653
01B38:  MOVLB  0
01B3A:  CALL   0BB2
01B3E:  MOVFF  03,638
01B42:  MOVFF  02,637
01B46:  MOVFF  01,636
01B4A:  MOVFF  00,635
01B4E:  MOVLB  6
....................    if (s)
01B50:  BTFSS  x3D.0
01B52:  BRA    1B5A
....................       res = -res;
01B54:  MOVF   x36,W
01B56:  XORLW  80
01B58:  MOVWF  x36
.................... 
....................    return(res);
01B5A:  MOVFF  635,00
01B5E:  MOVFF  636,01
01B62:  MOVFF  637,02
01B66:  MOVFF  638,03
01B6A:  MOVLB  0
01B6C:  RETURN 0
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
01B6E:  MOVLB  6
01B70:  BCF    x2B.0
....................    quad=0; //quadrant
01B72:  CLRF   x2C
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
01B74:  MOVFF  622,64E
01B78:  MOVFF  621,64D
01B7C:  MOVFF  620,64C
01B80:  MOVFF  61F,64B
01B84:  CLRF   x52
01B86:  CLRF   x51
01B88:  CLRF   x50
01B8A:  CLRF   x4F
01B8C:  MOVLB  0
01B8E:  RCALL  146C
01B90:  BC    1B94
01B92:  BNZ   1BBE
01B94:  MOVFF  626,64E
01B98:  MOVFF  625,64D
01B9C:  MOVFF  624,64C
01BA0:  MOVFF  623,64B
01BA4:  MOVLB  6
01BA6:  CLRF   x52
01BA8:  CLRF   x51
01BAA:  CLRF   x50
01BAC:  CLRF   x4F
01BAE:  MOVLB  0
01BB0:  RCALL  146C
01BB2:  BC    1BB6
01BB4:  BNZ   1BBA
01BB6:  MOVLW  03
01BB8:  BRA    1BBC
01BBA:  MOVLW  04
01BBC:  BRA    1BE4
01BBE:  MOVFF  626,64E
01BC2:  MOVFF  625,64D
01BC6:  MOVFF  624,64C
01BCA:  MOVFF  623,64B
01BCE:  MOVLB  6
01BD0:  CLRF   x52
01BD2:  CLRF   x51
01BD4:  CLRF   x50
01BD6:  CLRF   x4F
01BD8:  MOVLB  0
01BDA:  RCALL  146C
01BDC:  BNC   1BE2
01BDE:  MOVLW  02
01BE0:  BRA    1BE4
01BE2:  MOVLW  01
01BE4:  MOVLB  6
01BE6:  MOVWF  x2C
....................    if(y<0.0)
01BE8:  MOVFF  622,64E
01BEC:  MOVFF  621,64D
01BF0:  MOVFF  620,64C
01BF4:  MOVFF  61F,64B
01BF8:  CLRF   x52
01BFA:  CLRF   x51
01BFC:  CLRF   x50
01BFE:  CLRF   x4F
01C00:  MOVLB  0
01C02:  RCALL  146C
01C04:  BNC   1C12
....................    {
....................       sign=1;
01C06:  MOVLB  6
01C08:  BSF    x2B.0
....................       y=-y;
01C0A:  MOVF   x20,W
01C0C:  XORLW  80
01C0E:  MOVWF  x20
01C10:  MOVLB  0
....................    }
....................    if(x<0.0)
01C12:  MOVFF  626,64E
01C16:  MOVFF  625,64D
01C1A:  MOVFF  624,64C
01C1E:  MOVFF  623,64B
01C22:  MOVLB  6
01C24:  CLRF   x52
01C26:  CLRF   x51
01C28:  CLRF   x50
01C2A:  CLRF   x4F
01C2C:  MOVLB  0
01C2E:  RCALL  146C
01C30:  BNC   1C3C
....................    {
....................       x=-x;
01C32:  MOVLB  6
01C34:  MOVF   x24,W
01C36:  XORLW  80
01C38:  MOVWF  x24
01C3A:  MOVLB  0
....................    }
....................    if (x==0.0)
01C3C:  MOVFF  626,64E
01C40:  MOVFF  625,64D
01C44:  MOVFF  624,64C
01C48:  MOVFF  623,64B
01C4C:  MOVLB  6
01C4E:  CLRF   x52
01C50:  CLRF   x51
01C52:  CLRF   x50
01C54:  CLRF   x4F
01C56:  MOVLB  0
01C58:  RCALL  146C
01C5A:  BNZ   1CB0
....................    {
....................       if(y==0.0)
01C5C:  MOVFF  622,64E
01C60:  MOVFF  621,64D
01C64:  MOVFF  620,64C
01C68:  MOVFF  61F,64B
01C6C:  MOVLB  6
01C6E:  CLRF   x52
01C70:  CLRF   x51
01C72:  CLRF   x50
01C74:  CLRF   x4F
01C76:  MOVLB  0
01C78:  CALL   146C
01C7C:  BNZ   1C80
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
01C7E:  BRA    1CAE
....................       else
....................       {
....................          if(sign)
01C80:  MOVLB  6
01C82:  BTFSS  x2B.0
01C84:  BRA    1C9A
....................          {
....................          return (-(PI_DIV_BY_TWO));
01C86:  MOVLW  7F
01C88:  MOVWF  00
01C8A:  MOVLW  C9
01C8C:  MOVWF  01
01C8E:  MOVLW  0F
01C90:  MOVWF  02
01C92:  MOVLW  DB
01C94:  MOVWF  03
01C96:  BRA    1DE8
....................          }
01C98:  BRA    1CAC
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
01C9A:  MOVLW  7F
01C9C:  MOVWF  00
01C9E:  MOVLW  49
01CA0:  MOVWF  01
01CA2:  MOVLW  0F
01CA4:  MOVWF  02
01CA6:  MOVLW  DB
01CA8:  MOVWF  03
01CAA:  BRA    1DE8
01CAC:  MOVLB  0
....................          }
....................       }
....................    }
01CAE:  BRA    1DE6
....................    else
....................    {
....................       z=y/x;
01CB0:  MOVFF  622,647
01CB4:  MOVFF  621,646
01CB8:  MOVFF  620,645
01CBC:  MOVFF  61F,644
01CC0:  MOVFF  626,64B
01CC4:  MOVFF  625,64A
01CC8:  MOVFF  624,649
01CCC:  MOVFF  623,648
01CD0:  RCALL  14E6
01CD2:  MOVFF  03,62A
01CD6:  MOVFF  02,629
01CDA:  MOVFF  01,628
01CDE:  MOVFF  00,627
....................       switch(quad)
01CE2:  MOVLW  01
01CE4:  MOVLB  6
01CE6:  SUBWF  x2C,W
01CE8:  ADDLW  FC
01CEA:  BTFSC  FD8.0
01CEC:  BRA    1DE8
01CEE:  ADDLW  04
01CF0:  MOVLB  0
01CF2:  GOTO   1DEE
....................       {
....................          case 1:
....................          {
....................             return atan(z);
01CF6:  MOVFF  62A,630
01CFA:  MOVFF  629,62F
01CFE:  MOVFF  628,62E
01D02:  MOVFF  627,62D
01D06:  RCALL  1644
01D08:  MOVLB  6
01D0A:  BRA    1DE8
....................             break;
01D0C:  BRA    1DE8
01D0E:  MOVLB  0
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
01D10:  MOVFF  62A,630
01D14:  MOVFF  629,62F
01D18:  MOVFF  628,62E
01D1C:  MOVFF  627,62D
01D20:  RCALL  1644
01D22:  MOVFF  FEA,62E
01D26:  MOVFF  FE9,62D
01D2A:  BSF    FD8.1
01D2C:  MOVLW  DB
01D2E:  MOVLB  6
01D30:  MOVWF  x52
01D32:  MOVLW  0F
01D34:  MOVWF  x51
01D36:  MOVLW  49
01D38:  MOVWF  x50
01D3A:  MOVLW  80
01D3C:  MOVWF  x4F
01D3E:  MOVFF  03,656
01D42:  MOVFF  02,655
01D46:  MOVFF  01,654
01D4A:  MOVFF  00,653
01D4E:  MOVLB  0
01D50:  CALL   0BB2
01D54:  MOVFF  62E,FEA
01D58:  MOVFF  62D,FE9
01D5C:  MOVLB  6
01D5E:  BRA    1DE8
....................             break;
01D60:  BRA    1DE8
01D62:  MOVLB  0
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
01D64:  MOVFF  62A,630
01D68:  MOVFF  629,62F
01D6C:  MOVFF  628,62E
01D70:  MOVFF  627,62D
01D74:  RCALL  1644
01D76:  MOVFF  03,630
01D7A:  MOVFF  02,62F
01D7E:  MOVFF  01,62E
01D82:  MOVFF  00,62D
01D86:  MOVFF  FEA,632
01D8A:  MOVFF  FE9,631
01D8E:  BSF    FD8.1
01D90:  MOVFF  03,652
01D94:  MOVFF  02,651
01D98:  MOVFF  01,650
01D9C:  MOVFF  00,64F
01DA0:  MOVLW  DB
01DA2:  MOVLB  6
01DA4:  MOVWF  x56
01DA6:  MOVLW  0F
01DA8:  MOVWF  x55
01DAA:  MOVLW  49
01DAC:  MOVWF  x54
01DAE:  MOVLW  80
01DB0:  MOVWF  x53
01DB2:  MOVLB  0
01DB4:  CALL   0BB2
01DB8:  MOVFF  632,FEA
01DBC:  MOVFF  631,FE9
01DC0:  MOVLB  6
01DC2:  BRA    1DE8
....................             break;
01DC4:  BRA    1DE8
01DC6:  MOVLB  0
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
01DC8:  MOVFF  62A,630
01DCC:  MOVFF  629,62F
01DD0:  MOVFF  628,62E
01DD4:  MOVFF  627,62D
01DD8:  RCALL  1644
01DDA:  MOVLW  80
01DDC:  XORWF  01,F
01DDE:  MOVLB  6
01DE0:  BRA    1DE8
....................             break;
01DE2:  BRA    1DE8
01DE4:  MOVLB  0
01DE6:  MOVLB  6
....................          }
....................       }
....................    }
01DE8:  MOVLB  0
01DEA:  GOTO   34C4 (RETURN)
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... #define sensorSampleRate 50 // 50mS delay between each sensor sample = 200ms cadence 
.................... 
.................... #define maxCount 16777216.0   // ADC max count
.................... #define vRef 2.048            // ADC vRef
.................... 
.................... #define sc sensorCal
.................... 
.................... #define vMonN15   6
.................... #define vMon200   16
.................... #define vMon5V6   24
.................... #define vMon5VA   25
.................... #define vMon3V6X  17
.................... #define vMon3V3A  27
.................... #define vMon3V3D  26
.................... 
.................... struct sensorMonitorData
.................... {
....................    boolean dataReady;
....................    boolean adcBusy;
.................... } smData[2] = 
.................... {
....................    {false, false},
....................    {false, false}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* INTERNAL MONITOR task - gets voltages                                     */
.................... /* gets one value each time the task is run                                  */
.................... /*****************************************************************************/
.................... void internal_monitor_task()
.................... {
....................    static int8 state = 0;
....................    if (adc_done())
*
00E2A:  MOVLB  F
00E2C:  BTFSC  x5B.0
00E2E:  BRA    137A
....................    {
....................       switch (state)
00E30:  MOVLB  1
00E32:  MOVF   x65,W
00E34:  ADDLW  F9
00E36:  BTFSC  FD8.0
00E38:  BRA    1378
00E3A:  ADDLW  07
00E3C:  MOVLB  0
00E3E:  GOTO   1380
....................       {
....................          case 0:     // vMonN15
....................             monitorVals.vN15 = read_adc(ADC_READ_ONLY) * monCal.vN15[1] + monCal.vN15[0];
00E42:  MOVLB  F
00E44:  BTFSC  x5B.0
00E46:  BRA    0E44
00E48:  MOVFF  F5F,02
00E4C:  MOVFF  F5E,01
00E50:  MOVFF  02,5EF
00E54:  MOVFF  01,5EE
00E58:  MOVFF  02,650
00E5C:  MOVFF  01,64F
00E60:  MOVLB  0
00E62:  RCALL  0A86
00E64:  MOVFF  03,64E
00E68:  MOVFF  02,64D
00E6C:  MOVFF  01,64C
00E70:  MOVFF  00,64B
00E74:  MOVFF  B9,652
00E78:  MOVFF  B8,651
00E7C:  MOVFF  B7,650
00E80:  MOVFF  B6,64F
00E84:  RCALL  0ABC
00E86:  MOVFF  03,5F1
00E8A:  MOVFF  02,5F0
00E8E:  MOVFF  01,5EF
00E92:  MOVFF  00,5EE
00E96:  BCF    FD8.1
00E98:  MOVFF  03,652
00E9C:  MOVFF  02,651
00EA0:  MOVFF  01,650
00EA4:  MOVFF  00,64F
00EA8:  MOVFF  B5,656
00EAC:  MOVFF  B4,655
00EB0:  MOVFF  B3,654
00EB4:  MOVFF  B2,653
00EB8:  RCALL  0BB2
00EBA:  MOVFF  03,F6
00EBE:  MOVFF  02,F5
00EC2:  MOVFF  01,F4
00EC6:  MOVFF  00,F3
....................             set_adc_channel(vMon200);
00ECA:  MOVLB  F
00ECC:  MOVF   x5A,W
00ECE:  ANDLW  3F
00ED0:  MOVWF  01
00ED2:  MOVLW  10
00ED4:  MOVWF  x5A
00ED6:  BTFSS  x5B.7
00ED8:  BRA    0EE8
00EDA:  MOVF   01,W
00EDC:  SUBLW  10
00EDE:  BZ    0EE8
00EE0:  BSF    x5B.0
00EE2:  NOP   
00EE4:  BTFSC  x5B.0
00EE6:  BRA    0EE4
....................             delay_ms(10);
00EE8:  MOVLW  0A
00EEA:  MOVLB  5
00EEC:  MOVWF  xF3
00EEE:  MOVLB  0
00EF0:  CALL   03F6
....................             read_adc(ADC_START_ONLY);
00EF4:  MOVLB  F
00EF6:  BSF    x5B.0
00EF8:  NOP   
....................             state = 1;
00EFA:  MOVLW  01
00EFC:  MOVLB  1
00EFE:  MOVWF  x65
....................          break;
00F00:  BRA    1378
....................          
....................          case 1:     // vMon200
....................             monitorVals.v200 = read_adc(ADC_READ_ONLY) * monCal.v200[1] + monCal.v200[0];
00F02:  MOVLB  F
00F04:  BTFSC  x5B.0
00F06:  BRA    0F04
00F08:  MOVFF  F5F,02
00F0C:  MOVFF  F5E,01
00F10:  MOVFF  02,5EF
00F14:  MOVFF  01,5EE
00F18:  MOVFF  02,650
00F1C:  MOVFF  01,64F
00F20:  MOVLB  0
00F22:  RCALL  0A86
00F24:  MOVFF  03,64E
00F28:  MOVFF  02,64D
00F2C:  MOVFF  01,64C
00F30:  MOVFF  00,64B
00F34:  MOVFF  C1,652
00F38:  MOVFF  C0,651
00F3C:  MOVFF  BF,650
00F40:  MOVFF  BE,64F
00F44:  RCALL  0ABC
00F46:  MOVFF  03,5F1
00F4A:  MOVFF  02,5F0
00F4E:  MOVFF  01,5EF
00F52:  MOVFF  00,5EE
00F56:  BCF    FD8.1
00F58:  MOVFF  03,652
00F5C:  MOVFF  02,651
00F60:  MOVFF  01,650
00F64:  MOVFF  00,64F
00F68:  MOVFF  BD,656
00F6C:  MOVFF  BC,655
00F70:  MOVFF  BB,654
00F74:  MOVFF  BA,653
00F78:  RCALL  0BB2
00F7A:  MOVFF  03,FA
00F7E:  MOVFF  02,F9
00F82:  MOVFF  01,F8
00F86:  MOVFF  00,F7
....................             set_adc_channel(vMon5V6);
00F8A:  MOVLB  F
00F8C:  MOVF   x5A,W
00F8E:  ANDLW  3F
00F90:  MOVWF  01
00F92:  MOVLW  18
00F94:  MOVWF  x5A
00F96:  BTFSS  x5B.7
00F98:  BRA    0FA8
00F9A:  MOVF   01,W
00F9C:  SUBLW  18
00F9E:  BZ    0FA8
00FA0:  BSF    x5B.0
00FA2:  NOP   
00FA4:  BTFSC  x5B.0
00FA6:  BRA    0FA4
....................             delay_ms(10);
00FA8:  MOVLW  0A
00FAA:  MOVLB  5
00FAC:  MOVWF  xF3
00FAE:  MOVLB  0
00FB0:  CALL   03F6
....................             read_adc(ADC_START_ONLY);
00FB4:  MOVLB  F
00FB6:  BSF    x5B.0
00FB8:  NOP   
....................             state = 2;
00FBA:  MOVLW  02
00FBC:  MOVLB  1
00FBE:  MOVWF  x65
....................          break;
00FC0:  BRA    1378
....................          
....................          case 2:     // vMon5V6
....................             monitorVals.v5V6 = read_adc(ADC_READ_ONLY) * monCal.v5V6[1] + monCal.v5V6[0];
00FC2:  MOVLB  F
00FC4:  BTFSC  x5B.0
00FC6:  BRA    0FC4
00FC8:  MOVFF  F5F,02
00FCC:  MOVFF  F5E,01
00FD0:  MOVFF  02,5EF
00FD4:  MOVFF  01,5EE
00FD8:  MOVFF  02,650
00FDC:  MOVFF  01,64F
00FE0:  MOVLB  0
00FE2:  RCALL  0A86
00FE4:  MOVFF  03,64E
00FE8:  MOVFF  02,64D
00FEC:  MOVFF  01,64C
00FF0:  MOVFF  00,64B
00FF4:  MOVFF  C9,652
00FF8:  MOVFF  C8,651
00FFC:  MOVFF  C7,650
01000:  MOVFF  C6,64F
01004:  RCALL  0ABC
01006:  MOVFF  03,5F1
0100A:  MOVFF  02,5F0
0100E:  MOVFF  01,5EF
01012:  MOVFF  00,5EE
01016:  BCF    FD8.1
01018:  MOVFF  03,652
0101C:  MOVFF  02,651
01020:  MOVFF  01,650
01024:  MOVFF  00,64F
01028:  MOVFF  C5,656
0102C:  MOVFF  C4,655
01030:  MOVFF  C3,654
01034:  MOVFF  C2,653
01038:  RCALL  0BB2
0103A:  MOVFF  03,FE
0103E:  MOVFF  02,FD
01042:  MOVFF  01,FC
01046:  MOVFF  00,FB
....................             set_adc_channel(vMon5VA);
0104A:  MOVLB  F
0104C:  MOVF   x5A,W
0104E:  ANDLW  3F
01050:  MOVWF  01
01052:  MOVLW  19
01054:  MOVWF  x5A
01056:  BTFSS  x5B.7
01058:  BRA    1068
0105A:  MOVF   01,W
0105C:  SUBLW  19
0105E:  BZ    1068
01060:  BSF    x5B.0
01062:  NOP   
01064:  BTFSC  x5B.0
01066:  BRA    1064
....................             delay_ms(10);
01068:  MOVLW  0A
0106A:  MOVLB  5
0106C:  MOVWF  xF3
0106E:  MOVLB  0
01070:  CALL   03F6
....................             read_adc(ADC_START_ONLY);
01074:  MOVLB  F
01076:  BSF    x5B.0
01078:  NOP   
....................             state = 3;
0107A:  MOVLW  03
0107C:  MOVLB  1
0107E:  MOVWF  x65
....................          break;
01080:  BRA    1378
....................          
....................          case 3:     // vMon5VA
....................             monitorVals.v5VA = read_adc(ADC_READ_ONLY) * monCal.v5VA[1] + monCal.v5VA[0];
01082:  MOVLB  F
01084:  BTFSC  x5B.0
01086:  BRA    1084
01088:  MOVFF  F5F,02
0108C:  MOVFF  F5E,01
01090:  MOVFF  02,5EF
01094:  MOVFF  01,5EE
01098:  MOVFF  02,650
0109C:  MOVFF  01,64F
010A0:  MOVLB  0
010A2:  RCALL  0A86
010A4:  MOVFF  03,64E
010A8:  MOVFF  02,64D
010AC:  MOVFF  01,64C
010B0:  MOVFF  00,64B
010B4:  MOVFF  D1,652
010B8:  MOVFF  D0,651
010BC:  MOVFF  CF,650
010C0:  MOVFF  CE,64F
010C4:  RCALL  0ABC
010C6:  MOVFF  03,5F1
010CA:  MOVFF  02,5F0
010CE:  MOVFF  01,5EF
010D2:  MOVFF  00,5EE
010D6:  BCF    FD8.1
010D8:  MOVFF  03,652
010DC:  MOVFF  02,651
010E0:  MOVFF  01,650
010E4:  MOVFF  00,64F
010E8:  MOVFF  CD,656
010EC:  MOVFF  CC,655
010F0:  MOVFF  CB,654
010F4:  MOVFF  CA,653
010F8:  RCALL  0BB2
010FA:  MOVFF  03,102
010FE:  MOVFF  02,101
01102:  MOVFF  01,100
01106:  MOVFF  00,FF
....................             set_adc_channel(vMon3V6X);
0110A:  MOVLB  F
0110C:  MOVF   x5A,W
0110E:  ANDLW  3F
01110:  MOVWF  01
01112:  MOVLW  11
01114:  MOVWF  x5A
01116:  BTFSS  x5B.7
01118:  BRA    1128
0111A:  MOVF   01,W
0111C:  SUBLW  11
0111E:  BZ    1128
01120:  BSF    x5B.0
01122:  NOP   
01124:  BTFSC  x5B.0
01126:  BRA    1124
....................             delay_ms(10);
01128:  MOVLW  0A
0112A:  MOVLB  5
0112C:  MOVWF  xF3
0112E:  MOVLB  0
01130:  CALL   03F6
....................             read_adc(ADC_START_ONLY);
01134:  MOVLB  F
01136:  BSF    x5B.0
01138:  NOP   
....................             state = 4;
0113A:  MOVLW  04
0113C:  MOVLB  1
0113E:  MOVWF  x65
....................          break;
01140:  BRA    1378
....................          
....................          case 4:     // vMon3V6X
....................             monitorVals.v3V6X = read_adc(ADC_READ_ONLY) * monCal.v3V6X[1] + monCal.v3V6X[0];
01142:  MOVLB  F
01144:  BTFSC  x5B.0
01146:  BRA    1144
01148:  MOVFF  F5F,02
0114C:  MOVFF  F5E,01
01150:  MOVFF  02,5EF
01154:  MOVFF  01,5EE
01158:  MOVFF  02,650
0115C:  MOVFF  01,64F
01160:  MOVLB  0
01162:  RCALL  0A86
01164:  MOVFF  03,64E
01168:  MOVFF  02,64D
0116C:  MOVFF  01,64C
01170:  MOVFF  00,64B
01174:  MOVFF  D9,652
01178:  MOVFF  D8,651
0117C:  MOVFF  D7,650
01180:  MOVFF  D6,64F
01184:  RCALL  0ABC
01186:  MOVFF  03,5F1
0118A:  MOVFF  02,5F0
0118E:  MOVFF  01,5EF
01192:  MOVFF  00,5EE
01196:  BCF    FD8.1
01198:  MOVFF  03,652
0119C:  MOVFF  02,651
011A0:  MOVFF  01,650
011A4:  MOVFF  00,64F
011A8:  MOVFF  D5,656
011AC:  MOVFF  D4,655
011B0:  MOVFF  D3,654
011B4:  MOVFF  D2,653
011B8:  RCALL  0BB2
011BA:  MOVFF  03,106
011BE:  MOVFF  02,105
011C2:  MOVFF  01,104
011C6:  MOVFF  00,103
....................             set_adc_channel(vMon3V3A);
011CA:  MOVLB  F
011CC:  MOVF   x5A,W
011CE:  ANDLW  3F
011D0:  MOVWF  01
011D2:  MOVLW  1B
011D4:  MOVWF  x5A
011D6:  BTFSS  x5B.7
011D8:  BRA    11E8
011DA:  MOVF   01,W
011DC:  SUBLW  1B
011DE:  BZ    11E8
011E0:  BSF    x5B.0
011E2:  NOP   
011E4:  BTFSC  x5B.0
011E6:  BRA    11E4
....................             delay_ms(10);
011E8:  MOVLW  0A
011EA:  MOVLB  5
011EC:  MOVWF  xF3
011EE:  MOVLB  0
011F0:  CALL   03F6
....................             read_adc(ADC_START_ONLY);
011F4:  MOVLB  F
011F6:  BSF    x5B.0
011F8:  NOP   
....................             state = 5;
011FA:  MOVLW  05
011FC:  MOVLB  1
011FE:  MOVWF  x65
....................          break;
01200:  BRA    1378
....................          
....................          case 5:     // vMon3V3A
....................             monitorVals.v3V3A = read_adc(ADC_READ_ONLY) * monCal.v3V3A[1] + monCal.v3V3A[0];
01202:  MOVLB  F
01204:  BTFSC  x5B.0
01206:  BRA    1204
01208:  MOVFF  F5F,02
0120C:  MOVFF  F5E,01
01210:  MOVFF  02,5EF
01214:  MOVFF  01,5EE
01218:  MOVFF  02,650
0121C:  MOVFF  01,64F
01220:  MOVLB  0
01222:  RCALL  0A86
01224:  MOVFF  03,64E
01228:  MOVFF  02,64D
0122C:  MOVFF  01,64C
01230:  MOVFF  00,64B
01234:  MOVFF  E1,652
01238:  MOVFF  E0,651
0123C:  MOVFF  DF,650
01240:  MOVFF  DE,64F
01244:  RCALL  0ABC
01246:  MOVFF  03,5F1
0124A:  MOVFF  02,5F0
0124E:  MOVFF  01,5EF
01252:  MOVFF  00,5EE
01256:  BCF    FD8.1
01258:  MOVFF  03,652
0125C:  MOVFF  02,651
01260:  MOVFF  01,650
01264:  MOVFF  00,64F
01268:  MOVFF  DD,656
0126C:  MOVFF  DC,655
01270:  MOVFF  DB,654
01274:  MOVFF  DA,653
01278:  RCALL  0BB2
0127A:  MOVFF  03,10A
0127E:  MOVFF  02,109
01282:  MOVFF  01,108
01286:  MOVFF  00,107
....................             set_adc_channel(vMon3V3D);
0128A:  MOVLB  F
0128C:  MOVF   x5A,W
0128E:  ANDLW  3F
01290:  MOVWF  01
01292:  MOVLW  1A
01294:  MOVWF  x5A
01296:  BTFSS  x5B.7
01298:  BRA    12A8
0129A:  MOVF   01,W
0129C:  SUBLW  1A
0129E:  BZ    12A8
012A0:  BSF    x5B.0
012A2:  NOP   
012A4:  BTFSC  x5B.0
012A6:  BRA    12A4
....................             delay_ms(10);
012A8:  MOVLW  0A
012AA:  MOVLB  5
012AC:  MOVWF  xF3
012AE:  MOVLB  0
012B0:  CALL   03F6
....................             read_adc(ADC_START_ONLY);
012B4:  MOVLB  F
012B6:  BSF    x5B.0
012B8:  NOP   
....................             state = 6;
012BA:  MOVLW  06
012BC:  MOVLB  1
012BE:  MOVWF  x65
....................          break;
012C0:  BRA    1378
....................          
....................          case 6:    // vMon3V3D
....................             monitorVals.v3V3D = read_adc(ADC_READ_ONLY) * monCal.v3V3D[1] + monCal.v3V3D[0];
012C2:  MOVLB  F
012C4:  BTFSC  x5B.0
012C6:  BRA    12C4
012C8:  MOVFF  F5F,02
012CC:  MOVFF  F5E,01
012D0:  MOVFF  02,5EF
012D4:  MOVFF  01,5EE
012D8:  MOVFF  02,650
012DC:  MOVFF  01,64F
012E0:  MOVLB  0
012E2:  CALL   0A86
012E6:  MOVFF  03,64E
012EA:  MOVFF  02,64D
012EE:  MOVFF  01,64C
012F2:  MOVFF  00,64B
012F6:  MOVFF  E9,652
012FA:  MOVFF  E8,651
012FE:  MOVFF  E7,650
01302:  MOVFF  E6,64F
01306:  CALL   0ABC
0130A:  MOVFF  03,5F1
0130E:  MOVFF  02,5F0
01312:  MOVFF  01,5EF
01316:  MOVFF  00,5EE
0131A:  BCF    FD8.1
0131C:  MOVFF  03,652
01320:  MOVFF  02,651
01324:  MOVFF  01,650
01328:  MOVFF  00,64F
0132C:  MOVFF  E5,656
01330:  MOVFF  E4,655
01334:  MOVFF  E3,654
01338:  MOVFF  E2,653
0133C:  RCALL  0BB2
0133E:  MOVFF  03,10E
01342:  MOVFF  02,10D
01346:  MOVFF  01,10C
0134A:  MOVFF  00,10B
....................             set_adc_channel(vMonN15);
0134E:  MOVLB  F
01350:  MOVF   x5A,W
01352:  ANDLW  3F
01354:  MOVWF  01
01356:  MOVLW  06
01358:  MOVWF  x5A
0135A:  BTFSS  x5B.7
0135C:  BRA    136C
0135E:  MOVF   01,W
01360:  SUBLW  06
01362:  BZ    136C
01364:  BSF    x5B.0
01366:  NOP   
01368:  BTFSC  x5B.0
0136A:  BRA    1368
....................             read_adc(ADC_START_ONLY);
0136C:  BSF    x5B.0
0136E:  NOP   
....................             state = 0;
01370:  MOVLB  1
01372:  CLRF   x65
....................          break;   
01374:  BRA    1378
01376:  MOVLB  1
01378:  MOVLB  F
....................       }
....................    }
0137A:  MOVLB  0
0137C:  GOTO   9E94 (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* PROCESS ADC SENSOR DATA                                                   */
.................... /*****************************************************************************/
.................... void sensor_process_data(int8 ch, signed int32 sinRawCounts, signed int32 cosRawCounts)
.................... {
....................    adcVals[ch].sinLast = adcVals[ch].sinCounts;
*
02E4C:  MOVLB  5
02E4E:  MOVF   xF6,W
02E50:  MULLW  21
02E52:  MOVF   FF3,W
02E54:  MOVLB  6
02E56:  CLRF   x08
02E58:  MOVWF  x07
02E5A:  MOVLW  10
02E5C:  ADDWF  x07,W
02E5E:  MOVWF  01
02E60:  MOVLW  00
02E62:  ADDWFC x08,W
02E64:  MOVWF  03
02E66:  MOVF   01,W
02E68:  ADDLW  0F
02E6A:  MOVWF  01
02E6C:  MOVLW  01
02E6E:  ADDWFC 03,F
02E70:  MOVFF  01,607
02E74:  MOVFF  03,608
02E78:  MOVLB  5
02E7A:  MOVF   xF6,W
02E7C:  MULLW  21
02E7E:  MOVF   FF3,W
02E80:  MOVLB  6
02E82:  CLRF   x0A
02E84:  MOVWF  x09
02E86:  MOVLW  08
02E88:  ADDWF  x09,W
02E8A:  MOVWF  01
02E8C:  MOVLW  00
02E8E:  ADDWFC x0A,W
02E90:  MOVWF  03
02E92:  MOVF   01,W
02E94:  ADDLW  0F
02E96:  MOVWF  FE9
02E98:  MOVLW  01
02E9A:  ADDWFC 03,W
02E9C:  MOVWF  FEA
02E9E:  MOVFF  FEF,00
02EA2:  MOVFF  FEC,01
02EA6:  MOVFF  FEC,02
02EAA:  MOVFF  FEC,03
02EAE:  MOVFF  608,FEA
02EB2:  MOVFF  607,FE9
02EB6:  MOVFF  00,FEF
02EBA:  MOVFF  01,FEC
02EBE:  MOVFF  02,FEC
02EC2:  MOVFF  03,FEC
....................    adcVals[ch].cosLast = adcVals[ch].cosCounts;
02EC6:  MOVLB  5
02EC8:  MOVF   xF6,W
02ECA:  MULLW  21
02ECC:  MOVF   FF3,W
02ECE:  MOVLB  6
02ED0:  CLRF   x08
02ED2:  MOVWF  x07
02ED4:  MOVLW  14
02ED6:  ADDWF  x07,W
02ED8:  MOVWF  01
02EDA:  MOVLW  00
02EDC:  ADDWFC x08,W
02EDE:  MOVWF  03
02EE0:  MOVF   01,W
02EE2:  ADDLW  0F
02EE4:  MOVWF  01
02EE6:  MOVLW  01
02EE8:  ADDWFC 03,F
02EEA:  MOVFF  01,607
02EEE:  MOVFF  03,608
02EF2:  MOVLB  5
02EF4:  MOVF   xF6,W
02EF6:  MULLW  21
02EF8:  MOVF   FF3,W
02EFA:  MOVLB  6
02EFC:  CLRF   x0A
02EFE:  MOVWF  x09
02F00:  MOVLW  0C
02F02:  ADDWF  x09,W
02F04:  MOVWF  01
02F06:  MOVLW  00
02F08:  ADDWFC x0A,W
02F0A:  MOVWF  03
02F0C:  MOVF   01,W
02F0E:  ADDLW  0F
02F10:  MOVWF  FE9
02F12:  MOVLW  01
02F14:  ADDWFC 03,W
02F16:  MOVWF  FEA
02F18:  MOVFF  FEF,00
02F1C:  MOVFF  FEC,01
02F20:  MOVFF  FEC,02
02F24:  MOVFF  FEC,03
02F28:  MOVFF  608,FEA
02F2C:  MOVFF  607,FE9
02F30:  MOVFF  00,FEF
02F34:  MOVFF  01,FEC
02F38:  MOVFF  02,FEC
02F3C:  MOVFF  03,FEC
....................    
....................    adcVals[ch].sinRaw = (float)sinRawCounts;
02F40:  MOVLB  5
02F42:  MOVF   xF6,W
02F44:  MULLW  21
02F46:  MOVF   FF3,W
02F48:  MOVLB  6
02F4A:  CLRF   x08
02F4C:  MOVWF  x07
02F4E:  MOVLW  0F
02F50:  ADDWF  x07,W
02F52:  MOVWF  FE9
02F54:  MOVLW  01
02F56:  ADDWFC x08,W
02F58:  MOVWF  FEA
02F5A:  MOVFF  5FA,618
02F5E:  MOVFF  5F9,617
02F62:  MOVFF  5F8,616
02F66:  MOVFF  5F7,615
02F6A:  MOVLB  0
02F6C:  CALL   1412
02F70:  MOVFF  00,FEF
02F74:  MOVFF  01,FEC
02F78:  MOVFF  02,FEC
02F7C:  MOVFF  03,FEC
....................    adcVals[ch].cosRaw = (float)cosRawCounts;
02F80:  MOVLB  5
02F82:  MOVF   xF6,W
02F84:  MULLW  21
02F86:  MOVF   FF3,W
02F88:  MOVLB  6
02F8A:  CLRF   x08
02F8C:  MOVWF  x07
02F8E:  MOVLW  04
02F90:  ADDWF  x07,W
02F92:  MOVWF  01
02F94:  MOVLW  00
02F96:  ADDWFC x08,W
02F98:  MOVWF  03
02F9A:  MOVF   01,W
02F9C:  ADDLW  0F
02F9E:  MOVWF  FE9
02FA0:  MOVLW  01
02FA2:  ADDWFC 03,W
02FA4:  MOVWF  FEA
02FA6:  MOVFF  5FE,618
02FAA:  MOVFF  5FD,617
02FAE:  MOVFF  5FC,616
02FB2:  MOVFF  5FB,615
02FB6:  MOVLB  0
02FB8:  CALL   1412
02FBC:  MOVFF  00,FEF
02FC0:  MOVFF  01,FEC
02FC4:  MOVFF  02,FEC
02FC8:  MOVFF  03,FEC
....................    
....................    adcVals[ch].sinCounts = adcVals[ch].sinRaw * adcCal[ch].sinGain + adcCal[ch].sinOS;
02FCC:  MOVLB  5
02FCE:  MOVF   xF6,W
02FD0:  MULLW  21
02FD2:  MOVF   FF3,W
02FD4:  MOVLB  6
02FD6:  CLRF   x08
02FD8:  MOVWF  x07
02FDA:  MOVLW  08
02FDC:  ADDWF  x07,W
02FDE:  MOVWF  01
02FE0:  MOVLW  00
02FE2:  ADDWFC x08,W
02FE4:  MOVWF  03
02FE6:  MOVF   01,W
02FE8:  ADDLW  0F
02FEA:  MOVWF  01
02FEC:  MOVLW  01
02FEE:  ADDWFC 03,F
02FF0:  MOVFF  01,607
02FF4:  MOVFF  03,608
02FF8:  MOVLB  5
02FFA:  MOVF   xF6,W
02FFC:  MULLW  21
02FFE:  MOVF   FF3,W
03000:  MOVLB  6
03002:  CLRF   x0A
03004:  MOVWF  x09
03006:  MOVLW  0F
03008:  ADDWF  x09,W
0300A:  MOVWF  FE9
0300C:  MOVLW  01
0300E:  ADDWFC x0A,W
03010:  MOVWF  FEA
03012:  MOVFF  FEF,64B
03016:  MOVFF  FEC,64C
0301A:  MOVFF  FEC,64D
0301E:  MOVFF  FEC,64E
03022:  MOVLB  5
03024:  MOVF   xF6,W
03026:  MULLW  10
03028:  MOVF   FF3,W
0302A:  MOVLB  6
0302C:  CLRF   x10
0302E:  MOVWF  x0F
03030:  MOVLW  08
03032:  ADDWF  x0F,W
03034:  MOVWF  01
03036:  MOVLW  00
03038:  ADDWFC x10,W
0303A:  MOVWF  03
0303C:  MOVF   01,W
0303E:  ADDLW  62
03040:  MOVWF  FE9
03042:  MOVLW  00
03044:  ADDWFC 03,W
03046:  MOVWF  FEA
03048:  MOVFF  FEF,64F
0304C:  MOVFF  FEC,01
03050:  MOVFF  FEC,02
03054:  MOVFF  FEC,03
03058:  MOVFF  03,652
0305C:  MOVFF  02,651
03060:  MOVFF  01,650
03064:  MOVLB  0
03066:  CALL   0ABC
0306A:  MOVFF  03,652
0306E:  MOVFF  02,651
03072:  MOVFF  01,650
03076:  MOVFF  00,64F
0307A:  MOVLB  5
0307C:  MOVF   xF6,W
0307E:  MULLW  10
03080:  MOVF   FF3,W
03082:  MOVLB  6
03084:  CLRF   x10
03086:  MOVWF  x0F
03088:  MOVLW  62
0308A:  ADDWF  x0F,W
0308C:  MOVWF  FE9
0308E:  MOVLW  00
03090:  ADDWFC x10,W
03092:  MOVWF  FEA
03094:  MOVFF  FEF,653
03098:  MOVFF  FEC,01
0309C:  MOVFF  FEC,02
030A0:  MOVFF  FEC,03
030A4:  BCF    FD8.1
030A6:  MOVFF  03,656
030AA:  MOVFF  02,655
030AE:  MOVFF  01,654
030B2:  MOVLB  0
030B4:  CALL   0BB2
030B8:  MOVFF  608,FEA
030BC:  MOVFF  607,FE9
030C0:  MOVFF  00,FEF
030C4:  MOVFF  01,FEC
030C8:  MOVFF  02,FEC
030CC:  MOVFF  03,FEC
....................    adcVals[ch].cosCounts = adcVals[ch].cosRaw * adcCal[ch].cosGain + adcCal[ch].cosOS;
030D0:  MOVLB  5
030D2:  MOVF   xF6,W
030D4:  MULLW  21
030D6:  MOVF   FF3,W
030D8:  MOVLB  6
030DA:  CLRF   x08
030DC:  MOVWF  x07
030DE:  MOVLW  0C
030E0:  ADDWF  x07,W
030E2:  MOVWF  01
030E4:  MOVLW  00
030E6:  ADDWFC x08,W
030E8:  MOVWF  03
030EA:  MOVF   01,W
030EC:  ADDLW  0F
030EE:  MOVWF  01
030F0:  MOVLW  01
030F2:  ADDWFC 03,F
030F4:  MOVFF  01,607
030F8:  MOVFF  03,608
030FC:  MOVLB  5
030FE:  MOVF   xF6,W
03100:  MULLW  21
03102:  MOVF   FF3,W
03104:  MOVLB  6
03106:  CLRF   x0A
03108:  MOVWF  x09
0310A:  MOVLW  04
0310C:  ADDWF  x09,W
0310E:  MOVWF  01
03110:  MOVLW  00
03112:  ADDWFC x0A,W
03114:  MOVWF  03
03116:  MOVF   01,W
03118:  ADDLW  0F
0311A:  MOVWF  FE9
0311C:  MOVLW  01
0311E:  ADDWFC 03,W
03120:  MOVWF  FEA
03122:  MOVFF  FEF,64B
03126:  MOVFF  FEC,64C
0312A:  MOVFF  FEC,64D
0312E:  MOVFF  FEC,64E
03132:  MOVLB  5
03134:  MOVF   xF6,W
03136:  MULLW  10
03138:  MOVF   FF3,W
0313A:  MOVLB  6
0313C:  CLRF   x0E
0313E:  MOVWF  x0D
03140:  MOVLW  0C
03142:  ADDWF  x0D,W
03144:  MOVWF  01
03146:  MOVLW  00
03148:  ADDWFC x0E,W
0314A:  MOVWF  03
0314C:  MOVF   01,W
0314E:  ADDLW  62
03150:  MOVWF  FE9
03152:  MOVLW  00
03154:  ADDWFC 03,W
03156:  MOVWF  FEA
03158:  MOVFF  FEF,64F
0315C:  MOVFF  FEC,01
03160:  MOVFF  FEC,02
03164:  MOVFF  FEC,03
03168:  MOVFF  03,652
0316C:  MOVFF  02,651
03170:  MOVFF  01,650
03174:  MOVLB  0
03176:  CALL   0ABC
0317A:  MOVFF  03,652
0317E:  MOVFF  02,651
03182:  MOVFF  01,650
03186:  MOVFF  00,64F
0318A:  MOVLB  5
0318C:  MOVF   xF6,W
0318E:  MULLW  10
03190:  MOVF   FF3,W
03192:  MOVLB  6
03194:  CLRF   x0E
03196:  MOVWF  x0D
03198:  MOVLW  04
0319A:  ADDWF  x0D,W
0319C:  MOVWF  01
0319E:  MOVLW  00
031A0:  ADDWFC x0E,W
031A2:  MOVWF  03
031A4:  MOVF   01,W
031A6:  ADDLW  62
031A8:  MOVWF  FE9
031AA:  MOVLW  00
031AC:  ADDWFC 03,W
031AE:  MOVWF  FEA
031B0:  MOVFF  FEF,653
031B4:  MOVFF  FEC,01
031B8:  MOVFF  FEC,02
031BC:  MOVFF  FEC,03
031C0:  BCF    FD8.1
031C2:  MOVFF  03,656
031C6:  MOVFF  02,655
031CA:  MOVFF  01,654
031CE:  MOVLB  0
031D0:  CALL   0BB2
031D4:  MOVFF  608,FEA
031D8:  MOVFF  607,FE9
031DC:  MOVFF  00,FEF
031E0:  MOVFF  01,FEC
031E4:  MOVFF  02,FEC
031E8:  MOVFF  03,FEC
....................    float pTmp = 0;
....................    float polePitch = magPP;
031EC:  MOVLB  6
031EE:  CLRF   x02
031F0:  CLRF   x01
031F2:  CLRF   x00
031F4:  MOVLB  5
031F6:  CLRF   xFF
031F8:  MOVLB  6
031FA:  CLRF   x06
031FC:  CLRF   x05
031FE:  CLRF   x04
03200:  MOVLW  7F
03202:  MOVWF  x03
....................    
....................    if (adcVals[ch].cosCounts < 0){
03204:  MOVLB  5
03206:  MOVF   xF6,W
03208:  MULLW  21
0320A:  MOVF   FF3,W
0320C:  MOVLB  6
0320E:  CLRF   x08
03210:  MOVWF  x07
03212:  MOVLW  0C
03214:  ADDWF  x07,W
03216:  MOVWF  01
03218:  MOVLW  00
0321A:  ADDWFC x08,W
0321C:  MOVWF  03
0321E:  MOVF   01,W
03220:  ADDLW  0F
03222:  MOVWF  FE9
03224:  MOVLW  01
03226:  ADDWFC 03,W
03228:  MOVWF  FEA
0322A:  MOVFF  FEF,64B
0322E:  MOVFF  FEC,64C
03232:  MOVFF  FEC,64D
03236:  MOVFF  FEC,64E
0323A:  CLRF   x52
0323C:  CLRF   x51
0323E:  CLRF   x50
03240:  CLRF   x4F
03242:  MOVLB  0
03244:  CALL   146C
03248:  BTFSS  FD8.0
0324A:  BRA    33C0
....................       if ((adcVals[ch].sinCounts > 0) && (adcVals[ch].sinLast < 0)){
0324C:  MOVLB  5
0324E:  MOVF   xF6,W
03250:  MULLW  21
03252:  MOVF   FF3,W
03254:  MOVLB  6
03256:  CLRF   x08
03258:  MOVWF  x07
0325A:  MOVLW  08
0325C:  ADDWF  x07,W
0325E:  MOVWF  01
03260:  MOVLW  00
03262:  ADDWFC x08,W
03264:  MOVWF  03
03266:  MOVF   01,W
03268:  ADDLW  0F
0326A:  MOVWF  FE9
0326C:  MOVLW  01
0326E:  ADDWFC 03,W
03270:  MOVWF  FEA
03272:  MOVFF  FEF,64F
03276:  MOVFF  FEC,608
0327A:  MOVFF  FEC,651
0327E:  MOVFF  FEC,652
03282:  CLRF   x4E
03284:  CLRF   x4D
03286:  CLRF   x4C
03288:  CLRF   x4B
0328A:  MOVFF  608,650
0328E:  MOVLB  0
03290:  CALL   146C
03294:  BNC   3306
03296:  MOVLB  5
03298:  MOVF   xF6,W
0329A:  MULLW  21
0329C:  MOVF   FF3,W
0329E:  MOVLB  6
032A0:  CLRF   x08
032A2:  MOVWF  x07
032A4:  MOVLW  10
032A6:  ADDWF  x07,W
032A8:  MOVWF  01
032AA:  MOVLW  00
032AC:  ADDWFC x08,W
032AE:  MOVWF  03
032B0:  MOVF   01,W
032B2:  ADDLW  0F
032B4:  MOVWF  FE9
032B6:  MOVLW  01
032B8:  ADDWFC 03,W
032BA:  MOVWF  FEA
032BC:  MOVFF  FEF,64B
032C0:  MOVFF  FEC,64C
032C4:  MOVFF  FEC,64D
032C8:  MOVFF  FEC,64E
032CC:  CLRF   x52
032CE:  CLRF   x51
032D0:  CLRF   x50
032D2:  CLRF   x4F
032D4:  MOVLB  0
032D6:  CALL   146C
032DA:  BNC   3306
....................          adcVals[ch].npoles--;
032DC:  MOVLB  5
032DE:  MOVF   xF6,W
032E0:  MULLW  21
032E2:  MOVF   FF3,W
032E4:  MOVLB  6
032E6:  CLRF   x08
032E8:  MOVWF  x07
032EA:  MOVLW  1C
032EC:  ADDWF  x07,W
032EE:  MOVWF  01
032F0:  MOVLW  00
032F2:  ADDWFC x08,W
032F4:  MOVWF  03
032F6:  MOVF   01,W
032F8:  ADDLW  0F
032FA:  MOVWF  FE9
032FC:  MOVLW  01
032FE:  ADDWFC 03,W
03300:  MOVWF  FEA
03302:  DECF   FEF,F
....................       }
03304:  BRA    33BE
....................       else if ((adcVals[ch].sinCounts < 0) && (adcVals[ch].sinLast > 0)){
03306:  MOVLB  5
03308:  MOVF   xF6,W
0330A:  MULLW  21
0330C:  MOVF   FF3,W
0330E:  MOVLB  6
03310:  CLRF   x08
03312:  MOVWF  x07
03314:  MOVLW  08
03316:  ADDWF  x07,W
03318:  MOVWF  01
0331A:  MOVLW  00
0331C:  ADDWFC x08,W
0331E:  MOVWF  03
03320:  MOVF   01,W
03322:  ADDLW  0F
03324:  MOVWF  FE9
03326:  MOVLW  01
03328:  ADDWFC 03,W
0332A:  MOVWF  FEA
0332C:  MOVFF  FEF,64B
03330:  MOVFF  FEC,608
03334:  MOVFF  FEC,64D
03338:  MOVFF  FEC,64E
0333C:  MOVFF  608,64C
03340:  CLRF   x52
03342:  CLRF   x51
03344:  CLRF   x50
03346:  CLRF   x4F
03348:  MOVLB  0
0334A:  CALL   146C
0334E:  BNC   33C0
03350:  MOVLB  5
03352:  MOVF   xF6,W
03354:  MULLW  21
03356:  MOVF   FF3,W
03358:  MOVLB  6
0335A:  CLRF   x08
0335C:  MOVWF  x07
0335E:  MOVLW  10
03360:  ADDWF  x07,W
03362:  MOVWF  01
03364:  MOVLW  00
03366:  ADDWFC x08,W
03368:  MOVWF  03
0336A:  MOVF   01,W
0336C:  ADDLW  0F
0336E:  MOVWF  FE9
03370:  MOVLW  01
03372:  ADDWFC 03,W
03374:  MOVWF  FEA
03376:  MOVFF  FEF,64F
0337A:  MOVFF  FEC,650
0337E:  MOVFF  FEC,651
03382:  MOVFF  FEC,652
03386:  CLRF   x4E
03388:  CLRF   x4D
0338A:  CLRF   x4C
0338C:  CLRF   x4B
0338E:  MOVLB  0
03390:  CALL   146C
03394:  BNC   33C0
....................          adcVals[ch].npoles++;
03396:  MOVLB  5
03398:  MOVF   xF6,W
0339A:  MULLW  21
0339C:  MOVF   FF3,W
0339E:  MOVLB  6
033A0:  CLRF   x08
033A2:  MOVWF  x07
033A4:  MOVLW  1C
033A6:  ADDWF  x07,W
033A8:  MOVWF  01
033AA:  MOVLW  00
033AC:  ADDWFC x08,W
033AE:  MOVWF  03
033B0:  MOVF   01,W
033B2:  ADDLW  0F
033B4:  MOVWF  FE9
033B6:  MOVLW  01
033B8:  ADDWFC 03,W
033BA:  MOVWF  FEA
033BC:  INCF   FEF,F
033BE:  MOVLB  0
....................       }
....................    }
....................    
....................    adcVals[ch].p0 = polePitch * ( 1000 / (2*PI) ) * atan2( (float)adcVals[ch].sinCounts, (float)adcVals[ch].cosCounts );
033C0:  MOVLB  5
033C2:  MOVF   xF6,W
033C4:  MULLW  21
033C6:  MOVF   FF3,W
033C8:  MOVLB  6
033CA:  CLRF   x08
033CC:  MOVWF  x07
033CE:  MOVLW  18
033D0:  ADDWF  x07,W
033D2:  MOVWF  01
033D4:  MOVLW  00
033D6:  ADDWFC x08,W
033D8:  MOVWF  03
033DA:  MOVF   01,W
033DC:  ADDLW  0F
033DE:  MOVWF  01
033E0:  MOVLW  01
033E2:  ADDWFC 03,F
033E4:  MOVFF  01,607
033E8:  MOVFF  03,608
033EC:  MOVFF  606,64E
033F0:  MOVFF  605,64D
033F4:  MOVFF  604,64C
033F8:  MOVFF  603,64B
033FC:  MOVLW  AA
033FE:  MOVWF  x52
03400:  MOVLW  27
03402:  MOVWF  x51
03404:  MOVLW  1F
03406:  MOVWF  x50
03408:  MOVLW  86
0340A:  MOVWF  x4F
0340C:  MOVLB  0
0340E:  CALL   0ABC
03412:  MOVFF  03,60C
03416:  MOVFF  02,60B
0341A:  MOVFF  01,60A
0341E:  MOVFF  00,609
03422:  MOVLB  5
03424:  MOVF   xF6,W
03426:  MULLW  21
03428:  MOVF   FF3,W
0342A:  MOVLB  6
0342C:  CLRF   x0E
0342E:  MOVWF  x0D
03430:  MOVLW  08
03432:  ADDWF  x0D,W
03434:  MOVWF  01
03436:  MOVLW  00
03438:  ADDWFC x0E,W
0343A:  MOVWF  03
0343C:  MOVF   01,W
0343E:  ADDLW  0F
03440:  MOVWF  FE9
03442:  MOVLW  01
03444:  ADDWFC 03,W
03446:  MOVWF  FEA
03448:  MOVFF  FEF,60D
0344C:  MOVFF  FEC,60E
03450:  MOVFF  FEC,60F
03454:  MOVFF  FEC,610
03458:  MOVLB  5
0345A:  MOVF   xF6,W
0345C:  MULLW  21
0345E:  MOVF   FF3,W
03460:  MOVLB  6
03462:  CLRF   x12
03464:  MOVWF  x11
03466:  MOVLW  0C
03468:  ADDWF  x11,W
0346A:  MOVWF  01
0346C:  MOVLW  00
0346E:  ADDWFC x12,W
03470:  MOVWF  03
03472:  MOVF   01,W
03474:  ADDLW  0F
03476:  MOVWF  FE9
03478:  MOVLW  01
0347A:  ADDWFC 03,W
0347C:  MOVWF  FEA
0347E:  MOVFF  FEF,00
03482:  MOVFF  FEC,01
03486:  MOVFF  FEC,02
0348A:  MOVFF  FEC,03
0348E:  MOVFF  03,614
03492:  MOVFF  02,613
03496:  MOVFF  01,612
0349A:  MOVFF  00,611
0349E:  MOVFF  610,622
034A2:  MOVFF  60F,621
034A6:  MOVFF  60E,620
034AA:  MOVFF  60D,61F
034AE:  MOVFF  03,626
034B2:  MOVFF  02,625
034B6:  MOVFF  01,624
034BA:  MOVFF  00,623
034BE:  MOVLB  0
034C0:  GOTO   1B6E
034C4:  MOVFF  60C,64E
034C8:  MOVFF  60B,64D
034CC:  MOVFF  60A,64C
034D0:  MOVFF  609,64B
034D4:  MOVFF  03,652
034D8:  MOVFF  02,651
034DC:  MOVFF  01,650
034E0:  MOVFF  00,64F
034E4:  CALL   0ABC
034E8:  MOVFF  608,FEA
034EC:  MOVFF  607,FE9
034F0:  MOVFF  00,FEF
034F4:  MOVFF  01,FEC
034F8:  MOVFF  02,FEC
034FC:  MOVFF  03,FEC
....................    pTmp = adcVals[ch].p0 + ( 1000 * polePitch * (float)adcVals[ch].npoles );
03500:  MOVLB  5
03502:  MOVF   xF6,W
03504:  MULLW  21
03506:  MOVF   FF3,W
03508:  MOVLB  6
0350A:  CLRF   x08
0350C:  MOVWF  x07
0350E:  MOVLW  18
03510:  ADDWF  x07,W
03512:  MOVWF  01
03514:  MOVLW  00
03516:  ADDWFC x08,W
03518:  MOVWF  03
0351A:  MOVF   01,W
0351C:  ADDLW  0F
0351E:  MOVWF  FE9
03520:  MOVLW  01
03522:  ADDWFC 03,W
03524:  MOVWF  FEA
03526:  MOVFF  FEF,607
0352A:  MOVFF  FEC,608
0352E:  MOVFF  FEC,609
03532:  MOVFF  FEC,60A
03536:  CLRF   x4E
03538:  CLRF   x4D
0353A:  MOVLW  7A
0353C:  MOVWF  x4C
0353E:  MOVLW  88
03540:  MOVWF  x4B
03542:  MOVFF  606,652
03546:  MOVFF  605,651
0354A:  MOVFF  604,650
0354E:  MOVFF  603,64F
03552:  MOVLB  0
03554:  CALL   0ABC
03558:  MOVFF  03,60E
0355C:  MOVFF  02,60D
03560:  MOVFF  01,60C
03564:  MOVFF  00,60B
03568:  MOVLB  5
0356A:  MOVF   xF6,W
0356C:  MULLW  21
0356E:  MOVF   FF3,W
03570:  MOVLB  6
03572:  CLRF   x10
03574:  MOVWF  x0F
03576:  MOVLW  1C
03578:  ADDWF  x0F,W
0357A:  MOVWF  01
0357C:  MOVLW  00
0357E:  ADDWFC x10,W
03580:  MOVWF  03
03582:  MOVF   01,W
03584:  ADDLW  0F
03586:  MOVWF  FE9
03588:  MOVLW  01
0358A:  ADDWFC 03,W
0358C:  MOVWF  FEA
0358E:  MOVF   FEF,W
03590:  CLRF   x42
03592:  MOVWF  x41
03594:  BTFSC  x41.7
03596:  DECF   x42,F
03598:  MOVLB  0
0359A:  CALL   1E10
0359E:  MOVFF  60E,64E
035A2:  MOVFF  60D,64D
035A6:  MOVFF  60C,64C
035AA:  MOVFF  60B,64B
035AE:  MOVFF  03,652
035B2:  MOVFF  02,651
035B6:  MOVFF  01,650
035BA:  MOVFF  00,64F
035BE:  CALL   0ABC
035C2:  MOVFF  FEA,60C
035C6:  MOVFF  FE9,60B
035CA:  BCF    FD8.1
035CC:  MOVFF  60A,652
035D0:  MOVFF  609,651
035D4:  MOVFF  608,650
035D8:  MOVFF  607,64F
035DC:  MOVFF  03,656
035E0:  MOVFF  02,655
035E4:  MOVFF  01,654
035E8:  MOVFF  00,653
035EC:  CALL   0BB2
035F0:  MOVFF  60C,FEA
035F4:  MOVFF  60B,FE9
035F8:  MOVFF  03,602
035FC:  MOVFF  02,601
03600:  MOVFF  01,600
03604:  MOVFF  00,5FF
....................    
....................    adcVals[ch].pReal = (pow(pTmp*sc[ch].c5,5) + pow(pTmp*sc[ch].c4,4) + pow(pTmp*sc[ch].c3,3) + pow(pTmp*sc[ch].c2,2) + pTmp*sc[ch].c1 + sc[ch].c0);
03608:  MOVLB  5
0360A:  MOVF   xF6,W
0360C:  MULLW  21
0360E:  MOVF   FF3,W
03610:  MOVLB  6
03612:  CLRF   x08
03614:  MOVWF  x07
03616:  MOVLW  1D
03618:  ADDWF  x07,W
0361A:  MOVWF  01
0361C:  MOVLW  00
0361E:  ADDWFC x08,W
03620:  MOVWF  03
03622:  MOVF   01,W
03624:  ADDLW  0F
03626:  MOVWF  01
03628:  MOVLW  01
0362A:  ADDWFC 03,F
0362C:  MOVFF  01,607
03630:  MOVFF  03,608
03634:  MOVLB  5
03636:  MOVF   xF6,W
03638:  MULLW  18
0363A:  MOVF   FF3,W
0363C:  MOVLB  6
0363E:  CLRF   x0A
03640:  MOVWF  x09
03642:  MOVLW  14
03644:  ADDWF  x09,W
03646:  MOVWF  01
03648:  MOVLW  00
0364A:  ADDWFC x0A,W
0364C:  MOVWF  03
0364E:  MOVF   01,W
03650:  ADDLW  82
03652:  MOVWF  FE9
03654:  MOVLW  00
03656:  ADDWFC 03,W
03658:  MOVWF  FEA
0365A:  MOVFF  FEF,64F
0365E:  MOVFF  FEC,01
03662:  MOVFF  FEC,02
03666:  MOVFF  FEC,03
0366A:  MOVFF  602,64E
0366E:  MOVFF  601,64D
03672:  MOVFF  600,64C
03676:  MOVFF  5FF,64B
0367A:  MOVFF  03,652
0367E:  MOVFF  02,651
03682:  MOVFF  01,650
03686:  MOVLB  0
03688:  CALL   0ABC
0368C:  MOVFF  03,60C
03690:  MOVFF  02,60B
03694:  MOVFF  01,60A
03698:  MOVFF  00,609
0369C:  MOVFF  03,622
036A0:  MOVFF  02,621
036A4:  MOVFF  01,620
036A8:  MOVFF  00,61F
036AC:  MOVLB  6
036AE:  CLRF   x26
036B0:  CLRF   x25
036B2:  MOVLW  20
036B4:  MOVWF  x24
036B6:  MOVLW  81
036B8:  MOVWF  x23
036BA:  MOVLB  0
036BC:  CALL   2B4E
036C0:  MOVFF  03,60C
036C4:  MOVFF  02,60B
036C8:  MOVFF  01,60A
036CC:  MOVFF  00,609
036D0:  MOVLB  5
036D2:  MOVF   xF6,W
036D4:  MULLW  18
036D6:  MOVF   FF3,W
036D8:  MOVLB  6
036DA:  CLRF   x0E
036DC:  MOVWF  x0D
036DE:  MOVLW  10
036E0:  ADDWF  x0D,W
036E2:  MOVWF  01
036E4:  MOVLW  00
036E6:  ADDWFC x0E,W
036E8:  MOVWF  03
036EA:  MOVF   01,W
036EC:  ADDLW  82
036EE:  MOVWF  FE9
036F0:  MOVLW  00
036F2:  ADDWFC 03,W
036F4:  MOVWF  FEA
036F6:  MOVFF  FEF,64F
036FA:  MOVFF  FEC,01
036FE:  MOVFF  FEC,02
03702:  MOVFF  FEC,03
03706:  MOVFF  602,64E
0370A:  MOVFF  601,64D
0370E:  MOVFF  600,64C
03712:  MOVFF  5FF,64B
03716:  MOVFF  03,652
0371A:  MOVFF  02,651
0371E:  MOVFF  01,650
03722:  MOVLB  0
03724:  CALL   0ABC
03728:  MOVFF  03,610
0372C:  MOVFF  02,60F
03730:  MOVFF  01,60E
03734:  MOVFF  00,60D
03738:  MOVFF  03,622
0373C:  MOVFF  02,621
03740:  MOVFF  01,620
03744:  MOVFF  00,61F
03748:  MOVLB  6
0374A:  CLRF   x26
0374C:  CLRF   x25
0374E:  CLRF   x24
03750:  MOVLW  81
03752:  MOVWF  x23
03754:  MOVLB  0
03756:  CALL   2B4E
0375A:  MOVFF  FEA,60E
0375E:  MOVFF  FE9,60D
03762:  BCF    FD8.1
03764:  MOVFF  60C,652
03768:  MOVFF  60B,651
0376C:  MOVFF  60A,650
03770:  MOVFF  609,64F
03774:  MOVFF  03,656
03778:  MOVFF  02,655
0377C:  MOVFF  01,654
03780:  MOVFF  00,653
03784:  CALL   0BB2
03788:  MOVFF  60E,FEA
0378C:  MOVFF  60D,FE9
03790:  MOVFF  03,60C
03794:  MOVFF  02,60B
03798:  MOVFF  01,60A
0379C:  MOVFF  00,609
037A0:  MOVLB  5
037A2:  MOVF   xF6,W
037A4:  MULLW  18
037A6:  MOVF   FF3,W
037A8:  MOVLB  6
037AA:  CLRF   x10
037AC:  MOVWF  x0F
037AE:  MOVLW  0C
037B0:  ADDWF  x0F,W
037B2:  MOVWF  01
037B4:  MOVLW  00
037B6:  ADDWFC x10,W
037B8:  MOVWF  03
037BA:  MOVF   01,W
037BC:  ADDLW  82
037BE:  MOVWF  FE9
037C0:  MOVLW  00
037C2:  ADDWFC 03,W
037C4:  MOVWF  FEA
037C6:  MOVFF  FEF,64F
037CA:  MOVFF  FEC,01
037CE:  MOVFF  FEC,02
037D2:  MOVFF  FEC,03
037D6:  MOVFF  602,64E
037DA:  MOVFF  601,64D
037DE:  MOVFF  600,64C
037E2:  MOVFF  5FF,64B
037E6:  MOVFF  03,652
037EA:  MOVFF  02,651
037EE:  MOVFF  01,650
037F2:  MOVLB  0
037F4:  CALL   0ABC
037F8:  MOVFF  03,612
037FC:  MOVFF  02,611
03800:  MOVFF  01,610
03804:  MOVFF  00,60F
03808:  MOVFF  03,622
0380C:  MOVFF  02,621
03810:  MOVFF  01,620
03814:  MOVFF  00,61F
03818:  MOVLB  6
0381A:  CLRF   x26
0381C:  CLRF   x25
0381E:  MOVLW  40
03820:  MOVWF  x24
03822:  MOVLW  80
03824:  MOVWF  x23
03826:  MOVLB  0
03828:  CALL   2B4E
0382C:  MOVFF  FEA,610
03830:  MOVFF  FE9,60F
03834:  BCF    FD8.1
03836:  MOVFF  60C,652
0383A:  MOVFF  60B,651
0383E:  MOVFF  60A,650
03842:  MOVFF  609,64F
03846:  MOVFF  03,656
0384A:  MOVFF  02,655
0384E:  MOVFF  01,654
03852:  MOVFF  00,653
03856:  CALL   0BB2
0385A:  MOVFF  610,FEA
0385E:  MOVFF  60F,FE9
03862:  MOVFF  03,60C
03866:  MOVFF  02,60B
0386A:  MOVFF  01,60A
0386E:  MOVFF  00,609
03872:  MOVLB  5
03874:  MOVF   xF6,W
03876:  MULLW  18
03878:  MOVF   FF3,W
0387A:  MOVLB  6
0387C:  CLRF   x12
0387E:  MOVWF  x11
03880:  MOVLW  08
03882:  ADDWF  x11,W
03884:  MOVWF  01
03886:  MOVLW  00
03888:  ADDWFC x12,W
0388A:  MOVWF  03
0388C:  MOVF   01,W
0388E:  ADDLW  82
03890:  MOVWF  FE9
03892:  MOVLW  00
03894:  ADDWFC 03,W
03896:  MOVWF  FEA
03898:  MOVFF  FEF,64F
0389C:  MOVFF  FEC,01
038A0:  MOVFF  FEC,02
038A4:  MOVFF  FEC,03
038A8:  MOVFF  602,64E
038AC:  MOVFF  601,64D
038B0:  MOVFF  600,64C
038B4:  MOVFF  5FF,64B
038B8:  MOVFF  03,652
038BC:  MOVFF  02,651
038C0:  MOVFF  01,650
038C4:  MOVLB  0
038C6:  CALL   0ABC
038CA:  MOVFF  03,614
038CE:  MOVFF  02,613
038D2:  MOVFF  01,612
038D6:  MOVFF  00,611
038DA:  MOVFF  03,622
038DE:  MOVFF  02,621
038E2:  MOVFF  01,620
038E6:  MOVFF  00,61F
038EA:  MOVLB  6
038EC:  CLRF   x26
038EE:  CLRF   x25
038F0:  CLRF   x24
038F2:  MOVLW  80
038F4:  MOVWF  x23
038F6:  MOVLB  0
038F8:  CALL   2B4E
038FC:  MOVFF  FEA,612
03900:  MOVFF  FE9,611
03904:  BCF    FD8.1
03906:  MOVFF  60C,652
0390A:  MOVFF  60B,651
0390E:  MOVFF  60A,650
03912:  MOVFF  609,64F
03916:  MOVFF  03,656
0391A:  MOVFF  02,655
0391E:  MOVFF  01,654
03922:  MOVFF  00,653
03926:  CALL   0BB2
0392A:  MOVFF  612,FEA
0392E:  MOVFF  611,FE9
03932:  MOVFF  03,60C
03936:  MOVFF  02,60B
0393A:  MOVFF  01,60A
0393E:  MOVFF  00,609
03942:  MOVLB  5
03944:  MOVF   xF6,W
03946:  MULLW  18
03948:  MOVF   FF3,W
0394A:  MOVLB  6
0394C:  CLRF   x14
0394E:  MOVWF  x13
03950:  MOVLW  04
03952:  ADDWF  x13,W
03954:  MOVWF  01
03956:  MOVLW  00
03958:  ADDWFC x14,W
0395A:  MOVWF  03
0395C:  MOVF   01,W
0395E:  ADDLW  82
03960:  MOVWF  FE9
03962:  MOVLW  00
03964:  ADDWFC 03,W
03966:  MOVWF  FEA
03968:  MOVFF  FEF,64F
0396C:  MOVFF  FEC,01
03970:  MOVFF  FEC,02
03974:  MOVFF  FEC,03
03978:  MOVFF  602,64E
0397C:  MOVFF  601,64D
03980:  MOVFF  600,64C
03984:  MOVFF  5FF,64B
03988:  MOVFF  03,652
0398C:  MOVFF  02,651
03990:  MOVFF  01,650
03994:  MOVLB  0
03996:  CALL   0ABC
0399A:  MOVFF  FEA,614
0399E:  MOVFF  FE9,613
039A2:  BCF    FD8.1
039A4:  MOVFF  60C,652
039A8:  MOVFF  60B,651
039AC:  MOVFF  60A,650
039B0:  MOVFF  609,64F
039B4:  MOVFF  03,656
039B8:  MOVFF  02,655
039BC:  MOVFF  01,654
039C0:  MOVFF  00,653
039C4:  CALL   0BB2
039C8:  MOVFF  614,FEA
039CC:  MOVFF  613,FE9
039D0:  MOVFF  03,652
039D4:  MOVFF  02,651
039D8:  MOVFF  01,650
039DC:  MOVFF  00,64F
039E0:  MOVLB  5
039E2:  MOVF   xF6,W
039E4:  MULLW  18
039E6:  MOVF   FF3,W
039E8:  MOVLB  6
039EA:  CLRF   x16
039EC:  MOVWF  x15
039EE:  MOVLW  82
039F0:  ADDWF  x15,W
039F2:  MOVWF  FE9
039F4:  MOVLW  00
039F6:  ADDWFC x16,W
039F8:  MOVWF  FEA
039FA:  MOVFF  FEF,653
039FE:  MOVFF  FEC,01
03A02:  MOVFF  FEC,02
03A06:  MOVFF  FEC,03
03A0A:  BCF    FD8.1
03A0C:  MOVFF  03,656
03A10:  MOVFF  02,655
03A14:  MOVFF  01,654
03A18:  MOVLB  0
03A1A:  CALL   0BB2
03A1E:  MOVFF  608,FEA
03A22:  MOVFF  607,FE9
03A26:  MOVFF  00,FEF
03A2A:  MOVFF  01,FEC
03A2E:  MOVFF  02,FEC
03A32:  MOVFF  03,FEC
....................    if (ch == chX) adcVals[ch].pReal *= -1;
03A36:  MOVLB  5
03A38:  MOVF   xF6,F
03A3A:  BNZ   3A9A
03A3C:  MOVF   xF6,W
03A3E:  MULLW  21
03A40:  MOVF   FF3,W
03A42:  MOVLB  6
03A44:  CLRF   x08
03A46:  MOVWF  x07
03A48:  MOVLW  1D
03A4A:  ADDWF  x07,W
03A4C:  MOVWF  01
03A4E:  MOVLW  00
03A50:  ADDWFC x08,W
03A52:  MOVWF  03
03A54:  MOVF   01,W
03A56:  ADDLW  0F
03A58:  MOVWF  FE9
03A5A:  MOVLW  01
03A5C:  ADDWFC 03,W
03A5E:  MOVWF  FEA
03A60:  MOVFF  FEF,64B
03A64:  MOVFF  FEC,64C
03A68:  MOVFF  FEC,64D
03A6C:  MOVFF  FEC,64E
03A70:  MOVF   FED,F
03A72:  MOVF   FED,F
03A74:  MOVF   FED,F
03A76:  CLRF   x52
03A78:  CLRF   x51
03A7A:  MOVLW  80
03A7C:  MOVWF  x50
03A7E:  MOVLW  7F
03A80:  MOVWF  x4F
03A82:  MOVLB  0
03A84:  CALL   0ABC
03A88:  MOVFF  00,FEF
03A8C:  MOVFF  01,FEC
03A90:  MOVFF  02,FEC
03A94:  MOVFF  03,FEC
03A98:  MOVLB  5
....................    PID[ch].PVold = PID[ch].PV;
03A9A:  MOVF   xF6,W
03A9C:  MULLW  20
03A9E:  MOVF   FF3,W
03AA0:  MOVLB  6
03AA2:  CLRF   x08
03AA4:  MOVWF  x07
03AA6:  MOVLW  14
03AA8:  ADDWF  x07,W
03AAA:  MOVWF  01
03AAC:  MOVLW  00
03AAE:  ADDWFC x08,W
03AB0:  MOVWF  03
03AB2:  MOVF   01,W
03AB4:  ADDLW  20
03AB6:  MOVWF  01
03AB8:  MOVLW  00
03ABA:  ADDWFC 03,F
03ABC:  MOVFF  01,607
03AC0:  MOVFF  03,608
03AC4:  MOVLB  5
03AC6:  MOVF   xF6,W
03AC8:  MULLW  20
03ACA:  MOVF   FF3,W
03ACC:  MOVLB  6
03ACE:  CLRF   x0A
03AD0:  MOVWF  x09
03AD2:  MOVLW  10
03AD4:  ADDWF  x09,W
03AD6:  MOVWF  01
03AD8:  MOVLW  00
03ADA:  ADDWFC x0A,W
03ADC:  MOVWF  03
03ADE:  MOVF   01,W
03AE0:  ADDLW  20
03AE2:  MOVWF  FE9
03AE4:  MOVLW  00
03AE6:  ADDWFC 03,W
03AE8:  MOVWF  FEA
03AEA:  MOVFF  FEF,00
03AEE:  MOVFF  FEC,01
03AF2:  MOVFF  FEC,02
03AF6:  MOVFF  FEC,03
03AFA:  MOVFF  608,FEA
03AFE:  MOVFF  607,FE9
03B02:  MOVFF  00,FEF
03B06:  MOVFF  01,FEC
03B0A:  MOVFF  02,FEC
03B0E:  MOVFF  03,FEC
....................    PID[ch].PV = adcVals[ch].pReal;
03B12:  MOVLB  5
03B14:  MOVF   xF6,W
03B16:  MULLW  20
03B18:  MOVF   FF3,W
03B1A:  MOVLB  6
03B1C:  CLRF   x08
03B1E:  MOVWF  x07
03B20:  MOVLW  10
03B22:  ADDWF  x07,W
03B24:  MOVWF  01
03B26:  MOVLW  00
03B28:  ADDWFC x08,W
03B2A:  MOVWF  03
03B2C:  MOVF   01,W
03B2E:  ADDLW  20
03B30:  MOVWF  01
03B32:  MOVLW  00
03B34:  ADDWFC 03,F
03B36:  MOVFF  01,607
03B3A:  MOVFF  03,608
03B3E:  MOVLB  5
03B40:  MOVF   xF6,W
03B42:  MULLW  21
03B44:  MOVF   FF3,W
03B46:  MOVLB  6
03B48:  CLRF   x0A
03B4A:  MOVWF  x09
03B4C:  MOVLW  1D
03B4E:  ADDWF  x09,W
03B50:  MOVWF  01
03B52:  MOVLW  00
03B54:  ADDWFC x0A,W
03B56:  MOVWF  03
03B58:  MOVF   01,W
03B5A:  ADDLW  0F
03B5C:  MOVWF  FE9
03B5E:  MOVLW  01
03B60:  ADDWFC 03,W
03B62:  MOVWF  FEA
03B64:  MOVFF  FEF,00
03B68:  MOVFF  FEC,01
03B6C:  MOVFF  FEC,02
03B70:  MOVFF  FEC,03
03B74:  MOVFF  608,FEA
03B78:  MOVFF  607,FE9
03B7C:  MOVFF  00,FEF
03B80:  MOVFF  01,FEC
03B84:  MOVFF  02,FEC
03B88:  MOVFF  03,FEC
03B8C:  MOVLB  0
03B8E:  GOTO   3C52 (RETURN)
.................... }  
.................... 
.................... /*****************************************************************************/
.................... /* SENSOR MONITOR INTERRUPT TASK                                             */
.................... /* starts conversion of the other two ADCs                                   */
.................... /*****************************************************************************/
.................... void sensor_monitor_interrupt_task()
.................... {
....................    static int8 ch = 0;
....................    
....................    if (!smData[ch].adcBusy)
*
001C0:  MOVLB  6
001C2:  CLRF   x65
001C4:  MOVFF  166,664
001C8:  MOVLW  63
001CA:  ADDWF  x64,W
001CC:  MOVWF  FE9
001CE:  MOVLW  01
001D0:  ADDWFC x65,W
001D2:  MOVWF  FEA
001D4:  BTFSC  FEF.1
001D6:  BRA    0240
....................    {
....................       smData[ch].adcBusy = true;
001D8:  CLRF   x65
001DA:  MOVFF  166,664
001DE:  MOVLW  63
001E0:  ADDWF  x64,W
001E2:  MOVWF  FE9
001E4:  MOVLW  01
001E6:  ADDWFC x65,W
001E8:  MOVWF  FEA
001EA:  BSF    FEF.1
....................       
....................       ads_start_conv_block(ch);
001EC:  MOVFF  166,664
001F0:  MOVLB  0
001F2:  BRA    01A2
....................       ch = !ch;
001F4:  MOVLB  1
001F6:  MOVF   x66,F
001F8:  BZ    01FE
001FA:  MOVLW  00
001FC:  BRA    0200
001FE:  MOVLW  01
00200:  MOVWF  x66
....................       
....................       smData[!ch].dataReady = true;
00202:  MOVF   x66,F
00204:  BZ    020A
00206:  MOVLW  00
00208:  BRA    020C
0020A:  MOVLW  01
0020C:  MOVLB  6
0020E:  CLRF   x65
00210:  MOVWF  x64
00212:  MOVLW  63
00214:  ADDWF  x64,W
00216:  MOVWF  FE9
00218:  MOVLW  01
0021A:  ADDWFC x65,W
0021C:  MOVWF  FEA
0021E:  BSF    FEF.0
....................       smData[!ch].adcBusy = false;
00220:  MOVLB  1
00222:  MOVF   x66,F
00224:  BZ    022A
00226:  MOVLW  00
00228:  BRA    022C
0022A:  MOVLW  01
0022C:  MOVLB  6
0022E:  CLRF   x65
00230:  MOVWF  x64
00232:  MOVLW  63
00234:  ADDWF  x64,W
00236:  MOVWF  FE9
00238:  MOVLW  01
0023A:  ADDWFC x65,W
0023C:  MOVWF  FEA
0023E:  BCF    FEF.1
....................    }
00240:  MOVLB  0
00242:  GOTO   0304 (RETURN)
.................... }
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* SENSOR MONITOR task - gets magnetoresistive sensor counts                 */
.................... /* gets two values each time the task is run                                  */
.................... /*****************************************************************************/
.................... void sensor_monitor_task()
*
03B92:  MOVLB  5
03B94:  CLRF   xF1
03B96:  CLRF   xF0
03B98:  CLRF   xEF
03B9A:  CLRF   xEE
03B9C:  CLRF   xF5
03B9E:  CLRF   xF4
03BA0:  CLRF   xF3
03BA2:  CLRF   xF2
.................... {
....................    static int8 ch = 0;
....................    signed int32 sinRaw = 0;
....................    signed int32 cosRaw = 0;
....................    
....................    if ( (!smData[ch].adcBusy) && smData[ch].dataReady ){
03BA4:  CLRF   xF7
03BA6:  MOVFF  167,5F6
03BAA:  MOVLW  63
03BAC:  ADDWF  xF6,W
03BAE:  MOVWF  FE9
03BB0:  MOVLW  01
03BB2:  ADDWFC xF7,W
03BB4:  MOVWF  FEA
03BB6:  BTFSC  FEF.1
03BB8:  BRA    3C9E
03BBA:  CLRF   xF9
03BBC:  MOVFF  167,5F8
03BC0:  MOVLW  63
03BC2:  ADDWF  xF8,W
03BC4:  MOVWF  FE9
03BC6:  MOVLW  01
03BC8:  ADDWFC xF9,W
03BCA:  MOVWF  FEA
03BCC:  BTFSS  FEF.0
03BCE:  BRA    3C9E
....................       smData[ch].adcBusy = true;
03BD0:  CLRF   xF7
03BD2:  MOVFF  167,5F6
03BD6:  MOVLW  63
03BD8:  ADDWF  xF6,W
03BDA:  MOVWF  FE9
03BDC:  MOVLW  01
03BDE:  ADDWFC xF7,W
03BE0:  MOVWF  FEA
03BE2:  BSF    FEF.1
....................       
....................       sinRaw = ads_read_data(ch*2);
03BE4:  BCF    FD8.0
03BE6:  MOVLB  1
03BE8:  RLCF   x67,W
03BEA:  MOVLB  5
03BEC:  MOVWF  xF6
03BEE:  MOVWF  xF7
03BF0:  MOVLB  0
03BF2:  CALL   13C2
03BF6:  MOVFF  03,5F1
03BFA:  MOVFF  02,5F0
03BFE:  MOVFF  01,5EF
03C02:  MOVFF  00,5EE
....................       cosRaw = ads_read_data(ch*2+1);      
03C06:  BCF    FD8.0
03C08:  MOVLB  1
03C0A:  RLCF   x67,W
03C0C:  ADDLW  01
03C0E:  MOVLB  5
03C10:  MOVWF  xF6
03C12:  MOVWF  xF7
03C14:  MOVLB  0
03C16:  CALL   13C2
03C1A:  MOVFF  03,5F5
03C1E:  MOVFF  02,5F4
03C22:  MOVFF  01,5F3
03C26:  MOVFF  00,5F2
....................       
....................       sensor_process_data(ch, sinRaw, cosRaw);
03C2A:  MOVFF  167,5F6
03C2E:  MOVFF  5F1,5FA
03C32:  MOVFF  5F0,5F9
03C36:  MOVFF  5EF,5F8
03C3A:  MOVFF  5EE,5F7
03C3E:  MOVFF  5F5,5FE
03C42:  MOVFF  5F4,5FD
03C46:  MOVFF  5F3,5FC
03C4A:  MOVFF  5F2,5FB
03C4E:  GOTO   2E4C
....................       ch = !ch;
03C52:  MOVLB  1
03C54:  MOVF   x67,F
03C56:  BZ    3C5C
03C58:  MOVLW  00
03C5A:  BRA    3C5E
03C5C:  MOVLW  01
03C5E:  MOVWF  x67
....................       
....................       smData[!ch].dataReady = false;
03C60:  MOVF   x67,F
03C62:  BZ    3C68
03C64:  MOVLW  00
03C66:  BRA    3C6A
03C68:  MOVLW  01
03C6A:  MOVLB  5
03C6C:  CLRF   xF7
03C6E:  MOVWF  xF6
03C70:  MOVLW  63
03C72:  ADDWF  xF6,W
03C74:  MOVWF  FE9
03C76:  MOVLW  01
03C78:  ADDWFC xF7,W
03C7A:  MOVWF  FEA
03C7C:  BCF    FEF.0
....................       smData[!ch].adcBusy = false;
03C7E:  MOVLB  1
03C80:  MOVF   x67,F
03C82:  BZ    3C88
03C84:  MOVLW  00
03C86:  BRA    3C8A
03C88:  MOVLW  01
03C8A:  MOVLB  5
03C8C:  CLRF   xF7
03C8E:  MOVWF  xF6
03C90:  MOVLW  63
03C92:  ADDWF  xF6,W
03C94:  MOVWF  FE9
03C96:  MOVLW  01
03C98:  ADDWFC xF7,W
03C9A:  MOVWF  FEA
03C9C:  BCF    FEF.1
....................    }
03C9E:  MOVLB  0
03CA0:  GOTO   9E98 (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* INITIALIZE ADC's                                                          */
.................... /*****************************************************************************/
.................... void setup_external_ADCs()
*
00774:  MOVLB  5
00776:  CLRF   xEE
00778:  CLRF   xEF
0077A:  CLRF   xF0
0077C:  CLRF   xF1
.................... {
....................    unsigned int8 rc0=0;
....................    unsigned int8 rc1=0;
....................    unsigned int8 rc2=0;
....................    unsigned int8 rc3=0;
....................    
....................    for(int ch = 0; ch < 4; ch++)
0077E:  CLRF   xF2
00780:  MOVF   xF2,W
00782:  SUBLW  03
00784:  BNC   07BC
....................    {
....................       rc0=reg0config;
00786:  MOVLW  30
00788:  MOVWF  xEE
....................       rc1=reg1config;
0078A:  MOVLW  10
0078C:  MOVWF  xEF
....................       rc2=reg2config;
0078E:  MOVLW  30
00790:  MOVWF  xF0
....................       rc3=reg3config;
00792:  CLRF   xF1
....................       
....................       ADS1220init(ch, rc0, rc1, rc2, rc3);
00794:  MOVFF  5F2,5F3
00798:  MOVFF  5EE,5F4
0079C:  MOVFF  5EF,5F5
007A0:  MOVFF  5F0,5F6
007A4:  MOVFF  5F1,5F7
007A8:  MOVLB  0
007AA:  BRA    070A
....................       delay_ms(1);
007AC:  MOVLW  01
007AE:  MOVLB  5
007B0:  MOVWF  xF3
007B2:  MOVLB  0
007B4:  RCALL  03F6
007B6:  MOVLB  5
007B8:  INCF   xF2,F
007BA:  BRA    0780
....................    }   
007BC:  MOVLB  0
007BE:  GOTO   0822 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE MONITOR -- sets up ADC channels                                */
.................... /*****************************************************************************/
.................... void monitor_init()
.................... {
....................    setup_adc_ports(sAN6 | sAN16 | sAN17 | sAN24 | sAN25 | sAN26 | sAN27, NO_ANALOGS_P2, VSS_VDD);
007C2:  MOVLW  00
007C4:  MOVLB  F
007C6:  MOVWF  x53
007C8:  MOVLW  40
007CA:  MOVWF  x0C
007CC:  MOVLW  00
007CE:  MOVWF  x14
007D0:  MOVLW  03
007D2:  MOVWF  x1C
007D4:  MOVLW  0F
007D6:  MOVWF  x21
007D8:  MOVLW  00
007DA:  MOVWF  x29
....................    setup_adc(ADC_CLOCK_INTERNAL | ADC_TAD_MUL_255 | ADC_LEGACY_MODE | ADC_THRESHOLD_INT_DISABLED);
007DC:  MOVLW  08
007DE:  MOVWF  x55
007E0:  CLRF   x56
007E2:  CLRF   x52
007E4:  SETF   x57
007E6:  CLRF   F61
007E8:  MOVLW  94
007EA:  MOVWF  x5B
....................    output_high(EN_EXC);
007EC:  MOVLW  E8
007EE:  MOVWF  F8B
007F0:  BSF    F86.0
....................    set_adc_channel(vMonN15); // internal MUX
007F2:  MOVF   x5A,W
007F4:  ANDLW  3F
007F6:  MOVWF  01
007F8:  MOVLW  06
007FA:  MOVWF  x5A
007FC:  BTFSS  x5B.7
007FE:  BRA    080E
00800:  MOVF   01,W
00802:  SUBLW  06
00804:  BZ    080E
00806:  BSF    x5B.0
00808:  NOP   
0080A:  BTFSC  x5B.0
0080C:  BRA    080A
....................    delay_ms(10);
0080E:  MOVLW  0A
00810:  MOVLB  5
00812:  MOVWF  xF3
00814:  MOVLB  0
00816:  RCALL  03F6
....................    read_adc(ADC_START_ONLY);
00818:  MOVLB  F
0081A:  BSF    x5B.0
0081C:  NOP   
....................    setup_external_ADCs();
0081E:  MOVLB  0
00820:  BRA    0774
....................    intTimeoutReg = sensorSampleRate;
00822:  MOVLB  1
00824:  CLRF   x62
00826:  MOVLW  32
00828:  MOVWF  x61
0082A:  MOVLB  0
0082C:  GOTO   9E80 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <control.h>
.................... #ifndef control
.................... #define control
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0.3,0.1,0,0,0,0,0},
....................    {0.01,0.3,0.1,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;           // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... unsigned int16 dacVals[2] = {0,0};
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <pid.h>
.................... #ifndef pidcontroller
.................... #define pidcontroller
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0.3,0.1,0,0,0,0,0},
....................    {0.01,0.3,0.1,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;           // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... unsigned int16 dacVals[2] = {0,0};
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float32)(unsigned int16)y;
.................... 
....................  else if (y < 10000000.0)
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
....................       res = 32768.0*(float32)l;
....................       res += (float32)(unsigned int16)y;
....................    }
.................... 
....................  else
....................   res = y;
.................... 
....................  y = y - (float32)(unsigned int16)y;
.................... 
....................  if (s)
....................   res = -res;
.................... 
....................  if (y != 0)
....................  {
....................   if (s == 1 && n == 0)
....................    res -= 1.0;
.................... 
....................   if (s == 0 && n == 1)
....................    res += 1.0;
....................  }
....................  if (x == 0)
....................     res = 0;
.................... 
....................  return (res);
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl[0]*y2 + pl[1];
.................... 
....................       r = ql[0]*y2 + ql[1];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
....................          r = -(float32)-n;
....................       else
....................          r = (float32)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* UPDATE the Control Variable (CV)                                          */
.................... /*****************************************************************************/
.................... void pid_update (channelMap ch){
*
03D36:  MOVLB  5
03D38:  MOVF   xF2,W
03D3A:  MULLW  20
03D3C:  MOVF   FF3,W
03D3E:  MOVLB  6
03D40:  CLRF   x00
03D42:  MOVLB  5
03D44:  MOVWF  xFF
03D46:  MOVLW  0C
03D48:  ADDWF  xFF,W
03D4A:  MOVWF  01
03D4C:  MOVLW  00
03D4E:  MOVLB  6
03D50:  ADDWFC x00,W
03D52:  MOVWF  03
03D54:  MOVF   01,W
03D56:  ADDLW  20
03D58:  MOVWF  FE9
03D5A:  MOVLW  00
03D5C:  ADDWFC 03,W
03D5E:  MOVWF  FEA
03D60:  MOVFF  FEF,64F
03D64:  MOVFF  FEC,650
03D68:  MOVFF  FEC,651
03D6C:  MOVFF  FEC,652
03D70:  MOVLB  5
03D72:  MOVF   xF2,W
03D74:  MULLW  20
03D76:  MOVF   FF3,W
03D78:  MOVLB  6
03D7A:  CLRF   x04
03D7C:  MOVWF  x03
03D7E:  MOVLW  10
03D80:  ADDWF  x03,W
03D82:  MOVWF  01
03D84:  MOVLW  00
03D86:  ADDWFC x04,W
03D88:  MOVWF  03
03D8A:  MOVF   01,W
03D8C:  ADDLW  20
03D8E:  MOVWF  FE9
03D90:  MOVLW  00
03D92:  ADDWFC 03,W
03D94:  MOVWF  FEA
03D96:  MOVFF  FEF,653
03D9A:  MOVFF  FEC,01
03D9E:  MOVFF  FEC,02
03DA2:  MOVFF  FEC,03
03DA6:  MOVFF  FEA,604
03DAA:  MOVFF  FE9,603
03DAE:  BSF    FD8.1
03DB0:  MOVFF  03,656
03DB4:  MOVFF  02,655
03DB8:  MOVFF  01,654
03DBC:  MOVLB  0
03DBE:  CALL   0BB2
03DC2:  MOVFF  604,FEA
03DC6:  MOVFF  603,FE9
03DCA:  MOVFF  03,5F6
03DCE:  MOVFF  02,5F5
03DD2:  MOVFF  01,5F4
03DD6:  MOVFF  00,5F3
....................    float err = PID[ch].SP - PID[ch].PV;  // error = set value - measured
....................    
....................    PID[ch].I += err*PID[ch].kI;
03DDA:  MOVLB  5
03DDC:  MOVF   xF2,W
03DDE:  MULLW  20
03DE0:  MOVF   FF3,W
03DE2:  MOVLB  6
03DE4:  CLRF   x00
03DE6:  MOVLB  5
03DE8:  MOVWF  xFF
03DEA:  MOVLW  1C
03DEC:  ADDWF  xFF,W
03DEE:  MOVWF  01
03DF0:  MOVLW  00
03DF2:  MOVLB  6
03DF4:  ADDWFC x00,W
03DF6:  MOVWF  03
03DF8:  MOVF   01,W
03DFA:  ADDLW  20
03DFC:  MOVWF  01
03DFE:  MOVLW  00
03E00:  ADDWFC 03,F
03E02:  MOVFF  01,5FF
03E06:  MOVLB  5
03E08:  MOVFF  03,600
03E0C:  MOVFF  03,FEA
03E10:  MOVFF  01,FE9
03E14:  MOVFF  FEF,601
03E18:  MOVFF  FEC,602
03E1C:  MOVFF  FEC,603
03E20:  MOVFF  FEC,604
03E24:  MOVF   xF2,W
03E26:  MULLW  20
03E28:  MOVF   FF3,W
03E2A:  MOVLB  6
03E2C:  CLRF   x06
03E2E:  MOVWF  x05
03E30:  MOVLW  04
03E32:  ADDWF  x05,W
03E34:  MOVWF  01
03E36:  MOVLW  00
03E38:  ADDWFC x06,W
03E3A:  MOVWF  03
03E3C:  MOVF   01,W
03E3E:  ADDLW  20
03E40:  MOVWF  FE9
03E42:  MOVLW  00
03E44:  ADDWFC 03,W
03E46:  MOVWF  FEA
03E48:  MOVFF  FEF,64F
03E4C:  MOVFF  FEC,01
03E50:  MOVFF  FEC,02
03E54:  MOVFF  FEC,03
03E58:  MOVFF  5F6,64E
03E5C:  MOVFF  5F5,64D
03E60:  MOVFF  5F4,64C
03E64:  MOVFF  5F3,64B
03E68:  MOVFF  03,652
03E6C:  MOVFF  02,651
03E70:  MOVFF  01,650
03E74:  MOVLB  0
03E76:  CALL   0ABC
03E7A:  BCF    FD8.1
03E7C:  MOVFF  604,652
03E80:  MOVFF  603,651
03E84:  MOVFF  602,650
03E88:  MOVFF  601,64F
03E8C:  MOVFF  03,656
03E90:  MOVFF  02,655
03E94:  MOVFF  01,654
03E98:  MOVFF  00,653
03E9C:  CALL   0BB2
03EA0:  MOVFF  600,FEA
03EA4:  MOVFF  5FF,FE9
03EA8:  MOVFF  00,FEF
03EAC:  MOVFF  01,FEC
03EB0:  MOVFF  02,FEC
03EB4:  MOVFF  03,FEC
....................    if (PID[ch].I > op_upper_bound) PID[ch].I = op_upper_bound; // anti-windup
03EB8:  MOVLB  5
03EBA:  MOVF   xF2,W
03EBC:  MULLW  20
03EBE:  MOVF   FF3,W
03EC0:  MOVLB  6
03EC2:  CLRF   x00
03EC4:  MOVLB  5
03EC6:  MOVWF  xFF
03EC8:  MOVLW  1C
03ECA:  ADDWF  xFF,W
03ECC:  MOVWF  01
03ECE:  MOVLW  00
03ED0:  MOVLB  6
03ED2:  ADDWFC x00,W
03ED4:  MOVWF  03
03ED6:  MOVF   01,W
03ED8:  ADDLW  20
03EDA:  MOVWF  FE9
03EDC:  MOVLW  00
03EDE:  ADDWFC 03,W
03EE0:  MOVWF  FEA
03EE2:  MOVFF  FEF,64F
03EE6:  MOVFF  FEC,600
03EEA:  MOVFF  FEC,651
03EEE:  MOVFF  FEC,652
03EF2:  CLRF   x4E
03EF4:  CLRF   x4D
03EF6:  MOVLW  7C
03EF8:  MOVWF  x4C
03EFA:  MOVLW  84
03EFC:  MOVWF  x4B
03EFE:  MOVFF  600,650
03F02:  MOVLB  0
03F04:  CALL   146C
03F08:  BNC   3F42
03F0A:  MOVLB  5
03F0C:  MOVF   xF2,W
03F0E:  MULLW  20
03F10:  MOVF   FF3,W
03F12:  MOVLB  6
03F14:  CLRF   x00
03F16:  MOVLB  5
03F18:  MOVWF  xFF
03F1A:  MOVLW  1C
03F1C:  ADDWF  xFF,W
03F1E:  MOVWF  01
03F20:  MOVLW  00
03F22:  MOVLB  6
03F24:  ADDWFC x00,W
03F26:  MOVWF  03
03F28:  MOVF   01,W
03F2A:  ADDLW  20
03F2C:  MOVWF  FE9
03F2E:  MOVLW  00
03F30:  ADDWFC 03,W
03F32:  MOVWF  FEA
03F34:  MOVLW  84
03F36:  MOVWF  FEF
03F38:  MOVLW  7C
03F3A:  MOVWF  FEC
03F3C:  CLRF   FEC
03F3E:  CLRF   FEC
03F40:  BRA    3FCA
....................    else if (PID[ch].I < op_lower_bound) PID[ch].I = op_lower_bound;
03F42:  MOVLB  5
03F44:  MOVF   xF2,W
03F46:  MULLW  20
03F48:  MOVF   FF3,W
03F4A:  MOVLB  6
03F4C:  CLRF   x00
03F4E:  MOVLB  5
03F50:  MOVWF  xFF
03F52:  MOVLW  1C
03F54:  ADDWF  xFF,W
03F56:  MOVWF  01
03F58:  MOVLW  00
03F5A:  MOVLB  6
03F5C:  ADDWFC x00,W
03F5E:  MOVWF  03
03F60:  MOVF   01,W
03F62:  ADDLW  20
03F64:  MOVWF  FE9
03F66:  MOVLW  00
03F68:  ADDWFC 03,W
03F6A:  MOVWF  FEA
03F6C:  MOVFF  FEF,64B
03F70:  MOVFF  FEC,600
03F74:  MOVFF  FEC,64D
03F78:  MOVFF  FEC,64E
03F7C:  MOVFF  600,64C
03F80:  CLRF   x52
03F82:  CLRF   x51
03F84:  MOVLW  FC
03F86:  MOVWF  x50
03F88:  MOVLW  84
03F8A:  MOVWF  x4F
03F8C:  MOVLB  0
03F8E:  CALL   146C
03F92:  BNC   3FCC
03F94:  MOVLB  5
03F96:  MOVF   xF2,W
03F98:  MULLW  20
03F9A:  MOVF   FF3,W
03F9C:  MOVLB  6
03F9E:  CLRF   x00
03FA0:  MOVLB  5
03FA2:  MOVWF  xFF
03FA4:  MOVLW  1C
03FA6:  ADDWF  xFF,W
03FA8:  MOVWF  01
03FAA:  MOVLW  00
03FAC:  MOVLB  6
03FAE:  ADDWFC x00,W
03FB0:  MOVWF  03
03FB2:  MOVF   01,W
03FB4:  ADDLW  20
03FB6:  MOVWF  FE9
03FB8:  MOVLW  00
03FBA:  ADDWFC 03,W
03FBC:  MOVWF  FEA
03FBE:  MOVLW  84
03FC0:  MOVWF  FEF
03FC2:  MOVLW  FC
03FC4:  MOVWF  FEC
03FC6:  CLRF   FEC
03FC8:  CLRF   FEC
03FCA:  MOVLB  0
....................    
....................    float P = err * PID[ch].kP;  // proportional value
....................    
....................    float D = PID[ch].kD * (PID[ch].PV - PID[ch].PVold);  // derivative value
03FCC:  MOVLB  5
03FCE:  MOVF   xF2,W
03FD0:  MULLW  20
03FD2:  MOVF   FF3,W
03FD4:  MOVLB  6
03FD6:  CLRF   x00
03FD8:  MOVLB  5
03FDA:  MOVWF  xFF
03FDC:  MOVLW  20
03FDE:  ADDWF  xFF,W
03FE0:  MOVWF  FE9
03FE2:  MOVLW  00
03FE4:  MOVLB  6
03FE6:  ADDWFC x00,W
03FE8:  MOVWF  FEA
03FEA:  MOVFF  FEF,64F
03FEE:  MOVFF  FEC,01
03FF2:  MOVFF  FEC,02
03FF6:  MOVFF  FEC,03
03FFA:  MOVFF  5F6,64E
03FFE:  MOVFF  5F5,64D
04002:  MOVFF  5F4,64C
04006:  MOVFF  5F3,64B
0400A:  MOVFF  03,652
0400E:  MOVFF  02,651
04012:  MOVFF  01,650
04016:  MOVLB  0
04018:  CALL   0ABC
0401C:  MOVFF  03,5FA
04020:  MOVFF  02,5F9
04024:  MOVFF  01,5F8
04028:  MOVFF  00,5F7
0402C:  MOVLB  5
0402E:  MOVF   xF2,W
04030:  MULLW  20
04032:  MOVF   FF3,W
04034:  MOVLB  6
04036:  CLRF   x02
04038:  MOVWF  x01
0403A:  MOVLW  08
0403C:  ADDWF  x01,W
0403E:  MOVWF  01
04040:  MOVLW  00
04042:  ADDWFC x02,W
04044:  MOVWF  03
04046:  MOVF   01,W
04048:  ADDLW  20
0404A:  MOVWF  FE9
0404C:  MOVLW  00
0404E:  ADDWFC 03,W
04050:  MOVWF  FEA
04052:  MOVFF  FEF,601
04056:  MOVFF  FEC,602
0405A:  MOVFF  FEC,603
0405E:  MOVFF  FEC,604
04062:  MOVLB  5
04064:  MOVF   xF2,W
04066:  MULLW  20
04068:  MOVF   FF3,W
0406A:  MOVLB  6
0406C:  CLRF   x06
0406E:  MOVWF  x05
04070:  MOVLW  10
04072:  ADDWF  x05,W
04074:  MOVWF  01
04076:  MOVLW  00
04078:  ADDWFC x06,W
0407A:  MOVWF  03
0407C:  MOVF   01,W
0407E:  ADDLW  20
04080:  MOVWF  FE9
04082:  MOVLW  00
04084:  ADDWFC 03,W
04086:  MOVWF  FEA
04088:  MOVFF  FEF,64F
0408C:  MOVFF  FEC,650
04090:  MOVFF  FEC,651
04094:  MOVFF  FEC,652
04098:  MOVLB  5
0409A:  MOVF   xF2,W
0409C:  MULLW  20
0409E:  MOVF   FF3,W
040A0:  MOVLB  6
040A2:  CLRF   x0A
040A4:  MOVWF  x09
040A6:  MOVLW  14
040A8:  ADDWF  x09,W
040AA:  MOVWF  01
040AC:  MOVLW  00
040AE:  ADDWFC x0A,W
040B0:  MOVWF  03
040B2:  MOVF   01,W
040B4:  ADDLW  20
040B6:  MOVWF  FE9
040B8:  MOVLW  00
040BA:  ADDWFC 03,W
040BC:  MOVWF  FEA
040BE:  MOVFF  FEF,653
040C2:  MOVFF  FEC,01
040C6:  MOVFF  FEC,02
040CA:  MOVFF  FEC,03
040CE:  MOVFF  FEA,60A
040D2:  MOVFF  FE9,609
040D6:  BSF    FD8.1
040D8:  MOVFF  03,656
040DC:  MOVFF  02,655
040E0:  MOVFF  01,654
040E4:  MOVLB  0
040E6:  CALL   0BB2
040EA:  MOVFF  60A,FEA
040EE:  MOVFF  609,FE9
040F2:  MOVFF  604,64E
040F6:  MOVFF  603,64D
040FA:  MOVFF  602,64C
040FE:  MOVFF  601,64B
04102:  MOVFF  03,652
04106:  MOVFF  02,651
0410A:  MOVFF  01,650
0410E:  MOVFF  00,64F
04112:  CALL   0ABC
04116:  MOVFF  03,5FE
0411A:  MOVFF  02,5FD
0411E:  MOVFF  01,5FC
04122:  MOVFF  00,5FB
....................    
....................    PID[ch].CV = P + PID[ch].I + D;  // new control variable
04126:  MOVLB  5
04128:  MOVF   xF2,W
0412A:  MULLW  20
0412C:  MOVF   FF3,W
0412E:  MOVLB  6
04130:  CLRF   x00
04132:  MOVLB  5
04134:  MOVWF  xFF
04136:  MOVLW  18
04138:  ADDWF  xFF,W
0413A:  MOVWF  01
0413C:  MOVLW  00
0413E:  MOVLB  6
04140:  ADDWFC x00,W
04142:  MOVWF  03
04144:  MOVF   01,W
04146:  ADDLW  20
04148:  MOVWF  01
0414A:  MOVLW  00
0414C:  ADDWFC 03,F
0414E:  MOVFF  01,5FF
04152:  MOVLB  5
04154:  MOVFF  03,600
04158:  MOVF   xF2,W
0415A:  MULLW  20
0415C:  MOVF   FF3,W
0415E:  MOVLB  6
04160:  CLRF   x02
04162:  MOVWF  x01
04164:  MOVLW  1C
04166:  ADDWF  x01,W
04168:  MOVWF  01
0416A:  MOVLW  00
0416C:  ADDWFC x02,W
0416E:  MOVWF  03
04170:  MOVF   01,W
04172:  ADDLW  20
04174:  MOVWF  FE9
04176:  MOVLW  00
04178:  ADDWFC 03,W
0417A:  MOVWF  FEA
0417C:  MOVFF  FEF,653
04180:  MOVFF  FEC,01
04184:  MOVFF  FEC,02
04188:  MOVFF  FEC,03
0418C:  MOVFF  FEA,602
04190:  MOVFF  FE9,601
04194:  BCF    FD8.1
04196:  MOVFF  5FA,652
0419A:  MOVFF  5F9,651
0419E:  MOVFF  5F8,650
041A2:  MOVFF  5F7,64F
041A6:  MOVFF  03,656
041AA:  MOVFF  02,655
041AE:  MOVFF  01,654
041B2:  MOVLB  0
041B4:  CALL   0BB2
041B8:  MOVFF  602,FEA
041BC:  MOVFF  601,FE9
041C0:  MOVFF  03,606
041C4:  MOVFF  02,605
041C8:  MOVFF  01,604
041CC:  MOVFF  00,603
041D0:  BCF    FD8.1
041D2:  MOVFF  03,652
041D6:  MOVFF  02,651
041DA:  MOVFF  01,650
041DE:  MOVFF  00,64F
041E2:  MOVFF  5FE,656
041E6:  MOVFF  5FD,655
041EA:  MOVFF  5FC,654
041EE:  MOVFF  5FB,653
041F2:  CALL   0BB2
041F6:  MOVFF  600,FEA
041FA:  MOVFF  5FF,FE9
041FE:  MOVFF  00,FEF
04202:  MOVFF  01,FEC
04206:  MOVFF  02,FEC
0420A:  MOVFF  03,FEC
....................    if (PID[ch].CV > op_upper_bound) PID[ch].CV = op_upper_bound; // limit positive output
0420E:  MOVLB  5
04210:  MOVF   xF2,W
04212:  MULLW  20
04214:  MOVF   FF3,W
04216:  MOVLB  6
04218:  CLRF   x00
0421A:  MOVLB  5
0421C:  MOVWF  xFF
0421E:  MOVLW  18
04220:  ADDWF  xFF,W
04222:  MOVWF  01
04224:  MOVLW  00
04226:  MOVLB  6
04228:  ADDWFC x00,W
0422A:  MOVWF  03
0422C:  MOVF   01,W
0422E:  ADDLW  20
04230:  MOVWF  FE9
04232:  MOVLW  00
04234:  ADDWFC 03,W
04236:  MOVWF  FEA
04238:  MOVFF  FEF,64F
0423C:  MOVFF  FEC,600
04240:  MOVFF  FEC,651
04244:  MOVFF  FEC,652
04248:  CLRF   x4E
0424A:  CLRF   x4D
0424C:  MOVLW  7C
0424E:  MOVWF  x4C
04250:  MOVLW  84
04252:  MOVWF  x4B
04254:  MOVFF  600,650
04258:  MOVLB  0
0425A:  CALL   146C
0425E:  BNC   4298
04260:  MOVLB  5
04262:  MOVF   xF2,W
04264:  MULLW  20
04266:  MOVF   FF3,W
04268:  MOVLB  6
0426A:  CLRF   x00
0426C:  MOVLB  5
0426E:  MOVWF  xFF
04270:  MOVLW  18
04272:  ADDWF  xFF,W
04274:  MOVWF  01
04276:  MOVLW  00
04278:  MOVLB  6
0427A:  ADDWFC x00,W
0427C:  MOVWF  03
0427E:  MOVF   01,W
04280:  ADDLW  20
04282:  MOVWF  FE9
04284:  MOVLW  00
04286:  ADDWFC 03,W
04288:  MOVWF  FEA
0428A:  MOVLW  84
0428C:  MOVWF  FEF
0428E:  MOVLW  7C
04290:  MOVWF  FEC
04292:  CLRF   FEC
04294:  CLRF   FEC
04296:  BRA    4320
....................    else if (PID[ch].CV < op_lower_bound) PID[ch].CV = op_lower_bound; // limit negative output
04298:  MOVLB  5
0429A:  MOVF   xF2,W
0429C:  MULLW  20
0429E:  MOVF   FF3,W
042A0:  MOVLB  6
042A2:  CLRF   x00
042A4:  MOVLB  5
042A6:  MOVWF  xFF
042A8:  MOVLW  18
042AA:  ADDWF  xFF,W
042AC:  MOVWF  01
042AE:  MOVLW  00
042B0:  MOVLB  6
042B2:  ADDWFC x00,W
042B4:  MOVWF  03
042B6:  MOVF   01,W
042B8:  ADDLW  20
042BA:  MOVWF  FE9
042BC:  MOVLW  00
042BE:  ADDWFC 03,W
042C0:  MOVWF  FEA
042C2:  MOVFF  FEF,64B
042C6:  MOVFF  FEC,600
042CA:  MOVFF  FEC,64D
042CE:  MOVFF  FEC,64E
042D2:  MOVFF  600,64C
042D6:  CLRF   x52
042D8:  CLRF   x51
042DA:  MOVLW  FC
042DC:  MOVWF  x50
042DE:  MOVLW  84
042E0:  MOVWF  x4F
042E2:  MOVLB  0
042E4:  CALL   146C
042E8:  BNC   4320
042EA:  MOVLB  5
042EC:  MOVF   xF2,W
042EE:  MULLW  20
042F0:  MOVF   FF3,W
042F2:  MOVLB  6
042F4:  CLRF   x00
042F6:  MOVLB  5
042F8:  MOVWF  xFF
042FA:  MOVLW  18
042FC:  ADDWF  xFF,W
042FE:  MOVWF  01
04300:  MOVLW  00
04302:  MOVLB  6
04304:  ADDWFC x00,W
04306:  MOVWF  03
04308:  MOVF   01,W
0430A:  ADDLW  20
0430C:  MOVWF  FE9
0430E:  MOVLW  00
04310:  ADDWFC 03,W
04312:  MOVWF  FEA
04314:  MOVLW  84
04316:  MOVWF  FEF
04318:  MOVLW  FC
0431A:  MOVWF  FEC
0431C:  CLRF   FEC
0431E:  CLRF   FEC
04320:  MOVLB  0
04322:  GOTO   439A (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PID Task - looks for change to PV and updates CV                          */
.................... /*****************************************************************************/
.................... void pid_task(channelMap ch){
....................    static int index = 0;
....................    if (PID[ch].SP != PID[ch].PV) pid_update(ch);
04326:  MOVLB  5
04328:  MOVF   xF1,W
0432A:  MULLW  20
0432C:  MOVF   FF3,W
0432E:  CLRF   xF3
04330:  MOVWF  xF2
04332:  MOVLW  0C
04334:  ADDWF  xF2,W
04336:  MOVWF  01
04338:  MOVLW  00
0433A:  ADDWFC xF3,W
0433C:  MOVWF  03
0433E:  MOVF   01,W
04340:  ADDLW  20
04342:  MOVWF  FE9
04344:  MOVLW  00
04346:  ADDWFC 03,W
04348:  MOVWF  FEA
0434A:  MOVFF  FEF,64B
0434E:  MOVFF  FEC,64C
04352:  MOVFF  FEC,64D
04356:  MOVFF  FEC,64E
0435A:  MOVF   xF1,W
0435C:  MULLW  20
0435E:  MOVF   FF3,W
04360:  CLRF   xF7
04362:  MOVWF  xF6
04364:  MOVLW  10
04366:  ADDWF  xF6,W
04368:  MOVWF  01
0436A:  MOVLW  00
0436C:  ADDWFC xF7,W
0436E:  MOVWF  03
04370:  MOVF   01,W
04372:  ADDLW  20
04374:  MOVWF  FE9
04376:  MOVLW  00
04378:  ADDWFC 03,W
0437A:  MOVWF  FEA
0437C:  MOVFF  FEF,64F
04380:  MOVFF  FEC,650
04384:  MOVFF  FEC,651
04388:  MOVFF  FEC,652
0438C:  MOVLB  0
0438E:  CALL   146C
04392:  BZ    439A
04394:  MOVFF  5F1,5F2
04398:  BRA    3D36
....................    if ((index++) >= numChannels) index = 0;
0439A:  MOVLB  1
0439C:  MOVF   x68,W
0439E:  INCF   x68,F
043A0:  SUBLW  01
043A2:  BC    43A6
043A4:  CLRF   x68
043A6:  MOVLB  0
043A8:  GOTO   4498 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... #pin_select SCK1=PIN_C3
.................... #pin_select SDO1=PIN_C2
.................... #use spi (MASTER, SPI1, BAUD=100000, MODE=2, STREAM=SPI_ctrl)
*
00830:  CLRF   03
00832:  MOVF   F91,W
00834:  MOVFF  5F3,F91
00838:  RRCF   F94,W
0083A:  BNC   0838
0083C:  MOVF   F91,W
0083E:  MOVWF  02
00840:  MOVFF  5F2,F91
00844:  RRCF   F94,W
00846:  BNC   0844
00848:  MOVF   F91,W
0084A:  MOVWF  01
0084C:  MOVFF  5F1,F91
00850:  RRCF   F94,W
00852:  BNC   0850
00854:  MOVFF  F91,00
00858:  RETURN 0
.................... 
.................... #define DACfullScale 655.35 // full scale/100 because CV = %
.................... 
.................... /*****************************************************************************/
.................... /*  Inverts the output voltage ( -180V - 0V )                                */ 
.................... /*****************************************************************************/
.................... void invert_voltage(channelMap ch, BOOLEAN inv_v){
....................    if ( inv_v ) {
*
03CDA:  MOVLB  5
03CDC:  MOVF   xF2,F
03CDE:  BZ    3D0A
....................       if (chMap[0] == ch) output_low(INV_HVX);
03CE0:  MOVLW  00
03CE2:  MOVLB  0
03CE4:  BTFSC  x60.0
03CE6:  MOVLW  01
03CE8:  MOVLB  5
03CEA:  SUBWF  xF1,W
03CEC:  BNZ   3CF4
03CEE:  MOVLW  C4
03CF0:  MOVWF  F88
03CF2:  BCF    F83.4
....................       if (chMap[1] == ch) output_low(INV_HVY);
03CF4:  MOVLW  00
03CF6:  MOVLB  0
03CF8:  BTFSC  x60.1
03CFA:  MOVLW  01
03CFC:  MOVLB  5
03CFE:  SUBWF  xF1,W
03D00:  BNZ   3D08
03D02:  MOVLW  C4
03D04:  MOVWF  F88
03D06:  BCF    F83.5
....................    }
03D08:  BRA    3D32
....................    else {
....................       if (chMap[0] == ch) output_high(INV_HVX);
03D0A:  MOVLW  00
03D0C:  MOVLB  0
03D0E:  BTFSC  x60.0
03D10:  MOVLW  01
03D12:  MOVLB  5
03D14:  SUBWF  xF1,W
03D16:  BNZ   3D1E
03D18:  MOVLW  C4
03D1A:  MOVWF  F88
03D1C:  BSF    F83.4
....................       if (chMap[1] == ch) output_high(INV_HVY);
03D1E:  MOVLW  00
03D20:  MOVLB  0
03D22:  BTFSC  x60.1
03D24:  MOVLW  01
03D26:  MOVLB  5
03D28:  SUBWF  xF1,W
03D2A:  BNZ   3D32
03D2C:  MOVLW  C4
03D2E:  MOVWF  F88
03D30:  BSF    F83.5
....................    }
03D32:  MOVLB  0
03D34:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  Nano DAC's have a 16bit serial shift register. Data is sync'ed to output */ 
.................... /*****************************************************************************/
.................... void set_nanoDAC_outputs(channelMap ch){
*
043AC:  MOVLB  5
043AE:  CLRF   xF0
043B0:  CLRF   xEF
....................    unsigned int16 txData = 0;
....................    
....................    // use manualOutputValues if channel is manual mode
....................    // else, use PID control variable
....................    if (chMode[ch] == MANUAL){
043B2:  MOVFF  5EE,5FB
043B6:  CLRF   xFD
043B8:  MOVLW  61
043BA:  MOVWF  xFC
043BC:  MOVLB  0
043BE:  RCALL  3CA4
043C0:  MOVF   01,F
043C2:  BNZ   4492
....................       if ( manualOutputValues[ch] < 0) invert_voltage(ch, TRUE); 
043C4:  MOVLB  5
043C6:  MOVF   xEE,W
043C8:  MULLW  04
043CA:  MOVF   FF3,W
043CC:  CLRF   03
043CE:  ADDLW  EA
043D0:  MOVWF  FE9
043D2:  MOVLW  00
043D4:  ADDWFC 03,W
043D6:  MOVWF  FEA
043D8:  MOVFF  FEF,64B
043DC:  MOVFF  FEC,64C
043E0:  MOVFF  FEC,64D
043E4:  MOVFF  FEC,64E
043E8:  MOVLB  6
043EA:  CLRF   x52
043EC:  CLRF   x51
043EE:  CLRF   x50
043F0:  CLRF   x4F
043F2:  MOVLB  0
043F4:  CALL   146C
043F8:  BNC   440A
043FA:  MOVFF  5EE,5F1
043FE:  MOVLW  01
04400:  MOVLB  5
04402:  MOVWF  xF2
04404:  MOVLB  0
04406:  RCALL  3CDA
04408:  BRA    4416
....................       else                             invert_voltage(ch, FALSE);
0440A:  MOVFF  5EE,5F1
0440E:  MOVLB  5
04410:  CLRF   xF2
04412:  MOVLB  0
04414:  RCALL  3CDA
....................       
....................       txData = (unsigned int16)(abs(manualOutputValues[ch]) * DACfullScale);
04416:  MOVLB  5
04418:  MOVF   xEE,W
0441A:  MULLW  04
0441C:  MOVF   FF3,W
0441E:  CLRF   03
04420:  ADDLW  EA
04422:  MOVWF  FE9
04424:  MOVLW  00
04426:  ADDWFC 03,W
04428:  MOVWF  FEA
0442A:  MOVFF  FEF,00
0442E:  MOVFF  FEC,01
04432:  MOVFF  FEC,02
04436:  MOVFF  FEC,03
0443A:  BCF    01.7
0443C:  MOVFF  03,5F4
04440:  MOVFF  02,5F3
04444:  MOVFF  01,5F2
04448:  MOVFF  00,5F1
0444C:  MOVFF  03,64E
04450:  MOVFF  02,64D
04454:  MOVFF  01,64C
04458:  MOVFF  00,64B
0445C:  MOVLW  66
0445E:  MOVLB  6
04460:  MOVWF  x52
04462:  MOVLW  D6
04464:  MOVWF  x51
04466:  MOVLW  23
04468:  MOVWF  x50
0446A:  MOVLW  88
0446C:  MOVWF  x4F
0446E:  MOVLB  0
04470:  CALL   0ABC
04474:  MOVFF  03,64E
04478:  MOVFF  02,64D
0447C:  MOVFF  01,64C
04480:  MOVFF  00,64B
04484:  CALL   1E60
04488:  MOVFF  02,5F0
0448C:  MOVFF  01,5EF
....................    }
04490:  BRA    4588
....................    else {
....................       pid_task(ch);
04492:  MOVFF  5EE,5F1
04496:  BRA    4326
....................       if ( PID[(int)ch].CV < 0 ) invert_voltage(ch, TRUE); 
04498:  MOVLB  5
0449A:  MOVF   xEE,W
0449C:  MULLW  20
0449E:  MOVF   FF3,W
044A0:  CLRF   xF2
044A2:  MOVWF  xF1
044A4:  MOVLW  18
044A6:  ADDWF  xF1,W
044A8:  MOVWF  01
044AA:  MOVLW  00
044AC:  ADDWFC xF2,W
044AE:  MOVWF  03
044B0:  MOVF   01,W
044B2:  ADDLW  20
044B4:  MOVWF  FE9
044B6:  MOVLW  00
044B8:  ADDWFC 03,W
044BA:  MOVWF  FEA
044BC:  MOVFF  FEF,64B
044C0:  MOVFF  FEC,64C
044C4:  MOVFF  FEC,64D
044C8:  MOVFF  FEC,64E
044CC:  MOVLB  6
044CE:  CLRF   x52
044D0:  CLRF   x51
044D2:  CLRF   x50
044D4:  CLRF   x4F
044D6:  MOVLB  0
044D8:  CALL   146C
044DC:  BNC   44F0
044DE:  MOVFF  5EE,5F1
044E2:  MOVLW  01
044E4:  MOVLB  5
044E6:  MOVWF  xF2
044E8:  MOVLB  0
044EA:  CALL   3CDA
044EE:  BRA    44FE
....................       else                       invert_voltage(ch, FALSE);
044F0:  MOVFF  5EE,5F1
044F4:  MOVLB  5
044F6:  CLRF   xF2
044F8:  MOVLB  0
044FA:  CALL   3CDA
....................       
....................       txData = (unsigned int16)(abs(PID[(int)ch].CV) * DACfullScale);
044FE:  MOVLB  5
04500:  MOVF   xEE,W
04502:  MULLW  20
04504:  MOVF   FF3,W
04506:  CLRF   xF2
04508:  MOVWF  xF1
0450A:  MOVLW  18
0450C:  ADDWF  xF1,W
0450E:  MOVWF  01
04510:  MOVLW  00
04512:  ADDWFC xF2,W
04514:  MOVWF  03
04516:  MOVF   01,W
04518:  ADDLW  20
0451A:  MOVWF  FE9
0451C:  MOVLW  00
0451E:  ADDWFC 03,W
04520:  MOVWF  FEA
04522:  MOVFF  FEF,00
04526:  MOVFF  FEC,01
0452A:  MOVFF  FEC,02
0452E:  MOVFF  FEC,03
04532:  BCF    01.7
04534:  MOVFF  03,5F4
04538:  MOVFF  02,5F3
0453C:  MOVFF  01,5F2
04540:  MOVFF  00,5F1
04544:  MOVFF  03,64E
04548:  MOVFF  02,64D
0454C:  MOVFF  01,64C
04550:  MOVFF  00,64B
04554:  MOVLW  66
04556:  MOVLB  6
04558:  MOVWF  x52
0455A:  MOVLW  D6
0455C:  MOVWF  x51
0455E:  MOVLW  23
04560:  MOVWF  x50
04562:  MOVLW  88
04564:  MOVWF  x4F
04566:  MOVLB  0
04568:  CALL   0ABC
0456C:  MOVFF  03,64E
04570:  MOVFF  02,64D
04574:  MOVFF  01,64C
04578:  MOVFF  00,64B
0457C:  CALL   1E60
04580:  MOVFF  02,5F0
04584:  MOVFF  01,5EF
....................    }
....................    
....................    dacVals[ch] = txData;
04588:  BCF    FD8.0
0458A:  MOVLB  5
0458C:  RLCF   xEE,W
0458E:  CLRF   03
04590:  ADDLW  51
04592:  MOVWF  FE9
04594:  MOVLW  01
04596:  ADDWFC 03,W
04598:  MOVWF  FEA
0459A:  MOVFF  5F0,FEC
0459E:  MOVF   FED,F
045A0:  MOVFF  5EF,FEF
....................    
....................    // use channel map to decide which outputs channels to update
....................    // strobe _sync low to push data to the outputs
....................    if (chMap[0] == ch) output_high(_SYNC_X);
045A4:  MOVLW  00
045A6:  MOVLB  0
045A8:  BTFSC  x60.0
045AA:  MOVLW  01
045AC:  MOVLB  5
045AE:  SUBWF  xEE,W
045B0:  BNZ   45B8
045B2:  MOVLW  E8
045B4:  MOVWF  F8B
045B6:  BSF    F86.2
....................    if (chMap[1] == ch) output_high(_SYNC_Y);
045B8:  MOVLW  00
045BA:  MOVLB  0
045BC:  BTFSC  x60.1
045BE:  MOVLW  01
045C0:  MOVLB  5
045C2:  SUBWF  xEE,W
045C4:  BNZ   45CC
045C6:  MOVLW  E8
045C8:  MOVWF  F8B
045CA:  BSF    F86.1
....................    
....................    delay_ms(1);
045CC:  MOVLW  01
045CE:  MOVWF  xF3
045D0:  MOVLB  0
045D2:  CALL   03F6
....................    
....................    if (chMap[0] == ch) output_low(_SYNC_X);
045D6:  MOVLW  00
045D8:  BTFSC  x60.0
045DA:  MOVLW  01
045DC:  MOVLB  5
045DE:  SUBWF  xEE,W
045E0:  BNZ   45E8
045E2:  MOVLW  E8
045E4:  MOVWF  F8B
045E6:  BCF    F86.2
....................    if (chMap[1] == ch) output_low(_SYNC_Y);
045E8:  MOVLW  00
045EA:  MOVLB  0
045EC:  BTFSC  x60.1
045EE:  MOVLW  01
045F0:  MOVLB  5
045F2:  SUBWF  xEE,W
045F4:  BNZ   45FC
045F6:  MOVLW  E8
045F8:  MOVWF  F8B
045FA:  BCF    F86.1
....................    delay_ms(1);
045FC:  MOVLW  01
045FE:  MOVWF  xF3
04600:  MOVLB  0
04602:  CALL   03F6
....................    
....................    // shift 16 bits of data
....................    spi_xfer(SPI_ctrl, txData, 24);
04606:  MOVLB  5
04608:  CLRF   xF4
0460A:  CLRF   xF3
0460C:  MOVFF  5F0,5F2
04610:  MOVFF  5EF,5F1
04614:  MOVLB  0
04616:  CALL   0830
....................    delay_ms(1);
0461A:  MOVLW  01
0461C:  MOVLB  5
0461E:  MOVWF  xF3
04620:  MOVLB  0
04622:  CALL   03F6
....................    
....................    if (chMap[0] == ch) output_high(_SYNC_X);
04626:  MOVLW  00
04628:  BTFSC  x60.0
0462A:  MOVLW  01
0462C:  MOVLB  5
0462E:  SUBWF  xEE,W
04630:  BNZ   4638
04632:  MOVLW  E8
04634:  MOVWF  F8B
04636:  BSF    F86.2
....................    if (chMap[1] == ch) output_high(_SYNC_Y);
04638:  MOVLW  00
0463A:  MOVLB  0
0463C:  BTFSC  x60.1
0463E:  MOVLW  01
04640:  MOVLB  5
04642:  SUBWF  xEE,W
04644:  BNZ   464C
04646:  MOVLW  E8
04648:  MOVWF  F8B
0464A:  BSF    F86.1
0464C:  MOVLB  0
0464E:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  control task sets up the outputs channels                                */ 
.................... /*****************************************************************************/
.................... void control_task(){
....................    static int state = 0;
....................    
....................    switch (state)
04650:  MOVLB  1
04652:  MOVF   x69,W
04654:  XORLW  00
04656:  MOVLB  0
04658:  BZ    4660
0465A:  XORLW  01
0465C:  BZ    4672
0465E:  BRA    4682
....................    {
....................       case 0:
....................          set_nanoDAC_outputs(chX);
04660:  MOVLB  5
04662:  CLRF   xEE
04664:  MOVLB  0
04666:  RCALL  43AC
....................          state = 1;
04668:  MOVLW  01
0466A:  MOVLB  1
0466C:  MOVWF  x69
....................       break;
0466E:  MOVLB  0
04670:  BRA    4682
....................       case 1:
....................          set_nanoDAC_outputs(chY);
04672:  MOVLW  01
04674:  MOVLB  5
04676:  MOVWF  xEE
04678:  MOVLB  0
0467A:  RCALL  43AC
....................          state = 0;
0467C:  MOVLB  1
0467E:  CLRF   x69
....................       break;
04680:  MOVLB  0
....................    }
04682:  GOTO   9E9C (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  control task sets up the outputs channels                                */ 
.................... /*****************************************************************************/
.................... void control_init(){
....................    spi_xfer(SPI_ctrl, 0, 24);
*
0085A:  MOVLB  5
0085C:  CLRF   xF4
0085E:  CLRF   xF3
00860:  CLRF   xF2
00862:  CLRF   xF1
00864:  MOVLB  0
00866:  RCALL  0830
....................    output_low(_SYNC_X);
00868:  MOVLW  E8
0086A:  MOVWF  F8B
0086C:  BCF    F86.2
....................    output_low(_SYNC_Y);
0086E:  MOVWF  F8B
00870:  BCF    F86.1
....................    output_high(_SYNC_X);
00872:  MOVWF  F8B
00874:  BSF    F86.2
....................    output_high(_SYNC_Y);
00876:  MOVWF  F8B
00878:  BSF    F86.1
0087A:  GOTO   9E84 (RETURN)
.................... }
.................... #endif
.................... 
.................... #include <serialport.h>
.................... #ifndef serialPort
.................... #define serialPort
.................... #include <cmdBuffer.h>
.................... #ifndef cmd_buffer
.................... #define cmd_buffer
.................... 
.................... /*****************************************************************************/
.................... /* DIFCS COMMAND BUFFER                                                      */
.................... /* The beginning of a message is signified by an address record. The address */
.................... /* is 4 characters. The first 2 are the hardware identifier (TC - temperature*/
.................... /* controller, DC - difics controller, etc..) The second 2 characters dev-   */
.................... /* ice ID... Valid values are 00 thru 0F. A device ID of FF writes to all    */
.................... /* boards. This might be used to feed angles data to all listeners.          */
.................... /*****************************************************************************/
.................... 
.................... // t,p0,p1,p2,p3,p4,p5,p6
.................... // t is the start character, p0 is the address, p1 is command, p2-6 are params
.................... // these characters used for storing messages
.................... 
.................... #define startChr '~' // start character. Also diagnostic command type
.................... #define diagCmdType startChr
.................... #define endChr '\n'
.................... #define delimiter ','
.................... #define ignoreChr1 '\r'
.................... #define ignoreChr2 ' '
.................... #define noRecordFound (char)0xFF
.................... 
.................... #define numRecords 4
.................... #define numParam 7
.................... #define lenParam 25
.................... 
.................... #define useSerial
.................... //#define useTCPIP
.................... 
.................... typedef enum cmdMode {tcp, ser};
.................... 
.................... // this structure holds a command. This is used by the serial routine as well
.................... // as the TCP routine to store an incoming command + parameters
.................... // in the case of TCP socket id is also passed in this structure
.................... typedef struct cmd 
.................... {
....................    BOOLEAN full;        // if full, command is ready to execute
....................    unsigned int8 chrIndex;
....................    unsigned int8 paramIndex;
....................    unsigned int8 recReadIndex;
....................    unsigned int8 recWriteIndex;
....................    #ifdef useTCPIP
....................    TCP_SOCKET s;              // socket ID for TCP commands 
....................    #endif
....................    char t;
....................    char p[numParam][lenParam];   // only used with ~ type command
.................... };
.................... 
.................... #ifdef useSerial
.................... struct cmd SERcmd[numRecords]; // holds serial command 
.................... unsigned int8 SRI = 0; //usb readindex
.................... unsigned int8 SWI = 0; //usb write index
.................... #endif
.................... 
.................... #ifdef useTCPIP
.................... struct cmd TCPcmd[numRecords]; // holds TCP command
.................... unsigned int8 TRI = 0; //usb readindex
.................... unsigned int8 TWI = 0; //usb write index
.................... #endif
.................... 
.................... char retData[100]; // this is used to hold return data 
.................... 
.................... #ifdef useSerial
.................... /*****************************************************************************/
.................... /* RESET SER COMMAND -- ready for a new command                              */
.................... /*****************************************************************************/
.................... void resetSERcmd(unsigned int8 recNum)
.................... {
....................    if (recNum < numRecords)
*
008A0:  MOVLB  5
008A2:  MOVF   xEF,W
008A4:  SUBLW  03
008A6:  BTFSS  FD8.0
008A8:  BRA    0A26
....................    {
....................       for (int i = 0; i <numParam; i ++)
008AA:  CLRF   xF0
008AC:  MOVF   xF0,W
008AE:  SUBLW  06
008B0:  BNC   0904
....................       {
....................          SERcmd[recNum].p[i][0] = '\0';
008B2:  MOVLB  6
008B4:  CLRF   x30
008B6:  MOVFF  5EF,62F
008BA:  CLRF   x32
008BC:  MOVLW  B5
008BE:  MOVWF  x31
008C0:  MOVLB  0
008C2:  RCALL  087E
008C4:  MOVFF  02,5F2
008C8:  MOVFF  01,5F1
008CC:  MOVLW  06
008CE:  MOVLB  5
008D0:  ADDWF  xF1,F
008D2:  MOVLW  00
008D4:  ADDWFC xF2,F
008D6:  MOVLB  6
008D8:  CLRF   x30
008DA:  MOVFF  5F0,62F
008DE:  CLRF   x32
008E0:  MOVLW  19
008E2:  MOVWF  x31
008E4:  MOVLB  0
008E6:  RCALL  087E
008E8:  MOVF   01,W
008EA:  MOVLB  5
008EC:  ADDWF  xF1,F
008EE:  MOVF   02,W
008F0:  ADDWFC xF2,F
008F2:  MOVLW  6A
008F4:  ADDWF  xF1,W
008F6:  MOVWF  FE9
008F8:  MOVLW  01
008FA:  ADDWFC xF2,W
008FC:  MOVWF  FEA
008FE:  CLRF   FEF
00900:  INCF   xF0,F
00902:  BRA    08AC
....................       }
....................       SERcmd[recNum].t = 0;
00904:  MOVLB  6
00906:  CLRF   x30
00908:  MOVFF  5EF,62F
0090C:  CLRF   x32
0090E:  MOVLW  B5
00910:  MOVWF  x31
00912:  MOVLB  0
00914:  RCALL  087E
00916:  MOVFF  01,5F1
0091A:  MOVLW  05
0091C:  MOVLB  5
0091E:  ADDWF  01,W
00920:  MOVWF  01
00922:  MOVLW  00
00924:  ADDWFC 02,W
00926:  MOVWF  03
00928:  MOVF   01,W
0092A:  ADDLW  6A
0092C:  MOVWF  FE9
0092E:  MOVLW  01
00930:  ADDWFC 03,W
00932:  MOVWF  FEA
00934:  CLRF   FEF
....................       SERcmd[recNum].chrIndex = 0;
00936:  MOVLB  6
00938:  CLRF   x30
0093A:  MOVFF  5EF,62F
0093E:  CLRF   x32
00940:  MOVLW  B5
00942:  MOVWF  x31
00944:  MOVLB  0
00946:  RCALL  087E
00948:  MOVFF  01,5F1
0094C:  MOVLW  01
0094E:  MOVLB  5
00950:  ADDWF  01,W
00952:  MOVWF  01
00954:  MOVLW  00
00956:  ADDWFC 02,W
00958:  MOVWF  03
0095A:  MOVF   01,W
0095C:  ADDLW  6A
0095E:  MOVWF  FE9
00960:  MOVLW  01
00962:  ADDWFC 03,W
00964:  MOVWF  FEA
00966:  CLRF   FEF
....................       SERcmd[recNum].paramIndex = 0;
00968:  MOVLB  6
0096A:  CLRF   x30
0096C:  MOVFF  5EF,62F
00970:  CLRF   x32
00972:  MOVLW  B5
00974:  MOVWF  x31
00976:  MOVLB  0
00978:  RCALL  087E
0097A:  MOVFF  01,5F1
0097E:  MOVLW  02
00980:  MOVLB  5
00982:  ADDWF  01,W
00984:  MOVWF  01
00986:  MOVLW  00
00988:  ADDWFC 02,W
0098A:  MOVWF  03
0098C:  MOVF   01,W
0098E:  ADDLW  6A
00990:  MOVWF  FE9
00992:  MOVLW  01
00994:  ADDWFC 03,W
00996:  MOVWF  FEA
00998:  CLRF   FEF
....................       SERcmd[recNum].recReadIndex = 0;
0099A:  MOVLB  6
0099C:  CLRF   x30
0099E:  MOVFF  5EF,62F
009A2:  CLRF   x32
009A4:  MOVLW  B5
009A6:  MOVWF  x31
009A8:  MOVLB  0
009AA:  RCALL  087E
009AC:  MOVFF  01,5F1
009B0:  MOVLW  03
009B2:  MOVLB  5
009B4:  ADDWF  01,W
009B6:  MOVWF  01
009B8:  MOVLW  00
009BA:  ADDWFC 02,W
009BC:  MOVWF  03
009BE:  MOVF   01,W
009C0:  ADDLW  6A
009C2:  MOVWF  FE9
009C4:  MOVLW  01
009C6:  ADDWFC 03,W
009C8:  MOVWF  FEA
009CA:  CLRF   FEF
....................       SERcmd[recNum].recWriteIndex = 0;
009CC:  MOVLB  6
009CE:  CLRF   x30
009D0:  MOVFF  5EF,62F
009D4:  CLRF   x32
009D6:  MOVLW  B5
009D8:  MOVWF  x31
009DA:  MOVLB  0
009DC:  RCALL  087E
009DE:  MOVFF  01,5F1
009E2:  MOVLW  04
009E4:  MOVLB  5
009E6:  ADDWF  01,W
009E8:  MOVWF  01
009EA:  MOVLW  00
009EC:  ADDWFC 02,W
009EE:  MOVWF  03
009F0:  MOVF   01,W
009F2:  ADDLW  6A
009F4:  MOVWF  FE9
009F6:  MOVLW  01
009F8:  ADDWFC 03,W
009FA:  MOVWF  FEA
009FC:  CLRF   FEF
....................       SERcmd[recNum].full = FALSE;
009FE:  MOVLB  6
00A00:  CLRF   x30
00A02:  MOVFF  5EF,62F
00A06:  CLRF   x32
00A08:  MOVLW  B5
00A0A:  MOVWF  x31
00A0C:  MOVLB  0
00A0E:  RCALL  087E
00A10:  MOVLW  6A
00A12:  MOVLB  5
00A14:  ADDWF  01,W
00A16:  MOVWF  FE9
00A18:  MOVLW  01
00A1A:  ADDWFC 02,W
00A1C:  MOVWF  FEA
00A1E:  BCF    FEF.0
....................       retData[0] = '\0';
00A20:  MOVLB  4
00A22:  CLRF   x40
00A24:  MOVLB  5
....................    }
00A26:  MOVLB  0
00A28:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next serial read index (SRI)                                          */
.................... /*****************************************************************************/
.................... BOOLEAN getNextSERReadIndex()
.................... {
....................    while (!SERcmd[SRI].full)
*
0505C:  MOVLB  6
0505E:  CLRF   x30
05060:  MOVFF  43E,62F
05064:  CLRF   x32
05066:  MOVLW  B5
05068:  MOVWF  x31
0506A:  MOVLB  0
0506C:  CALL   087E
05070:  MOVFF  02,5F0
05074:  MOVFF  01,5EF
05078:  MOVLW  6A
0507A:  MOVLB  5
0507C:  ADDWF  01,W
0507E:  MOVWF  FE9
05080:  MOVLW  01
05082:  ADDWFC 02,W
05084:  MOVWF  FEA
05086:  BTFSC  FEF.0
05088:  BRA    50AA
....................    {
....................       if (SRI == SWI) return FALSE;
0508A:  MOVLB  4
0508C:  MOVF   x3F,W
0508E:  SUBWF  x3E,W
05090:  BNZ   5098
05092:  MOVLW  00
05094:  MOVWF  01
05096:  BRA    50B0
....................       SRI +=1;
05098:  MOVLW  01
0509A:  ADDWF  x3E,F
....................       if (SRI >= numRecords) SRI=0;
0509C:  MOVF   x3E,W
0509E:  SUBLW  03
050A0:  BC    50A4
050A2:  CLRF   x3E
050A4:  MOVLB  0
050A6:  BRA    505C
050A8:  MOVLB  5
....................    }
....................    return TRUE;
050AA:  MOVLW  01
050AC:  MOVWF  01
050AE:  MOVLB  4
050B0:  MOVLB  0
050B2:  GOTO   99EC (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next serial write index (SWI)                                         */
.................... /*****************************************************************************/
.................... void setNextSERWriteIndex()
.................... {
....................    SWI +=1;
*
046BA:  MOVLW  01
046BC:  MOVLB  4
046BE:  ADDWF  x3F,F
....................    if (SWI >= numRecords) SWI=0;
046C0:  MOVF   x3F,W
046C2:  SUBLW  03
046C4:  BC    46C8
046C6:  CLRF   x3F
046C8:  MOVLB  0
046CA:  RETURN 0
.................... }
.................... #endif
.................... 
.................... #ifdef useTCPIP
.................... /*****************************************************************************/
.................... /* RESET TCP COMMAND -- ready for a new command                              */
.................... /*****************************************************************************/
.................... void resetTCPcmd(unsigned int8 recNum)
.................... {
....................    if(recNum < numRecords)
....................    {
....................       for (int i = 0; i <numParam; i ++)
....................       {
....................          TCPcmd[recNum].p[i][0] = '\0';
....................       }
....................       TCPcmd[recNum].t = 0;
....................       TCPcmd[recNum].chrIndex = 0;
....................       TCPcmd[recNum].paramIndex = 0;
....................       TCPcmd[recNum].full = FALSE;
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next TCP read index (TRI)                                             */
.................... /*****************************************************************************/
.................... BOOLEAN getNextTCPReadIndex()
.................... {
....................    while (!TCPcmd[TRI].full)
....................    {
....................       if (TRI == TWI) return FALSE;
....................       TRI +=1;
....................       if (TRI >= numRecords) TRI=0;
....................    }
....................    return TRUE;
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next TCP write index (TWI)                                            */
.................... /*****************************************************************************/
.................... void setNextTCPWriteIndex()
.................... {
....................    TWI +=1;
....................    if (TWI >= numRecords) TWI=0;
.................... }
.................... #endif
.................... #endif
.................... 
.................... 
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
....................    output_b(portB_reset);
....................    output_c(portC_reset);
....................    output_d(portD_reset);
....................    output_e(portE_reset);
....................    
....................    port_a_pullups(portA_pullups);
....................    port_b_pullups(portB_pullups);
....................    port_c_pullups(portC_pullups);
....................    port_d_pullups(portD_pullups);
....................    port_e_pullups(portE_pullups);
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... #define use_RS485 // adds RX enable pin//
.................... 
.................... #define oneByteCmdTestValue 128
.................... #define UART_BUFFER_SIZE 60
.................... #define UART_EOT_CHAR1 0x0D //Carriage Return
.................... #define UART_EOT_CHAR2 0x0A //Line Feed
.................... #define UART_SOT_CHAR  '~' // START CHARACTER
.................... #define line_turnaround_char 0xFF
.................... 
.................... #bit UART_TXBuffer_Empty = 0x0FAC.1
.................... 
.................... char UART_BUFFER[UART_BUFFER_SIZE] = {0};
.................... unsigned int8 UART_WR_PTR = 0;
.................... unsigned int8 UART_RD_PTR = 0;
.................... boolean BYTES_AVAILABLE= FALSE;
.................... 
.................... #ifdef use_RS485
.................... #use rs232(baud=baudRate, xmit=TX_PIN, rcv=RX_PIN, enable=TX_ENABLE, stream=SERIAL, ERRORS)
*
000CA:  MOVLB  E
000CC:  BTFSS  xC8.5
000CE:  BRA    00CC
000D0:  MOVFF  F9C,4E3
000D4:  MOVLB  4
000D6:  MOVFF  F98,01
000DA:  BTFSS  xE3.1
000DC:  BRA    00E2
000DE:  BCF    F9C.4
000E0:  BSF    F9C.4
000E2:  MOVLB  0
000E4:  GOTO   010C (RETURN)
*
046CC:  MOVLW  93
046CE:  MOVWF  F89
046D0:  BSF    F84.5
046D2:  MOVLB  E
046D4:  BTFSS  xC8.4
046D6:  BRA    46D4
046D8:  MOVLW  93
046DA:  MOVWF  F89
046DC:  BSF    F84.5
046DE:  MOVLB  6
046E0:  MOVFF  600,F99
046E4:  NOP   
046E6:  BTFSS  F9D.1
046E8:  BRA    46E6
046EA:  MOVLW  93
046EC:  MOVWF  F89
046EE:  BCF    F84.5
046F0:  MOVLB  0
046F2:  RETURN 0
.................... #else
.................... #use rs232(baud=baudRate, xmit=TX_PIN, rcv=RX_PIN, stream=SERIAL)
.................... #endif
.................... 
.................... // Message format: [SOT]addr ,cmd, arg1, arg2, arg3[EOT]} 
.................... // arguments are optional
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* SERIAL PORT ISR                                                           */
.................... /*****************************************************************************/
.................... #INT_RDA
.................... void RX_isr()
*
000E8:  MOVLB  0
.................... {
....................    while (kbhit())
000EA:  MOVLB  E
000EC:  BTFSS  xC8.5
000EE:  BRA    012E
....................    {
....................       UART_BUFFER[UART_WR_PTR]=getch();
000F0:  CLRF   03
000F2:  MOVLB  4
000F4:  MOVF   xE0,W
000F6:  ADDLW  A4
000F8:  MOVWF  FE9
000FA:  MOVLW  04
000FC:  ADDWFC 03,W
000FE:  MOVWF  FEA
00100:  MOVFF  FEA,667
00104:  MOVFF  FE9,666
00108:  MOVLB  0
0010A:  BRA    00CA
0010C:  MOVFF  667,FEA
00110:  MOVFF  666,FE9
00114:  MOVFF  01,FEF
....................       UART_WR_PTR +=1;
00118:  MOVLW  01
0011A:  MOVLB  4
0011C:  ADDWF  xE0,F
....................       if (UART_WR_PTR>=UART_BUFFER_SIZE) UART_WR_PTR=0;
0011E:  MOVF   xE0,W
00120:  SUBLW  3B
00122:  BC    0126
00124:  CLRF   xE0
....................       BYTES_AVAILABLE=TRUE;
00126:  BSF    xE2.0
00128:  MOVLB  0
0012A:  BRA    00EA
0012C:  MOVLB  E
....................    }
0012E:  BCF    xC8.5
00130:  MOVLB  0
00132:  GOTO   006E
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get character from buffer                                                 */
.................... /*****************************************************************************/
.................... char getchFromBuffer()
*
04686:  CLRF   03
04688:  MOVLB  4
0468A:  MOVF   xE1,W
0468C:  ADDLW  A4
0468E:  MOVWF  FE9
04690:  MOVLW  04
04692:  ADDWFC 03,W
04694:  MOVWF  FEA
04696:  MOVFF  FEF,5EF
.................... {
....................    char data = UART_BUFFER[UART_RD_PTR];
....................    UART_RD_PTR +=1;
0469A:  MOVLW  01
0469C:  ADDWF  xE1,F
....................    if (UART_RD_PTR>=UART_BUFFER_SIZE) UART_RD_PTR=0;
0469E:  MOVF   xE1,W
046A0:  SUBLW  3B
046A2:  BC    46A6
046A4:  CLRF   xE1
....................    if (UART_RD_PTR == UART_WR_PTR) BYTES_AVAILABLE=FALSE;
046A6:  MOVF   xE0,W
046A8:  SUBWF  xE1,W
046AA:  BNZ   46AE
046AC:  BCF    xE2.0
....................    return data;
046AE:  MOVLB  5
046B0:  MOVFF  5EF,01
046B4:  MOVLB  0
046B6:  GOTO   475A (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Serial Task transfers bytes to command buffer                             */
.................... /*****************************************************************************/
.................... void serial_task()
.................... {
....................    while(BYTES_AVAILABLE && SERcmd[SWI].full==FALSE)
*
04718:  MOVLB  4
0471A:  BTFSS  xE2.0
0471C:  BRA    4C2A
0471E:  MOVLB  6
04720:  CLRF   x30
04722:  MOVFF  43F,62F
04726:  CLRF   x32
04728:  MOVLW  B5
0472A:  MOVWF  x31
0472C:  MOVLB  0
0472E:  CALL   087E
04732:  MOVFF  02,5F0
04736:  MOVFF  01,5EF
0473A:  MOVLW  6A
0473C:  MOVLB  5
0473E:  ADDWF  01,W
04740:  MOVWF  01
04742:  MOVLW  01
04744:  ADDWFC 02,W
04746:  MOVWF  03
04748:  MOVFF  01,FE9
0474C:  MOVWF  FEA
0474E:  BTFSS  FEF.0
04750:  BRA    4756
04752:  MOVLB  4
04754:  BRA    4C2A
....................    {  
....................       unsigned int8 rxChar = getchFromBuffer();
04756:  MOVLB  0
04758:  BRA    4686
0475A:  MOVFF  01,5EE
....................       if (rxChar == ignoreChr1 || rxChar == ignoreChr2)
0475E:  MOVLB  5
04760:  MOVF   xEE,W
04762:  SUBLW  0D
04764:  BZ    476C
04766:  MOVF   xEE,W
04768:  SUBLW  20
0476A:  BNZ   476E
....................       {
....................       }
0476C:  BRA    4C24
....................       else if (rxChar == UART_SOT_CHAR)
0476E:  MOVF   xEE,W
04770:  SUBLW  7E
04772:  BNZ   47B6
....................       {
....................          resetSERcmd(SWI);
04774:  MOVFF  43F,5EF
04778:  MOVLB  0
0477A:  CALL   08A0
....................          SERcmd[SWI].t = rxChar;
0477E:  MOVLB  6
04780:  CLRF   x30
04782:  MOVFF  43F,62F
04786:  CLRF   x32
04788:  MOVLW  B5
0478A:  MOVWF  x31
0478C:  MOVLB  0
0478E:  CALL   087E
04792:  MOVFF  01,5EF
04796:  MOVLW  05
04798:  MOVLB  5
0479A:  ADDWF  01,W
0479C:  MOVWF  01
0479E:  MOVLW  00
047A0:  ADDWFC 02,W
047A2:  MOVWF  03
047A4:  MOVF   01,W
047A6:  ADDLW  6A
047A8:  MOVWF  FE9
047AA:  MOVLW  01
047AC:  ADDWFC 03,W
047AE:  MOVWF  FEA
047B0:  MOVFF  5EE,FEF
....................       }
047B4:  BRA    4C24
....................       else if (rxChar >= oneByteCmdTestValue)
047B6:  MOVF   xEE,W
047B8:  SUBLW  7F
047BA:  BC    4828
....................       {
....................          resetSERcmd(SWI);
047BC:  MOVFF  43F,5EF
047C0:  MOVLB  0
047C2:  CALL   08A0
....................          SERcmd[SWI].t = rxChar;
047C6:  MOVLB  6
047C8:  CLRF   x30
047CA:  MOVFF  43F,62F
047CE:  CLRF   x32
047D0:  MOVLW  B5
047D2:  MOVWF  x31
047D4:  MOVLB  0
047D6:  CALL   087E
047DA:  MOVFF  01,5EF
047DE:  MOVLW  05
047E0:  MOVLB  5
047E2:  ADDWF  01,W
047E4:  MOVWF  01
047E6:  MOVLW  00
047E8:  ADDWFC 02,W
047EA:  MOVWF  03
047EC:  MOVF   01,W
047EE:  ADDLW  6A
047F0:  MOVWF  FE9
047F2:  MOVLW  01
047F4:  ADDWFC 03,W
047F6:  MOVWF  FEA
047F8:  MOVFF  5EE,FEF
....................          SERcmd[SWI].full = TRUE;
047FC:  MOVLB  6
047FE:  CLRF   x30
04800:  MOVFF  43F,62F
04804:  CLRF   x32
04806:  MOVLW  B5
04808:  MOVWF  x31
0480A:  MOVLB  0
0480C:  CALL   087E
04810:  MOVLW  6A
04812:  MOVLB  5
04814:  ADDWF  01,W
04816:  MOVWF  FE9
04818:  MOVLW  01
0481A:  ADDWFC 02,W
0481C:  MOVWF  FEA
0481E:  BSF    FEF.0
....................          setNextSERWriteIndex();
04820:  MOVLB  0
04822:  RCALL  46BA
....................       }
04824:  BRA    4C22
04826:  MOVLB  5
....................       else if (rxChar == UART_EOT_CHAR2)
04828:  MOVF   xEE,W
0482A:  SUBLW  0A
0482C:  BTFSS  FD8.2
0482E:  BRA    493C
....................       {
....................          SERcmd[SWI].full = TRUE;
04830:  MOVLB  6
04832:  CLRF   x30
04834:  MOVFF  43F,62F
04838:  CLRF   x32
0483A:  MOVLW  B5
0483C:  MOVWF  x31
0483E:  MOVLB  0
04840:  CALL   087E
04844:  MOVLW  6A
04846:  MOVLB  5
04848:  ADDWF  01,W
0484A:  MOVWF  FE9
0484C:  MOVLW  01
0484E:  ADDWFC 02,W
04850:  MOVWF  FEA
04852:  BSF    FEF.0
....................          SERcmd[SWI].recWriteIndex = SERcmd[SWI].paramIndex;
04854:  MOVLB  6
04856:  CLRF   x30
04858:  MOVFF  43F,62F
0485C:  CLRF   x32
0485E:  MOVLW  B5
04860:  MOVWF  x31
04862:  MOVLB  0
04864:  CALL   087E
04868:  MOVFF  01,5EF
0486C:  MOVLW  04
0486E:  ADDWF  01,W
04870:  MOVWF  01
04872:  MOVLW  00
04874:  ADDWFC 02,W
04876:  MOVWF  03
04878:  MOVF   01,W
0487A:  ADDLW  6A
0487C:  MOVWF  01
0487E:  MOVLW  01
04880:  ADDWFC 03,F
04882:  MOVFF  01,5EF
04886:  MOVFF  03,5F0
0488A:  MOVLB  6
0488C:  CLRF   x30
0488E:  MOVFF  43F,62F
04892:  CLRF   x32
04894:  MOVLW  B5
04896:  MOVWF  x31
04898:  MOVLB  0
0489A:  CALL   087E
0489E:  MOVFF  01,5F1
048A2:  MOVLW  02
048A4:  MOVLB  5
048A6:  ADDWF  01,W
048A8:  MOVWF  01
048AA:  MOVLW  00
048AC:  ADDWFC 02,W
048AE:  MOVWF  03
048B0:  MOVF   01,W
048B2:  ADDLW  6A
048B4:  MOVWF  FE9
048B6:  MOVLW  01
048B8:  ADDWFC 03,W
048BA:  MOVWF  FEA
048BC:  MOVFF  FEF,5F1
048C0:  MOVFF  5F0,FEA
048C4:  MOVFF  5EF,FE9
048C8:  MOVFF  5F1,FEF
....................          SERcmd[SWI].chrIndex = 0;
048CC:  MOVLB  6
048CE:  CLRF   x30
048D0:  MOVFF  43F,62F
048D4:  CLRF   x32
048D6:  MOVLW  B5
048D8:  MOVWF  x31
048DA:  MOVLB  0
048DC:  CALL   087E
048E0:  MOVFF  01,5EF
048E4:  MOVLW  01
048E6:  MOVLB  5
048E8:  ADDWF  01,W
048EA:  MOVWF  01
048EC:  MOVLW  00
048EE:  ADDWFC 02,W
048F0:  MOVWF  03
048F2:  MOVF   01,W
048F4:  ADDLW  6A
048F6:  MOVWF  FE9
048F8:  MOVLW  01
048FA:  ADDWFC 03,W
048FC:  MOVWF  FEA
048FE:  CLRF   FEF
....................          SERcmd[SWI].paramIndex = 0;
04900:  MOVLB  6
04902:  CLRF   x30
04904:  MOVFF  43F,62F
04908:  CLRF   x32
0490A:  MOVLW  B5
0490C:  MOVWF  x31
0490E:  MOVLB  0
04910:  CALL   087E
04914:  MOVFF  01,5EF
04918:  MOVLW  02
0491A:  MOVLB  5
0491C:  ADDWF  01,W
0491E:  MOVWF  01
04920:  MOVLW  00
04922:  ADDWFC 02,W
04924:  MOVWF  03
04926:  MOVF   01,W
04928:  ADDLW  6A
0492A:  MOVWF  FE9
0492C:  MOVLW  01
0492E:  ADDWFC 03,W
04930:  MOVWF  FEA
04932:  CLRF   FEF
....................          setNextSERWriteIndex();
04934:  MOVLB  0
04936:  RCALL  46BA
....................       }
04938:  BRA    4C22
0493A:  MOVLB  5
....................       else if (rxChar == delimiter)
0493C:  MOVF   xEE,W
0493E:  SUBLW  2C
04940:  BNZ   4A04
....................       {
....................          if (SERcmd[SWI].paramIndex < numParam-1)
04942:  MOVLB  6
04944:  CLRF   x30
04946:  MOVFF  43F,62F
0494A:  CLRF   x32
0494C:  MOVLW  B5
0494E:  MOVWF  x31
04950:  MOVLB  0
04952:  CALL   087E
04956:  MOVFF  02,5F0
0495A:  MOVFF  01,5EF
0495E:  MOVLW  02
04960:  MOVLB  5
04962:  ADDWF  01,W
04964:  MOVWF  01
04966:  MOVLW  00
04968:  ADDWFC 02,W
0496A:  MOVWF  03
0496C:  MOVF   01,W
0496E:  ADDLW  6A
04970:  MOVWF  FE9
04972:  MOVLW  01
04974:  ADDWFC 03,W
04976:  MOVWF  FEA
04978:  MOVF   FEF,W
0497A:  SUBLW  05
0497C:  BNC   49EC
....................          {
....................             SERcmd[SWI].paramIndex +=1;
0497E:  MOVLB  6
04980:  CLRF   x30
04982:  MOVFF  43F,62F
04986:  CLRF   x32
04988:  MOVLW  B5
0498A:  MOVWF  x31
0498C:  MOVLB  0
0498E:  CALL   087E
04992:  MOVFF  01,5EF
04996:  MOVLW  02
04998:  MOVLB  5
0499A:  ADDWF  01,W
0499C:  MOVWF  01
0499E:  MOVLW  00
049A0:  ADDWFC 02,W
049A2:  MOVWF  03
049A4:  MOVF   01,W
049A6:  ADDLW  6A
049A8:  MOVWF  FE9
049AA:  MOVLW  01
049AC:  ADDWFC 03,W
049AE:  MOVWF  FEA
049B0:  MOVLW  01
049B2:  ADDWF  FEF,W
049B4:  MOVWF  FEF
....................             SERcmd[SWI].chrIndex = 0;
049B6:  MOVLB  6
049B8:  CLRF   x30
049BA:  MOVFF  43F,62F
049BE:  CLRF   x32
049C0:  MOVLW  B5
049C2:  MOVWF  x31
049C4:  MOVLB  0
049C6:  CALL   087E
049CA:  MOVFF  01,5EF
049CE:  MOVLW  01
049D0:  MOVLB  5
049D2:  ADDWF  01,W
049D4:  MOVWF  01
049D6:  MOVLW  00
049D8:  ADDWFC 02,W
049DA:  MOVWF  03
049DC:  MOVF   01,W
049DE:  ADDLW  6A
049E0:  MOVWF  FE9
049E2:  MOVLW  01
049E4:  ADDWFC 03,W
049E6:  MOVWF  FEA
049E8:  CLRF   FEF
....................          }
049EA:  BRA    4A02
....................          else
....................          {
....................             resetSERcmd(SWI); // exceed number of params... reset capture
049EC:  MOVFF  43F,5EF
049F0:  MOVLB  0
049F2:  CALL   08A0
....................             fprintf(SERIAL, retData);
049F6:  MOVLW  04
049F8:  MOVWF  FEA
049FA:  MOVLW  40
049FC:  MOVWF  FE9
049FE:  RCALL  46F4
04A00:  MOVLB  5
....................          }
....................       }
04A02:  BRA    4C24
....................       
....................       else
....................       {
....................          if (SERcmd[SWI].chrIndex < lenParam)
04A04:  MOVLB  6
04A06:  CLRF   x30
04A08:  MOVFF  43F,62F
04A0C:  CLRF   x32
04A0E:  MOVLW  B5
04A10:  MOVWF  x31
04A12:  MOVLB  0
04A14:  CALL   087E
04A18:  MOVFF  02,5F0
04A1C:  MOVFF  01,5EF
04A20:  MOVLW  01
04A22:  MOVLB  5
04A24:  ADDWF  01,W
04A26:  MOVWF  01
04A28:  MOVLW  00
04A2A:  ADDWFC 02,W
04A2C:  MOVWF  03
04A2E:  MOVF   01,W
04A30:  ADDLW  6A
04A32:  MOVWF  FE9
04A34:  MOVLW  01
04A36:  ADDWFC 03,W
04A38:  MOVWF  FEA
04A3A:  MOVF   FEF,W
04A3C:  SUBLW  18
04A3E:  BTFSS  FD8.0
04A40:  BRA    4C0E
....................          {
....................             SERcmd[SWI].p[SERcmd[SWI].paramIndex][SERcmd[SWI].chrIndex] = rxChar;
04A42:  MOVLB  6
04A44:  CLRF   x30
04A46:  MOVFF  43F,62F
04A4A:  CLRF   x32
04A4C:  MOVLW  B5
04A4E:  MOVWF  x31
04A50:  MOVLB  0
04A52:  CALL   087E
04A56:  MOVFF  02,5F0
04A5A:  MOVFF  01,5EF
04A5E:  MOVLW  06
04A60:  MOVLB  5
04A62:  ADDWF  xEF,F
04A64:  MOVLW  00
04A66:  ADDWFC xF0,F
04A68:  MOVLB  6
04A6A:  CLRF   x30
04A6C:  MOVFF  43F,62F
04A70:  CLRF   x32
04A72:  MOVLW  B5
04A74:  MOVWF  x31
04A76:  MOVLB  0
04A78:  CALL   087E
04A7C:  MOVFF  02,5F2
04A80:  MOVFF  01,5F1
04A84:  MOVLW  02
04A86:  ADDWF  01,W
04A88:  MOVWF  01
04A8A:  MOVLW  00
04A8C:  ADDWFC 02,W
04A8E:  MOVWF  03
04A90:  MOVF   01,W
04A92:  ADDLW  6A
04A94:  MOVWF  FE9
04A96:  MOVLW  01
04A98:  ADDWFC 03,W
04A9A:  MOVWF  FEA
04A9C:  MOVLB  6
04A9E:  CLRF   x30
04AA0:  MOVFF  FEF,62F
04AA4:  CLRF   x32
04AA6:  MOVLW  19
04AA8:  MOVWF  x31
04AAA:  MOVLB  0
04AAC:  CALL   087E
04AB0:  MOVFF  02,03
04AB4:  MOVF   01,W
04AB6:  MOVLB  5
04AB8:  ADDWF  xEF,F
04ABA:  MOVF   02,W
04ABC:  ADDWFC xF0,F
04ABE:  MOVLB  6
04AC0:  CLRF   x30
04AC2:  MOVFF  43F,62F
04AC6:  CLRF   x32
04AC8:  MOVLW  B5
04ACA:  MOVWF  x31
04ACC:  MOVLB  0
04ACE:  CALL   087E
04AD2:  MOVFF  01,5F1
04AD6:  MOVLW  01
04AD8:  MOVLB  5
04ADA:  ADDWF  01,W
04ADC:  MOVWF  01
04ADE:  MOVLW  00
04AE0:  ADDWFC 02,W
04AE2:  MOVWF  03
04AE4:  MOVF   01,W
04AE6:  ADDLW  6A
04AE8:  MOVWF  FE9
04AEA:  MOVLW  01
04AEC:  ADDWFC 03,W
04AEE:  MOVWF  FEA
04AF0:  MOVF   FEF,W
04AF2:  ADDWF  xEF,W
04AF4:  MOVWF  01
04AF6:  MOVLW  00
04AF8:  ADDWFC xF0,W
04AFA:  MOVWF  03
04AFC:  MOVF   01,W
04AFE:  ADDLW  6A
04B00:  MOVWF  FE9
04B02:  MOVLW  01
04B04:  ADDWFC 03,W
04B06:  MOVWF  FEA
04B08:  MOVFF  5EE,FEF
....................             SERcmd[SWI].chrIndex += 1;
04B0C:  MOVLB  6
04B0E:  CLRF   x30
04B10:  MOVFF  43F,62F
04B14:  CLRF   x32
04B16:  MOVLW  B5
04B18:  MOVWF  x31
04B1A:  MOVLB  0
04B1C:  CALL   087E
04B20:  MOVFF  01,5EF
04B24:  MOVLW  01
04B26:  MOVLB  5
04B28:  ADDWF  01,W
04B2A:  MOVWF  01
04B2C:  MOVLW  00
04B2E:  ADDWFC 02,W
04B30:  MOVWF  03
04B32:  MOVF   01,W
04B34:  ADDLW  6A
04B36:  MOVWF  FE9
04B38:  MOVLW  01
04B3A:  ADDWFC 03,W
04B3C:  MOVWF  FEA
04B3E:  MOVLW  01
04B40:  ADDWF  FEF,W
04B42:  MOVWF  FEF
....................             SERcmd[SWI].p[SERcmd[SWI].paramIndex][SERcmd[SWI].chrIndex] = '\0';
04B44:  MOVLB  6
04B46:  CLRF   x30
04B48:  MOVFF  43F,62F
04B4C:  CLRF   x32
04B4E:  MOVLW  B5
04B50:  MOVWF  x31
04B52:  MOVLB  0
04B54:  CALL   087E
04B58:  MOVFF  02,5F0
04B5C:  MOVFF  01,5EF
04B60:  MOVLW  06
04B62:  MOVLB  5
04B64:  ADDWF  xEF,F
04B66:  MOVLW  00
04B68:  ADDWFC xF0,F
04B6A:  MOVLB  6
04B6C:  CLRF   x30
04B6E:  MOVFF  43F,62F
04B72:  CLRF   x32
04B74:  MOVLW  B5
04B76:  MOVWF  x31
04B78:  MOVLB  0
04B7A:  CALL   087E
04B7E:  MOVFF  02,5F2
04B82:  MOVFF  01,5F1
04B86:  MOVLW  02
04B88:  ADDWF  01,W
04B8A:  MOVWF  01
04B8C:  MOVLW  00
04B8E:  ADDWFC 02,W
04B90:  MOVWF  03
04B92:  MOVF   01,W
04B94:  ADDLW  6A
04B96:  MOVWF  FE9
04B98:  MOVLW  01
04B9A:  ADDWFC 03,W
04B9C:  MOVWF  FEA
04B9E:  MOVLB  6
04BA0:  CLRF   x30
04BA2:  MOVFF  FEF,62F
04BA6:  CLRF   x32
04BA8:  MOVLW  19
04BAA:  MOVWF  x31
04BAC:  MOVLB  0
04BAE:  CALL   087E
04BB2:  MOVFF  02,03
04BB6:  MOVF   01,W
04BB8:  MOVLB  5
04BBA:  ADDWF  xEF,F
04BBC:  MOVF   02,W
04BBE:  ADDWFC xF0,F
04BC0:  MOVLB  6
04BC2:  CLRF   x30
04BC4:  MOVFF  43F,62F
04BC8:  CLRF   x32
04BCA:  MOVLW  B5
04BCC:  MOVWF  x31
04BCE:  MOVLB  0
04BD0:  CALL   087E
04BD4:  MOVFF  01,5F1
04BD8:  MOVLW  01
04BDA:  MOVLB  5
04BDC:  ADDWF  01,W
04BDE:  MOVWF  01
04BE0:  MOVLW  00
04BE2:  ADDWFC 02,W
04BE4:  MOVWF  03
04BE6:  MOVF   01,W
04BE8:  ADDLW  6A
04BEA:  MOVWF  FE9
04BEC:  MOVLW  01
04BEE:  ADDWFC 03,W
04BF0:  MOVWF  FEA
04BF2:  MOVF   FEF,W
04BF4:  ADDWF  xEF,W
04BF6:  MOVWF  01
04BF8:  MOVLW  00
04BFA:  ADDWFC xF0,W
04BFC:  MOVWF  03
04BFE:  MOVF   01,W
04C00:  ADDLW  6A
04C02:  MOVWF  FE9
04C04:  MOVLW  01
04C06:  ADDWFC 03,W
04C08:  MOVWF  FEA
04C0A:  CLRF   FEF
....................          }
04C0C:  BRA    4C24
....................          else
....................          {
....................             resetSERcmd(SWI); // exceed number of characters... reset capture
04C0E:  MOVFF  43F,5EF
04C12:  MOVLB  0
04C14:  CALL   08A0
....................             fprintf(SERIAL, retData);
04C18:  MOVLW  04
04C1A:  MOVWF  FEA
04C1C:  MOVLW  40
04C1E:  MOVWF  FE9
04C20:  RCALL  46F4
04C22:  MOVLB  5
....................          }
....................       }
04C24:  MOVLB  0
04C26:  BRA    4718
04C28:  MOVLB  4
....................    }          
04C2A:  MOVLB  0
04C2C:  GOTO   9EA0 (RETURN)
.................... }
....................            
.................... /*****************************************************************************/
.................... /* serialInit ROUTINE  - Sets up serial port                                 */
.................... /*****************************************************************************/ 
.................... void serial_init()
.................... {
....................    for (int i = 0; i < numRecords; i++) 
*
00A2A:  MOVLB  5
00A2C:  CLRF   xEE
00A2E:  MOVF   xEE,W
00A30:  SUBLW  03
00A32:  BNC   0A42
....................    {
....................       resetSERcmd(i);
00A34:  MOVFF  5EE,5EF
00A38:  MOVLB  0
00A3A:  RCALL  08A0
00A3C:  MOVLB  5
00A3E:  INCF   xEE,F
00A40:  BRA    0A2E
....................    }
....................    enable_interrupts(INT_RDA);
00A42:  MOVLB  E
00A44:  BSF    xC0.5
00A46:  MOVLB  0
00A48:  GOTO   9E88 (RETURN)
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #include <pid.h>
.................... #ifndef pidcontroller
.................... #define pidcontroller
.................... #include <parameters.h>
.................... #include <math.h>
.................... 
.................... /*****************************************************************************/
.................... /* UPDATE the Control Variable (CV)                                          */
.................... /*****************************************************************************/
.................... void pid_update (channelMap ch){
....................    float err = PID[ch].SP - PID[ch].PV;  // error = set value - measured
....................    
....................    PID[ch].I += err*PID[ch].kI;
....................    if (PID[ch].I > op_upper_bound) PID[ch].I = op_upper_bound; // anti-windup
....................    else if (PID[ch].I < op_lower_bound) PID[ch].I = op_lower_bound;
....................    
....................    float P = err * PID[ch].kP;  // proportional value
....................    
....................    float D = PID[ch].kD * (PID[ch].PV - PID[ch].PVold);  // derivative value
....................    
....................    PID[ch].CV = P + PID[ch].I + D;  // new control variable
....................    if (PID[ch].CV > op_upper_bound) PID[ch].CV = op_upper_bound; // limit positive output
....................    else if (PID[ch].CV < op_lower_bound) PID[ch].CV = op_lower_bound; // limit negative output
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PID Task - looks for change to PV and updates CV                          */
.................... /*****************************************************************************/
.................... void pid_task(channelMap ch){
....................    static int index = 0;
....................    if (PID[ch].SP != PID[ch].PV) pid_update(ch);
....................    if ((index++) >= numChannels) index = 0;
.................... }
.................... 
.................... #endif
.................... 
.................... #include <eventTimer.h>
.................... #ifndef timeout
.................... #define timeout
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0.3,0.1,0,0,0,0,0},
....................    {0.01,0.3,0.1,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;           // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... unsigned int16 dacVals[2] = {0,0};
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/           
.................... /* Global timers used by all routnes                                         */
.................... /* timeoutReg0-2 are used for timeouts. Other routines monitor the value of  */
.................... /* intTimeoutReg. On boot, they will be loaded from EEProm. Any              */
.................... /* configuration changes will be changed in EEprom, hence will be restored on*/
.................... /* subsequent boot.                                                          */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* Register definitions                                                      */
.................... /*****************************************************************************/
.................... //!unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... //!unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... //!unsigned int32 timeoutReg2 = 0;
.................... //!unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... unsigned int32 timeCounter = 0;
.................... 
.................... /*****************************************************************************/
.................... /* TIMEOUT_INIT initializes the timer                                        */
.................... /*****************************************************************************/
.................... void event_timer_init()
.................... {        
....................    disable_interrupts(INT_TIMER1);
00A4C:  MOVLB  E
00A4E:  BCF    xC1.0
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_1);
00A50:  MOVLW  01
00A52:  MOVWF  FD1
00A54:  MOVLW  07
00A56:  MOVWF  FCE
00A58:  CLRF   FCF
00A5A:  CLRF   FD0
....................    timeoutReg0 = 0;  // clear all the timers
00A5C:  MOVLB  1
00A5E:  CLRF   x58
00A60:  CLRF   x57
00A62:  CLRF   x56
00A64:  CLRF   x55
....................    timeoutReg1 = 0;
00A66:  CLRF   x5C
00A68:  CLRF   x5B
00A6A:  CLRF   x5A
00A6C:  CLRF   x59
....................    timeoutReg2 = 0;
00A6E:  CLRF   x60
00A70:  CLRF   x5F
00A72:  CLRF   x5E
00A74:  CLRF   x5D
....................    intTimeoutReg = 50;
00A76:  CLRF   x62
00A78:  MOVLW  32
00A7A:  MOVWF  x61
....................    enable_interrupts(INT_TIMER1);
00A7C:  MOVLB  E
00A7E:  BSF    xC1.0
00A80:  MOVLB  0
00A82:  GOTO   9E8C (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* TIMEOUT INTERRUPT decrements the timeout registers every second           */
.................... /*****************************************************************************/
.................... #INT_TIMER1
.................... void TIMER1_isr(void) 
*
00246:  MOVLB  0
.................... {
....................    set_timer1(0x0BDB); // load timer register to allow 10 millisecond interupts
00248:  MOVLW  0B
0024A:  MOVWF  FCD
0024C:  MOVLW  DB
0024E:  MOVWF  FCC
00250:  NOP   
....................    if (timeoutReg0 > 10) timeoutReg0 -= 10; else timeoutReg0 = 0;
00252:  MOVLB  1
00254:  MOVF   x58,F
00256:  BNZ   0266
00258:  MOVF   x57,F
0025A:  BNZ   0266
0025C:  MOVF   x56,F
0025E:  BNZ   0266
00260:  MOVF   x55,W
00262:  SUBLW  0A
00264:  BC    0274
00266:  MOVLW  0A
00268:  SUBWF  x55,F
0026A:  MOVLW  00
0026C:  SUBWFB x56,F
0026E:  SUBWFB x57,F
00270:  SUBWFB x58,F
00272:  BRA    027C
00274:  CLRF   x58
00276:  CLRF   x57
00278:  CLRF   x56
0027A:  CLRF   x55
....................    if (timeoutReg1 > 10) timeoutReg1 -= 10; else timeoutReg1 = 0;
0027C:  MOVF   x5C,F
0027E:  BNZ   028E
00280:  MOVF   x5B,F
00282:  BNZ   028E
00284:  MOVF   x5A,F
00286:  BNZ   028E
00288:  MOVF   x59,W
0028A:  SUBLW  0A
0028C:  BC    029C
0028E:  MOVLW  0A
00290:  SUBWF  x59,F
00292:  MOVLW  00
00294:  SUBWFB x5A,F
00296:  SUBWFB x5B,F
00298:  SUBWFB x5C,F
0029A:  BRA    02A4
0029C:  CLRF   x5C
0029E:  CLRF   x5B
002A0:  CLRF   x5A
002A2:  CLRF   x59
....................    if (timeoutReg2 > 10) timeoutReg2 -= 10; else timeoutReg2 = 0;
002A4:  MOVF   x60,F
002A6:  BNZ   02B6
002A8:  MOVF   x5F,F
002AA:  BNZ   02B6
002AC:  MOVF   x5E,F
002AE:  BNZ   02B6
002B0:  MOVF   x5D,W
002B2:  SUBLW  0A
002B4:  BC    02C4
002B6:  MOVLW  0A
002B8:  SUBWF  x5D,F
002BA:  MOVLW  00
002BC:  SUBWFB x5E,F
002BE:  SUBWFB x5F,F
002C0:  SUBWFB x60,F
002C2:  BRA    02CC
002C4:  CLRF   x60
002C6:  CLRF   x5F
002C8:  CLRF   x5E
002CA:  CLRF   x5D
....................    if (intTimeoutReg != 0) // INTERRUPTING TIMER
002CC:  MOVF   x61,F
002CE:  BNZ   02D4
002D0:  MOVF   x62,F
002D2:  BZ    0310
....................    {
....................       timeCounter+=10;
002D4:  MOVLW  0A
002D6:  MOVLB  4
002D8:  ADDWF  xE6,F
002DA:  MOVLW  00
002DC:  ADDWFC xE7,F
002DE:  ADDWFC xE8,F
002E0:  ADDWFC xE9,F
....................       if (timeCounter >= intTimeoutReg)
002E2:  MOVF   xE9,F
002E4:  BNZ   0300
002E6:  MOVF   xE8,F
002E8:  BNZ   0300
002EA:  MOVLB  1
002EC:  MOVF   x62,W
002EE:  MOVLB  4
002F0:  SUBWF  xE7,W
002F2:  BNC   030E
002F4:  BNZ   0300
002F6:  MOVLB  1
002F8:  MOVF   x61,W
002FA:  MOVLB  4
002FC:  SUBWF  xE6,W
002FE:  BNC   030E
....................       {
....................          sensor_monitor_interrupt_task();
00300:  MOVLB  0
00302:  BRA    01C0
....................          timeCounter = 0;
00304:  MOVLB  4
00306:  CLRF   xE9
00308:  CLRF   xE8
0030A:  CLRF   xE7
0030C:  CLRF   xE6
0030E:  MOVLB  1
....................       }
....................    }
.................... }
.................... 
.................... #endif
.................... 
.................... #include <commandHandler.c>
.................... #ifndef cmdHandlerC
.................... #define cmdHandlerC
.................... #include <commandHandler.h>
.................... #ifndef cmdHandler
.................... #define cmdHandler
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0.3,0.1,0,0,0,0,0},
....................    {0.01,0.3,0.1,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;           // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... unsigned int16 dacVals[2] = {0,0};
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... 
00310:  MOVLB  E
00312:  BCF    xC9.0
00314:  MOVLB  0
00316:  GOTO   006E
.................... #define hwID 'D'   // DiFCS
.................... 
.................... /*****************************************************************************/
.................... /* RESPONSE MESSAGES                                                         */
.................... /*****************************************************************************/
.................... typedef struct response {
....................    int8 id;
....................    char *msg;
.................... } resp;
.................... 
.................... //!#define INVALID_DATA "error - invalid data"
.................... //!#define invalidTime "error - invalid TO value"
.................... //!#define overrun "error - buffer overrun"
.................... //!#define dcVoltage "VDC:%f1"
.................... //!#define USBVoltage "VUSB:%f"
.................... //!#define USBupstream "VUSBup:%f"
.................... //!#define plus5V "5V Rail:%f"
.................... //!#define plus3V3 "3V3 Rai:%f"
.................... //!#define allVoltages "All Voltages = %f, %f, %f, %f, %f"
.................... //!#define USBdownstream "USB downstream status:\r\nPG:%s\r\nch0:%s\r\nch1:%s"
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC MESSGAGE DUMP                                                  */
.................... /*****************************************************************************/
.................... //!#define voltageMsg "V0:%f\r\nV1:%f\r\nV2:%f\r\nV3:%f\r\nV4:%f"
.................... //!#define TimerMsg "T0:%Lu\r\nT1:%Lu\r\nT2:%Lu\r\Tint:%Lu\r\nTtick:%Lu"
.................... //!#define ioStatusMsg "Inputs:%u\r\nOutputs:%u\r\nStatus:%u"
.................... //!#define diagnosticMsg "V0:%f\r\nV1:%f\r\nV2:%f\r\nV3:%f\r\nV4:%f\r\nT0:%Lu\r\nT1:%Lu\r\nT2:%Lu\r\nTint:%Lu\r\nTtick:%Lu\r\nInputs:%u\r\nOutputs:%u\r\nStatus:%u"
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC COMMAND PROTOTYPES                                             */
.................... /*****************************************************************************/
.................... int8 getRev(unsigned int8);                // gr 
.................... int8 getSN(unsigned int8);                 // gs
.................... 
.................... int8 getOPchMap(unsigned int8);            // gChMap,   {1|2}
.................... int8 setOPchMap(unsigned int8);            // sChMap,   {1|2}, {X|Y}
.................... 
.................... int8 getIPchMode(unsigned int8);           // gChMode,  {1|2}
.................... int8 setIPchMode(unsigned int8);           // sChMode,  {1|2}, {MANUAL|MAGSNS}
....................    
.................... int8 getPIDvals(unsigned int8);            // gPID,     {1|2}, {P|I|D}
.................... int8 setPIDvals(unsigned int8);            // sPID,     {1|2}, {P|I|D}, <float>
.................... 
.................... int8 enablePID(unsigned int8);             // enaPID,   {1|2}
.................... int8 disablePID(unsigned int8);            // disPID,   {1|2}
.................... 
.................... int8 getSetPoint(unsigned int8);           // gSP,      {1|2}
.................... int8 setSetPoint(unsigned int8);           // sSP,      {1|2}, <float>
.................... 
.................... int8 getAllSensorCalParams(unsigned int8); // gSCals,   {1|2}
.................... int8 getSensorCalParam(unsigned int8);     // gSCal,    {1|2}, {0|1|2|3|4|5}
.................... int8 setSensorCalParam(unsigned int8);     // sSCal,    {1|2}, {0|1|2|3|4|5}, <float>
.................... 
.................... int8 getMonitorCalParam(unsigned int8);    // gMCal,    {N15|200|5V6|5VA|3V6X|3V3A|3V3D}
.................... int8 setMonitorCalParam(unsigned int8);    // sMCal,    {N15|200|5V6|5VA|3V6X|3V3A|3V3D}, <float>, <float>
.................... int8 getMonitorValue(unsigned int8);       // gMon,     {N15|200|5V6|5VA|3V6X|3V3A|3V3D|all}
.................... 
.................... int8 getPIDdata(unsigned int8);            // gPIDdata, {1|2}, {PV|CV|PVold|I}
.................... 
.................... int8 getIPdata(unsigned int8);             // gIPdata,  {1|2}, {raw|calib|p0|poles|real}
....................    
.................... int8 getManOPvals(unsigned int8);          // gManOP,   {1|2}  
.................... int8 setManOPvals(unsigned int8);          // sManOP,   {1|2}, <float>  
.................... 
.................... int8 invalidCmd(unsigned int8);
.................... 
.................... struct command {
....................    char *cmd_name;
....................    int8 (*cmd_func)(unsigned int8);
.................... };
.................... 
.................... BOOLEAN arg_is_float(char *);
.................... BOOLEAN is_valid_channel(char *);
.................... int8 hex_to_int(char);
.................... void echo_cmd(unsigned int8 rec);
.................... int8 command_parser(unsigned int8 rec);
.................... void command_handler_task();
.................... 
.................... #endif
.................... 
.................... 
.................... /* LIST OF DIAGNOSTIC COMMAND KEYWORDS AND THEIR FUNCTIONS */
.................... struct command cmd_list[] = {
....................    {"gr",       &getRev},
....................    {"gs",       &getSN},
....................    {"gChMap",   &getOPchMap},
....................    {"sChMap",   &setOPchMap},
....................    {"gChMode",  &getIPchMode},
....................    {"sChMode",  &setIPchMode},
....................    {"gPID",     &getPIDvals},
....................    {"sPID",     &setPIDvals},
.................... //!   {"enaPID",   &enablePID},
.................... //!   {"disPID",   &disablePID},
....................    {"gSP",      &getSetPoint},
....................    {"sSP",      &setSetPoint},
....................    {"gSCals",   &getAllSensorCalParams},
....................    {"gSCal",    &getSensorCalParam},
....................    {"sSCal",    &setSensorCalParam},
....................    {"gMCal",    &getMonitorCalParam},
....................    {"sMCal",    &setMonitorCalParam},
....................    {"gMon",     &getMonitorValue},
....................    {"gPIDdata", &getPIDdata},
....................    {"gIPdata",  &getIPdata},
....................    {"gManOP",   &getManOPvals},
....................    {"sManOP",   &setManOPvals},
....................    {"\0", &invalidCmd}
.................... };
.................... 
.................... /* LIST OF RESPONSE MESSAGES */
.................... enum resp_e { 
....................    SUCCESS,
....................    INV_CMD,
....................    INV_PARAM 
.................... };
.................... 
.................... resp resp_list[] = {
....................    {SUCCESS, "SUCCESS"},
....................    {INV_CMD, "INVALID COMMAND"},
....................    {INV_PARAM, "INVALID PARAMETER"}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC COMMAND DEFINITIONS                                            */
.................... /*****************************************************************************/
....................                           
.................... int8 getRev(unsigned int8 rec){
....................    sprintf(retData+strlen(retData), "%s,", version);
*
051E0:  MOVLW  04
051E2:  MOVLB  6
051E4:  MOVWF  x30
051E6:  MOVLW  40
051E8:  MOVWF  x2F
051EA:  MOVLB  0
051EC:  RCALL  50F0
051EE:  MOVFF  02,03
051F2:  MOVF   01,W
051F4:  ADDLW  40
051F6:  MOVLB  5
051F8:  MOVWF  xF9
051FA:  MOVLW  04
051FC:  ADDWFC 02,W
051FE:  MOVWF  xFA
05200:  MOVFF  FE8,4E5
05204:  MOVFF  5F9,4E4
05208:  MOVLW  1A
0520A:  MOVWF  FF6
0520C:  MOVLW  03
0520E:  MOVWF  FF7
05210:  MOVLB  0
05212:  RCALL  51C0
05214:  MOVLW  2C
05216:  MOVLB  6
05218:  MOVWF  x3E
0521A:  MOVLB  0
0521C:  RCALL  51A0
....................    return SUCCESS;
0521E:  MOVLW  00
05220:  MOVWF  01
05222:  RETURN 0
.................... }
.................... 
.................... int8 getSN(unsigned int8 rec){
....................    sprintf(retData+strlen(retData), "%s,", serialID);
05224:  MOVLW  04
05226:  MOVLB  6
05228:  MOVWF  x30
0522A:  MOVLW  40
0522C:  MOVWF  x2F
0522E:  MOVLB  0
05230:  RCALL  50F0
05232:  MOVFF  02,03
05236:  MOVF   01,W
05238:  ADDLW  40
0523A:  MOVLB  5
0523C:  MOVWF  xF9
0523E:  MOVLW  04
05240:  ADDWFC 02,W
05242:  MOVWF  xFA
05244:  MOVFF  FE8,4E5
05248:  MOVFF  5F9,4E4
0524C:  MOVLW  24
0524E:  MOVWF  FF6
05250:  MOVLW  03
05252:  MOVWF  FF7
05254:  MOVLB  0
05256:  RCALL  51C0
05258:  MOVLW  2C
0525A:  MOVLB  6
0525C:  MOVWF  x3E
0525E:  MOVLB  0
05260:  RCALL  51A0
....................    return SUCCESS;
05262:  MOVLW  00
05264:  MOVWF  01
05266:  RETURN 0
.................... }
.................... 
.................... int8 getOPchMap(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
0576C:  MOVLB  6
0576E:  CLRF   x30
05770:  MOVFF  5ED,62F
05774:  CLRF   x32
05776:  MOVLW  B5
05778:  MOVWF  x31
0577A:  MOVLB  0
0577C:  CALL   087E
05780:  MOVFF  02,5FB
05784:  MOVFF  01,5FA
05788:  MOVLW  06
0578A:  MOVLB  5
0578C:  ADDWF  xFA,F
0578E:  MOVLW  00
05790:  ADDWFC xFB,F
05792:  MOVLW  32
05794:  ADDWF  xFA,W
05796:  MOVWF  01
05798:  MOVLW  00
0579A:  ADDWFC xFB,W
0579C:  MOVWF  03
0579E:  MOVF   01,W
057A0:  ADDLW  6A
057A2:  MOVWF  01
057A4:  MOVLW  01
057A6:  ADDWFC 03,F
057A8:  MOVFF  01,5FA
057AC:  MOVFF  03,5FB
057B0:  MOVFF  03,629
057B4:  MOVFF  01,628
057B8:  MOVLB  0
057BA:  RCALL  5268
057BC:  MOVF   01,F
057BE:  BNZ   57C8
057C0:  MOVLW  02
057C2:  MOVWF  01
057C4:  BRA    590C
057C6:  BRA    5826
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
057C8:  MOVLB  6
057CA:  CLRF   x30
057CC:  MOVFF  5ED,62F
057D0:  CLRF   x32
057D2:  MOVLW  B5
057D4:  MOVWF  x31
057D6:  MOVLB  0
057D8:  CALL   087E
057DC:  MOVFF  02,5FB
057E0:  MOVFF  01,5FA
057E4:  MOVLW  06
057E6:  MOVLB  5
057E8:  ADDWF  xFA,F
057EA:  MOVLW  00
057EC:  ADDWFC xFB,F
057EE:  MOVLW  32
057F0:  ADDWF  xFA,W
057F2:  MOVWF  01
057F4:  MOVLW  00
057F6:  ADDWFC xFB,W
057F8:  MOVWF  03
057FA:  MOVF   01,W
057FC:  ADDLW  6A
057FE:  MOVWF  01
05800:  MOVLW  01
05802:  ADDWFC 03,F
05804:  MOVFF  01,5FA
05808:  MOVFF  03,5FB
0580C:  MOVFF  03,629
05810:  MOVFF  01,628
05814:  MOVLB  6
05816:  CLRF   x2B
05818:  CLRF   x2A
0581A:  MOVLW  0A
0581C:  MOVWF  x2C
0581E:  MOVLB  0
05820:  RCALL  5358
05822:  MOVFF  01,5F9
....................    
....................    /*** GET CHANNEL MAP ***************/ 
....................    if      (0 == chMap[arg1-1]) sprintf(retData+strlen(retData), "%d,%c,", arg1, 'X');
05826:  MOVLW  01
05828:  MOVLB  5
0582A:  SUBWF  xF9,W
0582C:  MOVWF  xFB
0582E:  CLRF   xFD
05830:  MOVLW  60
05832:  MOVWF  xFC
05834:  MOVLB  0
05836:  CALL   3CA4
0583A:  BTFSC  01.0
0583C:  BRA    5894
0583E:  MOVLW  04
05840:  MOVLB  6
05842:  MOVWF  x30
05844:  MOVLW  40
05846:  MOVWF  x2F
05848:  MOVLB  0
0584A:  RCALL  50F0
0584C:  MOVFF  02,03
05850:  MOVF   01,W
05852:  ADDLW  40
05854:  MOVLB  5
05856:  MOVWF  xFA
05858:  MOVLW  04
0585A:  ADDWFC 02,W
0585C:  MOVWF  xFB
0585E:  MOVFF  FE8,4E5
05862:  MOVFF  5FA,4E4
05866:  MOVFF  5F9,629
0586A:  MOVLW  18
0586C:  MOVLB  6
0586E:  MOVWF  x2A
05870:  MOVLB  0
05872:  RCALL  56AC
05874:  MOVLW  2C
05876:  MOVLB  6
05878:  MOVWF  x3E
0587A:  MOVLB  0
0587C:  RCALL  51A0
0587E:  MOVLW  58
05880:  MOVLB  6
05882:  MOVWF  x3E
05884:  MOVLB  0
05886:  RCALL  51A0
05888:  MOVLW  2C
0588A:  MOVLB  6
0588C:  MOVWF  x3E
0588E:  MOVLB  0
05890:  RCALL  51A0
05892:  BRA    5908
....................    else if (1 == chMap[arg1-1]) sprintf(retData+strlen(retData), "%d,%c,", arg1, 'Y');
05894:  MOVLW  01
05896:  MOVLB  5
05898:  SUBWF  xF9,W
0589A:  MOVWF  xFB
0589C:  CLRF   xFD
0589E:  MOVLW  60
058A0:  MOVWF  xFC
058A2:  MOVLB  0
058A4:  CALL   3CA4
058A8:  BTFSS  01.0
058AA:  BRA    5902
058AC:  MOVLW  04
058AE:  MOVLB  6
058B0:  MOVWF  x30
058B2:  MOVLW  40
058B4:  MOVWF  x2F
058B6:  MOVLB  0
058B8:  RCALL  50F0
058BA:  MOVFF  02,03
058BE:  MOVF   01,W
058C0:  ADDLW  40
058C2:  MOVLB  5
058C4:  MOVWF  xFA
058C6:  MOVLW  04
058C8:  ADDWFC 02,W
058CA:  MOVWF  xFB
058CC:  MOVFF  FE8,4E5
058D0:  MOVFF  5FA,4E4
058D4:  MOVFF  5F9,629
058D8:  MOVLW  18
058DA:  MOVLB  6
058DC:  MOVWF  x2A
058DE:  MOVLB  0
058E0:  RCALL  56AC
058E2:  MOVLW  2C
058E4:  MOVLB  6
058E6:  MOVWF  x3E
058E8:  MOVLB  0
058EA:  RCALL  51A0
058EC:  MOVLW  59
058EE:  MOVLB  6
058F0:  MOVWF  x3E
058F2:  MOVLB  0
058F4:  RCALL  51A0
058F6:  MOVLW  2C
058F8:  MOVLB  6
058FA:  MOVWF  x3E
058FC:  MOVLB  0
058FE:  RCALL  51A0
05900:  BRA    5908
....................    else return INV_PARAM;
05902:  MOVLW  02
05904:  MOVWF  01
05906:  BRA    590C
....................    
....................    return SUCCESS;
05908:  MOVLW  00
0590A:  MOVWF  01
0590C:  RETURN 0
.................... }
.................... 
.................... int8 setOPchMap(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
05950:  MOVLB  6
05952:  CLRF   x30
05954:  MOVFF  5ED,62F
05958:  CLRF   x32
0595A:  MOVLW  B5
0595C:  MOVWF  x31
0595E:  MOVLB  0
05960:  CALL   087E
05964:  MOVFF  02,5FC
05968:  MOVFF  01,5FB
0596C:  MOVLW  06
0596E:  MOVLB  5
05970:  ADDWF  xFB,F
05972:  MOVLW  00
05974:  ADDWFC xFC,F
05976:  MOVLW  32
05978:  ADDWF  xFB,W
0597A:  MOVWF  01
0597C:  MOVLW  00
0597E:  ADDWFC xFC,W
05980:  MOVWF  03
05982:  MOVF   01,W
05984:  ADDLW  6A
05986:  MOVWF  01
05988:  MOVLW  01
0598A:  ADDWFC 03,F
0598C:  MOVFF  01,5FB
05990:  MOVFF  03,5FC
05994:  MOVFF  03,629
05998:  MOVFF  01,628
0599C:  MOVLB  0
0599E:  RCALL  5268
059A0:  MOVF   01,F
059A2:  BNZ   59AC
059A4:  MOVLW  02
059A6:  MOVWF  01
059A8:  BRA    5B06
059AA:  BRA    5A0A
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
059AC:  MOVLB  6
059AE:  CLRF   x30
059B0:  MOVFF  5ED,62F
059B4:  CLRF   x32
059B6:  MOVLW  B5
059B8:  MOVWF  x31
059BA:  MOVLB  0
059BC:  CALL   087E
059C0:  MOVFF  02,5FC
059C4:  MOVFF  01,5FB
059C8:  MOVLW  06
059CA:  MOVLB  5
059CC:  ADDWF  xFB,F
059CE:  MOVLW  00
059D0:  ADDWFC xFC,F
059D2:  MOVLW  32
059D4:  ADDWF  xFB,W
059D6:  MOVWF  01
059D8:  MOVLW  00
059DA:  ADDWFC xFC,W
059DC:  MOVWF  03
059DE:  MOVF   01,W
059E0:  ADDLW  6A
059E2:  MOVWF  01
059E4:  MOVLW  01
059E6:  ADDWFC 03,F
059E8:  MOVFF  01,5FB
059EC:  MOVFF  03,5FC
059F0:  MOVFF  03,629
059F4:  MOVFF  01,628
059F8:  MOVLB  6
059FA:  CLRF   x2B
059FC:  CLRF   x2A
059FE:  MOVLW  0A
05A00:  MOVWF  x2C
05A02:  MOVLB  0
05A04:  RCALL  5358
05A06:  MOVFF  01,5F9
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
05A0A:  MOVLB  6
05A0C:  CLRF   x30
05A0E:  MOVFF  5ED,62F
05A12:  CLRF   x32
05A14:  MOVLW  B5
05A16:  MOVWF  x31
05A18:  MOVLB  0
05A1A:  CALL   087E
05A1E:  MOVFF  02,5FC
05A22:  MOVFF  01,5FB
05A26:  MOVLW  06
05A28:  MOVLB  5
05A2A:  ADDWF  xFB,F
05A2C:  MOVLW  00
05A2E:  ADDWFC xFC,F
05A30:  MOVLW  4B
05A32:  ADDWF  xFB,W
05A34:  MOVWF  01
05A36:  MOVLW  00
05A38:  ADDWFC xFC,W
05A3A:  MOVWF  03
05A3C:  MOVF   01,W
05A3E:  ADDLW  6A
05A40:  MOVWF  01
05A42:  MOVLW  01
05A44:  ADDWFC 03,F
05A46:  MOVFF  01,5FB
05A4A:  MOVFF  03,5FC
05A4E:  MOVFF  03,630
05A52:  MOVFF  01,62F
05A56:  MOVLB  0
05A58:  CALL   50F0
05A5C:  MOVFF  02,03
05A60:  MOVF   01,W
05A62:  SUBLW  01
05A64:  BNZ   5A6A
05A66:  MOVF   03,F
05A68:  BZ    5A72
05A6A:  MOVLW  02
05A6C:  MOVWF  01
05A6E:  BRA    5B06
05A70:  BRA    5AB2
....................    else arg2 = SERcmd[rec].p[3][0];
05A72:  MOVLB  6
05A74:  CLRF   x30
05A76:  MOVFF  5ED,62F
05A7A:  CLRF   x32
05A7C:  MOVLW  B5
05A7E:  MOVWF  x31
05A80:  MOVLB  0
05A82:  CALL   087E
05A86:  MOVFF  02,5FC
05A8A:  MOVFF  01,5FB
05A8E:  MOVLW  06
05A90:  MOVLB  5
05A92:  ADDWF  xFB,F
05A94:  MOVLW  00
05A96:  ADDWFC xFC,F
05A98:  MOVLW  4B
05A9A:  ADDWF  xFB,F
05A9C:  MOVLW  00
05A9E:  ADDWFC xFC,F
05AA0:  MOVLW  6A
05AA2:  ADDWF  xFB,W
05AA4:  MOVWF  FE9
05AA6:  MOVLW  01
05AA8:  ADDWFC xFC,W
05AAA:  MOVWF  FEA
05AAC:  MOVFF  FEF,5FA
05AB0:  MOVLB  0
....................    
....................    /*** SET CHANNEL MAP ***************/
....................    if      ('X' == arg2) chMap[arg1-1] = chX;
05AB2:  MOVLB  5
05AB4:  MOVF   xFA,W
05AB6:  SUBLW  58
05AB8:  BNZ   5AD6
05ABA:  MOVLW  01
05ABC:  SUBWF  xF9,W
05ABE:  MOVWF  xFB
05AC0:  MOVFF  FE8,610
05AC4:  MOVLB  6
05AC6:  CLRF   x11
05AC8:  CLRF   x13
05ACA:  MOVLW  60
05ACC:  MOVWF  x12
05ACE:  MOVLB  0
05AD0:  RCALL  590E
05AD2:  BRA    5B02
05AD4:  MOVLB  5
....................    else if ('Y' == arg2) chMap[arg1-1] = chY;
05AD6:  MOVF   xFA,W
05AD8:  SUBLW  59
05ADA:  BNZ   5AFA
05ADC:  MOVLW  01
05ADE:  SUBWF  xF9,W
05AE0:  MOVWF  xFB
05AE2:  MOVFF  FE8,610
05AE6:  MOVLW  01
05AE8:  MOVLB  6
05AEA:  MOVWF  x11
05AEC:  CLRF   x13
05AEE:  MOVLW  60
05AF0:  MOVWF  x12
05AF2:  MOVLB  0
05AF4:  RCALL  590E
05AF6:  BRA    5B02
05AF8:  MOVLB  5
....................    else return INV_PARAM;
05AFA:  MOVLW  02
05AFC:  MOVWF  01
05AFE:  MOVLB  0
05B00:  BRA    5B06
....................    
....................    return SUCCESS;
05B02:  MOVLW  00
05B04:  MOVWF  01
05B06:  RETURN 0
.................... }
.................... 
.................... int8 getIPchMode(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
05B32:  MOVLB  6
05B34:  CLRF   x30
05B36:  MOVFF  5ED,62F
05B3A:  CLRF   x32
05B3C:  MOVLW  B5
05B3E:  MOVWF  x31
05B40:  MOVLB  0
05B42:  CALL   087E
05B46:  MOVFF  02,5FB
05B4A:  MOVFF  01,5FA
05B4E:  MOVLW  06
05B50:  MOVLB  5
05B52:  ADDWF  xFA,F
05B54:  MOVLW  00
05B56:  ADDWFC xFB,F
05B58:  MOVLW  32
05B5A:  ADDWF  xFA,W
05B5C:  MOVWF  01
05B5E:  MOVLW  00
05B60:  ADDWFC xFB,W
05B62:  MOVWF  03
05B64:  MOVF   01,W
05B66:  ADDLW  6A
05B68:  MOVWF  01
05B6A:  MOVLW  01
05B6C:  ADDWFC 03,F
05B6E:  MOVFF  01,5FA
05B72:  MOVFF  03,5FB
05B76:  MOVFF  03,629
05B7A:  MOVFF  01,628
05B7E:  MOVLB  0
05B80:  CALL   5268
05B84:  MOVF   01,F
05B86:  BNZ   5B90
05B88:  MOVLW  02
05B8A:  MOVWF  01
05B8C:  BRA    5CC2
05B8E:  BRA    5BF0
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
05B90:  MOVLB  6
05B92:  CLRF   x30
05B94:  MOVFF  5ED,62F
05B98:  CLRF   x32
05B9A:  MOVLW  B5
05B9C:  MOVWF  x31
05B9E:  MOVLB  0
05BA0:  CALL   087E
05BA4:  MOVFF  02,5FB
05BA8:  MOVFF  01,5FA
05BAC:  MOVLW  06
05BAE:  MOVLB  5
05BB0:  ADDWF  xFA,F
05BB2:  MOVLW  00
05BB4:  ADDWFC xFB,F
05BB6:  MOVLW  32
05BB8:  ADDWF  xFA,W
05BBA:  MOVWF  01
05BBC:  MOVLW  00
05BBE:  ADDWFC xFB,W
05BC0:  MOVWF  03
05BC2:  MOVF   01,W
05BC4:  ADDLW  6A
05BC6:  MOVWF  01
05BC8:  MOVLW  01
05BCA:  ADDWFC 03,F
05BCC:  MOVFF  01,5FA
05BD0:  MOVFF  03,5FB
05BD4:  MOVFF  03,629
05BD8:  MOVFF  01,628
05BDC:  MOVLB  6
05BDE:  CLRF   x2B
05BE0:  CLRF   x2A
05BE2:  MOVLW  0A
05BE4:  MOVWF  x2C
05BE6:  MOVLB  0
05BE8:  CALL   5358
05BEC:  MOVFF  01,5F9
....................    
....................    /*** GET INPUT MAP *****************/
....................    if      (0 == chMode[arg1-1]) sprintf(retData+strlen(retData), "%d,MANUAL,", arg1);
05BF0:  MOVLW  01
05BF2:  MOVLB  5
05BF4:  SUBWF  xF9,W
05BF6:  MOVWF  xFB
05BF8:  CLRF   xFD
05BFA:  MOVLW  61
05BFC:  MOVWF  xFC
05BFE:  MOVLB  0
05C00:  CALL   3CA4
05C04:  BTFSC  01.0
05C06:  BRA    5C54
05C08:  MOVLW  04
05C0A:  MOVLB  6
05C0C:  MOVWF  x30
05C0E:  MOVLW  40
05C10:  MOVWF  x2F
05C12:  MOVLB  0
05C14:  CALL   50F0
05C18:  MOVFF  02,03
05C1C:  MOVF   01,W
05C1E:  ADDLW  40
05C20:  MOVLB  5
05C22:  MOVWF  xFA
05C24:  MOVLW  04
05C26:  ADDWFC 02,W
05C28:  MOVWF  xFB
05C2A:  MOVFF  FE8,4E5
05C2E:  MOVFF  5FA,4E4
05C32:  MOVFF  5F9,629
05C36:  MOVLW  18
05C38:  MOVLB  6
05C3A:  MOVWF  x2A
05C3C:  MOVLB  0
05C3E:  RCALL  56AC
05C40:  MOVLW  2C
05C42:  MOVWF  FF6
05C44:  MOVLW  03
05C46:  MOVWF  FF7
05C48:  MOVLW  08
05C4A:  MOVLB  5
05C4C:  MOVWF  xFD
05C4E:  MOVLB  0
05C50:  RCALL  5B08
05C52:  BRA    5CBE
....................    else if (1 == chMode[arg1-1]) sprintf(retData+strlen(retData), "%d,MAGSNS,", arg1);
05C54:  MOVLW  01
05C56:  MOVLB  5
05C58:  SUBWF  xF9,W
05C5A:  MOVWF  xFB
05C5C:  CLRF   xFD
05C5E:  MOVLW  61
05C60:  MOVWF  xFC
05C62:  MOVLB  0
05C64:  CALL   3CA4
05C68:  BTFSS  01.0
05C6A:  BRA    5CB8
05C6C:  MOVLW  04
05C6E:  MOVLB  6
05C70:  MOVWF  x30
05C72:  MOVLW  40
05C74:  MOVWF  x2F
05C76:  MOVLB  0
05C78:  CALL   50F0
05C7C:  MOVFF  02,03
05C80:  MOVF   01,W
05C82:  ADDLW  40
05C84:  MOVLB  5
05C86:  MOVWF  xFA
05C88:  MOVLW  04
05C8A:  ADDWFC 02,W
05C8C:  MOVWF  xFB
05C8E:  MOVFF  FE8,4E5
05C92:  MOVFF  5FA,4E4
05C96:  MOVFF  5F9,629
05C9A:  MOVLW  18
05C9C:  MOVLB  6
05C9E:  MOVWF  x2A
05CA0:  MOVLB  0
05CA2:  RCALL  56AC
05CA4:  MOVLW  38
05CA6:  MOVWF  FF6
05CA8:  MOVLW  03
05CAA:  MOVWF  FF7
05CAC:  MOVLW  08
05CAE:  MOVLB  5
05CB0:  MOVWF  xFD
05CB2:  MOVLB  0
05CB4:  RCALL  5B08
05CB6:  BRA    5CBE
....................    else return INV_PARAM;
05CB8:  MOVLW  02
05CBA:  MOVWF  01
05CBC:  BRA    5CC2
....................    
....................    return SUCCESS;
05CBE:  MOVLW  00
05CC0:  MOVWF  01
05CC2:  RETURN 0
.................... }
.................... 
.................... int8 setIPchMode(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char *arg2;
....................    char *s_manual = "MANUAL";
05CC4:  MOVLW  4D
05CC6:  MOVLB  5
05CC8:  MOVWF  xFE
05CCA:  MOVLW  41
05CCC:  MOVWF  xFF
05CCE:  MOVLW  4E
05CD0:  MOVLB  6
05CD2:  MOVWF  x00
05CD4:  MOVLW  55
05CD6:  MOVWF  x01
05CD8:  MOVLW  41
05CDA:  MOVWF  x02
05CDC:  MOVLW  4C
05CDE:  MOVWF  x03
05CE0:  CLRF   x04
05CE2:  MOVLW  05
05CE4:  MOVLB  5
05CE6:  MOVWF  xFD
05CE8:  MOVLW  FE
05CEA:  MOVWF  xFC
....................    char *s_magsns = "MAGSNS";
05CEC:  MOVLW  4D
05CEE:  MOVLB  6
05CF0:  MOVWF  x07
05CF2:  MOVLW  41
05CF4:  MOVWF  x08
05CF6:  MOVLW  47
05CF8:  MOVWF  x09
05CFA:  MOVLW  53
05CFC:  MOVWF  x0A
05CFE:  MOVLW  4E
05D00:  MOVWF  x0B
05D02:  MOVLW  53
05D04:  MOVWF  x0C
05D06:  CLRF   x0D
05D08:  MOVLW  06
05D0A:  MOVWF  x06
05D0C:  MOVLW  07
05D0E:  MOVWF  x05
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
05D10:  CLRF   x30
05D12:  MOVFF  5ED,62F
05D16:  CLRF   x32
05D18:  MOVLW  B5
05D1A:  MOVWF  x31
05D1C:  MOVLB  0
05D1E:  CALL   087E
05D22:  MOVFF  02,60F
05D26:  MOVFF  01,60E
05D2A:  MOVLW  06
05D2C:  MOVLB  6
05D2E:  ADDWF  x0E,F
05D30:  MOVLW  00
05D32:  ADDWFC x0F,F
05D34:  MOVLW  32
05D36:  ADDWF  x0E,W
05D38:  MOVWF  01
05D3A:  MOVLW  00
05D3C:  ADDWFC x0F,W
05D3E:  MOVWF  03
05D40:  MOVF   01,W
05D42:  ADDLW  6A
05D44:  MOVWF  01
05D46:  MOVLW  01
05D48:  ADDWFC 03,F
05D4A:  MOVFF  01,60E
05D4E:  MOVFF  03,60F
05D52:  MOVFF  03,629
05D56:  MOVFF  01,628
05D5A:  MOVLB  0
05D5C:  CALL   5268
05D60:  MOVF   01,F
05D62:  BNZ   5D6C
05D64:  MOVLW  02
05D66:  MOVWF  01
05D68:  BRA    5EE6
05D6A:  BRA    5DCA
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
05D6C:  MOVLB  6
05D6E:  CLRF   x30
05D70:  MOVFF  5ED,62F
05D74:  CLRF   x32
05D76:  MOVLW  B5
05D78:  MOVWF  x31
05D7A:  MOVLB  0
05D7C:  CALL   087E
05D80:  MOVFF  02,60F
05D84:  MOVFF  01,60E
05D88:  MOVLW  06
05D8A:  MOVLB  6
05D8C:  ADDWF  x0E,F
05D8E:  MOVLW  00
05D90:  ADDWFC x0F,F
05D92:  MOVLW  32
05D94:  ADDWF  x0E,W
05D96:  MOVWF  01
05D98:  MOVLW  00
05D9A:  ADDWFC x0F,W
05D9C:  MOVWF  03
05D9E:  MOVF   01,W
05DA0:  ADDLW  6A
05DA2:  MOVWF  01
05DA4:  MOVLW  01
05DA6:  ADDWFC 03,F
05DA8:  MOVFF  01,60E
05DAC:  MOVFF  03,60F
05DB0:  MOVFF  03,629
05DB4:  MOVFF  01,628
05DB8:  CLRF   x2B
05DBA:  CLRF   x2A
05DBC:  MOVLW  0A
05DBE:  MOVWF  x2C
05DC0:  MOVLB  0
05DC2:  CALL   5358
05DC6:  MOVFF  01,5F9
....................    
....................    if (0 == strlen(SERcmd[rec].p[3])) return INV_PARAM;
05DCA:  MOVLB  6
05DCC:  CLRF   x30
05DCE:  MOVFF  5ED,62F
05DD2:  CLRF   x32
05DD4:  MOVLW  B5
05DD6:  MOVWF  x31
05DD8:  MOVLB  0
05DDA:  CALL   087E
05DDE:  MOVFF  02,60F
05DE2:  MOVFF  01,60E
05DE6:  MOVLW  06
05DE8:  MOVLB  6
05DEA:  ADDWF  x0E,F
05DEC:  MOVLW  00
05DEE:  ADDWFC x0F,F
05DF0:  MOVLW  4B
05DF2:  ADDWF  x0E,W
05DF4:  MOVWF  01
05DF6:  MOVLW  00
05DF8:  ADDWFC x0F,W
05DFA:  MOVWF  03
05DFC:  MOVF   01,W
05DFE:  ADDLW  6A
05E00:  MOVWF  01
05E02:  MOVLW  01
05E04:  ADDWFC 03,F
05E06:  MOVFF  01,60E
05E0A:  MOVFF  03,60F
05E0E:  MOVFF  03,630
05E12:  MOVFF  01,62F
05E16:  MOVLB  0
05E18:  CALL   50F0
05E1C:  MOVFF  02,03
05E20:  MOVF   01,W
05E22:  BNZ   5E30
05E24:  MOVF   03,F
05E26:  BNZ   5E30
05E28:  MOVLW  02
05E2A:  MOVWF  01
05E2C:  BRA    5EE6
05E2E:  BRA    5E76
....................    else arg2 = SERcmd[rec].p[3];
05E30:  MOVLB  6
05E32:  CLRF   x30
05E34:  MOVFF  5ED,62F
05E38:  CLRF   x32
05E3A:  MOVLW  B5
05E3C:  MOVWF  x31
05E3E:  MOVLB  0
05E40:  CALL   087E
05E44:  MOVFF  02,60F
05E48:  MOVFF  01,60E
05E4C:  MOVLW  06
05E4E:  MOVLB  6
05E50:  ADDWF  x0E,F
05E52:  MOVLW  00
05E54:  ADDWFC x0F,F
05E56:  MOVLW  4B
05E58:  ADDWF  x0E,W
05E5A:  MOVWF  01
05E5C:  MOVLW  00
05E5E:  ADDWFC x0F,W
05E60:  MOVWF  03
05E62:  MOVF   01,W
05E64:  ADDLW  6A
05E66:  MOVWF  01
05E68:  MOVLW  01
05E6A:  ADDWFC 03,F
05E6C:  MOVFF  01,5FA
05E70:  MOVFF  03,5FB
05E74:  MOVLB  0
....................    
....................    /*** SET INPUT MAP *****************/
....................    if      (0 == strcmp(s_manual, arg2)) chMode[arg1-1] = MANUAL;
05E76:  MOVFF  5FD,630
05E7A:  MOVFF  5FC,62F
05E7E:  MOVFF  5FB,632
05E82:  MOVFF  5FA,631
05E86:  CALL   5128
05E8A:  MOVF   01,F
05E8C:  BNZ   5EA8
05E8E:  MOVLW  01
05E90:  MOVLB  5
05E92:  SUBWF  xF9,W
05E94:  MOVLB  6
05E96:  MOVWF  x0E
05E98:  MOVWF  x10
05E9A:  CLRF   x11
05E9C:  CLRF   x13
05E9E:  MOVLW  61
05EA0:  MOVWF  x12
05EA2:  MOVLB  0
05EA4:  RCALL  590E
05EA6:  BRA    5EE2
....................    else if (0 == strcmp(s_magsns, arg2)) chMode[arg1-1] = MAGSNS;
05EA8:  MOVFF  606,630
05EAC:  MOVFF  605,62F
05EB0:  MOVFF  5FB,632
05EB4:  MOVFF  5FA,631
05EB8:  CALL   5128
05EBC:  MOVF   01,F
05EBE:  BNZ   5EDC
05EC0:  MOVLW  01
05EC2:  MOVLB  5
05EC4:  SUBWF  xF9,W
05EC6:  MOVLB  6
05EC8:  MOVWF  x0E
05ECA:  MOVWF  x10
05ECC:  MOVLW  01
05ECE:  MOVWF  x11
05ED0:  CLRF   x13
05ED2:  MOVLW  61
05ED4:  MOVWF  x12
05ED6:  MOVLB  0
05ED8:  RCALL  590E
05EDA:  BRA    5EE2
....................    else return INV_PARAM;
05EDC:  MOVLW  02
05EDE:  MOVWF  01
05EE0:  BRA    5EE6
....................    
....................    return SUCCESS;
05EE2:  MOVLW  00
05EE4:  MOVWF  01
05EE6:  RETURN 0
.................... }
.................... 
.................... int8 getPIDvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/ 
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
0609E:  MOVLB  6
060A0:  CLRF   x30
060A2:  MOVFF  5ED,62F
060A6:  CLRF   x32
060A8:  MOVLW  B5
060AA:  MOVWF  x31
060AC:  MOVLB  0
060AE:  CALL   087E
060B2:  MOVFF  02,601
060B6:  MOVFF  01,600
060BA:  MOVLW  06
060BC:  MOVLB  6
060BE:  ADDWF  x00,F
060C0:  MOVLW  00
060C2:  ADDWFC x01,F
060C4:  MOVLW  32
060C6:  ADDWF  x00,W
060C8:  MOVWF  01
060CA:  MOVLW  00
060CC:  ADDWFC x01,W
060CE:  MOVWF  03
060D0:  MOVF   01,W
060D2:  ADDLW  6A
060D4:  MOVWF  01
060D6:  MOVLW  01
060D8:  ADDWFC 03,F
060DA:  MOVFF  01,600
060DE:  MOVFF  03,601
060E2:  MOVFF  03,629
060E6:  MOVFF  01,628
060EA:  MOVLB  0
060EC:  CALL   5268
060F0:  MOVF   01,F
060F2:  BNZ   60FC
060F4:  MOVLW  02
060F6:  MOVWF  01
060F8:  BRA    6572
060FA:  BRA    615A
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
060FC:  MOVLB  6
060FE:  CLRF   x30
06100:  MOVFF  5ED,62F
06104:  CLRF   x32
06106:  MOVLW  B5
06108:  MOVWF  x31
0610A:  MOVLB  0
0610C:  CALL   087E
06110:  MOVFF  02,601
06114:  MOVFF  01,600
06118:  MOVLW  06
0611A:  MOVLB  6
0611C:  ADDWF  x00,F
0611E:  MOVLW  00
06120:  ADDWFC x01,F
06122:  MOVLW  32
06124:  ADDWF  x00,W
06126:  MOVWF  01
06128:  MOVLW  00
0612A:  ADDWFC x01,W
0612C:  MOVWF  03
0612E:  MOVF   01,W
06130:  ADDLW  6A
06132:  MOVWF  01
06134:  MOVLW  01
06136:  ADDWFC 03,F
06138:  MOVFF  01,600
0613C:  MOVFF  03,601
06140:  MOVFF  03,629
06144:  MOVFF  01,628
06148:  CLRF   x2B
0614A:  CLRF   x2A
0614C:  MOVLW  0A
0614E:  MOVWF  x2C
06150:  MOVLB  0
06152:  CALL   5358
06156:  MOVFF  01,5F9
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
0615A:  MOVLB  6
0615C:  CLRF   x30
0615E:  MOVFF  5ED,62F
06162:  CLRF   x32
06164:  MOVLW  B5
06166:  MOVWF  x31
06168:  MOVLB  0
0616A:  CALL   087E
0616E:  MOVFF  02,601
06172:  MOVFF  01,600
06176:  MOVLW  06
06178:  MOVLB  6
0617A:  ADDWF  x00,F
0617C:  MOVLW  00
0617E:  ADDWFC x01,F
06180:  MOVLW  4B
06182:  ADDWF  x00,W
06184:  MOVWF  01
06186:  MOVLW  00
06188:  ADDWFC x01,W
0618A:  MOVWF  03
0618C:  MOVF   01,W
0618E:  ADDLW  6A
06190:  MOVWF  01
06192:  MOVLW  01
06194:  ADDWFC 03,F
06196:  MOVFF  01,600
0619A:  MOVFF  03,601
0619E:  MOVFF  03,630
061A2:  MOVFF  01,62F
061A6:  MOVLB  0
061A8:  CALL   50F0
061AC:  MOVFF  02,03
061B0:  MOVF   01,W
061B2:  SUBLW  01
061B4:  BNZ   61BA
061B6:  MOVF   03,F
061B8:  BZ    61C2
061BA:  MOVLW  02
061BC:  MOVWF  01
061BE:  BRA    6572
061C0:  BRA    6202
....................    else arg2 = SERcmd[rec].p[3][0];
061C2:  MOVLB  6
061C4:  CLRF   x30
061C6:  MOVFF  5ED,62F
061CA:  CLRF   x32
061CC:  MOVLW  B5
061CE:  MOVWF  x31
061D0:  MOVLB  0
061D2:  CALL   087E
061D6:  MOVFF  02,601
061DA:  MOVFF  01,600
061DE:  MOVLW  06
061E0:  MOVLB  6
061E2:  ADDWF  x00,F
061E4:  MOVLW  00
061E6:  ADDWFC x01,F
061E8:  MOVLW  4B
061EA:  ADDWF  x00,F
061EC:  MOVLW  00
061EE:  ADDWFC x01,F
061F0:  MOVLW  6A
061F2:  ADDWF  x00,W
061F4:  MOVWF  FE9
061F6:  MOVLW  01
061F8:  ADDWFC x01,W
061FA:  MOVWF  FEA
061FC:  MOVFF  FEF,5FA
06200:  MOVLB  0
....................    
....................    /*** GET P, I, D, or A(LL) VALUE **********/
....................    if      ('P' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kP);
06202:  MOVLB  5
06204:  MOVF   xFA,W
06206:  SUBLW  50
06208:  BNZ   62A8
0620A:  MOVLW  04
0620C:  MOVLB  6
0620E:  MOVWF  x30
06210:  MOVLW  40
06212:  MOVWF  x2F
06214:  MOVLB  0
06216:  CALL   50F0
0621A:  MOVFF  02,03
0621E:  MOVF   01,W
06220:  ADDLW  40
06222:  MOVLB  6
06224:  MOVWF  x00
06226:  MOVLW  04
06228:  ADDWFC 02,W
0622A:  MOVWF  x01
0622C:  MOVLW  01
0622E:  MOVLB  5
06230:  SUBWF  xF9,W
06232:  MULLW  20
06234:  MOVF   FF3,W
06236:  MOVLB  6
06238:  CLRF   x03
0623A:  MOVWF  x02
0623C:  MOVLW  20
0623E:  ADDWF  x02,W
06240:  MOVWF  FE9
06242:  MOVLW  00
06244:  ADDWFC x03,W
06246:  MOVWF  FEA
06248:  MOVFF  FEF,604
0624C:  MOVFF  FEC,605
06250:  MOVFF  FEC,606
06254:  MOVFF  FEC,607
06258:  MOVFF  601,4E5
0625C:  MOVFF  600,4E4
06260:  MOVFF  5F9,629
06264:  MOVLW  18
06266:  MOVWF  x2A
06268:  MOVLB  0
0626A:  CALL   56AC
0626E:  MOVLW  2C
06270:  MOVLB  6
06272:  MOVWF  x3E
06274:  MOVLB  0
06276:  CALL   51A0
0627A:  MOVLW  89
0627C:  MOVWF  FE9
0627E:  MOVFF  607,634
06282:  MOVFF  606,633
06286:  MOVFF  605,632
0628A:  MOVFF  604,631
0628E:  MOVLW  02
06290:  MOVLB  6
06292:  MOVWF  x35
06294:  MOVLB  0
06296:  RCALL  5EE8
06298:  MOVLW  2C
0629A:  MOVLB  6
0629C:  MOVWF  x3E
0629E:  MOVLB  0
062A0:  CALL   51A0
062A4:  BRA    656E
062A6:  MOVLB  5
....................    else if ('I' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kI);
062A8:  MOVF   xFA,W
062AA:  SUBLW  49
062AC:  BNZ   6354
062AE:  MOVLW  04
062B0:  MOVLB  6
062B2:  MOVWF  x30
062B4:  MOVLW  40
062B6:  MOVWF  x2F
062B8:  MOVLB  0
062BA:  CALL   50F0
062BE:  MOVF   01,W
062C0:  ADDLW  40
062C2:  MOVLB  6
062C4:  MOVWF  x00
062C6:  MOVLW  04
062C8:  ADDWFC 02,W
062CA:  MOVWF  x01
062CC:  MOVLW  01
062CE:  MOVLB  5
062D0:  SUBWF  xF9,W
062D2:  MULLW  20
062D4:  MOVF   FF3,W
062D6:  MOVLB  6
062D8:  CLRF   x03
062DA:  MOVWF  x02
062DC:  MOVLW  04
062DE:  ADDWF  x02,W
062E0:  MOVWF  01
062E2:  MOVLW  00
062E4:  ADDWFC x03,W
062E6:  MOVWF  03
062E8:  MOVF   01,W
062EA:  ADDLW  20
062EC:  MOVWF  FE9
062EE:  MOVLW  00
062F0:  ADDWFC 03,W
062F2:  MOVWF  FEA
062F4:  MOVFF  FEF,602
062F8:  MOVFF  FEC,603
062FC:  MOVFF  FEC,604
06300:  MOVFF  FEC,605
06304:  MOVFF  601,4E5
06308:  MOVFF  600,4E4
0630C:  MOVFF  5F9,629
06310:  MOVLW  18
06312:  MOVWF  x2A
06314:  MOVLB  0
06316:  CALL   56AC
0631A:  MOVLW  2C
0631C:  MOVLB  6
0631E:  MOVWF  x3E
06320:  MOVLB  0
06322:  CALL   51A0
06326:  MOVLW  89
06328:  MOVWF  FE9
0632A:  MOVFF  605,634
0632E:  MOVFF  604,633
06332:  MOVFF  603,632
06336:  MOVFF  602,631
0633A:  MOVLW  02
0633C:  MOVLB  6
0633E:  MOVWF  x35
06340:  MOVLB  0
06342:  RCALL  5EE8
06344:  MOVLW  2C
06346:  MOVLB  6
06348:  MOVWF  x3E
0634A:  MOVLB  0
0634C:  CALL   51A0
06350:  BRA    656E
06352:  MOVLB  5
....................    else if ('D' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kD);
06354:  MOVF   xFA,W
06356:  SUBLW  44
06358:  BNZ   6400
0635A:  MOVLW  04
0635C:  MOVLB  6
0635E:  MOVWF  x30
06360:  MOVLW  40
06362:  MOVWF  x2F
06364:  MOVLB  0
06366:  CALL   50F0
0636A:  MOVF   01,W
0636C:  ADDLW  40
0636E:  MOVLB  6
06370:  MOVWF  x00
06372:  MOVLW  04
06374:  ADDWFC 02,W
06376:  MOVWF  x01
06378:  MOVLW  01
0637A:  MOVLB  5
0637C:  SUBWF  xF9,W
0637E:  MULLW  20
06380:  MOVF   FF3,W
06382:  MOVLB  6
06384:  CLRF   x03
06386:  MOVWF  x02
06388:  MOVLW  08
0638A:  ADDWF  x02,W
0638C:  MOVWF  01
0638E:  MOVLW  00
06390:  ADDWFC x03,W
06392:  MOVWF  03
06394:  MOVF   01,W
06396:  ADDLW  20
06398:  MOVWF  FE9
0639A:  MOVLW  00
0639C:  ADDWFC 03,W
0639E:  MOVWF  FEA
063A0:  MOVFF  FEF,602
063A4:  MOVFF  FEC,603
063A8:  MOVFF  FEC,604
063AC:  MOVFF  FEC,605
063B0:  MOVFF  601,4E5
063B4:  MOVFF  600,4E4
063B8:  MOVFF  5F9,629
063BC:  MOVLW  18
063BE:  MOVWF  x2A
063C0:  MOVLB  0
063C2:  CALL   56AC
063C6:  MOVLW  2C
063C8:  MOVLB  6
063CA:  MOVWF  x3E
063CC:  MOVLB  0
063CE:  CALL   51A0
063D2:  MOVLW  89
063D4:  MOVWF  FE9
063D6:  MOVFF  605,634
063DA:  MOVFF  604,633
063DE:  MOVFF  603,632
063E2:  MOVFF  602,631
063E6:  MOVLW  02
063E8:  MOVLB  6
063EA:  MOVWF  x35
063EC:  MOVLB  0
063EE:  RCALL  5EE8
063F0:  MOVLW  2C
063F2:  MOVLB  6
063F4:  MOVWF  x3E
063F6:  MOVLB  0
063F8:  CALL   51A0
063FC:  BRA    656E
063FE:  MOVLB  5
....................    else if ('A' == arg2) sprintf(retData+strlen(retData), "%d,%f,%f,%f,", arg1, PID[arg1-1].kP, PID[arg1-1].kI, PID[arg1-1].kD);
06400:  MOVF   xFA,W
06402:  SUBLW  41
06404:  BTFSS  FD8.2
06406:  BRA    6566
06408:  MOVLW  04
0640A:  MOVLB  6
0640C:  MOVWF  x30
0640E:  MOVLW  40
06410:  MOVWF  x2F
06412:  MOVLB  0
06414:  CALL   50F0
06418:  MOVF   01,W
0641A:  ADDLW  40
0641C:  MOVLB  6
0641E:  MOVWF  x00
06420:  MOVLW  04
06422:  ADDWFC 02,W
06424:  MOVWF  x01
06426:  MOVLW  01
06428:  MOVLB  5
0642A:  SUBWF  xF9,W
0642C:  MULLW  20
0642E:  MOVF   FF3,W
06430:  MOVLB  6
06432:  CLRF   x03
06434:  MOVWF  x02
06436:  MOVLW  20
06438:  ADDWF  x02,W
0643A:  MOVWF  FE9
0643C:  MOVLW  00
0643E:  ADDWFC x03,W
06440:  MOVWF  FEA
06442:  MOVFF  FEF,604
06446:  MOVFF  FEC,605
0644A:  MOVFF  FEC,606
0644E:  MOVFF  FEC,607
06452:  MOVLW  01
06454:  MOVLB  5
06456:  SUBWF  xF9,W
06458:  MULLW  20
0645A:  MOVF   FF3,W
0645C:  MOVLB  6
0645E:  CLRF   x09
06460:  MOVWF  x08
06462:  MOVLW  04
06464:  ADDWF  x08,W
06466:  MOVWF  01
06468:  MOVLW  00
0646A:  ADDWFC x09,W
0646C:  MOVWF  03
0646E:  MOVF   01,W
06470:  ADDLW  20
06472:  MOVWF  FE9
06474:  MOVLW  00
06476:  ADDWFC 03,W
06478:  MOVWF  FEA
0647A:  MOVFF  FEF,608
0647E:  MOVFF  FEC,609
06482:  MOVFF  FEC,60A
06486:  MOVFF  FEC,60B
0648A:  MOVLW  01
0648C:  MOVLB  5
0648E:  SUBWF  xF9,W
06490:  MULLW  20
06492:  MOVF   FF3,W
06494:  MOVLB  6
06496:  CLRF   x0D
06498:  MOVWF  x0C
0649A:  MOVLW  08
0649C:  ADDWF  x0C,W
0649E:  MOVWF  01
064A0:  MOVLW  00
064A2:  ADDWFC x0D,W
064A4:  MOVWF  03
064A6:  MOVF   01,W
064A8:  ADDLW  20
064AA:  MOVWF  FE9
064AC:  MOVLW  00
064AE:  ADDWFC 03,W
064B0:  MOVWF  FEA
064B2:  MOVFF  FEF,60C
064B6:  MOVFF  FEC,60D
064BA:  MOVFF  FEC,60E
064BE:  MOVFF  FEC,60F
064C2:  MOVFF  601,4E5
064C6:  MOVFF  600,4E4
064CA:  MOVFF  5F9,629
064CE:  MOVLW  18
064D0:  MOVWF  x2A
064D2:  MOVLB  0
064D4:  CALL   56AC
064D8:  MOVLW  2C
064DA:  MOVLB  6
064DC:  MOVWF  x3E
064DE:  MOVLB  0
064E0:  CALL   51A0
064E4:  MOVLW  89
064E6:  MOVWF  FE9
064E8:  MOVFF  607,634
064EC:  MOVFF  606,633
064F0:  MOVFF  605,632
064F4:  MOVFF  604,631
064F8:  MOVLW  02
064FA:  MOVLB  6
064FC:  MOVWF  x35
064FE:  MOVLB  0
06500:  RCALL  5EE8
06502:  MOVLW  2C
06504:  MOVLB  6
06506:  MOVWF  x3E
06508:  MOVLB  0
0650A:  CALL   51A0
0650E:  MOVLW  89
06510:  MOVWF  FE9
06512:  MOVFF  60B,634
06516:  MOVFF  60A,633
0651A:  MOVFF  609,632
0651E:  MOVFF  608,631
06522:  MOVLW  02
06524:  MOVLB  6
06526:  MOVWF  x35
06528:  MOVLB  0
0652A:  RCALL  5EE8
0652C:  MOVLW  2C
0652E:  MOVLB  6
06530:  MOVWF  x3E
06532:  MOVLB  0
06534:  CALL   51A0
06538:  MOVLW  89
0653A:  MOVWF  FE9
0653C:  MOVFF  60F,634
06540:  MOVFF  60E,633
06544:  MOVFF  60D,632
06548:  MOVFF  60C,631
0654C:  MOVLW  02
0654E:  MOVLB  6
06550:  MOVWF  x35
06552:  MOVLB  0
06554:  RCALL  5EE8
06556:  MOVLW  2C
06558:  MOVLB  6
0655A:  MOVWF  x3E
0655C:  MOVLB  0
0655E:  CALL   51A0
06562:  BRA    656E
06564:  MOVLB  5
....................    else return INV_PARAM;
06566:  MOVLW  02
06568:  MOVWF  01
0656A:  MOVLB  0
0656C:  BRA    6572
....................    
....................    return SUCCESS;
0656E:  MOVLW  00
06570:  MOVWF  01
06572:  RETURN 0
.................... }
.................... 
.................... int8 setPIDvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char  arg2;
....................    float arg3;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
06890:  MOVLB  6
06892:  CLRF   x30
06894:  MOVFF  5ED,62F
06898:  CLRF   x32
0689A:  MOVLW  B5
0689C:  MOVWF  x31
0689E:  MOVLB  0
068A0:  CALL   087E
068A4:  MOVFF  02,600
068A8:  MOVFF  01,5FF
068AC:  MOVLW  06
068AE:  MOVLB  5
068B0:  ADDWF  xFF,F
068B2:  MOVLW  00
068B4:  MOVLB  6
068B6:  ADDWFC x00,F
068B8:  MOVLW  32
068BA:  MOVLB  5
068BC:  ADDWF  xFF,W
068BE:  MOVWF  01
068C0:  MOVLW  00
068C2:  MOVLB  6
068C4:  ADDWFC x00,W
068C6:  MOVWF  03
068C8:  MOVF   01,W
068CA:  ADDLW  6A
068CC:  MOVWF  01
068CE:  MOVLW  01
068D0:  ADDWFC 03,F
068D2:  MOVFF  01,5FF
068D6:  MOVFF  03,600
068DA:  MOVFF  03,629
068DE:  MOVFF  01,628
068E2:  MOVLB  0
068E4:  CALL   5268
068E8:  MOVF   01,F
068EA:  BNZ   68F4
068EC:  MOVLW  02
068EE:  MOVWF  01
068F0:  BRA    6BB2
068F2:  BRA    695A
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
068F4:  MOVLB  6
068F6:  CLRF   x30
068F8:  MOVFF  5ED,62F
068FC:  CLRF   x32
068FE:  MOVLW  B5
06900:  MOVWF  x31
06902:  MOVLB  0
06904:  CALL   087E
06908:  MOVFF  02,600
0690C:  MOVFF  01,5FF
06910:  MOVLW  06
06912:  MOVLB  5
06914:  ADDWF  xFF,F
06916:  MOVLW  00
06918:  MOVLB  6
0691A:  ADDWFC x00,F
0691C:  MOVLW  32
0691E:  MOVLB  5
06920:  ADDWF  xFF,W
06922:  MOVWF  01
06924:  MOVLW  00
06926:  MOVLB  6
06928:  ADDWFC x00,W
0692A:  MOVWF  03
0692C:  MOVF   01,W
0692E:  ADDLW  6A
06930:  MOVWF  01
06932:  MOVLW  01
06934:  ADDWFC 03,F
06936:  MOVFF  01,5FF
0693A:  MOVFF  03,600
0693E:  MOVFF  03,629
06942:  MOVFF  01,628
06946:  MOVLB  6
06948:  CLRF   x2B
0694A:  CLRF   x2A
0694C:  MOVLW  0A
0694E:  MOVWF  x2C
06950:  MOVLB  0
06952:  CALL   5358
06956:  MOVFF  01,5F9
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
0695A:  MOVLB  6
0695C:  CLRF   x30
0695E:  MOVFF  5ED,62F
06962:  CLRF   x32
06964:  MOVLW  B5
06966:  MOVWF  x31
06968:  MOVLB  0
0696A:  CALL   087E
0696E:  MOVFF  02,600
06972:  MOVFF  01,5FF
06976:  MOVLW  06
06978:  MOVLB  5
0697A:  ADDWF  xFF,F
0697C:  MOVLW  00
0697E:  MOVLB  6
06980:  ADDWFC x00,F
06982:  MOVLW  4B
06984:  MOVLB  5
06986:  ADDWF  xFF,W
06988:  MOVWF  01
0698A:  MOVLW  00
0698C:  MOVLB  6
0698E:  ADDWFC x00,W
06990:  MOVWF  03
06992:  MOVF   01,W
06994:  ADDLW  6A
06996:  MOVWF  01
06998:  MOVLW  01
0699A:  ADDWFC 03,F
0699C:  MOVFF  01,5FF
069A0:  MOVFF  03,600
069A4:  MOVFF  03,630
069A8:  MOVFF  01,62F
069AC:  MOVLB  0
069AE:  CALL   50F0
069B2:  MOVFF  02,03
069B6:  MOVF   01,W
069B8:  SUBLW  01
069BA:  BNZ   69C0
069BC:  MOVF   03,F
069BE:  BZ    69C8
069C0:  MOVLW  02
069C2:  MOVWF  01
069C4:  BRA    6BB2
069C6:  BRA    6A12
....................    else arg2 = SERcmd[rec].p[3][0];
069C8:  MOVLB  6
069CA:  CLRF   x30
069CC:  MOVFF  5ED,62F
069D0:  CLRF   x32
069D2:  MOVLW  B5
069D4:  MOVWF  x31
069D6:  MOVLB  0
069D8:  CALL   087E
069DC:  MOVFF  02,600
069E0:  MOVFF  01,5FF
069E4:  MOVLW  06
069E6:  MOVLB  5
069E8:  ADDWF  xFF,F
069EA:  MOVLW  00
069EC:  MOVLB  6
069EE:  ADDWFC x00,F
069F0:  MOVLW  4B
069F2:  MOVLB  5
069F4:  ADDWF  xFF,F
069F6:  MOVLW  00
069F8:  MOVLB  6
069FA:  ADDWFC x00,F
069FC:  MOVLW  6A
069FE:  MOVLB  5
06A00:  ADDWF  xFF,W
06A02:  MOVWF  FE9
06A04:  MOVLW  01
06A06:  MOVLB  6
06A08:  ADDWFC x00,W
06A0A:  MOVWF  FEA
06A0C:  MOVFF  FEF,5FA
06A10:  MOVLB  0
....................    
....................    if (!arg_is_float(SERcmd[rec].p[4])) return INV_PARAM;
06A12:  MOVLB  6
06A14:  CLRF   x30
06A16:  MOVFF  5ED,62F
06A1A:  CLRF   x32
06A1C:  MOVLW  B5
06A1E:  MOVWF  x31
06A20:  MOVLB  0
06A22:  CALL   087E
06A26:  MOVFF  02,600
06A2A:  MOVFF  01,5FF
06A2E:  MOVLW  06
06A30:  MOVLB  5
06A32:  ADDWF  xFF,F
06A34:  MOVLW  00
06A36:  MOVLB  6
06A38:  ADDWFC x00,F
06A3A:  MOVLW  64
06A3C:  MOVLB  5
06A3E:  ADDWF  xFF,W
06A40:  MOVWF  01
06A42:  MOVLW  00
06A44:  MOVLB  6
06A46:  ADDWFC x00,W
06A48:  MOVWF  03
06A4A:  MOVF   01,W
06A4C:  ADDLW  6A
06A4E:  MOVWF  01
06A50:  MOVLW  01
06A52:  ADDWFC 03,F
06A54:  MOVFF  01,5FF
06A58:  MOVFF  03,600
06A5C:  MOVFF  03,603
06A60:  MOVFF  01,602
06A64:  MOVLB  0
06A66:  RCALL  6574
06A68:  MOVF   01,F
06A6A:  BNZ   6A74
06A6C:  MOVLW  02
06A6E:  MOVWF  01
06A70:  BRA    6BB2
06A72:  BRA    6AE0
....................    else arg3 = strtod(SERcmd[rec].p[4], '\0');
06A74:  MOVLB  6
06A76:  CLRF   x30
06A78:  MOVFF  5ED,62F
06A7C:  CLRF   x32
06A7E:  MOVLW  B5
06A80:  MOVWF  x31
06A82:  MOVLB  0
06A84:  CALL   087E
06A88:  MOVFF  02,600
06A8C:  MOVFF  01,5FF
06A90:  MOVLW  06
06A92:  MOVLB  5
06A94:  ADDWF  xFF,F
06A96:  MOVLW  00
06A98:  MOVLB  6
06A9A:  ADDWFC x00,F
06A9C:  MOVLW  64
06A9E:  MOVLB  5
06AA0:  ADDWF  xFF,W
06AA2:  MOVWF  01
06AA4:  MOVLW  00
06AA6:  MOVLB  6
06AA8:  ADDWFC x00,W
06AAA:  MOVWF  03
06AAC:  MOVF   01,W
06AAE:  ADDLW  6A
06AB0:  MOVWF  01
06AB2:  MOVLW  01
06AB4:  ADDWFC 03,F
06AB6:  MOVFF  01,5FF
06ABA:  MOVFF  03,600
06ABE:  MOVFF  03,603
06AC2:  MOVFF  01,602
06AC6:  MOVLB  6
06AC8:  CLRF   x05
06ACA:  CLRF   x04
06ACC:  MOVLB  0
06ACE:  RCALL  6636
06AD0:  MOVFF  03,5FE
06AD4:  MOVFF  02,5FD
06AD8:  MOVFF  01,5FC
06ADC:  MOVFF  00,5FB
....................    
....................    /*** SET P, I, or D VALUE **********/
....................    if      ('P' == arg2) PID[arg1-1].kP = arg3;
06AE0:  MOVLB  5
06AE2:  MOVF   xFA,W
06AE4:  SUBLW  50
06AE6:  BNZ   6B1A
06AE8:  MOVLW  01
06AEA:  SUBWF  xF9,W
06AEC:  MULLW  20
06AEE:  MOVF   FF3,W
06AF0:  MOVLB  6
06AF2:  CLRF   x00
06AF4:  MOVLB  5
06AF6:  MOVWF  xFF
06AF8:  MOVLW  20
06AFA:  ADDWF  xFF,W
06AFC:  MOVWF  FE9
06AFE:  MOVLW  00
06B00:  MOVLB  6
06B02:  ADDWFC x00,W
06B04:  MOVWF  FEA
06B06:  MOVFF  5FB,FEF
06B0A:  MOVFF  5FC,FEC
06B0E:  MOVFF  5FD,FEC
06B12:  MOVFF  5FE,FEC
06B16:  BRA    6BAC
06B18:  MOVLB  5
....................    else if ('I' == arg2) PID[arg1-1].kI = arg3;
06B1A:  MOVF   xFA,W
06B1C:  SUBLW  49
06B1E:  BNZ   6B5E
06B20:  MOVLW  01
06B22:  SUBWF  xF9,W
06B24:  MULLW  20
06B26:  MOVF   FF3,W
06B28:  MOVLB  6
06B2A:  CLRF   x00
06B2C:  MOVLB  5
06B2E:  MOVWF  xFF
06B30:  MOVLW  04
06B32:  ADDWF  xFF,W
06B34:  MOVWF  01
06B36:  MOVLW  00
06B38:  MOVLB  6
06B3A:  ADDWFC x00,W
06B3C:  MOVWF  03
06B3E:  MOVF   01,W
06B40:  ADDLW  20
06B42:  MOVWF  FE9
06B44:  MOVLW  00
06B46:  ADDWFC 03,W
06B48:  MOVWF  FEA
06B4A:  MOVFF  5FB,FEF
06B4E:  MOVFF  5FC,FEC
06B52:  MOVFF  5FD,FEC
06B56:  MOVFF  5FE,FEC
06B5A:  BRA    6BAC
06B5C:  MOVLB  5
....................    else if ('D' == arg2) PID[arg1-1].kD = arg3;
06B5E:  MOVF   xFA,W
06B60:  SUBLW  44
06B62:  BNZ   6BA2
06B64:  MOVLW  01
06B66:  SUBWF  xF9,W
06B68:  MULLW  20
06B6A:  MOVF   FF3,W
06B6C:  MOVLB  6
06B6E:  CLRF   x00
06B70:  MOVLB  5
06B72:  MOVWF  xFF
06B74:  MOVLW  08
06B76:  ADDWF  xFF,W
06B78:  MOVWF  01
06B7A:  MOVLW  00
06B7C:  MOVLB  6
06B7E:  ADDWFC x00,W
06B80:  MOVWF  03
06B82:  MOVF   01,W
06B84:  ADDLW  20
06B86:  MOVWF  FE9
06B88:  MOVLW  00
06B8A:  ADDWFC 03,W
06B8C:  MOVWF  FEA
06B8E:  MOVFF  5FB,FEF
06B92:  MOVFF  5FC,FEC
06B96:  MOVFF  5FD,FEC
06B9A:  MOVFF  5FE,FEC
06B9E:  BRA    6BAC
06BA0:  MOVLB  5
....................    else return INV_PARAM;
06BA2:  MOVLW  02
06BA4:  MOVWF  01
06BA6:  MOVLB  0
06BA8:  BRA    6BB2
06BAA:  MOVLB  6
....................    
....................    return SUCCESS;
06BAC:  MOVLW  00
06BAE:  MOVWF  01
06BB0:  MOVLB  0
06BB2:  RETURN 0
.................... }
.................... 
.................... //!int8 enablePID(unsigned int8 rec){
.................... //!   /*** ARG CHECKS ********************/
.................... //!   int8  arg1;
.................... //!   
.................... //!   if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
.................... //!   else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
.................... //!   
.................... //!   PID[arg1-1].enable = TRUE;
.................... //!   
.................... //!   return SUCCESS;
.................... //!}
.................... //!
.................... //!int8 disablePID(unsigned int8 rec){
.................... //!   /*** ARG CHECKS ********************/
.................... //!   int8  arg1;
.................... //!   
.................... //!   if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
.................... //!   else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
.................... //!   
.................... //!   PID[arg1-1].enable = FALSE;
.................... //!   
.................... //!   return SUCCESS;
.................... //!}
.................... 
.................... int8 getSetPoint(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
06BB4:  MOVLB  6
06BB6:  CLRF   x30
06BB8:  MOVFF  5ED,62F
06BBC:  CLRF   x32
06BBE:  MOVLW  B5
06BC0:  MOVWF  x31
06BC2:  MOVLB  0
06BC4:  CALL   087E
06BC8:  MOVFF  02,5FB
06BCC:  MOVFF  01,5FA
06BD0:  MOVLW  06
06BD2:  MOVLB  5
06BD4:  ADDWF  xFA,F
06BD6:  MOVLW  00
06BD8:  ADDWFC xFB,F
06BDA:  MOVLW  32
06BDC:  ADDWF  xFA,W
06BDE:  MOVWF  01
06BE0:  MOVLW  00
06BE2:  ADDWFC xFB,W
06BE4:  MOVWF  03
06BE6:  MOVF   01,W
06BE8:  ADDLW  6A
06BEA:  MOVWF  01
06BEC:  MOVLW  01
06BEE:  ADDWFC 03,F
06BF0:  MOVFF  01,5FA
06BF4:  MOVFF  03,5FB
06BF8:  MOVFF  03,629
06BFC:  MOVFF  01,628
06C00:  MOVLB  0
06C02:  CALL   5268
06C06:  MOVF   01,F
06C08:  BNZ   6C12
06C0A:  MOVLW  02
06C0C:  MOVWF  01
06C0E:  BRA    6D18
06C10:  BRA    6C72
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06C12:  MOVLB  6
06C14:  CLRF   x30
06C16:  MOVFF  5ED,62F
06C1A:  CLRF   x32
06C1C:  MOVLW  B5
06C1E:  MOVWF  x31
06C20:  MOVLB  0
06C22:  CALL   087E
06C26:  MOVFF  02,5FB
06C2A:  MOVFF  01,5FA
06C2E:  MOVLW  06
06C30:  MOVLB  5
06C32:  ADDWF  xFA,F
06C34:  MOVLW  00
06C36:  ADDWFC xFB,F
06C38:  MOVLW  32
06C3A:  ADDWF  xFA,W
06C3C:  MOVWF  01
06C3E:  MOVLW  00
06C40:  ADDWFC xFB,W
06C42:  MOVWF  03
06C44:  MOVF   01,W
06C46:  ADDLW  6A
06C48:  MOVWF  01
06C4A:  MOVLW  01
06C4C:  ADDWFC 03,F
06C4E:  MOVFF  01,5FA
06C52:  MOVFF  03,5FB
06C56:  MOVFF  03,629
06C5A:  MOVFF  01,628
06C5E:  MOVLB  6
06C60:  CLRF   x2B
06C62:  CLRF   x2A
06C64:  MOVLW  0A
06C66:  MOVWF  x2C
06C68:  MOVLB  0
06C6A:  CALL   5358
06C6E:  MOVFF  01,5F9
....................    
....................    /*** GET SETPOINT ******************/ 
....................    sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].SP);
06C72:  MOVLW  04
06C74:  MOVLB  6
06C76:  MOVWF  x30
06C78:  MOVLW  40
06C7A:  MOVWF  x2F
06C7C:  MOVLB  0
06C7E:  CALL   50F0
06C82:  MOVF   01,W
06C84:  ADDLW  40
06C86:  MOVLB  5
06C88:  MOVWF  xFA
06C8A:  MOVLW  04
06C8C:  ADDWFC 02,W
06C8E:  MOVWF  xFB
06C90:  MOVLW  01
06C92:  SUBWF  xF9,W
06C94:  MULLW  20
06C96:  MOVF   FF3,W
06C98:  CLRF   xFD
06C9A:  MOVWF  xFC
06C9C:  MOVLW  0C
06C9E:  ADDWF  xFC,W
06CA0:  MOVWF  01
06CA2:  MOVLW  00
06CA4:  ADDWFC xFD,W
06CA6:  MOVWF  03
06CA8:  MOVF   01,W
06CAA:  ADDLW  20
06CAC:  MOVWF  FE9
06CAE:  MOVLW  00
06CB0:  ADDWFC 03,W
06CB2:  MOVWF  FEA
06CB4:  MOVFF  FEF,5FC
06CB8:  MOVFF  FEC,5FD
06CBC:  MOVFF  FEC,5FE
06CC0:  MOVFF  FEC,5FF
06CC4:  MOVFF  5FB,4E5
06CC8:  MOVFF  5FA,4E4
06CCC:  MOVFF  5F9,629
06CD0:  MOVLW  18
06CD2:  MOVLB  6
06CD4:  MOVWF  x2A
06CD6:  MOVLB  0
06CD8:  CALL   56AC
06CDC:  MOVLW  2C
06CDE:  MOVLB  6
06CE0:  MOVWF  x3E
06CE2:  MOVLB  0
06CE4:  CALL   51A0
06CE8:  MOVLW  89
06CEA:  MOVWF  FE9
06CEC:  MOVFF  5FF,634
06CF0:  MOVFF  5FE,633
06CF4:  MOVFF  5FD,632
06CF8:  MOVFF  5FC,631
06CFC:  MOVLW  02
06CFE:  MOVLB  6
06D00:  MOVWF  x35
06D02:  MOVLB  0
06D04:  CALL   5EE8
06D08:  MOVLW  2C
06D0A:  MOVLB  6
06D0C:  MOVWF  x3E
06D0E:  MOVLB  0
06D10:  CALL   51A0
....................    return SUCCESS;
06D14:  MOVLW  00
06D16:  MOVWF  01
06D18:  RETURN 0
.................... }
.................... 
.................... int8 setSetPoint(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/   
....................    int8  arg1;
....................    float arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
06D1A:  MOVLB  6
06D1C:  CLRF   x30
06D1E:  MOVFF  5ED,62F
06D22:  CLRF   x32
06D24:  MOVLW  B5
06D26:  MOVWF  x31
06D28:  MOVLB  0
06D2A:  CALL   087E
06D2E:  MOVFF  02,5FF
06D32:  MOVFF  01,5FE
06D36:  MOVLW  06
06D38:  MOVLB  5
06D3A:  ADDWF  xFE,F
06D3C:  MOVLW  00
06D3E:  ADDWFC xFF,F
06D40:  MOVLW  32
06D42:  ADDWF  xFE,W
06D44:  MOVWF  01
06D46:  MOVLW  00
06D48:  ADDWFC xFF,W
06D4A:  MOVWF  03
06D4C:  MOVF   01,W
06D4E:  ADDLW  6A
06D50:  MOVWF  01
06D52:  MOVLW  01
06D54:  ADDWFC 03,F
06D56:  MOVFF  01,5FE
06D5A:  MOVFF  03,5FF
06D5E:  MOVFF  03,629
06D62:  MOVFF  01,628
06D66:  MOVLB  0
06D68:  CALL   5268
06D6C:  MOVF   01,F
06D6E:  BNZ   6D78
06D70:  MOVLW  02
06D72:  MOVWF  01
06D74:  BRA    6EDA
06D76:  BRA    6DD8
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06D78:  MOVLB  6
06D7A:  CLRF   x30
06D7C:  MOVFF  5ED,62F
06D80:  CLRF   x32
06D82:  MOVLW  B5
06D84:  MOVWF  x31
06D86:  MOVLB  0
06D88:  CALL   087E
06D8C:  MOVFF  02,5FF
06D90:  MOVFF  01,5FE
06D94:  MOVLW  06
06D96:  MOVLB  5
06D98:  ADDWF  xFE,F
06D9A:  MOVLW  00
06D9C:  ADDWFC xFF,F
06D9E:  MOVLW  32
06DA0:  ADDWF  xFE,W
06DA2:  MOVWF  01
06DA4:  MOVLW  00
06DA6:  ADDWFC xFF,W
06DA8:  MOVWF  03
06DAA:  MOVF   01,W
06DAC:  ADDLW  6A
06DAE:  MOVWF  01
06DB0:  MOVLW  01
06DB2:  ADDWFC 03,F
06DB4:  MOVFF  01,5FE
06DB8:  MOVFF  03,5FF
06DBC:  MOVFF  03,629
06DC0:  MOVFF  01,628
06DC4:  MOVLB  6
06DC6:  CLRF   x2B
06DC8:  CLRF   x2A
06DCA:  MOVLW  0A
06DCC:  MOVWF  x2C
06DCE:  MOVLB  0
06DD0:  CALL   5358
06DD4:  MOVFF  01,5F9
....................    
....................    if (!arg_is_float(SERcmd[rec].p[3])) return INV_PARAM;
06DD8:  MOVLB  6
06DDA:  CLRF   x30
06DDC:  MOVFF  5ED,62F
06DE0:  CLRF   x32
06DE2:  MOVLW  B5
06DE4:  MOVWF  x31
06DE6:  MOVLB  0
06DE8:  CALL   087E
06DEC:  MOVFF  02,5FF
06DF0:  MOVFF  01,5FE
06DF4:  MOVLW  06
06DF6:  MOVLB  5
06DF8:  ADDWF  xFE,F
06DFA:  MOVLW  00
06DFC:  ADDWFC xFF,F
06DFE:  MOVLW  4B
06E00:  ADDWF  xFE,W
06E02:  MOVWF  01
06E04:  MOVLW  00
06E06:  ADDWFC xFF,W
06E08:  MOVWF  03
06E0A:  MOVF   01,W
06E0C:  ADDLW  6A
06E0E:  MOVWF  01
06E10:  MOVLW  01
06E12:  ADDWFC 03,F
06E14:  MOVFF  01,5FE
06E18:  MOVFF  03,5FF
06E1C:  MOVFF  03,603
06E20:  MOVFF  01,602
06E24:  MOVLB  0
06E26:  CALL   6574
06E2A:  MOVF   01,F
06E2C:  BNZ   6E36
06E2E:  MOVLW  02
06E30:  MOVWF  01
06E32:  BRA    6EDA
06E34:  BRA    6E9E
....................    else arg2 = strtod(SERcmd[rec].p[3], '\0');
06E36:  MOVLB  6
06E38:  CLRF   x30
06E3A:  MOVFF  5ED,62F
06E3E:  CLRF   x32
06E40:  MOVLW  B5
06E42:  MOVWF  x31
06E44:  MOVLB  0
06E46:  CALL   087E
06E4A:  MOVFF  02,5FF
06E4E:  MOVFF  01,5FE
06E52:  MOVLW  06
06E54:  MOVLB  5
06E56:  ADDWF  xFE,F
06E58:  MOVLW  00
06E5A:  ADDWFC xFF,F
06E5C:  MOVLW  4B
06E5E:  ADDWF  xFE,W
06E60:  MOVWF  01
06E62:  MOVLW  00
06E64:  ADDWFC xFF,W
06E66:  MOVWF  03
06E68:  MOVF   01,W
06E6A:  ADDLW  6A
06E6C:  MOVWF  01
06E6E:  MOVLW  01
06E70:  ADDWFC 03,F
06E72:  MOVFF  01,5FE
06E76:  MOVFF  03,5FF
06E7A:  MOVFF  03,603
06E7E:  MOVFF  01,602
06E82:  MOVLB  6
06E84:  CLRF   x05
06E86:  CLRF   x04
06E88:  MOVLB  0
06E8A:  CALL   6636
06E8E:  MOVFF  03,5FD
06E92:  MOVFF  02,5FC
06E96:  MOVFF  01,5FB
06E9A:  MOVFF  00,5FA
....................    
....................    /*** SET SETPOINT ******************/ 
....................    PID[arg1-1].SP = arg2;
06E9E:  MOVLW  01
06EA0:  MOVLB  5
06EA2:  SUBWF  xF9,W
06EA4:  MULLW  20
06EA6:  MOVF   FF3,W
06EA8:  CLRF   xFF
06EAA:  MOVWF  xFE
06EAC:  MOVLW  0C
06EAE:  ADDWF  xFE,W
06EB0:  MOVWF  01
06EB2:  MOVLW  00
06EB4:  ADDWFC xFF,W
06EB6:  MOVWF  03
06EB8:  MOVF   01,W
06EBA:  ADDLW  20
06EBC:  MOVWF  FE9
06EBE:  MOVLW  00
06EC0:  ADDWFC 03,W
06EC2:  MOVWF  FEA
06EC4:  MOVFF  5FA,FEF
06EC8:  MOVFF  5FB,FEC
06ECC:  MOVFF  5FC,FEC
06ED0:  MOVFF  5FD,FEC
....................    
....................    return SUCCESS;
06ED4:  MOVLW  00
06ED6:  MOVWF  01
06ED8:  MOVLB  0
06EDA:  RETURN 0
.................... }
.................... 
.................... int8 getAllSensorCalParams(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
06EDC:  MOVLB  6
06EDE:  CLRF   x30
06EE0:  MOVFF  5ED,62F
06EE4:  CLRF   x32
06EE6:  MOVLW  B5
06EE8:  MOVWF  x31
06EEA:  MOVLB  0
06EEC:  CALL   087E
06EF0:  MOVFF  02,601
06EF4:  MOVFF  01,600
06EF8:  MOVLW  06
06EFA:  MOVLB  6
06EFC:  ADDWF  x00,F
06EFE:  MOVLW  00
06F00:  ADDWFC x01,F
06F02:  MOVLW  32
06F04:  ADDWF  x00,W
06F06:  MOVWF  01
06F08:  MOVLW  00
06F0A:  ADDWFC x01,W
06F0C:  MOVWF  03
06F0E:  MOVF   01,W
06F10:  ADDLW  6A
06F12:  MOVWF  01
06F14:  MOVLW  01
06F16:  ADDWFC 03,F
06F18:  MOVFF  01,600
06F1C:  MOVFF  03,601
06F20:  MOVFF  03,629
06F24:  MOVFF  01,628
06F28:  MOVLB  0
06F2A:  CALL   5268
06F2E:  MOVF   01,F
06F30:  BNZ   6F3A
06F32:  MOVLW  02
06F34:  MOVWF  01
06F36:  BRA    72A8
06F38:  BRA    6F98
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06F3A:  MOVLB  6
06F3C:  CLRF   x30
06F3E:  MOVFF  5ED,62F
06F42:  CLRF   x32
06F44:  MOVLW  B5
06F46:  MOVWF  x31
06F48:  MOVLB  0
06F4A:  CALL   087E
06F4E:  MOVFF  02,601
06F52:  MOVFF  01,600
06F56:  MOVLW  06
06F58:  MOVLB  6
06F5A:  ADDWF  x00,F
06F5C:  MOVLW  00
06F5E:  ADDWFC x01,F
06F60:  MOVLW  32
06F62:  ADDWF  x00,W
06F64:  MOVWF  01
06F66:  MOVLW  00
06F68:  ADDWFC x01,W
06F6A:  MOVWF  03
06F6C:  MOVF   01,W
06F6E:  ADDLW  6A
06F70:  MOVWF  01
06F72:  MOVLW  01
06F74:  ADDWFC 03,F
06F76:  MOVFF  01,600
06F7A:  MOVFF  03,601
06F7E:  MOVFF  03,629
06F82:  MOVFF  01,628
06F86:  CLRF   x2B
06F88:  CLRF   x2A
06F8A:  MOVLW  0A
06F8C:  MOVWF  x2C
06F8E:  MOVLB  0
06F90:  CALL   5358
06F94:  MOVFF  01,5F9
....................    
....................    /*** GET ALL SENSOR CAL PARAMS *****/
....................    sprintf(retData+strlen(retData), "%d,", arg1);
06F98:  MOVLW  04
06F9A:  MOVLB  6
06F9C:  MOVWF  x30
06F9E:  MOVLW  40
06FA0:  MOVWF  x2F
06FA2:  MOVLB  0
06FA4:  CALL   50F0
06FA8:  MOVFF  02,03
06FAC:  MOVF   01,W
06FAE:  ADDLW  40
06FB0:  MOVLB  6
06FB2:  MOVWF  x00
06FB4:  MOVLW  04
06FB6:  ADDWFC 02,W
06FB8:  MOVWF  x01
06FBA:  MOVFF  FE8,4E5
06FBE:  MOVFF  600,4E4
06FC2:  MOVFF  5F9,629
06FC6:  MOVLW  18
06FC8:  MOVWF  x2A
06FCA:  MOVLB  0
06FCC:  CALL   56AC
06FD0:  MOVLW  2C
06FD2:  MOVLB  6
06FD4:  MOVWF  x3E
06FD6:  MOVLB  0
06FD8:  CALL   51A0
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c0);
06FDC:  MOVLW  04
06FDE:  MOVLB  6
06FE0:  MOVWF  x30
06FE2:  MOVLW  40
06FE4:  MOVWF  x2F
06FE6:  MOVLB  0
06FE8:  CALL   50F0
06FEC:  MOVFF  02,03
06FF0:  MOVF   01,W
06FF2:  ADDLW  40
06FF4:  MOVLB  6
06FF6:  MOVWF  x00
06FF8:  MOVLW  04
06FFA:  ADDWFC 02,W
06FFC:  MOVWF  x01
06FFE:  MOVLW  01
07000:  MOVLB  5
07002:  SUBWF  xF9,W
07004:  MULLW  18
07006:  MOVF   FF3,W
07008:  MOVLB  6
0700A:  CLRF   x03
0700C:  MOVWF  x02
0700E:  MOVLW  82
07010:  ADDWF  x02,W
07012:  MOVWF  FE9
07014:  MOVLW  00
07016:  ADDWFC x03,W
07018:  MOVWF  FEA
0701A:  MOVFF  FEF,631
0701E:  MOVFF  FEC,632
07022:  MOVFF  FEC,633
07026:  MOVFF  FEC,634
0702A:  MOVFF  601,4E5
0702E:  MOVFF  600,4E4
07032:  MOVLW  89
07034:  MOVWF  FE9
07036:  MOVLW  02
07038:  MOVWF  x35
0703A:  MOVLB  0
0703C:  CALL   5EE8
07040:  MOVLW  2C
07042:  MOVLB  6
07044:  MOVWF  x3E
07046:  MOVLB  0
07048:  CALL   51A0
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c1);
0704C:  MOVLW  04
0704E:  MOVLB  6
07050:  MOVWF  x30
07052:  MOVLW  40
07054:  MOVWF  x2F
07056:  MOVLB  0
07058:  CALL   50F0
0705C:  MOVF   01,W
0705E:  ADDLW  40
07060:  MOVLB  6
07062:  MOVWF  x00
07064:  MOVLW  04
07066:  ADDWFC 02,W
07068:  MOVWF  x01
0706A:  MOVLW  01
0706C:  MOVLB  5
0706E:  SUBWF  xF9,W
07070:  MULLW  18
07072:  MOVF   FF3,W
07074:  MOVLB  6
07076:  CLRF   x03
07078:  MOVWF  x02
0707A:  MOVLW  04
0707C:  ADDWF  x02,W
0707E:  MOVWF  01
07080:  MOVLW  00
07082:  ADDWFC x03,W
07084:  MOVWF  03
07086:  MOVF   01,W
07088:  ADDLW  82
0708A:  MOVWF  FE9
0708C:  MOVLW  00
0708E:  ADDWFC 03,W
07090:  MOVWF  FEA
07092:  MOVFF  FEF,631
07096:  MOVFF  FEC,632
0709A:  MOVFF  FEC,633
0709E:  MOVFF  FEC,634
070A2:  MOVFF  601,4E5
070A6:  MOVFF  600,4E4
070AA:  MOVLW  89
070AC:  MOVWF  FE9
070AE:  MOVLW  02
070B0:  MOVWF  x35
070B2:  MOVLB  0
070B4:  CALL   5EE8
070B8:  MOVLW  2C
070BA:  MOVLB  6
070BC:  MOVWF  x3E
070BE:  MOVLB  0
070C0:  CALL   51A0
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c2);
070C4:  MOVLW  04
070C6:  MOVLB  6
070C8:  MOVWF  x30
070CA:  MOVLW  40
070CC:  MOVWF  x2F
070CE:  MOVLB  0
070D0:  CALL   50F0
070D4:  MOVF   01,W
070D6:  ADDLW  40
070D8:  MOVLB  6
070DA:  MOVWF  x00
070DC:  MOVLW  04
070DE:  ADDWFC 02,W
070E0:  MOVWF  x01
070E2:  MOVLW  01
070E4:  MOVLB  5
070E6:  SUBWF  xF9,W
070E8:  MULLW  18
070EA:  MOVF   FF3,W
070EC:  MOVLB  6
070EE:  CLRF   x03
070F0:  MOVWF  x02
070F2:  MOVLW  08
070F4:  ADDWF  x02,W
070F6:  MOVWF  01
070F8:  MOVLW  00
070FA:  ADDWFC x03,W
070FC:  MOVWF  03
070FE:  MOVF   01,W
07100:  ADDLW  82
07102:  MOVWF  FE9
07104:  MOVLW  00
07106:  ADDWFC 03,W
07108:  MOVWF  FEA
0710A:  MOVFF  FEF,631
0710E:  MOVFF  FEC,632
07112:  MOVFF  FEC,633
07116:  MOVFF  FEC,634
0711A:  MOVFF  601,4E5
0711E:  MOVFF  600,4E4
07122:  MOVLW  89
07124:  MOVWF  FE9
07126:  MOVLW  02
07128:  MOVWF  x35
0712A:  MOVLB  0
0712C:  CALL   5EE8
07130:  MOVLW  2C
07132:  MOVLB  6
07134:  MOVWF  x3E
07136:  MOVLB  0
07138:  CALL   51A0
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c3);
0713C:  MOVLW  04
0713E:  MOVLB  6
07140:  MOVWF  x30
07142:  MOVLW  40
07144:  MOVWF  x2F
07146:  MOVLB  0
07148:  CALL   50F0
0714C:  MOVF   01,W
0714E:  ADDLW  40
07150:  MOVLB  6
07152:  MOVWF  x00
07154:  MOVLW  04
07156:  ADDWFC 02,W
07158:  MOVWF  x01
0715A:  MOVLW  01
0715C:  MOVLB  5
0715E:  SUBWF  xF9,W
07160:  MULLW  18
07162:  MOVF   FF3,W
07164:  MOVLB  6
07166:  CLRF   x03
07168:  MOVWF  x02
0716A:  MOVLW  0C
0716C:  ADDWF  x02,W
0716E:  MOVWF  01
07170:  MOVLW  00
07172:  ADDWFC x03,W
07174:  MOVWF  03
07176:  MOVF   01,W
07178:  ADDLW  82
0717A:  MOVWF  FE9
0717C:  MOVLW  00
0717E:  ADDWFC 03,W
07180:  MOVWF  FEA
07182:  MOVFF  FEF,631
07186:  MOVFF  FEC,632
0718A:  MOVFF  FEC,633
0718E:  MOVFF  FEC,634
07192:  MOVFF  601,4E5
07196:  MOVFF  600,4E4
0719A:  MOVLW  89
0719C:  MOVWF  FE9
0719E:  MOVLW  02
071A0:  MOVWF  x35
071A2:  MOVLB  0
071A4:  CALL   5EE8
071A8:  MOVLW  2C
071AA:  MOVLB  6
071AC:  MOVWF  x3E
071AE:  MOVLB  0
071B0:  CALL   51A0
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c4);
071B4:  MOVLW  04
071B6:  MOVLB  6
071B8:  MOVWF  x30
071BA:  MOVLW  40
071BC:  MOVWF  x2F
071BE:  MOVLB  0
071C0:  CALL   50F0
071C4:  MOVF   01,W
071C6:  ADDLW  40
071C8:  MOVLB  6
071CA:  MOVWF  x00
071CC:  MOVLW  04
071CE:  ADDWFC 02,W
071D0:  MOVWF  x01
071D2:  MOVLW  01
071D4:  MOVLB  5
071D6:  SUBWF  xF9,W
071D8:  MULLW  18
071DA:  MOVF   FF3,W
071DC:  MOVLB  6
071DE:  CLRF   x03
071E0:  MOVWF  x02
071E2:  MOVLW  10
071E4:  ADDWF  x02,W
071E6:  MOVWF  01
071E8:  MOVLW  00
071EA:  ADDWFC x03,W
071EC:  MOVWF  03
071EE:  MOVF   01,W
071F0:  ADDLW  82
071F2:  MOVWF  FE9
071F4:  MOVLW  00
071F6:  ADDWFC 03,W
071F8:  MOVWF  FEA
071FA:  MOVFF  FEF,631
071FE:  MOVFF  FEC,632
07202:  MOVFF  FEC,633
07206:  MOVFF  FEC,634
0720A:  MOVFF  601,4E5
0720E:  MOVFF  600,4E4
07212:  MOVLW  89
07214:  MOVWF  FE9
07216:  MOVLW  02
07218:  MOVWF  x35
0721A:  MOVLB  0
0721C:  CALL   5EE8
07220:  MOVLW  2C
07222:  MOVLB  6
07224:  MOVWF  x3E
07226:  MOVLB  0
07228:  CALL   51A0
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c5);
0722C:  MOVLW  04
0722E:  MOVLB  6
07230:  MOVWF  x30
07232:  MOVLW  40
07234:  MOVWF  x2F
07236:  MOVLB  0
07238:  CALL   50F0
0723C:  MOVF   01,W
0723E:  ADDLW  40
07240:  MOVLB  6
07242:  MOVWF  x00
07244:  MOVLW  04
07246:  ADDWFC 02,W
07248:  MOVWF  x01
0724A:  MOVLW  01
0724C:  MOVLB  5
0724E:  SUBWF  xF9,W
07250:  MULLW  18
07252:  MOVF   FF3,W
07254:  MOVLB  6
07256:  CLRF   x03
07258:  MOVWF  x02
0725A:  MOVLW  14
0725C:  ADDWF  x02,W
0725E:  MOVWF  01
07260:  MOVLW  00
07262:  ADDWFC x03,W
07264:  MOVWF  03
07266:  MOVF   01,W
07268:  ADDLW  82
0726A:  MOVWF  FE9
0726C:  MOVLW  00
0726E:  ADDWFC 03,W
07270:  MOVWF  FEA
07272:  MOVFF  FEF,631
07276:  MOVFF  FEC,632
0727A:  MOVFF  FEC,633
0727E:  MOVFF  FEC,634
07282:  MOVFF  601,4E5
07286:  MOVFF  600,4E4
0728A:  MOVLW  89
0728C:  MOVWF  FE9
0728E:  MOVLW  02
07290:  MOVWF  x35
07292:  MOVLB  0
07294:  CALL   5EE8
07298:  MOVLW  2C
0729A:  MOVLB  6
0729C:  MOVWF  x3E
0729E:  MOVLB  0
072A0:  CALL   51A0
....................    
....................    return SUCCESS;
072A4:  MOVLW  00
072A6:  MOVWF  01
072A8:  RETURN 0
.................... }
.................... 
.................... int8 getSensorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
072AA:  MOVLB  6
072AC:  CLRF   x30
072AE:  MOVFF  5ED,62F
072B2:  CLRF   x32
072B4:  MOVLW  B5
072B6:  MOVWF  x31
072B8:  MOVLB  0
072BA:  CALL   087E
072BE:  MOVFF  02,601
072C2:  MOVFF  01,600
072C6:  MOVLW  06
072C8:  MOVLB  6
072CA:  ADDWF  x00,F
072CC:  MOVLW  00
072CE:  ADDWFC x01,F
072D0:  MOVLW  32
072D2:  ADDWF  x00,W
072D4:  MOVWF  01
072D6:  MOVLW  00
072D8:  ADDWFC x01,W
072DA:  MOVWF  03
072DC:  MOVF   01,W
072DE:  ADDLW  6A
072E0:  MOVWF  01
072E2:  MOVLW  01
072E4:  ADDWFC 03,F
072E6:  MOVFF  01,600
072EA:  MOVFF  03,601
072EE:  MOVFF  03,629
072F2:  MOVFF  01,628
072F6:  MOVLB  0
072F8:  CALL   5268
072FC:  MOVF   01,F
072FE:  BNZ   7308
07300:  MOVLW  02
07302:  MOVWF  01
07304:  BRA    7828
07306:  BRA    7366
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07308:  MOVLB  6
0730A:  CLRF   x30
0730C:  MOVFF  5ED,62F
07310:  CLRF   x32
07312:  MOVLW  B5
07314:  MOVWF  x31
07316:  MOVLB  0
07318:  CALL   087E
0731C:  MOVFF  02,601
07320:  MOVFF  01,600
07324:  MOVLW  06
07326:  MOVLB  6
07328:  ADDWF  x00,F
0732A:  MOVLW  00
0732C:  ADDWFC x01,F
0732E:  MOVLW  32
07330:  ADDWF  x00,W
07332:  MOVWF  01
07334:  MOVLW  00
07336:  ADDWFC x01,W
07338:  MOVWF  03
0733A:  MOVF   01,W
0733C:  ADDLW  6A
0733E:  MOVWF  01
07340:  MOVLW  01
07342:  ADDWFC 03,F
07344:  MOVFF  01,600
07348:  MOVFF  03,601
0734C:  MOVFF  03,629
07350:  MOVFF  01,628
07354:  CLRF   x2B
07356:  CLRF   x2A
07358:  MOVLW  0A
0735A:  MOVWF  x2C
0735C:  MOVLB  0
0735E:  CALL   5358
07362:  MOVFF  01,5F9
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
07366:  MOVLB  6
07368:  CLRF   x30
0736A:  MOVFF  5ED,62F
0736E:  CLRF   x32
07370:  MOVLW  B5
07372:  MOVWF  x31
07374:  MOVLB  0
07376:  CALL   087E
0737A:  MOVFF  02,601
0737E:  MOVFF  01,600
07382:  MOVLW  06
07384:  MOVLB  6
07386:  ADDWF  x00,F
07388:  MOVLW  00
0738A:  ADDWFC x01,F
0738C:  MOVLW  4B
0738E:  ADDWF  x00,W
07390:  MOVWF  01
07392:  MOVLW  00
07394:  ADDWFC x01,W
07396:  MOVWF  03
07398:  MOVF   01,W
0739A:  ADDLW  6A
0739C:  MOVWF  01
0739E:  MOVLW  01
073A0:  ADDWFC 03,F
073A2:  MOVFF  01,600
073A6:  MOVFF  03,601
073AA:  MOVFF  03,630
073AE:  MOVFF  01,62F
073B2:  MOVLB  0
073B4:  CALL   50F0
073B8:  MOVFF  02,03
073BC:  MOVF   01,W
073BE:  SUBLW  01
073C0:  BNZ   73C6
073C2:  MOVF   03,F
073C4:  BZ    73CE
073C6:  MOVLW  02
073C8:  MOVWF  01
073CA:  BRA    7828
073CC:  BRA    740E
....................    else arg2 = SERcmd[rec].p[3][0];
073CE:  MOVLB  6
073D0:  CLRF   x30
073D2:  MOVFF  5ED,62F
073D6:  CLRF   x32
073D8:  MOVLW  B5
073DA:  MOVWF  x31
073DC:  MOVLB  0
073DE:  CALL   087E
073E2:  MOVFF  02,601
073E6:  MOVFF  01,600
073EA:  MOVLW  06
073EC:  MOVLB  6
073EE:  ADDWF  x00,F
073F0:  MOVLW  00
073F2:  ADDWFC x01,F
073F4:  MOVLW  4B
073F6:  ADDWF  x00,F
073F8:  MOVLW  00
073FA:  ADDWFC x01,F
073FC:  MOVLW  6A
073FE:  ADDWF  x00,W
07400:  MOVWF  FE9
07402:  MOVLW  01
07404:  ADDWFC x01,W
07406:  MOVWF  FEA
07408:  MOVFF  FEF,5FA
0740C:  MOVLB  0
....................    
....................    /*** GET SENSOR CAL PARAM **********/
....................    if      ('0' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c0);
0740E:  MOVLB  5
07410:  MOVF   xFA,W
07412:  SUBLW  30
07414:  BNZ   74B6
07416:  MOVLW  04
07418:  MOVLB  6
0741A:  MOVWF  x30
0741C:  MOVLW  40
0741E:  MOVWF  x2F
07420:  MOVLB  0
07422:  CALL   50F0
07426:  MOVFF  02,03
0742A:  MOVF   01,W
0742C:  ADDLW  40
0742E:  MOVLB  6
07430:  MOVWF  x00
07432:  MOVLW  04
07434:  ADDWFC 02,W
07436:  MOVWF  x01
07438:  MOVLW  01
0743A:  MOVLB  5
0743C:  SUBWF  xF9,W
0743E:  MULLW  18
07440:  MOVF   FF3,W
07442:  MOVLB  6
07444:  CLRF   x03
07446:  MOVWF  x02
07448:  MOVLW  82
0744A:  ADDWF  x02,W
0744C:  MOVWF  FE9
0744E:  MOVLW  00
07450:  ADDWFC x03,W
07452:  MOVWF  FEA
07454:  MOVFF  FEF,604
07458:  MOVFF  FEC,605
0745C:  MOVFF  FEC,606
07460:  MOVFF  FEC,607
07464:  MOVFF  601,4E5
07468:  MOVFF  600,4E4
0746C:  MOVFF  5F9,629
07470:  MOVLW  18
07472:  MOVWF  x2A
07474:  MOVLB  0
07476:  CALL   56AC
0747A:  MOVLW  2C
0747C:  MOVLB  6
0747E:  MOVWF  x3E
07480:  MOVLB  0
07482:  CALL   51A0
07486:  MOVLW  89
07488:  MOVWF  FE9
0748A:  MOVFF  607,634
0748E:  MOVFF  606,633
07492:  MOVFF  605,632
07496:  MOVFF  604,631
0749A:  MOVLW  02
0749C:  MOVLB  6
0749E:  MOVWF  x35
074A0:  MOVLB  0
074A2:  CALL   5EE8
074A6:  MOVLW  2C
074A8:  MOVLB  6
074AA:  MOVWF  x3E
074AC:  MOVLB  0
074AE:  CALL   51A0
074B2:  BRA    7824
074B4:  MOVLB  5
....................    else if ('1' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c1);
074B6:  MOVF   xFA,W
074B8:  SUBLW  31
074BA:  BNZ   7564
074BC:  MOVLW  04
074BE:  MOVLB  6
074C0:  MOVWF  x30
074C2:  MOVLW  40
074C4:  MOVWF  x2F
074C6:  MOVLB  0
074C8:  CALL   50F0
074CC:  MOVF   01,W
074CE:  ADDLW  40
074D0:  MOVLB  6
074D2:  MOVWF  x00
074D4:  MOVLW  04
074D6:  ADDWFC 02,W
074D8:  MOVWF  x01
074DA:  MOVLW  01
074DC:  MOVLB  5
074DE:  SUBWF  xF9,W
074E0:  MULLW  18
074E2:  MOVF   FF3,W
074E4:  MOVLB  6
074E6:  CLRF   x03
074E8:  MOVWF  x02
074EA:  MOVLW  04
074EC:  ADDWF  x02,W
074EE:  MOVWF  01
074F0:  MOVLW  00
074F2:  ADDWFC x03,W
074F4:  MOVWF  03
074F6:  MOVF   01,W
074F8:  ADDLW  82
074FA:  MOVWF  FE9
074FC:  MOVLW  00
074FE:  ADDWFC 03,W
07500:  MOVWF  FEA
07502:  MOVFF  FEF,602
07506:  MOVFF  FEC,603
0750A:  MOVFF  FEC,604
0750E:  MOVFF  FEC,605
07512:  MOVFF  601,4E5
07516:  MOVFF  600,4E4
0751A:  MOVFF  5F9,629
0751E:  MOVLW  18
07520:  MOVWF  x2A
07522:  MOVLB  0
07524:  CALL   56AC
07528:  MOVLW  2C
0752A:  MOVLB  6
0752C:  MOVWF  x3E
0752E:  MOVLB  0
07530:  CALL   51A0
07534:  MOVLW  89
07536:  MOVWF  FE9
07538:  MOVFF  605,634
0753C:  MOVFF  604,633
07540:  MOVFF  603,632
07544:  MOVFF  602,631
07548:  MOVLW  02
0754A:  MOVLB  6
0754C:  MOVWF  x35
0754E:  MOVLB  0
07550:  CALL   5EE8
07554:  MOVLW  2C
07556:  MOVLB  6
07558:  MOVWF  x3E
0755A:  MOVLB  0
0755C:  CALL   51A0
07560:  BRA    7824
07562:  MOVLB  5
....................    else if ('2' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c2);
07564:  MOVF   xFA,W
07566:  SUBLW  32
07568:  BNZ   7612
0756A:  MOVLW  04
0756C:  MOVLB  6
0756E:  MOVWF  x30
07570:  MOVLW  40
07572:  MOVWF  x2F
07574:  MOVLB  0
07576:  CALL   50F0
0757A:  MOVF   01,W
0757C:  ADDLW  40
0757E:  MOVLB  6
07580:  MOVWF  x00
07582:  MOVLW  04
07584:  ADDWFC 02,W
07586:  MOVWF  x01
07588:  MOVLW  01
0758A:  MOVLB  5
0758C:  SUBWF  xF9,W
0758E:  MULLW  18
07590:  MOVF   FF3,W
07592:  MOVLB  6
07594:  CLRF   x03
07596:  MOVWF  x02
07598:  MOVLW  08
0759A:  ADDWF  x02,W
0759C:  MOVWF  01
0759E:  MOVLW  00
075A0:  ADDWFC x03,W
075A2:  MOVWF  03
075A4:  MOVF   01,W
075A6:  ADDLW  82
075A8:  MOVWF  FE9
075AA:  MOVLW  00
075AC:  ADDWFC 03,W
075AE:  MOVWF  FEA
075B0:  MOVFF  FEF,602
075B4:  MOVFF  FEC,603
075B8:  MOVFF  FEC,604
075BC:  MOVFF  FEC,605
075C0:  MOVFF  601,4E5
075C4:  MOVFF  600,4E4
075C8:  MOVFF  5F9,629
075CC:  MOVLW  18
075CE:  MOVWF  x2A
075D0:  MOVLB  0
075D2:  CALL   56AC
075D6:  MOVLW  2C
075D8:  MOVLB  6
075DA:  MOVWF  x3E
075DC:  MOVLB  0
075DE:  CALL   51A0
075E2:  MOVLW  89
075E4:  MOVWF  FE9
075E6:  MOVFF  605,634
075EA:  MOVFF  604,633
075EE:  MOVFF  603,632
075F2:  MOVFF  602,631
075F6:  MOVLW  02
075F8:  MOVLB  6
075FA:  MOVWF  x35
075FC:  MOVLB  0
075FE:  CALL   5EE8
07602:  MOVLW  2C
07604:  MOVLB  6
07606:  MOVWF  x3E
07608:  MOVLB  0
0760A:  CALL   51A0
0760E:  BRA    7824
07610:  MOVLB  5
....................    else if ('3' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c3);
07612:  MOVF   xFA,W
07614:  SUBLW  33
07616:  BNZ   76C0
07618:  MOVLW  04
0761A:  MOVLB  6
0761C:  MOVWF  x30
0761E:  MOVLW  40
07620:  MOVWF  x2F
07622:  MOVLB  0
07624:  CALL   50F0
07628:  MOVF   01,W
0762A:  ADDLW  40
0762C:  MOVLB  6
0762E:  MOVWF  x00
07630:  MOVLW  04
07632:  ADDWFC 02,W
07634:  MOVWF  x01
07636:  MOVLW  01
07638:  MOVLB  5
0763A:  SUBWF  xF9,W
0763C:  MULLW  18
0763E:  MOVF   FF3,W
07640:  MOVLB  6
07642:  CLRF   x03
07644:  MOVWF  x02
07646:  MOVLW  0C
07648:  ADDWF  x02,W
0764A:  MOVWF  01
0764C:  MOVLW  00
0764E:  ADDWFC x03,W
07650:  MOVWF  03
07652:  MOVF   01,W
07654:  ADDLW  82
07656:  MOVWF  FE9
07658:  MOVLW  00
0765A:  ADDWFC 03,W
0765C:  MOVWF  FEA
0765E:  MOVFF  FEF,602
07662:  MOVFF  FEC,603
07666:  MOVFF  FEC,604
0766A:  MOVFF  FEC,605
0766E:  MOVFF  601,4E5
07672:  MOVFF  600,4E4
07676:  MOVFF  5F9,629
0767A:  MOVLW  18
0767C:  MOVWF  x2A
0767E:  MOVLB  0
07680:  CALL   56AC
07684:  MOVLW  2C
07686:  MOVLB  6
07688:  MOVWF  x3E
0768A:  MOVLB  0
0768C:  CALL   51A0
07690:  MOVLW  89
07692:  MOVWF  FE9
07694:  MOVFF  605,634
07698:  MOVFF  604,633
0769C:  MOVFF  603,632
076A0:  MOVFF  602,631
076A4:  MOVLW  02
076A6:  MOVLB  6
076A8:  MOVWF  x35
076AA:  MOVLB  0
076AC:  CALL   5EE8
076B0:  MOVLW  2C
076B2:  MOVLB  6
076B4:  MOVWF  x3E
076B6:  MOVLB  0
076B8:  CALL   51A0
076BC:  BRA    7824
076BE:  MOVLB  5
....................    else if ('4' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c4);
076C0:  MOVF   xFA,W
076C2:  SUBLW  34
076C4:  BNZ   776E
076C6:  MOVLW  04
076C8:  MOVLB  6
076CA:  MOVWF  x30
076CC:  MOVLW  40
076CE:  MOVWF  x2F
076D0:  MOVLB  0
076D2:  CALL   50F0
076D6:  MOVF   01,W
076D8:  ADDLW  40
076DA:  MOVLB  6
076DC:  MOVWF  x00
076DE:  MOVLW  04
076E0:  ADDWFC 02,W
076E2:  MOVWF  x01
076E4:  MOVLW  01
076E6:  MOVLB  5
076E8:  SUBWF  xF9,W
076EA:  MULLW  18
076EC:  MOVF   FF3,W
076EE:  MOVLB  6
076F0:  CLRF   x03
076F2:  MOVWF  x02
076F4:  MOVLW  10
076F6:  ADDWF  x02,W
076F8:  MOVWF  01
076FA:  MOVLW  00
076FC:  ADDWFC x03,W
076FE:  MOVWF  03
07700:  MOVF   01,W
07702:  ADDLW  82
07704:  MOVWF  FE9
07706:  MOVLW  00
07708:  ADDWFC 03,W
0770A:  MOVWF  FEA
0770C:  MOVFF  FEF,602
07710:  MOVFF  FEC,603
07714:  MOVFF  FEC,604
07718:  MOVFF  FEC,605
0771C:  MOVFF  601,4E5
07720:  MOVFF  600,4E4
07724:  MOVFF  5F9,629
07728:  MOVLW  18
0772A:  MOVWF  x2A
0772C:  MOVLB  0
0772E:  CALL   56AC
07732:  MOVLW  2C
07734:  MOVLB  6
07736:  MOVWF  x3E
07738:  MOVLB  0
0773A:  CALL   51A0
0773E:  MOVLW  89
07740:  MOVWF  FE9
07742:  MOVFF  605,634
07746:  MOVFF  604,633
0774A:  MOVFF  603,632
0774E:  MOVFF  602,631
07752:  MOVLW  02
07754:  MOVLB  6
07756:  MOVWF  x35
07758:  MOVLB  0
0775A:  CALL   5EE8
0775E:  MOVLW  2C
07760:  MOVLB  6
07762:  MOVWF  x3E
07764:  MOVLB  0
07766:  CALL   51A0
0776A:  BRA    7824
0776C:  MOVLB  5
....................    else if ('5' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c5);
0776E:  MOVF   xFA,W
07770:  SUBLW  35
07772:  BNZ   781C
07774:  MOVLW  04
07776:  MOVLB  6
07778:  MOVWF  x30
0777A:  MOVLW  40
0777C:  MOVWF  x2F
0777E:  MOVLB  0
07780:  CALL   50F0
07784:  MOVF   01,W
07786:  ADDLW  40
07788:  MOVLB  6
0778A:  MOVWF  x00
0778C:  MOVLW  04
0778E:  ADDWFC 02,W
07790:  MOVWF  x01
07792:  MOVLW  01
07794:  MOVLB  5
07796:  SUBWF  xF9,W
07798:  MULLW  18
0779A:  MOVF   FF3,W
0779C:  MOVLB  6
0779E:  CLRF   x03
077A0:  MOVWF  x02
077A2:  MOVLW  14
077A4:  ADDWF  x02,W
077A6:  MOVWF  01
077A8:  MOVLW  00
077AA:  ADDWFC x03,W
077AC:  MOVWF  03
077AE:  MOVF   01,W
077B0:  ADDLW  82
077B2:  MOVWF  FE9
077B4:  MOVLW  00
077B6:  ADDWFC 03,W
077B8:  MOVWF  FEA
077BA:  MOVFF  FEF,602
077BE:  MOVFF  FEC,603
077C2:  MOVFF  FEC,604
077C6:  MOVFF  FEC,605
077CA:  MOVFF  601,4E5
077CE:  MOVFF  600,4E4
077D2:  MOVFF  5F9,629
077D6:  MOVLW  18
077D8:  MOVWF  x2A
077DA:  MOVLB  0
077DC:  CALL   56AC
077E0:  MOVLW  2C
077E2:  MOVLB  6
077E4:  MOVWF  x3E
077E6:  MOVLB  0
077E8:  CALL   51A0
077EC:  MOVLW  89
077EE:  MOVWF  FE9
077F0:  MOVFF  605,634
077F4:  MOVFF  604,633
077F8:  MOVFF  603,632
077FC:  MOVFF  602,631
07800:  MOVLW  02
07802:  MOVLB  6
07804:  MOVWF  x35
07806:  MOVLB  0
07808:  CALL   5EE8
0780C:  MOVLW  2C
0780E:  MOVLB  6
07810:  MOVWF  x3E
07812:  MOVLB  0
07814:  CALL   51A0
07818:  BRA    7824
0781A:  MOVLB  5
....................    else return INV_PARAM;
0781C:  MOVLW  02
0781E:  MOVWF  01
07820:  MOVLB  0
07822:  BRA    7828
....................    
....................    return SUCCESS;
07824:  MOVLW  00
07826:  MOVWF  01
07828:  RETURN 0
.................... }
.................... 
.................... int8 setSensorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char  arg2;
....................    float arg3;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0782A:  MOVLB  6
0782C:  CLRF   x30
0782E:  MOVFF  5ED,62F
07832:  CLRF   x32
07834:  MOVLW  B5
07836:  MOVWF  x31
07838:  MOVLB  0
0783A:  CALL   087E
0783E:  MOVFF  02,600
07842:  MOVFF  01,5FF
07846:  MOVLW  06
07848:  MOVLB  5
0784A:  ADDWF  xFF,F
0784C:  MOVLW  00
0784E:  MOVLB  6
07850:  ADDWFC x00,F
07852:  MOVLW  32
07854:  MOVLB  5
07856:  ADDWF  xFF,W
07858:  MOVWF  01
0785A:  MOVLW  00
0785C:  MOVLB  6
0785E:  ADDWFC x00,W
07860:  MOVWF  03
07862:  MOVF   01,W
07864:  ADDLW  6A
07866:  MOVWF  01
07868:  MOVLW  01
0786A:  ADDWFC 03,F
0786C:  MOVFF  01,5FF
07870:  MOVFF  03,600
07874:  MOVFF  03,629
07878:  MOVFF  01,628
0787C:  MOVLB  0
0787E:  CALL   5268
07882:  MOVF   01,F
07884:  BNZ   788E
07886:  MOVLW  02
07888:  MOVWF  01
0788A:  BRA    7C1C
0788C:  BRA    78F4
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
0788E:  MOVLB  6
07890:  CLRF   x30
07892:  MOVFF  5ED,62F
07896:  CLRF   x32
07898:  MOVLW  B5
0789A:  MOVWF  x31
0789C:  MOVLB  0
0789E:  CALL   087E
078A2:  MOVFF  02,600
078A6:  MOVFF  01,5FF
078AA:  MOVLW  06
078AC:  MOVLB  5
078AE:  ADDWF  xFF,F
078B0:  MOVLW  00
078B2:  MOVLB  6
078B4:  ADDWFC x00,F
078B6:  MOVLW  32
078B8:  MOVLB  5
078BA:  ADDWF  xFF,W
078BC:  MOVWF  01
078BE:  MOVLW  00
078C0:  MOVLB  6
078C2:  ADDWFC x00,W
078C4:  MOVWF  03
078C6:  MOVF   01,W
078C8:  ADDLW  6A
078CA:  MOVWF  01
078CC:  MOVLW  01
078CE:  ADDWFC 03,F
078D0:  MOVFF  01,5FF
078D4:  MOVFF  03,600
078D8:  MOVFF  03,629
078DC:  MOVFF  01,628
078E0:  MOVLB  6
078E2:  CLRF   x2B
078E4:  CLRF   x2A
078E6:  MOVLW  0A
078E8:  MOVWF  x2C
078EA:  MOVLB  0
078EC:  CALL   5358
078F0:  MOVFF  01,5F9
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
078F4:  MOVLB  6
078F6:  CLRF   x30
078F8:  MOVFF  5ED,62F
078FC:  CLRF   x32
078FE:  MOVLW  B5
07900:  MOVWF  x31
07902:  MOVLB  0
07904:  CALL   087E
07908:  MOVFF  02,600
0790C:  MOVFF  01,5FF
07910:  MOVLW  06
07912:  MOVLB  5
07914:  ADDWF  xFF,F
07916:  MOVLW  00
07918:  MOVLB  6
0791A:  ADDWFC x00,F
0791C:  MOVLW  4B
0791E:  MOVLB  5
07920:  ADDWF  xFF,W
07922:  MOVWF  01
07924:  MOVLW  00
07926:  MOVLB  6
07928:  ADDWFC x00,W
0792A:  MOVWF  03
0792C:  MOVF   01,W
0792E:  ADDLW  6A
07930:  MOVWF  01
07932:  MOVLW  01
07934:  ADDWFC 03,F
07936:  MOVFF  01,5FF
0793A:  MOVFF  03,600
0793E:  MOVFF  03,630
07942:  MOVFF  01,62F
07946:  MOVLB  0
07948:  CALL   50F0
0794C:  MOVFF  02,03
07950:  MOVF   01,W
07952:  SUBLW  01
07954:  BNZ   795A
07956:  MOVF   03,F
07958:  BZ    7962
0795A:  MOVLW  02
0795C:  MOVWF  01
0795E:  BRA    7C1C
07960:  BRA    79AC
....................    else arg2 = SERcmd[rec].p[3][0];
07962:  MOVLB  6
07964:  CLRF   x30
07966:  MOVFF  5ED,62F
0796A:  CLRF   x32
0796C:  MOVLW  B5
0796E:  MOVWF  x31
07970:  MOVLB  0
07972:  CALL   087E
07976:  MOVFF  02,600
0797A:  MOVFF  01,5FF
0797E:  MOVLW  06
07980:  MOVLB  5
07982:  ADDWF  xFF,F
07984:  MOVLW  00
07986:  MOVLB  6
07988:  ADDWFC x00,F
0798A:  MOVLW  4B
0798C:  MOVLB  5
0798E:  ADDWF  xFF,F
07990:  MOVLW  00
07992:  MOVLB  6
07994:  ADDWFC x00,F
07996:  MOVLW  6A
07998:  MOVLB  5
0799A:  ADDWF  xFF,W
0799C:  MOVWF  FE9
0799E:  MOVLW  01
079A0:  MOVLB  6
079A2:  ADDWFC x00,W
079A4:  MOVWF  FEA
079A6:  MOVFF  FEF,5FA
079AA:  MOVLB  0
....................    
....................    if (!arg_is_float(SERcmd[rec].p[4])) return INV_PARAM;
079AC:  MOVLB  6
079AE:  CLRF   x30
079B0:  MOVFF  5ED,62F
079B4:  CLRF   x32
079B6:  MOVLW  B5
079B8:  MOVWF  x31
079BA:  MOVLB  0
079BC:  CALL   087E
079C0:  MOVFF  02,600
079C4:  MOVFF  01,5FF
079C8:  MOVLW  06
079CA:  MOVLB  5
079CC:  ADDWF  xFF,F
079CE:  MOVLW  00
079D0:  MOVLB  6
079D2:  ADDWFC x00,F
079D4:  MOVLW  64
079D6:  MOVLB  5
079D8:  ADDWF  xFF,W
079DA:  MOVWF  01
079DC:  MOVLW  00
079DE:  MOVLB  6
079E0:  ADDWFC x00,W
079E2:  MOVWF  03
079E4:  MOVF   01,W
079E6:  ADDLW  6A
079E8:  MOVWF  01
079EA:  MOVLW  01
079EC:  ADDWFC 03,F
079EE:  MOVFF  01,5FF
079F2:  MOVFF  03,600
079F6:  MOVFF  03,603
079FA:  MOVFF  01,602
079FE:  MOVLB  0
07A00:  CALL   6574
07A04:  MOVF   01,F
07A06:  BNZ   7A10
07A08:  MOVLW  02
07A0A:  MOVWF  01
07A0C:  BRA    7C1C
07A0E:  BRA    7A7E
....................    else arg3 = strtod(SERcmd[rec].p[4], '\0');
07A10:  MOVLB  6
07A12:  CLRF   x30
07A14:  MOVFF  5ED,62F
07A18:  CLRF   x32
07A1A:  MOVLW  B5
07A1C:  MOVWF  x31
07A1E:  MOVLB  0
07A20:  CALL   087E
07A24:  MOVFF  02,600
07A28:  MOVFF  01,5FF
07A2C:  MOVLW  06
07A2E:  MOVLB  5
07A30:  ADDWF  xFF,F
07A32:  MOVLW  00
07A34:  MOVLB  6
07A36:  ADDWFC x00,F
07A38:  MOVLW  64
07A3A:  MOVLB  5
07A3C:  ADDWF  xFF,W
07A3E:  MOVWF  01
07A40:  MOVLW  00
07A42:  MOVLB  6
07A44:  ADDWFC x00,W
07A46:  MOVWF  03
07A48:  MOVF   01,W
07A4A:  ADDLW  6A
07A4C:  MOVWF  01
07A4E:  MOVLW  01
07A50:  ADDWFC 03,F
07A52:  MOVFF  01,5FF
07A56:  MOVFF  03,600
07A5A:  MOVFF  03,603
07A5E:  MOVFF  01,602
07A62:  MOVLB  6
07A64:  CLRF   x05
07A66:  CLRF   x04
07A68:  MOVLB  0
07A6A:  CALL   6636
07A6E:  MOVFF  03,5FE
07A72:  MOVFF  02,5FD
07A76:  MOVFF  01,5FC
07A7A:  MOVFF  00,5FB
....................    
....................    /*** SET SENSOR CAL PARAM **********/
....................    if      ('0' == arg2) sensorCal[arg1-1].c0 = arg3;
07A7E:  MOVLB  5
07A80:  MOVF   xFA,W
07A82:  SUBLW  30
07A84:  BNZ   7AB8
07A86:  MOVLW  01
07A88:  SUBWF  xF9,W
07A8A:  MULLW  18
07A8C:  MOVF   FF3,W
07A8E:  MOVLB  6
07A90:  CLRF   x00
07A92:  MOVLB  5
07A94:  MOVWF  xFF
07A96:  MOVLW  82
07A98:  ADDWF  xFF,W
07A9A:  MOVWF  FE9
07A9C:  MOVLW  00
07A9E:  MOVLB  6
07AA0:  ADDWFC x00,W
07AA2:  MOVWF  FEA
07AA4:  MOVFF  5FB,FEF
07AA8:  MOVFF  5FC,FEC
07AAC:  MOVFF  5FD,FEC
07AB0:  MOVFF  5FE,FEC
07AB4:  BRA    7C16
07AB6:  MOVLB  5
....................    else if ('1' == arg2) sensorCal[arg1-1].c1 = arg3;
07AB8:  MOVF   xFA,W
07ABA:  SUBLW  31
07ABC:  BNZ   7AFC
07ABE:  MOVLW  01
07AC0:  SUBWF  xF9,W
07AC2:  MULLW  18
07AC4:  MOVF   FF3,W
07AC6:  MOVLB  6
07AC8:  CLRF   x00
07ACA:  MOVLB  5
07ACC:  MOVWF  xFF
07ACE:  MOVLW  04
07AD0:  ADDWF  xFF,W
07AD2:  MOVWF  01
07AD4:  MOVLW  00
07AD6:  MOVLB  6
07AD8:  ADDWFC x00,W
07ADA:  MOVWF  03
07ADC:  MOVF   01,W
07ADE:  ADDLW  82
07AE0:  MOVWF  FE9
07AE2:  MOVLW  00
07AE4:  ADDWFC 03,W
07AE6:  MOVWF  FEA
07AE8:  MOVFF  5FB,FEF
07AEC:  MOVFF  5FC,FEC
07AF0:  MOVFF  5FD,FEC
07AF4:  MOVFF  5FE,FEC
07AF8:  BRA    7C16
07AFA:  MOVLB  5
....................    else if ('2' == arg2) sensorCal[arg1-1].c2 = arg3;
07AFC:  MOVF   xFA,W
07AFE:  SUBLW  32
07B00:  BNZ   7B40
07B02:  MOVLW  01
07B04:  SUBWF  xF9,W
07B06:  MULLW  18
07B08:  MOVF   FF3,W
07B0A:  MOVLB  6
07B0C:  CLRF   x00
07B0E:  MOVLB  5
07B10:  MOVWF  xFF
07B12:  MOVLW  08
07B14:  ADDWF  xFF,W
07B16:  MOVWF  01
07B18:  MOVLW  00
07B1A:  MOVLB  6
07B1C:  ADDWFC x00,W
07B1E:  MOVWF  03
07B20:  MOVF   01,W
07B22:  ADDLW  82
07B24:  MOVWF  FE9
07B26:  MOVLW  00
07B28:  ADDWFC 03,W
07B2A:  MOVWF  FEA
07B2C:  MOVFF  5FB,FEF
07B30:  MOVFF  5FC,FEC
07B34:  MOVFF  5FD,FEC
07B38:  MOVFF  5FE,FEC
07B3C:  BRA    7C16
07B3E:  MOVLB  5
....................    else if ('3' == arg2) sensorCal[arg1-1].c3 = arg3;
07B40:  MOVF   xFA,W
07B42:  SUBLW  33
07B44:  BNZ   7B84
07B46:  MOVLW  01
07B48:  SUBWF  xF9,W
07B4A:  MULLW  18
07B4C:  MOVF   FF3,W
07B4E:  MOVLB  6
07B50:  CLRF   x00
07B52:  MOVLB  5
07B54:  MOVWF  xFF
07B56:  MOVLW  0C
07B58:  ADDWF  xFF,W
07B5A:  MOVWF  01
07B5C:  MOVLW  00
07B5E:  MOVLB  6
07B60:  ADDWFC x00,W
07B62:  MOVWF  03
07B64:  MOVF   01,W
07B66:  ADDLW  82
07B68:  MOVWF  FE9
07B6A:  MOVLW  00
07B6C:  ADDWFC 03,W
07B6E:  MOVWF  FEA
07B70:  MOVFF  5FB,FEF
07B74:  MOVFF  5FC,FEC
07B78:  MOVFF  5FD,FEC
07B7C:  MOVFF  5FE,FEC
07B80:  BRA    7C16
07B82:  MOVLB  5
....................    else if ('4' == arg2) sensorCal[arg1-1].c4 = arg3;
07B84:  MOVF   xFA,W
07B86:  SUBLW  34
07B88:  BNZ   7BC8
07B8A:  MOVLW  01
07B8C:  SUBWF  xF9,W
07B8E:  MULLW  18
07B90:  MOVF   FF3,W
07B92:  MOVLB  6
07B94:  CLRF   x00
07B96:  MOVLB  5
07B98:  MOVWF  xFF
07B9A:  MOVLW  10
07B9C:  ADDWF  xFF,W
07B9E:  MOVWF  01
07BA0:  MOVLW  00
07BA2:  MOVLB  6
07BA4:  ADDWFC x00,W
07BA6:  MOVWF  03
07BA8:  MOVF   01,W
07BAA:  ADDLW  82
07BAC:  MOVWF  FE9
07BAE:  MOVLW  00
07BB0:  ADDWFC 03,W
07BB2:  MOVWF  FEA
07BB4:  MOVFF  5FB,FEF
07BB8:  MOVFF  5FC,FEC
07BBC:  MOVFF  5FD,FEC
07BC0:  MOVFF  5FE,FEC
07BC4:  BRA    7C16
07BC6:  MOVLB  5
....................    else if ('5' == arg2) sensorCal[arg1-1].c5 = arg3;
07BC8:  MOVF   xFA,W
07BCA:  SUBLW  35
07BCC:  BNZ   7C0C
07BCE:  MOVLW  01
07BD0:  SUBWF  xF9,W
07BD2:  MULLW  18
07BD4:  MOVF   FF3,W
07BD6:  MOVLB  6
07BD8:  CLRF   x00
07BDA:  MOVLB  5
07BDC:  MOVWF  xFF
07BDE:  MOVLW  14
07BE0:  ADDWF  xFF,W
07BE2:  MOVWF  01
07BE4:  MOVLW  00
07BE6:  MOVLB  6
07BE8:  ADDWFC x00,W
07BEA:  MOVWF  03
07BEC:  MOVF   01,W
07BEE:  ADDLW  82
07BF0:  MOVWF  FE9
07BF2:  MOVLW  00
07BF4:  ADDWFC 03,W
07BF6:  MOVWF  FEA
07BF8:  MOVFF  5FB,FEF
07BFC:  MOVFF  5FC,FEC
07C00:  MOVFF  5FD,FEC
07C04:  MOVFF  5FE,FEC
07C08:  BRA    7C16
07C0A:  MOVLB  5
....................    else return INV_PARAM;
07C0C:  MOVLW  02
07C0E:  MOVWF  01
07C10:  MOVLB  0
07C12:  BRA    7C1C
07C14:  MOVLB  6
....................    
....................    return SUCCESS;
07C16:  MOVLW  00
07C18:  MOVWF  01
07C1A:  MOVLB  0
07C1C:  RETURN 0
.................... }
.................... 
.................... int8 getMonitorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    char *arg1;
....................    char *s_N15 = "N15";
07C1E:  MOVLW  4E
07C20:  MOVLB  5
07C22:  MOVWF  xFD
07C24:  MOVLW  31
07C26:  MOVWF  xFE
07C28:  MOVLW  35
07C2A:  MOVWF  xFF
07C2C:  MOVLB  6
07C2E:  CLRF   x00
07C30:  MOVLW  05
07C32:  MOVLB  5
07C34:  MOVWF  xFC
07C36:  MOVLW  FD
07C38:  MOVWF  xFB
....................    char *s_200 = "200";
07C3A:  MOVLW  32
07C3C:  MOVLB  6
07C3E:  MOVWF  x03
07C40:  MOVLW  30
07C42:  MOVWF  x04
07C44:  MOVWF  x05
07C46:  CLRF   x06
07C48:  MOVLW  06
07C4A:  MOVWF  x02
07C4C:  MOVLW  03
07C4E:  MOVWF  x01
....................    char *s_5V6 = "5V6";
07C50:  MOVLW  35
07C52:  MOVWF  x09
07C54:  MOVLW  56
07C56:  MOVWF  x0A
07C58:  MOVLW  36
07C5A:  MOVWF  x0B
07C5C:  CLRF   x0C
07C5E:  MOVLW  06
07C60:  MOVWF  x08
07C62:  MOVLW  09
07C64:  MOVWF  x07
....................    char *s_5VA = "5VA";
07C66:  MOVLW  35
07C68:  MOVWF  x0F
07C6A:  MOVLW  56
07C6C:  MOVWF  x10
07C6E:  MOVLW  41
07C70:  MOVWF  x11
07C72:  CLRF   x12
07C74:  MOVLW  06
07C76:  MOVWF  x0E
07C78:  MOVLW  0F
07C7A:  MOVWF  x0D
....................    char *s_3V6X = "3V6X";
07C7C:  MOVLW  33
07C7E:  MOVWF  x15
07C80:  MOVLW  56
07C82:  MOVWF  x16
07C84:  MOVLW  36
07C86:  MOVWF  x17
07C88:  MOVLW  58
07C8A:  MOVWF  x18
07C8C:  CLRF   x19
07C8E:  MOVLW  06
07C90:  MOVWF  x14
07C92:  MOVLW  15
07C94:  MOVWF  x13
....................    char *s_3V3A = "3V3A";
07C96:  MOVLW  33
07C98:  MOVWF  x1C
07C9A:  MOVLW  56
07C9C:  MOVWF  x1D
07C9E:  MOVLW  33
07CA0:  MOVWF  x1E
07CA2:  MOVLW  41
07CA4:  MOVWF  x1F
07CA6:  CLRF   x20
07CA8:  MOVLW  06
07CAA:  MOVWF  x1B
07CAC:  MOVLW  1C
07CAE:  MOVWF  x1A
....................    char *s_3V3D = "3V3D";
07CB0:  MOVLW  33
07CB2:  MOVWF  x23
07CB4:  MOVLW  56
07CB6:  MOVWF  x24
07CB8:  MOVLW  33
07CBA:  MOVWF  x25
07CBC:  MOVLW  44
07CBE:  MOVWF  x26
07CC0:  CLRF   x27
07CC2:  MOVLW  06
07CC4:  MOVWF  x22
07CC6:  MOVLW  23
07CC8:  MOVWF  x21
.................... //!   char *s_all = "all";
....................    
....................    arg1 = SERcmd[rec].p[2];
07CCA:  CLRF   x30
07CCC:  MOVFF  5ED,62F
07CD0:  CLRF   x32
07CD2:  MOVLW  B5
07CD4:  MOVWF  x31
07CD6:  MOVLB  0
07CD8:  CALL   087E
07CDC:  MOVFF  02,629
07CE0:  MOVFF  01,628
07CE4:  MOVLW  06
07CE6:  MOVLB  6
07CE8:  ADDWF  x28,F
07CEA:  MOVLW  00
07CEC:  ADDWFC x29,F
07CEE:  MOVLW  32
07CF0:  ADDWF  x28,W
07CF2:  MOVWF  01
07CF4:  MOVLW  00
07CF6:  ADDWFC x29,W
07CF8:  MOVWF  03
07CFA:  MOVF   01,W
07CFC:  ADDLW  6A
07CFE:  MOVWF  01
07D00:  MOVLW  01
07D02:  ADDWFC 03,F
07D04:  MOVFF  01,5F9
07D08:  MOVLB  5
07D0A:  MOVFF  03,5FA
....................    
....................    /*** GET MONITOR VALUES ************/
....................    if      (0 == strcmp(s_N15, arg1)) {
07D0E:  MOVFF  5FC,630
07D12:  MOVFF  5FB,62F
07D16:  MOVFF  5FA,632
07D1A:  MOVFF  5F9,631
07D1E:  MOVLB  0
07D20:  CALL   5128
07D24:  MOVF   01,F
07D26:  BNZ   7DAA
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.vN15[0],monCal.vN15[1]);
07D28:  MOVLW  04
07D2A:  MOVLB  6
07D2C:  MOVWF  x30
07D2E:  MOVLW  40
07D30:  MOVWF  x2F
07D32:  MOVLB  0
07D34:  CALL   50F0
07D38:  MOVFF  02,03
07D3C:  MOVF   01,W
07D3E:  ADDLW  40
07D40:  MOVLB  6
07D42:  MOVWF  x28
07D44:  MOVLW  04
07D46:  ADDWFC 02,W
07D48:  MOVWF  x29
07D4A:  MOVFF  FE8,4E5
07D4E:  MOVFF  628,4E4
07D52:  MOVLW  89
07D54:  MOVWF  FE9
07D56:  MOVFF  B5,634
07D5A:  MOVFF  B4,633
07D5E:  MOVFF  B3,632
07D62:  MOVFF  B2,631
07D66:  MOVLW  02
07D68:  MOVWF  x35
07D6A:  MOVLB  0
07D6C:  CALL   5EE8
07D70:  MOVLW  2C
07D72:  MOVLB  6
07D74:  MOVWF  x3E
07D76:  MOVLB  0
07D78:  CALL   51A0
07D7C:  MOVLW  89
07D7E:  MOVWF  FE9
07D80:  MOVFF  B9,634
07D84:  MOVFF  B8,633
07D88:  MOVFF  B7,632
07D8C:  MOVFF  B6,631
07D90:  MOVLW  02
07D92:  MOVLB  6
07D94:  MOVWF  x35
07D96:  MOVLB  0
07D98:  CALL   5EE8
07D9C:  MOVLW  2C
07D9E:  MOVLB  6
07DA0:  MOVWF  x3E
07DA2:  MOVLB  0
07DA4:  CALL   51A0
....................    }
07DA8:  BRA    814C
....................    else if (0 == strcmp(s_200, arg1)) {
07DAA:  MOVFF  602,630
07DAE:  MOVFF  601,62F
07DB2:  MOVFF  5FA,632
07DB6:  MOVFF  5F9,631
07DBA:  CALL   5128
07DBE:  MOVF   01,F
07DC0:  BNZ   7E44
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v200[0],monCal.v200[1]);
07DC2:  MOVLW  04
07DC4:  MOVLB  6
07DC6:  MOVWF  x30
07DC8:  MOVLW  40
07DCA:  MOVWF  x2F
07DCC:  MOVLB  0
07DCE:  CALL   50F0
07DD2:  MOVFF  02,03
07DD6:  MOVF   01,W
07DD8:  ADDLW  40
07DDA:  MOVLB  6
07DDC:  MOVWF  x28
07DDE:  MOVLW  04
07DE0:  ADDWFC 02,W
07DE2:  MOVWF  x29
07DE4:  MOVFF  FE8,4E5
07DE8:  MOVFF  628,4E4
07DEC:  MOVLW  89
07DEE:  MOVWF  FE9
07DF0:  MOVFF  BD,634
07DF4:  MOVFF  BC,633
07DF8:  MOVFF  BB,632
07DFC:  MOVFF  BA,631
07E00:  MOVLW  02
07E02:  MOVWF  x35
07E04:  MOVLB  0
07E06:  CALL   5EE8
07E0A:  MOVLW  2C
07E0C:  MOVLB  6
07E0E:  MOVWF  x3E
07E10:  MOVLB  0
07E12:  CALL   51A0
07E16:  MOVLW  89
07E18:  MOVWF  FE9
07E1A:  MOVFF  C1,634
07E1E:  MOVFF  C0,633
07E22:  MOVFF  BF,632
07E26:  MOVFF  BE,631
07E2A:  MOVLW  02
07E2C:  MOVLB  6
07E2E:  MOVWF  x35
07E30:  MOVLB  0
07E32:  CALL   5EE8
07E36:  MOVLW  2C
07E38:  MOVLB  6
07E3A:  MOVWF  x3E
07E3C:  MOVLB  0
07E3E:  CALL   51A0
....................    }
07E42:  BRA    814C
....................    else if (0 == strcmp(s_5V6, arg1)) {
07E44:  MOVFF  608,630
07E48:  MOVFF  607,62F
07E4C:  MOVFF  5FA,632
07E50:  MOVFF  5F9,631
07E54:  CALL   5128
07E58:  MOVF   01,F
07E5A:  BNZ   7EDE
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v5V6[0],monCal.v5V6[1]);
07E5C:  MOVLW  04
07E5E:  MOVLB  6
07E60:  MOVWF  x30
07E62:  MOVLW  40
07E64:  MOVWF  x2F
07E66:  MOVLB  0
07E68:  CALL   50F0
07E6C:  MOVFF  02,03
07E70:  MOVF   01,W
07E72:  ADDLW  40
07E74:  MOVLB  6
07E76:  MOVWF  x28
07E78:  MOVLW  04
07E7A:  ADDWFC 02,W
07E7C:  MOVWF  x29
07E7E:  MOVFF  FE8,4E5
07E82:  MOVFF  628,4E4
07E86:  MOVLW  89
07E88:  MOVWF  FE9
07E8A:  MOVFF  C5,634
07E8E:  MOVFF  C4,633
07E92:  MOVFF  C3,632
07E96:  MOVFF  C2,631
07E9A:  MOVLW  02
07E9C:  MOVWF  x35
07E9E:  MOVLB  0
07EA0:  CALL   5EE8
07EA4:  MOVLW  2C
07EA6:  MOVLB  6
07EA8:  MOVWF  x3E
07EAA:  MOVLB  0
07EAC:  CALL   51A0
07EB0:  MOVLW  89
07EB2:  MOVWF  FE9
07EB4:  MOVFF  C9,634
07EB8:  MOVFF  C8,633
07EBC:  MOVFF  C7,632
07EC0:  MOVFF  C6,631
07EC4:  MOVLW  02
07EC6:  MOVLB  6
07EC8:  MOVWF  x35
07ECA:  MOVLB  0
07ECC:  CALL   5EE8
07ED0:  MOVLW  2C
07ED2:  MOVLB  6
07ED4:  MOVWF  x3E
07ED6:  MOVLB  0
07ED8:  CALL   51A0
....................    }
07EDC:  BRA    814C
....................    else if (0 == strcmp(s_5VA, arg1)) {
07EDE:  MOVFF  60E,630
07EE2:  MOVFF  60D,62F
07EE6:  MOVFF  5FA,632
07EEA:  MOVFF  5F9,631
07EEE:  CALL   5128
07EF2:  MOVF   01,F
07EF4:  BNZ   7F78
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v5VA[0],monCal.v5VA[1]);
07EF6:  MOVLW  04
07EF8:  MOVLB  6
07EFA:  MOVWF  x30
07EFC:  MOVLW  40
07EFE:  MOVWF  x2F
07F00:  MOVLB  0
07F02:  CALL   50F0
07F06:  MOVFF  02,03
07F0A:  MOVF   01,W
07F0C:  ADDLW  40
07F0E:  MOVLB  6
07F10:  MOVWF  x28
07F12:  MOVLW  04
07F14:  ADDWFC 02,W
07F16:  MOVWF  x29
07F18:  MOVFF  FE8,4E5
07F1C:  MOVFF  628,4E4
07F20:  MOVLW  89
07F22:  MOVWF  FE9
07F24:  MOVFF  CD,634
07F28:  MOVFF  CC,633
07F2C:  MOVFF  CB,632
07F30:  MOVFF  CA,631
07F34:  MOVLW  02
07F36:  MOVWF  x35
07F38:  MOVLB  0
07F3A:  CALL   5EE8
07F3E:  MOVLW  2C
07F40:  MOVLB  6
07F42:  MOVWF  x3E
07F44:  MOVLB  0
07F46:  CALL   51A0
07F4A:  MOVLW  89
07F4C:  MOVWF  FE9
07F4E:  MOVFF  D1,634
07F52:  MOVFF  D0,633
07F56:  MOVFF  CF,632
07F5A:  MOVFF  CE,631
07F5E:  MOVLW  02
07F60:  MOVLB  6
07F62:  MOVWF  x35
07F64:  MOVLB  0
07F66:  CALL   5EE8
07F6A:  MOVLW  2C
07F6C:  MOVLB  6
07F6E:  MOVWF  x3E
07F70:  MOVLB  0
07F72:  CALL   51A0
....................    }
07F76:  BRA    814C
....................    else if (0 == strcmp(s_3V6X, arg1)) {
07F78:  MOVFF  614,630
07F7C:  MOVFF  613,62F
07F80:  MOVFF  5FA,632
07F84:  MOVFF  5F9,631
07F88:  CALL   5128
07F8C:  MOVF   01,F
07F8E:  BNZ   8012
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V6X[0],monCal.v3V6X[1]);
07F90:  MOVLW  04
07F92:  MOVLB  6
07F94:  MOVWF  x30
07F96:  MOVLW  40
07F98:  MOVWF  x2F
07F9A:  MOVLB  0
07F9C:  CALL   50F0
07FA0:  MOVFF  02,03
07FA4:  MOVF   01,W
07FA6:  ADDLW  40
07FA8:  MOVLB  6
07FAA:  MOVWF  x28
07FAC:  MOVLW  04
07FAE:  ADDWFC 02,W
07FB0:  MOVWF  x29
07FB2:  MOVFF  FE8,4E5
07FB6:  MOVFF  628,4E4
07FBA:  MOVLW  89
07FBC:  MOVWF  FE9
07FBE:  MOVFF  D5,634
07FC2:  MOVFF  D4,633
07FC6:  MOVFF  D3,632
07FCA:  MOVFF  D2,631
07FCE:  MOVLW  02
07FD0:  MOVWF  x35
07FD2:  MOVLB  0
07FD4:  CALL   5EE8
07FD8:  MOVLW  2C
07FDA:  MOVLB  6
07FDC:  MOVWF  x3E
07FDE:  MOVLB  0
07FE0:  CALL   51A0
07FE4:  MOVLW  89
07FE6:  MOVWF  FE9
07FE8:  MOVFF  D9,634
07FEC:  MOVFF  D8,633
07FF0:  MOVFF  D7,632
07FF4:  MOVFF  D6,631
07FF8:  MOVLW  02
07FFA:  MOVLB  6
07FFC:  MOVWF  x35
07FFE:  MOVLB  0
08000:  CALL   5EE8
08004:  MOVLW  2C
08006:  MOVLB  6
08008:  MOVWF  x3E
0800A:  MOVLB  0
0800C:  CALL   51A0
....................    }
08010:  BRA    814C
....................    else if (0 == strcmp(s_3V3A, arg1)) {
08012:  MOVFF  61B,630
08016:  MOVFF  61A,62F
0801A:  MOVFF  5FA,632
0801E:  MOVFF  5F9,631
08022:  CALL   5128
08026:  MOVF   01,F
08028:  BNZ   80AC
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3A[0],monCal.v3V3A[1]);
0802A:  MOVLW  04
0802C:  MOVLB  6
0802E:  MOVWF  x30
08030:  MOVLW  40
08032:  MOVWF  x2F
08034:  MOVLB  0
08036:  CALL   50F0
0803A:  MOVFF  02,03
0803E:  MOVF   01,W
08040:  ADDLW  40
08042:  MOVLB  6
08044:  MOVWF  x28
08046:  MOVLW  04
08048:  ADDWFC 02,W
0804A:  MOVWF  x29
0804C:  MOVFF  FE8,4E5
08050:  MOVFF  628,4E4
08054:  MOVLW  89
08056:  MOVWF  FE9
08058:  MOVFF  DD,634
0805C:  MOVFF  DC,633
08060:  MOVFF  DB,632
08064:  MOVFF  DA,631
08068:  MOVLW  02
0806A:  MOVWF  x35
0806C:  MOVLB  0
0806E:  CALL   5EE8
08072:  MOVLW  2C
08074:  MOVLB  6
08076:  MOVWF  x3E
08078:  MOVLB  0
0807A:  CALL   51A0
0807E:  MOVLW  89
08080:  MOVWF  FE9
08082:  MOVFF  E1,634
08086:  MOVFF  E0,633
0808A:  MOVFF  DF,632
0808E:  MOVFF  DE,631
08092:  MOVLW  02
08094:  MOVLB  6
08096:  MOVWF  x35
08098:  MOVLB  0
0809A:  CALL   5EE8
0809E:  MOVLW  2C
080A0:  MOVLB  6
080A2:  MOVWF  x3E
080A4:  MOVLB  0
080A6:  CALL   51A0
....................    }
080AA:  BRA    814C
....................    else if (0 == strcmp(s_3V3D, arg1)) {
080AC:  MOVFF  622,630
080B0:  MOVFF  621,62F
080B4:  MOVFF  5FA,632
080B8:  MOVFF  5F9,631
080BC:  CALL   5128
080C0:  MOVF   01,F
080C2:  BNZ   8146
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3D[0],monCal.v3V3D[1]);
080C4:  MOVLW  04
080C6:  MOVLB  6
080C8:  MOVWF  x30
080CA:  MOVLW  40
080CC:  MOVWF  x2F
080CE:  MOVLB  0
080D0:  CALL   50F0
080D4:  MOVFF  02,03
080D8:  MOVF   01,W
080DA:  ADDLW  40
080DC:  MOVLB  6
080DE:  MOVWF  x28
080E0:  MOVLW  04
080E2:  ADDWFC 02,W
080E4:  MOVWF  x29
080E6:  MOVFF  FE8,4E5
080EA:  MOVFF  628,4E4
080EE:  MOVLW  89
080F0:  MOVWF  FE9
080F2:  MOVFF  E5,634
080F6:  MOVFF  E4,633
080FA:  MOVFF  E3,632
080FE:  MOVFF  E2,631
08102:  MOVLW  02
08104:  MOVWF  x35
08106:  MOVLB  0
08108:  CALL   5EE8
0810C:  MOVLW  2C
0810E:  MOVLB  6
08110:  MOVWF  x3E
08112:  MOVLB  0
08114:  CALL   51A0
08118:  MOVLW  89
0811A:  MOVWF  FE9
0811C:  MOVFF  E9,634
08120:  MOVFF  E8,633
08124:  MOVFF  E7,632
08128:  MOVFF  E6,631
0812C:  MOVLW  02
0812E:  MOVLB  6
08130:  MOVWF  x35
08132:  MOVLB  0
08134:  CALL   5EE8
08138:  MOVLW  2C
0813A:  MOVLB  6
0813C:  MOVWF  x3E
0813E:  MOVLB  0
08140:  CALL   51A0
....................    }
08144:  BRA    814C
.................... //!   else if (0 == strcmp(s_all, arg1)) {
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.vN15[0],monCal.vN15[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v200[0],monCal.v200[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v5V6[0],monCal.v5V6[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v5VA[0],monCal.v5VA[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V6X[0],monCal.v3V6X[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3A[0],monCal.v3V3A[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3D[0],monCal.v3V3D[1]);
.................... //!   }
....................    else return INV_PARAM;
08146:  MOVLW  02
08148:  MOVWF  01
0814A:  BRA    8150
....................    
....................    return SUCCESS;
0814C:  MOVLW  00
0814E:  MOVWF  01
08150:  RETURN 0
.................... }
.................... 
.................... int8 setMonitorCalParam(unsigned int8 rec){
.................... 
....................    return SUCCESS;
08152:  MOVLW  00
08154:  MOVWF  01
08156:  RETURN 0
.................... }
.................... 
.................... int8 getMonitorValue(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    char *arg1;
....................    char *s_N15 = "N15";
08158:  MOVLW  4E
0815A:  MOVLB  5
0815C:  MOVWF  xFD
0815E:  MOVLW  31
08160:  MOVWF  xFE
08162:  MOVLW  35
08164:  MOVWF  xFF
08166:  MOVLB  6
08168:  CLRF   x00
0816A:  MOVLW  05
0816C:  MOVLB  5
0816E:  MOVWF  xFC
08170:  MOVLW  FD
08172:  MOVWF  xFB
....................    char *s_200 = "200";
08174:  MOVLW  32
08176:  MOVLB  6
08178:  MOVWF  x03
0817A:  MOVLW  30
0817C:  MOVWF  x04
0817E:  MOVWF  x05
08180:  CLRF   x06
08182:  MOVLW  06
08184:  MOVWF  x02
08186:  MOVLW  03
08188:  MOVWF  x01
....................    char *s_5V6 = "5V6";
0818A:  MOVLW  35
0818C:  MOVWF  x09
0818E:  MOVLW  56
08190:  MOVWF  x0A
08192:  MOVLW  36
08194:  MOVWF  x0B
08196:  CLRF   x0C
08198:  MOVLW  06
0819A:  MOVWF  x08
0819C:  MOVLW  09
0819E:  MOVWF  x07
....................    char *s_5VA = "5VA";
081A0:  MOVLW  35
081A2:  MOVWF  x0F
081A4:  MOVLW  56
081A6:  MOVWF  x10
081A8:  MOVLW  41
081AA:  MOVWF  x11
081AC:  CLRF   x12
081AE:  MOVLW  06
081B0:  MOVWF  x0E
081B2:  MOVLW  0F
081B4:  MOVWF  x0D
....................    char *s_3V6X = "3V6X";
081B6:  MOVLW  33
081B8:  MOVWF  x15
081BA:  MOVLW  56
081BC:  MOVWF  x16
081BE:  MOVLW  36
081C0:  MOVWF  x17
081C2:  MOVLW  58
081C4:  MOVWF  x18
081C6:  CLRF   x19
081C8:  MOVLW  06
081CA:  MOVWF  x14
081CC:  MOVLW  15
081CE:  MOVWF  x13
....................    char *s_3V3A = "3V3A";
081D0:  MOVLW  33
081D2:  MOVWF  x1C
081D4:  MOVLW  56
081D6:  MOVWF  x1D
081D8:  MOVLW  33
081DA:  MOVWF  x1E
081DC:  MOVLW  41
081DE:  MOVWF  x1F
081E0:  CLRF   x20
081E2:  MOVLW  06
081E4:  MOVWF  x1B
081E6:  MOVLW  1C
081E8:  MOVWF  x1A
....................    char *s_3V3D = "3V3D";
081EA:  MOVLW  33
081EC:  MOVWF  x23
081EE:  MOVLW  56
081F0:  MOVWF  x24
081F2:  MOVLW  33
081F4:  MOVWF  x25
081F6:  MOVLW  44
081F8:  MOVWF  x26
081FA:  CLRF   x27
081FC:  MOVLW  06
081FE:  MOVWF  x22
08200:  MOVLW  23
08202:  MOVWF  x21
....................    char *s_all = "all";
08204:  MOVLW  61
08206:  MOVWF  x2A
08208:  MOVLW  6C
0820A:  MOVWF  x2B
0820C:  MOVWF  x2C
0820E:  CLRF   x2D
08210:  MOVLW  06
08212:  MOVWF  x29
08214:  MOVLW  2A
08216:  MOVWF  x28
....................    
....................    arg1 = SERcmd[rec].p[2];
08218:  CLRF   x30
0821A:  MOVFF  5ED,62F
0821E:  CLRF   x32
08220:  MOVLW  B5
08222:  MOVWF  x31
08224:  MOVLB  0
08226:  CALL   087E
0822A:  MOVFF  02,62F
0822E:  MOVFF  01,62E
08232:  MOVLW  06
08234:  MOVLB  6
08236:  ADDWF  x2E,F
08238:  MOVLW  00
0823A:  ADDWFC x2F,F
0823C:  MOVLW  32
0823E:  ADDWF  x2E,W
08240:  MOVWF  01
08242:  MOVLW  00
08244:  ADDWFC x2F,W
08246:  MOVWF  03
08248:  MOVF   01,W
0824A:  ADDLW  6A
0824C:  MOVWF  01
0824E:  MOVLW  01
08250:  ADDWFC 03,F
08252:  MOVFF  01,5F9
08256:  MOVLB  5
08258:  MOVFF  03,5FA
....................    
....................    /*** GET MONITOR VALUES ************/
....................    if      (0 == strcmp(s_N15, arg1)) {
0825C:  MOVFF  5FC,630
08260:  MOVFF  5FB,62F
08264:  MOVFF  5FA,632
08268:  MOVFF  5F9,631
0826C:  MOVLB  0
0826E:  CALL   5128
08272:  MOVF   01,F
08274:  BNZ   82CC
....................       sprintf(retData+strlen(retData), "%.2f,", monitorVals.vN15);
08276:  MOVLW  04
08278:  MOVLB  6
0827A:  MOVWF  x30
0827C:  MOVLW  40
0827E:  MOVWF  x2F
08280:  MOVLB  0
08282:  CALL   50F0
08286:  MOVFF  02,03
0828A:  MOVF   01,W
0828C:  ADDLW  40
0828E:  MOVLB  6
08290:  MOVWF  x2E
08292:  MOVLW  04
08294:  ADDWFC 02,W
08296:  MOVWF  x2F
08298:  MOVFF  FE8,4E5
0829C:  MOVFF  62E,4E4
082A0:  MOVLW  89
082A2:  MOVWF  FE9
082A4:  MOVFF  F6,634
082A8:  MOVFF  F5,633
082AC:  MOVFF  F4,632
082B0:  MOVFF  F3,631
082B4:  MOVLW  02
082B6:  MOVWF  x35
082B8:  MOVLB  0
082BA:  CALL   5EE8
082BE:  MOVLW  2C
082C0:  MOVLB  6
082C2:  MOVWF  x3E
082C4:  MOVLB  0
082C6:  CALL   51A0
....................    }
082CA:  BRA    87CE
....................    else if (0 == strcmp(s_200, arg1)) {
082CC:  MOVFF  602,630
082D0:  MOVFF  601,62F
082D4:  MOVFF  5FA,632
082D8:  MOVFF  5F9,631
082DC:  CALL   5128
082E0:  MOVF   01,F
082E2:  BNZ   833A
....................       sprintf(retData+strlen(retData), "%.1f,", monitorVals.v200);
082E4:  MOVLW  04
082E6:  MOVLB  6
082E8:  MOVWF  x30
082EA:  MOVLW  40
082EC:  MOVWF  x2F
082EE:  MOVLB  0
082F0:  CALL   50F0
082F4:  MOVFF  02,03
082F8:  MOVF   01,W
082FA:  ADDLW  40
082FC:  MOVLB  6
082FE:  MOVWF  x2E
08300:  MOVLW  04
08302:  ADDWFC 02,W
08304:  MOVWF  x2F
08306:  MOVFF  FE8,4E5
0830A:  MOVFF  62E,4E4
0830E:  MOVLW  89
08310:  MOVWF  FE9
08312:  MOVFF  FA,634
08316:  MOVFF  F9,633
0831A:  MOVFF  F8,632
0831E:  MOVFF  F7,631
08322:  MOVLW  01
08324:  MOVWF  x35
08326:  MOVLB  0
08328:  CALL   5EE8
0832C:  MOVLW  2C
0832E:  MOVLB  6
08330:  MOVWF  x3E
08332:  MOVLB  0
08334:  CALL   51A0
....................    }
08338:  BRA    87CE
....................    else if (0 == strcmp(s_5V6, arg1)) {
0833A:  MOVFF  608,630
0833E:  MOVFF  607,62F
08342:  MOVFF  5FA,632
08346:  MOVFF  5F9,631
0834A:  CALL   5128
0834E:  MOVF   01,F
08350:  BNZ   83A8
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5V6);
08352:  MOVLW  04
08354:  MOVLB  6
08356:  MOVWF  x30
08358:  MOVLW  40
0835A:  MOVWF  x2F
0835C:  MOVLB  0
0835E:  CALL   50F0
08362:  MOVFF  02,03
08366:  MOVF   01,W
08368:  ADDLW  40
0836A:  MOVLB  6
0836C:  MOVWF  x2E
0836E:  MOVLW  04
08370:  ADDWFC 02,W
08372:  MOVWF  x2F
08374:  MOVFF  FE8,4E5
08378:  MOVFF  62E,4E4
0837C:  MOVLW  89
0837E:  MOVWF  FE9
08380:  MOVFF  FE,634
08384:  MOVFF  FD,633
08388:  MOVFF  FC,632
0838C:  MOVFF  FB,631
08390:  MOVLW  03
08392:  MOVWF  x35
08394:  MOVLB  0
08396:  CALL   5EE8
0839A:  MOVLW  2C
0839C:  MOVLB  6
0839E:  MOVWF  x3E
083A0:  MOVLB  0
083A2:  CALL   51A0
....................    }
083A6:  BRA    87CE
....................    else if (0 == strcmp(s_5VA, arg1)) {
083A8:  MOVFF  60E,630
083AC:  MOVFF  60D,62F
083B0:  MOVFF  5FA,632
083B4:  MOVFF  5F9,631
083B8:  CALL   5128
083BC:  MOVF   01,F
083BE:  BNZ   8416
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5VA);
083C0:  MOVLW  04
083C2:  MOVLB  6
083C4:  MOVWF  x30
083C6:  MOVLW  40
083C8:  MOVWF  x2F
083CA:  MOVLB  0
083CC:  CALL   50F0
083D0:  MOVFF  02,03
083D4:  MOVF   01,W
083D6:  ADDLW  40
083D8:  MOVLB  6
083DA:  MOVWF  x2E
083DC:  MOVLW  04
083DE:  ADDWFC 02,W
083E0:  MOVWF  x2F
083E2:  MOVFF  FE8,4E5
083E6:  MOVFF  62E,4E4
083EA:  MOVLW  89
083EC:  MOVWF  FE9
083EE:  MOVFF  102,634
083F2:  MOVFF  101,633
083F6:  MOVFF  100,632
083FA:  MOVFF  FF,631
083FE:  MOVLW  03
08400:  MOVWF  x35
08402:  MOVLB  0
08404:  CALL   5EE8
08408:  MOVLW  2C
0840A:  MOVLB  6
0840C:  MOVWF  x3E
0840E:  MOVLB  0
08410:  CALL   51A0
....................    }
08414:  BRA    87CE
....................    else if (0 == strcmp(s_3V6X, arg1)) {
08416:  MOVFF  614,630
0841A:  MOVFF  613,62F
0841E:  MOVFF  5FA,632
08422:  MOVFF  5F9,631
08426:  CALL   5128
0842A:  MOVF   01,F
0842C:  BNZ   8484
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V6X);
0842E:  MOVLW  04
08430:  MOVLB  6
08432:  MOVWF  x30
08434:  MOVLW  40
08436:  MOVWF  x2F
08438:  MOVLB  0
0843A:  CALL   50F0
0843E:  MOVFF  02,03
08442:  MOVF   01,W
08444:  ADDLW  40
08446:  MOVLB  6
08448:  MOVWF  x2E
0844A:  MOVLW  04
0844C:  ADDWFC 02,W
0844E:  MOVWF  x2F
08450:  MOVFF  FE8,4E5
08454:  MOVFF  62E,4E4
08458:  MOVLW  89
0845A:  MOVWF  FE9
0845C:  MOVFF  106,634
08460:  MOVFF  105,633
08464:  MOVFF  104,632
08468:  MOVFF  103,631
0846C:  MOVLW  03
0846E:  MOVWF  x35
08470:  MOVLB  0
08472:  CALL   5EE8
08476:  MOVLW  2C
08478:  MOVLB  6
0847A:  MOVWF  x3E
0847C:  MOVLB  0
0847E:  CALL   51A0
....................    }
08482:  BRA    87CE
....................    else if (0 == strcmp(s_3V3A, arg1)) {
08484:  MOVFF  61B,630
08488:  MOVFF  61A,62F
0848C:  MOVFF  5FA,632
08490:  MOVFF  5F9,631
08494:  CALL   5128
08498:  MOVF   01,F
0849A:  BNZ   84F2
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3A);
0849C:  MOVLW  04
0849E:  MOVLB  6
084A0:  MOVWF  x30
084A2:  MOVLW  40
084A4:  MOVWF  x2F
084A6:  MOVLB  0
084A8:  CALL   50F0
084AC:  MOVFF  02,03
084B0:  MOVF   01,W
084B2:  ADDLW  40
084B4:  MOVLB  6
084B6:  MOVWF  x2E
084B8:  MOVLW  04
084BA:  ADDWFC 02,W
084BC:  MOVWF  x2F
084BE:  MOVFF  FE8,4E5
084C2:  MOVFF  62E,4E4
084C6:  MOVLW  89
084C8:  MOVWF  FE9
084CA:  MOVFF  10A,634
084CE:  MOVFF  109,633
084D2:  MOVFF  108,632
084D6:  MOVFF  107,631
084DA:  MOVLW  03
084DC:  MOVWF  x35
084DE:  MOVLB  0
084E0:  CALL   5EE8
084E4:  MOVLW  2C
084E6:  MOVLB  6
084E8:  MOVWF  x3E
084EA:  MOVLB  0
084EC:  CALL   51A0
....................    }
084F0:  BRA    87CE
....................    else if (0 == strcmp(s_3V3D, arg1)) {
084F2:  MOVFF  622,630
084F6:  MOVFF  621,62F
084FA:  MOVFF  5FA,632
084FE:  MOVFF  5F9,631
08502:  CALL   5128
08506:  MOVF   01,F
08508:  BNZ   8560
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3D);
0850A:  MOVLW  04
0850C:  MOVLB  6
0850E:  MOVWF  x30
08510:  MOVLW  40
08512:  MOVWF  x2F
08514:  MOVLB  0
08516:  CALL   50F0
0851A:  MOVFF  02,03
0851E:  MOVF   01,W
08520:  ADDLW  40
08522:  MOVLB  6
08524:  MOVWF  x2E
08526:  MOVLW  04
08528:  ADDWFC 02,W
0852A:  MOVWF  x2F
0852C:  MOVFF  FE8,4E5
08530:  MOVFF  62E,4E4
08534:  MOVLW  89
08536:  MOVWF  FE9
08538:  MOVFF  10E,634
0853C:  MOVFF  10D,633
08540:  MOVFF  10C,632
08544:  MOVFF  10B,631
08548:  MOVLW  03
0854A:  MOVWF  x35
0854C:  MOVLB  0
0854E:  CALL   5EE8
08552:  MOVLW  2C
08554:  MOVLB  6
08556:  MOVWF  x3E
08558:  MOVLB  0
0855A:  CALL   51A0
....................    }
0855E:  BRA    87CE
....................    else if (0 == strcmp(s_all, arg1)) {
08560:  MOVFF  629,630
08564:  MOVFF  628,62F
08568:  MOVFF  5FA,632
0856C:  MOVFF  5F9,631
08570:  CALL   5128
08574:  MOVF   01,F
08576:  BTFSS  FD8.2
08578:  BRA    87C8
....................       sprintf(retData+strlen(retData), "%.2f,", monitorVals.vN15);
0857A:  MOVLW  04
0857C:  MOVLB  6
0857E:  MOVWF  x30
08580:  MOVLW  40
08582:  MOVWF  x2F
08584:  MOVLB  0
08586:  CALL   50F0
0858A:  MOVFF  02,03
0858E:  MOVF   01,W
08590:  ADDLW  40
08592:  MOVLB  6
08594:  MOVWF  x2E
08596:  MOVLW  04
08598:  ADDWFC 02,W
0859A:  MOVWF  x2F
0859C:  MOVFF  FE8,4E5
085A0:  MOVFF  62E,4E4
085A4:  MOVLW  89
085A6:  MOVWF  FE9
085A8:  MOVFF  F6,634
085AC:  MOVFF  F5,633
085B0:  MOVFF  F4,632
085B4:  MOVFF  F3,631
085B8:  MOVLW  02
085BA:  MOVWF  x35
085BC:  MOVLB  0
085BE:  CALL   5EE8
085C2:  MOVLW  2C
085C4:  MOVLB  6
085C6:  MOVWF  x3E
085C8:  MOVLB  0
085CA:  CALL   51A0
....................       sprintf(retData+strlen(retData), "%.1f,", monitorVals.v200);
085CE:  MOVLW  04
085D0:  MOVLB  6
085D2:  MOVWF  x30
085D4:  MOVLW  40
085D6:  MOVWF  x2F
085D8:  MOVLB  0
085DA:  CALL   50F0
085DE:  MOVFF  02,03
085E2:  MOVF   01,W
085E4:  ADDLW  40
085E6:  MOVLB  6
085E8:  MOVWF  x2E
085EA:  MOVLW  04
085EC:  ADDWFC 02,W
085EE:  MOVWF  x2F
085F0:  MOVFF  FE8,4E5
085F4:  MOVFF  62E,4E4
085F8:  MOVLW  89
085FA:  MOVWF  FE9
085FC:  MOVFF  FA,634
08600:  MOVFF  F9,633
08604:  MOVFF  F8,632
08608:  MOVFF  F7,631
0860C:  MOVLW  01
0860E:  MOVWF  x35
08610:  MOVLB  0
08612:  CALL   5EE8
08616:  MOVLW  2C
08618:  MOVLB  6
0861A:  MOVWF  x3E
0861C:  MOVLB  0
0861E:  CALL   51A0
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5V6);
08622:  MOVLW  04
08624:  MOVLB  6
08626:  MOVWF  x30
08628:  MOVLW  40
0862A:  MOVWF  x2F
0862C:  MOVLB  0
0862E:  CALL   50F0
08632:  MOVFF  02,03
08636:  MOVF   01,W
08638:  ADDLW  40
0863A:  MOVLB  6
0863C:  MOVWF  x2E
0863E:  MOVLW  04
08640:  ADDWFC 02,W
08642:  MOVWF  x2F
08644:  MOVFF  FE8,4E5
08648:  MOVFF  62E,4E4
0864C:  MOVLW  89
0864E:  MOVWF  FE9
08650:  MOVFF  FE,634
08654:  MOVFF  FD,633
08658:  MOVFF  FC,632
0865C:  MOVFF  FB,631
08660:  MOVLW  03
08662:  MOVWF  x35
08664:  MOVLB  0
08666:  CALL   5EE8
0866A:  MOVLW  2C
0866C:  MOVLB  6
0866E:  MOVWF  x3E
08670:  MOVLB  0
08672:  CALL   51A0
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5VA);
08676:  MOVLW  04
08678:  MOVLB  6
0867A:  MOVWF  x30
0867C:  MOVLW  40
0867E:  MOVWF  x2F
08680:  MOVLB  0
08682:  CALL   50F0
08686:  MOVFF  02,03
0868A:  MOVF   01,W
0868C:  ADDLW  40
0868E:  MOVLB  6
08690:  MOVWF  x2E
08692:  MOVLW  04
08694:  ADDWFC 02,W
08696:  MOVWF  x2F
08698:  MOVFF  FE8,4E5
0869C:  MOVFF  62E,4E4
086A0:  MOVLW  89
086A2:  MOVWF  FE9
086A4:  MOVFF  102,634
086A8:  MOVFF  101,633
086AC:  MOVFF  100,632
086B0:  MOVFF  FF,631
086B4:  MOVLW  03
086B6:  MOVWF  x35
086B8:  MOVLB  0
086BA:  CALL   5EE8
086BE:  MOVLW  2C
086C0:  MOVLB  6
086C2:  MOVWF  x3E
086C4:  MOVLB  0
086C6:  CALL   51A0
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V6X);
086CA:  MOVLW  04
086CC:  MOVLB  6
086CE:  MOVWF  x30
086D0:  MOVLW  40
086D2:  MOVWF  x2F
086D4:  MOVLB  0
086D6:  CALL   50F0
086DA:  MOVFF  02,03
086DE:  MOVF   01,W
086E0:  ADDLW  40
086E2:  MOVLB  6
086E4:  MOVWF  x2E
086E6:  MOVLW  04
086E8:  ADDWFC 02,W
086EA:  MOVWF  x2F
086EC:  MOVFF  FE8,4E5
086F0:  MOVFF  62E,4E4
086F4:  MOVLW  89
086F6:  MOVWF  FE9
086F8:  MOVFF  106,634
086FC:  MOVFF  105,633
08700:  MOVFF  104,632
08704:  MOVFF  103,631
08708:  MOVLW  03
0870A:  MOVWF  x35
0870C:  MOVLB  0
0870E:  CALL   5EE8
08712:  MOVLW  2C
08714:  MOVLB  6
08716:  MOVWF  x3E
08718:  MOVLB  0
0871A:  CALL   51A0
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3A);
0871E:  MOVLW  04
08720:  MOVLB  6
08722:  MOVWF  x30
08724:  MOVLW  40
08726:  MOVWF  x2F
08728:  MOVLB  0
0872A:  CALL   50F0
0872E:  MOVFF  02,03
08732:  MOVF   01,W
08734:  ADDLW  40
08736:  MOVLB  6
08738:  MOVWF  x2E
0873A:  MOVLW  04
0873C:  ADDWFC 02,W
0873E:  MOVWF  x2F
08740:  MOVFF  FE8,4E5
08744:  MOVFF  62E,4E4
08748:  MOVLW  89
0874A:  MOVWF  FE9
0874C:  MOVFF  10A,634
08750:  MOVFF  109,633
08754:  MOVFF  108,632
08758:  MOVFF  107,631
0875C:  MOVLW  03
0875E:  MOVWF  x35
08760:  MOVLB  0
08762:  CALL   5EE8
08766:  MOVLW  2C
08768:  MOVLB  6
0876A:  MOVWF  x3E
0876C:  MOVLB  0
0876E:  CALL   51A0
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3D);
08772:  MOVLW  04
08774:  MOVLB  6
08776:  MOVWF  x30
08778:  MOVLW  40
0877A:  MOVWF  x2F
0877C:  MOVLB  0
0877E:  CALL   50F0
08782:  MOVFF  02,03
08786:  MOVF   01,W
08788:  ADDLW  40
0878A:  MOVLB  6
0878C:  MOVWF  x2E
0878E:  MOVLW  04
08790:  ADDWFC 02,W
08792:  MOVWF  x2F
08794:  MOVFF  FE8,4E5
08798:  MOVFF  62E,4E4
0879C:  MOVLW  89
0879E:  MOVWF  FE9
087A0:  MOVFF  10E,634
087A4:  MOVFF  10D,633
087A8:  MOVFF  10C,632
087AC:  MOVFF  10B,631
087B0:  MOVLW  03
087B2:  MOVWF  x35
087B4:  MOVLB  0
087B6:  CALL   5EE8
087BA:  MOVLW  2C
087BC:  MOVLB  6
087BE:  MOVWF  x3E
087C0:  MOVLB  0
087C2:  CALL   51A0
....................    }
087C6:  BRA    87CE
....................    else return INV_PARAM;
087C8:  MOVLW  02
087CA:  MOVWF  01
087CC:  BRA    87D2
....................    
....................    return SUCCESS;
087CE:  MOVLW  00
087D0:  MOVWF  01
087D2:  RETURN 0
.................... }
.................... 
.................... int8 getPIDdata(unsigned int8 rec){
....................   /*** ARG CHECKS ********************/ 
....................    int8 arg1;
....................    char *arg2;
....................    char *s_PV = "PV";
087D4:  MOVLW  50
087D6:  MOVLB  5
087D8:  MOVWF  xFE
087DA:  MOVLW  56
087DC:  MOVWF  xFF
087DE:  MOVLB  6
087E0:  CLRF   x00
087E2:  MOVLW  05
087E4:  MOVLB  5
087E6:  MOVWF  xFD
087E8:  MOVLW  FE
087EA:  MOVWF  xFC
....................    char *s_CV = "CV";
087EC:  MOVLW  43
087EE:  MOVLB  6
087F0:  MOVWF  x03
087F2:  MOVLW  56
087F4:  MOVWF  x04
087F6:  CLRF   x05
087F8:  MOVLW  06
087FA:  MOVWF  x02
087FC:  MOVLW  03
087FE:  MOVWF  x01
....................    char *s_PVold = "PVold";
08800:  MOVLW  50
08802:  MOVWF  x08
08804:  MOVLW  56
08806:  MOVWF  x09
08808:  MOVLW  6F
0880A:  MOVWF  x0A
0880C:  MOVLW  6C
0880E:  MOVWF  x0B
08810:  MOVLW  64
08812:  MOVWF  x0C
08814:  CLRF   x0D
08816:  MOVLW  06
08818:  MOVWF  x07
0881A:  MOVLW  08
0881C:  MOVWF  x06
....................    char *s_I = "I";
0881E:  MOVLW  49
08820:  MOVWF  x10
08822:  CLRF   x11
08824:  MOVLW  06
08826:  MOVWF  x0F
08828:  MOVLW  10
0882A:  MOVWF  x0E
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0882C:  CLRF   x30
0882E:  MOVFF  5ED,62F
08832:  CLRF   x32
08834:  MOVLW  B5
08836:  MOVWF  x31
08838:  MOVLB  0
0883A:  CALL   087E
0883E:  MOVFF  02,613
08842:  MOVFF  01,612
08846:  MOVLW  06
08848:  MOVLB  6
0884A:  ADDWF  x12,F
0884C:  MOVLW  00
0884E:  ADDWFC x13,F
08850:  MOVLW  32
08852:  ADDWF  x12,W
08854:  MOVWF  01
08856:  MOVLW  00
08858:  ADDWFC x13,W
0885A:  MOVWF  03
0885C:  MOVF   01,W
0885E:  ADDLW  6A
08860:  MOVWF  01
08862:  MOVLW  01
08864:  ADDWFC 03,F
08866:  MOVFF  01,612
0886A:  MOVFF  03,613
0886E:  MOVFF  03,629
08872:  MOVFF  01,628
08876:  MOVLB  0
08878:  CALL   5268
0887C:  MOVF   01,F
0887E:  BNZ   8888
08880:  MOVLW  02
08882:  MOVWF  01
08884:  BRA    8C30
08886:  BRA    88E6
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
08888:  MOVLB  6
0888A:  CLRF   x30
0888C:  MOVFF  5ED,62F
08890:  CLRF   x32
08892:  MOVLW  B5
08894:  MOVWF  x31
08896:  MOVLB  0
08898:  CALL   087E
0889C:  MOVFF  02,613
088A0:  MOVFF  01,612
088A4:  MOVLW  06
088A6:  MOVLB  6
088A8:  ADDWF  x12,F
088AA:  MOVLW  00
088AC:  ADDWFC x13,F
088AE:  MOVLW  32
088B0:  ADDWF  x12,W
088B2:  MOVWF  01
088B4:  MOVLW  00
088B6:  ADDWFC x13,W
088B8:  MOVWF  03
088BA:  MOVF   01,W
088BC:  ADDLW  6A
088BE:  MOVWF  01
088C0:  MOVLW  01
088C2:  ADDWFC 03,F
088C4:  MOVFF  01,612
088C8:  MOVFF  03,613
088CC:  MOVFF  03,629
088D0:  MOVFF  01,628
088D4:  CLRF   x2B
088D6:  CLRF   x2A
088D8:  MOVLW  0A
088DA:  MOVWF  x2C
088DC:  MOVLB  0
088DE:  CALL   5358
088E2:  MOVFF  01,5F9
....................    
....................    arg2 = SERcmd[rec].p[3];
088E6:  MOVLB  6
088E8:  CLRF   x30
088EA:  MOVFF  5ED,62F
088EE:  CLRF   x32
088F0:  MOVLW  B5
088F2:  MOVWF  x31
088F4:  MOVLB  0
088F6:  CALL   087E
088FA:  MOVFF  02,613
088FE:  MOVFF  01,612
08902:  MOVLW  06
08904:  MOVLB  6
08906:  ADDWF  x12,F
08908:  MOVLW  00
0890A:  ADDWFC x13,F
0890C:  MOVLW  4B
0890E:  ADDWF  x12,W
08910:  MOVWF  01
08912:  MOVLW  00
08914:  ADDWFC x13,W
08916:  MOVWF  03
08918:  MOVF   01,W
0891A:  ADDLW  6A
0891C:  MOVWF  01
0891E:  MOVLW  01
08920:  ADDWFC 03,F
08922:  MOVFF  01,5FA
08926:  MOVLB  5
08928:  MOVFF  03,5FB
....................    
....................    /*** GET PV, CV, PVold, I, or A(LL) VALUE **********/
....................    if      (0 == strcmp(s_PV, arg2))     sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].PV);
0892C:  MOVFF  5FD,630
08930:  MOVFF  5FC,62F
08934:  MOVFF  5FB,632
08938:  MOVFF  5FA,631
0893C:  MOVLB  0
0893E:  CALL   5128
08942:  MOVF   01,F
08944:  BNZ   89EC
08946:  MOVLW  04
08948:  MOVLB  6
0894A:  MOVWF  x30
0894C:  MOVLW  40
0894E:  MOVWF  x2F
08950:  MOVLB  0
08952:  CALL   50F0
08956:  MOVF   01,W
08958:  ADDLW  40
0895A:  MOVLB  6
0895C:  MOVWF  x12
0895E:  MOVLW  04
08960:  ADDWFC 02,W
08962:  MOVWF  x13
08964:  MOVLW  01
08966:  MOVLB  5
08968:  SUBWF  xF9,W
0896A:  MULLW  20
0896C:  MOVF   FF3,W
0896E:  MOVLB  6
08970:  CLRF   x15
08972:  MOVWF  x14
08974:  MOVLW  10
08976:  ADDWF  x14,W
08978:  MOVWF  01
0897A:  MOVLW  00
0897C:  ADDWFC x15,W
0897E:  MOVWF  03
08980:  MOVF   01,W
08982:  ADDLW  20
08984:  MOVWF  FE9
08986:  MOVLW  00
08988:  ADDWFC 03,W
0898A:  MOVWF  FEA
0898C:  MOVFF  FEF,614
08990:  MOVFF  FEC,615
08994:  MOVFF  FEC,616
08998:  MOVFF  FEC,617
0899C:  MOVFF  613,4E5
089A0:  MOVFF  612,4E4
089A4:  MOVFF  5F9,629
089A8:  MOVLW  18
089AA:  MOVWF  x2A
089AC:  MOVLB  0
089AE:  CALL   56AC
089B2:  MOVLW  2C
089B4:  MOVLB  6
089B6:  MOVWF  x3E
089B8:  MOVLB  0
089BA:  CALL   51A0
089BE:  MOVLW  89
089C0:  MOVWF  FE9
089C2:  MOVFF  617,634
089C6:  MOVFF  616,633
089CA:  MOVFF  615,632
089CE:  MOVFF  614,631
089D2:  MOVLW  02
089D4:  MOVLB  6
089D6:  MOVWF  x35
089D8:  MOVLB  0
089DA:  CALL   5EE8
089DE:  MOVLW  2C
089E0:  MOVLB  6
089E2:  MOVWF  x3E
089E4:  MOVLB  0
089E6:  CALL   51A0
089EA:  BRA    8C2C
....................    else if (0 == strcmp(s_CV, arg2))     sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].CV);
089EC:  MOVFF  602,630
089F0:  MOVFF  601,62F
089F4:  MOVFF  5FB,632
089F8:  MOVFF  5FA,631
089FC:  CALL   5128
08A00:  MOVF   01,F
08A02:  BNZ   8AAA
08A04:  MOVLW  04
08A06:  MOVLB  6
08A08:  MOVWF  x30
08A0A:  MOVLW  40
08A0C:  MOVWF  x2F
08A0E:  MOVLB  0
08A10:  CALL   50F0
08A14:  MOVF   01,W
08A16:  ADDLW  40
08A18:  MOVLB  6
08A1A:  MOVWF  x12
08A1C:  MOVLW  04
08A1E:  ADDWFC 02,W
08A20:  MOVWF  x13
08A22:  MOVLW  01
08A24:  MOVLB  5
08A26:  SUBWF  xF9,W
08A28:  MULLW  20
08A2A:  MOVF   FF3,W
08A2C:  MOVLB  6
08A2E:  CLRF   x15
08A30:  MOVWF  x14
08A32:  MOVLW  18
08A34:  ADDWF  x14,W
08A36:  MOVWF  01
08A38:  MOVLW  00
08A3A:  ADDWFC x15,W
08A3C:  MOVWF  03
08A3E:  MOVF   01,W
08A40:  ADDLW  20
08A42:  MOVWF  FE9
08A44:  MOVLW  00
08A46:  ADDWFC 03,W
08A48:  MOVWF  FEA
08A4A:  MOVFF  FEF,614
08A4E:  MOVFF  FEC,615
08A52:  MOVFF  FEC,616
08A56:  MOVFF  FEC,617
08A5A:  MOVFF  613,4E5
08A5E:  MOVFF  612,4E4
08A62:  MOVFF  5F9,629
08A66:  MOVLW  18
08A68:  MOVWF  x2A
08A6A:  MOVLB  0
08A6C:  CALL   56AC
08A70:  MOVLW  2C
08A72:  MOVLB  6
08A74:  MOVWF  x3E
08A76:  MOVLB  0
08A78:  CALL   51A0
08A7C:  MOVLW  89
08A7E:  MOVWF  FE9
08A80:  MOVFF  617,634
08A84:  MOVFF  616,633
08A88:  MOVFF  615,632
08A8C:  MOVFF  614,631
08A90:  MOVLW  02
08A92:  MOVLB  6
08A94:  MOVWF  x35
08A96:  MOVLB  0
08A98:  CALL   5EE8
08A9C:  MOVLW  2C
08A9E:  MOVLB  6
08AA0:  MOVWF  x3E
08AA2:  MOVLB  0
08AA4:  CALL   51A0
08AA8:  BRA    8C2C
....................    else if (0 == strcmp(s_PVold, arg2))  sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].PVold);
08AAA:  MOVFF  607,630
08AAE:  MOVFF  606,62F
08AB2:  MOVFF  5FB,632
08AB6:  MOVFF  5FA,631
08ABA:  CALL   5128
08ABE:  MOVF   01,F
08AC0:  BNZ   8B68
08AC2:  MOVLW  04
08AC4:  MOVLB  6
08AC6:  MOVWF  x30
08AC8:  MOVLW  40
08ACA:  MOVWF  x2F
08ACC:  MOVLB  0
08ACE:  CALL   50F0
08AD2:  MOVF   01,W
08AD4:  ADDLW  40
08AD6:  MOVLB  6
08AD8:  MOVWF  x12
08ADA:  MOVLW  04
08ADC:  ADDWFC 02,W
08ADE:  MOVWF  x13
08AE0:  MOVLW  01
08AE2:  MOVLB  5
08AE4:  SUBWF  xF9,W
08AE6:  MULLW  20
08AE8:  MOVF   FF3,W
08AEA:  MOVLB  6
08AEC:  CLRF   x15
08AEE:  MOVWF  x14
08AF0:  MOVLW  14
08AF2:  ADDWF  x14,W
08AF4:  MOVWF  01
08AF6:  MOVLW  00
08AF8:  ADDWFC x15,W
08AFA:  MOVWF  03
08AFC:  MOVF   01,W
08AFE:  ADDLW  20
08B00:  MOVWF  FE9
08B02:  MOVLW  00
08B04:  ADDWFC 03,W
08B06:  MOVWF  FEA
08B08:  MOVFF  FEF,614
08B0C:  MOVFF  FEC,615
08B10:  MOVFF  FEC,616
08B14:  MOVFF  FEC,617
08B18:  MOVFF  613,4E5
08B1C:  MOVFF  612,4E4
08B20:  MOVFF  5F9,629
08B24:  MOVLW  18
08B26:  MOVWF  x2A
08B28:  MOVLB  0
08B2A:  CALL   56AC
08B2E:  MOVLW  2C
08B30:  MOVLB  6
08B32:  MOVWF  x3E
08B34:  MOVLB  0
08B36:  CALL   51A0
08B3A:  MOVLW  89
08B3C:  MOVWF  FE9
08B3E:  MOVFF  617,634
08B42:  MOVFF  616,633
08B46:  MOVFF  615,632
08B4A:  MOVFF  614,631
08B4E:  MOVLW  02
08B50:  MOVLB  6
08B52:  MOVWF  x35
08B54:  MOVLB  0
08B56:  CALL   5EE8
08B5A:  MOVLW  2C
08B5C:  MOVLB  6
08B5E:  MOVWF  x3E
08B60:  MOVLB  0
08B62:  CALL   51A0
08B66:  BRA    8C2C
....................    else if (0 == strcmp(s_I, arg2))      sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].I);
08B68:  MOVFF  60F,630
08B6C:  MOVFF  60E,62F
08B70:  MOVFF  5FB,632
08B74:  MOVFF  5FA,631
08B78:  CALL   5128
08B7C:  MOVF   01,F
08B7E:  BNZ   8C26
08B80:  MOVLW  04
08B82:  MOVLB  6
08B84:  MOVWF  x30
08B86:  MOVLW  40
08B88:  MOVWF  x2F
08B8A:  MOVLB  0
08B8C:  CALL   50F0
08B90:  MOVF   01,W
08B92:  ADDLW  40
08B94:  MOVLB  6
08B96:  MOVWF  x12
08B98:  MOVLW  04
08B9A:  ADDWFC 02,W
08B9C:  MOVWF  x13
08B9E:  MOVLW  01
08BA0:  MOVLB  5
08BA2:  SUBWF  xF9,W
08BA4:  MULLW  20
08BA6:  MOVF   FF3,W
08BA8:  MOVLB  6
08BAA:  CLRF   x15
08BAC:  MOVWF  x14
08BAE:  MOVLW  1C
08BB0:  ADDWF  x14,W
08BB2:  MOVWF  01
08BB4:  MOVLW  00
08BB6:  ADDWFC x15,W
08BB8:  MOVWF  03
08BBA:  MOVF   01,W
08BBC:  ADDLW  20
08BBE:  MOVWF  FE9
08BC0:  MOVLW  00
08BC2:  ADDWFC 03,W
08BC4:  MOVWF  FEA
08BC6:  MOVFF  FEF,614
08BCA:  MOVFF  FEC,615
08BCE:  MOVFF  FEC,616
08BD2:  MOVFF  FEC,617
08BD6:  MOVFF  613,4E5
08BDA:  MOVFF  612,4E4
08BDE:  MOVFF  5F9,629
08BE2:  MOVLW  18
08BE4:  MOVWF  x2A
08BE6:  MOVLB  0
08BE8:  CALL   56AC
08BEC:  MOVLW  2C
08BEE:  MOVLB  6
08BF0:  MOVWF  x3E
08BF2:  MOVLB  0
08BF4:  CALL   51A0
08BF8:  MOVLW  89
08BFA:  MOVWF  FE9
08BFC:  MOVFF  617,634
08C00:  MOVFF  616,633
08C04:  MOVFF  615,632
08C08:  MOVFF  614,631
08C0C:  MOVLW  02
08C0E:  MOVLB  6
08C10:  MOVWF  x35
08C12:  MOVLB  0
08C14:  CALL   5EE8
08C18:  MOVLW  2C
08C1A:  MOVLB  6
08C1C:  MOVWF  x3E
08C1E:  MOVLB  0
08C20:  CALL   51A0
08C24:  BRA    8C2C
....................    else return INV_PARAM;
08C26:  MOVLW  02
08C28:  MOVWF  01
08C2A:  BRA    8C30
....................    
....................    return SUCCESS;
08C2C:  MOVLW  00
08C2E:  MOVWF  01
08C30:  RETURN 0
.................... }
.................... 
.................... int8 getIPdata(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char *arg2;
....................    char *s_raw = "raw";
*
08D50:  MOVLW  72
08D52:  MOVLB  5
08D54:  MOVWF  xFE
08D56:  MOVLW  61
08D58:  MOVWF  xFF
08D5A:  MOVLW  77
08D5C:  MOVLB  6
08D5E:  MOVWF  x00
08D60:  CLRF   x01
08D62:  MOVLW  05
08D64:  MOVLB  5
08D66:  MOVWF  xFD
08D68:  MOVLW  FE
08D6A:  MOVWF  xFC
....................    char *s_calibrated = "calib";
08D6C:  MOVLW  63
08D6E:  MOVLB  6
08D70:  MOVWF  x04
08D72:  MOVLW  61
08D74:  MOVWF  x05
08D76:  MOVLW  6C
08D78:  MOVWF  x06
08D7A:  MOVLW  69
08D7C:  MOVWF  x07
08D7E:  MOVLW  62
08D80:  MOVWF  x08
08D82:  CLRF   x09
08D84:  MOVLW  06
08D86:  MOVWF  x03
08D88:  MOVLW  04
08D8A:  MOVWF  x02
....................    char *s_p0 = "p0";
08D8C:  MOVLW  70
08D8E:  MOVWF  x0C
08D90:  MOVLW  30
08D92:  MOVWF  x0D
08D94:  CLRF   x0E
08D96:  MOVLW  06
08D98:  MOVWF  x0B
08D9A:  MOVLW  0C
08D9C:  MOVWF  x0A
....................    char *s_poles = "poles";
08D9E:  MOVLW  70
08DA0:  MOVWF  x11
08DA2:  MOVLW  6F
08DA4:  MOVWF  x12
08DA6:  MOVLW  6C
08DA8:  MOVWF  x13
08DAA:  MOVLW  65
08DAC:  MOVWF  x14
08DAE:  MOVLW  73
08DB0:  MOVWF  x15
08DB2:  CLRF   x16
08DB4:  MOVLW  06
08DB6:  MOVWF  x10
08DB8:  MOVLW  11
08DBA:  MOVWF  x0F
....................    char *s_real = "real";
08DBC:  MOVLW  72
08DBE:  MOVWF  x19
08DC0:  MOVLW  65
08DC2:  MOVWF  x1A
08DC4:  MOVLW  61
08DC6:  MOVWF  x1B
08DC8:  MOVLW  6C
08DCA:  MOVWF  x1C
08DCC:  CLRF   x1D
08DCE:  MOVLW  06
08DD0:  MOVWF  x18
08DD2:  MOVLW  19
08DD4:  MOVWF  x17
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
08DD6:  CLRF   x30
08DD8:  MOVFF  5ED,62F
08DDC:  CLRF   x32
08DDE:  MOVLW  B5
08DE0:  MOVWF  x31
08DE2:  MOVLB  0
08DE4:  CALL   087E
08DE8:  MOVFF  02,61F
08DEC:  MOVFF  01,61E
08DF0:  MOVLW  06
08DF2:  MOVLB  6
08DF4:  ADDWF  x1E,F
08DF6:  MOVLW  00
08DF8:  ADDWFC x1F,F
08DFA:  MOVLW  32
08DFC:  ADDWF  x1E,W
08DFE:  MOVWF  01
08E00:  MOVLW  00
08E02:  ADDWFC x1F,W
08E04:  MOVWF  03
08E06:  MOVF   01,W
08E08:  ADDLW  6A
08E0A:  MOVWF  01
08E0C:  MOVLW  01
08E0E:  ADDWFC 03,F
08E10:  MOVFF  01,61E
08E14:  MOVFF  03,61F
08E18:  MOVFF  03,629
08E1C:  MOVFF  01,628
08E20:  MOVLB  0
08E22:  CALL   5268
08E26:  MOVF   01,F
08E28:  BNZ   8E32
08E2A:  MOVLW  02
08E2C:  MOVWF  01
08E2E:  BRA    9494
08E30:  BRA    8E90
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
08E32:  MOVLB  6
08E34:  CLRF   x30
08E36:  MOVFF  5ED,62F
08E3A:  CLRF   x32
08E3C:  MOVLW  B5
08E3E:  MOVWF  x31
08E40:  MOVLB  0
08E42:  CALL   087E
08E46:  MOVFF  02,61F
08E4A:  MOVFF  01,61E
08E4E:  MOVLW  06
08E50:  MOVLB  6
08E52:  ADDWF  x1E,F
08E54:  MOVLW  00
08E56:  ADDWFC x1F,F
08E58:  MOVLW  32
08E5A:  ADDWF  x1E,W
08E5C:  MOVWF  01
08E5E:  MOVLW  00
08E60:  ADDWFC x1F,W
08E62:  MOVWF  03
08E64:  MOVF   01,W
08E66:  ADDLW  6A
08E68:  MOVWF  01
08E6A:  MOVLW  01
08E6C:  ADDWFC 03,F
08E6E:  MOVFF  01,61E
08E72:  MOVFF  03,61F
08E76:  MOVFF  03,629
08E7A:  MOVFF  01,628
08E7E:  CLRF   x2B
08E80:  CLRF   x2A
08E82:  MOVLW  0A
08E84:  MOVWF  x2C
08E86:  MOVLB  0
08E88:  CALL   5358
08E8C:  MOVFF  01,5F9
....................    
....................    arg2 = SERcmd[rec].p[3];
08E90:  MOVLB  6
08E92:  CLRF   x30
08E94:  MOVFF  5ED,62F
08E98:  CLRF   x32
08E9A:  MOVLW  B5
08E9C:  MOVWF  x31
08E9E:  MOVLB  0
08EA0:  CALL   087E
08EA4:  MOVFF  02,61F
08EA8:  MOVFF  01,61E
08EAC:  MOVLW  06
08EAE:  MOVLB  6
08EB0:  ADDWF  x1E,F
08EB2:  MOVLW  00
08EB4:  ADDWFC x1F,F
08EB6:  MOVLW  4B
08EB8:  ADDWF  x1E,W
08EBA:  MOVWF  01
08EBC:  MOVLW  00
08EBE:  ADDWFC x1F,W
08EC0:  MOVWF  03
08EC2:  MOVF   01,W
08EC4:  ADDLW  6A
08EC6:  MOVWF  01
08EC8:  MOVLW  01
08ECA:  ADDWFC 03,F
08ECC:  MOVFF  01,5FA
08ED0:  MOVLB  5
08ED2:  MOVFF  03,5FB
....................    
....................    /*** GET INPUT DATA ****************/
....................    if      (0 == strcmp(s_raw, arg2)) {
08ED6:  MOVFF  5FD,630
08EDA:  MOVFF  5FC,62F
08EDE:  MOVFF  5FB,632
08EE2:  MOVFF  5FA,631
08EE6:  MOVLB  0
08EE8:  CALL   5128
08EEC:  MOVF   01,F
08EEE:  BTFSS  FD8.2
08EF0:  BRA    9074
....................       sprintf(retData+strlen(retData), "%d,", arg1);
08EF2:  MOVLW  04
08EF4:  MOVLB  6
08EF6:  MOVWF  x30
08EF8:  MOVLW  40
08EFA:  MOVWF  x2F
08EFC:  MOVLB  0
08EFE:  CALL   50F0
08F02:  MOVFF  02,03
08F06:  MOVF   01,W
08F08:  ADDLW  40
08F0A:  MOVLB  6
08F0C:  MOVWF  x1E
08F0E:  MOVLW  04
08F10:  ADDWFC 02,W
08F12:  MOVWF  x1F
08F14:  MOVFF  FE8,4E5
08F18:  MOVFF  61E,4E4
08F1C:  MOVFF  5F9,629
08F20:  MOVLW  18
08F22:  MOVWF  x2A
08F24:  MOVLB  0
08F26:  CALL   56AC
08F2A:  MOVLW  2C
08F2C:  MOVLB  6
08F2E:  MOVWF  x3E
08F30:  MOVLB  0
08F32:  CALL   51A0
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].sinRaw);
08F36:  MOVLW  04
08F38:  MOVLB  6
08F3A:  MOVWF  x30
08F3C:  MOVLW  40
08F3E:  MOVWF  x2F
08F40:  MOVLB  0
08F42:  CALL   50F0
08F46:  MOVFF  02,03
08F4A:  MOVF   01,W
08F4C:  ADDLW  40
08F4E:  MOVLB  6
08F50:  MOVWF  x1E
08F52:  MOVLW  04
08F54:  ADDWFC 02,W
08F56:  MOVWF  x1F
08F58:  MOVLW  01
08F5A:  MOVLB  5
08F5C:  SUBWF  xF9,W
08F5E:  MULLW  21
08F60:  MOVF   FF3,W
08F62:  MOVLB  6
08F64:  CLRF   x21
08F66:  MOVWF  x20
08F68:  MOVLW  0F
08F6A:  ADDWF  x20,W
08F6C:  MOVWF  FE9
08F6E:  MOVLW  01
08F70:  ADDWFC x21,W
08F72:  MOVWF  FEA
08F74:  MOVFF  FEF,63E
08F78:  MOVFF  FEC,01
08F7C:  MOVFF  FEC,02
08F80:  MOVFF  FEC,03
08F84:  MOVFF  03,641
08F88:  MOVFF  02,640
08F8C:  MOVFF  01,63F
08F90:  MOVLB  0
08F92:  CALL   4D00
08F96:  MOVFF  03,625
08F9A:  MOVFF  02,624
08F9E:  MOVFF  01,623
08FA2:  MOVFF  00,622
08FA6:  MOVFF  61F,4E5
08FAA:  MOVFF  61E,4E4
08FAE:  MOVLW  41
08FB0:  MOVWF  FE9
08FB2:  MOVFF  03,631
08FB6:  MOVFF  02,630
08FBA:  MOVFF  01,62F
08FBE:  MOVFF  00,62E
08FC2:  RCALL  8C32
08FC4:  MOVLW  2C
08FC6:  MOVLB  6
08FC8:  MOVWF  x3E
08FCA:  MOVLB  0
08FCC:  CALL   51A0
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].cosRaw);
08FD0:  MOVLW  04
08FD2:  MOVLB  6
08FD4:  MOVWF  x30
08FD6:  MOVLW  40
08FD8:  MOVWF  x2F
08FDA:  MOVLB  0
08FDC:  CALL   50F0
08FE0:  MOVF   01,W
08FE2:  ADDLW  40
08FE4:  MOVLB  6
08FE6:  MOVWF  x1E
08FE8:  MOVLW  04
08FEA:  ADDWFC 02,W
08FEC:  MOVWF  x1F
08FEE:  MOVLW  01
08FF0:  MOVLB  5
08FF2:  SUBWF  xF9,W
08FF4:  MULLW  21
08FF6:  MOVF   FF3,W
08FF8:  MOVLB  6
08FFA:  CLRF   x21
08FFC:  MOVWF  x20
08FFE:  MOVLW  04
09000:  ADDWF  x20,W
09002:  MOVWF  01
09004:  MOVLW  00
09006:  ADDWFC x21,W
09008:  MOVWF  03
0900A:  MOVF   01,W
0900C:  ADDLW  0F
0900E:  MOVWF  FE9
09010:  MOVLW  01
09012:  ADDWFC 03,W
09014:  MOVWF  FEA
09016:  MOVFF  FEF,63E
0901A:  MOVFF  FEC,01
0901E:  MOVFF  FEC,02
09022:  MOVFF  FEC,03
09026:  MOVFF  03,641
0902A:  MOVFF  02,640
0902E:  MOVFF  01,63F
09032:  MOVLB  0
09034:  CALL   4D00
09038:  MOVFF  03,623
0903C:  MOVFF  02,622
09040:  MOVFF  01,621
09044:  MOVFF  00,620
09048:  MOVFF  61F,4E5
0904C:  MOVFF  61E,4E4
09050:  MOVLW  41
09052:  MOVWF  FE9
09054:  MOVFF  03,631
09058:  MOVFF  02,630
0905C:  MOVFF  01,62F
09060:  MOVFF  00,62E
09064:  RCALL  8C32
09066:  MOVLW  2C
09068:  MOVLB  6
0906A:  MOVWF  x3E
0906C:  MOVLB  0
0906E:  CALL   51A0
....................    }
09072:  BRA    9490
....................    else if (0 == strcmp(s_calibrated, arg2)) {
09074:  MOVFF  603,630
09078:  MOVFF  602,62F
0907C:  MOVFF  5FB,632
09080:  MOVFF  5FA,631
09084:  CALL   5128
09088:  MOVF   01,F
0908A:  BTFSS  FD8.2
0908C:  BRA    9218
....................       sprintf(retData+strlen(retData), "%d,", arg1);
0908E:  MOVLW  04
09090:  MOVLB  6
09092:  MOVWF  x30
09094:  MOVLW  40
09096:  MOVWF  x2F
09098:  MOVLB  0
0909A:  CALL   50F0
0909E:  MOVFF  02,03
090A2:  MOVF   01,W
090A4:  ADDLW  40
090A6:  MOVLB  6
090A8:  MOVWF  x1E
090AA:  MOVLW  04
090AC:  ADDWFC 02,W
090AE:  MOVWF  x1F
090B0:  MOVFF  FE8,4E5
090B4:  MOVFF  61E,4E4
090B8:  MOVFF  5F9,629
090BC:  MOVLW  18
090BE:  MOVWF  x2A
090C0:  MOVLB  0
090C2:  CALL   56AC
090C6:  MOVLW  2C
090C8:  MOVLB  6
090CA:  MOVWF  x3E
090CC:  MOVLB  0
090CE:  CALL   51A0
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].sinCounts);
090D2:  MOVLW  04
090D4:  MOVLB  6
090D6:  MOVWF  x30
090D8:  MOVLW  40
090DA:  MOVWF  x2F
090DC:  MOVLB  0
090DE:  CALL   50F0
090E2:  MOVF   01,W
090E4:  ADDLW  40
090E6:  MOVLB  6
090E8:  MOVWF  x1E
090EA:  MOVLW  04
090EC:  ADDWFC 02,W
090EE:  MOVWF  x1F
090F0:  MOVLW  01
090F2:  MOVLB  5
090F4:  SUBWF  xF9,W
090F6:  MULLW  21
090F8:  MOVF   FF3,W
090FA:  MOVLB  6
090FC:  CLRF   x21
090FE:  MOVWF  x20
09100:  MOVLW  08
09102:  ADDWF  x20,W
09104:  MOVWF  01
09106:  MOVLW  00
09108:  ADDWFC x21,W
0910A:  MOVWF  03
0910C:  MOVF   01,W
0910E:  ADDLW  0F
09110:  MOVWF  FE9
09112:  MOVLW  01
09114:  ADDWFC 03,W
09116:  MOVWF  FEA
09118:  MOVFF  FEF,63E
0911C:  MOVFF  FEC,01
09120:  MOVFF  FEC,02
09124:  MOVFF  FEC,03
09128:  MOVFF  03,641
0912C:  MOVFF  02,640
09130:  MOVFF  01,63F
09134:  MOVLB  0
09136:  CALL   4D00
0913A:  MOVFF  03,623
0913E:  MOVFF  02,622
09142:  MOVFF  01,621
09146:  MOVFF  00,620
0914A:  MOVFF  61F,4E5
0914E:  MOVFF  61E,4E4
09152:  MOVLW  41
09154:  MOVWF  FE9
09156:  MOVFF  03,631
0915A:  MOVFF  02,630
0915E:  MOVFF  01,62F
09162:  MOVFF  00,62E
09166:  RCALL  8C32
09168:  MOVLW  2C
0916A:  MOVLB  6
0916C:  MOVWF  x3E
0916E:  MOVLB  0
09170:  CALL   51A0
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].cosCounts);
09174:  MOVLW  04
09176:  MOVLB  6
09178:  MOVWF  x30
0917A:  MOVLW  40
0917C:  MOVWF  x2F
0917E:  MOVLB  0
09180:  CALL   50F0
09184:  MOVF   01,W
09186:  ADDLW  40
09188:  MOVLB  6
0918A:  MOVWF  x1E
0918C:  MOVLW  04
0918E:  ADDWFC 02,W
09190:  MOVWF  x1F
09192:  MOVLW  01
09194:  MOVLB  5
09196:  SUBWF  xF9,W
09198:  MULLW  21
0919A:  MOVF   FF3,W
0919C:  MOVLB  6
0919E:  CLRF   x21
091A0:  MOVWF  x20
091A2:  MOVLW  0C
091A4:  ADDWF  x20,W
091A6:  MOVWF  01
091A8:  MOVLW  00
091AA:  ADDWFC x21,W
091AC:  MOVWF  03
091AE:  MOVF   01,W
091B0:  ADDLW  0F
091B2:  MOVWF  FE9
091B4:  MOVLW  01
091B6:  ADDWFC 03,W
091B8:  MOVWF  FEA
091BA:  MOVFF  FEF,63E
091BE:  MOVFF  FEC,01
091C2:  MOVFF  FEC,02
091C6:  MOVFF  FEC,03
091CA:  MOVFF  03,641
091CE:  MOVFF  02,640
091D2:  MOVFF  01,63F
091D6:  MOVLB  0
091D8:  CALL   4D00
091DC:  MOVFF  03,623
091E0:  MOVFF  02,622
091E4:  MOVFF  01,621
091E8:  MOVFF  00,620
091EC:  MOVFF  61F,4E5
091F0:  MOVFF  61E,4E4
091F4:  MOVLW  41
091F6:  MOVWF  FE9
091F8:  MOVFF  03,631
091FC:  MOVFF  02,630
09200:  MOVFF  01,62F
09204:  MOVFF  00,62E
09208:  RCALL  8C32
0920A:  MOVLW  2C
0920C:  MOVLB  6
0920E:  MOVWF  x3E
09210:  MOVLB  0
09212:  CALL   51A0
....................    }
09216:  BRA    9490
....................    else if (0 == strcmp(s_p0, arg2)) {
09218:  MOVFF  60B,630
0921C:  MOVFF  60A,62F
09220:  MOVFF  5FB,632
09224:  MOVFF  5FA,631
09228:  CALL   5128
0922C:  MOVF   01,F
0922E:  BNZ   92EE
....................       sprintf(retData+strlen(retData), "%d,", arg1);
09230:  MOVLW  04
09232:  MOVLB  6
09234:  MOVWF  x30
09236:  MOVLW  40
09238:  MOVWF  x2F
0923A:  MOVLB  0
0923C:  CALL   50F0
09240:  MOVFF  02,03
09244:  MOVF   01,W
09246:  ADDLW  40
09248:  MOVLB  6
0924A:  MOVWF  x1E
0924C:  MOVLW  04
0924E:  ADDWFC 02,W
09250:  MOVWF  x1F
09252:  MOVFF  FE8,4E5
09256:  MOVFF  61E,4E4
0925A:  MOVFF  5F9,629
0925E:  MOVLW  18
09260:  MOVWF  x2A
09262:  MOVLB  0
09264:  CALL   56AC
09268:  MOVLW  2C
0926A:  MOVLB  6
0926C:  MOVWF  x3E
0926E:  MOVLB  0
09270:  CALL   51A0
....................       sprintf(retData+strlen(retData), "%f,", adcVals[arg1-1].p0);
09274:  MOVLW  04
09276:  MOVLB  6
09278:  MOVWF  x30
0927A:  MOVLW  40
0927C:  MOVWF  x2F
0927E:  MOVLB  0
09280:  CALL   50F0
09284:  MOVF   01,W
09286:  ADDLW  40
09288:  MOVLB  6
0928A:  MOVWF  x1E
0928C:  MOVLW  04
0928E:  ADDWFC 02,W
09290:  MOVWF  x1F
09292:  MOVLW  01
09294:  MOVLB  5
09296:  SUBWF  xF9,W
09298:  MULLW  21
0929A:  MOVF   FF3,W
0929C:  MOVLB  6
0929E:  CLRF   x21
092A0:  MOVWF  x20
092A2:  MOVLW  18
092A4:  ADDWF  x20,W
092A6:  MOVWF  01
092A8:  MOVLW  00
092AA:  ADDWFC x21,W
092AC:  MOVWF  03
092AE:  MOVF   01,W
092B0:  ADDLW  0F
092B2:  MOVWF  FE9
092B4:  MOVLW  01
092B6:  ADDWFC 03,W
092B8:  MOVWF  FEA
092BA:  MOVFF  FEF,631
092BE:  MOVFF  FEC,632
092C2:  MOVFF  FEC,633
092C6:  MOVFF  FEC,634
092CA:  MOVFF  61F,4E5
092CE:  MOVFF  61E,4E4
092D2:  MOVLW  89
092D4:  MOVWF  FE9
092D6:  MOVLW  02
092D8:  MOVWF  x35
092DA:  MOVLB  0
092DC:  CALL   5EE8
092E0:  MOVLW  2C
092E2:  MOVLB  6
092E4:  MOVWF  x3E
092E6:  MOVLB  0
092E8:  CALL   51A0
....................    }
092EC:  BRA    9490
....................    else if (0 == strcmp(s_poles, arg2)) {
092EE:  MOVFF  610,630
092F2:  MOVFF  60F,62F
092F6:  MOVFF  5FB,632
092FA:  MOVFF  5FA,631
092FE:  CALL   5128
09302:  MOVF   01,F
09304:  BNZ   93B4
....................       sprintf(retData+strlen(retData), "%d,", arg1);
09306:  MOVLW  04
09308:  MOVLB  6
0930A:  MOVWF  x30
0930C:  MOVLW  40
0930E:  MOVWF  x2F
09310:  MOVLB  0
09312:  CALL   50F0
09316:  MOVFF  02,03
0931A:  MOVF   01,W
0931C:  ADDLW  40
0931E:  MOVLB  6
09320:  MOVWF  x1E
09322:  MOVLW  04
09324:  ADDWFC 02,W
09326:  MOVWF  x1F
09328:  MOVFF  FE8,4E5
0932C:  MOVFF  61E,4E4
09330:  MOVFF  5F9,629
09334:  MOVLW  18
09336:  MOVWF  x2A
09338:  MOVLB  0
0933A:  CALL   56AC
0933E:  MOVLW  2C
09340:  MOVLB  6
09342:  MOVWF  x3E
09344:  MOVLB  0
09346:  CALL   51A0
....................       sprintf(retData+strlen(retData), "%d,", adcVals[arg1-1].npoles);
0934A:  MOVLW  04
0934C:  MOVLB  6
0934E:  MOVWF  x30
09350:  MOVLW  40
09352:  MOVWF  x2F
09354:  MOVLB  0
09356:  CALL   50F0
0935A:  MOVF   01,W
0935C:  ADDLW  40
0935E:  MOVLB  6
09360:  MOVWF  x1E
09362:  MOVLW  04
09364:  ADDWFC 02,W
09366:  MOVWF  x1F
09368:  MOVLW  01
0936A:  MOVLB  5
0936C:  SUBWF  xF9,W
0936E:  MULLW  21
09370:  MOVF   FF3,W
09372:  MOVLB  6
09374:  CLRF   x21
09376:  MOVWF  x20
09378:  MOVLW  1C
0937A:  ADDWF  x20,W
0937C:  MOVWF  01
0937E:  MOVLW  00
09380:  ADDWFC x21,W
09382:  MOVWF  03
09384:  MOVF   01,W
09386:  ADDLW  0F
09388:  MOVWF  FE9
0938A:  MOVLW  01
0938C:  ADDWFC 03,W
0938E:  MOVWF  FEA
09390:  MOVFF  FEF,629
09394:  MOVFF  61F,4E5
09398:  MOVFF  61E,4E4
0939C:  MOVLW  18
0939E:  MOVWF  x2A
093A0:  MOVLB  0
093A2:  CALL   56AC
093A6:  MOVLW  2C
093A8:  MOVLB  6
093AA:  MOVWF  x3E
093AC:  MOVLB  0
093AE:  CALL   51A0
....................    }
093B2:  BRA    9490
....................    else if (0 == strcmp(s_real, arg2)) {
093B4:  MOVFF  618,630
093B8:  MOVFF  617,62F
093BC:  MOVFF  5FB,632
093C0:  MOVFF  5FA,631
093C4:  CALL   5128
093C8:  MOVF   01,F
093CA:  BNZ   948A
....................       sprintf(retData+strlen(retData), "%d,", arg1);
093CC:  MOVLW  04
093CE:  MOVLB  6
093D0:  MOVWF  x30
093D2:  MOVLW  40
093D4:  MOVWF  x2F
093D6:  MOVLB  0
093D8:  CALL   50F0
093DC:  MOVFF  02,03
093E0:  MOVF   01,W
093E2:  ADDLW  40
093E4:  MOVLB  6
093E6:  MOVWF  x1E
093E8:  MOVLW  04
093EA:  ADDWFC 02,W
093EC:  MOVWF  x1F
093EE:  MOVFF  FE8,4E5
093F2:  MOVFF  61E,4E4
093F6:  MOVFF  5F9,629
093FA:  MOVLW  18
093FC:  MOVWF  x2A
093FE:  MOVLB  0
09400:  CALL   56AC
09404:  MOVLW  2C
09406:  MOVLB  6
09408:  MOVWF  x3E
0940A:  MOVLB  0
0940C:  CALL   51A0
....................       sprintf(retData+strlen(retData), "%f,", adcVals[arg1-1].pReal);
09410:  MOVLW  04
09412:  MOVLB  6
09414:  MOVWF  x30
09416:  MOVLW  40
09418:  MOVWF  x2F
0941A:  MOVLB  0
0941C:  CALL   50F0
09420:  MOVF   01,W
09422:  ADDLW  40
09424:  MOVLB  6
09426:  MOVWF  x1E
09428:  MOVLW  04
0942A:  ADDWFC 02,W
0942C:  MOVWF  x1F
0942E:  MOVLW  01
09430:  MOVLB  5
09432:  SUBWF  xF9,W
09434:  MULLW  21
09436:  MOVF   FF3,W
09438:  MOVLB  6
0943A:  CLRF   x21
0943C:  MOVWF  x20
0943E:  MOVLW  1D
09440:  ADDWF  x20,W
09442:  MOVWF  01
09444:  MOVLW  00
09446:  ADDWFC x21,W
09448:  MOVWF  03
0944A:  MOVF   01,W
0944C:  ADDLW  0F
0944E:  MOVWF  FE9
09450:  MOVLW  01
09452:  ADDWFC 03,W
09454:  MOVWF  FEA
09456:  MOVFF  FEF,631
0945A:  MOVFF  FEC,632
0945E:  MOVFF  FEC,633
09462:  MOVFF  FEC,634
09466:  MOVFF  61F,4E5
0946A:  MOVFF  61E,4E4
0946E:  MOVLW  89
09470:  MOVWF  FE9
09472:  MOVLW  02
09474:  MOVWF  x35
09476:  MOVLB  0
09478:  CALL   5EE8
0947C:  MOVLW  2C
0947E:  MOVLB  6
09480:  MOVWF  x3E
09482:  MOVLB  0
09484:  CALL   51A0
....................    }
09488:  BRA    9490
....................    else return INV_PARAM;
0948A:  MOVLW  02
0948C:  MOVWF  01
0948E:  BRA    9494
....................    
....................    return SUCCESS;
09490:  MOVLW  00
09492:  MOVWF  01
09494:  RETURN 0
.................... }
.................... 
.................... int8 getManOPvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
09496:  MOVLB  6
09498:  CLRF   x30
0949A:  MOVFF  5ED,62F
0949E:  CLRF   x32
094A0:  MOVLW  B5
094A2:  MOVWF  x31
094A4:  MOVLB  0
094A6:  CALL   087E
094AA:  MOVFF  02,5FB
094AE:  MOVFF  01,5FA
094B2:  MOVLW  06
094B4:  MOVLB  5
094B6:  ADDWF  xFA,F
094B8:  MOVLW  00
094BA:  ADDWFC xFB,F
094BC:  MOVLW  32
094BE:  ADDWF  xFA,W
094C0:  MOVWF  01
094C2:  MOVLW  00
094C4:  ADDWFC xFB,W
094C6:  MOVWF  03
094C8:  MOVF   01,W
094CA:  ADDLW  6A
094CC:  MOVWF  01
094CE:  MOVLW  01
094D0:  ADDWFC 03,F
094D2:  MOVFF  01,5FA
094D6:  MOVFF  03,5FB
094DA:  MOVFF  03,629
094DE:  MOVFF  01,628
094E2:  MOVLB  0
094E4:  CALL   5268
094E8:  MOVF   01,F
094EA:  BNZ   94F4
094EC:  MOVLW  02
094EE:  MOVWF  01
094F0:  BRA    95EA
094F2:  BRA    9554
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
094F4:  MOVLB  6
094F6:  CLRF   x30
094F8:  MOVFF  5ED,62F
094FC:  CLRF   x32
094FE:  MOVLW  B5
09500:  MOVWF  x31
09502:  MOVLB  0
09504:  CALL   087E
09508:  MOVFF  02,5FB
0950C:  MOVFF  01,5FA
09510:  MOVLW  06
09512:  MOVLB  5
09514:  ADDWF  xFA,F
09516:  MOVLW  00
09518:  ADDWFC xFB,F
0951A:  MOVLW  32
0951C:  ADDWF  xFA,W
0951E:  MOVWF  01
09520:  MOVLW  00
09522:  ADDWFC xFB,W
09524:  MOVWF  03
09526:  MOVF   01,W
09528:  ADDLW  6A
0952A:  MOVWF  01
0952C:  MOVLW  01
0952E:  ADDWFC 03,F
09530:  MOVFF  01,5FA
09534:  MOVFF  03,5FB
09538:  MOVFF  03,629
0953C:  MOVFF  01,628
09540:  MOVLB  6
09542:  CLRF   x2B
09544:  CLRF   x2A
09546:  MOVLW  0A
09548:  MOVWF  x2C
0954A:  MOVLB  0
0954C:  CALL   5358
09550:  MOVFF  01,5F9
....................    
....................    /*** GET MANUAL OUTPUT VALUE ***************/ 
....................    sprintf(retData+strlen(retData), "%d,%f,", arg1, manualOutputValues[arg1-1]);
09554:  MOVLW  04
09556:  MOVLB  6
09558:  MOVWF  x30
0955A:  MOVLW  40
0955C:  MOVWF  x2F
0955E:  MOVLB  0
09560:  CALL   50F0
09564:  MOVF   01,W
09566:  ADDLW  40
09568:  MOVLB  5
0956A:  MOVWF  xFA
0956C:  MOVLW  04
0956E:  ADDWFC 02,W
09570:  MOVWF  xFB
09572:  MOVLW  01
09574:  SUBWF  xF9,W
09576:  MULLW  04
09578:  MOVF   FF3,W
0957A:  CLRF   03
0957C:  ADDLW  EA
0957E:  MOVWF  FE9
09580:  MOVLW  00
09582:  ADDWFC 03,W
09584:  MOVWF  FEA
09586:  MOVFF  FEF,5FC
0958A:  MOVFF  FEC,5FD
0958E:  MOVFF  FEC,5FE
09592:  MOVFF  FEC,5FF
09596:  MOVFF  5FB,4E5
0959A:  MOVFF  5FA,4E4
0959E:  MOVFF  5F9,629
095A2:  MOVLW  18
095A4:  MOVLB  6
095A6:  MOVWF  x2A
095A8:  MOVLB  0
095AA:  CALL   56AC
095AE:  MOVLW  2C
095B0:  MOVLB  6
095B2:  MOVWF  x3E
095B4:  MOVLB  0
095B6:  CALL   51A0
095BA:  MOVLW  89
095BC:  MOVWF  FE9
095BE:  MOVFF  5FF,634
095C2:  MOVFF  5FE,633
095C6:  MOVFF  5FD,632
095CA:  MOVFF  5FC,631
095CE:  MOVLW  02
095D0:  MOVLB  6
095D2:  MOVWF  x35
095D4:  MOVLB  0
095D6:  CALL   5EE8
095DA:  MOVLW  2C
095DC:  MOVLB  6
095DE:  MOVWF  x3E
095E0:  MOVLB  0
095E2:  CALL   51A0
....................    
....................    return SUCCESS;
095E6:  MOVLW  00
095E8:  MOVWF  01
095EA:  RETURN 0
.................... }
.................... 
.................... int8 setManOPvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    float arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
095EC:  MOVLB  6
095EE:  CLRF   x30
095F0:  MOVFF  5ED,62F
095F4:  CLRF   x32
095F6:  MOVLW  B5
095F8:  MOVWF  x31
095FA:  MOVLB  0
095FC:  CALL   087E
09600:  MOVFF  02,5FF
09604:  MOVFF  01,5FE
09608:  MOVLW  06
0960A:  MOVLB  5
0960C:  ADDWF  xFE,F
0960E:  MOVLW  00
09610:  ADDWFC xFF,F
09612:  MOVLW  32
09614:  ADDWF  xFE,W
09616:  MOVWF  01
09618:  MOVLW  00
0961A:  ADDWFC xFF,W
0961C:  MOVWF  03
0961E:  MOVF   01,W
09620:  ADDLW  6A
09622:  MOVWF  01
09624:  MOVLW  01
09626:  ADDWFC 03,F
09628:  MOVFF  01,5FE
0962C:  MOVFF  03,5FF
09630:  MOVFF  03,629
09634:  MOVFF  01,628
09638:  MOVLB  0
0963A:  CALL   5268
0963E:  MOVF   01,F
09640:  BNZ   964A
09642:  MOVLW  02
09644:  MOVWF  01
09646:  BRA    9830
09648:  BRA    96AA
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
0964A:  MOVLB  6
0964C:  CLRF   x30
0964E:  MOVFF  5ED,62F
09652:  CLRF   x32
09654:  MOVLW  B5
09656:  MOVWF  x31
09658:  MOVLB  0
0965A:  CALL   087E
0965E:  MOVFF  02,5FF
09662:  MOVFF  01,5FE
09666:  MOVLW  06
09668:  MOVLB  5
0966A:  ADDWF  xFE,F
0966C:  MOVLW  00
0966E:  ADDWFC xFF,F
09670:  MOVLW  32
09672:  ADDWF  xFE,W
09674:  MOVWF  01
09676:  MOVLW  00
09678:  ADDWFC xFF,W
0967A:  MOVWF  03
0967C:  MOVF   01,W
0967E:  ADDLW  6A
09680:  MOVWF  01
09682:  MOVLW  01
09684:  ADDWFC 03,F
09686:  MOVFF  01,5FE
0968A:  MOVFF  03,5FF
0968E:  MOVFF  03,629
09692:  MOVFF  01,628
09696:  MOVLB  6
09698:  CLRF   x2B
0969A:  CLRF   x2A
0969C:  MOVLW  0A
0969E:  MOVWF  x2C
096A0:  MOVLB  0
096A2:  CALL   5358
096A6:  MOVFF  01,5F9
....................    
....................    if (!arg_is_float(SERcmd[rec].p[3])) return INV_PARAM;
096AA:  MOVLB  6
096AC:  CLRF   x30
096AE:  MOVFF  5ED,62F
096B2:  CLRF   x32
096B4:  MOVLW  B5
096B6:  MOVWF  x31
096B8:  MOVLB  0
096BA:  CALL   087E
096BE:  MOVFF  02,5FF
096C2:  MOVFF  01,5FE
096C6:  MOVLW  06
096C8:  MOVLB  5
096CA:  ADDWF  xFE,F
096CC:  MOVLW  00
096CE:  ADDWFC xFF,F
096D0:  MOVLW  4B
096D2:  ADDWF  xFE,W
096D4:  MOVWF  01
096D6:  MOVLW  00
096D8:  ADDWFC xFF,W
096DA:  MOVWF  03
096DC:  MOVF   01,W
096DE:  ADDLW  6A
096E0:  MOVWF  01
096E2:  MOVLW  01
096E4:  ADDWFC 03,F
096E6:  MOVFF  01,5FE
096EA:  MOVFF  03,5FF
096EE:  MOVFF  03,603
096F2:  MOVFF  01,602
096F6:  MOVLB  0
096F8:  CALL   6574
096FC:  MOVF   01,F
096FE:  BNZ   9708
09700:  MOVLW  02
09702:  MOVWF  01
09704:  BRA    9830
09706:  BRA    9770
....................    else arg2 = strtod(SERcmd[rec].p[3], '\0');
09708:  MOVLB  6
0970A:  CLRF   x30
0970C:  MOVFF  5ED,62F
09710:  CLRF   x32
09712:  MOVLW  B5
09714:  MOVWF  x31
09716:  MOVLB  0
09718:  CALL   087E
0971C:  MOVFF  02,5FF
09720:  MOVFF  01,5FE
09724:  MOVLW  06
09726:  MOVLB  5
09728:  ADDWF  xFE,F
0972A:  MOVLW  00
0972C:  ADDWFC xFF,F
0972E:  MOVLW  4B
09730:  ADDWF  xFE,W
09732:  MOVWF  01
09734:  MOVLW  00
09736:  ADDWFC xFF,W
09738:  MOVWF  03
0973A:  MOVF   01,W
0973C:  ADDLW  6A
0973E:  MOVWF  01
09740:  MOVLW  01
09742:  ADDWFC 03,F
09744:  MOVFF  01,5FE
09748:  MOVFF  03,5FF
0974C:  MOVFF  03,603
09750:  MOVFF  01,602
09754:  MOVLB  6
09756:  CLRF   x05
09758:  CLRF   x04
0975A:  MOVLB  0
0975C:  CALL   6636
09760:  MOVFF  03,5FD
09764:  MOVFF  02,5FC
09768:  MOVFF  01,5FB
0976C:  MOVFF  00,5FA
....................    
....................    /*** SET MANUAL OUTPUT VALUE ***************/
....................    if (arg2 > op_upper_bound) manualOutputValues[arg1-1] = op_upper_bound;
09770:  MOVLB  6
09772:  CLRF   x4E
09774:  CLRF   x4D
09776:  MOVLW  7C
09778:  MOVWF  x4C
0977A:  MOVLW  84
0977C:  MOVWF  x4B
0977E:  MOVFF  5FD,652
09782:  MOVFF  5FC,651
09786:  MOVFF  5FB,650
0978A:  MOVFF  5FA,64F
0978E:  MOVLB  0
09790:  CALL   146C
09794:  BNC   97BA
09796:  MOVLW  01
09798:  MOVLB  5
0979A:  SUBWF  xF9,W
0979C:  MULLW  04
0979E:  MOVF   FF3,W
097A0:  CLRF   03
097A2:  ADDLW  EA
097A4:  MOVWF  FE9
097A6:  MOVLW  00
097A8:  ADDWFC 03,W
097AA:  MOVWF  FEA
097AC:  MOVLW  84
097AE:  MOVWF  FEF
097B0:  MOVLW  7C
097B2:  MOVWF  FEC
097B4:  CLRF   FEC
097B6:  CLRF   FEC
097B8:  BRA    982A
....................    else if (arg2 < op_lower_bound) manualOutputValues[arg1-1] = op_lower_bound;  
097BA:  MOVFF  5FD,64E
097BE:  MOVFF  5FC,64D
097C2:  MOVFF  5FB,64C
097C6:  MOVFF  5FA,64B
097CA:  MOVLB  6
097CC:  CLRF   x52
097CE:  CLRF   x51
097D0:  MOVLW  FC
097D2:  MOVWF  x50
097D4:  MOVLW  84
097D6:  MOVWF  x4F
097D8:  MOVLB  0
097DA:  CALL   146C
097DE:  BNC   9804
097E0:  MOVLW  01
097E2:  MOVLB  5
097E4:  SUBWF  xF9,W
097E6:  MULLW  04
097E8:  MOVF   FF3,W
097EA:  CLRF   03
097EC:  ADDLW  EA
097EE:  MOVWF  FE9
097F0:  MOVLW  00
097F2:  ADDWFC 03,W
097F4:  MOVWF  FEA
097F6:  MOVLW  84
097F8:  MOVWF  FEF
097FA:  MOVLW  FC
097FC:  MOVWF  FEC
097FE:  CLRF   FEC
09800:  CLRF   FEC
09802:  BRA    982A
....................    else manualOutputValues[arg1-1] = arg2;
09804:  MOVLW  01
09806:  MOVLB  5
09808:  SUBWF  xF9,W
0980A:  MULLW  04
0980C:  MOVF   FF3,W
0980E:  CLRF   03
09810:  ADDLW  EA
09812:  MOVWF  FE9
09814:  MOVLW  00
09816:  ADDWFC 03,W
09818:  MOVWF  FEA
0981A:  MOVFF  5FA,FEF
0981E:  MOVFF  5FB,FEC
09822:  MOVFF  5FC,FEC
09826:  MOVFF  5FD,FEC
....................    
....................    return SUCCESS;
0982A:  MOVLW  00
0982C:  MOVWF  01
0982E:  MOVLB  0
09830:  RETURN 0
.................... }
.................... 
.................... int8 invalidCmd(unsigned int8 rec){
....................    return INV_CMD;
09832:  MOVLW  01
09834:  MOVWF  01
09836:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* ARG VALIDATION HELPER FUNCS                                               */
.................... /*****************************************************************************/
.................... BOOLEAN arg_is_float(char *arg){
*
06574:  MOVLB  6
06576:  BCF    x04.0
....................    BOOLEAN decimal = FALSE;
....................    for (int i=0; i<strlen(arg); i++){
06578:  CLRF   x05
0657A:  MOVFF  603,630
0657E:  MOVFF  602,62F
06582:  MOVLB  0
06584:  CALL   50F0
06588:  MOVFF  02,03
0658C:  MOVF   01,W
0658E:  MOVF   03,F
06590:  BNZ   659C
06592:  MOVF   01,W
06594:  MOVLB  6
06596:  SUBWF  x05,W
06598:  BC    662E
0659A:  MOVLB  0
....................       if (!isdigit(arg[i])){
0659C:  MOVLB  6
0659E:  MOVF   x05,W
065A0:  ADDWF  x02,W
065A2:  MOVWF  FE9
065A4:  MOVLW  00
065A6:  ADDWFC x03,W
065A8:  MOVWF  FEA
065AA:  MOVFF  FEF,606
065AE:  MOVF   x06,W
065B0:  SUBLW  2F
065B2:  BC    65BA
065B4:  MOVF   x06,W
065B6:  SUBLW  39
065B8:  BC    6626
....................          // Check for negative sign
....................          if ('-' != arg[i]){
065BA:  MOVF   x05,W
065BC:  ADDWF  x02,W
065BE:  MOVWF  FE9
065C0:  MOVLW  00
065C2:  ADDWFC x03,W
065C4:  MOVWF  FEA
065C6:  MOVF   FEF,W
065C8:  SUBLW  2D
065CA:  BZ    65F6
....................             // Check for decimal
....................             if ('.' != arg[i]) return FALSE;
065CC:  MOVF   x05,W
065CE:  ADDWF  x02,W
065D0:  MOVWF  FE9
065D2:  MOVLW  00
065D4:  ADDWFC x03,W
065D6:  MOVWF  FEA
065D8:  MOVF   FEF,W
065DA:  SUBLW  2E
065DC:  BZ    65E6
065DE:  MOVLW  00
065E0:  MOVWF  01
065E2:  BRA    6632
065E4:  BRA    65F4
....................             else if  (decimal) return FALSE;
065E6:  BTFSS  x04.0
065E8:  BRA    65F2
065EA:  MOVLW  00
065EC:  MOVWF  01
065EE:  BRA    6632
065F0:  BRA    65F4
....................             else decimal = TRUE;
065F2:  BSF    x04.0
....................          }
065F4:  BRA    6626
....................          else if (0 != i) return FALSE;
065F6:  MOVF   x05,F
065F8:  BZ    6602
065FA:  MOVLW  00
065FC:  MOVWF  01
065FE:  BRA    6632
06600:  BRA    6626
....................          else if (1 == strlen(arg)) return FALSE;
06602:  MOVFF  603,630
06606:  MOVFF  602,62F
0660A:  MOVLB  0
0660C:  CALL   50F0
06610:  MOVFF  02,03
06614:  MOVF   01,W
06616:  SUBLW  01
06618:  BNZ   6628
0661A:  MOVF   03,F
0661C:  BNZ   6628
0661E:  MOVLW  00
06620:  MOVWF  01
06622:  MOVLB  6
06624:  BRA    6632
06626:  MOVLB  0
....................       }
06628:  MOVLB  6
0662A:  INCF   x05,F
0662C:  BRA    657A
....................    }
....................    return TRUE;
0662E:  MOVLW  01
06630:  MOVWF  01
06632:  MOVLB  0
06634:  RETURN 0
.................... }
.................... 
.................... BOOLEAN is_valid_channel(char *arg){
....................     if (1 != strlen(arg)) return FALSE;
*
05268:  MOVFF  629,630
0526C:  MOVFF  628,62F
05270:  RCALL  50F0
05272:  MOVFF  02,03
05276:  MOVF   01,W
05278:  SUBLW  01
0527A:  BNZ   5280
0527C:  MOVF   03,F
0527E:  BZ    5288
05280:  MOVLW  00
05282:  MOVWF  01
05284:  BRA    52B6
05286:  BRA    52AE
....................     else if ('1' != arg[0] && '2' != arg[0]) return FALSE;
05288:  MOVLB  6
0528A:  MOVFF  628,FE9
0528E:  MOVFF  629,FEA
05292:  MOVF   FEF,W
05294:  SUBLW  31
05296:  BZ    52B0
05298:  MOVFF  628,FE9
0529C:  MOVFF  629,FEA
052A0:  MOVF   FEF,W
052A2:  SUBLW  32
052A4:  BZ    52B0
052A6:  MOVLW  00
052A8:  MOVWF  01
052AA:  MOVLB  0
052AC:  BRA    52B6
052AE:  MOVLB  6
....................     return TRUE;
052B0:  MOVLW  01
052B2:  MOVWF  01
052B4:  MOVLB  0
052B6:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* ASCII HEX CHARACTER TO INT                                                */
.................... /*****************************************************************************/
.................... int8 hex_to_int(char ascii){
....................    if (ascii >= '0' && ascii <= '9') return ascii-'0';
*
050B6:  MOVLB  5
050B8:  MOVF   xF8,W
050BA:  SUBLW  2F
050BC:  BC    50CE
050BE:  MOVF   xF8,W
050C0:  SUBLW  39
050C2:  BNC   50CE
050C4:  MOVLW  30
050C6:  SUBWF  xF8,W
050C8:  MOVWF  01
050CA:  BRA    50EA
050CC:  BRA    50EA
....................    else if (ascii >= 'A' && ascii <= 'F') return ascii-'A'+10;
050CE:  MOVF   xF8,W
050D0:  SUBLW  40
050D2:  BC    50E6
050D4:  MOVF   xF8,W
050D6:  SUBLW  46
050D8:  BNC   50E6
050DA:  MOVLW  41
050DC:  SUBWF  xF8,W
050DE:  ADDLW  0A
050E0:  MOVWF  01
050E2:  BRA    50EA
050E4:  BRA    50EA
....................    else return 0xFF;
050E6:  MOVLW  FF
050E8:  MOVWF  01
050EA:  MOVLB  0
050EC:  GOTO   98DE (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* COMMAND HANDLER/PARSER FUNCS                                              */
.................... /*****************************************************************************/
.................... void echo_cmd(unsigned int8 rec){
....................    fprintf(SERIAL, "%c", SERcmd[rec].t);
....................    while (SERcmd[rec].recReadIndex <= SERcmd[rec].recWriteIndex)
....................    {
....................       if (SERcmd[rec].recReadIndex != 0) fprintf(SERIAL, "%c", delimiter);
....................       fprintf(SERIAL, "%s", SERcmd[rec].p[SERcmd[rec].recReadIndex]);
....................       SERcmd[rec].recReadIndex++;
....................    }
....................    SERcmd[rec].recReadIndex=0;
.................... }
.................... 
.................... int8 command_parser(unsigned int8 rec){
*
09838:  MOVLB  6
0983A:  CLRF   x30
0983C:  MOVFF  5EF,62F
09840:  CLRF   x32
09842:  MOVLW  B5
09844:  MOVWF  x31
09846:  MOVLB  0
09848:  CALL   087E
0984C:  MOVFF  02,5F8
09850:  MOVFF  01,5F7
09854:  MOVLW  06
09856:  MOVLB  5
09858:  ADDWF  xF7,F
0985A:  MOVLW  00
0985C:  ADDWFC xF8,F
0985E:  MOVLW  6A
09860:  ADDWF  xF7,W
09862:  MOVWF  01
09864:  MOVLW  01
09866:  ADDWFC xF8,W
09868:  MOVWF  03
0986A:  MOVFF  01,5F0
0986E:  MOVWF  xF1
09870:  MOVLB  6
09872:  CLRF   x30
09874:  MOVFF  5EF,62F
09878:  CLRF   x32
0987A:  MOVLW  B5
0987C:  MOVWF  x31
0987E:  MOVLB  0
09880:  CALL   087E
09884:  MOVFF  02,5FA
09888:  MOVFF  01,5F9
0988C:  MOVLW  06
0988E:  MOVLB  5
09890:  ADDWF  xF9,F
09892:  MOVLW  00
09894:  ADDWFC xFA,F
09896:  MOVLW  19
09898:  ADDWF  xF9,W
0989A:  MOVWF  01
0989C:  MOVLW  00
0989E:  ADDWFC xFA,W
098A0:  MOVWF  03
098A2:  MOVF   01,W
098A4:  ADDLW  6A
098A6:  MOVWF  01
098A8:  MOVLW  01
098AA:  ADDWFC 03,F
098AC:  MOVFF  01,5F2
098B0:  MOVFF  03,5F3
098B4:  CLRF   xF4
098B6:  CLRF   xF5
....................    char *cmd_adr = SERcmd[rec].p[0];
....................    char *cmd_str = SERcmd[rec].p[1];
.................... //!   int8 devID = input_a();
....................    int8 devID = 0;
....................    int8 i = 0;
....................    
....................    if (hwID == cmd_adr[0]){
098B8:  MOVFF  5F0,FE9
098BC:  MOVFF  5F1,FEA
098C0:  MOVF   FEF,W
098C2:  SUBLW  44
098C4:  BTFSS  FD8.2
098C6:  BRA    99B6
....................       if (hex_to_int(cmd_adr[1]) == (devID & 0x0F)){
098C8:  MOVLW  01
098CA:  ADDWF  xF0,W
098CC:  MOVWF  FE9
098CE:  MOVLW  00
098D0:  ADDWFC xF1,W
098D2:  MOVWF  FEA
098D4:  MOVFF  FEF,5F8
098D8:  MOVLB  0
098DA:  GOTO   50B6
098DE:  MOVFF  01,5F7
098E2:  MOVLB  5
098E4:  MOVF   xF4,W
098E6:  ANDLW  0F
098E8:  SUBWF  01,W
098EA:  BNZ   99AE
....................          while (0 != strlen(cmd_list[i].cmd_name)){
098EC:  MOVF   xF5,W
098EE:  MULLW  04
098F0:  MOVF   FF3,W
098F2:  CLRF   xF8
098F4:  MOVWF  xF7
098F6:  MOVLW  EA
098F8:  ADDWF  xF7,W
098FA:  MOVWF  FE9
098FC:  MOVLW  04
098FE:  ADDWFC xF8,W
09900:  MOVWF  FEA
09902:  MOVFF  FEC,630
09906:  MOVF   FED,F
09908:  MOVFF  FEF,62F
0990C:  MOVLB  0
0990E:  CALL   50F0
09912:  MOVFF  02,03
09916:  MOVF   01,W
09918:  BNZ   991E
0991A:  MOVF   03,F
0991C:  BZ    99A4
....................             if (0 == strcmp(cmd_str, cmd_list[i].cmd_name))
0991E:  MOVLB  5
09920:  MOVF   xF5,W
09922:  MULLW  04
09924:  MOVF   FF3,W
09926:  CLRF   xF8
09928:  MOVWF  xF7
0992A:  MOVLW  EA
0992C:  ADDWF  xF7,W
0992E:  MOVWF  FE9
09930:  MOVLW  04
09932:  ADDWFC xF8,W
09934:  MOVWF  FEA
09936:  MOVFF  FEC,632
0993A:  MOVF   FED,F
0993C:  MOVFF  FEF,631
09940:  MOVFF  5F3,630
09944:  MOVFF  5F2,62F
09948:  MOVLB  0
0994A:  CALL   5128
0994E:  MOVF   01,F
09950:  BNZ   999C
....................             {
....................                int8 return_code = cmd_list[i].cmd_func(rec);
09952:  MOVLB  5
09954:  MOVF   xF5,W
09956:  MULLW  04
09958:  MOVF   FF3,W
0995A:  CLRF   xF8
0995C:  MOVWF  xF7
0995E:  MOVLW  02
09960:  ADDWF  xF7,W
09962:  MOVWF  01
09964:  MOVLW  00
09966:  ADDWFC xF8,W
09968:  MOVWF  03
0996A:  MOVF   01,W
0996C:  ADDLW  EA
0996E:  MOVWF  01
09970:  MOVLW  04
09972:  ADDWFC 03,F
09974:  MOVFF  01,5F7
09978:  MOVFF  03,5F8
0997C:  MOVFF  03,FEA
09980:  MOVFF  01,FE9
09984:  MOVFF  5EF,5ED
09988:  MOVLB  0
0998A:  CALL   00BC
0998E:  MOVFF  01,5F6
....................                return return_code;
09992:  MOVLB  5
09994:  MOVFF  5F6,01
09998:  BRA    99BA
0999A:  MOVLB  0
....................             }
....................             i++;
0999C:  MOVLB  5
0999E:  INCF   xF5,F
099A0:  BRA    98EC
099A2:  MOVLB  0
....................          }
....................          return INV_CMD; // INVALID_CMD
099A4:  MOVLW  01
099A6:  MOVWF  01
099A8:  MOVLB  5
099AA:  BRA    99BA
....................       } else return 254; // NOT THIS ADDRESS
099AC:  BRA    99B4
099AE:  MOVLW  FE
099B0:  MOVWF  01
099B2:  BRA    99BA
....................    } else return 255; // NOT THIS DEVICE TYPE
099B4:  BRA    99BA
099B6:  MOVLW  FF
099B8:  MOVWF  01
099BA:  MOVLB  0
099BC:  GOTO   99F6 (RETURN)
.................... }
.................... 
.................... void command_handler_task(){
....................    while (getNextSERReadIndex())
*
099E8:  GOTO   505C
099EC:  MOVF   01,F
099EE:  BZ    9AE0
....................    {
....................       int8 return_code = command_parser(SRI);
099F0:  MOVFF  43E,5EF
099F4:  BRA    9838
099F6:  MOVFF  01,5EE
....................       //echo_cmd(SRI);
....................       sprintf(retData + strlen(retData), "%s", resp_list[return_code].msg);
099FA:  MOVLW  04
099FC:  MOVLB  6
099FE:  MOVWF  x30
09A00:  MOVLW  40
09A02:  MOVWF  x2F
09A04:  MOVLB  0
09A06:  CALL   50F0
09A0A:  MOVF   01,W
09A0C:  ADDLW  40
09A0E:  MOVLB  5
09A10:  MOVWF  xEF
09A12:  MOVLW  04
09A14:  ADDWFC 02,W
09A16:  MOVWF  xF0
09A18:  MOVF   xEE,W
09A1A:  MULLW  03
09A1C:  MOVF   FF3,W
09A1E:  CLRF   xF2
09A20:  MOVWF  xF1
09A22:  MOVLW  01
09A24:  ADDWF  xF1,W
09A26:  MOVWF  01
09A28:  MOVLW  00
09A2A:  ADDWFC xF2,W
09A2C:  MOVWF  03
09A2E:  MOVF   01,W
09A30:  ADDLW  B9
09A32:  MOVWF  FE9
09A34:  MOVLW  05
09A36:  ADDWFC 03,W
09A38:  MOVWF  FEA
09A3A:  MOVFF  FEC,5F2
09A3E:  MOVF   FED,F
09A40:  MOVFF  FEF,5F1
09A44:  MOVFF  5F0,4E5
09A48:  MOVFF  5EF,4E4
09A4C:  MOVFF  4E5,FEA
09A50:  MOVFF  4E4,FE9
09A54:  CLRF   FEF
09A56:  MOVFF  5F2,FEA
09A5A:  MOVFF  5F1,FE9
09A5E:  MOVLB  0
09A60:  BRA    99C0
....................       fprintf(SERIAL, "$%s,%s\n", SERcmd[SRI].p[0], retData);
09A62:  MOVLB  6
09A64:  CLRF   x30
09A66:  MOVFF  43E,62F
09A6A:  CLRF   x32
09A6C:  MOVLW  B5
09A6E:  MOVWF  x31
09A70:  MOVLB  0
09A72:  CALL   087E
09A76:  MOVFF  02,5F0
09A7A:  MOVFF  01,5EF
09A7E:  MOVLW  06
09A80:  MOVLB  5
09A82:  ADDWF  xEF,F
09A84:  MOVLW  00
09A86:  ADDWFC xF0,F
09A88:  MOVLW  6A
09A8A:  ADDWF  xEF,W
09A8C:  MOVWF  01
09A8E:  MOVLW  01
09A90:  ADDWFC xF0,W
09A92:  MOVWF  03
09A94:  MOVFF  01,5F1
09A98:  MOVWF  xF2
09A9A:  MOVLW  24
09A9C:  MOVLB  6
09A9E:  MOVWF  x00
09AA0:  MOVLB  0
09AA2:  CALL   46CC
09AA6:  MOVFF  5F2,FEA
09AAA:  MOVFF  5F1,FE9
09AAE:  CALL   46F4
09AB2:  MOVLW  2C
09AB4:  MOVLB  6
09AB6:  MOVWF  x00
09AB8:  MOVLB  0
09ABA:  CALL   46CC
09ABE:  MOVLW  04
09AC0:  MOVWF  FEA
09AC2:  MOVLW  40
09AC4:  MOVWF  FE9
09AC6:  CALL   46F4
09ACA:  MOVLW  0A
09ACC:  MOVLB  6
09ACE:  MOVWF  x00
09AD0:  MOVLB  0
09AD2:  CALL   46CC
....................       
....................       resetSERcmd(SRI);
09AD6:  MOVFF  43E,5EF
09ADA:  CALL   08A0
09ADE:  BRA    99E8
....................    }
09AE0:  GOTO   9FB2 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... #define DEBUG_1
.................... 
.................... void main()
09AE4:  CLRF   FF8
09AE6:  BCF    FF2.5
09AE8:  BSF    07.7
09AEA:  MOVLB  E
09AEC:  MOVLW  55
09AEE:  MOVWF  x9B
09AF0:  MOVLW  AA
09AF2:  MOVWF  x9B
09AF4:  BCF    x9B.0
09AF6:  MOVLW  17
09AF8:  MOVWF  xB0
09AFA:  MOVLW  13
09AFC:  MOVWF  xB2
09AFE:  MOVLW  09
09B00:  MOVWF  x8A
09B02:  MOVLW  0A
09B04:  MOVWF  x8B
09B06:  MOVLW  11
09B08:  MOVWF  xEB
09B0A:  MOVLW  12
09B0C:  MOVWF  xED
09B0E:  MOVLW  10
09B10:  MOVWF  xF4
09B12:  MOVLW  0F
09B14:  MOVWF  xF5
09B16:  MOVLW  09
09B18:  MOVWF  xF8
09B1A:  MOVLW  55
09B1C:  MOVWF  x9B
09B1E:  MOVLW  AA
09B20:  MOVWF  x9B
09B22:  BSF    x9B.0
09B24:  CLRF   xD8
09B26:  CLRF   xD5
09B28:  CLRF   xD7
09B2A:  MOVLW  08
09B2C:  MOVWF  xD9
09B2E:  MOVLW  60
09B30:  MOVWF  xD3
09B32:  MOVLW  AA
09B34:  MOVLB  0
09B36:  MOVWF  xF2
09B38:  MOVLB  1
09B3A:  CLRF   x58
09B3C:  CLRF   x57
09B3E:  CLRF   x56
09B40:  CLRF   x55
09B42:  CLRF   x5C
09B44:  CLRF   x5B
09B46:  CLRF   x5A
09B48:  CLRF   x59
09B4A:  CLRF   x60
09B4C:  CLRF   x5F
09B4E:  CLRF   x5E
09B50:  CLRF   x5D
09B52:  CLRF   x62
09B54:  CLRF   x61
09B56:  MOVLB  E
09B58:  BCF    x91.5
09B5A:  MOVLW  00
09B5C:  MOVWF  x90
09B5E:  MOVLW  0F
09B60:  MOVWF  x8E
09B62:  MOVLW  2A
09B64:  MOVWF  x91
09B66:  MOVLW  C4
09B68:  MOVWF  F88
09B6A:  MOVWF  F88
09B6C:  MOVWF  F88
09B6E:  BCF    F95.5
09B70:  MOVLW  40
09B72:  MOVWF  F94
09B74:  MOVLW  9F
09B76:  MOVWF  F92
09B78:  MOVLW  3A
09B7A:  MOVWF  F95
09B7C:  MOVLW  93
09B7E:  MOVWF  F89
09B80:  MOVWF  F89
09B82:  MOVLB  4
09B84:  CLRF   x3E
09B86:  CLRF   x3F
09B88:  CLRF   xE0
09B8A:  CLRF   xE1
09B8C:  BCF    xE2.0
09B8E:  CLRF   xE3
09B90:  BSF    F9E.3
09B92:  MOVLW  7C
09B94:  MOVWF  F9A
09B96:  MOVLW  00
09B98:  MOVWF  F9B
09B9A:  MOVLW  A6
09B9C:  MOVWF  F9D
09B9E:  MOVLW  90
09BA0:  MOVWF  F9C
09BA2:  MOVLW  93
09BA4:  MOVWF  F89
09BA6:  BCF    F84.5
09BA8:  CLRF   xE5
09BAA:  CLRF   xE4
09BAC:  CLRF   xE9
09BAE:  CLRF   xE8
09BB0:  CLRF   xE7
09BB2:  CLRF   xE6
09BB4:  MOVLB  F
09BB6:  CLRF   x0C
09BB8:  CLRF   x14
09BBA:  CLRF   x1C
09BBC:  CLRF   x21
09BBE:  CLRF   x29
09BC0:  CLRF   x35
09BC2:  CLRF   x36
09BC4:  CLRF   x37
09BC6:  CLRF   x34
09BC8:  CLRF   x31
09BCA:  CLRF   x32
09BCC:  CLRF   x33
09BCE:  CLRF   x30
09BD0:  MOVLW  51
09BD2:  MOVLB  4
09BD4:  MOVWF  xED
09BD6:  MOVLW  E0
09BD8:  MOVWF  xEC
09BDA:  MOVLW  52
09BDC:  MOVWF  xF1
09BDE:  MOVLW  24
09BE0:  MOVWF  xF0
09BE2:  MOVLW  57
09BE4:  MOVWF  xF5
09BE6:  MOVLW  6C
09BE8:  MOVWF  xF4
09BEA:  MOVLW  59
09BEC:  MOVWF  xF9
09BEE:  MOVLW  50
09BF0:  MOVWF  xF8
09BF2:  MOVLW  5B
09BF4:  MOVWF  xFD
09BF6:  MOVLW  32
09BF8:  MOVWF  xFC
09BFA:  MOVLW  5C
09BFC:  MOVLB  5
09BFE:  MOVWF  x01
09C00:  MOVLW  C4
09C02:  MOVWF  x00
09C04:  MOVLW  60
09C06:  MOVWF  x05
09C08:  MOVLW  9E
09C0A:  MOVWF  x04
09C0C:  MOVLW  68
09C0E:  MOVWF  x09
09C10:  MOVLW  90
09C12:  MOVWF  x08
09C14:  MOVLW  6B
09C16:  MOVWF  x0D
09C18:  MOVLW  B4
09C1A:  MOVWF  x0C
09C1C:  MOVLW  6D
09C1E:  MOVWF  x11
09C20:  MOVLW  1A
09C22:  MOVWF  x10
09C24:  MOVLW  6E
09C26:  MOVWF  x15
09C28:  MOVLW  DC
09C2A:  MOVWF  x14
09C2C:  MOVLW  72
09C2E:  MOVWF  x19
09C30:  MOVLW  AA
09C32:  MOVWF  x18
09C34:  MOVLW  78
09C36:  MOVWF  x1D
09C38:  MOVLW  2A
09C3A:  MOVWF  x1C
09C3C:  MOVLW  7C
09C3E:  MOVWF  x21
09C40:  MOVLW  1E
09C42:  MOVWF  x20
09C44:  MOVLW  81
09C46:  MOVWF  x25
09C48:  MOVLW  52
09C4A:  MOVWF  x24
09C4C:  MOVLW  81
09C4E:  MOVWF  x29
09C50:  MOVLW  58
09C52:  MOVWF  x28
09C54:  MOVLW  87
09C56:  MOVWF  x2D
09C58:  MOVLW  D4
09C5A:  MOVWF  x2C
09C5C:  MOVLW  8D
09C5E:  MOVWF  x31
09C60:  MOVLW  50
09C62:  MOVWF  x30
09C64:  MOVLW  94
09C66:  MOVWF  x35
09C68:  MOVLW  96
09C6A:  MOVWF  x34
09C6C:  MOVLW  95
09C6E:  MOVWF  x39
09C70:  MOVLW  EC
09C72:  MOVWF  x38
09C74:  MOVLW  98
09C76:  MOVWF  x3D
09C78:  MOVLW  32
09C7A:  MOVWF  x3C
09C7C:  BRA    9E34
09C7E:  DATA 02,00
09C80:  DATA 1A,00
09C82:  DATA 00,0C
09C84:  DATA 00,20
09C86:  DATA 78,23
09C88:  DATA D7,0A
09C8A:  DATA 7D,19
09C8C:  DATA 99,9A
09C8E:  DATA 7B,4C
09C90:  DATA CC,CD
09C92:  DATA 14,C0
09C94:  DATA 00,0C
09C96:  DATA 80,78
09C98:  DATA 23,D7
09C9A:  DATA 0A,7D
09C9C:  DATA 19,99
09C9E:  DATA 9A,7B
09CA0:  DATA 4C,CC
09CA2:  DATA CD,14
09CA4:  DATA C0,00
09CA6:  DATA 01,80
09CA8:  DATA 02,09
09CAA:  DATA C0,00
09CAC:  DATA 05,80
09CAE:  DATA 7F,00
09CB0:  DATA 00,00
09CB2:  DATA 7F,0B
09CB4:  DATA C0,00
09CB6:  DATA 05,80
09CB8:  DATA 7F,00
09CBA:  DATA 00,00
09CBC:  DATA 7F,07
09CBE:  DATA C0,00
09CC0:  DATA 01,80
09CC2:  DATA 7F,17
09CC4:  DATA C0,00
09CC6:  DATA 01,80
09CC8:  DATA 7F,17
09CCA:  DATA C0,00
09CCC:  DATA 04,80
09CCE:  DATA 79,B7
09CD0:  DATA F3,BD
09CD2:  DATA 04,C0
09CD4:  DATA 00,04
09CD6:  DATA 80,7C
09CD8:  DATA 59,DF
09CDA:  DATA 4E,04
09CDC:  DATA C0,00
09CDE:  DATA 04,80
09CE0:  DATA 78,0A
09CE2:  DATA 28,88
09CE4:  DATA 04,C0
09CE6:  DATA 00,04
09CE8:  DATA 80,78
09CEA:  DATA 05,EA
09CEC:  DATA 16,04
09CEE:  DATA C0,00
09CF0:  DATA 04,80
09CF2:  DATA 78,1E
09CF4:  DATA 33,D7
09CF6:  DATA 04,C0
09CF8:  DATA 00,04
09CFA:  DATA 80,77
09CFC:  DATA 68,7B
09CFE:  DATA BB,04
09D00:  DATA C0,00
09D02:  DATA 04,80
09D04:  DATA 77,68
09D06:  DATA 0D,C6
09D08:  DATA 08,C0
09D0A:  DATA 00,62
09D0C:  DATA 40,F3
09D0E:  DATA 00,07
09D10:  DATA 41,63
09D12:  DATA 00,3C
09D14:  DATA 44,A4
09D16:  DATA 00,02
09D18:  DATA 04,EA
09D1A:  DATA 3E,05
09D1C:  DATA 02,04
09D1E:  DATA EE,41
09D20:  DATA 05,02
09D22:  DATA 04,F2
09D24:  DATA 44,05
09D26:  DATA 02,04
09D28:  DATA F6,4B
09D2A:  DATA 05,02
09D2C:  DATA 04,FA
09D2E:  DATA 52,05
09D30:  DATA 02,04
09D32:  DATA FE,5A
09D34:  DATA 05,02
09D36:  DATA 05,02
09D38:  DATA 62,05
09D3A:  DATA 02,05
09D3C:  DATA 06,67
09D3E:  DATA 05,02
09D40:  DATA 05,0A
09D42:  DATA 6C,05
09D44:  DATA 02,05
09D46:  DATA 0E,70
09D48:  DATA 05,02
09D4A:  DATA 05,12
09D4C:  DATA 74,05
09D4E:  DATA 02,05
09D50:  DATA 16,7B
09D52:  DATA 05,02
09D54:  DATA 05,1A
09D56:  DATA 81,05
09D58:  DATA 02,05
09D5A:  DATA 1E,87
09D5C:  DATA 05,02
09D5E:  DATA 05,22
09D60:  DATA 8D,05
09D62:  DATA 02,05
09D64:  DATA 26,93
09D66:  DATA 05,02
09D68:  DATA 05,2A
09D6A:  DATA 98,05
09D6C:  DATA 02,05
09D6E:  DATA 2E,A1
09D70:  DATA 05,02
09D72:  DATA 05,32
09D74:  DATA A9,05
09D76:  DATA 02,05
09D78:  DATA 36,B0
09D7A:  DATA 05,02
09D7C:  DATA 05,3A
09D7E:  DATA B7,05
09D80:  DATA 78,05
09D82:  DATA 3E,67
09D84:  DATA 72,00
09D86:  DATA 67,73
09D88:  DATA 00,67
09D8A:  DATA 43,68
09D8C:  DATA 4D,61
09D8E:  DATA 70,00
09D90:  DATA 73,43
09D92:  DATA 68,4D
09D94:  DATA 61,70
09D96:  DATA 00,67
09D98:  DATA 43,68
09D9A:  DATA 4D,6F
09D9C:  DATA 64,65
09D9E:  DATA 00,73
09DA0:  DATA 43,68
09DA2:  DATA 4D,6F
09DA4:  DATA 64,65
09DA6:  DATA 00,67
09DA8:  DATA 50,49
09DAA:  DATA 44,00
09DAC:  DATA 73,50
09DAE:  DATA 49,44
09DB0:  DATA 00,67
09DB2:  DATA 53,50
09DB4:  DATA 00,73
09DB6:  DATA 53,50
09DB8:  DATA 00,67
09DBA:  DATA 53,43
09DBC:  DATA 61,6C
09DBE:  DATA 73,00
09DC0:  DATA 67,53
09DC2:  DATA 43,61
09DC4:  DATA 6C,00
09DC6:  DATA 73,53
09DC8:  DATA 43,61
09DCA:  DATA 6C,00
09DCC:  DATA 67,4D
09DCE:  DATA 43,61
09DD0:  DATA 6C,00
09DD2:  DATA 73,4D
09DD4:  DATA 43,61
09DD6:  DATA 6C,00
09DD8:  DATA 67,4D
09DDA:  DATA 6F,6E
09DDC:  DATA 00,67
09DDE:  DATA 50,49
09DE0:  DATA 44,64
09DE2:  DATA 61,74
09DE4:  DATA 61,00
09DE6:  DATA 67,49
09DE8:  DATA 50,64
09DEA:  DATA 61,74
09DEC:  DATA 61,00
09DEE:  DATA 67,4D
09DF0:  DATA 61,6E
09DF2:  DATA 4F,50
09DF4:  DATA 00,73
09DF6:  DATA 4D,61
09DF8:  DATA 6E,4F
09DFA:  DATA 50,04
09DFC:  DATA C0,00
09DFE:  DATA 33,80
09E00:  DATA C2,05
09E02:  DATA 01,CA
09E04:  DATA 05,02
09E06:  DATA DA,05
09E08:  DATA 53,55
09E0A:  DATA 43,43
09E0C:  DATA 45,53
09E0E:  DATA 53,00
09E10:  DATA 49,4E
09E12:  DATA 56,41
09E14:  DATA 4C,49
09E16:  DATA 44,20
09E18:  DATA 43,4F
09E1A:  DATA 4D,4D
09E1C:  DATA 41,4E
09E1E:  DATA 44,00
09E20:  DATA 49,4E
09E22:  DATA 56,41
09E24:  DATA 4C,49
09E26:  DATA 44,20
09E28:  DATA 50,41
09E2A:  DATA 52,41
09E2C:  DATA 4D,45
09E2E:  DATA 54,45
09E30:  DATA 52,00
09E32:  DATA 00,00
09E34:  MOVLW  00
09E36:  MOVWF  FF8
09E38:  MOVLW  9C
09E3A:  MOVWF  FF7
09E3C:  MOVLW  7E
09E3E:  MOVWF  FF6
09E40:  TBLRD*+
09E42:  MOVF   FF5,W
09E44:  MOVWF  00
09E46:  XORLW  00
09E48:  BZ    9E70
09E4A:  TBLRD*+
09E4C:  MOVF   FF5,W
09E4E:  MOVWF  01
09E50:  BTFSC  FE8.7
09E52:  BRA    9E5E
09E54:  ANDLW  3F
09E56:  MOVWF  FEA
09E58:  TBLRD*+
09E5A:  MOVFF  FF5,FE9
09E5E:  BTFSC  01.6
09E60:  TBLRD*+
09E62:  BTFSS  01.6
09E64:  TBLRD*+
09E66:  MOVFF  FF5,FEE
09E6A:  DCFSNZ 00,F
09E6C:  BRA    9E40
09E6E:  BRA    9E62
09E70:  CLRF   FF8
.................... {
....................    IO_init();                    // set up IO 
09E72:  MOVLB  0
09E74:  GOTO   0360
....................    params_init();                // load parameters
09E78:  GOTO   0608
....................    monitor_init();               // initialize internal ADC for voltage and current telemetry
09E7C:  GOTO   07C2
....................    control_init();               // initialize the output control DACs
09E80:  GOTO   085A
....................    serial_init();                // setup the serial port
09E84:  GOTO   0A2A
....................    event_timer_init();
09E88:  GOTO   0A4C
.................... //!   setup_wdt(WDT_512MS);
....................    enable_interrupts(GLOBAL);
09E8C:  MOVLW  C0
09E8E:  IORWF  FF2,F
....................    
....................    while(TRUE)
....................    {
.................... //!      restart_wdt();
....................       internal_monitor_task();   //Update monitored voltage and currents etc
09E90:  GOTO   0E2A
....................       sensor_monitor_task();     //get magnetoresistive sensor data
09E94:  GOTO   3B92
....................       control_task();            //output control
09E98:  GOTO   4650
....................       serial_task();             //serial port 
09E9C:  GOTO   4718
....................       
....................       #ifdef DEBUG_1
....................       static int8 ch = 0;
.................... //!      fprintf(SERIAL, "#D0,%u,%.0f,%.0f,SUCCESS\n", ch+1, adcVals[ch].sinCounts, adcVals[ch].cosCounts);
....................       fprintf(SERIAL, "#D0,%u,%3.3f\n", ch+1, adcVals[ch].pReal);
09EA0:  MOVLW  01
09EA2:  MOVLB  5
09EA4:  ADDWF  xEC,W
09EA6:  MOVWF  xEE
09EA8:  MOVF   xEC,W
09EAA:  MULLW  21
09EAC:  MOVF   FF3,W
09EAE:  CLRF   xF0
09EB0:  MOVWF  xEF
09EB2:  MOVLW  1D
09EB4:  ADDWF  xEF,W
09EB6:  MOVWF  01
09EB8:  MOVLW  00
09EBA:  ADDWFC xF0,W
09EBC:  MOVWF  03
09EBE:  MOVF   01,W
09EC0:  ADDLW  0F
09EC2:  MOVWF  FE9
09EC4:  MOVLW  01
09EC6:  ADDWFC 03,W
09EC8:  MOVWF  FEA
09ECA:  MOVFF  FEF,5EF
09ECE:  MOVFF  FEC,5F0
09ED2:  MOVFF  FEC,5F1
09ED6:  MOVFF  FEC,5F2
09EDA:  MOVLW  42
09EDC:  MOVWF  FF6
09EDE:  MOVLW  03
09EE0:  MOVWF  FF7
09EE2:  MOVLW  04
09EE4:  MOVWF  xF3
09EE6:  MOVLB  0
09EE8:  CALL   4C30
09EEC:  MOVFF  5EE,5F3
09EF0:  MOVLW  1B
09EF2:  MOVLB  5
09EF4:  MOVWF  xF4
09EF6:  MOVLB  0
09EF8:  CALL   4C84
09EFC:  MOVLW  2C
09EFE:  MOVLB  6
09F00:  MOVWF  x00
09F02:  MOVLB  0
09F04:  CALL   46CC
09F08:  MOVLW  89
09F0A:  MOVWF  FE9
09F0C:  MOVFF  5F2,5F6
09F10:  MOVFF  5F1,5F5
09F14:  MOVFF  5F0,5F4
09F18:  MOVFF  5EF,5F3
09F1C:  MOVLW  03
09F1E:  MOVLB  5
09F20:  MOVWF  xF7
09F22:  MOVLB  0
09F24:  GOTO   4DD6
09F28:  MOVLW  0A
09F2A:  MOVLB  6
09F2C:  MOVWF  x00
09F2E:  MOVLB  0
09F30:  CALL   46CC
....................       fprintf(SERIAL, "#D0,OP,%u,%Lu\n", ch+1, dacVals[ch]);
09F34:  MOVLW  01
09F36:  MOVLB  5
09F38:  ADDWF  xEC,W
09F3A:  MOVWF  xEE
09F3C:  BCF    FD8.0
09F3E:  RLCF   xEC,W
09F40:  CLRF   03
09F42:  ADDLW  51
09F44:  MOVWF  FE9
09F46:  MOVLW  01
09F48:  ADDWFC 03,W
09F4A:  MOVWF  FEA
09F4C:  MOVFF  FEC,5F0
09F50:  MOVF   FED,F
09F52:  MOVFF  FEF,5EF
09F56:  MOVLW  50
09F58:  MOVWF  FF6
09F5A:  MOVLW  03
09F5C:  MOVWF  FF7
09F5E:  MOVLW  07
09F60:  MOVWF  xF3
09F62:  MOVLB  0
09F64:  CALL   4C30
09F68:  MOVFF  5EE,5F3
09F6C:  MOVLW  1B
09F6E:  MOVLB  5
09F70:  MOVWF  xF4
09F72:  MOVLB  0
09F74:  CALL   4C84
09F78:  MOVLW  2C
09F7A:  MOVLB  6
09F7C:  MOVWF  x00
09F7E:  MOVLB  0
09F80:  CALL   46CC
09F84:  MOVLW  10
09F86:  MOVWF  FE9
09F88:  MOVFF  5F0,5F2
09F8C:  MOVFF  5EF,5F1
09F90:  GOTO   4F92
09F94:  MOVLW  0A
09F96:  MOVLB  6
09F98:  MOVWF  x00
09F9A:  MOVLB  0
09F9C:  CALL   46CC
....................       ch = !ch;
09FA0:  MOVLB  5
09FA2:  MOVF   xEC,F
09FA4:  BZ    9FAA
09FA6:  MOVLW  00
09FA8:  BRA    9FAC
09FAA:  MOVLW  01
09FAC:  MOVWF  xEC
....................       #endif
....................       
....................       command_handler_task();    //execute commands
09FAE:  MOVLB  0
09FB0:  BRA    99E8
....................       
....................       delay_ms(250);
09FB2:  MOVLW  FA
09FB4:  MOVLB  5
09FB6:  MOVWF  xF3
09FB8:  MOVLB  0
09FBA:  CALL   03F6
09FBE:  BRA    9E90
....................    }
.................... }
09FC0:  SLEEP 

Configuration Fuses:
   Word  1: FF8C   NOEXTOSC RSTOSC_HFINTRC_64MHZ NOCLKOUT CKS FCMEN
   Word  2: FFFD   MCLR PUT NOLPBOR BROWNOUT BORV19 ZCDDIS PPS1WAY STVREN NODEBUG NOXINST
   Word  3: FF9F   WDTSW NOWDT WDTWIN_SW WDTCLK_SW
   Word  4: DFFF   NOWRT NOWRTC NOWRTB NOWRTD SCANE NOLVP
   Word  5: FFFF   NOPROTECT NOCPD
   Word  6: FFFF   NOEBTR NOEBTRB
