CCS PCH C Compiler, Version 5.109, 62303               29-May-25 12:14

               Filename:   C:\Users\aidan\Documents\GitHub\DiFCS-Controller\src\main.lst

               ROM used:   27372 bytes (42%)
                           Largest free fragment is 38162
               RAM used:   1472 (41%) at main() level
                           1581 (44%) worst case
               Stack used: 7 locations (4 in main + 3 for interrupts)
               Stack size: 31

*
00000:  NOP   
00002:  GOTO   6798
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  MOVLB  E
00056:  BTFSS  xC0.5
00058:  GOTO   0062
0005C:  BTFSC  xC8.5
0005E:  GOTO   00E8
00062:  BTFSS  xC1.0
00064:  GOTO   006E
00068:  BTFSC  xC9.0
0006A:  GOTO   021E
0006E:  MOVFF  0E,00
00072:  MOVFF  0F,01
00076:  MOVFF  10,02
0007A:  MOVFF  11,03
0007E:  MOVFF  0C,FE9
00082:  MOVFF  07,FEA
00086:  BSF    07.7
00088:  MOVFF  08,FE1
0008C:  MOVFF  09,FE2
00090:  MOVFF  0A,FD9
00094:  MOVFF  0B,FDA
00098:  MOVFF  12,FF3
0009C:  MOVFF  13,FF4
000A0:  MOVFF  14,FFA
000A4:  MOVFF  15,FF5
000A8:  MOVFF  16,FF6
000AC:  MOVFF  17,FF7
000B0:  MOVF   04,W
000B2:  MOVFF  06,FE0
000B6:  MOVFF  05,FD8
000BA:  RETFIE 0
.................... #include <main.h>
.................... #include <18F46Q10.h>
.................... //////////// Standard Header file for the PIC18F46Q10 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F46Q10
000BC:  MOVFF  FEC,FFA
000C0:  MOVF   FED,F
000C2:  MOVFF  FEF,FE8
000C6:  MOVWF  FF9
000C8:  RETURN 0
*
002F2:  DATA 32,30
002F4:  DATA 32,35
002F6:  DATA 30,35
002F8:  DATA 32,32
002FA:  DATA 00,00
002FC:  DATA 30,30
002FE:  DATA 30,30
00300:  DATA 00,00
00302:  DATA 56,4F
00304:  DATA 4C,54
00306:  DATA 41,47
00308:  DATA 45,2C
0030A:  DATA 00,00
0030C:  DATA 4D,41
0030E:  DATA 47,53
00310:  DATA 45,4E
00312:  DATA 53,2C
00314:  DATA 00,00
*
007CC:  MOVLB  5
007CE:  MOVF   xE2,W
007D0:  MULWF  xE4
007D2:  MOVFF  FF3,01
007D6:  MOVFF  FF4,00
007DA:  MULWF  xE5
007DC:  MOVF   FF3,W
007DE:  ADDWF  00,F
007E0:  MOVF   xE3,W
007E2:  MULWF  xE4
007E4:  MOVF   FF3,W
007E6:  ADDWFC 00,W
007E8:  MOVWF  02
007EA:  MOVLB  0
007EC:  RETURN 0
*
009C4:  MOVLW  8E
009C6:  MOVWF  00
009C8:  MOVFF  618,01
009CC:  MOVFF  617,02
009D0:  CLRF   03
009D2:  MOVF   01,F
009D4:  BNZ   09E8
009D6:  MOVFF  02,01
009DA:  CLRF   02
009DC:  MOVLW  08
009DE:  SUBWF  00,F
009E0:  MOVF   01,F
009E2:  BNZ   09E8
009E4:  CLRF   00
009E6:  BRA    09F8
009E8:  BCF    FD8.0
009EA:  BTFSC  01.7
009EC:  BRA    09F6
009EE:  RLCF   02,F
009F0:  RLCF   01,F
009F2:  DECF   00,F
009F4:  BRA    09E8
009F6:  BCF    01.7
009F8:  RETURN 0
009FA:  MOVLB  6
009FC:  MOVF   x13,W
009FE:  BTFSC  FD8.2
00A00:  BRA    0AE4
00A02:  MOVWF  00
00A04:  MOVF   x17,W
00A06:  BTFSC  FD8.2
00A08:  BRA    0AE4
00A0A:  ADDWF  00,F
00A0C:  BNC   0A16
00A0E:  MOVLW  81
00A10:  ADDWF  00,F
00A12:  BC    0AE4
00A14:  BRA    0A1E
00A16:  MOVLW  7F
00A18:  SUBWF  00,F
00A1A:  BNC   0AE4
00A1C:  BZ    0AE4
00A1E:  MOVFF  614,61B
00A22:  MOVF   x18,W
00A24:  XORWF  x1B,F
00A26:  BSF    x14.7
00A28:  BSF    x18.7
00A2A:  MOVF   x16,W
00A2C:  MULWF  x1A
00A2E:  MOVFF  FF4,61D
00A32:  MOVF   x15,W
00A34:  MULWF  x19
00A36:  MOVFF  FF4,03
00A3A:  MOVFF  FF3,61C
00A3E:  MULWF  x1A
00A40:  MOVF   FF3,W
00A42:  ADDWF  x1D,F
00A44:  MOVF   FF4,W
00A46:  ADDWFC x1C,F
00A48:  MOVLW  00
00A4A:  ADDWFC 03,F
00A4C:  MOVF   x16,W
00A4E:  MULWF  x19
00A50:  MOVF   FF3,W
00A52:  ADDWF  x1D,F
00A54:  MOVF   FF4,W
00A56:  ADDWFC x1C,F
00A58:  MOVLW  00
00A5A:  CLRF   02
00A5C:  ADDWFC 03,F
00A5E:  ADDWFC 02,F
00A60:  MOVF   x14,W
00A62:  MULWF  x1A
00A64:  MOVF   FF3,W
00A66:  ADDWF  x1C,F
00A68:  MOVF   FF4,W
00A6A:  ADDWFC 03,F
00A6C:  MOVLW  00
00A6E:  ADDWFC 02,F
00A70:  MOVF   x14,W
00A72:  MULWF  x19
00A74:  MOVF   FF3,W
00A76:  ADDWF  03,F
00A78:  MOVF   FF4,W
00A7A:  ADDWFC 02,F
00A7C:  MOVLW  00
00A7E:  CLRF   01
00A80:  ADDWFC 01,F
00A82:  MOVF   x16,W
00A84:  MULWF  x18
00A86:  MOVF   FF3,W
00A88:  ADDWF  x1C,F
00A8A:  MOVF   FF4,W
00A8C:  ADDWFC 03,F
00A8E:  MOVLW  00
00A90:  ADDWFC 02,F
00A92:  ADDWFC 01,F
00A94:  MOVF   x15,W
00A96:  MULWF  x18
00A98:  MOVF   FF3,W
00A9A:  ADDWF  03,F
00A9C:  MOVF   FF4,W
00A9E:  ADDWFC 02,F
00AA0:  MOVLW  00
00AA2:  ADDWFC 01,F
00AA4:  MOVF   x14,W
00AA6:  MULWF  x18
00AA8:  MOVF   FF3,W
00AAA:  ADDWF  02,F
00AAC:  MOVF   FF4,W
00AAE:  ADDWFC 01,F
00AB0:  INCF   00,F
00AB2:  BTFSC  01.7
00AB4:  BRA    0AC0
00AB6:  RLCF   x1C,F
00AB8:  RLCF   03,F
00ABA:  RLCF   02,F
00ABC:  RLCF   01,F
00ABE:  DECF   00,F
00AC0:  MOVLW  00
00AC2:  BTFSS  x1C.7
00AC4:  BRA    0ADA
00AC6:  INCF   03,F
00AC8:  ADDWFC 02,F
00ACA:  ADDWFC 01,F
00ACC:  MOVF   01,W
00ACE:  BNZ   0ADA
00AD0:  MOVF   02,W
00AD2:  BNZ   0ADA
00AD4:  MOVF   03,W
00AD6:  BNZ   0ADA
00AD8:  INCF   00,F
00ADA:  BTFSC  x1B.7
00ADC:  BSF    01.7
00ADE:  BTFSS  x1B.7
00AE0:  BCF    01.7
00AE2:  BRA    0AEC
00AE4:  CLRF   00
00AE6:  CLRF   01
00AE8:  CLRF   02
00AEA:  CLRF   03
00AEC:  MOVLB  0
00AEE:  RETURN 0
00AF0:  MOVLW  80
00AF2:  BTFSS  FD8.1
00AF4:  BRA    0AFA
00AF6:  MOVLB  6
00AF8:  XORWF  x1C,F
00AFA:  MOVLB  6
00AFC:  CLRF   x21
00AFE:  CLRF   x22
00B00:  MOVFF  618,620
00B04:  MOVF   x1C,W
00B06:  XORWF  x20,F
00B08:  MOVF   x17,W
00B0A:  BTFSC  FD8.2
00B0C:  BRA    0CCC
00B0E:  MOVWF  x1F
00B10:  MOVWF  00
00B12:  MOVF   x1B,W
00B14:  BTFSC  FD8.2
00B16:  BRA    0CDE
00B18:  SUBWF  x1F,F
00B1A:  BTFSC  FD8.2
00B1C:  BRA    0C24
00B1E:  BNC   0B9C
00B20:  MOVFF  61C,625
00B24:  BSF    x25.7
00B26:  MOVFF  61D,624
00B2A:  MOVFF  61E,623
00B2E:  CLRF   x22
00B30:  BCF    FD8.0
00B32:  RRCF   x25,F
00B34:  RRCF   x24,F
00B36:  RRCF   x23,F
00B38:  RRCF   x22,F
00B3A:  DECFSZ x1F,F
00B3C:  BRA    0B2E
00B3E:  BTFSS  x20.7
00B40:  BRA    0B48
00B42:  BSF    x21.0
00B44:  BRA    0D06
00B46:  BCF    x21.0
00B48:  BCF    x1F.0
00B4A:  BSF    x21.4
00B4C:  MOVLW  06
00B4E:  MOVWF  FEA
00B50:  MOVLW  1A
00B52:  MOVWF  FE9
00B54:  BRA    0D2C
00B56:  BCF    x21.4
00B58:  BTFSC  x20.7
00B5A:  BRA    0B70
00B5C:  BTFSS  x1F.0
00B5E:  BRA    0B86
00B60:  RRCF   x25,F
00B62:  RRCF   x24,F
00B64:  RRCF   x23,F
00B66:  RRCF   x22,F
00B68:  INCF   00,F
00B6A:  BTFSC  FD8.2
00B6C:  BRA    0CFC
00B6E:  BRA    0B86
00B70:  BTFSC  x25.7
00B72:  BRA    0B8C
00B74:  BCF    FD8.0
00B76:  RLCF   x22,F
00B78:  RLCF   x23,F
00B7A:  RLCF   x24,F
00B7C:  RLCF   x25,F
00B7E:  DECF   00,F
00B80:  BTFSC  FD8.2
00B82:  BRA    0CFC
00B84:  BRA    0B70
00B86:  BSF    x21.6
00B88:  BRA    0C64
00B8A:  BCF    x21.6
00B8C:  MOVFF  618,620
00B90:  BTFSS  x18.7
00B92:  BRA    0B98
00B94:  BSF    x25.7
00B96:  BRA    0CEE
00B98:  BCF    x25.7
00B9A:  BRA    0CEE
00B9C:  MOVFF  61B,61F
00BA0:  MOVFF  61B,00
00BA4:  MOVF   x17,W
00BA6:  SUBWF  x1F,F
00BA8:  MOVFF  618,625
00BAC:  BSF    x25.7
00BAE:  MOVFF  619,624
00BB2:  MOVFF  61A,623
00BB6:  CLRF   x22
00BB8:  BCF    FD8.0
00BBA:  RRCF   x25,F
00BBC:  RRCF   x24,F
00BBE:  RRCF   x23,F
00BC0:  RRCF   x22,F
00BC2:  DECFSZ x1F,F
00BC4:  BRA    0BB6
00BC6:  BTFSS  x20.7
00BC8:  BRA    0BD0
00BCA:  BSF    x21.1
00BCC:  BRA    0D06
00BCE:  BCF    x21.1
00BD0:  BCF    x1F.0
00BD2:  BSF    x21.5
00BD4:  MOVLW  06
00BD6:  MOVWF  FEA
00BD8:  MOVLW  1E
00BDA:  MOVWF  FE9
00BDC:  BRA    0D2C
00BDE:  BCF    x21.5
00BE0:  BTFSC  x20.7
00BE2:  BRA    0BF8
00BE4:  BTFSS  x1F.0
00BE6:  BRA    0C0E
00BE8:  RRCF   x25,F
00BEA:  RRCF   x24,F
00BEC:  RRCF   x23,F
00BEE:  RRCF   x22,F
00BF0:  INCF   00,F
00BF2:  BTFSC  FD8.2
00BF4:  BRA    0CFC
00BF6:  BRA    0C0E
00BF8:  BTFSC  x25.7
00BFA:  BRA    0C14
00BFC:  BCF    FD8.0
00BFE:  RLCF   x22,F
00C00:  RLCF   x23,F
00C02:  RLCF   x24,F
00C04:  RLCF   x25,F
00C06:  DECF   00,F
00C08:  BTFSC  FD8.2
00C0A:  BRA    0CFC
00C0C:  BRA    0BF8
00C0E:  BSF    x21.7
00C10:  BRA    0C64
00C12:  BCF    x21.7
00C14:  MOVFF  61C,620
00C18:  BTFSS  x1C.7
00C1A:  BRA    0C20
00C1C:  BSF    x25.7
00C1E:  BRA    0CEE
00C20:  BCF    x25.7
00C22:  BRA    0CEE
00C24:  MOVFF  61C,625
00C28:  BSF    x25.7
00C2A:  MOVFF  61D,624
00C2E:  MOVFF  61E,623
00C32:  BTFSS  x20.7
00C34:  BRA    0C3E
00C36:  BCF    x25.7
00C38:  BSF    x21.2
00C3A:  BRA    0D06
00C3C:  BCF    x21.2
00C3E:  CLRF   x22
00C40:  BCF    x1F.0
00C42:  MOVLW  06
00C44:  MOVWF  FEA
00C46:  MOVLW  1A
00C48:  MOVWF  FE9
00C4A:  BRA    0D2C
00C4C:  BTFSC  x20.7
00C4E:  BRA    0C88
00C50:  MOVFF  618,620
00C54:  BTFSS  x1F.0
00C56:  BRA    0C64
00C58:  RRCF   x25,F
00C5A:  RRCF   x24,F
00C5C:  RRCF   x23,F
00C5E:  RRCF   x22,F
00C60:  INCF   00,F
00C62:  BZ    0CFC
00C64:  BTFSS  x22.7
00C66:  BRA    0C7E
00C68:  INCF   x23,F
00C6A:  BNZ   0C7E
00C6C:  INCF   x24,F
00C6E:  BNZ   0C7E
00C70:  INCF   x25,F
00C72:  BNZ   0C7E
00C74:  RRCF   x25,F
00C76:  RRCF   x24,F
00C78:  RRCF   x23,F
00C7A:  INCF   00,F
00C7C:  BZ    0CFC
00C7E:  BTFSC  x21.6
00C80:  BRA    0B8A
00C82:  BTFSC  x21.7
00C84:  BRA    0C12
00C86:  BRA    0CC0
00C88:  MOVLW  80
00C8A:  XORWF  x25,F
00C8C:  BTFSS  x25.7
00C8E:  BRA    0C98
00C90:  BRA    0D06
00C92:  MOVFF  61C,620
00C96:  BRA    0CAC
00C98:  MOVFF  618,620
00C9C:  MOVF   x25,F
00C9E:  BNZ   0CAC
00CA0:  MOVF   x24,F
00CA2:  BNZ   0CAC
00CA4:  MOVF   x23,F
00CA6:  BNZ   0CAC
00CA8:  CLRF   00
00CAA:  BRA    0CEE
00CAC:  BTFSC  x25.7
00CAE:  BRA    0CC0
00CB0:  BCF    FD8.0
00CB2:  RLCF   x22,F
00CB4:  RLCF   x23,F
00CB6:  RLCF   x24,F
00CB8:  RLCF   x25,F
00CBA:  DECFSZ 00,F
00CBC:  BRA    0CAC
00CBE:  BRA    0CFC
00CC0:  BTFSS  x20.7
00CC2:  BRA    0CC8
00CC4:  BSF    x25.7
00CC6:  BRA    0CEE
00CC8:  BCF    x25.7
00CCA:  BRA    0CEE
00CCC:  MOVFF  61B,00
00CD0:  MOVFF  61C,625
00CD4:  MOVFF  61D,624
00CD8:  MOVFF  61E,623
00CDC:  BRA    0CEE
00CDE:  MOVFF  617,00
00CE2:  MOVFF  618,625
00CE6:  MOVFF  619,624
00CEA:  MOVFF  61A,623
00CEE:  MOVFF  625,01
00CF2:  MOVFF  624,02
00CF6:  MOVFF  623,03
00CFA:  BRA    0D64
00CFC:  CLRF   00
00CFE:  CLRF   01
00D00:  CLRF   02
00D02:  CLRF   03
00D04:  BRA    0D64
00D06:  CLRF   x22
00D08:  COMF   x23,F
00D0A:  COMF   x24,F
00D0C:  COMF   x25,F
00D0E:  COMF   x22,F
00D10:  INCF   x22,F
00D12:  BNZ   0D1E
00D14:  INCF   x23,F
00D16:  BNZ   0D1E
00D18:  INCF   x24,F
00D1A:  BNZ   0D1E
00D1C:  INCF   x25,F
00D1E:  BTFSC  x21.0
00D20:  BRA    0B46
00D22:  BTFSC  x21.1
00D24:  BRA    0BCE
00D26:  BTFSC  x21.2
00D28:  BRA    0C3C
00D2A:  BRA    0C92
00D2C:  MOVF   FEF,W
00D2E:  ADDWF  x23,F
00D30:  BNC   0D3C
00D32:  INCF   x24,F
00D34:  BNZ   0D3C
00D36:  INCF   x25,F
00D38:  BTFSC  FD8.2
00D3A:  BSF    x1F.0
00D3C:  MOVF   FED,F
00D3E:  MOVF   FEF,W
00D40:  ADDWF  x24,F
00D42:  BNC   0D4A
00D44:  INCF   x25,F
00D46:  BTFSC  FD8.2
00D48:  BSF    x1F.0
00D4A:  MOVF   FED,F
00D4C:  MOVF   FEF,W
00D4E:  BTFSC  FEF.7
00D50:  BRA    0D54
00D52:  XORLW  80
00D54:  ADDWF  x25,F
00D56:  BTFSC  FD8.0
00D58:  BSF    x1F.0
00D5A:  BTFSC  x21.4
00D5C:  BRA    0B56
00D5E:  BTFSC  x21.5
00D60:  BRA    0BDE
00D62:  BRA    0C4C
00D64:  MOVLB  0
00D66:  RETURN 0
*
012F4:  MOVLW  B6
012F6:  MOVWF  00
012F8:  CLRF   03
012FA:  CLRF   02
012FC:  CLRF   01
012FE:  MOVLB  5
01300:  MOVF   xDD,W
01302:  IORWF  xDE,W
01304:  IORWF  xDF,W
01306:  IORWF  xE0,W
01308:  BNZ   130E
0130A:  CLRF   00
0130C:  BRA    1328
0130E:  BCF    FD8.0
01310:  BTFSC  01.7
01312:  BRA    1326
01314:  RLCF   xDD,F
01316:  RLCF   xDE,F
01318:  RLCF   xDF,F
0131A:  RLCF   xE0,F
0131C:  RLCF   03,F
0131E:  RLCF   02,F
01320:  RLCF   01,F
01322:  DECFSZ 00,F
01324:  BRA    130E
01326:  BCF    01.7
01328:  MOVLB  0
0132A:  RETURN 0
0132C:  MOVFF  614,61B
01330:  MOVLB  6
01332:  MOVF   x18,W
01334:  XORWF  x1B,F
01336:  BTFSS  x1B.7
01338:  BRA    1344
0133A:  BCF    FD8.2
0133C:  BCF    FD8.0
0133E:  BTFSC  x14.7
01340:  BSF    FD8.0
01342:  BRA    13A2
01344:  MOVFF  614,61B
01348:  MOVFF  617,61C
0134C:  MOVF   x13,W
0134E:  SUBWF  x1C,F
01350:  BZ    135E
01352:  BTFSS  x1B.7
01354:  BRA    13A2
01356:  MOVF   FD8,W
01358:  XORLW  01
0135A:  MOVWF  FD8
0135C:  BRA    13A2
0135E:  MOVFF  618,61C
01362:  MOVF   x14,W
01364:  SUBWF  x1C,F
01366:  BZ    1374
01368:  BTFSS  x1B.7
0136A:  BRA    13A2
0136C:  MOVF   FD8,W
0136E:  XORLW  01
01370:  MOVWF  FD8
01372:  BRA    13A2
01374:  MOVFF  619,61C
01378:  MOVF   x15,W
0137A:  SUBWF  x1C,F
0137C:  BZ    138A
0137E:  BTFSS  x1B.7
01380:  BRA    13A2
01382:  MOVF   FD8,W
01384:  XORLW  01
01386:  MOVWF  FD8
01388:  BRA    13A2
0138A:  MOVFF  61A,61C
0138E:  MOVF   x16,W
01390:  SUBWF  x1C,F
01392:  BZ    13A0
01394:  BTFSS  x1B.7
01396:  BRA    13A2
01398:  MOVF   FD8,W
0139A:  XORLW  01
0139C:  MOVWF  FD8
0139E:  BRA    13A2
013A0:  BCF    FD8.0
013A2:  MOVLB  0
013A4:  RETURN 0
013A6:  MOVLB  6
013A8:  MOVF   x0C,W
013AA:  BTFSC  FD8.2
013AC:  BRA    14F8
013AE:  MOVWF  x18
013B0:  MOVF   x10,W
013B2:  BTFSC  FD8.2
013B4:  BRA    14F8
013B6:  SUBWF  x18,F
013B8:  BNC   13C4
013BA:  MOVLW  7F
013BC:  ADDWF  x18,F
013BE:  BTFSC  FD8.0
013C0:  BRA    14F8
013C2:  BRA    13D0
013C4:  MOVLW  81
013C6:  SUBWF  x18,F
013C8:  BTFSS  FD8.0
013CA:  BRA    14F8
013CC:  BTFSC  FD8.2
013CE:  BRA    14F8
013D0:  MOVFF  618,00
013D4:  CLRF   01
013D6:  CLRF   02
013D8:  CLRF   03
013DA:  CLRF   x17
013DC:  MOVFF  60D,616
013E0:  BSF    x16.7
013E2:  MOVFF  60E,615
013E6:  MOVFF  60F,614
013EA:  MOVLW  19
013EC:  MOVWF  x18
013EE:  MOVF   x13,W
013F0:  SUBWF  x14,F
013F2:  BC    140E
013F4:  MOVLW  01
013F6:  SUBWF  x15,F
013F8:  BC    140E
013FA:  SUBWF  x16,F
013FC:  BC    140E
013FE:  SUBWF  x17,F
01400:  BC    140E
01402:  INCF   x17,F
01404:  INCF   x16,F
01406:  INCF   x15,F
01408:  MOVF   x13,W
0140A:  ADDWF  x14,F
0140C:  BRA    145E
0140E:  MOVF   x12,W
01410:  SUBWF  x15,F
01412:  BC    1438
01414:  MOVLW  01
01416:  SUBWF  x16,F
01418:  BC    1438
0141A:  SUBWF  x17,F
0141C:  BC    1438
0141E:  INCF   x17,F
01420:  INCF   x16,F
01422:  MOVF   x12,W
01424:  ADDWF  x15,F
01426:  MOVF   x13,W
01428:  ADDWF  x14,F
0142A:  BNC   145E
0142C:  INCF   x15,F
0142E:  BNZ   145E
01430:  INCF   x16,F
01432:  BNZ   145E
01434:  INCF   x17,F
01436:  BRA    145E
01438:  MOVF   x11,W
0143A:  IORLW  80
0143C:  SUBWF  x16,F
0143E:  BC    145C
01440:  MOVLW  01
01442:  SUBWF  x17,F
01444:  BC    145C
01446:  INCF   x17,F
01448:  MOVF   x11,W
0144A:  IORLW  80
0144C:  ADDWF  x16,F
0144E:  MOVF   x12,W
01450:  ADDWF  x15,F
01452:  BNC   1426
01454:  INCF   x16,F
01456:  BNZ   1426
01458:  INCF   x17,F
0145A:  BRA    1426
0145C:  BSF    03.0
0145E:  DECFSZ x18,F
01460:  BRA    1464
01462:  BRA    147A
01464:  BCF    FD8.0
01466:  RLCF   x14,F
01468:  RLCF   x15,F
0146A:  RLCF   x16,F
0146C:  RLCF   x17,F
0146E:  BCF    FD8.0
01470:  RLCF   03,F
01472:  RLCF   02,F
01474:  RLCF   01,F
01476:  RLCF   x19,F
01478:  BRA    13EE
0147A:  BTFSS  x19.0
0147C:  BRA    148A
0147E:  BCF    FD8.0
01480:  RRCF   01,F
01482:  RRCF   02,F
01484:  RRCF   03,F
01486:  RRCF   x19,F
01488:  BRA    148E
0148A:  DECF   00,F
0148C:  BZ    14F8
0148E:  BTFSC  x19.7
01490:  BRA    14CE
01492:  BCF    FD8.0
01494:  RLCF   x14,F
01496:  RLCF   x15,F
01498:  RLCF   x16,F
0149A:  RLCF   x17,F
0149C:  MOVF   x13,W
0149E:  SUBWF  x14,F
014A0:  BC    14B0
014A2:  MOVLW  01
014A4:  SUBWF  x15,F
014A6:  BC    14B0
014A8:  SUBWF  x16,F
014AA:  BC    14B0
014AC:  SUBWF  x17,F
014AE:  BNC   14E4
014B0:  MOVF   x12,W
014B2:  SUBWF  x15,F
014B4:  BC    14C0
014B6:  MOVLW  01
014B8:  SUBWF  x16,F
014BA:  BC    14C0
014BC:  SUBWF  x17,F
014BE:  BNC   14E4
014C0:  MOVF   x11,W
014C2:  IORLW  80
014C4:  SUBWF  x16,F
014C6:  BC    14CE
014C8:  MOVLW  01
014CA:  SUBWF  x17,F
014CC:  BNC   14E4
014CE:  INCF   03,F
014D0:  BNZ   14E4
014D2:  INCF   02,F
014D4:  BNZ   14E4
014D6:  INCF   01,F
014D8:  BNZ   14E4
014DA:  INCF   00,F
014DC:  BZ    14F8
014DE:  RRCF   01,F
014E0:  RRCF   02,F
014E2:  RRCF   03,F
014E4:  MOVFF  60D,618
014E8:  MOVF   x11,W
014EA:  XORWF  x18,F
014EC:  BTFSS  x18.7
014EE:  BRA    14F4
014F0:  BSF    01.7
014F2:  BRA    1500
014F4:  BCF    01.7
014F6:  BRA    1500
014F8:  CLRF   00
014FA:  CLRF   01
014FC:  CLRF   02
014FE:  CLRF   03
01500:  MOVLB  0
01502:  RETURN 0
*
01CB8:  ADDWF  FE8,W
01CBA:  CLRF   FF7
01CBC:  RLCF   FF7,F
01CBE:  ADDLW  D3
01CC0:  MOVWF  FF6
01CC2:  MOVLW  1C
01CC4:  ADDWFC FF7,F
01CC6:  TBLRD*-
01CC8:  MOVF   FF5,W
01CCA:  MOVWF  FFA
01CCC:  TBLRD*
01CCE:  MOVF   FF5,W
01CD0:  MOVWF  FF9
01CD2:  DATA C0,1B
01CD4:  DATA DA,1B
01CD6:  DATA 2E,1C
01CD8:  DATA 92,1C
01CDA:  MOVLW  8E
01CDC:  MOVWF  00
01CDE:  MOVLB  6
01CE0:  MOVF   x13,W
01CE2:  SUBWF  00,F
01CE4:  MOVFF  614,02
01CE8:  MOVFF  615,01
01CEC:  BSF    02.7
01CEE:  MOVF   00,F
01CF0:  BZ    1D04
01CF2:  BCF    FD8.0
01CF4:  MOVF   02,F
01CF6:  BNZ   1CFC
01CF8:  MOVF   01,F
01CFA:  BZ    1D04
01CFC:  RRCF   02,F
01CFE:  RRCF   01,F
01D00:  DECFSZ 00,F
01D02:  BRA    1CF2
01D04:  BTFSS  x14.7
01D06:  BRA    1D12
01D08:  COMF   01,F
01D0A:  COMF   02,F
01D0C:  INCF   01,F
01D0E:  BTFSC  FD8.2
01D10:  INCF   02,F
01D12:  MOVLB  0
01D14:  RETURN 0
*
02226:  MOVLW  8E
02228:  MOVWF  00
0222A:  MOVFF  60A,01
0222E:  MOVFF  609,02
02232:  CLRF   03
02234:  BTFSS  01.7
02236:  BRA    2242
02238:  COMF   01,F
0223A:  COMF   02,F
0223C:  INCF   02,F
0223E:  BNZ   2242
02240:  INCF   01,F
02242:  MOVF   01,F
02244:  BNZ   2258
02246:  MOVFF  02,01
0224A:  CLRF   02
0224C:  MOVLW  08
0224E:  SUBWF  00,F
02250:  MOVF   01,F
02252:  BNZ   2258
02254:  CLRF   00
02256:  BRA    2274
02258:  BCF    FD8.0
0225A:  BTFSC  01.7
0225C:  BRA    2266
0225E:  RLCF   02,F
02260:  RLCF   01,F
02262:  DECF   00,F
02264:  BRA    2258
02266:  MOVLB  6
02268:  BTFSS  x0A.7
0226A:  BRA    2270
0226C:  MOVLB  0
0226E:  BRA    2274
02270:  BCF    01.7
02272:  MOVLB  0
02274:  RETURN 0
*
03816:  MOVF   FEF,F
03818:  BZ    3838
0381A:  MOVFF  FEA,5C5
0381E:  MOVFF  FE9,5C4
03822:  MOVFF  FEF,5C6
03826:  RCALL  37EE
03828:  MOVFF  5C5,FEA
0382C:  MOVFF  5C4,FE9
03830:  INCF   FE9,F
03832:  BTFSC  FD8.2
03834:  INCF   FEA,F
03836:  BRA    3816
03838:  RETURN 0
*
03E76:  MOVFF  4CD,FEA
03E7A:  MOVFF  4CC,FE9
03E7E:  MOVFF  5E2,FEF
03E82:  INCF   FE9,F
03E84:  BTFSC  FD8.2
03E86:  INCF   FEA,F
03E88:  CLRF   FEF
03E8A:  MOVLB  4
03E8C:  INCF   xCC,F
03E8E:  BTFSC  FD8.2
03E90:  INCF   xCD,F
03E92:  MOVLB  0
03E94:  RETURN 0
03E96:  TBLRD*+
03E98:  MOVF   FF5,F
03E9A:  BZ    3EB4
03E9C:  MOVFF  FF6,5CE
03EA0:  MOVFF  FF7,5CF
03EA4:  MOVFF  FF5,5E2
03EA8:  RCALL  3E76
03EAA:  MOVFF  5CE,FF6
03EAE:  MOVFF  5CF,FF7
03EB2:  BRA    3E96
03EB4:  RETURN 0
*
03FD8:  MOVLB  6
03FDA:  MOVF   x19,W
03FDC:  XORWF  x1B,W
03FDE:  ANDLW  80
03FE0:  MOVWF  x1D
03FE2:  BTFSS  x19.7
03FE4:  BRA    3FF0
03FE6:  COMF   x18,F
03FE8:  COMF   x19,F
03FEA:  INCF   x18,F
03FEC:  BTFSC  FD8.2
03FEE:  INCF   x19,F
03FF0:  BTFSS  x1B.7
03FF2:  BRA    3FFE
03FF4:  COMF   x1A,F
03FF6:  COMF   x1B,F
03FF8:  INCF   x1A,F
03FFA:  BTFSC  FD8.2
03FFC:  INCF   x1B,F
03FFE:  MOVF   x18,W
04000:  MULWF  x1A
04002:  MOVFF  FF3,01
04006:  MOVFF  FF4,00
0400A:  MULWF  x1B
0400C:  MOVF   FF3,W
0400E:  ADDWF  00,F
04010:  MOVF   x19,W
04012:  MULWF  x1A
04014:  MOVF   FF3,W
04016:  ADDWFC 00,W
04018:  MOVWF  02
0401A:  BTFSS  x1D.7
0401C:  BRA    4028
0401E:  COMF   01,F
04020:  COMF   02,F
04022:  INCF   01,F
04024:  BTFSC  FD8.2
04026:  INCF   02,F
04028:  MOVLB  0
0402A:  GOTO   42CA (RETURN)
*
04392:  MOVLB  5
04394:  MOVF   xCC,W
04396:  ANDLW  07
04398:  MOVWF  00
0439A:  RRCF   xCC,W
0439C:  MOVWF  01
0439E:  RRCF   01,F
043A0:  RRCF   01,F
043A2:  MOVLW  1F
043A4:  ANDWF  01,F
043A6:  MOVF   01,W
043A8:  ADDWF  xCD,W
043AA:  MOVWF  FE9
043AC:  MOVLW  00
043AE:  ADDWFC xCE,W
043B0:  MOVWF  FEA
043B2:  MOVFF  FEF,01
043B6:  INCF   00,F
043B8:  BRA    43BC
043BA:  RRCF   01,F
043BC:  DECFSZ 00,F
043BE:  BRA    43BA
043C0:  MOVLW  01
043C2:  ANDWF  01,F
043C4:  MOVLB  0
043C6:  RETURN 0
*
04530:  MOVLB  5
04532:  MOVF   xE3,W
04534:  ANDLW  07
04536:  MOVWF  00
04538:  RRCF   xE3,W
0453A:  MOVWF  01
0453C:  RRCF   01,F
0453E:  RRCF   01,F
04540:  MOVLW  1F
04542:  ANDWF  01,F
04544:  MOVF   01,W
04546:  ADDWF  xE5,W
04548:  MOVWF  FE9
0454A:  MOVLW  00
0454C:  ADDWFC xE6,W
0454E:  MOVWF  FEA
04550:  CLRF   01
04552:  INCF   01,F
04554:  INCF   00,F
04556:  BRA    455A
04558:  RLCF   01,F
0455A:  DECFSZ 00,F
0455C:  BRA    4558
0455E:  MOVF   xE4,F
04560:  BZ    4568
04562:  MOVF   01,W
04564:  IORWF  FEF,F
04566:  BRA    456E
04568:  COMF   01,F
0456A:  MOVF   01,W
0456C:  ANDWF  FEF,F
0456E:  MOVLB  0
04570:  RETURN 0
*
04AAA:  MOVLB  5
04AAC:  MOVF   xE2,W
04AAE:  SUBLW  B6
04AB0:  MOVWF  xE2
04AB2:  CLRF   03
04AB4:  MOVFF  5E3,5E6
04AB8:  BSF    xE3.7
04ABA:  BCF    FD8.0
04ABC:  RRCF   xE3,F
04ABE:  RRCF   xE4,F
04AC0:  RRCF   xE5,F
04AC2:  RRCF   03,F
04AC4:  RRCF   02,F
04AC6:  RRCF   01,F
04AC8:  RRCF   00,F
04ACA:  DECFSZ xE2,F
04ACC:  BRA    4ABA
04ACE:  BTFSS  xE6.7
04AD0:  BRA    4AE8
04AD2:  COMF   00,F
04AD4:  COMF   01,F
04AD6:  COMF   02,F
04AD8:  COMF   03,F
04ADA:  INCF   00,F
04ADC:  BTFSC  FD8.2
04ADE:  INCF   01,F
04AE0:  BTFSC  FD8.2
04AE2:  INCF   02,F
04AE4:  BTFSC  FD8.2
04AE6:  INCF   03,F
04AE8:  MOVLB  0
04AEA:  GOTO   4BDC (RETURN)
04AEE:  BTFSC  FD8.1
04AF0:  BRA    4AFA
04AF2:  MOVLW  05
04AF4:  MOVWF  FEA
04AF6:  MOVLW  EA
04AF8:  MOVWF  FE9
04AFA:  CLRF   00
04AFC:  CLRF   01
04AFE:  CLRF   02
04B00:  CLRF   03
04B02:  MOVLB  5
04B04:  CLRF   xEA
04B06:  CLRF   xEB
04B08:  CLRF   xEC
04B0A:  CLRF   xED
04B0C:  MOVF   xE9,W
04B0E:  IORWF  xE8,W
04B10:  IORWF  xE7,W
04B12:  IORWF  xE6,W
04B14:  BZ    4B6E
04B16:  MOVLW  20
04B18:  MOVWF  xEE
04B1A:  BCF    FD8.0
04B1C:  RLCF   xE2,F
04B1E:  RLCF   xE3,F
04B20:  RLCF   xE4,F
04B22:  RLCF   xE5,F
04B24:  RLCF   xEA,F
04B26:  RLCF   xEB,F
04B28:  RLCF   xEC,F
04B2A:  RLCF   xED,F
04B2C:  MOVF   xE9,W
04B2E:  SUBWF  xED,W
04B30:  BNZ   4B42
04B32:  MOVF   xE8,W
04B34:  SUBWF  xEC,W
04B36:  BNZ   4B42
04B38:  MOVF   xE7,W
04B3A:  SUBWF  xEB,W
04B3C:  BNZ   4B42
04B3E:  MOVF   xE6,W
04B40:  SUBWF  xEA,W
04B42:  BNC   4B62
04B44:  MOVF   xE6,W
04B46:  SUBWF  xEA,F
04B48:  MOVF   xE7,W
04B4A:  BTFSS  FD8.0
04B4C:  INCFSZ xE7,W
04B4E:  SUBWF  xEB,F
04B50:  MOVF   xE8,W
04B52:  BTFSS  FD8.0
04B54:  INCFSZ xE8,W
04B56:  SUBWF  xEC,F
04B58:  MOVF   xE9,W
04B5A:  BTFSS  FD8.0
04B5C:  INCFSZ xE9,W
04B5E:  SUBWF  xED,F
04B60:  BSF    FD8.0
04B62:  RLCF   00,F
04B64:  RLCF   01,F
04B66:  RLCF   02,F
04B68:  RLCF   03,F
04B6A:  DECFSZ xEE,F
04B6C:  BRA    4B1A
04B6E:  MOVFF  5EA,FEF
04B72:  MOVFF  5EB,FEC
04B76:  MOVFF  5EC,FEC
04B7A:  MOVFF  5ED,FEC
04B7E:  MOVLB  0
04B80:  RETURN 0
04B82:  MOVF   FE9,W
04B84:  MOVLB  5
04B86:  MOVWF  xDA
04B88:  MOVF   xD9,W
04B8A:  MOVWF  xDC
04B8C:  BZ    4BC8
04B8E:  MOVFF  5D8,616
04B92:  MOVFF  5D7,615
04B96:  MOVFF  5D6,614
04B9A:  MOVFF  5D5,613
04B9E:  MOVLB  6
04BA0:  CLRF   x1A
04BA2:  CLRF   x19
04BA4:  MOVLW  20
04BA6:  MOVWF  x18
04BA8:  MOVLW  82
04BAA:  MOVWF  x17
04BAC:  MOVLB  0
04BAE:  CALL   09FA
04BB2:  MOVFF  03,5D8
04BB6:  MOVFF  02,5D7
04BBA:  MOVFF  01,5D6
04BBE:  MOVFF  00,5D5
04BC2:  MOVLB  5
04BC4:  DECFSZ xDC,F
04BC6:  BRA    4B8E
04BC8:  MOVFF  5D8,5E5
04BCC:  MOVFF  5D7,5E4
04BD0:  MOVFF  5D6,5E3
04BD4:  MOVFF  5D5,5E2
04BD8:  MOVLB  0
04BDA:  BRA    4AAA
04BDC:  MOVFF  03,5D8
04BE0:  MOVFF  02,5D7
04BE4:  MOVFF  01,5D6
04BE8:  MOVFF  00,5D5
04BEC:  MOVLB  5
04BEE:  BTFSS  xD8.7
04BF0:  BRA    4C0C
04BF2:  DECF   xDA,F
04BF4:  BSF    xDA.5
04BF6:  COMF   xD5,F
04BF8:  COMF   xD6,F
04BFA:  COMF   xD7,F
04BFC:  COMF   xD8,F
04BFE:  INCF   xD5,F
04C00:  BTFSC  FD8.2
04C02:  INCF   xD6,F
04C04:  BTFSC  FD8.2
04C06:  INCF   xD7,F
04C08:  BTFSC  FD8.2
04C0A:  INCF   xD8,F
04C0C:  MOVLW  3B
04C0E:  MOVWF  xE1
04C10:  MOVLW  9A
04C12:  MOVWF  xE0
04C14:  MOVLW  CA
04C16:  MOVWF  xDF
04C18:  CLRF   xDE
04C1A:  MOVLW  0A
04C1C:  MOVWF  xDC
04C1E:  MOVF   xD9,W
04C20:  BTFSC  FD8.2
04C22:  INCF   xDA,F
04C24:  BSF    FD8.1
04C26:  MOVLW  05
04C28:  MOVWF  FEA
04C2A:  MOVLW  D5
04C2C:  MOVWF  FE9
04C2E:  MOVFF  5D8,5E5
04C32:  MOVFF  5D7,5E4
04C36:  MOVFF  5D6,5E3
04C3A:  MOVFF  5D5,5E2
04C3E:  MOVFF  5E1,5E9
04C42:  MOVFF  5E0,5E8
04C46:  MOVFF  5DF,5E7
04C4A:  MOVFF  5DE,5E6
04C4E:  MOVLB  0
04C50:  RCALL  4AEE
04C52:  MOVF   01,W
04C54:  MOVF   00,F
04C56:  BNZ   4C7E
04C58:  MOVLB  5
04C5A:  INCF   xD9,W
04C5C:  SUBWF  xDC,W
04C5E:  BTFSS  FD8.2
04C60:  BRA    4C66
04C62:  MOVLB  0
04C64:  BRA    4C7E
04C66:  MOVF   xDA,W
04C68:  BZ    4C84
04C6A:  ANDLW  0F
04C6C:  SUBWF  xDC,W
04C6E:  BZ    4C72
04C70:  BC    4CFA
04C72:  BTFSC  xDA.7
04C74:  BRA    4CFA
04C76:  BTFSC  xDA.6
04C78:  BRA    4C84
04C7A:  MOVLW  20
04C7C:  BRA    4CEC
04C7E:  MOVLW  20
04C80:  MOVLB  5
04C82:  ANDWF  xDA,F
04C84:  BTFSS  xDA.5
04C86:  BRA    4CA6
04C88:  BCF    xDA.5
04C8A:  MOVF   xD9,W
04C8C:  BTFSS  FD8.2
04C8E:  DECF   xDA,F
04C90:  MOVF   00,W
04C92:  MOVWF  xDA
04C94:  MOVLW  2D
04C96:  MOVWF  xE2
04C98:  MOVLB  0
04C9A:  CALL   3E76
04C9E:  MOVLB  5
04CA0:  MOVF   xDA,W
04CA2:  MOVWF  00
04CA4:  CLRF   xDA
04CA6:  MOVF   xD9,W
04CA8:  SUBWF  xDC,W
04CAA:  BNZ   4CC6
04CAC:  MOVF   00,W
04CAE:  MOVWF  xDA
04CB0:  MOVLW  2E
04CB2:  MOVWF  xE2
04CB4:  MOVLB  0
04CB6:  CALL   3E76
04CBA:  MOVLB  5
04CBC:  MOVF   xDA,W
04CBE:  MOVWF  00
04CC0:  MOVLW  20
04CC2:  ANDWF  xDA,F
04CC4:  MOVLW  00
04CC6:  MOVLW  30
04CC8:  BTFSS  xDA.5
04CCA:  BRA    4CEC
04CCC:  BCF    xDA.5
04CCE:  MOVF   xD9,W
04CD0:  BTFSS  FD8.2
04CD2:  DECF   xDA,F
04CD4:  MOVF   00,W
04CD6:  MOVWF  xDA
04CD8:  MOVLW  2D
04CDA:  MOVWF  xE2
04CDC:  MOVLB  0
04CDE:  CALL   3E76
04CE2:  MOVLB  5
04CE4:  MOVF   xDA,W
04CE6:  MOVWF  00
04CE8:  CLRF   xDA
04CEA:  MOVLW  30
04CEC:  ADDWF  00,F
04CEE:  MOVFF  00,5E2
04CF2:  MOVLB  0
04CF4:  CALL   3E76
04CF8:  MOVLB  5
04CFA:  BCF    FD8.1
04CFC:  MOVFF  5E1,5E5
04D00:  MOVFF  5E0,5E4
04D04:  MOVFF  5DF,5E3
04D08:  MOVFF  5DE,5E2
04D0C:  CLRF   xE9
04D0E:  CLRF   xE8
04D10:  CLRF   xE7
04D12:  MOVLW  0A
04D14:  MOVWF  xE6
04D16:  MOVLB  0
04D18:  RCALL  4AEE
04D1A:  MOVFF  03,5E1
04D1E:  MOVFF  02,5E0
04D22:  MOVFF  01,5DF
04D26:  MOVFF  00,5DE
04D2A:  MOVLB  5
04D2C:  DECFSZ xDC,F
04D2E:  BRA    4C24
04D30:  MOVLB  0
04D32:  RETURN 0
*
0668C:  MOVF   FEF,F
0668E:  BZ    66B0
06690:  MOVFF  FEA,5C5
06694:  MOVFF  FE9,5C4
06698:  MOVFF  FEF,5E2
0669C:  CALL   3E76
066A0:  MOVFF  5C5,FEA
066A4:  MOVFF  5C4,FE9
066A8:  INCF   FE9,F
066AA:  BTFSC  FD8.2
066AC:  INCF   FEA,F
066AE:  BRA    668C
066B0:  GOTO   672E (RETURN)
.................... 
.................... #list
.................... 
.................... 
.................... #device ADC=10
.................... 
.................... //!#FUSES WDT                      //Watch Dog Timer
.................... //!#FUSES WDT4096                  //Watch Dog Timer uses 1:4096 Postscale
.................... 
.................... #use delay(internal=64000000)
*
003AC:  MOVLW  05
003AE:  MOVWF  FEA
003B0:  MOVLW  C0
003B2:  MOVWF  FE9
003B4:  MOVF   FEF,W
003B6:  BZ    03D4
003B8:  MOVLW  14
003BA:  MOVWF  01
003BC:  CLRF   00
003BE:  DECFSZ 00,F
003C0:  BRA    03BE
003C2:  DECFSZ 01,F
003C4:  BRA    03BC
003C6:  MOVLW  BF
003C8:  MOVWF  00
003CA:  DECFSZ 00,F
003CC:  BRA    03CA
003CE:  BRA    03D0
003D0:  DECFSZ FEF,F
003D2:  BRA    03B8
003D4:  RETURN 0
*
0065E:  MOVLW  01
00660:  MOVLB  5
00662:  SUBWF  xC9,F
00664:  BNC   067E
00666:  MOVLW  05
00668:  MOVWF  FEA
0066A:  MOVLW  C9
0066C:  MOVWF  FE9
0066E:  MOVF   FEF,W
00670:  BZ    067E
00672:  MOVLW  04
00674:  MOVWF  00
00676:  DECFSZ 00,F
00678:  BRA    0676
0067A:  DECFSZ FEF,F
0067C:  BRA    0672
0067E:  MOVLB  0
00680:  GOTO   06D0 (RETURN)
.................... #define baudRate 128000
.................... 
.................... #define version  "20250522" // SW Version
.................... #define serialID "0000"     // Unique Serial ID
.................... #define magPP 1             // Magnetoresistive Sensor Pole Pitch in mm       
.................... 
.................... 
.................... 
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define _LE          PIN_B4
.................... #define CLR          PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
*
00316:  MOVLW  CF
00318:  MOVWF  F87
0031A:  CLRF   F82
....................    output_b(portB_reset);
0031C:  MOVLW  F4
0031E:  MOVWF  F88
00320:  CLRF   F83
....................    output_c(portC_reset);
00322:  MOVLW  93
00324:  MOVWF  F89
00326:  CLRF   F84
....................    output_d(portD_reset);
00328:  MOVLW  1F
0032A:  MOVWF  F8A
0032C:  CLRF   F85
....................    output_e(portE_reset);
0032E:  BCF    F8B.0
00330:  BCF    F8B.1
00332:  BCF    F8B.2
00334:  BCF    F8B.3
00336:  CLRF   F86
....................    
....................    port_a_pullups(portA_pullups);
00338:  MOVLB  F
0033A:  SETF   x0B
....................    port_b_pullups(portB_pullups);
0033C:  CLRF   x13
....................    port_c_pullups(portC_pullups);
0033E:  CLRF   x1B
....................    port_d_pullups(portD_pullups);
00340:  SETF   x20
....................    port_e_pullups(portE_pullups);
00342:  CLRF   x28
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
00344:  MOVLW  40
00346:  MOVWF  x0C
00348:  CLRF   x14
0034A:  MOVLW  03
0034C:  MOVWF  x1C
0034E:  MOVLW  0F
00350:  MOVWF  x21
00352:  CLRF   x29
00354:  MOVLB  0
00356:  GOTO   6AB0 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
*
03DFE:  MOVFF  5E3,FEA
03E02:  MOVLB  5
03E04:  MOVFF  5E2,FE9
03E08:  MOVFF  FEF,5E6
03E0C:  MOVFF  5E5,FEA
03E10:  MOVFF  5E4,FE9
03E14:  MOVF   FEF,W
03E16:  SUBWF  xE6,W
03E18:  BNZ   3E48
....................       if (*s1 == '\0')
03E1A:  MOVFF  5E3,03
03E1E:  MOVFF  5E2,FE9
03E22:  MOVFF  03,FEA
03E26:  MOVF   FEF,F
03E28:  BNZ   3E30
....................          return(0);
03E2A:  MOVLW  00
03E2C:  MOVWF  01
03E2E:  BRA    3E72
03E30:  MOVFF  5E3,03
03E34:  MOVF   xE2,W
03E36:  INCF   xE2,F
03E38:  BTFSC  FD8.2
03E3A:  INCF   xE3,F
03E3C:  INCF   xE4,F
03E3E:  BTFSC  FD8.2
03E40:  INCF   xE5,F
03E42:  MOVLB  0
03E44:  BRA    3DFE
03E46:  MOVLB  5
....................    return((*s1 < *s2) ? -1: 1);
03E48:  MOVFF  5E3,03
03E4C:  MOVFF  5E2,FE9
03E50:  MOVFF  03,FEA
03E54:  MOVFF  FEF,5E6
03E58:  MOVFF  5E5,03
03E5C:  MOVFF  5E4,FE9
03E60:  MOVFF  03,FEA
03E64:  MOVF   FEF,W
03E66:  SUBWF  xE6,W
03E68:  BC    3E6E
03E6A:  MOVLW  FF
03E6C:  BRA    3E70
03E6E:  MOVLW  01
03E70:  MOVWF  01
03E72:  MOVLB  0
03E74:  RETURN 0
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
*
03F8E:  MOVFF  619,61C
....................    for(su=s;0<n;++su,--n)
03F92:  MOVFF  618,61E
03F96:  MOVFF  617,61D
03F9A:  MOVLB  6
03F9C:  MOVF   x1B,F
03F9E:  BNZ   3FA6
03FA0:  MOVF   x1A,W
03FA2:  SUBLW  00
03FA4:  BC    3FCE
....................       if(*su==uc)
03FA6:  MOVFF  61E,FEA
03FAA:  MOVFF  61D,FE9
03FAE:  MOVF   x1C,W
03FB0:  SUBWF  FEF,W
03FB2:  BNZ   3FBE
....................       return su;
03FB4:  MOVFF  61D,01
03FB8:  MOVFF  61E,02
03FBC:  BRA    3FD4
03FBE:  INCF   x1D,F
03FC0:  BTFSC  FD8.2
03FC2:  INCF   x1E,F
03FC4:  MOVF   x1A,W
03FC6:  BTFSC  FD8.2
03FC8:  DECF   x1B,F
03FCA:  DECF   x1A,F
03FCC:  BRA    3F9C
....................    return NULL;
03FCE:  MOVLW  00
03FD0:  MOVWF  01
03FD2:  MOVWF  02
03FD4:  MOVLB  0
03FD6:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
*
03DC6:  MOVFF  5E7,5E9
03DCA:  MOVFF  5E6,5E8
03DCE:  MOVFF  5E9,FEA
03DD2:  MOVLB  5
03DD4:  MOVFF  5E8,FE9
03DD8:  MOVF   FEF,F
03DDA:  BZ    3DE8
03DDC:  INCF   xE8,F
03DDE:  BTFSC  FD8.2
03DE0:  INCF   xE9,F
03DE2:  MOVLB  0
03DE4:  BRA    3DCE
03DE6:  MOVLB  5
....................    return(sc - s);
03DE8:  MOVF   xE6,W
03DEA:  SUBWF  xE8,W
03DEC:  MOVWF  00
03DEE:  MOVF   xE7,W
03DF0:  SUBWFB xE9,W
03DF2:  MOVWF  03
03DF4:  MOVFF  00,01
03DF8:  MOVWF  02
03DFA:  MOVLB  0
03DFC:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
*
0500E:  MOVLB  5
05010:  CLRF   xDA
05012:  CLRF   xD9
05014:  CLRF   xD8
05016:  MOVLW  7F
05018:  MOVWF  xD7
0501A:  CLRF   xDE
0501C:  CLRF   xDD
0501E:  CLRF   xDC
05020:  CLRF   xDB
05022:  BSF    xDF.0
05024:  BCF    xDF.1
05026:  BCF    xDF.2
05028:  CLRF   xE1
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
0502A:  MOVF   xD3,W
0502C:  IORWF  xD4,W
0502E:  BNZ   503A
....................       return 0;
05030:  CLRF   00
05032:  CLRF   01
05034:  CLRF   02
05036:  CLRF   03
05038:  BRA    526A
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
0503A:  MOVF   xE1,W
0503C:  INCF   xE1,F
0503E:  ADDWF  xD3,W
05040:  MOVWF  FE9
05042:  MOVLW  00
05044:  ADDWFC xD4,W
05046:  MOVWF  FEA
05048:  MOVFF  FEF,5E0
0504C:  MOVF   xE0,F
0504E:  BTFSC  FD8.2
05050:  BRA    51EC
....................    {
....................       if (skip && !isspace(c))
05052:  BTFSS  xDF.0
05054:  BRA    5074
05056:  MOVF   xE0,W
05058:  SUBLW  20
0505A:  BZ    5074
....................       {
....................          skip = 0;
0505C:  BCF    xDF.0
....................          if (c == '+')
0505E:  MOVF   xE0,W
05060:  SUBLW  2B
05062:  BNZ   506A
....................          {
....................             sign = 0;
05064:  BCF    xDF.1
....................             continue;
05066:  BRA    51D4
....................          }            
05068:  BRA    5074
....................          else if (c == '-')
0506A:  MOVF   xE0,W
0506C:  SUBLW  2D
0506E:  BNZ   5074
....................          {
....................             sign = 1;
05070:  BSF    xDF.1
....................             continue;
05072:  BRA    51D4
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
05074:  BTFSC  xDF.0
05076:  BRA    5086
05078:  MOVF   xE0,W
0507A:  SUBLW  2E
0507C:  BNZ   5086
0507E:  BTFSC  xDF.2
05080:  BRA    5086
....................          point = 1;
05082:  BSF    xDF.2
05084:  BRA    51D4
....................       else if (!skip && isdigit(c))
05086:  BTFSC  xDF.0
05088:  BRA    51CE
0508A:  MOVF   xE0,W
0508C:  SUBLW  2F
0508E:  BTFSC  FD8.0
05090:  BRA    51CE
05092:  MOVF   xE0,W
05094:  SUBLW  39
05096:  BTFSS  FD8.0
05098:  BRA    51CE
....................       {
....................          c -= '0';
0509A:  MOVLW  30
0509C:  SUBWF  xE0,F
....................          if (point)
0509E:  BTFSS  xDF.2
050A0:  BRA    5152
....................          {
....................             pow10 = pow10 * 10.0;
050A2:  MOVFF  5DA,616
050A6:  MOVFF  5D9,615
050AA:  MOVFF  5D8,614
050AE:  MOVFF  5D7,613
050B2:  MOVLB  6
050B4:  CLRF   x1A
050B6:  CLRF   x19
050B8:  MOVLW  20
050BA:  MOVWF  x18
050BC:  MOVLW  82
050BE:  MOVWF  x17
050C0:  MOVLB  0
050C2:  CALL   09FA
050C6:  MOVFF  03,5DA
050CA:  MOVFF  02,5D9
050CE:  MOVFF  01,5D8
050D2:  MOVFF  00,5D7
....................             result += (float)c / pow10;   
050D6:  MOVLB  6
050D8:  CLRF   x18
050DA:  MOVFF  5E0,617
050DE:  MOVLB  0
050E0:  CALL   09C4
050E4:  MOVFF  03,5E5
050E8:  MOVFF  02,5E4
050EC:  MOVFF  01,5E3
050F0:  MOVFF  00,5E2
050F4:  MOVFF  03,60F
050F8:  MOVFF  02,60E
050FC:  MOVFF  01,60D
05100:  MOVFF  00,60C
05104:  MOVFF  5DA,613
05108:  MOVFF  5D9,612
0510C:  MOVFF  5D8,611
05110:  MOVFF  5D7,610
05114:  CALL   13A6
05118:  BCF    FD8.1
0511A:  MOVFF  5DE,61A
0511E:  MOVFF  5DD,619
05122:  MOVFF  5DC,618
05126:  MOVFF  5DB,617
0512A:  MOVFF  03,61E
0512E:  MOVFF  02,61D
05132:  MOVFF  01,61C
05136:  MOVFF  00,61B
0513A:  CALL   0AF0
0513E:  MOVFF  03,5DE
05142:  MOVFF  02,5DD
05146:  MOVFF  01,5DC
0514A:  MOVFF  00,5DB
....................          }
0514E:  BRA    51CA
05150:  MOVLB  5
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
05152:  MOVLB  6
05154:  CLRF   x16
05156:  CLRF   x15
05158:  MOVLW  20
0515A:  MOVWF  x14
0515C:  MOVLW  82
0515E:  MOVWF  x13
05160:  MOVFF  5DE,61A
05164:  MOVFF  5DD,619
05168:  MOVFF  5DC,618
0516C:  MOVFF  5DB,617
05170:  MOVLB  0
05172:  CALL   09FA
05176:  MOVFF  03,5E5
0517A:  MOVFF  02,5E4
0517E:  MOVFF  01,5E3
05182:  MOVFF  00,5E2
05186:  MOVLB  6
05188:  CLRF   x18
0518A:  MOVFF  5E0,617
0518E:  MOVLB  0
05190:  CALL   09C4
05194:  BCF    FD8.1
05196:  MOVFF  5E5,61A
0519A:  MOVFF  5E4,619
0519E:  MOVFF  5E3,618
051A2:  MOVFF  5E2,617
051A6:  MOVFF  03,61E
051AA:  MOVFF  02,61D
051AE:  MOVFF  01,61C
051B2:  MOVFF  00,61B
051B6:  CALL   0AF0
051BA:  MOVFF  03,5DE
051BE:  MOVFF  02,5DD
051C2:  MOVFF  01,5DC
051C6:  MOVFF  00,5DB
....................          }
....................       }
051CA:  BRA    51D6
051CC:  MOVLB  5
....................       else if (!skip)
051CE:  BTFSC  xDF.0
051D0:  BRA    51D4
....................          break;
051D2:  BRA    51EC
051D4:  MOVLB  0
051D6:  MOVLB  5
051D8:  MOVF   xE1,W
051DA:  INCF   xE1,F
051DC:  ADDWF  xD3,W
051DE:  MOVWF  FE9
051E0:  MOVLW  00
051E2:  ADDWFC xD4,W
051E4:  MOVWF  FEA
051E6:  MOVFF  FEF,5E0
051EA:  BRA    504C
....................    }
.................... 
....................    if (sign)
051EC:  BTFSS  xDF.1
051EE:  BRA    5226
....................       result = -1*result;
051F0:  MOVLB  6
051F2:  CLRF   x16
051F4:  CLRF   x15
051F6:  MOVLW  80
051F8:  MOVWF  x14
051FA:  MOVLW  7F
051FC:  MOVWF  x13
051FE:  MOVFF  5DE,61A
05202:  MOVFF  5DD,619
05206:  MOVFF  5DC,618
0520A:  MOVFF  5DB,617
0520E:  MOVLB  0
05210:  CALL   09FA
05214:  MOVFF  03,5DE
05218:  MOVFF  02,5DD
0521C:  MOVFF  01,5DC
05220:  MOVFF  00,5DB
05224:  MOVLB  5
....................       
....................    if(endptr)
05226:  MOVF   xD5,W
05228:  IORWF  xD6,W
0522A:  BZ    525A
....................    {
....................       if (ptr) {
0522C:  MOVF   xE1,F
0522E:  BZ    5248
....................          ptr--;
05230:  DECF   xE1,F
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
05232:  MOVFF  5D6,FEA
05236:  MOVFF  5D5,FE9
0523A:  MOVF   xE1,W
0523C:  ADDWF  xD3,W
0523E:  MOVWF  FEF
05240:  MOVLW  00
05242:  ADDWFC xD4,W
05244:  MOVWF  FEC
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
05246:  BRA    525A
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
05248:  MOVFF  5D6,FEA
0524C:  MOVFF  5D5,FE9
05250:  MOVFF  5D4,FEC
05254:  MOVF   FED,F
05256:  MOVFF  5D3,FEF
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
0525A:  MOVFF  5DB,00
0525E:  MOVFF  5DC,01
05262:  MOVFF  5DD,02
05266:  MOVFF  5DE,03
0526A:  MOVLB  0
0526C:  RETURN 0
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
*
0402E:  MOVLB  5
04030:  CLRF   xF0
04032:  CLRF   xEF
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
04034:  MOVLW  30
04036:  MOVWF  xF2
04038:  MOVLW  31
0403A:  MOVWF  xF3
0403C:  MOVLW  32
0403E:  MOVWF  xF4
04040:  MOVLW  33
04042:  MOVWF  xF5
04044:  MOVLW  34
04046:  MOVWF  xF6
04048:  MOVLW  35
0404A:  MOVWF  xF7
0404C:  MOVLW  36
0404E:  MOVWF  xF8
04050:  MOVLW  37
04052:  MOVWF  xF9
04054:  MOVLW  38
04056:  MOVWF  xFA
04058:  MOVLW  39
0405A:  MOVWF  xFB
0405C:  MOVLW  61
0405E:  MOVWF  xFC
04060:  MOVLW  62
04062:  MOVWF  xFD
04064:  MOVLW  63
04066:  MOVWF  xFE
04068:  MOVLW  64
0406A:  MOVWF  xFF
0406C:  MOVLW  65
0406E:  MOVLB  6
04070:  MOVWF  x00
04072:  MOVLW  66
04074:  MOVWF  x01
04076:  MOVLW  67
04078:  MOVWF  x02
0407A:  MOVLW  68
0407C:  MOVWF  x03
0407E:  MOVLW  69
04080:  MOVWF  x04
04082:  MOVLW  6A
04084:  MOVWF  x05
04086:  MOVLW  6B
04088:  MOVWF  x06
0408A:  MOVLW  6C
0408C:  MOVWF  x07
0408E:  MOVLW  6D
04090:  MOVWF  x08
04092:  MOVLW  6E
04094:  MOVWF  x09
04096:  MOVLW  6F
04098:  MOVWF  x0A
0409A:  MOVLW  70
0409C:  MOVWF  x0B
0409E:  MOVLW  71
040A0:  MOVWF  x0C
040A2:  MOVLW  73
040A4:  MOVWF  x0D
040A6:  MOVLW  74
040A8:  MOVWF  x0E
040AA:  MOVLW  75
040AC:  MOVWF  x0F
040AE:  MOVLW  76
040B0:  MOVWF  x10
040B2:  MOVLW  77
040B4:  MOVWF  x11
040B6:  MOVLW  78
040B8:  MOVWF  x12
040BA:  MOVLW  79
040BC:  MOVWF  x13
040BE:  MOVLW  7A
040C0:  MOVWF  x14
040C2:  CLRF   x15
....................    for(sc=s;isspace(*sc);++sc);
040C4:  MOVFF  5E5,5EA
040C8:  MOVFF  5E4,5E9
040CC:  MOVFF  5EA,FEA
040D0:  MOVLB  5
040D2:  MOVFF  5E9,FE9
040D6:  MOVF   FEF,W
040D8:  SUBLW  20
040DA:  BNZ   40E8
040DC:  INCF   xE9,F
040DE:  BTFSC  FD8.2
040E0:  INCF   xEA,F
040E2:  MOVLB  6
040E4:  BRA    40CC
040E6:  MOVLB  5
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
040E8:  MOVFF  5EA,03
040EC:  MOVFF  5E9,FE9
040F0:  MOVFF  03,FEA
040F4:  MOVF   FEF,W
040F6:  SUBLW  2D
040F8:  BZ    4108
040FA:  MOVFF  5EA,FEA
040FE:  MOVFF  5E9,FE9
04102:  MOVF   FEF,W
04104:  SUBLW  2B
04106:  BNZ   411A
04108:  MOVFF  5EA,FEA
0410C:  MOVF   xE9,W
0410E:  INCF   xE9,F
04110:  BTFSC  FD8.2
04112:  INCF   xEA,F
04114:  MOVWF  FE9
04116:  MOVF   FEF,W
04118:  BRA    411C
0411A:  MOVLW  2B
0411C:  MOVWF  xF1
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
0411E:  MOVF   xF1,W
04120:  SUBLW  2D
04122:  BZ    4138
04124:  BTFSC  xE8.7
04126:  BRA    4138
04128:  DECFSZ xE8,W
0412A:  BRA    412E
0412C:  BRA    4138
0412E:  BTFSC  xE8.7
04130:  BRA    413C
04132:  MOVF   xE8,W
04134:  SUBLW  24
04136:  BC    413C
....................    goto StrtoulGO;
04138:  BRA    434C
0413A:  BRA    4234
.................... 
....................    else if (base)
0413C:  MOVF   xE8,F
0413E:  BZ    41CC
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
04140:  MOVF   xE8,W
04142:  SUBLW  10
04144:  BNZ   4180
04146:  MOVFF  5EA,FEA
0414A:  MOVFF  5E9,FE9
0414E:  MOVF   FEF,W
04150:  SUBLW  30
04152:  BNZ   4180
04154:  MOVLW  01
04156:  ADDWF  xE9,W
04158:  MOVWF  FE9
0415A:  MOVLW  00
0415C:  ADDWFC xEA,W
0415E:  MOVWF  FEA
04160:  MOVF   FEF,W
04162:  SUBLW  78
04164:  BZ    4178
04166:  MOVLW  01
04168:  ADDWF  xE9,W
0416A:  MOVWF  FE9
0416C:  MOVLW  00
0416E:  ADDWFC xEA,W
04170:  MOVWF  FEA
04172:  MOVF   FEF,W
04174:  SUBLW  58
04176:  BNZ   4180
....................          sc+=2;
04178:  MOVLW  02
0417A:  ADDWF  xE9,F
0417C:  MOVLW  00
0417E:  ADDWFC xEA,F
....................       if(base==8 && *sc =='0')
04180:  MOVF   xE8,W
04182:  SUBLW  08
04184:  BNZ   419C
04186:  MOVFF  5EA,FEA
0418A:  MOVFF  5E9,FE9
0418E:  MOVF   FEF,W
04190:  SUBLW  30
04192:  BNZ   419C
....................          sc+=1;
04194:  MOVLW  01
04196:  ADDWF  xE9,F
04198:  MOVLW  00
0419A:  ADDWFC xEA,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
0419C:  MOVF   xE8,W
0419E:  SUBLW  02
041A0:  BNZ   41CA
041A2:  MOVFF  5EA,FEA
041A6:  MOVFF  5E9,FE9
041AA:  MOVF   FEF,W
041AC:  SUBLW  30
041AE:  BNZ   41CA
041B0:  MOVLW  01
041B2:  ADDWF  xE9,W
041B4:  MOVWF  FE9
041B6:  MOVLW  00
041B8:  ADDWFC xEA,W
041BA:  MOVWF  FEA
041BC:  MOVF   FEF,W
041BE:  SUBLW  62
041C0:  BNZ   41CA
....................          sc+=2;
041C2:  MOVLW  02
041C4:  ADDWF  xE9,F
041C6:  MOVLW  00
041C8:  ADDWFC xEA,F
.................... 
....................    }
041CA:  BRA    4234
....................    else if(*sc!='0') // base is 0, find base
041CC:  MOVFF  5EA,FEA
041D0:  MOVFF  5E9,FE9
041D4:  MOVF   FEF,W
041D6:  SUBLW  30
041D8:  BZ    41E0
....................       base=10;
041DA:  MOVLW  0A
041DC:  MOVWF  xE8
041DE:  BRA    4234
....................    else if (sc[1]=='x' || sc[1]=='X')
041E0:  MOVLW  01
041E2:  ADDWF  xE9,W
041E4:  MOVWF  FE9
041E6:  MOVLW  00
041E8:  ADDWFC xEA,W
041EA:  MOVWF  FEA
041EC:  MOVF   FEF,W
041EE:  SUBLW  78
041F0:  BZ    4204
041F2:  MOVLW  01
041F4:  ADDWF  xE9,W
041F6:  MOVWF  FE9
041F8:  MOVLW  00
041FA:  ADDWFC xEA,W
041FC:  MOVWF  FEA
041FE:  MOVF   FEF,W
04200:  SUBLW  58
04202:  BNZ   4212
....................       base =16,sc+=2;
04204:  MOVLW  10
04206:  MOVWF  xE8
04208:  MOVLW  02
0420A:  ADDWF  xE9,F
0420C:  MOVLW  00
0420E:  ADDWFC xEA,F
04210:  BRA    4234
....................    else if(sc[1]=='b')
04212:  MOVLW  01
04214:  ADDWF  xE9,W
04216:  MOVWF  FE9
04218:  MOVLW  00
0421A:  ADDWFC xEA,W
0421C:  MOVWF  FEA
0421E:  MOVF   FEF,W
04220:  SUBLW  62
04222:  BNZ   4230
....................       base=2,sc+=2;
04224:  MOVLW  02
04226:  MOVWF  xE8
04228:  ADDWF  xE9,F
0422A:  MOVLW  00
0422C:  ADDWFC xEA,F
0422E:  BRA    4234
....................    else
....................       base=8;
04230:  MOVLW  08
04232:  MOVWF  xE8
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
04234:  MOVFF  5EA,5EC
04238:  MOVFF  5E9,5EB
0423C:  MOVFF  5EA,FEA
04240:  MOVFF  5E9,FE9
04244:  MOVF   FEF,W
04246:  SUBLW  30
04248:  BNZ   4252
0424A:  INCF   xE9,F
0424C:  BTFSC  FD8.2
0424E:  INCF   xEA,F
04250:  BRA    423C
....................    sd=memchr(digits,tolower(*sc),base);
04252:  MOVFF  5EA,03
04256:  MOVFF  5E9,FE9
0425A:  MOVFF  03,FEA
0425E:  MOVFF  FEF,616
04262:  MOVLB  6
04264:  MOVF   x16,W
04266:  SUBLW  40
04268:  BC    4276
0426A:  MOVF   x16,W
0426C:  SUBLW  5A
0426E:  BNC   4276
04270:  MOVF   x16,W
04272:  IORLW  20
04274:  BRA    4278
04276:  MOVF   x16,W
04278:  MOVWF  x16
0427A:  MOVLW  05
0427C:  MOVWF  x18
0427E:  MOVLW  F2
04280:  MOVWF  x17
04282:  MOVFF  616,619
04286:  CLRF   x1B
04288:  MOVFF  5E8,61A
0428C:  BTFSC  x1A.7
0428E:  DECF   x1B,F
04290:  MOVLB  0
04292:  RCALL  3F8E
04294:  MOVFF  02,5EE
04298:  MOVFF  01,5ED
....................    for(; sd!=0; )
0429C:  MOVLB  5
0429E:  MOVF   xED,F
042A0:  BNZ   42A6
042A2:  MOVF   xEE,F
042A4:  BZ    4340
....................    {
....................       x=x*base+(int16)(sd-digits);
042A6:  CLRF   03
042A8:  MOVF   xE8,W
042AA:  MOVWF  00
042AC:  BTFSC  FE8.7
042AE:  DECF   03,F
042B0:  MOVLB  6
042B2:  MOVWF  x16
042B4:  MOVFF  03,617
042B8:  MOVFF  5F0,619
042BC:  MOVFF  5EF,618
042C0:  MOVFF  03,61B
042C4:  MOVWF  x1A
042C6:  MOVLB  0
042C8:  BRA    3FD8
042CA:  MOVFF  01,616
042CE:  MOVLW  F2
042D0:  MOVLB  5
042D2:  SUBWF  xED,W
042D4:  MOVWF  00
042D6:  MOVLW  05
042D8:  SUBWFB xEE,W
042DA:  MOVWF  03
042DC:  MOVF   00,W
042DE:  ADDWF  01,W
042E0:  MOVWF  01
042E2:  MOVF   02,W
042E4:  ADDWFC 03,F
042E6:  MOVFF  01,5EF
042EA:  MOVLB  5
042EC:  MOVFF  03,5F0
....................       ++sc;
042F0:  INCF   xE9,F
042F2:  BTFSC  FD8.2
042F4:  INCF   xEA,F
....................       sd=memchr(digits,tolower(*sc),base);
042F6:  MOVFF  5EA,FEA
042FA:  MOVFF  5E9,FE9
042FE:  MOVFF  FEF,616
04302:  MOVLB  6
04304:  MOVF   x16,W
04306:  SUBLW  40
04308:  BC    4316
0430A:  MOVF   x16,W
0430C:  SUBLW  5A
0430E:  BNC   4316
04310:  MOVF   x16,W
04312:  IORLW  20
04314:  BRA    4318
04316:  MOVF   x16,W
04318:  MOVWF  x16
0431A:  MOVLW  05
0431C:  MOVWF  x18
0431E:  MOVLW  F2
04320:  MOVWF  x17
04322:  MOVFF  616,619
04326:  CLRF   x1B
04328:  MOVFF  5E8,61A
0432C:  BTFSC  x1A.7
0432E:  DECF   x1B,F
04330:  MOVLB  0
04332:  RCALL  3F8E
04334:  MOVFF  02,5EE
04338:  MOVFF  01,5ED
0433C:  BRA    429C
0433E:  MOVLB  5
....................    }
....................    if(s1==sc)
04340:  MOVF   xE9,W
04342:  SUBWF  xEB,W
04344:  BNZ   436E
04346:  MOVF   xEA,W
04348:  SUBWF  xEC,W
0434A:  BNZ   436E
....................    {
....................    StrtoulGO:
....................       if (endptr)
0434C:  MOVLB  5
0434E:  MOVF   xE6,W
04350:  IORWF  xE7,W
04352:  BZ    4366
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
04354:  MOVFF  5E7,FEA
04358:  MOVFF  5E6,FE9
0435C:  MOVFF  5E5,FEC
04360:  MOVF   FED,F
04362:  MOVFF  5E4,FEF
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
04366:  MOVLW  00
04368:  MOVWF  01
0436A:  MOVWF  02
0436C:  BRA    438E
....................    }
....................    if (endptr)
0436E:  MOVF   xE6,W
04370:  IORWF  xE7,W
04372:  BZ    4386
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
04374:  MOVFF  5E7,FEA
04378:  MOVFF  5E6,FE9
0437C:  MOVFF  5EA,FEC
04380:  MOVF   FED,F
04382:  MOVFF  5E9,FEF
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
04386:  MOVFF  5EF,01
0438A:  MOVFF  5F0,02
0438E:  MOVLB  0
04390:  RETURN 0
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {VOLTAGE, MAGSENS}; // Voltage or Magnetic Sensor Control
.................... //!typedef enum sensorType {kmxp1000, kmxp2000}; // Magsensors
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2];
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MAGSENS, MAGSENS};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = 
.................... {
....................    {0,1}, {0,1}, {0,1}, {0,1}, {0,1}, {0,1}, {0,1}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals;
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;    // adc raw count data
....................    float cosRaw;    // adc raw count data
....................    float sinCounts; // calibrated counts
....................    float cosCounts; // calibrated counts
....................    float p0;               // position in units of pole-pitch
....................    int8  npoles;           // number of poles passed
....................    float pReal;            // real position
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0},
....................    {0,0,0,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
*
003D6:  MOVLB  5
003D8:  CLRF   xC4
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
003DA:  CLRF   xC4
003DC:  MOVF   xC3,W
003DE:  SUBWF  xC4,W
003E0:  BC    0438
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
003E2:  MOVF   xC4,W
003E4:  ADDWF  xC1,W
003E6:  MOVWF  xC5
003E8:  MOVLW  00
003EA:  ADDWFC xC2,W
003EC:  MOVWF  xC6
003EE:  MOVF   xC4,W
003F0:  ADDWF  xBF,W
003F2:  MOVWF  01
003F4:  MOVLW  00
003F6:  ADDWFC xC0,W
003F8:  MOVWF  03
003FA:  MOVF   01,W
003FC:  MOVWF  FE9
003FE:  MOVFF  03,FEA
00402:  MOVFF  FEF,5C7
00406:  BSF    F7F.7
00408:  MOVF   FF2,W
0040A:  MOVWF  00
0040C:  BCF    FF2.7
0040E:  MOVFF  5C6,F7A
00412:  MOVFF  5C5,F79
00416:  MOVLW  31
00418:  MOVWF  F7B
0041A:  MOVFF  5C7,F7C
0041E:  MOVLB  F
00420:  MOVLW  55
00422:  MOVWF  F81
00424:  MOVLW  AA
00426:  MOVWF  F81
00428:  BSF    F80.4
0042A:  BTFSC  F80.4
0042C:  BRA    042A
0042E:  MOVF   00,W
00430:  IORWF  FF2,F
00432:  MOVLB  5
00434:  INCF   xC4,F
00436:  BRA    03DC
....................    }
00438:  MOVLB  0
0043A:  RETURN 0
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
*
0035A:  MOVLB  5
0035C:  CLRF   xC4
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
0035E:  CLRF   xC4
00360:  MOVF   xC3,W
00362:  SUBWF  xC4,W
00364:  BC    03A8
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
00366:  MOVF   xC4,W
00368:  ADDWF  xBF,W
0036A:  MOVWF  01
0036C:  MOVLW  00
0036E:  ADDWFC xC0,W
00370:  MOVWF  03
00372:  MOVF   01,W
00374:  MOVWF  FE9
00376:  MOVFF  03,FEA
0037A:  MOVF   xC4,W
0037C:  ADDWF  xC1,W
0037E:  MOVWF  xC7
00380:  MOVLW  00
00382:  ADDWFC xC2,W
00384:  MOVWF  xC8
00386:  BSF    F7F.7
00388:  MOVFF  FF2,5C9
0038C:  BCF    FF2.7
0038E:  MOVFF  5C8,F7A
00392:  MOVFF  5C7,F79
00396:  MOVLW  31
00398:  MOVWF  F7B
0039A:  BSF    F80.0
0039C:  MOVF   F7C,W
0039E:  BTFSC  xC9.7
003A0:  BSF    FF2.7
003A2:  MOVWF  FEF
003A4:  INCF   xC4,F
003A6:  BRA    0360
....................    }
003A8:  MOVLB  0
003AA:  RETURN 0
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
*
0043C:  MOVLB  5
0043E:  CLRF   xC0
00440:  MOVLW  20
00442:  MOVWF  xBF
00444:  CLRF   xC2
00446:  CLRF   xC1
00448:  MOVLW  80
0044A:  MOVWF  xC3
0044C:  MOVLB  0
0044E:  RCALL  03D6
....................    delay_ms(1);
00450:  MOVLW  01
00452:  MOVLB  5
00454:  MOVWF  xC0
00456:  MOVLB  0
00458:  RCALL  03AC
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
0045A:  MOVLB  5
0045C:  CLRF   xC0
0045E:  MOVLW  60
00460:  MOVWF  xBF
00462:  CLRF   xC2
00464:  MOVLW  80
00466:  MOVWF  xC1
00468:  MOVLW  02
0046A:  MOVWF  xC3
0046C:  MOVLB  0
0046E:  RCALL  03D6
....................    delay_ms(1);
00470:  MOVLW  01
00472:  MOVLB  5
00474:  MOVWF  xC0
00476:  MOVLB  0
00478:  RCALL  03AC
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
0047A:  MOVLB  5
0047C:  CLRF   xC0
0047E:  MOVLW  61
00480:  MOVWF  xBF
00482:  CLRF   xC2
00484:  MOVLW  90
00486:  MOVWF  xC1
00488:  MOVLW  02
0048A:  MOVWF  xC3
0048C:  MOVLB  0
0048E:  RCALL  03D6
....................    delay_ms(1);
00490:  MOVLW  01
00492:  MOVLB  5
00494:  MOVWF  xC0
00496:  MOVLB  0
00498:  RCALL  03AC
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
0049A:  MOVLB  5
0049C:  CLRF   xC0
0049E:  MOVLW  62
004A0:  MOVWF  xBF
004A2:  CLRF   xC2
004A4:  MOVLW  A0
004A6:  MOVWF  xC1
004A8:  MOVLW  20
004AA:  MOVWF  xC3
004AC:  MOVLB  0
004AE:  RCALL  03D6
....................    delay_ms(1);
004B0:  MOVLW  01
004B2:  MOVLB  5
004B4:  MOVWF  xC0
004B6:  MOVLB  0
004B8:  RCALL  03AC
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
004BA:  MOVLB  5
004BC:  CLRF   xC0
004BE:  MOVLW  82
004C0:  MOVWF  xBF
004C2:  CLRF   xC2
004C4:  MOVLW  C0
004C6:  MOVWF  xC1
004C8:  MOVLW  30
004CA:  MOVWF  xC3
004CC:  MOVLB  0
004CE:  RCALL  03D6
....................    delay_ms(1);
004D0:  MOVLW  01
004D2:  MOVLB  5
004D4:  MOVWF  xC0
004D6:  MOVLB  0
004D8:  RCALL  03AC
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
004DA:  MOVLB  5
004DC:  CLRF   xC0
004DE:  MOVLW  B2
004E0:  MOVWF  xBF
004E2:  CLRF   xC2
004E4:  MOVLW  F0
004E6:  MOVWF  xC1
004E8:  MOVLW  38
004EA:  MOVWF  xC3
004EC:  MOVLB  0
004EE:  RCALL  03D6
....................    delay_ms(1);
004F0:  MOVLW  01
004F2:  MOVLB  5
004F4:  MOVWF  xC0
004F6:  MOVLB  0
004F8:  RCALL  03AC
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
004FA:  MOVLB  5
004FC:  CLRF   xC0
004FE:  MOVLW  F2
00500:  MOVWF  xBF
00502:  MOVLW  01
00504:  MOVWF  xC2
00506:  MOVLW  40
00508:  MOVWF  xC1
0050A:  MOVLW  01
0050C:  MOVWF  xC3
0050E:  MOVLB  0
00510:  RCALL  03D6
....................    delay_ms(1);
00512:  MOVLW  01
00514:  MOVLB  5
00516:  MOVWF  xC0
00518:  MOVLB  0
0051A:  RCALL  03AC
0051C:  GOTO   05EC (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
00520:  MOVLB  5
00522:  CLRF   xC0
00524:  MOVLW  20
00526:  MOVWF  xBF
00528:  CLRF   xC2
0052A:  CLRF   xC1
0052C:  MOVLW  80
0052E:  MOVWF  xC3
00530:  MOVLB  0
00532:  RCALL  035A
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
00534:  MOVLB  5
00536:  CLRF   xC0
00538:  MOVLW  60
0053A:  MOVWF  xBF
0053C:  CLRF   xC2
0053E:  MOVLW  80
00540:  MOVWF  xC1
00542:  MOVLW  02
00544:  MOVWF  xC3
00546:  MOVLB  0
00548:  RCALL  035A
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
0054A:  MOVLB  5
0054C:  CLRF   xC0
0054E:  MOVLW  61
00550:  MOVWF  xBF
00552:  CLRF   xC2
00554:  MOVLW  90
00556:  MOVWF  xC1
00558:  MOVLW  02
0055A:  MOVWF  xC3
0055C:  MOVLB  0
0055E:  RCALL  035A
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
00560:  MOVLB  5
00562:  CLRF   xC0
00564:  MOVLW  62
00566:  MOVWF  xBF
00568:  CLRF   xC2
0056A:  MOVLW  A0
0056C:  MOVWF  xC1
0056E:  MOVLW  20
00570:  MOVWF  xC3
00572:  MOVLB  0
00574:  RCALL  035A
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
00576:  MOVLB  5
00578:  CLRF   xC0
0057A:  MOVLW  82
0057C:  MOVWF  xBF
0057E:  CLRF   xC2
00580:  MOVLW  C0
00582:  MOVWF  xC1
00584:  MOVLW  30
00586:  MOVWF  xC3
00588:  MOVLB  0
0058A:  RCALL  035A
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
0058C:  MOVLB  5
0058E:  CLRF   xC0
00590:  MOVLW  B2
00592:  MOVWF  xBF
00594:  CLRF   xC2
00596:  MOVLW  F0
00598:  MOVWF  xC1
0059A:  MOVLW  38
0059C:  MOVWF  xC3
0059E:  MOVLB  0
005A0:  RCALL  035A
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
005A2:  MOVLB  5
005A4:  CLRF   xC0
005A6:  MOVLW  F2
005A8:  MOVWF  xBF
005AA:  MOVLW  01
005AC:  MOVWF  xC2
005AE:  MOVLW  40
005B0:  MOVWF  xC1
005B2:  MOVLW  01
005B4:  MOVWF  xC3
005B6:  MOVLB  0
005B8:  RCALL  035A
005BA:  GOTO   05F0 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
005BE:  MOVLB  5
005C0:  CLRF   xC0
005C2:  MOVLW  F2
005C4:  MOVWF  xBF
005C6:  MOVLW  01
005C8:  MOVWF  xC2
005CA:  MOVLW  40
005CC:  MOVWF  xC1
005CE:  MOVLW  01
005D0:  MOVWF  xC3
005D2:  MOVLB  0
005D4:  RCALL  035A
....................    delay_ms(1);
005D6:  MOVLW  01
005D8:  MOVLB  5
005DA:  MOVWF  xC0
005DC:  MOVLB  0
005DE:  RCALL  03AC
....................    if (paramsValid != isValid)
005E0:  MOVF   xF2,W
005E2:  SUBLW  AA
005E4:  BZ    05EE
....................    {
....................       paramsValid = isValid;
005E6:  MOVLW  AA
005E8:  MOVWF  xF2
....................       params_save_to_ee(); // saves the base parameters on first boot
005EA:  BRA    043C
....................    }
005EC:  BRA    05F0
....................    else
....................    {
....................       params_load_from_ee();
005EE:  BRA    0520
....................    }
005F0:  GOTO   6AB4 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <monitor.h>
.................... #ifndef monitor
.................... #define monitor
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define _LE          PIN_B4
.................... #define CLR          PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
....................    output_b(portB_reset);
....................    output_c(portC_reset);
....................    output_d(portD_reset);
....................    output_e(portE_reset);
....................    
....................    port_a_pullups(portA_pullups);
....................    port_b_pullups(portB_pullups);
....................    port_c_pullups(portC_pullups);
....................    port_d_pullups(portD_pullups);
....................    port_e_pullups(portE_pullups);
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {VOLTAGE, MAGSENS}; // Voltage or Magnetic Sensor Control
.................... //!typedef enum sensorType {kmxp1000, kmxp2000}; // Magsensors
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2];
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MAGSENS, MAGSENS};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = 
.................... {
....................    {0,1}, {0,1}, {0,1}, {0,1}, {0,1}, {0,1}, {0,1}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals;
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;    // adc raw count data
....................    float cosRaw;    // adc raw count data
....................    float sinCounts; // calibrated counts
....................    float cosCounts; // calibrated counts
....................    float p0;               // position in units of pole-pitch
....................    int8  npoles;           // number of poles passed
....................    float pReal;            // real position
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0},
....................    {0,0,0,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <ADS1220.h>
.................... #ifndef ADS1220
.................... #define ADS1220
.................... 
.................... /*****************************************************************************/
.................... /* SET UP PORTS FOR USE WITH DRIVER                                          */
.................... /*****************************************************************************/
.................... #define _CS0  PIN_D5 // chip select pins 
.................... #define _CS1  PIN_D6
.................... #define _CS2  PIN_D7
.................... #define _CS3  PIN_B0
.................... 
.................... #pin_select SCK2=PIN_B1
.................... #pin_select SDI2=PIN_B2
.................... #pin_select SDO2=PIN_B3
.................... #use spi(MASTER, SPI2, BAUD=1000000, MODE=1, STREAM=SPI_mon)
*
00190:  MOVLB  E
00192:  MOVF   x8D,W
00194:  MOVFF  62C,E8D
00198:  RRCF   x90,W
0019A:  BNC   0198
0019C:  MOVF   x8D,W
0019E:  MOVWF  03
001A0:  MOVFF  62B,E8D
001A4:  RRCF   x90,W
001A6:  BNC   01A4
001A8:  MOVF   x8D,W
001AA:  MOVWF  02
001AC:  MOVFF  62A,E8D
001B0:  RRCF   x90,W
001B2:  BNC   01B0
001B4:  MOVF   x8D,W
001B6:  MOVWF  01
001B8:  MOVFF  629,E8D
001BC:  RRCF   x90,W
001BE:  BNC   01BC
001C0:  MOVFF  E8D,00
001C4:  MOVLB  0
001C6:  RETURN 0
*
0127E:  CLRF   03
01280:  MOVLB  E
01282:  MOVF   x8D,W
01284:  MOVFF  5CF,E8D
01288:  RRCF   x90,W
0128A:  BNC   1288
0128C:  MOVF   x8D,W
0128E:  MOVWF  02
01290:  MOVFF  5CE,E8D
01294:  RRCF   x90,W
01296:  BNC   1294
01298:  MOVF   x8D,W
0129A:  MOVWF  01
0129C:  MOVFF  5CD,E8D
012A0:  RRCF   x90,W
012A2:  BNC   12A0
012A4:  MOVFF  E8D,00
012A8:  MOVLB  0
012AA:  GOTO   12CC (RETURN)
.................... 
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* REGISTER DEFINITIONS                                                      */
.................... /*****************************************************************************/
.................... typedef enum {reg0 = 0x00,reg1 = 0x04 ,reg2 = 0x08, reg3 = 0x0C}adsReg;
.................... 
.................... //REGISTER 0 OPTIONS
.................... 
.................... #define IPp0n1 0x00
.................... #define IPp0n2 0x10
.................... #define IPp0n3 0x20
.................... #define IPp1n2 0x30
.................... #define IPp1n3 0x40
.................... #define IPp2n3 0x50
.................... #define IPp1n0 0x60
.................... #define IPp3n2 0x70
.................... #define IPp0nVss 0x80
.................... #define IPp1nVss 0x90
.................... #define IPp2nVss 0xA0
.................... #define IPp3nVss 0xB0
.................... #define IPVrpVrn 0xC0
.................... #define IPVddVss 0xD0
.................... #define IPhalfRail 0xE0
.................... 
.................... #define g1 0x00
.................... #define g2 0x02
.................... #define g4 0x04
.................... #define g8 0x06
.................... #define g16 0x08
.................... #define g32 0x0A
.................... #define g64 0x0C
.................... #define g128 0x0E
.................... 
.................... #define PGAenabled 0x00
.................... #define PGAbypass 0x01
.................... 
.................... //REGISTER 1 OPTIONS
.................... 
.................... #define DRn20 0x00
.................... #define DRn45 0x20
.................... #define DRn90 0x40
.................... #define DRn175 0x60
.................... #define DRn330 0x80
.................... #define DRn600 0xA0
.................... #define DRn1000 0xC0
.................... 
.................... #define MDnormal 0x00
.................... #define MDduty 0x80
.................... #define MDturbo 0x10
.................... 
.................... #define CMsingle 0x00
.................... #define CMcont 0x40
.................... 
.................... #define TSdisable 0x00
.................... #define TSenable 0x20
.................... 
.................... #define BCSoff 0x00
.................... #define BCSon 0x01
.................... 
.................... //REGISTER 2 OPTIONS
.................... 
.................... #define REFinternal 0x00
.................... #define REFp0n0 0x40
.................... #define REFp1n1 0x80
.................... #define REFVddVss 0xC0
.................... 
.................... #define FIRoff 0x00
.................... #define FIR5060 0x10
.................... #define FIR50 0x20
.................... #define FIR60 0x30
.................... 
.................... #define PSWopen 0x00
.................... #define PSWstart 0x08
.................... 
.................... #define Ioff 0x00
.................... #define Iu10 0x01
.................... #define Iu50 0x02
.................... #define Iu100 0x03
.................... #define Iu250 0x04
.................... #define Iu500 0x05
.................... #define Iu1000 0x06
.................... #define Iu1500 0x07  
.................... 
.................... //REGISTER 3 OPTIONS
.................... 
.................... #define I1disabled 0x00
.................... #define I1a0p1 0x20
.................... #define I1a1 0x40
.................... #define I1a2 0x60
.................... #define I1a3n1 0x80
.................... #define I1p0 0xA0
.................... #define I1n0 0xC0
.................... 
.................... #define I2disabled 0x00
.................... #define I2a0p1 0x04
.................... #define I2a1 0x08
.................... #define I2a2 0x0A
.................... #define I2a3n1 0x10
.................... #define I2p0 0x14
.................... #define I2n0 0x18
.................... 
.................... #define drdyPin 0x00
.................... #define doutPin 0x20
.................... 
.................... // REGISTER CONGIGURATIONS FOR THIS APP
.................... #define reg0config IPp1n2|g16|PGAenabled // 0x3A//
.................... #define reg1config DRn20|MDturbo|CMsingle|TSDisable|BCSoff //0x00
.................... #define reg2config REFinternal|FIR60|PSWopen|Ioff //0x30
.................... #define reg3config I1disabled|I2disabled|drdyPin //0x00
.................... 
.................... //COMMANDS
.................... #define ADSreset 0x06
.................... #define ADSstart 0x08
.................... #define ADSpowerDn 0x02
.................... #define ADSreadData 0x10
.................... #define ADSreadReg 0x20
.................... #define ADSwriteReg 0x40
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* DESELECT ALL ADCs                                                         */
.................... /*****************************************************************************/
.................... void ads_deselect_all()
.................... {
....................    output_high(_CS0); // deselect all chip select pins
*
00136:  MOVLW  1F
00138:  MOVWF  F8A
0013A:  BSF    F85.5
....................    output_high(_CS1);
0013C:  MOVWF  F8A
0013E:  BSF    F85.6
....................    output_high(_CS2);
00140:  MOVWF  F8A
00142:  BSF    F85.7
....................    output_high(_CS3);
00144:  MOVLW  F4
00146:  MOVWF  F88
00148:  BSF    F83.0
0014A:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT DESIRED ADC                                                        */
.................... /*****************************************************************************/
.................... void ads_select_ch(int8 ch)
.................... {
....................    ads_deselect_all();
*
005F4:  RCALL  0136
....................    switch(ch)
005F6:  MOVLB  5
005F8:  MOVF   xCF,W
005FA:  XORLW  00
005FC:  MOVLB  0
005FE:  BZ    060A
00600:  XORLW  01
00602:  BZ    0612
00604:  XORLW  03
00606:  BZ    061A
00608:  BRA    0622
....................    {
....................       case 0:
....................          output_low(_CS0);
0060A:  MOVLW  1F
0060C:  MOVWF  F8A
0060E:  BCF    F85.5
....................       break; 
00610:  BRA    0636
....................       case 1:
....................          output_low(_CS1);
00612:  MOVLW  1F
00614:  MOVWF  F8A
00616:  BCF    F85.6
....................       break;   
00618:  BRA    0636
....................       case 2:
....................          output_low(_CS2);
0061A:  MOVLW  1F
0061C:  MOVWF  F8A
0061E:  BCF    F85.7
....................       break;   
00620:  BRA    0636
....................       default: // select all
....................          output_low(_CS0);
00622:  MOVLW  1F
00624:  MOVWF  F8A
00626:  BCF    F85.5
....................          output_low(_CS1);
00628:  MOVWF  F8A
0062A:  BCF    F85.6
....................          output_low(_CS2);
0062C:  MOVWF  F8A
0062E:  BCF    F85.7
....................          output_low(_CS3);
00630:  MOVLW  F4
00632:  MOVWF  F88
00634:  BCF    F83.0
....................       break;             
....................    }
00636:  GOTO   0640 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT ADC BLOCK (2 ADCs/BLOCK)                                           */
.................... /*****************************************************************************/
.................... void ads_select_block(int8 block)
.................... {
....................    ads_deselect_all();
*
0014C:  RCALL  0136
....................    switch(block)
0014E:  MOVLB  6
00150:  MOVF   x29,W
00152:  XORLW  00
00154:  MOVLB  0
00156:  BZ    015E
00158:  XORLW  01
0015A:  BZ    016A
0015C:  BRA    0178
....................    {
....................       case 0:
....................          output_low(_CS0);
0015E:  MOVLW  1F
00160:  MOVWF  F8A
00162:  BCF    F85.5
....................          output_low(_CS1);
00164:  MOVWF  F8A
00166:  BCF    F85.6
....................       break; 
00168:  BRA    018C
....................       case 1:
....................          output_low(_CS2);
0016A:  MOVLW  1F
0016C:  MOVWF  F8A
0016E:  BCF    F85.7
....................          output_low(_CS3);
00170:  MOVLW  F4
00172:  MOVWF  F88
00174:  BCF    F83.0
....................       break;   
00176:  BRA    018C
....................       default: // select all
....................          output_low(_CS0);
00178:  MOVLW  1F
0017A:  MOVWF  F8A
0017C:  BCF    F85.5
....................          output_low(_CS1);
0017E:  MOVWF  F8A
00180:  BCF    F85.6
....................          output_low(_CS2);
00182:  MOVWF  F8A
00184:  BCF    F85.7
....................          output_low(_CS3);
00186:  MOVLW  F4
00188:  MOVWF  F88
0018A:  BCF    F83.0
....................       break;             
....................    }
0018C:  GOTO   01CE (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE                                                    */
.................... /*****************************************************************************/
.................... void ads_write_command(int8 ch, unsigned int8 command)
.................... {
....................    ads_select_ch(ch);
*
0063A:  MOVFF  5CD,5CF
0063E:  BRA    05F4
00640:  CLRF   19
00642:  BTFSC  FF2.7
00644:  BSF    19.7
00646:  BCF    FF2.7
....................    spi_xfer(SPI_mon, command);
00648:  MOVLB  6
0064A:  CLRF   x2C
0064C:  CLRF   x2B
0064E:  CLRF   x2A
00650:  MOVFF  5CE,629
00654:  MOVLB  0
00656:  RCALL  0190
00658:  BTFSC  19.7
0065A:  BSF    FF2.7
0065C:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO A BLOCK OF ADCs                                 */
.................... /*****************************************************************************/
.................... void ads_write_command_block(int8 block, unsigned int8 command)
.................... {
....................    ads_select_block(block);
*
001C8:  MOVFF  627,629
001CC:  BRA    014C
....................    spi_xfer(SPI_mon, command);
001CE:  MOVLB  6
001D0:  CLRF   x2C
001D2:  CLRF   x2B
001D4:  CLRF   x2A
001D6:  MOVFF  628,629
001DA:  MOVLB  0
001DC:  RCALL  0190
001DE:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE REGISTER DATA                                                       */
.................... /*****************************************************************************/
.................... void ads_write_reg(int8 ch, adsReg regID, int8 data)
*
00684:  MOVLB  5
00686:  MOVF   xCA,W
00688:  IORLW  40
0068A:  MOVWF  xCC
.................... {
....................    unsigned int8 command = ADSwriteReg | regID | 0; // 0 is numbytes to write-1
....................    ads_write_command(ch, command);
0068C:  MOVFF  5C9,5CD
00690:  MOVFF  5CC,5CE
00694:  MOVLB  0
00696:  RCALL  063A
00698:  CLRF   19
0069A:  BTFSC  FF2.7
0069C:  BSF    19.7
0069E:  BCF    FF2.7
....................    spi_xfer(SPI_mon, data);
006A0:  MOVLB  6
006A2:  CLRF   x2C
006A4:  CLRF   x2B
006A6:  CLRF   x2A
006A8:  MOVFF  5CB,629
006AC:  MOVLB  0
006AE:  RCALL  0190
006B0:  BTFSC  19.7
006B2:  BSF    FF2.7
....................    ads_deselect_all();
006B4:  RCALL  0136
006B6:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER REGISTER                                                    */
.................... /*****************************************************************************/
.................... unsigned int8 ads_read_reg(int8 ch, adsReg regID)
.................... {
....................    unsigned int8 command = ADSreadReg | regID | 0;
....................    ads_write_command(ch, command);
....................    unsigned int8 data = spi_xfer(SPI_mon, 0, 8);
....................    ads_deselect_all();
....................    return data;
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* READ DATA                                                                 */
.................... /*****************************************************************************/
.................... unsigned int32 ads_read_data(int8 ch)
.................... {
....................    ads_write_command(ch, ADSreadData);
*
012AE:  MOVFF  5C8,5CD
012B2:  MOVLW  10
012B4:  MOVLB  5
012B6:  MOVWF  xCE
012B8:  MOVLB  0
012BA:  CALL   063A
....................    unsigned int32 data = spi_xfer(SPI_mon, 0, 24);
012BE:  MOVLB  5
012C0:  CLRF   xD0
012C2:  CLRF   xCF
012C4:  CLRF   xCE
012C6:  CLRF   xCD
012C8:  MOVLB  0
012CA:  BRA    127E
012CC:  MOVF   01,W
012CE:  MOVFF  03,5CC
012D2:  MOVFF  02,5CB
012D6:  MOVFF  01,5CA
012DA:  MOVFF  00,5C9
....................    ads_deselect_all();
012DE:  CALL   0136
....................    return data;
012E2:  MOVFF  5C9,00
012E6:  MOVFF  5CA,01
012EA:  MOVFF  5CB,02
012EE:  MOVFF  5CC,03
012F2:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE A CHANNEL                                                      */
.................... /*****************************************************************************/
.................... 
.................... void ADS1220init(int8 ch, rc0=reg0config, rc1=reg1config, rc2=reg2config, rc3=reg3config)
.................... {
....................    ads_write_command(ch, ADSreset);   //reset the device
*
006B8:  MOVFF  5C4,5CD
006BC:  MOVLW  06
006BE:  MOVLB  5
006C0:  MOVWF  xCE
006C2:  MOVLB  0
006C4:  RCALL  063A
....................    delay_us(100);                    
006C6:  MOVLW  64
006C8:  MOVLB  5
006CA:  MOVWF  xC9
006CC:  MOVLB  0
006CE:  BRA    065E
....................    ads_write_reg(ch, reg0, rc0);   //send default configurations
006D0:  MOVFF  5C4,5C9
006D4:  MOVLB  5
006D6:  CLRF   xCA
006D8:  MOVFF  5C5,5CB
006DC:  MOVLB  0
006DE:  RCALL  0684
....................    ads_write_reg(ch, reg1, rc1);
006E0:  MOVFF  5C4,5C9
006E4:  MOVLW  04
006E6:  MOVLB  5
006E8:  MOVWF  xCA
006EA:  MOVFF  5C6,5CB
006EE:  MOVLB  0
006F0:  RCALL  0684
....................    ads_write_reg(ch, reg2, rc2);
006F2:  MOVFF  5C4,5C9
006F6:  MOVLW  08
006F8:  MOVLB  5
006FA:  MOVWF  xCA
006FC:  MOVFF  5C7,5CB
00700:  MOVLB  0
00702:  RCALL  0684
....................    ads_write_reg(ch, reg3, rc3);  
00704:  MOVFF  5C4,5C9
00708:  MOVLW  0C
0070A:  MOVLB  5
0070C:  MOVWF  xCA
0070E:  MOVFF  5C8,5CB
00712:  MOVLB  0
00714:  RCALL  0684
00716:  GOTO   0752 (RETURN)
.................... }
.................... #endif 
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
*
01D16:  MOVLB  6
01D18:  BCF    x12.0
....................    y = x;
01D1A:  MOVFF  606,60B
01D1E:  MOVFF  605,60A
01D22:  MOVFF  604,609
01D26:  MOVFF  603,608
.................... 
....................    if (x < 0)
01D2A:  MOVFF  606,616
01D2E:  MOVFF  605,615
01D32:  MOVFF  604,614
01D36:  MOVFF  603,613
01D3A:  CLRF   x1A
01D3C:  CLRF   x19
01D3E:  CLRF   x18
01D40:  CLRF   x17
01D42:  MOVLB  0
01D44:  CALL   132C
01D48:  BNC   1D56
....................    {
....................       s = 1;
01D4A:  MOVLB  6
01D4C:  BSF    x12.0
....................       y = -y;
01D4E:  MOVF   x09,W
01D50:  XORLW  80
01D52:  MOVWF  x09
01D54:  MOVLB  0
....................    }
.................... 
....................    if (y <= 32768.0)
01D56:  MOVFF  60B,616
01D5A:  MOVFF  60A,615
01D5E:  MOVFF  609,614
01D62:  MOVFF  608,613
01D66:  MOVLB  6
01D68:  CLRF   x1A
01D6A:  CLRF   x19
01D6C:  CLRF   x18
01D6E:  MOVLW  8E
01D70:  MOVWF  x17
01D72:  MOVLB  0
01D74:  CALL   132C
01D78:  BC    1D7C
01D7A:  BNZ   1DAC
....................       res = (float32)(unsigned int16)y;
01D7C:  MOVFF  60B,616
01D80:  MOVFF  60A,615
01D84:  MOVFF  609,614
01D88:  MOVFF  608,613
01D8C:  RCALL  1CDA
01D8E:  MOVFF  02,618
01D92:  MOVFF  01,617
01D96:  CALL   09C4
01D9A:  MOVFF  03,60F
01D9E:  MOVFF  02,60E
01DA2:  MOVFF  01,60D
01DA6:  MOVFF  00,60C
01DAA:  BRA    1F4E
.................... 
....................  else if (y < 10000000.0)
01DAC:  MOVFF  60B,616
01DB0:  MOVFF  60A,615
01DB4:  MOVFF  609,614
01DB8:  MOVFF  608,613
01DBC:  MOVLW  80
01DBE:  MOVLB  6
01DC0:  MOVWF  x1A
01DC2:  MOVLW  96
01DC4:  MOVWF  x19
01DC6:  MOVLW  18
01DC8:  MOVWF  x18
01DCA:  MOVLW  96
01DCC:  MOVWF  x17
01DCE:  MOVLB  0
01DD0:  CALL   132C
01DD4:  BTFSS  FD8.0
01DD6:  BRA    1F3E
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
01DD8:  MOVFF  60B,616
01DDC:  MOVFF  60A,615
01DE0:  MOVFF  609,614
01DE4:  MOVFF  608,613
01DE8:  MOVLB  6
01DEA:  CLRF   x1A
01DEC:  CLRF   x19
01DEE:  CLRF   x18
01DF0:  MOVLW  70
01DF2:  MOVWF  x17
01DF4:  MOVLB  0
01DF6:  CALL   09FA
01DFA:  MOVFF  03,616
01DFE:  MOVFF  02,615
01E02:  MOVFF  01,614
01E06:  MOVFF  00,613
01E0A:  RCALL  1CDA
01E0C:  MOVFF  02,611
01E10:  MOVFF  01,610
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
01E14:  MOVFF  60B,616
01E18:  MOVFF  60A,615
01E1C:  MOVFF  609,614
01E20:  MOVFF  608,613
01E24:  MOVLB  6
01E26:  CLRF   x1A
01E28:  CLRF   x19
01E2A:  CLRF   x18
01E2C:  MOVLW  70
01E2E:  MOVWF  x17
01E30:  MOVLB  0
01E32:  CALL   09FA
01E36:  MOVFF  03,616
01E3A:  MOVFF  02,615
01E3E:  MOVFF  01,614
01E42:  MOVFF  00,613
01E46:  MOVFF  611,618
01E4A:  MOVFF  610,617
01E4E:  CALL   09C4
01E52:  BSF    FD8.1
01E54:  MOVFF  616,61A
01E58:  MOVFF  615,619
01E5C:  MOVFF  614,618
01E60:  MOVFF  613,617
01E64:  MOVFF  03,61E
01E68:  MOVFF  02,61D
01E6C:  MOVFF  01,61C
01E70:  MOVFF  00,61B
01E74:  CALL   0AF0
01E78:  MOVLB  6
01E7A:  CLRF   x16
01E7C:  CLRF   x15
01E7E:  CLRF   x14
01E80:  MOVLW  8E
01E82:  MOVWF  x13
01E84:  MOVFF  03,61A
01E88:  MOVFF  02,619
01E8C:  MOVFF  01,618
01E90:  MOVFF  00,617
01E94:  MOVLB  0
01E96:  CALL   09FA
01E9A:  MOVFF  03,60B
01E9E:  MOVFF  02,60A
01EA2:  MOVFF  01,609
01EA6:  MOVFF  00,608
....................       res = 32768.0*(float32)l;
01EAA:  MOVFF  611,618
01EAE:  MOVFF  610,617
01EB2:  CALL   09C4
01EB6:  MOVLB  6
01EB8:  CLRF   x16
01EBA:  CLRF   x15
01EBC:  CLRF   x14
01EBE:  MOVLW  8E
01EC0:  MOVWF  x13
01EC2:  MOVFF  03,61A
01EC6:  MOVFF  02,619
01ECA:  MOVFF  01,618
01ECE:  MOVFF  00,617
01ED2:  MOVLB  0
01ED4:  CALL   09FA
01ED8:  MOVFF  03,60F
01EDC:  MOVFF  02,60E
01EE0:  MOVFF  01,60D
01EE4:  MOVFF  00,60C
....................       res += (float32)(unsigned int16)y;
01EE8:  MOVFF  60B,616
01EEC:  MOVFF  60A,615
01EF0:  MOVFF  609,614
01EF4:  MOVFF  608,613
01EF8:  RCALL  1CDA
01EFA:  MOVFF  02,618
01EFE:  MOVFF  01,617
01F02:  CALL   09C4
01F06:  BCF    FD8.1
01F08:  MOVFF  60F,61A
01F0C:  MOVFF  60E,619
01F10:  MOVFF  60D,618
01F14:  MOVFF  60C,617
01F18:  MOVFF  03,61E
01F1C:  MOVFF  02,61D
01F20:  MOVFF  01,61C
01F24:  MOVFF  00,61B
01F28:  CALL   0AF0
01F2C:  MOVFF  03,60F
01F30:  MOVFF  02,60E
01F34:  MOVFF  01,60D
01F38:  MOVFF  00,60C
....................    }
01F3C:  BRA    1F4E
.................... 
....................  else
....................   res = y;
01F3E:  MOVFF  60B,60F
01F42:  MOVFF  60A,60E
01F46:  MOVFF  609,60D
01F4A:  MOVFF  608,60C
.................... 
....................  y = y - (float32)(unsigned int16)y;
01F4E:  MOVFF  60B,616
01F52:  MOVFF  60A,615
01F56:  MOVFF  609,614
01F5A:  MOVFF  608,613
01F5E:  RCALL  1CDA
01F60:  MOVFF  02,618
01F64:  MOVFF  01,617
01F68:  CALL   09C4
01F6C:  BSF    FD8.1
01F6E:  MOVFF  60B,61A
01F72:  MOVFF  60A,619
01F76:  MOVFF  609,618
01F7A:  MOVFF  608,617
01F7E:  MOVFF  03,61E
01F82:  MOVFF  02,61D
01F86:  MOVFF  01,61C
01F8A:  MOVFF  00,61B
01F8E:  CALL   0AF0
01F92:  MOVFF  03,60B
01F96:  MOVFF  02,60A
01F9A:  MOVFF  01,609
01F9E:  MOVFF  00,608
.................... 
....................  if (s)
01FA2:  MOVLB  6
01FA4:  BTFSS  x12.0
01FA6:  BRA    1FAE
....................   res = -res;
01FA8:  MOVF   x0D,W
01FAA:  XORLW  80
01FAC:  MOVWF  x0D
.................... 
....................  if (y != 0)
01FAE:  MOVFF  60B,616
01FB2:  MOVFF  60A,615
01FB6:  MOVFF  609,614
01FBA:  MOVFF  608,613
01FBE:  CLRF   x1A
01FC0:  CLRF   x19
01FC2:  CLRF   x18
01FC4:  CLRF   x17
01FC6:  MOVLB  0
01FC8:  CALL   132C
01FCC:  BZ    2046
....................  {
....................   if (s == 1 && n == 0)
01FCE:  MOVLB  6
01FD0:  BTFSS  x12.0
01FD2:  BRA    200C
01FD4:  MOVF   x07,F
01FD6:  BNZ   200C
....................    res -= 1.0;
01FD8:  BSF    FD8.1
01FDA:  MOVFF  60F,61A
01FDE:  MOVFF  60E,619
01FE2:  MOVFF  60D,618
01FE6:  MOVFF  60C,617
01FEA:  CLRF   x1E
01FEC:  CLRF   x1D
01FEE:  CLRF   x1C
01FF0:  MOVLW  7F
01FF2:  MOVWF  x1B
01FF4:  MOVLB  0
01FF6:  CALL   0AF0
01FFA:  MOVFF  03,60F
01FFE:  MOVFF  02,60E
02002:  MOVFF  01,60D
02006:  MOVFF  00,60C
0200A:  MOVLB  6
.................... 
....................   if (s == 0 && n == 1)
0200C:  BTFSC  x12.0
0200E:  BRA    2048
02010:  DECFSZ x07,W
02012:  BRA    2048
....................    res += 1.0;
02014:  BCF    FD8.1
02016:  MOVFF  60F,61A
0201A:  MOVFF  60E,619
0201E:  MOVFF  60D,618
02022:  MOVFF  60C,617
02026:  CLRF   x1E
02028:  CLRF   x1D
0202A:  CLRF   x1C
0202C:  MOVLW  7F
0202E:  MOVWF  x1B
02030:  MOVLB  0
02032:  CALL   0AF0
02036:  MOVFF  03,60F
0203A:  MOVFF  02,60E
0203E:  MOVFF  01,60D
02042:  MOVFF  00,60C
02046:  MOVLB  6
....................  }
....................  if (x == 0)
02048:  MOVFF  606,616
0204C:  MOVFF  605,615
02050:  MOVFF  604,614
02054:  MOVFF  603,613
02058:  CLRF   x1A
0205A:  CLRF   x19
0205C:  CLRF   x18
0205E:  CLRF   x17
02060:  MOVLB  0
02062:  CALL   132C
02066:  BNZ   2074
....................     res = 0;
02068:  MOVLB  6
0206A:  CLRF   x0F
0206C:  CLRF   x0E
0206E:  CLRF   x0D
02070:  CLRF   x0C
02072:  MOVLB  0
.................... 
....................  return (res);
02074:  MOVFF  60C,00
02078:  MOVFF  60D,01
0207C:  MOVFF  60E,02
02080:  MOVFF  60F,03
02084:  RETURN 0
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
*
020A4:  MOVFF  602,606
020A8:  MOVFF  601,605
020AC:  MOVFF  600,604
020B0:  MOVFF  5FF,603
020B4:  MOVLB  6
020B6:  CLRF   x07
020B8:  MOVLB  0
020BA:  RCALL  1D16
020BC:  GOTO   21C8 (RETURN)
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
*
02086:  MOVFF  602,606
0208A:  MOVFF  601,605
0208E:  MOVFF  600,604
02092:  MOVFF  5FF,603
02096:  MOVLW  01
02098:  MOVLB  6
0209A:  MOVWF  x07
0209C:  MOVLB  0
0209E:  RCALL  1D16
020A0:  GOTO   2180 (RETURN)
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
*
020C0:  MOVFF  5F6,616
020C4:  MOVFF  5F5,615
020C8:  MOVFF  5F4,614
020CC:  MOVFF  5F3,613
020D0:  MOVLB  6
020D2:  CLRF   x1A
020D4:  CLRF   x19
020D6:  CLRF   x18
020D8:  CLRF   x17
020DA:  MOVLB  0
020DC:  CALL   132C
020E0:  BTFSC  FD8.2
020E2:  BRA    2224
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
020E4:  MOVFF  5F2,60F
020E8:  MOVFF  5F1,60E
020EC:  MOVFF  5F0,60D
020F0:  MOVFF  5EF,60C
020F4:  MOVFF  5F6,613
020F8:  MOVFF  5F5,612
020FC:  MOVFF  5F4,611
02100:  MOVFF  5F3,610
02104:  CALL   13A6
02108:  MOVFF  03,5FE
0210C:  MOVFF  02,5FD
02110:  MOVFF  01,5FC
02114:  MOVFF  00,5FB
02118:  MOVFF  03,616
0211C:  MOVFF  02,615
02120:  MOVFF  01,614
02124:  MOVFF  00,613
02128:  MOVLB  6
0212A:  CLRF   x1A
0212C:  CLRF   x19
0212E:  CLRF   x18
02130:  CLRF   x17
02132:  MOVLB  0
02134:  CALL   132C
02138:  BNC   2182
0213A:  MOVFF  5F2,60F
0213E:  MOVFF  5F1,60E
02142:  MOVFF  5F0,60D
02146:  MOVFF  5EF,60C
0214A:  MOVFF  5F6,613
0214E:  MOVFF  5F5,612
02152:  MOVFF  5F4,611
02156:  MOVFF  5F3,610
0215A:  CALL   13A6
0215E:  MOVFF  03,5FE
02162:  MOVFF  02,5FD
02166:  MOVFF  01,5FC
0216A:  MOVFF  00,5FB
0216E:  MOVFF  03,602
02172:  MOVFF  02,601
02176:  MOVFF  01,600
0217A:  MOVFF  00,5FF
0217E:  BRA    2086
02180:  BRA    21C8
02182:  MOVFF  5F2,60F
02186:  MOVFF  5F1,60E
0218A:  MOVFF  5F0,60D
0218E:  MOVFF  5EF,60C
02192:  MOVFF  5F6,613
02196:  MOVFF  5F5,612
0219A:  MOVFF  5F4,611
0219E:  MOVFF  5F3,610
021A2:  CALL   13A6
021A6:  MOVFF  03,5FE
021AA:  MOVFF  02,5FD
021AE:  MOVFF  01,5FC
021B2:  MOVFF  00,5FB
021B6:  MOVFF  03,602
021BA:  MOVFF  02,601
021BE:  MOVFF  01,600
021C2:  MOVFF  00,5FF
021C6:  BRA    20A4
021C8:  MOVFF  03,5FA
021CC:  MOVFF  02,5F9
021D0:  MOVFF  01,5F8
021D4:  MOVFF  00,5F7
....................       return(x-(i*y));
021D8:  MOVFF  5FA,616
021DC:  MOVFF  5F9,615
021E0:  MOVFF  5F8,614
021E4:  MOVFF  5F7,613
021E8:  MOVFF  5F6,61A
021EC:  MOVFF  5F5,619
021F0:  MOVFF  5F4,618
021F4:  MOVFF  5F3,617
021F8:  CALL   09FA
021FC:  BSF    FD8.1
021FE:  MOVFF  5F2,61A
02202:  MOVFF  5F1,619
02206:  MOVFF  5F0,618
0220A:  MOVFF  5EF,617
0220E:  MOVFF  03,61E
02212:  MOVFF  02,61D
02216:  MOVFF  01,61C
0221A:  MOVFF  00,61B
0221E:  CALL   0AF0
02222:  BRA    2224
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
02224:  RETURN 0
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
*
02606:  MOVFF  5F6,616
0260A:  MOVFF  5F5,615
0260E:  MOVFF  5F4,614
02612:  MOVFF  5F3,613
02616:  MOVLW  3B
02618:  MOVLB  6
0261A:  MOVWF  x1A
0261C:  MOVLW  AA
0261E:  MOVWF  x19
02620:  MOVLW  38
02622:  MOVWF  x18
02624:  MOVLW  7F
02626:  MOVWF  x17
02628:  MOVLB  0
0262A:  CALL   09FA
0262E:  MOVFF  03,616
02632:  MOVFF  02,615
02636:  MOVFF  01,614
0263A:  MOVFF  00,613
0263E:  CALL   1CDA
02642:  MOVFF  01,603
....................    s = 0;
02646:  MOVLB  6
02648:  BCF    x04.0
....................    y = x;
0264A:  MOVFF  5F6,5FA
0264E:  MOVFF  5F5,5F9
02652:  MOVFF  5F4,5F8
02656:  MOVFF  5F3,5F7
.................... 
....................    if (x < 0)
0265A:  MOVFF  5F6,616
0265E:  MOVFF  5F5,615
02662:  MOVFF  5F4,614
02666:  MOVFF  5F3,613
0266A:  CLRF   x1A
0266C:  CLRF   x19
0266E:  CLRF   x18
02670:  CLRF   x17
02672:  MOVLB  0
02674:  CALL   132C
02678:  BNC   268A
....................    {
....................       s = 1;
0267A:  MOVLB  6
0267C:  BSF    x04.0
....................       n = -n;
0267E:  NEGF   x03
....................       y = -y;
02680:  MOVLB  5
02682:  MOVF   xF8,W
02684:  XORLW  80
02686:  MOVWF  xF8
02688:  MOVLB  0
....................    }
.................... 
....................    res = 0.0;
0268A:  MOVLB  5
0268C:  CLRF   xFE
0268E:  CLRF   xFD
02690:  CLRF   xFC
02692:  CLRF   xFB
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
02694:  MOVLW  05
02696:  MOVLB  6
02698:  MOVWF  x06
0269A:  MOVLW  FB
0269C:  MOVFF  606,FEA
026A0:  MOVWF  FE9
026A2:  MOVLW  7F
026A4:  ADDWF  x03,W
026A6:  MOVWF  FEF
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
026A8:  MOVFF  5FA,616
026AC:  MOVFF  5F9,615
026B0:  MOVFF  5F8,614
026B4:  MOVFF  5F7,613
026B8:  MOVLW  3B
026BA:  MOVWF  x1A
026BC:  MOVLW  AA
026BE:  MOVWF  x19
026C0:  MOVLW  38
026C2:  MOVWF  x18
026C4:  MOVLW  7F
026C6:  MOVWF  x17
026C8:  MOVLB  0
026CA:  CALL   09FA
026CE:  MOVFF  03,608
026D2:  MOVFF  02,607
026D6:  MOVFF  01,606
026DA:  MOVFF  00,605
026DE:  MOVLB  6
026E0:  CLRF   x0A
026E2:  MOVFF  603,609
026E6:  BTFSC  x09.7
026E8:  DECF   x0A,F
026EA:  MOVLB  0
026EC:  RCALL  2226
026EE:  BSF    FD8.1
026F0:  MOVFF  608,61A
026F4:  MOVFF  607,619
026F8:  MOVFF  606,618
026FC:  MOVFF  605,617
02700:  MOVFF  03,61E
02704:  MOVFF  02,61D
02708:  MOVFF  01,61C
0270C:  MOVFF  00,61B
02710:  CALL   0AF0
02714:  MOVFF  03,5FA
02718:  MOVFF  02,5F9
0271C:  MOVFF  01,5F8
02720:  MOVFF  00,5F7
.................... 
....................    r = pe[0]*y + pe[1];
02724:  MOVLW  7C
02726:  MOVLB  6
02728:  MOVWF  x16
0272A:  MOVLW  88
0272C:  MOVWF  x15
0272E:  MOVLW  59
02730:  MOVWF  x14
02732:  MOVLW  72
02734:  MOVWF  x13
02736:  MOVFF  5FA,61A
0273A:  MOVFF  5F9,619
0273E:  MOVFF  5F8,618
02742:  MOVFF  5F7,617
02746:  MOVLB  0
02748:  CALL   09FA
0274C:  MOVFF  03,608
02750:  MOVFF  02,607
02754:  MOVFF  01,606
02758:  MOVFF  00,605
0275C:  BCF    FD8.1
0275E:  MOVFF  03,61A
02762:  MOVFF  02,619
02766:  MOVFF  01,618
0276A:  MOVFF  00,617
0276E:  MOVLW  E0
02770:  MOVLB  6
02772:  MOVWF  x1E
02774:  MOVLW  97
02776:  MOVWF  x1D
02778:  MOVLW  26
0277A:  MOVWF  x1C
0277C:  MOVLW  75
0277E:  MOVWF  x1B
02780:  MOVLB  0
02782:  CALL   0AF0
02786:  MOVFF  03,602
0278A:  MOVFF  02,601
0278E:  MOVFF  01,600
02792:  MOVFF  00,5FF
....................    r = r*y + pe[2];
02796:  MOVFF  602,616
0279A:  MOVFF  601,615
0279E:  MOVFF  600,614
027A2:  MOVFF  5FF,613
027A6:  MOVFF  5FA,61A
027AA:  MOVFF  5F9,619
027AE:  MOVFF  5F8,618
027B2:  MOVFF  5F7,617
027B6:  CALL   09FA
027BA:  MOVFF  03,608
027BE:  MOVFF  02,607
027C2:  MOVFF  01,606
027C6:  MOVFF  00,605
027CA:  BCF    FD8.1
027CC:  MOVFF  03,61A
027D0:  MOVFF  02,619
027D4:  MOVFF  01,618
027D8:  MOVFF  00,617
027DC:  MOVLW  C4
027DE:  MOVLB  6
027E0:  MOVWF  x1E
027E2:  MOVLW  1D
027E4:  MOVWF  x1D
027E6:  MOVLW  1E
027E8:  MOVWF  x1C
027EA:  MOVLW  78
027EC:  MOVWF  x1B
027EE:  MOVLB  0
027F0:  CALL   0AF0
027F4:  MOVFF  03,602
027F8:  MOVFF  02,601
027FC:  MOVFF  01,600
02800:  MOVFF  00,5FF
....................    r = r*y + pe[3];
02804:  MOVFF  602,616
02808:  MOVFF  601,615
0280C:  MOVFF  600,614
02810:  MOVFF  5FF,613
02814:  MOVFF  5FA,61A
02818:  MOVFF  5F9,619
0281C:  MOVFF  5F8,618
02820:  MOVFF  5F7,617
02824:  CALL   09FA
02828:  MOVFF  03,608
0282C:  MOVFF  02,607
02830:  MOVFF  01,606
02834:  MOVFF  00,605
02838:  BCF    FD8.1
0283A:  MOVFF  03,61A
0283E:  MOVFF  02,619
02842:  MOVFF  01,618
02846:  MOVFF  00,617
0284A:  MOVLW  5E
0284C:  MOVLB  6
0284E:  MOVWF  x1E
02850:  MOVLW  50
02852:  MOVWF  x1D
02854:  MOVLW  63
02856:  MOVWF  x1C
02858:  MOVLW  7A
0285A:  MOVWF  x1B
0285C:  MOVLB  0
0285E:  CALL   0AF0
02862:  MOVFF  03,602
02866:  MOVFF  02,601
0286A:  MOVFF  01,600
0286E:  MOVFF  00,5FF
....................    r = r*y + pe[4];
02872:  MOVFF  602,616
02876:  MOVFF  601,615
0287A:  MOVFF  600,614
0287E:  MOVFF  5FF,613
02882:  MOVFF  5FA,61A
02886:  MOVFF  5F9,619
0288A:  MOVFF  5F8,618
0288E:  MOVFF  5F7,617
02892:  CALL   09FA
02896:  MOVFF  03,608
0289A:  MOVFF  02,607
0289E:  MOVFF  01,606
028A2:  MOVFF  00,605
028A6:  BCF    FD8.1
028A8:  MOVFF  03,61A
028AC:  MOVFF  02,619
028B0:  MOVFF  01,618
028B4:  MOVFF  00,617
028B8:  MOVLW  1A
028BA:  MOVLB  6
028BC:  MOVWF  x1E
028BE:  MOVLW  FE
028C0:  MOVWF  x1D
028C2:  MOVLW  75
028C4:  MOVWF  x1C
028C6:  MOVLW  7C
028C8:  MOVWF  x1B
028CA:  MOVLB  0
028CC:  CALL   0AF0
028D0:  MOVFF  03,602
028D4:  MOVFF  02,601
028D8:  MOVFF  01,600
028DC:  MOVFF  00,5FF
....................    r = r*y + pe[5];
028E0:  MOVFF  602,616
028E4:  MOVFF  601,615
028E8:  MOVFF  600,614
028EC:  MOVFF  5FF,613
028F0:  MOVFF  5FA,61A
028F4:  MOVFF  5F9,619
028F8:  MOVFF  5F8,618
028FC:  MOVFF  5F7,617
02900:  CALL   09FA
02904:  MOVFF  03,608
02908:  MOVFF  02,607
0290C:  MOVFF  01,606
02910:  MOVFF  00,605
02914:  BCF    FD8.1
02916:  MOVFF  03,61A
0291A:  MOVFF  02,619
0291E:  MOVFF  01,618
02922:  MOVFF  00,617
02926:  MOVLW  18
02928:  MOVLB  6
0292A:  MOVWF  x1E
0292C:  MOVLW  72
0292E:  MOVWF  x1D
02930:  MOVLW  31
02932:  MOVWF  x1C
02934:  MOVLW  7E
02936:  MOVWF  x1B
02938:  MOVLB  0
0293A:  CALL   0AF0
0293E:  MOVFF  03,602
02942:  MOVFF  02,601
02946:  MOVFF  01,600
0294A:  MOVFF  00,5FF
.................... 
....................    res = res*(1.0 + y*r);
0294E:  MOVFF  5FA,616
02952:  MOVFF  5F9,615
02956:  MOVFF  5F8,614
0295A:  MOVFF  5F7,613
0295E:  MOVFF  602,61A
02962:  MOVFF  601,619
02966:  MOVFF  600,618
0296A:  MOVFF  5FF,617
0296E:  CALL   09FA
02972:  BCF    FD8.1
02974:  MOVLB  6
02976:  CLRF   x1A
02978:  CLRF   x19
0297A:  CLRF   x18
0297C:  MOVLW  7F
0297E:  MOVWF  x17
02980:  MOVFF  03,61E
02984:  MOVFF  02,61D
02988:  MOVFF  01,61C
0298C:  MOVFF  00,61B
02990:  MOVLB  0
02992:  CALL   0AF0
02996:  MOVFF  5FE,616
0299A:  MOVFF  5FD,615
0299E:  MOVFF  5FC,614
029A2:  MOVFF  5FB,613
029A6:  MOVFF  03,61A
029AA:  MOVFF  02,619
029AE:  MOVFF  01,618
029B2:  MOVFF  00,617
029B6:  CALL   09FA
029BA:  MOVFF  03,5FE
029BE:  MOVFF  02,5FD
029C2:  MOVFF  01,5FC
029C6:  MOVFF  00,5FB
.................... 
....................    if (s)
029CA:  MOVLB  6
029CC:  BTFSS  x04.0
029CE:  BRA    2A02
....................       res = 1.0/res;
029D0:  CLRF   x0F
029D2:  CLRF   x0E
029D4:  CLRF   x0D
029D6:  MOVLW  7F
029D8:  MOVWF  x0C
029DA:  MOVFF  5FE,613
029DE:  MOVFF  5FD,612
029E2:  MOVFF  5FC,611
029E6:  MOVFF  5FB,610
029EA:  MOVLB  0
029EC:  CALL   13A6
029F0:  MOVFF  03,5FE
029F4:  MOVFF  02,5FD
029F8:  MOVFF  01,5FC
029FC:  MOVFF  00,5FB
02A00:  MOVLB  6
....................    return(res);
02A02:  MOVFF  5FB,00
02A06:  MOVFF  5FC,01
02A0A:  MOVFF  5FD,02
02A0E:  MOVFF  5FE,03
02A12:  MOVLB  0
02A14:  RETURN 0
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
*
02276:  MOVFF  5F6,5FA
0227A:  MOVFF  5F5,5F9
0227E:  MOVFF  5F4,5F8
02282:  MOVFF  5F3,5F7
.................... 
....................    if (y != 1.0)
02286:  MOVFF  5FA,616
0228A:  MOVFF  5F9,615
0228E:  MOVFF  5F8,614
02292:  MOVFF  5F7,613
02296:  MOVLB  6
02298:  CLRF   x1A
0229A:  CLRF   x19
0229C:  CLRF   x18
0229E:  MOVLW  7F
022A0:  MOVWF  x17
022A2:  MOVLB  0
022A4:  CALL   132C
022A8:  BTFSC  FD8.2
022AA:  BRA    25E8
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
022AC:  MOVLW  05
022AE:  MOVLB  6
022B0:  MOVWF  x09
022B2:  MOVLW  F7
022B4:  MOVFF  609,FEA
022B8:  MOVWF  FE9
022BA:  MOVLW  7E
022BC:  MOVWF  FEF
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
022BE:  BSF    FD8.1
022C0:  MOVFF  5FA,61A
022C4:  MOVFF  5F9,619
022C8:  MOVFF  5F8,618
022CC:  MOVFF  5F7,617
022D0:  CLRF   x1E
022D2:  CLRF   x1D
022D4:  CLRF   x1C
022D6:  MOVLW  7F
022D8:  MOVWF  x1B
022DA:  MOVLB  0
022DC:  CALL   0AF0
022E0:  MOVFF  03,60B
022E4:  MOVFF  02,60A
022E8:  MOVFF  01,609
022EC:  MOVFF  00,608
022F0:  BCF    FD8.1
022F2:  MOVFF  5FA,61A
022F6:  MOVFF  5F9,619
022FA:  MOVFF  5F8,618
022FE:  MOVFF  5F7,617
02302:  MOVLB  6
02304:  CLRF   x1E
02306:  CLRF   x1D
02308:  CLRF   x1C
0230A:  MOVLW  7F
0230C:  MOVWF  x1B
0230E:  MOVLB  0
02310:  CALL   0AF0
02314:  MOVFF  60B,60F
02318:  MOVFF  60A,60E
0231C:  MOVFF  609,60D
02320:  MOVFF  608,60C
02324:  MOVFF  03,613
02328:  MOVFF  02,612
0232C:  MOVFF  01,611
02330:  MOVFF  00,610
02334:  CALL   13A6
02338:  MOVFF  03,5FA
0233C:  MOVFF  02,5F9
02340:  MOVFF  01,5F8
02344:  MOVFF  00,5F7
.................... 
....................       y2=y*y;
02348:  MOVFF  5FA,616
0234C:  MOVFF  5F9,615
02350:  MOVFF  5F8,614
02354:  MOVFF  5F7,613
02358:  MOVFF  5FA,61A
0235C:  MOVFF  5F9,619
02360:  MOVFF  5F8,618
02364:  MOVFF  5F7,617
02368:  CALL   09FA
0236C:  MOVFF  03,606
02370:  MOVFF  02,605
02374:  MOVFF  01,604
02378:  MOVFF  00,603
.................... 
....................       res = pl[0]*y2 + pl[1];
0237C:  MOVLW  99
0237E:  MOVLB  6
02380:  MOVWF  x16
02382:  MOVLW  47
02384:  MOVWF  x15
02386:  MOVLW  8A
02388:  MOVWF  x14
0238A:  MOVLW  7F
0238C:  MOVWF  x13
0238E:  MOVFF  606,61A
02392:  MOVFF  605,619
02396:  MOVFF  604,618
0239A:  MOVFF  603,617
0239E:  MOVLB  0
023A0:  CALL   09FA
023A4:  MOVFF  03,60B
023A8:  MOVFF  02,60A
023AC:  MOVFF  01,609
023B0:  MOVFF  00,608
023B4:  BCF    FD8.1
023B6:  MOVFF  03,61A
023BA:  MOVFF  02,619
023BE:  MOVFF  01,618
023C2:  MOVFF  00,617
023C6:  MOVLB  6
023C8:  CLRF   x1E
023CA:  CLRF   x1D
023CC:  CLRF   x1C
023CE:  MOVLW  80
023D0:  MOVWF  x1B
023D2:  MOVLB  0
023D4:  CALL   0AF0
023D8:  MOVFF  03,5FE
023DC:  MOVFF  02,5FD
023E0:  MOVFF  01,5FC
023E4:  MOVFF  00,5FB
.................... 
....................       r = ql[0]*y2 + ql[1];
023E8:  MOVLW  4C
023EA:  MOVLB  6
023EC:  MOVWF  x16
023EE:  MOVLW  F3
023F0:  MOVWF  x15
023F2:  MOVLW  3A
023F4:  MOVWF  x14
023F6:  MOVLW  7B
023F8:  MOVWF  x13
023FA:  MOVFF  606,61A
023FE:  MOVFF  605,619
02402:  MOVFF  604,618
02406:  MOVFF  603,617
0240A:  MOVLB  0
0240C:  CALL   09FA
02410:  MOVFF  03,60B
02414:  MOVFF  02,60A
02418:  MOVFF  01,609
0241C:  MOVFF  00,608
02420:  BCF    FD8.1
02422:  MOVFF  03,61A
02426:  MOVFF  02,619
0242A:  MOVFF  01,618
0242E:  MOVFF  00,617
02432:  MOVLW  2B
02434:  MOVLB  6
02436:  MOVWF  x1E
02438:  MOVLW  9D
0243A:  MOVWF  x1D
0243C:  MOVLW  DF
0243E:  MOVWF  x1C
02440:  MOVLW  7E
02442:  MOVWF  x1B
02444:  MOVLB  0
02446:  CALL   0AF0
0244A:  MOVFF  03,602
0244E:  MOVFF  02,601
02452:  MOVFF  01,600
02456:  MOVFF  00,5FF
....................       r = r*y2 + 1.0;
0245A:  MOVFF  602,616
0245E:  MOVFF  601,615
02462:  MOVFF  600,614
02466:  MOVFF  5FF,613
0246A:  MOVFF  606,61A
0246E:  MOVFF  605,619
02472:  MOVFF  604,618
02476:  MOVFF  603,617
0247A:  CALL   09FA
0247E:  MOVFF  03,60B
02482:  MOVFF  02,60A
02486:  MOVFF  01,609
0248A:  MOVFF  00,608
0248E:  BCF    FD8.1
02490:  MOVFF  03,61A
02494:  MOVFF  02,619
02498:  MOVFF  01,618
0249C:  MOVFF  00,617
024A0:  MOVLB  6
024A2:  CLRF   x1E
024A4:  CLRF   x1D
024A6:  CLRF   x1C
024A8:  MOVLW  7F
024AA:  MOVWF  x1B
024AC:  MOVLB  0
024AE:  CALL   0AF0
024B2:  MOVFF  03,602
024B6:  MOVFF  02,601
024BA:  MOVFF  01,600
024BE:  MOVFF  00,5FF
.................... 
....................       res = y*res/r;
024C2:  MOVFF  5FA,616
024C6:  MOVFF  5F9,615
024CA:  MOVFF  5F8,614
024CE:  MOVFF  5F7,613
024D2:  MOVFF  5FE,61A
024D6:  MOVFF  5FD,619
024DA:  MOVFF  5FC,618
024DE:  MOVFF  5FB,617
024E2:  CALL   09FA
024E6:  MOVFF  03,60B
024EA:  MOVFF  02,60A
024EE:  MOVFF  01,609
024F2:  MOVFF  00,608
024F6:  MOVFF  03,60F
024FA:  MOVFF  02,60E
024FE:  MOVFF  01,60D
02502:  MOVFF  00,60C
02506:  MOVFF  602,613
0250A:  MOVFF  601,612
0250E:  MOVFF  600,611
02512:  MOVFF  5FF,610
02516:  CALL   13A6
0251A:  MOVFF  03,5FE
0251E:  MOVFF  02,5FD
02522:  MOVFF  01,5FC
02526:  MOVFF  00,5FB
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
0252A:  MOVLW  05
0252C:  MOVLB  6
0252E:  MOVWF  x09
02530:  MOVLW  F3
02532:  MOVFF  609,FEA
02536:  MOVWF  FE9
02538:  MOVLW  7E
0253A:  SUBWF  FEF,W
0253C:  MOVWF  x07
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
0253E:  BTFSS  x07.7
02540:  BRA    256A
....................          r = -(float32)-n;
02542:  MOVLW  00
02544:  BSF    FD8.0
02546:  SUBFWB x07,W
02548:  CLRF   x0A
0254A:  MOVWF  x09
0254C:  BTFSC  x09.7
0254E:  DECF   x0A,F
02550:  MOVLB  0
02552:  RCALL  2226
02554:  MOVFF  00,5FF
02558:  MOVF   01,W
0255A:  XORLW  80
0255C:  MOVLB  6
0255E:  MOVWF  x00
02560:  MOVFF  02,601
02564:  MOVFF  03,602
02568:  BRA    258A
....................       else
....................          r = (float32)n;
0256A:  CLRF   x0A
0256C:  MOVFF  607,609
02570:  BTFSC  x09.7
02572:  DECF   x0A,F
02574:  MOVLB  0
02576:  RCALL  2226
02578:  MOVFF  03,602
0257C:  MOVFF  02,601
02580:  MOVFF  01,600
02584:  MOVFF  00,5FF
02588:  MOVLB  6
.................... 
....................       res += r*LN2;
0258A:  MOVFF  602,616
0258E:  MOVFF  601,615
02592:  MOVFF  600,614
02596:  MOVFF  5FF,613
0259A:  MOVLW  18
0259C:  MOVWF  x1A
0259E:  MOVLW  72
025A0:  MOVWF  x19
025A2:  MOVLW  31
025A4:  MOVWF  x18
025A6:  MOVLW  7E
025A8:  MOVWF  x17
025AA:  MOVLB  0
025AC:  CALL   09FA
025B0:  BCF    FD8.1
025B2:  MOVFF  5FE,61A
025B6:  MOVFF  5FD,619
025BA:  MOVFF  5FC,618
025BE:  MOVFF  5FB,617
025C2:  MOVFF  03,61E
025C6:  MOVFF  02,61D
025CA:  MOVFF  01,61C
025CE:  MOVFF  00,61B
025D2:  CALL   0AF0
025D6:  MOVFF  03,5FE
025DA:  MOVFF  02,5FD
025DE:  MOVFF  01,5FC
025E2:  MOVFF  00,5FB
....................    }
025E6:  BRA    25F4
.................... 
....................    else
....................       res = 0.0;
025E8:  MOVLB  5
025EA:  CLRF   xFE
025EC:  CLRF   xFD
025EE:  CLRF   xFC
025F0:  CLRF   xFB
025F2:  MOVLB  0
.................... 
....................    return(res);
025F4:  MOVFF  5FB,00
025F8:  MOVFF  5FC,01
025FC:  MOVFF  5FD,02
02600:  MOVFF  5FE,03
02604:  RETURN 0
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
*
02A16:  MOVFF  5EA,616
02A1A:  MOVFF  5E9,615
02A1E:  MOVFF  5E8,614
02A22:  MOVFF  5E7,613
02A26:  MOVLB  6
02A28:  CLRF   x1A
02A2A:  CLRF   x19
02A2C:  CLRF   x18
02A2E:  CLRF   x17
02A30:  MOVLB  0
02A32:  CALL   132C
02A36:  BTFSS  FD8.0
02A38:  BRA    2BD4
02A3A:  MOVFF  5EE,5F2
02A3E:  MOVFF  5ED,5F1
02A42:  MOVFF  5EC,5F0
02A46:  MOVFF  5EB,5EF
02A4A:  MOVLB  5
02A4C:  CLRF   xF6
02A4E:  CLRF   xF5
02A50:  CLRF   xF4
02A52:  MOVLW  7F
02A54:  MOVWF  xF3
02A56:  MOVLB  0
02A58:  CALL   20C0
02A5C:  MOVFF  03,5F2
02A60:  MOVFF  02,5F1
02A64:  MOVFF  01,5F0
02A68:  MOVFF  00,5EF
02A6C:  MOVFF  03,616
02A70:  MOVFF  02,615
02A74:  MOVFF  01,614
02A78:  MOVFF  00,613
02A7C:  MOVLB  6
02A7E:  CLRF   x1A
02A80:  CLRF   x19
02A82:  CLRF   x18
02A84:  CLRF   x17
02A86:  MOVLB  0
02A88:  CALL   132C
02A8C:  BTFSS  FD8.2
02A8E:  BRA    2BD4
....................       if(fmod(y, 2) == 0) {
02A90:  MOVFF  5EE,5F2
02A94:  MOVFF  5ED,5F1
02A98:  MOVFF  5EC,5F0
02A9C:  MOVFF  5EB,5EF
02AA0:  MOVLB  5
02AA2:  CLRF   xF6
02AA4:  CLRF   xF5
02AA6:  CLRF   xF4
02AA8:  MOVLW  80
02AAA:  MOVWF  xF3
02AAC:  MOVLB  0
02AAE:  CALL   20C0
02AB2:  MOVFF  03,5F2
02AB6:  MOVFF  02,5F1
02ABA:  MOVFF  01,5F0
02ABE:  MOVFF  00,5EF
02AC2:  MOVFF  03,616
02AC6:  MOVFF  02,615
02ACA:  MOVFF  01,614
02ACE:  MOVFF  00,613
02AD2:  MOVLB  6
02AD4:  CLRF   x1A
02AD6:  CLRF   x19
02AD8:  CLRF   x18
02ADA:  CLRF   x17
02ADC:  MOVLB  0
02ADE:  CALL   132C
02AE2:  BNZ   2B5A
....................          return (exp(log(-x) * y));
02AE4:  MOVLB  5
02AE6:  MOVF   xE8,W
02AE8:  XORLW  80
02AEA:  MOVWF  xF0
02AEC:  MOVFF  5EA,5F6
02AF0:  MOVFF  5E9,5F5
02AF4:  MOVWF  xF4
02AF6:  MOVFF  5E7,5F3
02AFA:  MOVLB  0
02AFC:  CALL   2276
02B00:  MOVFF  03,5F2
02B04:  MOVFF  02,5F1
02B08:  MOVFF  01,5F0
02B0C:  MOVFF  00,5EF
02B10:  MOVFF  03,616
02B14:  MOVFF  02,615
02B18:  MOVFF  01,614
02B1C:  MOVFF  00,613
02B20:  MOVFF  5EE,61A
02B24:  MOVFF  5ED,619
02B28:  MOVFF  5EC,618
02B2C:  MOVFF  5EB,617
02B30:  CALL   09FA
02B34:  MOVFF  03,5F2
02B38:  MOVFF  02,5F1
02B3C:  MOVFF  01,5F0
02B40:  MOVFF  00,5EF
02B44:  MOVFF  03,5F6
02B48:  MOVFF  02,5F5
02B4C:  MOVFF  01,5F4
02B50:  MOVFF  00,5F3
02B54:  RCALL  2606
02B56:  BRA    2D12
....................       } else {
02B58:  BRA    2BD2
....................          return (-exp(log(-x) * y));
02B5A:  MOVLB  5
02B5C:  MOVF   xE8,W
02B5E:  XORLW  80
02B60:  MOVWF  xF0
02B62:  MOVFF  5EA,5F6
02B66:  MOVFF  5E9,5F5
02B6A:  MOVWF  xF4
02B6C:  MOVFF  5E7,5F3
02B70:  MOVLB  0
02B72:  CALL   2276
02B76:  MOVFF  03,5F2
02B7A:  MOVFF  02,5F1
02B7E:  MOVFF  01,5F0
02B82:  MOVFF  00,5EF
02B86:  MOVFF  03,616
02B8A:  MOVFF  02,615
02B8E:  MOVFF  01,614
02B92:  MOVFF  00,613
02B96:  MOVFF  5EE,61A
02B9A:  MOVFF  5ED,619
02B9E:  MOVFF  5EC,618
02BA2:  MOVFF  5EB,617
02BA6:  CALL   09FA
02BAA:  MOVFF  03,5F2
02BAE:  MOVFF  02,5F1
02BB2:  MOVFF  01,5F0
02BB6:  MOVFF  00,5EF
02BBA:  MOVFF  03,5F6
02BBE:  MOVFF  02,5F5
02BC2:  MOVFF  01,5F4
02BC6:  MOVFF  00,5F3
02BCA:  RCALL  2606
02BCC:  MOVLW  80
02BCE:  XORWF  01,F
02BD0:  BRA    2D12
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
02BD2:  BRA    2D12
02BD4:  MOVFF  5EA,616
02BD8:  MOVFF  5E9,615
02BDC:  MOVFF  5E8,614
02BE0:  MOVFF  5E7,613
02BE4:  MOVLB  6
02BE6:  CLRF   x1A
02BE8:  CLRF   x19
02BEA:  CLRF   x18
02BEC:  CLRF   x17
02BEE:  MOVLB  0
02BF0:  CALL   132C
02BF4:  BNC   2C56
02BF6:  MOVFF  5EE,5F2
02BFA:  MOVFF  5ED,5F1
02BFE:  MOVFF  5EC,5F0
02C02:  MOVFF  5EB,5EF
02C06:  MOVLB  5
02C08:  CLRF   xF6
02C0A:  CLRF   xF5
02C0C:  CLRF   xF4
02C0E:  MOVLW  7F
02C10:  MOVWF  xF3
02C12:  MOVLB  0
02C14:  CALL   20C0
02C18:  MOVFF  03,5F2
02C1C:  MOVFF  02,5F1
02C20:  MOVFF  01,5F0
02C24:  MOVFF  00,5EF
02C28:  MOVFF  03,616
02C2C:  MOVFF  02,615
02C30:  MOVFF  01,614
02C34:  MOVFF  00,613
02C38:  MOVLB  6
02C3A:  CLRF   x1A
02C3C:  CLRF   x19
02C3E:  CLRF   x18
02C40:  CLRF   x17
02C42:  MOVLB  0
02C44:  CALL   132C
02C48:  BZ    2C56
....................       return 0;
02C4A:  CLRF   00
02C4C:  CLRF   01
02C4E:  CLRF   02
02C50:  CLRF   03
02C52:  BRA    2D12
....................    } else {
02C54:  BRA    2D12
....................       if(x != 0 || 0 >= y) {
02C56:  MOVFF  5EA,616
02C5A:  MOVFF  5E9,615
02C5E:  MOVFF  5E8,614
02C62:  MOVFF  5E7,613
02C66:  MOVLB  6
02C68:  CLRF   x1A
02C6A:  CLRF   x19
02C6C:  CLRF   x18
02C6E:  CLRF   x17
02C70:  MOVLB  0
02C72:  CALL   132C
02C76:  BNZ   2C9C
02C78:  MOVFF  5EE,616
02C7C:  MOVFF  5ED,615
02C80:  MOVFF  5EC,614
02C84:  MOVFF  5EB,613
02C88:  MOVLB  6
02C8A:  CLRF   x1A
02C8C:  CLRF   x19
02C8E:  CLRF   x18
02C90:  CLRF   x17
02C92:  MOVLB  0
02C94:  CALL   132C
02C98:  BC    2C9C
02C9A:  BNZ   2D0A
....................          return (exp(log(x) * y));
02C9C:  MOVFF  5EA,5F6
02CA0:  MOVFF  5E9,5F5
02CA4:  MOVFF  5E8,5F4
02CA8:  MOVFF  5E7,5F3
02CAC:  CALL   2276
02CB0:  MOVFF  03,5F2
02CB4:  MOVFF  02,5F1
02CB8:  MOVFF  01,5F0
02CBC:  MOVFF  00,5EF
02CC0:  MOVFF  03,616
02CC4:  MOVFF  02,615
02CC8:  MOVFF  01,614
02CCC:  MOVFF  00,613
02CD0:  MOVFF  5EE,61A
02CD4:  MOVFF  5ED,619
02CD8:  MOVFF  5EC,618
02CDC:  MOVFF  5EB,617
02CE0:  CALL   09FA
02CE4:  MOVFF  03,5F2
02CE8:  MOVFF  02,5F1
02CEC:  MOVFF  01,5F0
02CF0:  MOVFF  00,5EF
02CF4:  MOVFF  03,5F6
02CF8:  MOVFF  02,5F5
02CFC:  MOVFF  01,5F4
02D00:  MOVFF  00,5F3
02D04:  RCALL  2606
02D06:  BRA    2D12
....................       } else return 0;
02D08:  BRA    2D12
02D0A:  CLRF   00
02D0C:  CLRF   01
02D0E:  CLRF   02
02D10:  CLRF   03
....................    }
02D12:  RETURN 0
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
*
01504:  MOVLB  6
01506:  BCF    x05.0
....................    flag = 0;
01508:  BCF    x05.1
....................    y = x;
0150A:  MOVFF  5F8,5FC
0150E:  MOVFF  5F7,5FB
01512:  MOVFF  5F6,5FA
01516:  MOVFF  5F5,5F9
.................... 
....................    if (x < 0)
0151A:  MOVFF  5F8,616
0151E:  MOVFF  5F7,615
01522:  MOVFF  5F6,614
01526:  MOVFF  5F5,613
0152A:  CLRF   x1A
0152C:  CLRF   x19
0152E:  CLRF   x18
01530:  CLRF   x17
01532:  MOVLB  0
01534:  RCALL  132C
01536:  BNC   1546
....................    {
....................       s = 1;
01538:  MOVLB  6
0153A:  BSF    x05.0
....................       y = -y;
0153C:  MOVLB  5
0153E:  MOVF   xFA,W
01540:  XORLW  80
01542:  MOVWF  xFA
01544:  MOVLB  0
....................    }
.................... 
....................    if (y > 1.0)
01546:  MOVLB  6
01548:  CLRF   x16
0154A:  CLRF   x15
0154C:  CLRF   x14
0154E:  MOVLW  7F
01550:  MOVWF  x13
01552:  MOVFF  5FC,61A
01556:  MOVFF  5FB,619
0155A:  MOVFF  5FA,618
0155E:  MOVFF  5F9,617
01562:  MOVLB  0
01564:  RCALL  132C
01566:  BNC   159E
....................    {
....................       y = 1.0/y;
01568:  MOVLB  6
0156A:  CLRF   x0F
0156C:  CLRF   x0E
0156E:  CLRF   x0D
01570:  MOVLW  7F
01572:  MOVWF  x0C
01574:  MOVFF  5FC,613
01578:  MOVFF  5FB,612
0157C:  MOVFF  5FA,611
01580:  MOVFF  5F9,610
01584:  MOVLB  0
01586:  RCALL  13A6
01588:  MOVFF  03,5FC
0158C:  MOVFF  02,5FB
01590:  MOVFF  01,5FA
01594:  MOVFF  00,5F9
....................       flag = 1;
01598:  MOVLB  6
0159A:  BSF    x05.1
0159C:  MOVLB  0
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
0159E:  MOVLW  0A
015A0:  MOVLB  6
015A2:  MOVWF  x16
015A4:  MOVLW  89
015A6:  MOVWF  x15
015A8:  MOVLW  34
015AA:  MOVWF  x14
015AC:  MOVLW  7C
015AE:  MOVWF  x13
015B0:  MOVFF  5FC,61A
015B4:  MOVFF  5FB,619
015B8:  MOVFF  5FA,618
015BC:  MOVFF  5F9,617
015C0:  MOVLB  0
015C2:  CALL   09FA
015C6:  MOVFF  03,609
015CA:  MOVFF  02,608
015CE:  MOVFF  01,607
015D2:  MOVFF  00,606
015D6:  MOVFF  03,616
015DA:  MOVFF  02,615
015DE:  MOVFF  01,614
015E2:  MOVFF  00,613
015E6:  MOVFF  5FC,61A
015EA:  MOVFF  5FB,619
015EE:  MOVFF  5FA,618
015F2:  MOVFF  5F9,617
015F6:  CALL   09FA
015FA:  MOVFF  03,609
015FE:  MOVFF  02,608
01602:  MOVFF  01,607
01606:  MOVFF  00,606
0160A:  BCF    FD8.1
0160C:  MOVFF  03,61A
01610:  MOVFF  02,619
01614:  MOVFF  01,618
01618:  MOVFF  00,617
0161C:  MOVLW  7C
0161E:  MOVLB  6
01620:  MOVWF  x1E
01622:  MOVLW  79
01624:  MOVWF  x1D
01626:  MOVLW  35
01628:  MOVWF  x1C
0162A:  MOVLW  81
0162C:  MOVWF  x1B
0162E:  MOVLB  0
01630:  CALL   0AF0
01634:  MOVFF  03,600
01638:  MOVFF  02,5FF
0163C:  MOVFF  01,5FE
01640:  MOVFF  00,5FD
....................    res = res*y*y + pat[2];
01644:  MOVFF  600,616
01648:  MOVFF  5FF,615
0164C:  MOVFF  5FE,614
01650:  MOVFF  5FD,613
01654:  MOVFF  5FC,61A
01658:  MOVFF  5FB,619
0165C:  MOVFF  5FA,618
01660:  MOVFF  5F9,617
01664:  CALL   09FA
01668:  MOVFF  03,609
0166C:  MOVFF  02,608
01670:  MOVFF  01,607
01674:  MOVFF  00,606
01678:  MOVFF  03,616
0167C:  MOVFF  02,615
01680:  MOVFF  01,614
01684:  MOVFF  00,613
01688:  MOVFF  5FC,61A
0168C:  MOVFF  5FB,619
01690:  MOVFF  5FA,618
01694:  MOVFF  5F9,617
01698:  CALL   09FA
0169C:  MOVFF  03,609
016A0:  MOVFF  02,608
016A4:  MOVFF  01,607
016A8:  MOVFF  00,606
016AC:  BCF    FD8.1
016AE:  MOVFF  03,61A
016B2:  MOVFF  02,619
016B6:  MOVFF  01,618
016BA:  MOVFF  00,617
016BE:  MOVLW  3F
016C0:  MOVLB  6
016C2:  MOVWF  x1E
016C4:  MOVLW  02
016C6:  MOVWF  x1D
016C8:  MOVLW  33
016CA:  MOVWF  x1C
016CC:  MOVLW  83
016CE:  MOVWF  x1B
016D0:  MOVLB  0
016D2:  CALL   0AF0
016D6:  MOVFF  03,600
016DA:  MOVFF  02,5FF
016DE:  MOVFF  01,5FE
016E2:  MOVFF  00,5FD
....................    res = res*y*y + pat[3];
016E6:  MOVFF  600,616
016EA:  MOVFF  5FF,615
016EE:  MOVFF  5FE,614
016F2:  MOVFF  5FD,613
016F6:  MOVFF  5FC,61A
016FA:  MOVFF  5FB,619
016FE:  MOVFF  5FA,618
01702:  MOVFF  5F9,617
01706:  CALL   09FA
0170A:  MOVFF  03,609
0170E:  MOVFF  02,608
01712:  MOVFF  01,607
01716:  MOVFF  00,606
0171A:  MOVFF  03,616
0171E:  MOVFF  02,615
01722:  MOVFF  01,614
01726:  MOVFF  00,613
0172A:  MOVFF  5FC,61A
0172E:  MOVFF  5FB,619
01732:  MOVFF  5FA,618
01736:  MOVFF  5F9,617
0173A:  CALL   09FA
0173E:  MOVFF  03,609
01742:  MOVFF  02,608
01746:  MOVFF  01,607
0174A:  MOVFF  00,606
0174E:  BCF    FD8.1
01750:  MOVFF  03,61A
01754:  MOVFF  02,619
01758:  MOVFF  01,618
0175C:  MOVFF  00,617
01760:  MOVLW  33
01762:  MOVLB  6
01764:  MOVWF  x1E
01766:  MOVLW  8C
01768:  MOVWF  x1D
0176A:  MOVLW  1E
0176C:  MOVWF  x1C
0176E:  MOVLW  83
01770:  MOVWF  x1B
01772:  MOVLB  0
01774:  CALL   0AF0
01778:  MOVFF  03,600
0177C:  MOVFF  02,5FF
01780:  MOVFF  01,5FE
01784:  MOVFF  00,5FD
.................... 
....................    r = qat[0]*y*y + qat[1];
01788:  MOVLB  6
0178A:  CLRF   x16
0178C:  CLRF   x15
0178E:  CLRF   x14
01790:  MOVLW  7F
01792:  MOVWF  x13
01794:  MOVFF  5FC,61A
01798:  MOVFF  5FB,619
0179C:  MOVFF  5FA,618
017A0:  MOVFF  5F9,617
017A4:  MOVLB  0
017A6:  CALL   09FA
017AA:  MOVFF  03,609
017AE:  MOVFF  02,608
017B2:  MOVFF  01,607
017B6:  MOVFF  00,606
017BA:  MOVFF  03,616
017BE:  MOVFF  02,615
017C2:  MOVFF  01,614
017C6:  MOVFF  00,613
017CA:  MOVFF  5FC,61A
017CE:  MOVFF  5FB,619
017D2:  MOVFF  5FA,618
017D6:  MOVFF  5F9,617
017DA:  CALL   09FA
017DE:  MOVFF  03,609
017E2:  MOVFF  02,608
017E6:  MOVFF  01,607
017EA:  MOVFF  00,606
017EE:  BCF    FD8.1
017F0:  MOVFF  03,61A
017F4:  MOVFF  02,619
017F8:  MOVFF  01,618
017FC:  MOVFF  00,617
01800:  MOVLW  1B
01802:  MOVLB  6
01804:  MOVWF  x1E
01806:  MOVLW  E4
01808:  MOVWF  x1D
0180A:  MOVLW  35
0180C:  MOVWF  x1C
0180E:  MOVLW  82
01810:  MOVWF  x1B
01812:  MOVLB  0
01814:  CALL   0AF0
01818:  MOVFF  03,604
0181C:  MOVFF  02,603
01820:  MOVFF  01,602
01824:  MOVFF  00,601
....................    r = r*y*y + qat[2];
01828:  MOVFF  604,616
0182C:  MOVFF  603,615
01830:  MOVFF  602,614
01834:  MOVFF  601,613
01838:  MOVFF  5FC,61A
0183C:  MOVFF  5FB,619
01840:  MOVFF  5FA,618
01844:  MOVFF  5F9,617
01848:  CALL   09FA
0184C:  MOVFF  03,609
01850:  MOVFF  02,608
01854:  MOVFF  01,607
01858:  MOVFF  00,606
0185C:  MOVFF  03,616
01860:  MOVFF  02,615
01864:  MOVFF  01,614
01868:  MOVFF  00,613
0186C:  MOVFF  5FC,61A
01870:  MOVFF  5FB,619
01874:  MOVFF  5FA,618
01878:  MOVFF  5F9,617
0187C:  CALL   09FA
01880:  MOVFF  03,609
01884:  MOVFF  02,608
01888:  MOVFF  01,607
0188C:  MOVFF  00,606
01890:  BCF    FD8.1
01892:  MOVFF  03,61A
01896:  MOVFF  02,619
0189A:  MOVFF  01,618
0189E:  MOVFF  00,617
018A2:  MOVLW  A4
018A4:  MOVLB  6
018A6:  MOVWF  x1E
018A8:  MOVLW  DB
018AA:  MOVWF  x1D
018AC:  MOVLW  67
018AE:  MOVWF  x1C
018B0:  MOVLW  83
018B2:  MOVWF  x1B
018B4:  MOVLB  0
018B6:  CALL   0AF0
018BA:  MOVFF  03,604
018BE:  MOVFF  02,603
018C2:  MOVFF  01,602
018C6:  MOVFF  00,601
....................    r = r*y*y + qat[3];
018CA:  MOVFF  604,616
018CE:  MOVFF  603,615
018D2:  MOVFF  602,614
018D6:  MOVFF  601,613
018DA:  MOVFF  5FC,61A
018DE:  MOVFF  5FB,619
018E2:  MOVFF  5FA,618
018E6:  MOVFF  5F9,617
018EA:  CALL   09FA
018EE:  MOVFF  03,609
018F2:  MOVFF  02,608
018F6:  MOVFF  01,607
018FA:  MOVFF  00,606
018FE:  MOVFF  03,616
01902:  MOVFF  02,615
01906:  MOVFF  01,614
0190A:  MOVFF  00,613
0190E:  MOVFF  5FC,61A
01912:  MOVFF  5FB,619
01916:  MOVFF  5FA,618
0191A:  MOVFF  5F9,617
0191E:  CALL   09FA
01922:  MOVFF  03,609
01926:  MOVFF  02,608
0192A:  MOVFF  01,607
0192E:  MOVFF  00,606
01932:  BCF    FD8.1
01934:  MOVFF  03,61A
01938:  MOVFF  02,619
0193C:  MOVFF  01,618
01940:  MOVFF  00,617
01944:  MOVLW  33
01946:  MOVLB  6
01948:  MOVWF  x1E
0194A:  MOVLW  8C
0194C:  MOVWF  x1D
0194E:  MOVLW  1E
01950:  MOVWF  x1C
01952:  MOVLW  83
01954:  MOVWF  x1B
01956:  MOVLB  0
01958:  CALL   0AF0
0195C:  MOVFF  03,604
01960:  MOVFF  02,603
01964:  MOVFF  01,602
01968:  MOVFF  00,601
.................... 
....................    res = y*res/r;
0196C:  MOVFF  5FC,616
01970:  MOVFF  5FB,615
01974:  MOVFF  5FA,614
01978:  MOVFF  5F9,613
0197C:  MOVFF  600,61A
01980:  MOVFF  5FF,619
01984:  MOVFF  5FE,618
01988:  MOVFF  5FD,617
0198C:  CALL   09FA
01990:  MOVFF  03,609
01994:  MOVFF  02,608
01998:  MOVFF  01,607
0199C:  MOVFF  00,606
019A0:  MOVFF  03,60F
019A4:  MOVFF  02,60E
019A8:  MOVFF  01,60D
019AC:  MOVFF  00,60C
019B0:  MOVFF  604,613
019B4:  MOVFF  603,612
019B8:  MOVFF  602,611
019BC:  MOVFF  601,610
019C0:  RCALL  13A6
019C2:  MOVFF  03,600
019C6:  MOVFF  02,5FF
019CA:  MOVFF  01,5FE
019CE:  MOVFF  00,5FD
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
019D2:  MOVLB  6
019D4:  BTFSS  x05.1
019D6:  BRA    1A12
....................       res = PI_DIV_BY_TWO - res;
019D8:  BSF    FD8.1
019DA:  MOVLW  DB
019DC:  MOVWF  x1A
019DE:  MOVLW  0F
019E0:  MOVWF  x19
019E2:  MOVLW  49
019E4:  MOVWF  x18
019E6:  MOVLW  7F
019E8:  MOVWF  x17
019EA:  MOVFF  600,61E
019EE:  MOVFF  5FF,61D
019F2:  MOVFF  5FE,61C
019F6:  MOVFF  5FD,61B
019FA:  MOVLB  0
019FC:  CALL   0AF0
01A00:  MOVFF  03,600
01A04:  MOVFF  02,5FF
01A08:  MOVFF  01,5FE
01A0C:  MOVFF  00,5FD
01A10:  MOVLB  6
....................    if (s)
01A12:  BTFSS  x05.0
01A14:  BRA    1A20
....................       res = -res;
01A16:  MOVLB  5
01A18:  MOVF   xFE,W
01A1A:  XORLW  80
01A1C:  MOVWF  xFE
01A1E:  MOVLB  6
.................... 
....................    return(res);
01A20:  MOVFF  5FD,00
01A24:  MOVFF  5FE,01
01A28:  MOVFF  5FF,02
01A2C:  MOVFF  600,03
01A30:  MOVLB  0
01A32:  RETURN 0
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
01A34:  MOVLB  5
01A36:  BCF    xF3.0
....................    quad=0; //quadrant
01A38:  CLRF   xF4
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
01A3A:  MOVFF  5EA,616
01A3E:  MOVFF  5E9,615
01A42:  MOVFF  5E8,614
01A46:  MOVFF  5E7,613
01A4A:  MOVLB  6
01A4C:  CLRF   x1A
01A4E:  CLRF   x19
01A50:  CLRF   x18
01A52:  CLRF   x17
01A54:  MOVLB  0
01A56:  RCALL  132C
01A58:  BC    1A5C
01A5A:  BNZ   1A86
01A5C:  MOVFF  5EE,616
01A60:  MOVFF  5ED,615
01A64:  MOVFF  5EC,614
01A68:  MOVFF  5EB,613
01A6C:  MOVLB  6
01A6E:  CLRF   x1A
01A70:  CLRF   x19
01A72:  CLRF   x18
01A74:  CLRF   x17
01A76:  MOVLB  0
01A78:  RCALL  132C
01A7A:  BC    1A7E
01A7C:  BNZ   1A82
01A7E:  MOVLW  03
01A80:  BRA    1A84
01A82:  MOVLW  04
01A84:  BRA    1AAC
01A86:  MOVFF  5EE,616
01A8A:  MOVFF  5ED,615
01A8E:  MOVFF  5EC,614
01A92:  MOVFF  5EB,613
01A96:  MOVLB  6
01A98:  CLRF   x1A
01A9A:  CLRF   x19
01A9C:  CLRF   x18
01A9E:  CLRF   x17
01AA0:  MOVLB  0
01AA2:  RCALL  132C
01AA4:  BNC   1AAA
01AA6:  MOVLW  02
01AA8:  BRA    1AAC
01AAA:  MOVLW  01
01AAC:  MOVLB  5
01AAE:  MOVWF  xF4
....................    if(y<0.0)
01AB0:  MOVFF  5EA,616
01AB4:  MOVFF  5E9,615
01AB8:  MOVFF  5E8,614
01ABC:  MOVFF  5E7,613
01AC0:  MOVLB  6
01AC2:  CLRF   x1A
01AC4:  CLRF   x19
01AC6:  CLRF   x18
01AC8:  CLRF   x17
01ACA:  MOVLB  0
01ACC:  RCALL  132C
01ACE:  BNC   1ADC
....................    {
....................       sign=1;
01AD0:  MOVLB  5
01AD2:  BSF    xF3.0
....................       y=-y;
01AD4:  MOVF   xE8,W
01AD6:  XORLW  80
01AD8:  MOVWF  xE8
01ADA:  MOVLB  0
....................    }
....................    if(x<0.0)
01ADC:  MOVFF  5EE,616
01AE0:  MOVFF  5ED,615
01AE4:  MOVFF  5EC,614
01AE8:  MOVFF  5EB,613
01AEC:  MOVLB  6
01AEE:  CLRF   x1A
01AF0:  CLRF   x19
01AF2:  CLRF   x18
01AF4:  CLRF   x17
01AF6:  MOVLB  0
01AF8:  RCALL  132C
01AFA:  BNC   1B06
....................    {
....................       x=-x;
01AFC:  MOVLB  5
01AFE:  MOVF   xEC,W
01B00:  XORLW  80
01B02:  MOVWF  xEC
01B04:  MOVLB  0
....................    }
....................    if (x==0.0)
01B06:  MOVFF  5EE,616
01B0A:  MOVFF  5ED,615
01B0E:  MOVFF  5EC,614
01B12:  MOVFF  5EB,613
01B16:  MOVLB  6
01B18:  CLRF   x1A
01B1A:  CLRF   x19
01B1C:  CLRF   x18
01B1E:  CLRF   x17
01B20:  MOVLB  0
01B22:  RCALL  132C
01B24:  BNZ   1B7A
....................    {
....................       if(y==0.0)
01B26:  MOVFF  5EA,616
01B2A:  MOVFF  5E9,615
01B2E:  MOVFF  5E8,614
01B32:  MOVFF  5E7,613
01B36:  MOVLB  6
01B38:  CLRF   x1A
01B3A:  CLRF   x19
01B3C:  CLRF   x18
01B3E:  CLRF   x17
01B40:  MOVLB  0
01B42:  CALL   132C
01B46:  BNZ   1B4A
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
01B48:  BRA    1B78
....................       else
....................       {
....................          if(sign)
01B4A:  MOVLB  5
01B4C:  BTFSS  xF3.0
01B4E:  BRA    1B64
....................          {
....................          return (-(PI_DIV_BY_TWO));
01B50:  MOVLW  7F
01B52:  MOVWF  00
01B54:  MOVLW  C9
01B56:  MOVWF  01
01B58:  MOVLW  0F
01B5A:  MOVWF  02
01B5C:  MOVLW  DB
01B5E:  MOVWF  03
01B60:  BRA    1CB2
....................          }
01B62:  BRA    1B76
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
01B64:  MOVLW  7F
01B66:  MOVWF  00
01B68:  MOVLW  49
01B6A:  MOVWF  01
01B6C:  MOVLW  0F
01B6E:  MOVWF  02
01B70:  MOVLW  DB
01B72:  MOVWF  03
01B74:  BRA    1CB2
01B76:  MOVLB  0
....................          }
....................       }
....................    }
01B78:  BRA    1CB0
....................    else
....................    {
....................       z=y/x;
01B7A:  MOVFF  5EA,60F
01B7E:  MOVFF  5E9,60E
01B82:  MOVFF  5E8,60D
01B86:  MOVFF  5E7,60C
01B8A:  MOVFF  5EE,613
01B8E:  MOVFF  5ED,612
01B92:  MOVFF  5EC,611
01B96:  MOVFF  5EB,610
01B9A:  RCALL  13A6
01B9C:  MOVFF  03,5F2
01BA0:  MOVFF  02,5F1
01BA4:  MOVFF  01,5F0
01BA8:  MOVFF  00,5EF
....................       switch(quad)
01BAC:  MOVLW  01
01BAE:  MOVLB  5
01BB0:  SUBWF  xF4,W
01BB2:  ADDLW  FC
01BB4:  BTFSC  FD8.0
01BB6:  BRA    1CB2
01BB8:  ADDLW  04
01BBA:  MOVLB  0
01BBC:  GOTO   1CB8
....................       {
....................          case 1:
....................          {
....................             return atan(z);
01BC0:  MOVFF  5F2,5F8
01BC4:  MOVFF  5F1,5F7
01BC8:  MOVFF  5F0,5F6
01BCC:  MOVFF  5EF,5F5
01BD0:  RCALL  1504
01BD2:  MOVLB  5
01BD4:  BRA    1CB2
....................             break;
01BD6:  BRA    1CB2
01BD8:  MOVLB  0
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
01BDA:  MOVFF  5F2,5F8
01BDE:  MOVFF  5F1,5F7
01BE2:  MOVFF  5F0,5F6
01BE6:  MOVFF  5EF,5F5
01BEA:  RCALL  1504
01BEC:  MOVFF  FEA,5F6
01BF0:  MOVFF  FE9,5F5
01BF4:  BSF    FD8.1
01BF6:  MOVLW  DB
01BF8:  MOVLB  6
01BFA:  MOVWF  x1A
01BFC:  MOVLW  0F
01BFE:  MOVWF  x19
01C00:  MOVLW  49
01C02:  MOVWF  x18
01C04:  MOVLW  80
01C06:  MOVWF  x17
01C08:  MOVFF  03,61E
01C0C:  MOVFF  02,61D
01C10:  MOVFF  01,61C
01C14:  MOVFF  00,61B
01C18:  MOVLB  0
01C1A:  CALL   0AF0
01C1E:  MOVFF  5F6,FEA
01C22:  MOVFF  5F5,FE9
01C26:  MOVLB  5
01C28:  BRA    1CB2
....................             break;
01C2A:  BRA    1CB2
01C2C:  MOVLB  0
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
01C2E:  MOVFF  5F2,5F8
01C32:  MOVFF  5F1,5F7
01C36:  MOVFF  5F0,5F6
01C3A:  MOVFF  5EF,5F5
01C3E:  RCALL  1504
01C40:  MOVFF  03,5F8
01C44:  MOVFF  02,5F7
01C48:  MOVFF  01,5F6
01C4C:  MOVFF  00,5F5
01C50:  MOVFF  FEA,5FA
01C54:  MOVFF  FE9,5F9
01C58:  BSF    FD8.1
01C5A:  MOVFF  03,61A
01C5E:  MOVFF  02,619
01C62:  MOVFF  01,618
01C66:  MOVFF  00,617
01C6A:  MOVLW  DB
01C6C:  MOVLB  6
01C6E:  MOVWF  x1E
01C70:  MOVLW  0F
01C72:  MOVWF  x1D
01C74:  MOVLW  49
01C76:  MOVWF  x1C
01C78:  MOVLW  80
01C7A:  MOVWF  x1B
01C7C:  MOVLB  0
01C7E:  CALL   0AF0
01C82:  MOVFF  5FA,FEA
01C86:  MOVFF  5F9,FE9
01C8A:  MOVLB  5
01C8C:  BRA    1CB2
....................             break;
01C8E:  BRA    1CB2
01C90:  MOVLB  0
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
01C92:  MOVFF  5F2,5F8
01C96:  MOVFF  5F1,5F7
01C9A:  MOVFF  5F0,5F6
01C9E:  MOVFF  5EF,5F5
01CA2:  RCALL  1504
01CA4:  MOVLW  80
01CA6:  XORWF  01,F
01CA8:  MOVLB  5
01CAA:  BRA    1CB2
....................             break;
01CAC:  BRA    1CB2
01CAE:  MOVLB  0
01CB0:  MOVLB  5
....................          }
....................       }
....................    }
01CB2:  MOVLB  0
01CB4:  GOTO   30B4 (RETURN)
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... #define sensorSampleRate 50 // 50mS delay between each sensor sample = 200ms cadence 
.................... 
.................... #define maxCount 16777216.0   // ADC max count
.................... //!#define vRef 2.048            // ADC vRef
.................... 
.................... #define sc sensorCal
.................... 
.................... // adc settings for magnetoresistive sensors
.................... #define KMXP1000reg0config IPp1n2|g16|PGAenabled // 0x3A//
.................... #define KMXP1000reg1config DRn20|MDturbo|CMsingle|TSDisable|BCSoff //0x00
.................... #define KMXP1000reg2config REFinternal|FIR60|PSWopen|Ioff //0x30
.................... #define KMXP1000reg3config I1disabled|I2disabled|drdyPin //0x00
.................... 
.................... #define KMXP2000reg0config IPp1n2|g16|PGAenabled // 0x3A//
.................... #define KMXP2000reg1config DRn20|MDturbo|CMsingle|TSDisable|BCSoff //0x00
.................... #define KMXP2000reg2config REFinternal|FIR60|PSWopen|Ioff //0x30
.................... #define KMXP2000reg3config I1disabled|I2disabled|drdyPin //0x00
.................... 
.................... #define vMonN15   6
.................... #define vMon200   16
.................... #define vMon5V6   24
.................... #define vMon5VA   25
.................... #define vMon3V6X  17
.................... #define vMon3V3A  27
.................... #define vMon3V3D  26
.................... 
.................... struct sensorMonitorData
.................... {
....................    boolean dataReady;
....................    boolean adcBusy;
....................    int8 channel; // DEFAULT: 0=chX | 1=chY
.................... } smData = {false, false, 0};
.................... 
.................... /*****************************************************************************/
.................... /* INTERNAL MONITOR task - gets voltages                                     */
.................... /* gets one value each time the task is run                                  */
.................... /*****************************************************************************/
.................... void internal_monitor_task()
.................... {
....................    static int8 state = 0;
....................    if (adc_done())
*
00D68:  MOVLB  F
00D6A:  BTFSC  x5B.0
00D6C:  BRA    1278
....................    {
....................       switch (state)
00D6E:  MOVLB  1
00D70:  MOVF   x51,W
00D72:  XORLW  00
00D74:  MOVLB  0
00D76:  BZ    0D96
00D78:  XORLW  01
00D7A:  BZ    0E48
00D7C:  XORLW  03
00D7E:  BTFSC  FD8.2
00D80:  BRA    0EFA
00D82:  XORLW  01
00D84:  BTFSC  FD8.2
00D86:  BRA    0FAC
00D88:  XORLW  07
00D8A:  BTFSC  FD8.2
00D8C:  BRA    105E
00D8E:  XORLW  01
00D90:  BTFSC  FD8.2
00D92:  BRA    1110
00D94:  BRA    11C4
....................       {
....................          case 0:     // vMonN15
....................             monitorVals.vN15 = read_adc(ADC_READ_ONLY) * monCal.vN15[1] + monCal.vN15[0];
00D96:  MOVLB  F
00D98:  BTFSC  x5B.0
00D9A:  BRA    0D98
00D9C:  MOVFF  F5F,02
00DA0:  MOVFF  F5E,01
00DA4:  MOVFF  02,5C0
00DA8:  MOVFF  01,5BF
00DAC:  MOVFF  02,618
00DB0:  MOVFF  01,617
00DB4:  MOVLB  0
00DB6:  RCALL  09C4
00DB8:  MOVFF  03,616
00DBC:  MOVFF  02,615
00DC0:  MOVFF  01,614
00DC4:  MOVFF  00,613
00DC8:  MOVFF  B9,61A
00DCC:  MOVFF  B8,619
00DD0:  MOVFF  B7,618
00DD4:  MOVFF  B6,617
00DD8:  RCALL  09FA
00DDA:  MOVFF  03,5C2
00DDE:  MOVFF  02,5C1
00DE2:  MOVFF  01,5C0
00DE6:  MOVFF  00,5BF
00DEA:  BCF    FD8.1
00DEC:  MOVFF  03,61A
00DF0:  MOVFF  02,619
00DF4:  MOVFF  01,618
00DF8:  MOVFF  00,617
00DFC:  MOVFF  B5,61E
00E00:  MOVFF  B4,61D
00E04:  MOVFF  B3,61C
00E08:  MOVFF  B2,61B
00E0C:  RCALL  0AF0
00E0E:  MOVFF  03,F6
00E12:  MOVFF  02,F5
00E16:  MOVFF  01,F4
00E1A:  MOVFF  00,F3
....................             set_adc_channel(vMon200);
00E1E:  MOVLB  F
00E20:  MOVF   x5A,W
00E22:  ANDLW  3F
00E24:  MOVWF  01
00E26:  MOVLW  10
00E28:  MOVWF  x5A
00E2A:  BTFSS  x5B.7
00E2C:  BRA    0E3C
00E2E:  MOVF   01,W
00E30:  SUBLW  10
00E32:  BZ    0E3C
00E34:  BSF    x5B.0
00E36:  NOP   
00E38:  BTFSC  x5B.0
00E3A:  BRA    0E38
....................             read_adc(ADC_START_ONLY);
00E3C:  BSF    x5B.0
00E3E:  NOP   
....................             state = 1;
00E40:  MOVLW  01
00E42:  MOVLB  1
00E44:  MOVWF  x51
....................          break;
00E46:  BRA    1276
....................          
....................          case 1:     // vMon200
....................             monitorVals.v200 = read_adc(ADC_READ_ONLY) * monCal.v200[1] + monCal.v200[0];
00E48:  MOVLB  F
00E4A:  BTFSC  x5B.0
00E4C:  BRA    0E4A
00E4E:  MOVFF  F5F,02
00E52:  MOVFF  F5E,01
00E56:  MOVFF  02,5C0
00E5A:  MOVFF  01,5BF
00E5E:  MOVFF  02,618
00E62:  MOVFF  01,617
00E66:  MOVLB  0
00E68:  RCALL  09C4
00E6A:  MOVFF  03,616
00E6E:  MOVFF  02,615
00E72:  MOVFF  01,614
00E76:  MOVFF  00,613
00E7A:  MOVFF  C1,61A
00E7E:  MOVFF  C0,619
00E82:  MOVFF  BF,618
00E86:  MOVFF  BE,617
00E8A:  RCALL  09FA
00E8C:  MOVFF  03,5C2
00E90:  MOVFF  02,5C1
00E94:  MOVFF  01,5C0
00E98:  MOVFF  00,5BF
00E9C:  BCF    FD8.1
00E9E:  MOVFF  03,61A
00EA2:  MOVFF  02,619
00EA6:  MOVFF  01,618
00EAA:  MOVFF  00,617
00EAE:  MOVFF  BD,61E
00EB2:  MOVFF  BC,61D
00EB6:  MOVFF  BB,61C
00EBA:  MOVFF  BA,61B
00EBE:  RCALL  0AF0
00EC0:  MOVFF  03,FA
00EC4:  MOVFF  02,F9
00EC8:  MOVFF  01,F8
00ECC:  MOVFF  00,F7
....................             set_adc_channel(vMon5V6);
00ED0:  MOVLB  F
00ED2:  MOVF   x5A,W
00ED4:  ANDLW  3F
00ED6:  MOVWF  01
00ED8:  MOVLW  18
00EDA:  MOVWF  x5A
00EDC:  BTFSS  x5B.7
00EDE:  BRA    0EEE
00EE0:  MOVF   01,W
00EE2:  SUBLW  18
00EE4:  BZ    0EEE
00EE6:  BSF    x5B.0
00EE8:  NOP   
00EEA:  BTFSC  x5B.0
00EEC:  BRA    0EEA
....................             read_adc(ADC_START_ONLY);
00EEE:  BSF    x5B.0
00EF0:  NOP   
....................             state = 2;
00EF2:  MOVLW  02
00EF4:  MOVLB  1
00EF6:  MOVWF  x51
....................          break;
00EF8:  BRA    1276
....................          
....................          case 2:     // vMon5V6
....................             monitorVals.v5V6 = read_adc(ADC_READ_ONLY) * monCal.v5V6[1] + monCal.v5V6[0];
00EFA:  MOVLB  F
00EFC:  BTFSC  x5B.0
00EFE:  BRA    0EFC
00F00:  MOVFF  F5F,02
00F04:  MOVFF  F5E,01
00F08:  MOVFF  02,5C0
00F0C:  MOVFF  01,5BF
00F10:  MOVFF  02,618
00F14:  MOVFF  01,617
00F18:  MOVLB  0
00F1A:  RCALL  09C4
00F1C:  MOVFF  03,616
00F20:  MOVFF  02,615
00F24:  MOVFF  01,614
00F28:  MOVFF  00,613
00F2C:  MOVFF  C9,61A
00F30:  MOVFF  C8,619
00F34:  MOVFF  C7,618
00F38:  MOVFF  C6,617
00F3C:  RCALL  09FA
00F3E:  MOVFF  03,5C2
00F42:  MOVFF  02,5C1
00F46:  MOVFF  01,5C0
00F4A:  MOVFF  00,5BF
00F4E:  BCF    FD8.1
00F50:  MOVFF  03,61A
00F54:  MOVFF  02,619
00F58:  MOVFF  01,618
00F5C:  MOVFF  00,617
00F60:  MOVFF  C5,61E
00F64:  MOVFF  C4,61D
00F68:  MOVFF  C3,61C
00F6C:  MOVFF  C2,61B
00F70:  RCALL  0AF0
00F72:  MOVFF  03,FE
00F76:  MOVFF  02,FD
00F7A:  MOVFF  01,FC
00F7E:  MOVFF  00,FB
....................             set_adc_channel(vMon5VA);
00F82:  MOVLB  F
00F84:  MOVF   x5A,W
00F86:  ANDLW  3F
00F88:  MOVWF  01
00F8A:  MOVLW  19
00F8C:  MOVWF  x5A
00F8E:  BTFSS  x5B.7
00F90:  BRA    0FA0
00F92:  MOVF   01,W
00F94:  SUBLW  19
00F96:  BZ    0FA0
00F98:  BSF    x5B.0
00F9A:  NOP   
00F9C:  BTFSC  x5B.0
00F9E:  BRA    0F9C
....................             read_adc(ADC_START_ONLY);
00FA0:  BSF    x5B.0
00FA2:  NOP   
....................             state = 3;
00FA4:  MOVLW  03
00FA6:  MOVLB  1
00FA8:  MOVWF  x51
....................          break;
00FAA:  BRA    1276
....................          
....................          case 3:     // vMon5VA
....................             monitorVals.v5VA = read_adc(ADC_READ_ONLY) * monCal.v5VA[1] + monCal.v5VA[0];
00FAC:  MOVLB  F
00FAE:  BTFSC  x5B.0
00FB0:  BRA    0FAE
00FB2:  MOVFF  F5F,02
00FB6:  MOVFF  F5E,01
00FBA:  MOVFF  02,5C0
00FBE:  MOVFF  01,5BF
00FC2:  MOVFF  02,618
00FC6:  MOVFF  01,617
00FCA:  MOVLB  0
00FCC:  RCALL  09C4
00FCE:  MOVFF  03,616
00FD2:  MOVFF  02,615
00FD6:  MOVFF  01,614
00FDA:  MOVFF  00,613
00FDE:  MOVFF  D1,61A
00FE2:  MOVFF  D0,619
00FE6:  MOVFF  CF,618
00FEA:  MOVFF  CE,617
00FEE:  RCALL  09FA
00FF0:  MOVFF  03,5C2
00FF4:  MOVFF  02,5C1
00FF8:  MOVFF  01,5C0
00FFC:  MOVFF  00,5BF
01000:  BCF    FD8.1
01002:  MOVFF  03,61A
01006:  MOVFF  02,619
0100A:  MOVFF  01,618
0100E:  MOVFF  00,617
01012:  MOVFF  CD,61E
01016:  MOVFF  CC,61D
0101A:  MOVFF  CB,61C
0101E:  MOVFF  CA,61B
01022:  RCALL  0AF0
01024:  MOVFF  03,102
01028:  MOVFF  02,101
0102C:  MOVFF  01,100
01030:  MOVFF  00,FF
....................             set_adc_channel(vMon3V6X);
01034:  MOVLB  F
01036:  MOVF   x5A,W
01038:  ANDLW  3F
0103A:  MOVWF  01
0103C:  MOVLW  11
0103E:  MOVWF  x5A
01040:  BTFSS  x5B.7
01042:  BRA    1052
01044:  MOVF   01,W
01046:  SUBLW  11
01048:  BZ    1052
0104A:  BSF    x5B.0
0104C:  NOP   
0104E:  BTFSC  x5B.0
01050:  BRA    104E
....................             read_adc(ADC_START_ONLY);
01052:  BSF    x5B.0
01054:  NOP   
....................             state = 4;
01056:  MOVLW  04
01058:  MOVLB  1
0105A:  MOVWF  x51
....................          break;
0105C:  BRA    1276
....................          
....................          case 4:     // vMon3V6X
....................             monitorVals.v3V6X = read_adc(ADC_READ_ONLY) * monCal.v3V6X[1] + monCal.v3V6X[0];
0105E:  MOVLB  F
01060:  BTFSC  x5B.0
01062:  BRA    1060
01064:  MOVFF  F5F,02
01068:  MOVFF  F5E,01
0106C:  MOVFF  02,5C0
01070:  MOVFF  01,5BF
01074:  MOVFF  02,618
01078:  MOVFF  01,617
0107C:  MOVLB  0
0107E:  RCALL  09C4
01080:  MOVFF  03,616
01084:  MOVFF  02,615
01088:  MOVFF  01,614
0108C:  MOVFF  00,613
01090:  MOVFF  D9,61A
01094:  MOVFF  D8,619
01098:  MOVFF  D7,618
0109C:  MOVFF  D6,617
010A0:  RCALL  09FA
010A2:  MOVFF  03,5C2
010A6:  MOVFF  02,5C1
010AA:  MOVFF  01,5C0
010AE:  MOVFF  00,5BF
010B2:  BCF    FD8.1
010B4:  MOVFF  03,61A
010B8:  MOVFF  02,619
010BC:  MOVFF  01,618
010C0:  MOVFF  00,617
010C4:  MOVFF  D5,61E
010C8:  MOVFF  D4,61D
010CC:  MOVFF  D3,61C
010D0:  MOVFF  D2,61B
010D4:  RCALL  0AF0
010D6:  MOVFF  03,106
010DA:  MOVFF  02,105
010DE:  MOVFF  01,104
010E2:  MOVFF  00,103
....................             set_adc_channel(vMon3V3A);
010E6:  MOVLB  F
010E8:  MOVF   x5A,W
010EA:  ANDLW  3F
010EC:  MOVWF  01
010EE:  MOVLW  1B
010F0:  MOVWF  x5A
010F2:  BTFSS  x5B.7
010F4:  BRA    1104
010F6:  MOVF   01,W
010F8:  SUBLW  1B
010FA:  BZ    1104
010FC:  BSF    x5B.0
010FE:  NOP   
01100:  BTFSC  x5B.0
01102:  BRA    1100
....................             read_adc(ADC_START_ONLY);
01104:  BSF    x5B.0
01106:  NOP   
....................             state = 5;
01108:  MOVLW  05
0110A:  MOVLB  1
0110C:  MOVWF  x51
....................          break;
0110E:  BRA    1276
....................          
....................          case 5:     // vMon3V3A
....................             monitorVals.v3V3A = read_adc(ADC_READ_ONLY) * monCal.v3V3A[1] + monCal.v3V3A[0];
01110:  MOVLB  F
01112:  BTFSC  x5B.0
01114:  BRA    1112
01116:  MOVFF  F5F,02
0111A:  MOVFF  F5E,01
0111E:  MOVFF  02,5C0
01122:  MOVFF  01,5BF
01126:  MOVFF  02,618
0112A:  MOVFF  01,617
0112E:  MOVLB  0
01130:  RCALL  09C4
01132:  MOVFF  03,616
01136:  MOVFF  02,615
0113A:  MOVFF  01,614
0113E:  MOVFF  00,613
01142:  MOVFF  E1,61A
01146:  MOVFF  E0,619
0114A:  MOVFF  DF,618
0114E:  MOVFF  DE,617
01152:  RCALL  09FA
01154:  MOVFF  03,5C2
01158:  MOVFF  02,5C1
0115C:  MOVFF  01,5C0
01160:  MOVFF  00,5BF
01164:  BCF    FD8.1
01166:  MOVFF  03,61A
0116A:  MOVFF  02,619
0116E:  MOVFF  01,618
01172:  MOVFF  00,617
01176:  MOVFF  DD,61E
0117A:  MOVFF  DC,61D
0117E:  MOVFF  DB,61C
01182:  MOVFF  DA,61B
01186:  RCALL  0AF0
01188:  MOVFF  03,10A
0118C:  MOVFF  02,109
01190:  MOVFF  01,108
01194:  MOVFF  00,107
....................             set_adc_channel(vMon3V3D);
01198:  MOVLB  F
0119A:  MOVF   x5A,W
0119C:  ANDLW  3F
0119E:  MOVWF  01
011A0:  MOVLW  1A
011A2:  MOVWF  x5A
011A4:  BTFSS  x5B.7
011A6:  BRA    11B6
011A8:  MOVF   01,W
011AA:  SUBLW  1A
011AC:  BZ    11B6
011AE:  BSF    x5B.0
011B0:  NOP   
011B2:  BTFSC  x5B.0
011B4:  BRA    11B2
....................             read_adc(ADC_START_ONLY);
011B6:  BSF    x5B.0
011B8:  NOP   
....................             state = 6;
011BA:  MOVLW  06
011BC:  MOVLB  1
011BE:  MOVWF  x51
....................          break;
011C0:  BRA    1276
011C2:  MOVLB  0
....................          
....................          default:    // vMon3V3D
....................             monitorVals.v3V3D = read_adc(ADC_READ_ONLY) * monCal.v3V3D[1] + monCal.v3V3D[0];
011C4:  MOVLB  F
011C6:  BTFSC  x5B.0
011C8:  BRA    11C6
011CA:  MOVFF  F5F,02
011CE:  MOVFF  F5E,01
011D2:  MOVFF  02,5C0
011D6:  MOVFF  01,5BF
011DA:  MOVFF  02,618
011DE:  MOVFF  01,617
011E2:  MOVLB  0
011E4:  CALL   09C4
011E8:  MOVFF  03,616
011EC:  MOVFF  02,615
011F0:  MOVFF  01,614
011F4:  MOVFF  00,613
011F8:  MOVFF  E9,61A
011FC:  MOVFF  E8,619
01200:  MOVFF  E7,618
01204:  MOVFF  E6,617
01208:  CALL   09FA
0120C:  MOVFF  03,5C2
01210:  MOVFF  02,5C1
01214:  MOVFF  01,5C0
01218:  MOVFF  00,5BF
0121C:  BCF    FD8.1
0121E:  MOVFF  03,61A
01222:  MOVFF  02,619
01226:  MOVFF  01,618
0122A:  MOVFF  00,617
0122E:  MOVFF  E5,61E
01232:  MOVFF  E4,61D
01236:  MOVFF  E3,61C
0123A:  MOVFF  E2,61B
0123E:  RCALL  0AF0
01240:  MOVFF  03,10E
01244:  MOVFF  02,10D
01248:  MOVFF  01,10C
0124C:  MOVFF  00,10B
....................             set_adc_channel(vMonN15);
01250:  MOVLB  F
01252:  MOVF   x5A,W
01254:  ANDLW  3F
01256:  MOVWF  01
01258:  MOVLW  06
0125A:  MOVWF  x5A
0125C:  BTFSS  x5B.7
0125E:  BRA    126E
01260:  MOVF   01,W
01262:  SUBLW  06
01264:  BZ    126E
01266:  BSF    x5B.0
01268:  NOP   
0126A:  BTFSC  x5B.0
0126C:  BRA    126A
....................             read_adc(ADC_START_ONLY);
0126E:  BSF    x5B.0
01270:  NOP   
....................             state = 0;
01272:  MOVLB  1
01274:  CLRF   x51
....................          break;   
01276:  MOVLB  F
....................       }
....................    }
01278:  MOVLB  0
0127A:  GOTO   6AC8 (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* PROCESS ADC SENSOR DATA                                                   */
.................... /*****************************************************************************/
.................... void sensor_process_data(int8 ch, unsigned int32 sinRawCounts, unsigned int32 cosRawCounts)
.................... {
....................    adcVals[ch].sinRaw = (float)sinRawCounts;
*
02D14:  MOVLB  5
02D16:  MOVF   xC8,W
02D18:  MULLW  19
02D1A:  MOVF   FF3,W
02D1C:  CLRF   xDA
02D1E:  MOVWF  xD9
02D20:  MOVLW  0F
02D22:  ADDWF  xD9,W
02D24:  MOVWF  FE9
02D26:  MOVLW  01
02D28:  ADDWFC xDA,W
02D2A:  MOVWF  FEA
02D2C:  MOVFF  5CC,5E0
02D30:  MOVFF  5CB,5DF
02D34:  MOVFF  5CA,5DE
02D38:  MOVFF  5C9,5DD
02D3C:  MOVLB  0
02D3E:  CALL   12F4
02D42:  MOVFF  00,FEF
02D46:  MOVFF  01,FEC
02D4A:  MOVFF  02,FEC
02D4E:  MOVFF  03,FEC
....................    adcVals[ch].cosRaw = (float)cosRawCounts;
02D52:  MOVLB  5
02D54:  MOVF   xC8,W
02D56:  MULLW  19
02D58:  MOVF   FF3,W
02D5A:  CLRF   xDA
02D5C:  MOVWF  xD9
02D5E:  MOVLW  04
02D60:  ADDWF  xD9,W
02D62:  MOVWF  01
02D64:  MOVLW  00
02D66:  ADDWFC xDA,W
02D68:  MOVWF  03
02D6A:  MOVF   01,W
02D6C:  ADDLW  0F
02D6E:  MOVWF  FE9
02D70:  MOVLW  01
02D72:  ADDWFC 03,W
02D74:  MOVWF  FEA
02D76:  MOVFF  5D0,5E0
02D7A:  MOVFF  5CF,5DF
02D7E:  MOVFF  5CE,5DE
02D82:  MOVFF  5CD,5DD
02D86:  MOVLB  0
02D88:  CALL   12F4
02D8C:  MOVFF  00,FEF
02D90:  MOVFF  01,FEC
02D94:  MOVFF  02,FEC
02D98:  MOVFF  03,FEC
....................    
....................    adcVals[ch].sinCounts = adcVals[ch].sinRaw * adcCal[ch].sinGain + adcCal[ch].sinOS;
02D9C:  MOVLB  5
02D9E:  MOVF   xC8,W
02DA0:  MULLW  19
02DA2:  MOVF   FF3,W
02DA4:  CLRF   xDA
02DA6:  MOVWF  xD9
02DA8:  MOVLW  08
02DAA:  ADDWF  xD9,W
02DAC:  MOVWF  01
02DAE:  MOVLW  00
02DB0:  ADDWFC xDA,W
02DB2:  MOVWF  03
02DB4:  MOVF   01,W
02DB6:  ADDLW  0F
02DB8:  MOVWF  01
02DBA:  MOVLW  01
02DBC:  ADDWFC 03,F
02DBE:  MOVFF  01,5D9
02DC2:  MOVFF  03,5DA
02DC6:  MOVF   xC8,W
02DC8:  MULLW  19
02DCA:  MOVF   FF3,W
02DCC:  CLRF   xDC
02DCE:  MOVWF  xDB
02DD0:  MOVLW  0F
02DD2:  ADDWF  xDB,W
02DD4:  MOVWF  FE9
02DD6:  MOVLW  01
02DD8:  ADDWFC xDC,W
02DDA:  MOVWF  FEA
02DDC:  MOVFF  FEF,613
02DE0:  MOVFF  FEC,614
02DE4:  MOVFF  FEC,615
02DE8:  MOVFF  FEC,616
02DEC:  MOVF   xC8,W
02DEE:  MULLW  10
02DF0:  MOVF   FF3,W
02DF2:  CLRF   xE2
02DF4:  MOVWF  xE1
02DF6:  MOVLW  08
02DF8:  ADDWF  xE1,W
02DFA:  MOVWF  01
02DFC:  MOVLW  00
02DFE:  ADDWFC xE2,W
02E00:  MOVWF  03
02E02:  MOVF   01,W
02E04:  ADDLW  62
02E06:  MOVWF  FE9
02E08:  MOVLW  00
02E0A:  ADDWFC 03,W
02E0C:  MOVWF  FEA
02E0E:  MOVFF  FEF,617
02E12:  MOVFF  FEC,01
02E16:  MOVFF  FEC,02
02E1A:  MOVFF  FEC,03
02E1E:  MOVFF  03,61A
02E22:  MOVFF  02,619
02E26:  MOVFF  01,618
02E2A:  MOVLB  0
02E2C:  CALL   09FA
02E30:  MOVFF  03,61A
02E34:  MOVFF  02,619
02E38:  MOVFF  01,618
02E3C:  MOVFF  00,617
02E40:  MOVLB  5
02E42:  MOVF   xC8,W
02E44:  MULLW  10
02E46:  MOVF   FF3,W
02E48:  CLRF   xE2
02E4A:  MOVWF  xE1
02E4C:  MOVLW  62
02E4E:  ADDWF  xE1,W
02E50:  MOVWF  FE9
02E52:  MOVLW  00
02E54:  ADDWFC xE2,W
02E56:  MOVWF  FEA
02E58:  MOVFF  FEF,61B
02E5C:  MOVFF  FEC,01
02E60:  MOVFF  FEC,02
02E64:  MOVFF  FEC,03
02E68:  BCF    FD8.1
02E6A:  MOVFF  03,61E
02E6E:  MOVFF  02,61D
02E72:  MOVFF  01,61C
02E76:  MOVLB  0
02E78:  CALL   0AF0
02E7C:  MOVFF  5DA,FEA
02E80:  MOVFF  5D9,FE9
02E84:  MOVFF  00,FEF
02E88:  MOVFF  01,FEC
02E8C:  MOVFF  02,FEC
02E90:  MOVFF  03,FEC
....................    adcVals[ch].cosCounts = adcVals[ch].cosRaw * adcCal[ch].cosGain + adcCal[ch].cosOS;
02E94:  MOVLB  5
02E96:  MOVF   xC8,W
02E98:  MULLW  19
02E9A:  MOVF   FF3,W
02E9C:  CLRF   xDA
02E9E:  MOVWF  xD9
02EA0:  MOVLW  0C
02EA2:  ADDWF  xD9,W
02EA4:  MOVWF  01
02EA6:  MOVLW  00
02EA8:  ADDWFC xDA,W
02EAA:  MOVWF  03
02EAC:  MOVF   01,W
02EAE:  ADDLW  0F
02EB0:  MOVWF  01
02EB2:  MOVLW  01
02EB4:  ADDWFC 03,F
02EB6:  MOVFF  01,5D9
02EBA:  MOVFF  03,5DA
02EBE:  MOVF   xC8,W
02EC0:  MULLW  19
02EC2:  MOVF   FF3,W
02EC4:  CLRF   xDC
02EC6:  MOVWF  xDB
02EC8:  MOVLW  04
02ECA:  ADDWF  xDB,W
02ECC:  MOVWF  01
02ECE:  MOVLW  00
02ED0:  ADDWFC xDC,W
02ED2:  MOVWF  03
02ED4:  MOVF   01,W
02ED6:  ADDLW  0F
02ED8:  MOVWF  FE9
02EDA:  MOVLW  01
02EDC:  ADDWFC 03,W
02EDE:  MOVWF  FEA
02EE0:  MOVFF  FEF,613
02EE4:  MOVFF  FEC,614
02EE8:  MOVFF  FEC,615
02EEC:  MOVFF  FEC,616
02EF0:  MOVF   xC8,W
02EF2:  MULLW  10
02EF4:  MOVF   FF3,W
02EF6:  CLRF   xE0
02EF8:  MOVWF  xDF
02EFA:  MOVLW  0C
02EFC:  ADDWF  xDF,W
02EFE:  MOVWF  01
02F00:  MOVLW  00
02F02:  ADDWFC xE0,W
02F04:  MOVWF  03
02F06:  MOVF   01,W
02F08:  ADDLW  62
02F0A:  MOVWF  FE9
02F0C:  MOVLW  00
02F0E:  ADDWFC 03,W
02F10:  MOVWF  FEA
02F12:  MOVFF  FEF,617
02F16:  MOVFF  FEC,01
02F1A:  MOVFF  FEC,02
02F1E:  MOVFF  FEC,03
02F22:  MOVFF  03,61A
02F26:  MOVFF  02,619
02F2A:  MOVFF  01,618
02F2E:  MOVLB  0
02F30:  CALL   09FA
02F34:  MOVFF  03,61A
02F38:  MOVFF  02,619
02F3C:  MOVFF  01,618
02F40:  MOVFF  00,617
02F44:  MOVLB  5
02F46:  MOVF   xC8,W
02F48:  MULLW  10
02F4A:  MOVF   FF3,W
02F4C:  CLRF   xE0
02F4E:  MOVWF  xDF
02F50:  MOVLW  04
02F52:  ADDWF  xDF,W
02F54:  MOVWF  01
02F56:  MOVLW  00
02F58:  ADDWFC xE0,W
02F5A:  MOVWF  03
02F5C:  MOVF   01,W
02F5E:  ADDLW  62
02F60:  MOVWF  FE9
02F62:  MOVLW  00
02F64:  ADDWFC 03,W
02F66:  MOVWF  FEA
02F68:  MOVFF  FEF,61B
02F6C:  MOVFF  FEC,01
02F70:  MOVFF  FEC,02
02F74:  MOVFF  FEC,03
02F78:  BCF    FD8.1
02F7A:  MOVFF  03,61E
02F7E:  MOVFF  02,61D
02F82:  MOVFF  01,61C
02F86:  MOVLB  0
02F88:  CALL   0AF0
02F8C:  MOVFF  5DA,FEA
02F90:  MOVFF  5D9,FE9
02F94:  MOVFF  00,FEF
02F98:  MOVFF  01,FEC
02F9C:  MOVFF  02,FEC
02FA0:  MOVFF  03,FEC
....................    float pTmp = 0;
....................    float polePitch = magPP;
02FA4:  MOVLB  5
02FA6:  CLRF   xD4
02FA8:  CLRF   xD3
02FAA:  CLRF   xD2
02FAC:  CLRF   xD1
02FAE:  CLRF   xD8
02FB0:  CLRF   xD7
02FB2:  CLRF   xD6
02FB4:  MOVLW  7F
02FB6:  MOVWF  xD5
....................    
....................    adcVals[ch].p0 = polePitch * ( 1000 / (2*PI) ) * atan2( (float)adcVals[ch].sinCounts, (float)adcVals[ch].cosCounts );
02FB8:  MOVF   xC8,W
02FBA:  MULLW  19
02FBC:  MOVF   FF3,W
02FBE:  CLRF   xDA
02FC0:  MOVWF  xD9
02FC2:  MOVLW  10
02FC4:  ADDWF  xD9,W
02FC6:  MOVWF  01
02FC8:  MOVLW  00
02FCA:  ADDWFC xDA,W
02FCC:  MOVWF  03
02FCE:  MOVF   01,W
02FD0:  ADDLW  0F
02FD2:  MOVWF  01
02FD4:  MOVLW  01
02FD6:  ADDWFC 03,F
02FD8:  MOVFF  01,5D9
02FDC:  MOVFF  03,5DA
02FE0:  MOVFF  5D8,616
02FE4:  MOVFF  5D7,615
02FE8:  MOVFF  5D6,614
02FEC:  MOVFF  5D5,613
02FF0:  MOVLW  AA
02FF2:  MOVLB  6
02FF4:  MOVWF  x1A
02FF6:  MOVLW  27
02FF8:  MOVWF  x19
02FFA:  MOVLW  1F
02FFC:  MOVWF  x18
02FFE:  MOVLW  86
03000:  MOVWF  x17
03002:  MOVLB  0
03004:  CALL   09FA
03008:  MOVFF  03,5DE
0300C:  MOVFF  02,5DD
03010:  MOVFF  01,5DC
03014:  MOVFF  00,5DB
03018:  MOVLB  5
0301A:  MOVF   xC8,W
0301C:  MULLW  19
0301E:  MOVF   FF3,W
03020:  CLRF   xE0
03022:  MOVWF  xDF
03024:  MOVLW  08
03026:  ADDWF  xDF,W
03028:  MOVWF  01
0302A:  MOVLW  00
0302C:  ADDWFC xE0,W
0302E:  MOVWF  03
03030:  MOVF   01,W
03032:  ADDLW  0F
03034:  MOVWF  FE9
03036:  MOVLW  01
03038:  ADDWFC 03,W
0303A:  MOVWF  FEA
0303C:  MOVFF  FEF,5DF
03040:  MOVFF  FEC,5E0
03044:  MOVFF  FEC,5E1
03048:  MOVFF  FEC,5E2
0304C:  MOVF   xC8,W
0304E:  MULLW  19
03050:  MOVF   FF3,W
03052:  CLRF   xE4
03054:  MOVWF  xE3
03056:  MOVLW  0C
03058:  ADDWF  xE3,W
0305A:  MOVWF  01
0305C:  MOVLW  00
0305E:  ADDWFC xE4,W
03060:  MOVWF  03
03062:  MOVF   01,W
03064:  ADDLW  0F
03066:  MOVWF  FE9
03068:  MOVLW  01
0306A:  ADDWFC 03,W
0306C:  MOVWF  FEA
0306E:  MOVFF  FEF,00
03072:  MOVFF  FEC,01
03076:  MOVFF  FEC,02
0307A:  MOVFF  FEC,03
0307E:  MOVFF  03,5E6
03082:  MOVFF  02,5E5
03086:  MOVFF  01,5E4
0308A:  MOVFF  00,5E3
0308E:  MOVFF  5E2,5EA
03092:  MOVFF  5E1,5E9
03096:  MOVFF  5E0,5E8
0309A:  MOVFF  5DF,5E7
0309E:  MOVFF  03,5EE
030A2:  MOVFF  02,5ED
030A6:  MOVFF  01,5EC
030AA:  MOVFF  00,5EB
030AE:  MOVLB  0
030B0:  GOTO   1A34
030B4:  MOVFF  5DE,616
030B8:  MOVFF  5DD,615
030BC:  MOVFF  5DC,614
030C0:  MOVFF  5DB,613
030C4:  MOVFF  03,61A
030C8:  MOVFF  02,619
030CC:  MOVFF  01,618
030D0:  MOVFF  00,617
030D4:  CALL   09FA
030D8:  MOVFF  5DA,FEA
030DC:  MOVFF  5D9,FE9
030E0:  MOVFF  00,FEF
030E4:  MOVFF  01,FEC
030E8:  MOVFF  02,FEC
030EC:  MOVFF  03,FEC
....................    pTmp = adcVals[ch].p0 + ( polePitch * adcVals[ch].npoles );
030F0:  MOVLB  5
030F2:  MOVF   xC8,W
030F4:  MULLW  19
030F6:  MOVF   FF3,W
030F8:  CLRF   xDA
030FA:  MOVWF  xD9
030FC:  MOVLW  10
030FE:  ADDWF  xD9,W
03100:  MOVWF  01
03102:  MOVLW  00
03104:  ADDWFC xDA,W
03106:  MOVWF  03
03108:  MOVF   01,W
0310A:  ADDLW  0F
0310C:  MOVWF  FE9
0310E:  MOVLW  01
03110:  ADDWFC 03,W
03112:  MOVWF  FEA
03114:  MOVFF  FEF,5D9
03118:  MOVFF  FEC,5DA
0311C:  MOVFF  FEC,5DB
03120:  MOVFF  FEC,5DC
03124:  MOVF   xC8,W
03126:  MULLW  19
03128:  MOVF   FF3,W
0312A:  CLRF   xDE
0312C:  MOVWF  xDD
0312E:  MOVLW  14
03130:  ADDWF  xDD,W
03132:  MOVWF  01
03134:  MOVLW  00
03136:  ADDWFC xDE,W
03138:  MOVWF  03
0313A:  MOVF   01,W
0313C:  ADDLW  0F
0313E:  MOVWF  FE9
03140:  MOVLW  01
03142:  ADDWFC 03,W
03144:  MOVWF  FEA
03146:  MOVF   FEF,W
03148:  MOVLB  6
0314A:  CLRF   x18
0314C:  MOVWF  x17
0314E:  MOVLB  0
03150:  CALL   09C4
03154:  MOVFF  5D8,616
03158:  MOVFF  5D7,615
0315C:  MOVFF  5D6,614
03160:  MOVFF  5D5,613
03164:  MOVFF  03,61A
03168:  MOVFF  02,619
0316C:  MOVFF  01,618
03170:  MOVFF  00,617
03174:  CALL   09FA
03178:  MOVFF  FEA,5DE
0317C:  MOVFF  FE9,5DD
03180:  BCF    FD8.1
03182:  MOVFF  5DC,61A
03186:  MOVFF  5DB,619
0318A:  MOVFF  5DA,618
0318E:  MOVFF  5D9,617
03192:  MOVFF  03,61E
03196:  MOVFF  02,61D
0319A:  MOVFF  01,61C
0319E:  MOVFF  00,61B
031A2:  CALL   0AF0
031A6:  MOVFF  5DE,FEA
031AA:  MOVFF  5DD,FE9
031AE:  MOVFF  03,5D4
031B2:  MOVFF  02,5D3
031B6:  MOVFF  01,5D2
031BA:  MOVFF  00,5D1
....................    
....................    adcVals[ch].pReal = (pow(pTmp*sc[ch].c5,5) + pow(pTmp*sc[ch].c4,4) + pow(pTmp*sc[ch].c3,3) + pow(pTmp*sc[ch].c2,2) + pTmp*sc[ch].c1 + sc[ch].c0);
031BE:  MOVLB  5
031C0:  MOVF   xC8,W
031C2:  MULLW  19
031C4:  MOVF   FF3,W
031C6:  CLRF   xDA
031C8:  MOVWF  xD9
031CA:  MOVLW  15
031CC:  ADDWF  xD9,W
031CE:  MOVWF  01
031D0:  MOVLW  00
031D2:  ADDWFC xDA,W
031D4:  MOVWF  03
031D6:  MOVF   01,W
031D8:  ADDLW  0F
031DA:  MOVWF  01
031DC:  MOVLW  01
031DE:  ADDWFC 03,F
031E0:  MOVFF  01,5D9
031E4:  MOVFF  03,5DA
031E8:  MOVF   xC8,W
031EA:  MULLW  18
031EC:  MOVF   FF3,W
031EE:  CLRF   xDC
031F0:  MOVWF  xDB
031F2:  MOVLW  14
031F4:  ADDWF  xDB,W
031F6:  MOVWF  01
031F8:  MOVLW  00
031FA:  ADDWFC xDC,W
031FC:  MOVWF  03
031FE:  MOVF   01,W
03200:  ADDLW  82
03202:  MOVWF  FE9
03204:  MOVLW  00
03206:  ADDWFC 03,W
03208:  MOVWF  FEA
0320A:  MOVFF  FEF,617
0320E:  MOVFF  FEC,01
03212:  MOVFF  FEC,02
03216:  MOVFF  FEC,03
0321A:  MOVFF  5D4,616
0321E:  MOVFF  5D3,615
03222:  MOVFF  5D2,614
03226:  MOVFF  5D1,613
0322A:  MOVFF  03,61A
0322E:  MOVFF  02,619
03232:  MOVFF  01,618
03236:  MOVLB  0
03238:  CALL   09FA
0323C:  MOVFF  03,5DE
03240:  MOVFF  02,5DD
03244:  MOVFF  01,5DC
03248:  MOVFF  00,5DB
0324C:  MOVFF  03,5EA
03250:  MOVFF  02,5E9
03254:  MOVFF  01,5E8
03258:  MOVFF  00,5E7
0325C:  MOVLB  5
0325E:  CLRF   xEE
03260:  CLRF   xED
03262:  MOVLW  20
03264:  MOVWF  xEC
03266:  MOVLW  81
03268:  MOVWF  xEB
0326A:  MOVLB  0
0326C:  CALL   2A16
03270:  MOVFF  03,5DE
03274:  MOVFF  02,5DD
03278:  MOVFF  01,5DC
0327C:  MOVFF  00,5DB
03280:  MOVLB  5
03282:  MOVF   xC8,W
03284:  MULLW  18
03286:  MOVF   FF3,W
03288:  CLRF   xE0
0328A:  MOVWF  xDF
0328C:  MOVLW  10
0328E:  ADDWF  xDF,W
03290:  MOVWF  01
03292:  MOVLW  00
03294:  ADDWFC xE0,W
03296:  MOVWF  03
03298:  MOVF   01,W
0329A:  ADDLW  82
0329C:  MOVWF  FE9
0329E:  MOVLW  00
032A0:  ADDWFC 03,W
032A2:  MOVWF  FEA
032A4:  MOVFF  FEF,617
032A8:  MOVFF  FEC,01
032AC:  MOVFF  FEC,02
032B0:  MOVFF  FEC,03
032B4:  MOVFF  5D4,616
032B8:  MOVFF  5D3,615
032BC:  MOVFF  5D2,614
032C0:  MOVFF  5D1,613
032C4:  MOVFF  03,61A
032C8:  MOVFF  02,619
032CC:  MOVFF  01,618
032D0:  MOVLB  0
032D2:  CALL   09FA
032D6:  MOVFF  03,5E2
032DA:  MOVFF  02,5E1
032DE:  MOVFF  01,5E0
032E2:  MOVFF  00,5DF
032E6:  MOVFF  03,5EA
032EA:  MOVFF  02,5E9
032EE:  MOVFF  01,5E8
032F2:  MOVFF  00,5E7
032F6:  MOVLB  5
032F8:  CLRF   xEE
032FA:  CLRF   xED
032FC:  CLRF   xEC
032FE:  MOVLW  81
03300:  MOVWF  xEB
03302:  MOVLB  0
03304:  CALL   2A16
03308:  MOVFF  FEA,5E0
0330C:  MOVFF  FE9,5DF
03310:  BCF    FD8.1
03312:  MOVFF  5DE,61A
03316:  MOVFF  5DD,619
0331A:  MOVFF  5DC,618
0331E:  MOVFF  5DB,617
03322:  MOVFF  03,61E
03326:  MOVFF  02,61D
0332A:  MOVFF  01,61C
0332E:  MOVFF  00,61B
03332:  CALL   0AF0
03336:  MOVFF  5E0,FEA
0333A:  MOVFF  5DF,FE9
0333E:  MOVFF  03,5DE
03342:  MOVFF  02,5DD
03346:  MOVFF  01,5DC
0334A:  MOVFF  00,5DB
0334E:  MOVLB  5
03350:  MOVF   xC8,W
03352:  MULLW  18
03354:  MOVF   FF3,W
03356:  CLRF   xE2
03358:  MOVWF  xE1
0335A:  MOVLW  0C
0335C:  ADDWF  xE1,W
0335E:  MOVWF  01
03360:  MOVLW  00
03362:  ADDWFC xE2,W
03364:  MOVWF  03
03366:  MOVF   01,W
03368:  ADDLW  82
0336A:  MOVWF  FE9
0336C:  MOVLW  00
0336E:  ADDWFC 03,W
03370:  MOVWF  FEA
03372:  MOVFF  FEF,617
03376:  MOVFF  FEC,01
0337A:  MOVFF  FEC,02
0337E:  MOVFF  FEC,03
03382:  MOVFF  5D4,616
03386:  MOVFF  5D3,615
0338A:  MOVFF  5D2,614
0338E:  MOVFF  5D1,613
03392:  MOVFF  03,61A
03396:  MOVFF  02,619
0339A:  MOVFF  01,618
0339E:  MOVLB  0
033A0:  CALL   09FA
033A4:  MOVFF  03,5E4
033A8:  MOVFF  02,5E3
033AC:  MOVFF  01,5E2
033B0:  MOVFF  00,5E1
033B4:  MOVFF  03,5EA
033B8:  MOVFF  02,5E9
033BC:  MOVFF  01,5E8
033C0:  MOVFF  00,5E7
033C4:  MOVLB  5
033C6:  CLRF   xEE
033C8:  CLRF   xED
033CA:  MOVLW  40
033CC:  MOVWF  xEC
033CE:  MOVLW  80
033D0:  MOVWF  xEB
033D2:  MOVLB  0
033D4:  CALL   2A16
033D8:  MOVFF  FEA,5E2
033DC:  MOVFF  FE9,5E1
033E0:  BCF    FD8.1
033E2:  MOVFF  5DE,61A
033E6:  MOVFF  5DD,619
033EA:  MOVFF  5DC,618
033EE:  MOVFF  5DB,617
033F2:  MOVFF  03,61E
033F6:  MOVFF  02,61D
033FA:  MOVFF  01,61C
033FE:  MOVFF  00,61B
03402:  CALL   0AF0
03406:  MOVFF  5E2,FEA
0340A:  MOVFF  5E1,FE9
0340E:  MOVFF  03,5DE
03412:  MOVFF  02,5DD
03416:  MOVFF  01,5DC
0341A:  MOVFF  00,5DB
0341E:  MOVLB  5
03420:  MOVF   xC8,W
03422:  MULLW  18
03424:  MOVF   FF3,W
03426:  CLRF   xE4
03428:  MOVWF  xE3
0342A:  MOVLW  08
0342C:  ADDWF  xE3,W
0342E:  MOVWF  01
03430:  MOVLW  00
03432:  ADDWFC xE4,W
03434:  MOVWF  03
03436:  MOVF   01,W
03438:  ADDLW  82
0343A:  MOVWF  FE9
0343C:  MOVLW  00
0343E:  ADDWFC 03,W
03440:  MOVWF  FEA
03442:  MOVFF  FEF,617
03446:  MOVFF  FEC,01
0344A:  MOVFF  FEC,02
0344E:  MOVFF  FEC,03
03452:  MOVFF  5D4,616
03456:  MOVFF  5D3,615
0345A:  MOVFF  5D2,614
0345E:  MOVFF  5D1,613
03462:  MOVFF  03,61A
03466:  MOVFF  02,619
0346A:  MOVFF  01,618
0346E:  MOVLB  0
03470:  CALL   09FA
03474:  MOVFF  03,5E6
03478:  MOVFF  02,5E5
0347C:  MOVFF  01,5E4
03480:  MOVFF  00,5E3
03484:  MOVFF  03,5EA
03488:  MOVFF  02,5E9
0348C:  MOVFF  01,5E8
03490:  MOVFF  00,5E7
03494:  MOVLB  5
03496:  CLRF   xEE
03498:  CLRF   xED
0349A:  CLRF   xEC
0349C:  MOVLW  80
0349E:  MOVWF  xEB
034A0:  MOVLB  0
034A2:  CALL   2A16
034A6:  MOVFF  FEA,5E4
034AA:  MOVFF  FE9,5E3
034AE:  BCF    FD8.1
034B0:  MOVFF  5DE,61A
034B4:  MOVFF  5DD,619
034B8:  MOVFF  5DC,618
034BC:  MOVFF  5DB,617
034C0:  MOVFF  03,61E
034C4:  MOVFF  02,61D
034C8:  MOVFF  01,61C
034CC:  MOVFF  00,61B
034D0:  CALL   0AF0
034D4:  MOVFF  5E4,FEA
034D8:  MOVFF  5E3,FE9
034DC:  MOVFF  03,5DE
034E0:  MOVFF  02,5DD
034E4:  MOVFF  01,5DC
034E8:  MOVFF  00,5DB
034EC:  MOVLB  5
034EE:  MOVF   xC8,W
034F0:  MULLW  18
034F2:  MOVF   FF3,W
034F4:  CLRF   xE6
034F6:  MOVWF  xE5
034F8:  MOVLW  04
034FA:  ADDWF  xE5,W
034FC:  MOVWF  01
034FE:  MOVLW  00
03500:  ADDWFC xE6,W
03502:  MOVWF  03
03504:  MOVF   01,W
03506:  ADDLW  82
03508:  MOVWF  FE9
0350A:  MOVLW  00
0350C:  ADDWFC 03,W
0350E:  MOVWF  FEA
03510:  MOVFF  FEF,617
03514:  MOVFF  FEC,01
03518:  MOVFF  FEC,02
0351C:  MOVFF  FEC,03
03520:  MOVFF  5D4,616
03524:  MOVFF  5D3,615
03528:  MOVFF  5D2,614
0352C:  MOVFF  5D1,613
03530:  MOVFF  03,61A
03534:  MOVFF  02,619
03538:  MOVFF  01,618
0353C:  MOVLB  0
0353E:  CALL   09FA
03542:  MOVFF  FEA,5E6
03546:  MOVFF  FE9,5E5
0354A:  BCF    FD8.1
0354C:  MOVFF  5DE,61A
03550:  MOVFF  5DD,619
03554:  MOVFF  5DC,618
03558:  MOVFF  5DB,617
0355C:  MOVFF  03,61E
03560:  MOVFF  02,61D
03564:  MOVFF  01,61C
03568:  MOVFF  00,61B
0356C:  CALL   0AF0
03570:  MOVFF  5E6,FEA
03574:  MOVFF  5E5,FE9
03578:  MOVFF  03,61A
0357C:  MOVFF  02,619
03580:  MOVFF  01,618
03584:  MOVFF  00,617
03588:  MOVLB  5
0358A:  MOVF   xC8,W
0358C:  MULLW  18
0358E:  MOVF   FF3,W
03590:  CLRF   xE8
03592:  MOVWF  xE7
03594:  MOVLW  82
03596:  ADDWF  xE7,W
03598:  MOVWF  FE9
0359A:  MOVLW  00
0359C:  ADDWFC xE8,W
0359E:  MOVWF  FEA
035A0:  MOVFF  FEF,61B
035A4:  MOVFF  FEC,01
035A8:  MOVFF  FEC,02
035AC:  MOVFF  FEC,03
035B0:  BCF    FD8.1
035B2:  MOVFF  03,61E
035B6:  MOVFF  02,61D
035BA:  MOVFF  01,61C
035BE:  MOVLB  0
035C0:  CALL   0AF0
035C4:  MOVFF  5DA,FEA
035C8:  MOVFF  5D9,FE9
035CC:  MOVFF  00,FEF
035D0:  MOVFF  01,FEC
035D4:  MOVFF  02,FEC
035D8:  MOVFF  03,FEC
....................    
....................    PID[ch].PVold = PID[ch].PV;
035DC:  MOVLB  5
035DE:  MOVF   xC8,W
035E0:  MULLW  20
035E2:  MOVF   FF3,W
035E4:  CLRF   xDA
035E6:  MOVWF  xD9
035E8:  MOVLW  14
035EA:  ADDWF  xD9,W
035EC:  MOVWF  01
035EE:  MOVLW  00
035F0:  ADDWFC xDA,W
035F2:  MOVWF  03
035F4:  MOVF   01,W
035F6:  ADDLW  20
035F8:  MOVWF  01
035FA:  MOVLW  00
035FC:  ADDWFC 03,F
035FE:  MOVFF  01,5D9
03602:  MOVFF  03,5DA
03606:  MOVF   xC8,W
03608:  MULLW  20
0360A:  MOVF   FF3,W
0360C:  CLRF   xDC
0360E:  MOVWF  xDB
03610:  MOVLW  10
03612:  ADDWF  xDB,W
03614:  MOVWF  01
03616:  MOVLW  00
03618:  ADDWFC xDC,W
0361A:  MOVWF  03
0361C:  MOVF   01,W
0361E:  ADDLW  20
03620:  MOVWF  FE9
03622:  MOVLW  00
03624:  ADDWFC 03,W
03626:  MOVWF  FEA
03628:  MOVFF  FEF,00
0362C:  MOVFF  FEC,01
03630:  MOVFF  FEC,02
03634:  MOVFF  FEC,03
03638:  MOVFF  5DA,FEA
0363C:  MOVFF  5D9,FE9
03640:  MOVFF  00,FEF
03644:  MOVFF  01,FEC
03648:  MOVFF  02,FEC
0364C:  MOVFF  03,FEC
....................    PID[ch].PV = adcVals[ch].pReal;
03650:  MOVF   xC8,W
03652:  MULLW  20
03654:  MOVF   FF3,W
03656:  CLRF   xDA
03658:  MOVWF  xD9
0365A:  MOVLW  10
0365C:  ADDWF  xD9,W
0365E:  MOVWF  01
03660:  MOVLW  00
03662:  ADDWFC xDA,W
03664:  MOVWF  03
03666:  MOVF   01,W
03668:  ADDLW  20
0366A:  MOVWF  01
0366C:  MOVLW  00
0366E:  ADDWFC 03,F
03670:  MOVFF  01,5D9
03674:  MOVFF  03,5DA
03678:  MOVF   xC8,W
0367A:  MULLW  19
0367C:  MOVF   FF3,W
0367E:  CLRF   xDC
03680:  MOVWF  xDB
03682:  MOVLW  15
03684:  ADDWF  xDB,W
03686:  MOVWF  01
03688:  MOVLW  00
0368A:  ADDWFC xDC,W
0368C:  MOVWF  03
0368E:  MOVF   01,W
03690:  ADDLW  0F
03692:  MOVWF  FE9
03694:  MOVLW  01
03696:  ADDWFC 03,W
03698:  MOVWF  FEA
0369A:  MOVFF  FEF,00
0369E:  MOVFF  FEC,01
036A2:  MOVFF  FEC,02
036A6:  MOVFF  FEC,03
036AA:  MOVFF  5DA,FEA
036AE:  MOVFF  5D9,FE9
036B2:  MOVFF  00,FEF
036B6:  MOVFF  01,FEC
036BA:  MOVFF  02,FEC
036BE:  MOVFF  03,FEC
036C2:  MOVLB  0
036C4:  GOTO   37A0 (RETURN)
.................... }  
.................... 
.................... /*****************************************************************************/
.................... /* SENSOR MONITOR INTERRUPT TASK                                             */
.................... /* starts conversion of the other two ADCs                                   */
.................... /*****************************************************************************/
.................... void sensor_monitor_interrupt_task()
.................... {
....................    if (!smData.adcBusy)
*
001E0:  MOVLB  1
001E2:  BTFSC  x4F.1
001E4:  BRA    0218
....................    {
....................       smData.adcBusy = true;
001E6:  BSF    x4F.1
....................       switch (smData.channel)
001E8:  MOVF   x50,W
001EA:  XORLW  00
001EC:  MOVLB  0
001EE:  BZ    01F6
001F0:  XORLW  01
001F2:  BZ    0206
001F4:  BRA    0212
....................       {
....................          case 0:
....................             ads_write_command_block(1, ADSstart);
001F6:  MOVLW  01
001F8:  MOVLB  6
001FA:  MOVWF  x27
001FC:  MOVLW  08
001FE:  MOVWF  x28
00200:  MOVLB  0
00202:  RCALL  01C8
....................          break;
00204:  BRA    0212
....................          
....................          case 1:
....................             ads_write_command_block(0, ADSstart);
00206:  MOVLB  6
00208:  CLRF   x27
0020A:  MOVLW  08
0020C:  MOVWF  x28
0020E:  MOVLB  0
00210:  RCALL  01C8
....................          break;
....................       }
....................       smData.adcBusy = false;
00212:  MOVLB  1
00214:  BCF    x4F.1
....................       smData.dataReady = true;
00216:  BSF    x4F.0
....................    }
00218:  MOVLB  0
0021A:  GOTO   02DC (RETURN)
.................... }
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* SENSOR MONITOR task - gets magnetoresistive sensor counts                 */
.................... /* gets two values each time the task is run                                  */
.................... /*****************************************************************************/
.................... void sensor_monitor_task()
.................... {
....................    if (smData.dataReady)
*
036C8:  MOVLB  1
036CA:  BTFSS  x4F.0
036CC:  BRA    37A2
....................    {
....................       unsigned int32 sinRaw=0;
....................       unsigned int32 cosRaw=0;
....................       int8 ch=0;
036CE:  MOVLB  5
036D0:  CLRF   xC2
036D2:  CLRF   xC1
036D4:  CLRF   xC0
036D6:  CLRF   xBF
036D8:  CLRF   xC6
036DA:  CLRF   xC5
036DC:  CLRF   xC4
036DE:  CLRF   xC3
036E0:  CLRF   xC7
....................       
....................       smData.adcBusy = true;
036E2:  MOVLB  1
036E4:  BSF    x4F.1
....................       switch (smData.channel)
036E6:  MOVF   x50,W
036E8:  XORLW  00
036EA:  MOVLB  0
036EC:  BZ    36F0
036EE:  BRA    3732
....................       {
....................          case 0:
....................             ch = 0;
036F0:  MOVLB  5
036F2:  CLRF   xC7
....................             sinRaw = ads_read_data(0);
036F4:  CLRF   xC8
036F6:  MOVLB  0
036F8:  CALL   12AE
036FC:  MOVFF  03,5C2
03700:  MOVFF  02,5C1
03704:  MOVFF  01,5C0
03708:  MOVFF  00,5BF
....................             cosRaw = ads_read_data(1);
0370C:  MOVLW  01
0370E:  MOVLB  5
03710:  MOVWF  xC8
03712:  MOVLB  0
03714:  CALL   12AE
03718:  MOVFF  03,5C6
0371C:  MOVFF  02,5C5
03720:  MOVFF  01,5C4
03724:  MOVFF  00,5C3
....................             smData.channel = 1;
03728:  MOVLW  01
0372A:  MOVLB  1
0372C:  MOVWF  x50
....................          break;
0372E:  BRA    3772
03730:  MOVLB  0
....................          
....................          default:
....................             ch = 1;
03732:  MOVLW  01
03734:  MOVLB  5
03736:  MOVWF  xC7
....................             sinRaw = ads_read_data(2);
03738:  MOVLW  02
0373A:  MOVWF  xC8
0373C:  MOVLB  0
0373E:  CALL   12AE
03742:  MOVFF  03,5C2
03746:  MOVFF  02,5C1
0374A:  MOVFF  01,5C0
0374E:  MOVFF  00,5BF
....................             cosRaw = ads_read_data(3);
03752:  MOVLW  03
03754:  MOVLB  5
03756:  MOVWF  xC8
03758:  MOVLB  0
0375A:  CALL   12AE
0375E:  MOVFF  03,5C6
03762:  MOVFF  02,5C5
03766:  MOVFF  01,5C4
0376A:  MOVFF  00,5C3
....................             smData.channel = 0;
0376E:  MOVLB  1
03770:  CLRF   x50
....................          break;
....................       }
....................       smData.adcBusy = false;
03772:  BCF    x4F.1
....................       smData.dataReady = false;
03774:  BCF    x4F.0
....................       sensor_process_data(ch, sinRaw, cosRaw);
03776:  MOVFF  5C7,5C8
0377A:  MOVFF  5C2,5CC
0377E:  MOVFF  5C1,5CB
03782:  MOVFF  5C0,5CA
03786:  MOVFF  5BF,5C9
0378A:  MOVFF  5C6,5D0
0378E:  MOVFF  5C5,5CF
03792:  MOVFF  5C4,5CE
03796:  MOVFF  5C3,5CD
0379A:  MOVLB  0
0379C:  GOTO   2D14
037A0:  MOVLB  1
....................    }
037A2:  MOVLB  0
037A4:  GOTO   6ACC (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* INITIALIZE ADC's                                                          */
.................... /*****************************************************************************/
.................... void setup_external_ADCs()
*
0071A:  MOVLB  5
0071C:  CLRF   xBF
0071E:  CLRF   xC0
00720:  CLRF   xC1
00722:  CLRF   xC2
.................... {
....................    unsigned int8 rc0=0;
....................    unsigned int8 rc1=0;
....................    unsigned int8 rc2=0;
....................    unsigned int8 rc3=0;
....................    
....................    for(int ch = 0; ch < 4; ch++)
00724:  CLRF   xC3
00726:  MOVF   xC3,W
00728:  SUBLW  03
0072A:  BNC   0758
....................    {
....................       switch (magPP)
....................       {         
....................          case 1:
....................             rc0=KMXP1000reg0config;
0072C:  MOVLW  38
0072E:  MOVWF  xBF
....................             rc1=KMXP1000reg1config;
00730:  MOVLW  10
00732:  MOVWF  xC0
....................             rc2=KMXP1000reg2config;
00734:  MOVLW  30
00736:  MOVWF  xC1
....................             rc3=KMXP1000reg3config;
00738:  CLRF   xC2
....................          break;
....................          
....................          case 2:
....................             rc0=KMXP2000reg0config;
....................             rc1=KMXP2000reg1config;
....................             rc2=KMXP2000reg2config;
....................             rc3=KMXP2000reg3config;
....................          break;
....................          
....................          default:
....................             rc0=reg0config;
....................             rc1=reg1config;
....................             rc2=reg2config;
....................             rc3=reg3config;      
....................          break;
....................       }
....................       ADS1220init(ch, rc0, rc1, rc2, rc3);
0073A:  MOVFF  5C3,5C4
0073E:  MOVFF  5BF,5C5
00742:  MOVFF  5C0,5C6
00746:  MOVFF  5C1,5C7
0074A:  MOVFF  5C2,5C8
0074E:  MOVLB  0
00750:  BRA    06B8
00752:  MOVLB  5
00754:  INCF   xC3,F
00756:  BRA    0726
....................    }   
00758:  MOVLB  0
0075A:  GOTO   07BE (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE MONITOR -- sets up ADC channels                                */
.................... /*****************************************************************************/
.................... void monitor_init()
.................... {
....................    setup_adc_ports(sAN6 | sAN16 | sAN17 | sAN24 | sAN25 | sAN26 | sAN27, NO_ANALOGS_P2, VSS_VDD);
0075E:  MOVLW  00
00760:  MOVLB  F
00762:  MOVWF  x53
00764:  MOVLW  40
00766:  MOVWF  x0C
00768:  MOVLW  00
0076A:  MOVWF  x14
0076C:  MOVLW  03
0076E:  MOVWF  x1C
00770:  MOVLW  0F
00772:  MOVWF  x21
00774:  MOVLW  00
00776:  MOVWF  x29
....................    setup_adc(ADC_CLOCK_INTERNAL | ADC_TAD_MUL_255 | ADC_LEGACY_MODE | ADC_THRESHOLD_INT_DISABLED);
00778:  MOVLW  08
0077A:  MOVWF  x55
0077C:  CLRF   x56
0077E:  CLRF   x52
00780:  SETF   x57
00782:  CLRF   F61
00784:  MOVLW  94
00786:  MOVWF  x5B
....................    output_high(EN_EXC);
00788:  MOVLW  E8
0078A:  MOVWF  F8B
0078C:  BSF    F86.0
....................    set_adc_channel(vMonN15); // internal MUX
0078E:  MOVF   x5A,W
00790:  ANDLW  3F
00792:  MOVWF  01
00794:  MOVLW  06
00796:  MOVWF  x5A
00798:  BTFSS  x5B.7
0079A:  BRA    07AA
0079C:  MOVF   01,W
0079E:  SUBLW  06
007A0:  BZ    07AA
007A2:  BSF    x5B.0
007A4:  NOP   
007A6:  BTFSC  x5B.0
007A8:  BRA    07A6
....................    delay_ms(10);
007AA:  MOVLW  0A
007AC:  MOVLB  5
007AE:  MOVWF  xC0
007B0:  MOVLB  0
007B2:  RCALL  03AC
....................    read_adc(ADC_START_ONLY);
007B4:  MOVLB  F
007B6:  BSF    x5B.0
007B8:  NOP   
....................    setup_external_ADCs();
007BA:  MOVLB  0
007BC:  BRA    071A
....................    intTimeoutReg = sensorSampleRate;
007BE:  MOVLB  1
007C0:  CLRF   x4E
007C2:  MOVLW  32
007C4:  MOVWF  x4D
007C6:  MOVLB  0
007C8:  GOTO   6AB8 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... //!#include <control.h>
.................... #include <serialport.h>
.................... #ifndef serialPort
.................... #define serialPort
.................... #include <cmdBuffer.h>
.................... #ifndef cmd_buffer
.................... #define cmd_buffer
.................... 
.................... /*****************************************************************************/
.................... /* DIFCS COMMAND BUFFER                                                      */
.................... /* The beginning of a message is signified by an address record. The address */
.................... /* is 4 characters. The first 2 are the hardware identifier (TC - temperature*/
.................... /* controller, DC - difics controller, etc..) The second 2 characters dev-   */
.................... /* ice ID... Valid values are 00 thru 0F. A device ID of FF writes to all    */
.................... /* boards. This might be used to feed angles data to all listeners.          */
.................... /*****************************************************************************/
.................... 
.................... // t,p0,p1,p2,p3,p4,p5,p6
.................... // t is the start character, p0 is the address, p1 is command, p2-6 are params
.................... // these characters used for storing messages
.................... 
.................... #define startChr '~' // start character. Also diagnostic command type
.................... #define diagCmdType startChr
.................... #define endChr '\n'
.................... #define delimiter ','
.................... #define ignoreChr1 '\r'
.................... #define ignoreChr2 ' '
.................... #define noRecordFound (char)0xFF
.................... 
.................... #define numRecords 4
.................... #define numParam 7
.................... #define lenParam 25
.................... 
.................... #define useSerial
.................... //#define useTCPIP
.................... 
.................... typedef enum cmdMode {tcp, ser};
.................... 
.................... // this structure holds a command. This is used by the serial routine as well
.................... // as the TCP routine to store an incoming command + parameters
.................... // in the case of TCP socket id is also passed in this structure
.................... typedef struct cmd 
.................... {
....................    BOOLEAN full;        // if full, command is ready to execute
....................    unsigned int8 chrIndex;
....................    unsigned int8 paramIndex;
....................    unsigned int8 recReadIndex;
....................    unsigned int8 recWriteIndex;
....................    #ifdef useTCPIP
....................    TCP_SOCKET s;              // socket ID for TCP commands 
....................    #endif
....................    char t;
....................    char p[numParam][lenParam];   // only used with ~ type command
.................... };
.................... 
.................... #ifdef useSerial
.................... struct cmd SERcmd[numRecords]; // holds serial command 
.................... unsigned int8 SRI = 0; //usb readindex
.................... unsigned int8 SWI = 0; //usb write index
.................... #endif
.................... 
.................... #ifdef useTCPIP
.................... struct cmd TCPcmd[numRecords]; // holds TCP command
.................... unsigned int8 TRI = 0; //usb readindex
.................... unsigned int8 TWI = 0; //usb write index
.................... #endif
.................... 
.................... char retData[100]; // this is used to hold return data 
.................... 
.................... #ifdef useSerial
.................... /*****************************************************************************/
.................... /* RESET SER COMMAND -- ready for a new command                              */
.................... /*****************************************************************************/
.................... void resetSERcmd(unsigned int8 recNum)
.................... {
....................    if (recNum < numRecords)
*
007EE:  MOVLB  5
007F0:  MOVF   xC0,W
007F2:  SUBLW  03
007F4:  BTFSS  FD8.0
007F6:  BRA    0964
....................    {
....................       for (int i = 0; i <numParam; i ++)
007F8:  CLRF   xC1
007FA:  MOVF   xC1,W
007FC:  SUBLW  06
007FE:  BNC   084E
....................       {
....................          SERcmd[recNum].p[i][0] = '\0';
00800:  CLRF   xE3
00802:  MOVFF  5C0,5E2
00806:  CLRF   xE5
00808:  MOVLW  B5
0080A:  MOVWF  xE4
0080C:  MOVLB  0
0080E:  RCALL  07CC
00810:  MOVFF  02,5C3
00814:  MOVFF  01,5C2
00818:  MOVLW  06
0081A:  MOVLB  5
0081C:  ADDWF  xC2,F
0081E:  MOVLW  00
00820:  ADDWFC xC3,F
00822:  CLRF   xE3
00824:  MOVFF  5C1,5E2
00828:  CLRF   xE5
0082A:  MOVLW  19
0082C:  MOVWF  xE4
0082E:  MOVLB  0
00830:  RCALL  07CC
00832:  MOVF   01,W
00834:  MOVLB  5
00836:  ADDWF  xC2,F
00838:  MOVF   02,W
0083A:  ADDWFC xC3,F
0083C:  MOVLW  52
0083E:  ADDWF  xC2,W
00840:  MOVWF  FE9
00842:  MOVLW  01
00844:  ADDWFC xC3,W
00846:  MOVWF  FEA
00848:  CLRF   FEF
0084A:  INCF   xC1,F
0084C:  BRA    07FA
....................       }
....................       SERcmd[recNum].t = 0;
0084E:  CLRF   xE3
00850:  MOVFF  5C0,5E2
00854:  CLRF   xE5
00856:  MOVLW  B5
00858:  MOVWF  xE4
0085A:  MOVLB  0
0085C:  RCALL  07CC
0085E:  MOVFF  01,5C2
00862:  MOVLW  05
00864:  MOVLB  5
00866:  ADDWF  01,W
00868:  MOVWF  01
0086A:  MOVLW  00
0086C:  ADDWFC 02,W
0086E:  MOVWF  03
00870:  MOVF   01,W
00872:  ADDLW  52
00874:  MOVWF  FE9
00876:  MOVLW  01
00878:  ADDWFC 03,W
0087A:  MOVWF  FEA
0087C:  CLRF   FEF
....................       SERcmd[recNum].chrIndex = 0;
0087E:  CLRF   xE3
00880:  MOVFF  5C0,5E2
00884:  CLRF   xE5
00886:  MOVLW  B5
00888:  MOVWF  xE4
0088A:  MOVLB  0
0088C:  RCALL  07CC
0088E:  MOVFF  01,5C2
00892:  MOVLW  01
00894:  MOVLB  5
00896:  ADDWF  01,W
00898:  MOVWF  01
0089A:  MOVLW  00
0089C:  ADDWFC 02,W
0089E:  MOVWF  03
008A0:  MOVF   01,W
008A2:  ADDLW  52
008A4:  MOVWF  FE9
008A6:  MOVLW  01
008A8:  ADDWFC 03,W
008AA:  MOVWF  FEA
008AC:  CLRF   FEF
....................       SERcmd[recNum].paramIndex = 0;
008AE:  CLRF   xE3
008B0:  MOVFF  5C0,5E2
008B4:  CLRF   xE5
008B6:  MOVLW  B5
008B8:  MOVWF  xE4
008BA:  MOVLB  0
008BC:  RCALL  07CC
008BE:  MOVFF  01,5C2
008C2:  MOVLW  02
008C4:  MOVLB  5
008C6:  ADDWF  01,W
008C8:  MOVWF  01
008CA:  MOVLW  00
008CC:  ADDWFC 02,W
008CE:  MOVWF  03
008D0:  MOVF   01,W
008D2:  ADDLW  52
008D4:  MOVWF  FE9
008D6:  MOVLW  01
008D8:  ADDWFC 03,W
008DA:  MOVWF  FEA
008DC:  CLRF   FEF
....................       SERcmd[recNum].recReadIndex = 0;
008DE:  CLRF   xE3
008E0:  MOVFF  5C0,5E2
008E4:  CLRF   xE5
008E6:  MOVLW  B5
008E8:  MOVWF  xE4
008EA:  MOVLB  0
008EC:  RCALL  07CC
008EE:  MOVFF  01,5C2
008F2:  MOVLW  03
008F4:  MOVLB  5
008F6:  ADDWF  01,W
008F8:  MOVWF  01
008FA:  MOVLW  00
008FC:  ADDWFC 02,W
008FE:  MOVWF  03
00900:  MOVF   01,W
00902:  ADDLW  52
00904:  MOVWF  FE9
00906:  MOVLW  01
00908:  ADDWFC 03,W
0090A:  MOVWF  FEA
0090C:  CLRF   FEF
....................       SERcmd[recNum].recWriteIndex = 0;
0090E:  CLRF   xE3
00910:  MOVFF  5C0,5E2
00914:  CLRF   xE5
00916:  MOVLW  B5
00918:  MOVWF  xE4
0091A:  MOVLB  0
0091C:  RCALL  07CC
0091E:  MOVFF  01,5C2
00922:  MOVLW  04
00924:  MOVLB  5
00926:  ADDWF  01,W
00928:  MOVWF  01
0092A:  MOVLW  00
0092C:  ADDWFC 02,W
0092E:  MOVWF  03
00930:  MOVF   01,W
00932:  ADDLW  52
00934:  MOVWF  FE9
00936:  MOVLW  01
00938:  ADDWFC 03,W
0093A:  MOVWF  FEA
0093C:  CLRF   FEF
....................       SERcmd[recNum].full = FALSE;
0093E:  CLRF   xE3
00940:  MOVFF  5C0,5E2
00944:  CLRF   xE5
00946:  MOVLW  B5
00948:  MOVWF  xE4
0094A:  MOVLB  0
0094C:  RCALL  07CC
0094E:  MOVLW  52
00950:  MOVLB  5
00952:  ADDWF  01,W
00954:  MOVWF  FE9
00956:  MOVLW  01
00958:  ADDWFC 02,W
0095A:  MOVWF  FEA
0095C:  BCF    FEF.0
....................       retData[0] = '\0';
0095E:  MOVLB  4
00960:  CLRF   x28
00962:  MOVLB  5
....................    }
00964:  MOVLB  0
00966:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next serial read index (SRI)                                          */
.................... /*****************************************************************************/
.................... BOOLEAN getNextSERReadIndex()
.................... {
....................    while (!SERcmd[SRI].full)
*
03D32:  MOVLB  5
03D34:  CLRF   xE3
03D36:  MOVFF  426,5E2
03D3A:  CLRF   xE5
03D3C:  MOVLW  B5
03D3E:  MOVWF  xE4
03D40:  MOVLB  0
03D42:  CALL   07CC
03D46:  MOVFF  02,5C1
03D4A:  MOVFF  01,5C0
03D4E:  MOVLW  52
03D50:  MOVLB  5
03D52:  ADDWF  01,W
03D54:  MOVWF  FE9
03D56:  MOVLW  01
03D58:  ADDWFC 02,W
03D5A:  MOVWF  FEA
03D5C:  BTFSC  FEF.0
03D5E:  BRA    3D80
....................    {
....................       if (SRI == SWI) return FALSE;
03D60:  MOVLB  4
03D62:  MOVF   x27,W
03D64:  SUBWF  x26,W
03D66:  BNZ   3D6E
03D68:  MOVLW  00
03D6A:  MOVWF  01
03D6C:  BRA    3D86
....................       SRI +=1;
03D6E:  MOVLW  01
03D70:  ADDWF  x26,F
....................       if (SRI >= numRecords) SRI=0;
03D72:  MOVF   x26,W
03D74:  SUBLW  03
03D76:  BC    3D7A
03D78:  CLRF   x26
03D7A:  MOVLB  0
03D7C:  BRA    3D32
03D7E:  MOVLB  5
....................    }
....................    return TRUE;
03D80:  MOVLW  01
03D82:  MOVWF  01
03D84:  MOVLB  4
03D86:  MOVLB  0
03D88:  GOTO   66B8 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next serial write index (SWI)                                         */
.................... /*****************************************************************************/
.................... void setNextSERWriteIndex()
.................... {
....................    SWI +=1;
*
037DC:  MOVLW  01
037DE:  MOVLB  4
037E0:  ADDWF  x27,F
....................    if (SWI >= numRecords) SWI=0;
037E2:  MOVF   x27,W
037E4:  SUBLW  03
037E6:  BC    37EA
037E8:  CLRF   x27
037EA:  MOVLB  0
037EC:  RETURN 0
.................... }
.................... #endif
.................... 
.................... #ifdef useTCPIP
.................... /*****************************************************************************/
.................... /* RESET TCP COMMAND -- ready for a new command                              */
.................... /*****************************************************************************/
.................... void resetTCPcmd(unsigned int8 recNum)
.................... {
....................    if(recNum < numRecords)
....................    {
....................       for (int i = 0; i <numParam; i ++)
....................       {
....................          TCPcmd[recNum].p[i][0] = '\0';
....................       }
....................       TCPcmd[recNum].t = 0;
....................       TCPcmd[recNum].chrIndex = 0;
....................       TCPcmd[recNum].paramIndex = 0;
....................       TCPcmd[recNum].full = FALSE;
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next TCP read index (TRI)                                             */
.................... /*****************************************************************************/
.................... BOOLEAN getNextTCPReadIndex()
.................... {
....................    while (!TCPcmd[TRI].full)
....................    {
....................       if (TRI == TWI) return FALSE;
....................       TRI +=1;
....................       if (TRI >= numRecords) TRI=0;
....................    }
....................    return TRUE;
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next TCP write index (TWI)                                            */
.................... /*****************************************************************************/
.................... void setNextTCPWriteIndex()
.................... {
....................    TWI +=1;
....................    if (TWI >= numRecords) TWI=0;
.................... }
.................... #endif
.................... #endif
.................... 
.................... 
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define _LE          PIN_B4
.................... #define CLR          PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
....................    output_b(portB_reset);
....................    output_c(portC_reset);
....................    output_d(portD_reset);
....................    output_e(portE_reset);
....................    
....................    port_a_pullups(portA_pullups);
....................    port_b_pullups(portB_pullups);
....................    port_c_pullups(portC_pullups);
....................    port_d_pullups(portD_pullups);
....................    port_e_pullups(portE_pullups);
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... #define use_RS485 // adds RX enable pin//
.................... 
.................... #define oneByteCmdTestValue 128
.................... #define UART_BUFFER_SIZE 60
.................... #define UART_EOT_CHAR1 0x0D //Carriage Return
.................... #define UART_EOT_CHAR2 0x0A //Line Feed
.................... #define UART_SOT_CHAR  '~' // START CHARACTER
.................... #define line_turnaround_char 0xFF
.................... 
.................... #bit UART_TXBuffer_Empty = 0x0FAC.1
.................... 
.................... char UART_BUFFER[UART_BUFFER_SIZE] = {0};
.................... unsigned int8 UART_WR_PTR = 0;
.................... unsigned int8 UART_RD_PTR = 0;
.................... boolean BYTES_AVAILABLE= FALSE;
.................... 
.................... #ifdef use_RS485
.................... #use rs232(baud=baudRate, xmit=TX_PIN, rcv=RX_PIN, enable=TX_ENABLE, stream=SERIAL, ERRORS)
*
000CA:  MOVLB  E
000CC:  BTFSS  xC8.5
000CE:  BRA    00CC
000D0:  MOVFF  F9C,4CB
000D4:  MOVLB  4
000D6:  MOVFF  F98,01
000DA:  BTFSS  xCB.1
000DC:  BRA    00E2
000DE:  BCF    F9C.4
000E0:  BSF    F9C.4
000E2:  MOVLB  0
000E4:  GOTO   010C (RETURN)
*
037EE:  MOVLW  93
037F0:  MOVWF  F89
037F2:  BSF    F84.5
037F4:  MOVLB  E
037F6:  BTFSS  xC8.4
037F8:  BRA    37F6
037FA:  MOVLW  93
037FC:  MOVWF  F89
037FE:  BSF    F84.5
03800:  MOVLB  5
03802:  MOVFF  5C6,F99
03806:  NOP   
03808:  BTFSS  F9D.1
0380A:  BRA    3808
0380C:  MOVLW  93
0380E:  MOVWF  F89
03810:  BCF    F84.5
03812:  MOVLB  0
03814:  RETURN 0
.................... #else
.................... #use rs232(baud=baudRate, xmit=TX_PIN, rcv=RX_PIN, stream=SERIAL)
.................... #endif
.................... 
.................... // Message format: [SOT]addr ,cmd, arg1, arg2, arg3[EOT]} 
.................... // arguments are optional
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* SERIAL PORT ISR                                                           */
.................... /*****************************************************************************/
.................... #INT_RDA
.................... void RX_isr()
*
000E8:  MOVLB  0
.................... {
....................    while (kbhit())
000EA:  MOVLB  E
000EC:  BTFSS  xC8.5
000EE:  BRA    012E
....................    {
....................       UART_BUFFER[UART_WR_PTR]=getch();
000F0:  CLRF   03
000F2:  MOVLB  4
000F4:  MOVF   xC8,W
000F6:  ADDLW  8C
000F8:  MOVWF  FE9
000FA:  MOVLW  04
000FC:  ADDWFC 03,W
000FE:  MOVWF  FEA
00100:  MOVFF  FEA,62A
00104:  MOVFF  FE9,629
00108:  MOVLB  0
0010A:  BRA    00CA
0010C:  MOVFF  62A,FEA
00110:  MOVFF  629,FE9
00114:  MOVFF  01,FEF
....................       UART_WR_PTR +=1;
00118:  MOVLW  01
0011A:  MOVLB  4
0011C:  ADDWF  xC8,F
....................       if (UART_WR_PTR>=UART_BUFFER_SIZE) UART_WR_PTR=0;
0011E:  MOVF   xC8,W
00120:  SUBLW  3B
00122:  BC    0126
00124:  CLRF   xC8
....................       BYTES_AVAILABLE=TRUE;
00126:  BSF    xCA.0
00128:  MOVLB  0
0012A:  BRA    00EA
0012C:  MOVLB  E
....................    }
0012E:  BCF    xC8.5
00130:  MOVLB  0
00132:  GOTO   006E
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get character from buffer                                                 */
.................... /*****************************************************************************/
.................... char getchFromBuffer()
*
037A8:  CLRF   03
037AA:  MOVLB  4
037AC:  MOVF   xC9,W
037AE:  ADDLW  8C
037B0:  MOVWF  FE9
037B2:  MOVLW  04
037B4:  ADDWFC 03,W
037B6:  MOVWF  FEA
037B8:  MOVFF  FEF,5C0
.................... {
....................    char data = UART_BUFFER[UART_RD_PTR];
....................    UART_RD_PTR +=1;
037BC:  MOVLW  01
037BE:  ADDWF  xC9,F
....................    if (UART_RD_PTR>=UART_BUFFER_SIZE) UART_RD_PTR=0;
037C0:  MOVF   xC9,W
037C2:  SUBLW  3B
037C4:  BC    37C8
037C6:  CLRF   xC9
....................    if (UART_RD_PTR == UART_WR_PTR) BYTES_AVAILABLE=FALSE;
037C8:  MOVF   xC8,W
037CA:  SUBWF  xC9,W
037CC:  BNZ   37D0
037CE:  BCF    xCA.0
....................    return data;
037D0:  MOVLB  5
037D2:  MOVFF  5C0,01
037D6:  MOVLB  0
037D8:  GOTO   387C (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Serial Task transfers bytes to command buffer                             */
.................... /*****************************************************************************/
.................... void serial_task()
.................... {
....................    while(BYTES_AVAILABLE && SERcmd[SWI].full==FALSE)
*
0383A:  MOVLB  4
0383C:  BTFSS  xCA.0
0383E:  BRA    3D2C
03840:  MOVLB  5
03842:  CLRF   xE3
03844:  MOVFF  427,5E2
03848:  CLRF   xE5
0384A:  MOVLW  B5
0384C:  MOVWF  xE4
0384E:  MOVLB  0
03850:  CALL   07CC
03854:  MOVFF  02,5C1
03858:  MOVFF  01,5C0
0385C:  MOVLW  52
0385E:  MOVLB  5
03860:  ADDWF  01,W
03862:  MOVWF  01
03864:  MOVLW  01
03866:  ADDWFC 02,W
03868:  MOVWF  03
0386A:  MOVFF  01,FE9
0386E:  MOVWF  FEA
03870:  BTFSS  FEF.0
03872:  BRA    3878
03874:  MOVLB  4
03876:  BRA    3D2C
....................    {  
....................       unsigned int8 rxChar = getchFromBuffer();
03878:  MOVLB  0
0387A:  BRA    37A8
0387C:  MOVFF  01,5BF
....................       if (rxChar == ignoreChr1 || rxChar == ignoreChr2)
03880:  MOVLB  5
03882:  MOVF   xBF,W
03884:  SUBLW  0D
03886:  BZ    388E
03888:  MOVF   xBF,W
0388A:  SUBLW  20
0388C:  BNZ   3890
....................       {
....................       }
0388E:  BRA    3D26
....................       else if (rxChar == UART_SOT_CHAR)
03890:  MOVF   xBF,W
03892:  SUBLW  7E
03894:  BNZ   38D8
....................       {
....................          resetSERcmd(SWI);
03896:  MOVFF  427,5C0
0389A:  MOVLB  0
0389C:  CALL   07EE
....................          SERcmd[SWI].t = rxChar;
038A0:  MOVLB  5
038A2:  CLRF   xE3
038A4:  MOVFF  427,5E2
038A8:  CLRF   xE5
038AA:  MOVLW  B5
038AC:  MOVWF  xE4
038AE:  MOVLB  0
038B0:  CALL   07CC
038B4:  MOVFF  01,5C0
038B8:  MOVLW  05
038BA:  MOVLB  5
038BC:  ADDWF  01,W
038BE:  MOVWF  01
038C0:  MOVLW  00
038C2:  ADDWFC 02,W
038C4:  MOVWF  03
038C6:  MOVF   01,W
038C8:  ADDLW  52
038CA:  MOVWF  FE9
038CC:  MOVLW  01
038CE:  ADDWFC 03,W
038D0:  MOVWF  FEA
038D2:  MOVFF  5BF,FEF
....................       }
038D6:  BRA    3D26
....................       else if (rxChar >= oneByteCmdTestValue)
038D8:  MOVF   xBF,W
038DA:  SUBLW  7F
038DC:  BC    3948
....................       {
....................          resetSERcmd(SWI);
038DE:  MOVFF  427,5C0
038E2:  MOVLB  0
038E4:  CALL   07EE
....................          SERcmd[SWI].t = rxChar;
038E8:  MOVLB  5
038EA:  CLRF   xE3
038EC:  MOVFF  427,5E2
038F0:  CLRF   xE5
038F2:  MOVLW  B5
038F4:  MOVWF  xE4
038F6:  MOVLB  0
038F8:  CALL   07CC
038FC:  MOVFF  01,5C0
03900:  MOVLW  05
03902:  MOVLB  5
03904:  ADDWF  01,W
03906:  MOVWF  01
03908:  MOVLW  00
0390A:  ADDWFC 02,W
0390C:  MOVWF  03
0390E:  MOVF   01,W
03910:  ADDLW  52
03912:  MOVWF  FE9
03914:  MOVLW  01
03916:  ADDWFC 03,W
03918:  MOVWF  FEA
0391A:  MOVFF  5BF,FEF
....................          SERcmd[SWI].full = TRUE;
0391E:  CLRF   xE3
03920:  MOVFF  427,5E2
03924:  CLRF   xE5
03926:  MOVLW  B5
03928:  MOVWF  xE4
0392A:  MOVLB  0
0392C:  CALL   07CC
03930:  MOVLW  52
03932:  MOVLB  5
03934:  ADDWF  01,W
03936:  MOVWF  FE9
03938:  MOVLW  01
0393A:  ADDWFC 02,W
0393C:  MOVWF  FEA
0393E:  BSF    FEF.0
....................          setNextSERWriteIndex();
03940:  MOVLB  0
03942:  RCALL  37DC
....................       }
03944:  BRA    3D24
03946:  MOVLB  5
....................       else if (rxChar == UART_EOT_CHAR2)
03948:  MOVF   xBF,W
0394A:  SUBLW  0A
0394C:  BTFSS  FD8.2
0394E:  BRA    3A54
....................       {
....................          SERcmd[SWI].full = TRUE;
03950:  CLRF   xE3
03952:  MOVFF  427,5E2
03956:  CLRF   xE5
03958:  MOVLW  B5
0395A:  MOVWF  xE4
0395C:  MOVLB  0
0395E:  CALL   07CC
03962:  MOVLW  52
03964:  MOVLB  5
03966:  ADDWF  01,W
03968:  MOVWF  FE9
0396A:  MOVLW  01
0396C:  ADDWFC 02,W
0396E:  MOVWF  FEA
03970:  BSF    FEF.0
....................          SERcmd[SWI].recWriteIndex = SERcmd[SWI].paramIndex;
03972:  CLRF   xE3
03974:  MOVFF  427,5E2
03978:  CLRF   xE5
0397A:  MOVLW  B5
0397C:  MOVWF  xE4
0397E:  MOVLB  0
03980:  CALL   07CC
03984:  MOVFF  01,5C0
03988:  MOVLW  04
0398A:  MOVLB  5
0398C:  ADDWF  01,W
0398E:  MOVWF  01
03990:  MOVLW  00
03992:  ADDWFC 02,W
03994:  MOVWF  03
03996:  MOVF   01,W
03998:  ADDLW  52
0399A:  MOVWF  01
0399C:  MOVLW  01
0399E:  ADDWFC 03,F
039A0:  MOVFF  01,5C0
039A4:  MOVFF  03,5C1
039A8:  CLRF   xE3
039AA:  MOVFF  427,5E2
039AE:  CLRF   xE5
039B0:  MOVLW  B5
039B2:  MOVWF  xE4
039B4:  MOVLB  0
039B6:  CALL   07CC
039BA:  MOVFF  01,5C2
039BE:  MOVLW  02
039C0:  MOVLB  5
039C2:  ADDWF  01,W
039C4:  MOVWF  01
039C6:  MOVLW  00
039C8:  ADDWFC 02,W
039CA:  MOVWF  03
039CC:  MOVF   01,W
039CE:  ADDLW  52
039D0:  MOVWF  FE9
039D2:  MOVLW  01
039D4:  ADDWFC 03,W
039D6:  MOVWF  FEA
039D8:  MOVFF  FEF,5C2
039DC:  MOVFF  5C1,FEA
039E0:  MOVFF  5C0,FE9
039E4:  MOVFF  5C2,FEF
....................          SERcmd[SWI].chrIndex = 0;
039E8:  CLRF   xE3
039EA:  MOVFF  427,5E2
039EE:  CLRF   xE5
039F0:  MOVLW  B5
039F2:  MOVWF  xE4
039F4:  MOVLB  0
039F6:  CALL   07CC
039FA:  MOVFF  01,5C0
039FE:  MOVLW  01
03A00:  MOVLB  5
03A02:  ADDWF  01,W
03A04:  MOVWF  01
03A06:  MOVLW  00
03A08:  ADDWFC 02,W
03A0A:  MOVWF  03
03A0C:  MOVF   01,W
03A0E:  ADDLW  52
03A10:  MOVWF  FE9
03A12:  MOVLW  01
03A14:  ADDWFC 03,W
03A16:  MOVWF  FEA
03A18:  CLRF   FEF
....................          SERcmd[SWI].paramIndex = 0;
03A1A:  CLRF   xE3
03A1C:  MOVFF  427,5E2
03A20:  CLRF   xE5
03A22:  MOVLW  B5
03A24:  MOVWF  xE4
03A26:  MOVLB  0
03A28:  CALL   07CC
03A2C:  MOVFF  01,5C0
03A30:  MOVLW  02
03A32:  MOVLB  5
03A34:  ADDWF  01,W
03A36:  MOVWF  01
03A38:  MOVLW  00
03A3A:  ADDWFC 02,W
03A3C:  MOVWF  03
03A3E:  MOVF   01,W
03A40:  ADDLW  52
03A42:  MOVWF  FE9
03A44:  MOVLW  01
03A46:  ADDWFC 03,W
03A48:  MOVWF  FEA
03A4A:  CLRF   FEF
....................          setNextSERWriteIndex();
03A4C:  MOVLB  0
03A4E:  RCALL  37DC
....................       }
03A50:  BRA    3D24
03A52:  MOVLB  5
....................       else if (rxChar == delimiter)
03A54:  MOVF   xBF,W
03A56:  SUBLW  2C
03A58:  BNZ   3B16
....................       {
....................          if (SERcmd[SWI].paramIndex < numParam-1)
03A5A:  CLRF   xE3
03A5C:  MOVFF  427,5E2
03A60:  CLRF   xE5
03A62:  MOVLW  B5
03A64:  MOVWF  xE4
03A66:  MOVLB  0
03A68:  CALL   07CC
03A6C:  MOVFF  02,5C1
03A70:  MOVFF  01,5C0
03A74:  MOVLW  02
03A76:  MOVLB  5
03A78:  ADDWF  01,W
03A7A:  MOVWF  01
03A7C:  MOVLW  00
03A7E:  ADDWFC 02,W
03A80:  MOVWF  03
03A82:  MOVF   01,W
03A84:  ADDLW  52
03A86:  MOVWF  FE9
03A88:  MOVLW  01
03A8A:  ADDWFC 03,W
03A8C:  MOVWF  FEA
03A8E:  MOVF   FEF,W
03A90:  SUBLW  05
03A92:  BNC   3AFE
....................          {
....................             SERcmd[SWI].paramIndex +=1;
03A94:  CLRF   xE3
03A96:  MOVFF  427,5E2
03A9A:  CLRF   xE5
03A9C:  MOVLW  B5
03A9E:  MOVWF  xE4
03AA0:  MOVLB  0
03AA2:  CALL   07CC
03AA6:  MOVFF  01,5C0
03AAA:  MOVLW  02
03AAC:  MOVLB  5
03AAE:  ADDWF  01,W
03AB0:  MOVWF  01
03AB2:  MOVLW  00
03AB4:  ADDWFC 02,W
03AB6:  MOVWF  03
03AB8:  MOVF   01,W
03ABA:  ADDLW  52
03ABC:  MOVWF  FE9
03ABE:  MOVLW  01
03AC0:  ADDWFC 03,W
03AC2:  MOVWF  FEA
03AC4:  MOVLW  01
03AC6:  ADDWF  FEF,W
03AC8:  MOVWF  FEF
....................             SERcmd[SWI].chrIndex = 0;
03ACA:  CLRF   xE3
03ACC:  MOVFF  427,5E2
03AD0:  CLRF   xE5
03AD2:  MOVLW  B5
03AD4:  MOVWF  xE4
03AD6:  MOVLB  0
03AD8:  CALL   07CC
03ADC:  MOVFF  01,5C0
03AE0:  MOVLW  01
03AE2:  MOVLB  5
03AE4:  ADDWF  01,W
03AE6:  MOVWF  01
03AE8:  MOVLW  00
03AEA:  ADDWFC 02,W
03AEC:  MOVWF  03
03AEE:  MOVF   01,W
03AF0:  ADDLW  52
03AF2:  MOVWF  FE9
03AF4:  MOVLW  01
03AF6:  ADDWFC 03,W
03AF8:  MOVWF  FEA
03AFA:  CLRF   FEF
....................          }
03AFC:  BRA    3B14
....................          else
....................          {
....................             resetSERcmd(SWI); // exceed number of params... reset capture
03AFE:  MOVFF  427,5C0
03B02:  MOVLB  0
03B04:  CALL   07EE
....................             fprintf(SERIAL, retData);
03B08:  MOVLW  04
03B0A:  MOVWF  FEA
03B0C:  MOVLW  28
03B0E:  MOVWF  FE9
03B10:  RCALL  3816
03B12:  MOVLB  5
....................          }
....................       }
03B14:  BRA    3D26
....................       
....................       else
....................       {
....................          if (SERcmd[SWI].chrIndex < lenParam)
03B16:  CLRF   xE3
03B18:  MOVFF  427,5E2
03B1C:  CLRF   xE5
03B1E:  MOVLW  B5
03B20:  MOVWF  xE4
03B22:  MOVLB  0
03B24:  CALL   07CC
03B28:  MOVFF  02,5C1
03B2C:  MOVFF  01,5C0
03B30:  MOVLW  01
03B32:  MOVLB  5
03B34:  ADDWF  01,W
03B36:  MOVWF  01
03B38:  MOVLW  00
03B3A:  ADDWFC 02,W
03B3C:  MOVWF  03
03B3E:  MOVF   01,W
03B40:  ADDLW  52
03B42:  MOVWF  FE9
03B44:  MOVLW  01
03B46:  ADDWFC 03,W
03B48:  MOVWF  FEA
03B4A:  MOVF   FEF,W
03B4C:  SUBLW  18
03B4E:  BTFSS  FD8.0
03B50:  BRA    3D10
....................          {
....................             SERcmd[SWI].p[SERcmd[SWI].paramIndex][SERcmd[SWI].chrIndex] = rxChar;
03B52:  CLRF   xE3
03B54:  MOVFF  427,5E2
03B58:  CLRF   xE5
03B5A:  MOVLW  B5
03B5C:  MOVWF  xE4
03B5E:  MOVLB  0
03B60:  CALL   07CC
03B64:  MOVFF  02,5C1
03B68:  MOVFF  01,5C0
03B6C:  MOVLW  06
03B6E:  MOVLB  5
03B70:  ADDWF  xC0,F
03B72:  MOVLW  00
03B74:  ADDWFC xC1,F
03B76:  CLRF   xE3
03B78:  MOVFF  427,5E2
03B7C:  CLRF   xE5
03B7E:  MOVLW  B5
03B80:  MOVWF  xE4
03B82:  MOVLB  0
03B84:  CALL   07CC
03B88:  MOVFF  02,5C3
03B8C:  MOVFF  01,5C2
03B90:  MOVLW  02
03B92:  MOVLB  5
03B94:  ADDWF  01,W
03B96:  MOVWF  01
03B98:  MOVLW  00
03B9A:  ADDWFC 02,W
03B9C:  MOVWF  03
03B9E:  MOVF   01,W
03BA0:  ADDLW  52
03BA2:  MOVWF  FE9
03BA4:  MOVLW  01
03BA6:  ADDWFC 03,W
03BA8:  MOVWF  FEA
03BAA:  CLRF   xE3
03BAC:  MOVFF  FEF,5E2
03BB0:  CLRF   xE5
03BB2:  MOVLW  19
03BB4:  MOVWF  xE4
03BB6:  MOVLB  0
03BB8:  CALL   07CC
03BBC:  MOVFF  02,03
03BC0:  MOVF   01,W
03BC2:  MOVLB  5
03BC4:  ADDWF  xC0,F
03BC6:  MOVF   02,W
03BC8:  ADDWFC xC1,F
03BCA:  CLRF   xE3
03BCC:  MOVFF  427,5E2
03BD0:  CLRF   xE5
03BD2:  MOVLW  B5
03BD4:  MOVWF  xE4
03BD6:  MOVLB  0
03BD8:  CALL   07CC
03BDC:  MOVFF  01,5C2
03BE0:  MOVLW  01
03BE2:  MOVLB  5
03BE4:  ADDWF  01,W
03BE6:  MOVWF  01
03BE8:  MOVLW  00
03BEA:  ADDWFC 02,W
03BEC:  MOVWF  03
03BEE:  MOVF   01,W
03BF0:  ADDLW  52
03BF2:  MOVWF  FE9
03BF4:  MOVLW  01
03BF6:  ADDWFC 03,W
03BF8:  MOVWF  FEA
03BFA:  MOVF   FEF,W
03BFC:  ADDWF  xC0,W
03BFE:  MOVWF  01
03C00:  MOVLW  00
03C02:  ADDWFC xC1,W
03C04:  MOVWF  03
03C06:  MOVF   01,W
03C08:  ADDLW  52
03C0A:  MOVWF  FE9
03C0C:  MOVLW  01
03C0E:  ADDWFC 03,W
03C10:  MOVWF  FEA
03C12:  MOVFF  5BF,FEF
....................             SERcmd[SWI].chrIndex += 1;
03C16:  CLRF   xE3
03C18:  MOVFF  427,5E2
03C1C:  CLRF   xE5
03C1E:  MOVLW  B5
03C20:  MOVWF  xE4
03C22:  MOVLB  0
03C24:  CALL   07CC
03C28:  MOVFF  01,5C0
03C2C:  MOVLW  01
03C2E:  MOVLB  5
03C30:  ADDWF  01,W
03C32:  MOVWF  01
03C34:  MOVLW  00
03C36:  ADDWFC 02,W
03C38:  MOVWF  03
03C3A:  MOVF   01,W
03C3C:  ADDLW  52
03C3E:  MOVWF  FE9
03C40:  MOVLW  01
03C42:  ADDWFC 03,W
03C44:  MOVWF  FEA
03C46:  MOVLW  01
03C48:  ADDWF  FEF,W
03C4A:  MOVWF  FEF
....................             SERcmd[SWI].p[SERcmd[SWI].paramIndex][SERcmd[SWI].chrIndex] = '\0';
03C4C:  CLRF   xE3
03C4E:  MOVFF  427,5E2
03C52:  CLRF   xE5
03C54:  MOVLW  B5
03C56:  MOVWF  xE4
03C58:  MOVLB  0
03C5A:  CALL   07CC
03C5E:  MOVFF  02,5C1
03C62:  MOVFF  01,5C0
03C66:  MOVLW  06
03C68:  MOVLB  5
03C6A:  ADDWF  xC0,F
03C6C:  MOVLW  00
03C6E:  ADDWFC xC1,F
03C70:  CLRF   xE3
03C72:  MOVFF  427,5E2
03C76:  CLRF   xE5
03C78:  MOVLW  B5
03C7A:  MOVWF  xE4
03C7C:  MOVLB  0
03C7E:  CALL   07CC
03C82:  MOVFF  02,5C3
03C86:  MOVFF  01,5C2
03C8A:  MOVLW  02
03C8C:  MOVLB  5
03C8E:  ADDWF  01,W
03C90:  MOVWF  01
03C92:  MOVLW  00
03C94:  ADDWFC 02,W
03C96:  MOVWF  03
03C98:  MOVF   01,W
03C9A:  ADDLW  52
03C9C:  MOVWF  FE9
03C9E:  MOVLW  01
03CA0:  ADDWFC 03,W
03CA2:  MOVWF  FEA
03CA4:  CLRF   xE3
03CA6:  MOVFF  FEF,5E2
03CAA:  CLRF   xE5
03CAC:  MOVLW  19
03CAE:  MOVWF  xE4
03CB0:  MOVLB  0
03CB2:  CALL   07CC
03CB6:  MOVFF  02,03
03CBA:  MOVF   01,W
03CBC:  MOVLB  5
03CBE:  ADDWF  xC0,F
03CC0:  MOVF   02,W
03CC2:  ADDWFC xC1,F
03CC4:  CLRF   xE3
03CC6:  MOVFF  427,5E2
03CCA:  CLRF   xE5
03CCC:  MOVLW  B5
03CCE:  MOVWF  xE4
03CD0:  MOVLB  0
03CD2:  CALL   07CC
03CD6:  MOVFF  01,5C2
03CDA:  MOVLW  01
03CDC:  MOVLB  5
03CDE:  ADDWF  01,W
03CE0:  MOVWF  01
03CE2:  MOVLW  00
03CE4:  ADDWFC 02,W
03CE6:  MOVWF  03
03CE8:  MOVF   01,W
03CEA:  ADDLW  52
03CEC:  MOVWF  FE9
03CEE:  MOVLW  01
03CF0:  ADDWFC 03,W
03CF2:  MOVWF  FEA
03CF4:  MOVF   FEF,W
03CF6:  ADDWF  xC0,W
03CF8:  MOVWF  01
03CFA:  MOVLW  00
03CFC:  ADDWFC xC1,W
03CFE:  MOVWF  03
03D00:  MOVF   01,W
03D02:  ADDLW  52
03D04:  MOVWF  FE9
03D06:  MOVLW  01
03D08:  ADDWFC 03,W
03D0A:  MOVWF  FEA
03D0C:  CLRF   FEF
....................          }
03D0E:  BRA    3D26
....................          else
....................          {
....................             resetSERcmd(SWI); // exceed number of characters... reset capture
03D10:  MOVFF  427,5C0
03D14:  MOVLB  0
03D16:  CALL   07EE
....................             fprintf(SERIAL, retData);
03D1A:  MOVLW  04
03D1C:  MOVWF  FEA
03D1E:  MOVLW  28
03D20:  MOVWF  FE9
03D22:  RCALL  3816
03D24:  MOVLB  5
....................          }
....................       }
03D26:  MOVLB  0
03D28:  BRA    383A
03D2A:  MOVLB  4
....................    }          
03D2C:  MOVLB  0
03D2E:  GOTO   6AD0 (RETURN)
.................... }
....................            
.................... /*****************************************************************************/
.................... /* serialInit ROUTINE  - Sets up serial port                                 */
.................... /*****************************************************************************/ 
.................... void serial_init()
.................... {
....................    for (int i = 0; i < numRecords; i++) 
*
00968:  MOVLB  5
0096A:  CLRF   xBF
0096C:  MOVF   xBF,W
0096E:  SUBLW  03
00970:  BNC   0980
....................    {
....................       resetSERcmd(i);
00972:  MOVFF  5BF,5C0
00976:  MOVLB  0
00978:  RCALL  07EE
0097A:  MOVLB  5
0097C:  INCF   xBF,F
0097E:  BRA    096C
....................    }
....................    enable_interrupts(INT_RDA);
00980:  MOVLB  E
00982:  BSF    xC0.5
00984:  MOVLB  0
00986:  GOTO   6ABC (RETURN)
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... //!#include <pid.h>
.................... #include <eventTimer.h>
.................... #ifndef timeout
.................... #define timeout
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {VOLTAGE, MAGSENS}; // Voltage or Magnetic Sensor Control
.................... //!typedef enum sensorType {kmxp1000, kmxp2000}; // Magsensors
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2];
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MAGSENS, MAGSENS};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = 
.................... {
....................    {0,1}, {0,1}, {0,1}, {0,1}, {0,1}, {0,1}, {0,1}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals;
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;    // adc raw count data
....................    float cosRaw;    // adc raw count data
....................    float sinCounts; // calibrated counts
....................    float cosCounts; // calibrated counts
....................    float p0;               // position in units of pole-pitch
....................    int8  npoles;           // number of poles passed
....................    float pReal;            // real position
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0},
....................    {0,0,0,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/           
.................... /* Global timers used by all routnes                                         */
.................... /* timeoutReg0-2 are used for timeouts. Other routines monitor the value of  */
.................... /* intTimeoutReg. On boot, they will be loaded from EEProm. Any              */
.................... /* configuration changes will be changed in EEprom, hence will be restored on*/
.................... /* subsequent boot.                                                          */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* Register definitions                                                      */
.................... /*****************************************************************************/
.................... //!unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... //!unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... //!unsigned int32 timeoutReg2 = 0;
.................... //!unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... unsigned int32 timeCounter = 0;
.................... 
.................... /*****************************************************************************/
.................... /* TIMEOUT_INIT initializes the timer                                        */
.................... /*****************************************************************************/
.................... void event_timer_init()
.................... {        
....................    disable_interrupts(INT_TIMER1);
0098A:  MOVLB  E
0098C:  BCF    xC1.0
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_1);
0098E:  MOVLW  01
00990:  MOVWF  FD1
00992:  MOVLW  07
00994:  MOVWF  FCE
00996:  CLRF   FCF
00998:  CLRF   FD0
....................    timeoutReg0 = 0;  // clear all the timers
0099A:  MOVLB  1
0099C:  CLRF   x44
0099E:  CLRF   x43
009A0:  CLRF   x42
009A2:  CLRF   x41
....................    timeoutReg1 = 0;
009A4:  CLRF   x48
009A6:  CLRF   x47
009A8:  CLRF   x46
009AA:  CLRF   x45
....................    timeoutReg2 = 0;
009AC:  CLRF   x4C
009AE:  CLRF   x4B
009B0:  CLRF   x4A
009B2:  CLRF   x49
....................    intTimeoutReg = 50;
009B4:  CLRF   x4E
009B6:  MOVLW  32
009B8:  MOVWF  x4D
....................    enable_interrupts(INT_TIMER1);
009BA:  MOVLB  E
009BC:  BSF    xC1.0
009BE:  MOVLB  0
009C0:  GOTO   6AC0 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* TIMEOUT INTERRUPT decrements the timeout registers every second           */
.................... /*****************************************************************************/
.................... #INT_TIMER1
.................... void TIMER1_isr(void) 
*
0021E:  MOVLB  0
.................... {
....................    set_timer1(0x0BDB); // load timer register to allow 10 millisecond interupts
00220:  MOVLW  0B
00222:  MOVWF  FCD
00224:  MOVLW  DB
00226:  MOVWF  FCC
00228:  NOP   
....................    if (timeoutReg0 > 10) timeoutReg0 -= 10; else timeoutReg0 = 0;
0022A:  MOVLB  1
0022C:  MOVF   x44,F
0022E:  BNZ   023E
00230:  MOVF   x43,F
00232:  BNZ   023E
00234:  MOVF   x42,F
00236:  BNZ   023E
00238:  MOVF   x41,W
0023A:  SUBLW  0A
0023C:  BC    024C
0023E:  MOVLW  0A
00240:  SUBWF  x41,F
00242:  MOVLW  00
00244:  SUBWFB x42,F
00246:  SUBWFB x43,F
00248:  SUBWFB x44,F
0024A:  BRA    0254
0024C:  CLRF   x44
0024E:  CLRF   x43
00250:  CLRF   x42
00252:  CLRF   x41
....................    if (timeoutReg1 > 10) timeoutReg1 -= 10; else timeoutReg1 = 0;
00254:  MOVF   x48,F
00256:  BNZ   0266
00258:  MOVF   x47,F
0025A:  BNZ   0266
0025C:  MOVF   x46,F
0025E:  BNZ   0266
00260:  MOVF   x45,W
00262:  SUBLW  0A
00264:  BC    0274
00266:  MOVLW  0A
00268:  SUBWF  x45,F
0026A:  MOVLW  00
0026C:  SUBWFB x46,F
0026E:  SUBWFB x47,F
00270:  SUBWFB x48,F
00272:  BRA    027C
00274:  CLRF   x48
00276:  CLRF   x47
00278:  CLRF   x46
0027A:  CLRF   x45
....................    if (timeoutReg2 > 10) timeoutReg2 -= 10; else timeoutReg2 = 0;
0027C:  MOVF   x4C,F
0027E:  BNZ   028E
00280:  MOVF   x4B,F
00282:  BNZ   028E
00284:  MOVF   x4A,F
00286:  BNZ   028E
00288:  MOVF   x49,W
0028A:  SUBLW  0A
0028C:  BC    029C
0028E:  MOVLW  0A
00290:  SUBWF  x49,F
00292:  MOVLW  00
00294:  SUBWFB x4A,F
00296:  SUBWFB x4B,F
00298:  SUBWFB x4C,F
0029A:  BRA    02A4
0029C:  CLRF   x4C
0029E:  CLRF   x4B
002A0:  CLRF   x4A
002A2:  CLRF   x49
....................    if (intTimeoutReg != 0) // INTERRUPTING TIMER
002A4:  MOVF   x4D,F
002A6:  BNZ   02AC
002A8:  MOVF   x4E,F
002AA:  BZ    02E8
....................    {
....................       timeCounter+=10;
002AC:  MOVLW  0A
002AE:  MOVLB  4
002B0:  ADDWF  xCE,F
002B2:  MOVLW  00
002B4:  ADDWFC xCF,F
002B6:  ADDWFC xD0,F
002B8:  ADDWFC xD1,F
....................       if (timeCounter >= intTimeoutReg)
002BA:  MOVF   xD1,F
002BC:  BNZ   02D8
002BE:  MOVF   xD0,F
002C0:  BNZ   02D8
002C2:  MOVLB  1
002C4:  MOVF   x4E,W
002C6:  MOVLB  4
002C8:  SUBWF  xCF,W
002CA:  BNC   02E6
002CC:  BNZ   02D8
002CE:  MOVLB  1
002D0:  MOVF   x4D,W
002D2:  MOVLB  4
002D4:  SUBWF  xCE,W
002D6:  BNC   02E6
....................       {
....................          sensor_monitor_interrupt_task();
002D8:  MOVLB  0
002DA:  BRA    01E0
....................          timeCounter = 0;
002DC:  MOVLB  4
002DE:  CLRF   xD1
002E0:  CLRF   xD0
002E2:  CLRF   xCF
002E4:  CLRF   xCE
002E6:  MOVLB  1
....................       }
....................    }
.................... }
.................... 
.................... #endif
.................... 
.................... #include <commandHandler.c>
.................... #ifndef cmdHandlerC
.................... #define cmdHandlerC
.................... #include <commandHandler.h>
.................... #ifndef cmdHandler
.................... #define cmdHandler
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {VOLTAGE, MAGSENS}; // Voltage or Magnetic Sensor Control
.................... //!typedef enum sensorType {kmxp1000, kmxp2000}; // Magsensors
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2];
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MAGSENS, MAGSENS};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = 
.................... {
....................    {0,1}, {0,1}, {0,1}, {0,1}, {0,1}, {0,1}, {0,1}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals;
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;    // adc raw count data
....................    float cosRaw;    // adc raw count data
....................    float sinCounts; // calibrated counts
....................    float cosCounts; // calibrated counts
....................    float p0;               // position in units of pole-pitch
....................    int8  npoles;           // number of poles passed
....................    float pReal;            // real position
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0},
....................    {0,0,0,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... 
002E8:  MOVLB  E
002EA:  BCF    xC9.0
002EC:  MOVLB  0
002EE:  GOTO   006E
.................... #define hwID 'D'   // DiFCS
.................... 
.................... /*****************************************************************************/
.................... /* RESPONSE MESSAGES                                                         */
.................... /*****************************************************************************/
.................... typedef struct response {
....................    int8 id;
....................    char *msg;
.................... } resp;
.................... 
.................... //!#define INVALID_DATA "error - invalid data"
.................... //!#define invalidTime "error - invalid TO value"
.................... //!#define overrun "error - buffer overrun"
.................... //!#define dcVoltage "VDC:%f1"
.................... //!#define USBVoltage "VUSB:%f"
.................... //!#define USBupstream "VUSBup:%f"
.................... //!#define plus5V "5V Rail:%f"
.................... //!#define plus3V3 "3V3 Rai:%f"
.................... //!#define allVoltages "All Voltages = %f, %f, %f, %f, %f"
.................... //!#define USBdownstream "USB downstream status:\r\nPG:%s\r\nch0:%s\r\nch1:%s"
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC MESSGAGE DUMP                                                  */
.................... /*****************************************************************************/
.................... //!#define voltageMsg "V0:%f\r\nV1:%f\r\nV2:%f\r\nV3:%f\r\nV4:%f"
.................... //!#define TimerMsg "T0:%Lu\r\nT1:%Lu\r\nT2:%Lu\r\Tint:%Lu\r\nTtick:%Lu"
.................... //!#define ioStatusMsg "Inputs:%u\r\nOutputs:%u\r\nStatus:%u"
.................... //!#define diagnosticMsg "V0:%f\r\nV1:%f\r\nV2:%f\r\nV3:%f\r\nV4:%f\r\nT0:%Lu\r\nT1:%Lu\r\nT2:%Lu\r\nTint:%Lu\r\nTtick:%Lu\r\nInputs:%u\r\nOutputs:%u\r\nStatus:%u"
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC COMMAND PROTOTYPES                                             */
.................... /*****************************************************************************/
.................... int8 getRev(unsigned int8);                // gr 
.................... int8 getSN(unsigned int8);                 // gs
.................... 
.................... int8 getOPchMap(unsigned int8);            // gChMap,   {1|2}
.................... int8 setOPchMap(unsigned int8);            // sChMap,   {1|2}, {X|Y}
.................... 
.................... int8 getIPchMode(unsigned int8);           // gChMode,  {1|2}
.................... int8 setIPchMode(unsigned int8);           // sChMode,  {1|2}, {VOLTAGE|MAGSENS}
....................    
.................... int8 getPIDvals(unsigned int8);            // gPID,     {1|2}, {P|I|D}
.................... int8 setPIDvals(unsigned int8);            // sPID,     {1|2}, {P|I|D}, <float>
.................... 
.................... int8 getSetPoint(unsigned int8);           // gSP,      {1|2}
.................... int8 setSetPoint(unsigned int8);           // sSP,      {1|2}, <float>
.................... 
.................... int8 getAllSensorCalParams(unsigned int8); // gSCals,   {1|2}
.................... int8 getSensorCalParam(unsigned int8);     // gSCal,    {1|2}, {c0|c1|c2|c3|c4|c5}
.................... int8 setSensorCalParam(unsigned int8);     // sSCal,    {1|2}, {c0|c1|c2|c3|c4|c5}, <float>
.................... 
.................... int8 getMonitorCalParam(unsigned int8);    // gMCal,    {N15|200|5V6|5VA|3V6X|3V3A|3V3D}
.................... int8 setMonitorCalParam(unsigned int8);    // sMCal,    {N15|200|5V6|5VA|3V6X|3V3A|3V3D}, <float>, <float>
.................... int8 getMonitorValue(unsigned int8);       // gMon,     {N15|200|5V6|5VA|3V6X|3V3A|3V3D|all}
.................... 
.................... int8 getPIDdata(unsigned int8);            // gPIDdata, {1|2}
.................... 
.................... int8 getIPdata(unsigned int8);             // gIPdata,  {1|2}, {raw|volts|position|all}
.................... 
.................... int8 invalidCmd(unsigned int8);
.................... 
.................... struct command {
....................    char *cmd_name;
....................    int8 (*cmd_func)(unsigned int8);
.................... };
.................... 
.................... BOOLEAN arg_is_float(char *);
.................... BOOLEAN is_valid_channel(char *);
.................... int8 hex_to_int(char);
.................... void echo_cmd(unsigned int8 rec);
.................... int8 command_parser(unsigned int8 rec);
.................... void command_handler_task();
.................... 
.................... #endif
.................... 
.................... 
.................... /* LIST OF DIAGNOSTIC COMMAND KEYWORDS AND THEIR FUNCTIONS */
.................... struct command cmd_list[] = {
....................    {"gr",       &getRev},
....................    {"gs",       &getSN},
....................    {"gChMap",   &getOPchMap},
....................    {"sChMap",   &setOPchMap},
....................    {"gChMode",  &getIPchMode},
....................    {"sChMode",  &setIPchMode},
....................    {"gPID",     &getPIDvals},
....................    {"sPID",     &setPIDvals},
....................    {"gSP",      &getSetPoint},
....................    {"sSP",      &setSetPoint},
....................    {"gSCals",   &getAllSensorCalParams},
....................    {"gSCal",    &getSensorCalParam},
....................    {"sSCal",    &setSensorCalParam},
....................    {"gMCal",    &getMonitorCalParam},
....................    {"sMCal",    &setMonitorCalParam},
....................    {"gMon",     &getMonitorValue},
....................    {"gPIDdata", &getPIDdata},
....................    {"gIPdata",  &getIPdata},
....................    {"\0", &invalidCmd}
.................... };
.................... 
.................... /* LIST OF RESPONSE MESSAGES */
.................... enum resp_e { 
....................    SUCCESS,
....................    INV_CMD,
....................    INV_PARAM 
.................... };
.................... 
.................... resp resp_list[] = {
....................    {SUCCESS, "SUCCESS"},
....................    {INV_CMD, "INVALID COMMAND"},
....................    {INV_PARAM, "INVALID PARAMETER"}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC COMMAND DEFINITIONS                                            */
.................... /*****************************************************************************/
....................                           
.................... int8 getRev(unsigned int8 rec){
....................    sprintf(retData+strlen(retData), "%s,", version);
*
03EB6:  MOVLW  04
03EB8:  MOVLB  5
03EBA:  MOVWF  xE7
03EBC:  MOVLW  28
03EBE:  MOVWF  xE6
03EC0:  MOVLB  0
03EC2:  RCALL  3DC6
03EC4:  MOVFF  02,03
03EC8:  MOVF   01,W
03ECA:  ADDLW  28
03ECC:  MOVLB  5
03ECE:  MOVWF  xCA
03ED0:  MOVLW  04
03ED2:  ADDWFC 02,W
03ED4:  MOVWF  xCB
03ED6:  MOVFF  FE8,4CD
03EDA:  MOVFF  5CA,4CC
03EDE:  MOVLW  F2
03EE0:  MOVWF  FF6
03EE2:  MOVLW  02
03EE4:  MOVWF  FF7
03EE6:  MOVLB  0
03EE8:  RCALL  3E96
03EEA:  MOVLW  2C
03EEC:  MOVLB  5
03EEE:  MOVWF  xE2
03EF0:  MOVLB  0
03EF2:  RCALL  3E76
....................    return SUCCESS;
03EF4:  MOVLW  00
03EF6:  MOVWF  01
03EF8:  RETURN 0
.................... }
.................... 
.................... int8 getSN(unsigned int8 rec){
....................    sprintf(retData+strlen(retData), "%s,", serialID);
03EFA:  MOVLW  04
03EFC:  MOVLB  5
03EFE:  MOVWF  xE7
03F00:  MOVLW  28
03F02:  MOVWF  xE6
03F04:  MOVLB  0
03F06:  RCALL  3DC6
03F08:  MOVFF  02,03
03F0C:  MOVF   01,W
03F0E:  ADDLW  28
03F10:  MOVLB  5
03F12:  MOVWF  xCA
03F14:  MOVLW  04
03F16:  ADDWFC 02,W
03F18:  MOVWF  xCB
03F1A:  MOVFF  FE8,4CD
03F1E:  MOVFF  5CA,4CC
03F22:  MOVLW  FC
03F24:  MOVWF  FF6
03F26:  MOVLW  02
03F28:  MOVWF  FF7
03F2A:  MOVLB  0
03F2C:  RCALL  3E96
03F2E:  MOVLW  2C
03F30:  MOVLB  5
03F32:  MOVWF  xE2
03F34:  MOVLB  0
03F36:  RCALL  3E76
....................    return SUCCESS;
03F38:  MOVLW  00
03F3A:  MOVWF  01
03F3C:  RETURN 0
.................... }
.................... 
.................... int8 getOPchMap(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
043C8:  MOVLB  5
043CA:  CLRF   xE3
043CC:  MOVFF  5BE,5E2
043D0:  CLRF   xE5
043D2:  MOVLW  B5
043D4:  MOVWF  xE4
043D6:  MOVLB  0
043D8:  CALL   07CC
043DC:  MOVFF  02,5CC
043E0:  MOVFF  01,5CB
043E4:  MOVLW  06
043E6:  MOVLB  5
043E8:  ADDWF  xCB,F
043EA:  MOVLW  00
043EC:  ADDWFC xCC,F
043EE:  MOVLW  32
043F0:  ADDWF  xCB,W
043F2:  MOVWF  01
043F4:  MOVLW  00
043F6:  ADDWFC xCC,W
043F8:  MOVWF  03
043FA:  MOVF   01,W
043FC:  ADDLW  52
043FE:  MOVWF  01
04400:  MOVLW  01
04402:  ADDWFC 03,F
04404:  MOVFF  01,5CB
04408:  MOVFF  03,5CC
0440C:  MOVFF  03,5E5
04410:  MOVFF  01,5E4
04414:  MOVLB  0
04416:  RCALL  3F3E
04418:  MOVF   01,F
0441A:  BNZ   4424
0441C:  MOVLW  02
0441E:  MOVWF  01
04420:  BRA    452E
04422:  BRA    4480
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
04424:  MOVLB  5
04426:  CLRF   xE3
04428:  MOVFF  5BE,5E2
0442C:  CLRF   xE5
0442E:  MOVLW  B5
04430:  MOVWF  xE4
04432:  MOVLB  0
04434:  CALL   07CC
04438:  MOVFF  02,5CC
0443C:  MOVFF  01,5CB
04440:  MOVLW  06
04442:  MOVLB  5
04444:  ADDWF  xCB,F
04446:  MOVLW  00
04448:  ADDWFC xCC,F
0444A:  MOVLW  32
0444C:  ADDWF  xCB,W
0444E:  MOVWF  01
04450:  MOVLW  00
04452:  ADDWFC xCC,W
04454:  MOVWF  03
04456:  MOVF   01,W
04458:  ADDLW  52
0445A:  MOVWF  01
0445C:  MOVLW  01
0445E:  ADDWFC 03,F
04460:  MOVFF  01,5CB
04464:  MOVFF  03,5CC
04468:  MOVFF  03,5E5
0446C:  MOVFF  01,5E4
04470:  CLRF   xE7
04472:  CLRF   xE6
04474:  MOVLW  0A
04476:  MOVWF  xE8
04478:  MOVLB  0
0447A:  RCALL  402E
0447C:  MOVFF  01,5CA
....................    
....................    /*** GET CHANNEL MAP ***************/ 
....................    if      (0 == chMap[arg1-1]) sprintf(retData+strlen(retData), "%c,", 'X');
04480:  MOVLW  01
04482:  MOVLB  5
04484:  SUBWF  xCA,W
04486:  MOVWF  xCC
04488:  CLRF   xCE
0448A:  MOVLW  60
0448C:  MOVWF  xCD
0448E:  MOVLB  0
04490:  RCALL  4392
04492:  BTFSC  01.0
04494:  BRA    44D2
04496:  MOVLW  04
04498:  MOVLB  5
0449A:  MOVWF  xE7
0449C:  MOVLW  28
0449E:  MOVWF  xE6
044A0:  MOVLB  0
044A2:  RCALL  3DC6
044A4:  MOVFF  02,03
044A8:  MOVF   01,W
044AA:  ADDLW  28
044AC:  MOVLB  5
044AE:  MOVWF  xCB
044B0:  MOVLW  04
044B2:  ADDWFC 02,W
044B4:  MOVWF  xCC
044B6:  MOVFF  FE8,4CD
044BA:  MOVFF  5CB,4CC
044BE:  MOVLW  58
044C0:  MOVWF  xE2
044C2:  MOVLB  0
044C4:  RCALL  3E76
044C6:  MOVLW  2C
044C8:  MOVLB  5
044CA:  MOVWF  xE2
044CC:  MOVLB  0
044CE:  RCALL  3E76
044D0:  BRA    452A
....................    else if (1 == chMap[arg1-1]) sprintf(retData+strlen(retData), "%c,", 'Y');
044D2:  MOVLW  01
044D4:  MOVLB  5
044D6:  SUBWF  xCA,W
044D8:  MOVWF  xCC
044DA:  CLRF   xCE
044DC:  MOVLW  60
044DE:  MOVWF  xCD
044E0:  MOVLB  0
044E2:  RCALL  4392
044E4:  BTFSS  01.0
044E6:  BRA    4524
044E8:  MOVLW  04
044EA:  MOVLB  5
044EC:  MOVWF  xE7
044EE:  MOVLW  28
044F0:  MOVWF  xE6
044F2:  MOVLB  0
044F4:  RCALL  3DC6
044F6:  MOVFF  02,03
044FA:  MOVF   01,W
044FC:  ADDLW  28
044FE:  MOVLB  5
04500:  MOVWF  xCB
04502:  MOVLW  04
04504:  ADDWFC 02,W
04506:  MOVWF  xCC
04508:  MOVFF  FE8,4CD
0450C:  MOVFF  5CB,4CC
04510:  MOVLW  59
04512:  MOVWF  xE2
04514:  MOVLB  0
04516:  RCALL  3E76
04518:  MOVLW  2C
0451A:  MOVLB  5
0451C:  MOVWF  xE2
0451E:  MOVLB  0
04520:  RCALL  3E76
04522:  BRA    452A
....................    else return INV_PARAM;
04524:  MOVLW  02
04526:  MOVWF  01
04528:  BRA    452E
....................    
....................    return SUCCESS;
0452A:  MOVLW  00
0452C:  MOVWF  01
0452E:  RETURN 0
.................... }
.................... 
.................... int8 setOPchMap(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
04572:  MOVLB  5
04574:  CLRF   xE3
04576:  MOVFF  5BE,5E2
0457A:  CLRF   xE5
0457C:  MOVLW  B5
0457E:  MOVWF  xE4
04580:  MOVLB  0
04582:  CALL   07CC
04586:  MOVFF  02,5CD
0458A:  MOVFF  01,5CC
0458E:  MOVLW  06
04590:  MOVLB  5
04592:  ADDWF  xCC,F
04594:  MOVLW  00
04596:  ADDWFC xCD,F
04598:  MOVLW  32
0459A:  ADDWF  xCC,W
0459C:  MOVWF  01
0459E:  MOVLW  00
045A0:  ADDWFC xCD,W
045A2:  MOVWF  03
045A4:  MOVF   01,W
045A6:  ADDLW  52
045A8:  MOVWF  01
045AA:  MOVLW  01
045AC:  ADDWFC 03,F
045AE:  MOVFF  01,5CC
045B2:  MOVFF  03,5CD
045B6:  MOVFF  03,5E5
045BA:  MOVFF  01,5E4
045BE:  MOVLB  0
045C0:  RCALL  3F3E
045C2:  MOVF   01,F
045C4:  BNZ   45CE
045C6:  MOVLW  02
045C8:  MOVWF  01
045CA:  BRA    4720
045CC:  BRA    462A
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
045CE:  MOVLB  5
045D0:  CLRF   xE3
045D2:  MOVFF  5BE,5E2
045D6:  CLRF   xE5
045D8:  MOVLW  B5
045DA:  MOVWF  xE4
045DC:  MOVLB  0
045DE:  CALL   07CC
045E2:  MOVFF  02,5CD
045E6:  MOVFF  01,5CC
045EA:  MOVLW  06
045EC:  MOVLB  5
045EE:  ADDWF  xCC,F
045F0:  MOVLW  00
045F2:  ADDWFC xCD,F
045F4:  MOVLW  32
045F6:  ADDWF  xCC,W
045F8:  MOVWF  01
045FA:  MOVLW  00
045FC:  ADDWFC xCD,W
045FE:  MOVWF  03
04600:  MOVF   01,W
04602:  ADDLW  52
04604:  MOVWF  01
04606:  MOVLW  01
04608:  ADDWFC 03,F
0460A:  MOVFF  01,5CC
0460E:  MOVFF  03,5CD
04612:  MOVFF  03,5E5
04616:  MOVFF  01,5E4
0461A:  CLRF   xE7
0461C:  CLRF   xE6
0461E:  MOVLW  0A
04620:  MOVWF  xE8
04622:  MOVLB  0
04624:  RCALL  402E
04626:  MOVFF  01,5CA
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
0462A:  MOVLB  5
0462C:  CLRF   xE3
0462E:  MOVFF  5BE,5E2
04632:  CLRF   xE5
04634:  MOVLW  B5
04636:  MOVWF  xE4
04638:  MOVLB  0
0463A:  CALL   07CC
0463E:  MOVFF  02,5CD
04642:  MOVFF  01,5CC
04646:  MOVLW  06
04648:  MOVLB  5
0464A:  ADDWF  xCC,F
0464C:  MOVLW  00
0464E:  ADDWFC xCD,F
04650:  MOVLW  4B
04652:  ADDWF  xCC,W
04654:  MOVWF  01
04656:  MOVLW  00
04658:  ADDWFC xCD,W
0465A:  MOVWF  03
0465C:  MOVF   01,W
0465E:  ADDLW  52
04660:  MOVWF  01
04662:  MOVLW  01
04664:  ADDWFC 03,F
04666:  MOVFF  01,5CC
0466A:  MOVFF  03,5CD
0466E:  MOVFF  03,5E7
04672:  MOVFF  01,5E6
04676:  MOVLB  0
04678:  CALL   3DC6
0467C:  MOVFF  02,03
04680:  MOVF   01,W
04682:  SUBLW  01
04684:  BNZ   468A
04686:  MOVF   03,F
04688:  BZ    4692
0468A:  MOVLW  02
0468C:  MOVWF  01
0468E:  BRA    4720
04690:  BRA    46D4
....................    else arg2 = SERcmd[rec].p[3];
04692:  MOVLB  5
04694:  CLRF   xE3
04696:  MOVFF  5BE,5E2
0469A:  CLRF   xE5
0469C:  MOVLW  B5
0469E:  MOVWF  xE4
046A0:  MOVLB  0
046A2:  CALL   07CC
046A6:  MOVFF  02,5CD
046AA:  MOVFF  01,5CC
046AE:  MOVLW  06
046B0:  MOVLB  5
046B2:  ADDWF  xCC,F
046B4:  MOVLW  00
046B6:  ADDWFC xCD,F
046B8:  MOVLW  4B
046BA:  ADDWF  xCC,W
046BC:  MOVWF  01
046BE:  MOVLW  00
046C0:  ADDWFC xCD,W
046C2:  MOVWF  03
046C4:  MOVF   01,W
046C6:  ADDLW  52
046C8:  MOVWF  01
046CA:  MOVLW  01
046CC:  ADDWFC 03,F
046CE:  MOVFF  01,5CB
046D2:  MOVLB  0
....................    
....................    /*** SET CHANNEL MAP ***************/
....................    if      ('X' == arg2) chMap[arg1-1] = chX;
046D4:  MOVLB  5
046D6:  MOVF   xCB,W
046D8:  SUBLW  58
046DA:  BNZ   46F4
046DC:  MOVLW  01
046DE:  SUBWF  xCA,W
046E0:  MOVWF  xCC
046E2:  MOVWF  xE3
046E4:  CLRF   xE4
046E6:  CLRF   xE6
046E8:  MOVLW  60
046EA:  MOVWF  xE5
046EC:  MOVLB  0
046EE:  RCALL  4530
046F0:  BRA    471C
046F2:  MOVLB  5
....................    else if ('Y' == arg2) chMap[arg1-1] = chY;
046F4:  MOVF   xCB,W
046F6:  SUBLW  59
046F8:  BNZ   4714
046FA:  MOVLW  01
046FC:  SUBWF  xCA,W
046FE:  MOVWF  xCC
04700:  MOVWF  xE3
04702:  MOVLW  01
04704:  MOVWF  xE4
04706:  CLRF   xE6
04708:  MOVLW  60
0470A:  MOVWF  xE5
0470C:  MOVLB  0
0470E:  RCALL  4530
04710:  BRA    471C
04712:  MOVLB  5
....................    else return INV_PARAM;
04714:  MOVLW  02
04716:  MOVWF  01
04718:  MOVLB  0
0471A:  BRA    4720
....................    
....................    return SUCCESS;
0471C:  MOVLW  00
0471E:  MOVWF  01
04720:  RETURN 0
.................... }
.................... 
.................... int8 getIPchMode(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
04722:  MOVLB  5
04724:  CLRF   xE3
04726:  MOVFF  5BE,5E2
0472A:  CLRF   xE5
0472C:  MOVLW  B5
0472E:  MOVWF  xE4
04730:  MOVLB  0
04732:  CALL   07CC
04736:  MOVFF  02,5CC
0473A:  MOVFF  01,5CB
0473E:  MOVLW  06
04740:  MOVLB  5
04742:  ADDWF  xCB,F
04744:  MOVLW  00
04746:  ADDWFC xCC,F
04748:  MOVLW  32
0474A:  ADDWF  xCB,W
0474C:  MOVWF  01
0474E:  MOVLW  00
04750:  ADDWFC xCC,W
04752:  MOVWF  03
04754:  MOVF   01,W
04756:  ADDLW  52
04758:  MOVWF  01
0475A:  MOVLW  01
0475C:  ADDWFC 03,F
0475E:  MOVFF  01,5CB
04762:  MOVFF  03,5CC
04766:  MOVFF  03,5E5
0476A:  MOVFF  01,5E4
0476E:  MOVLB  0
04770:  CALL   3F3E
04774:  MOVF   01,F
04776:  BNZ   4780
04778:  MOVLW  02
0477A:  MOVWF  01
0477C:  BRA    4886
0477E:  BRA    47DC
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
04780:  MOVLB  5
04782:  CLRF   xE3
04784:  MOVFF  5BE,5E2
04788:  CLRF   xE5
0478A:  MOVLW  B5
0478C:  MOVWF  xE4
0478E:  MOVLB  0
04790:  CALL   07CC
04794:  MOVFF  02,5CC
04798:  MOVFF  01,5CB
0479C:  MOVLW  06
0479E:  MOVLB  5
047A0:  ADDWF  xCB,F
047A2:  MOVLW  00
047A4:  ADDWFC xCC,F
047A6:  MOVLW  32
047A8:  ADDWF  xCB,W
047AA:  MOVWF  01
047AC:  MOVLW  00
047AE:  ADDWFC xCC,W
047B0:  MOVWF  03
047B2:  MOVF   01,W
047B4:  ADDLW  52
047B6:  MOVWF  01
047B8:  MOVLW  01
047BA:  ADDWFC 03,F
047BC:  MOVFF  01,5CB
047C0:  MOVFF  03,5CC
047C4:  MOVFF  03,5E5
047C8:  MOVFF  01,5E4
047CC:  CLRF   xE7
047CE:  CLRF   xE6
047D0:  MOVLW  0A
047D2:  MOVWF  xE8
047D4:  MOVLB  0
047D6:  RCALL  402E
047D8:  MOVFF  01,5CA
....................    
....................    /*** GET INPUT MAP *****************/
....................    if      (0 == chMode[arg1-1]) sprintf(retData+strlen(retData), "VOLTAGE,");
047DC:  MOVLW  01
047DE:  MOVLB  5
047E0:  SUBWF  xCA,W
047E2:  MOVWF  xCC
047E4:  CLRF   xCE
047E6:  MOVLW  61
047E8:  MOVWF  xCD
047EA:  MOVLB  0
047EC:  RCALL  4392
047EE:  BTFSC  01.0
047F0:  BRA    482C
047F2:  MOVLW  04
047F4:  MOVLB  5
047F6:  MOVWF  xE7
047F8:  MOVLW  28
047FA:  MOVWF  xE6
047FC:  MOVLB  0
047FE:  CALL   3DC6
04802:  MOVFF  02,03
04806:  MOVF   01,W
04808:  ADDLW  28
0480A:  MOVLB  5
0480C:  MOVWF  xCB
0480E:  MOVLW  04
04810:  ADDWFC 02,W
04812:  MOVWF  xCC
04814:  MOVFF  FE8,4CD
04818:  MOVFF  5CB,4CC
0481C:  MOVLW  02
0481E:  MOVWF  FF6
04820:  MOVLW  03
04822:  MOVWF  FF7
04824:  MOVLB  0
04826:  CALL   3E96
0482A:  BRA    4882
....................    else if (1 == chMode[arg1-1]) sprintf(retData+strlen(retData), "MAGSENS,");
0482C:  MOVLW  01
0482E:  MOVLB  5
04830:  SUBWF  xCA,W
04832:  MOVWF  xCC
04834:  CLRF   xCE
04836:  MOVLW  61
04838:  MOVWF  xCD
0483A:  MOVLB  0
0483C:  RCALL  4392
0483E:  BTFSS  01.0
04840:  BRA    487C
04842:  MOVLW  04
04844:  MOVLB  5
04846:  MOVWF  xE7
04848:  MOVLW  28
0484A:  MOVWF  xE6
0484C:  MOVLB  0
0484E:  CALL   3DC6
04852:  MOVFF  02,03
04856:  MOVF   01,W
04858:  ADDLW  28
0485A:  MOVLB  5
0485C:  MOVWF  xCB
0485E:  MOVLW  04
04860:  ADDWFC 02,W
04862:  MOVWF  xCC
04864:  MOVFF  FE8,4CD
04868:  MOVFF  5CB,4CC
0486C:  MOVLW  0C
0486E:  MOVWF  FF6
04870:  MOVLW  03
04872:  MOVWF  FF7
04874:  MOVLB  0
04876:  CALL   3E96
0487A:  BRA    4882
....................    else return INV_PARAM;
0487C:  MOVLW  02
0487E:  MOVWF  01
04880:  BRA    4886
....................    
....................    return SUCCESS;
04882:  MOVLW  00
04884:  MOVWF  01
04886:  RETURN 0
.................... }
.................... 
.................... int8 setIPchMode(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char *arg2;
....................    char *s_voltage = "VOLTAGE";
04888:  MOVLW  56
0488A:  MOVLB  5
0488C:  MOVWF  xCF
0488E:  MOVLW  4F
04890:  MOVWF  xD0
04892:  MOVLW  4C
04894:  MOVWF  xD1
04896:  MOVLW  54
04898:  MOVWF  xD2
0489A:  MOVLW  41
0489C:  MOVWF  xD3
0489E:  MOVLW  47
048A0:  MOVWF  xD4
048A2:  MOVLW  45
048A4:  MOVWF  xD5
048A6:  CLRF   xD6
048A8:  MOVLW  05
048AA:  MOVWF  xCE
048AC:  MOVLW  CF
048AE:  MOVWF  xCD
....................    char *s_magsens = "MAGSENS";
048B0:  MOVLW  4D
048B2:  MOVWF  xD9
048B4:  MOVLW  41
048B6:  MOVWF  xDA
048B8:  MOVLW  47
048BA:  MOVWF  xDB
048BC:  MOVLW  53
048BE:  MOVWF  xDC
048C0:  MOVLW  45
048C2:  MOVWF  xDD
048C4:  MOVLW  4E
048C6:  MOVWF  xDE
048C8:  MOVLW  53
048CA:  MOVWF  xDF
048CC:  CLRF   xE0
048CE:  MOVLW  05
048D0:  MOVWF  xD8
048D2:  MOVLW  D9
048D4:  MOVWF  xD7
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
048D6:  CLRF   xE3
048D8:  MOVFF  5BE,5E2
048DC:  CLRF   xE5
048DE:  MOVLW  B5
048E0:  MOVWF  xE4
048E2:  MOVLB  0
048E4:  CALL   07CC
048E8:  MOVFF  02,5E2
048EC:  MOVFF  01,5E1
048F0:  MOVLW  06
048F2:  MOVLB  5
048F4:  ADDWF  xE1,F
048F6:  MOVLW  00
048F8:  ADDWFC xE2,F
048FA:  MOVLW  32
048FC:  ADDWF  xE1,W
048FE:  MOVWF  01
04900:  MOVLW  00
04902:  ADDWFC xE2,W
04904:  MOVWF  03
04906:  MOVF   01,W
04908:  ADDLW  52
0490A:  MOVWF  01
0490C:  MOVLW  01
0490E:  ADDWFC 03,F
04910:  MOVFF  01,5E1
04914:  MOVFF  03,5E2
04918:  MOVFF  03,5E5
0491C:  MOVFF  01,5E4
04920:  MOVLB  0
04922:  CALL   3F3E
04926:  MOVF   01,F
04928:  BNZ   4932
0492A:  MOVLW  02
0492C:  MOVWF  01
0492E:  BRA    4AA8
04930:  BRA    4990
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
04932:  MOVLB  5
04934:  CLRF   xE3
04936:  MOVFF  5BE,5E2
0493A:  CLRF   xE5
0493C:  MOVLW  B5
0493E:  MOVWF  xE4
04940:  MOVLB  0
04942:  CALL   07CC
04946:  MOVFF  02,5E2
0494A:  MOVFF  01,5E1
0494E:  MOVLW  06
04950:  MOVLB  5
04952:  ADDWF  xE1,F
04954:  MOVLW  00
04956:  ADDWFC xE2,F
04958:  MOVLW  32
0495A:  ADDWF  xE1,W
0495C:  MOVWF  01
0495E:  MOVLW  00
04960:  ADDWFC xE2,W
04962:  MOVWF  03
04964:  MOVF   01,W
04966:  ADDLW  52
04968:  MOVWF  01
0496A:  MOVLW  01
0496C:  ADDWFC 03,F
0496E:  MOVFF  01,5E1
04972:  MOVFF  03,5E2
04976:  MOVFF  03,5E5
0497A:  MOVFF  01,5E4
0497E:  CLRF   xE7
04980:  CLRF   xE6
04982:  MOVLW  0A
04984:  MOVWF  xE8
04986:  MOVLB  0
04988:  CALL   402E
0498C:  MOVFF  01,5CA
....................    
....................    if (0 == strlen(SERcmd[rec].p[3])) return INV_PARAM;
04990:  MOVLB  5
04992:  CLRF   xE3
04994:  MOVFF  5BE,5E2
04998:  CLRF   xE5
0499A:  MOVLW  B5
0499C:  MOVWF  xE4
0499E:  MOVLB  0
049A0:  CALL   07CC
049A4:  MOVFF  02,5E2
049A8:  MOVFF  01,5E1
049AC:  MOVLW  06
049AE:  MOVLB  5
049B0:  ADDWF  xE1,F
049B2:  MOVLW  00
049B4:  ADDWFC xE2,F
049B6:  MOVLW  4B
049B8:  ADDWF  xE1,W
049BA:  MOVWF  01
049BC:  MOVLW  00
049BE:  ADDWFC xE2,W
049C0:  MOVWF  03
049C2:  MOVF   01,W
049C4:  ADDLW  52
049C6:  MOVWF  01
049C8:  MOVLW  01
049CA:  ADDWFC 03,F
049CC:  MOVFF  01,5E1
049D0:  MOVFF  03,5E2
049D4:  MOVFF  03,5E7
049D8:  MOVFF  01,5E6
049DC:  MOVLB  0
049DE:  CALL   3DC6
049E2:  MOVFF  02,03
049E6:  MOVF   01,W
049E8:  BNZ   49F6
049EA:  MOVF   03,F
049EC:  BNZ   49F6
049EE:  MOVLW  02
049F0:  MOVWF  01
049F2:  BRA    4AA8
049F4:  BRA    4A3C
....................    else arg2 = SERcmd[rec].p[3];
049F6:  MOVLB  5
049F8:  CLRF   xE3
049FA:  MOVFF  5BE,5E2
049FE:  CLRF   xE5
04A00:  MOVLW  B5
04A02:  MOVWF  xE4
04A04:  MOVLB  0
04A06:  CALL   07CC
04A0A:  MOVFF  02,5E2
04A0E:  MOVFF  01,5E1
04A12:  MOVLW  06
04A14:  MOVLB  5
04A16:  ADDWF  xE1,F
04A18:  MOVLW  00
04A1A:  ADDWFC xE2,F
04A1C:  MOVLW  4B
04A1E:  ADDWF  xE1,W
04A20:  MOVWF  01
04A22:  MOVLW  00
04A24:  ADDWFC xE2,W
04A26:  MOVWF  03
04A28:  MOVF   01,W
04A2A:  ADDLW  52
04A2C:  MOVWF  01
04A2E:  MOVLW  01
04A30:  ADDWFC 03,F
04A32:  MOVFF  01,5CB
04A36:  MOVFF  03,5CC
04A3A:  MOVLB  0
....................    
....................    /*** SET INPUT MAP *****************/
....................    if      (0 == strcmp(s_voltage, arg2)) chMode[arg1-1] = VOLTAGE;
04A3C:  MOVFF  5CE,5E3
04A40:  MOVFF  5CD,5E2
04A44:  MOVFF  5CC,5E5
04A48:  MOVFF  5CB,5E4
04A4C:  CALL   3DFE
04A50:  MOVF   01,F
04A52:  BNZ   4A6C
04A54:  MOVLW  01
04A56:  MOVLB  5
04A58:  SUBWF  xCA,W
04A5A:  MOVWF  xE1
04A5C:  MOVWF  xE3
04A5E:  CLRF   xE4
04A60:  CLRF   xE6
04A62:  MOVLW  61
04A64:  MOVWF  xE5
04A66:  MOVLB  0
04A68:  RCALL  4530
04A6A:  BRA    4AA4
....................    else if (0 == strcmp(s_magsens, arg2)) chMode[arg1-1] = MAGSENS;
04A6C:  MOVFF  5D8,5E3
04A70:  MOVFF  5D7,5E2
04A74:  MOVFF  5CC,5E5
04A78:  MOVFF  5CB,5E4
04A7C:  CALL   3DFE
04A80:  MOVF   01,F
04A82:  BNZ   4A9E
04A84:  MOVLW  01
04A86:  MOVLB  5
04A88:  SUBWF  xCA,W
04A8A:  MOVWF  xE1
04A8C:  MOVWF  xE3
04A8E:  MOVLW  01
04A90:  MOVWF  xE4
04A92:  CLRF   xE6
04A94:  MOVLW  61
04A96:  MOVWF  xE5
04A98:  MOVLB  0
04A9A:  RCALL  4530
04A9C:  BRA    4AA4
....................    else return INV_PARAM;
04A9E:  MOVLW  02
04AA0:  MOVWF  01
04AA2:  BRA    4AA8
....................    
....................    return SUCCESS;
04AA4:  MOVLW  00
04AA6:  MOVWF  01
04AA8:  RETURN 0
.................... }
.................... 
.................... int8 getPIDvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/ 
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
04D34:  MOVLB  5
04D36:  CLRF   xE3
04D38:  MOVFF  5BE,5E2
04D3C:  CLRF   xE5
04D3E:  MOVLW  B5
04D40:  MOVWF  xE4
04D42:  MOVLB  0
04D44:  CALL   07CC
04D48:  MOVFF  02,5CD
04D4C:  MOVFF  01,5CC
04D50:  MOVLW  06
04D52:  MOVLB  5
04D54:  ADDWF  xCC,F
04D56:  MOVLW  00
04D58:  ADDWFC xCD,F
04D5A:  MOVLW  32
04D5C:  ADDWF  xCC,W
04D5E:  MOVWF  01
04D60:  MOVLW  00
04D62:  ADDWFC xCD,W
04D64:  MOVWF  03
04D66:  MOVF   01,W
04D68:  ADDLW  52
04D6A:  MOVWF  01
04D6C:  MOVLW  01
04D6E:  ADDWFC 03,F
04D70:  MOVFF  01,5CC
04D74:  MOVFF  03,5CD
04D78:  MOVFF  03,5E5
04D7C:  MOVFF  01,5E4
04D80:  MOVLB  0
04D82:  CALL   3F3E
04D86:  MOVF   01,F
04D88:  BNZ   4D92
04D8A:  MOVLW  02
04D8C:  MOVWF  01
04D8E:  BRA    500C
04D90:  BRA    4DF0
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
04D92:  MOVLB  5
04D94:  CLRF   xE3
04D96:  MOVFF  5BE,5E2
04D9A:  CLRF   xE5
04D9C:  MOVLW  B5
04D9E:  MOVWF  xE4
04DA0:  MOVLB  0
04DA2:  CALL   07CC
04DA6:  MOVFF  02,5CD
04DAA:  MOVFF  01,5CC
04DAE:  MOVLW  06
04DB0:  MOVLB  5
04DB2:  ADDWF  xCC,F
04DB4:  MOVLW  00
04DB6:  ADDWFC xCD,F
04DB8:  MOVLW  32
04DBA:  ADDWF  xCC,W
04DBC:  MOVWF  01
04DBE:  MOVLW  00
04DC0:  ADDWFC xCD,W
04DC2:  MOVWF  03
04DC4:  MOVF   01,W
04DC6:  ADDLW  52
04DC8:  MOVWF  01
04DCA:  MOVLW  01
04DCC:  ADDWFC 03,F
04DCE:  MOVFF  01,5CC
04DD2:  MOVFF  03,5CD
04DD6:  MOVFF  03,5E5
04DDA:  MOVFF  01,5E4
04DDE:  CLRF   xE7
04DE0:  CLRF   xE6
04DE2:  MOVLW  0A
04DE4:  MOVWF  xE8
04DE6:  MOVLB  0
04DE8:  CALL   402E
04DEC:  MOVFF  01,5CA
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
04DF0:  MOVLB  5
04DF2:  CLRF   xE3
04DF4:  MOVFF  5BE,5E2
04DF8:  CLRF   xE5
04DFA:  MOVLW  B5
04DFC:  MOVWF  xE4
04DFE:  MOVLB  0
04E00:  CALL   07CC
04E04:  MOVFF  02,5CD
04E08:  MOVFF  01,5CC
04E0C:  MOVLW  06
04E0E:  MOVLB  5
04E10:  ADDWF  xCC,F
04E12:  MOVLW  00
04E14:  ADDWFC xCD,F
04E16:  MOVLW  4B
04E18:  ADDWF  xCC,W
04E1A:  MOVWF  01
04E1C:  MOVLW  00
04E1E:  ADDWFC xCD,W
04E20:  MOVWF  03
04E22:  MOVF   01,W
04E24:  ADDLW  52
04E26:  MOVWF  01
04E28:  MOVLW  01
04E2A:  ADDWFC 03,F
04E2C:  MOVFF  01,5CC
04E30:  MOVFF  03,5CD
04E34:  MOVFF  03,5E7
04E38:  MOVFF  01,5E6
04E3C:  MOVLB  0
04E3E:  CALL   3DC6
04E42:  MOVFF  02,03
04E46:  MOVF   01,W
04E48:  SUBLW  01
04E4A:  BNZ   4E50
04E4C:  MOVF   03,F
04E4E:  BZ    4E58
04E50:  MOVLW  02
04E52:  MOVWF  01
04E54:  BRA    500C
04E56:  BRA    4E98
....................    else arg2 = SERcmd[rec].p[3][0];
04E58:  MOVLB  5
04E5A:  CLRF   xE3
04E5C:  MOVFF  5BE,5E2
04E60:  CLRF   xE5
04E62:  MOVLW  B5
04E64:  MOVWF  xE4
04E66:  MOVLB  0
04E68:  CALL   07CC
04E6C:  MOVFF  02,5CD
04E70:  MOVFF  01,5CC
04E74:  MOVLW  06
04E76:  MOVLB  5
04E78:  ADDWF  xCC,F
04E7A:  MOVLW  00
04E7C:  ADDWFC xCD,F
04E7E:  MOVLW  4B
04E80:  ADDWF  xCC,F
04E82:  MOVLW  00
04E84:  ADDWFC xCD,F
04E86:  MOVLW  52
04E88:  ADDWF  xCC,W
04E8A:  MOVWF  FE9
04E8C:  MOVLW  01
04E8E:  ADDWFC xCD,W
04E90:  MOVWF  FEA
04E92:  MOVFF  FEF,5CB
04E96:  MOVLB  0
....................    
....................    /*** GET P, I, or D VALUE **********/
....................    if      ('P' == arg2) sprintf(retData+strlen(retData), "%f,", PID[arg1-1].kP);
04E98:  MOVLB  5
04E9A:  MOVF   xCB,W
04E9C:  SUBLW  50
04E9E:  BNZ   4F0C
04EA0:  MOVLW  04
04EA2:  MOVWF  xE7
04EA4:  MOVLW  28
04EA6:  MOVWF  xE6
04EA8:  MOVLB  0
04EAA:  CALL   3DC6
04EAE:  MOVFF  02,03
04EB2:  MOVF   01,W
04EB4:  ADDLW  28
04EB6:  MOVLB  5
04EB8:  MOVWF  xCC
04EBA:  MOVLW  04
04EBC:  ADDWFC 02,W
04EBE:  MOVWF  xCD
04EC0:  MOVLW  01
04EC2:  SUBWF  xCA,W
04EC4:  MULLW  20
04EC6:  MOVF   FF3,W
04EC8:  CLRF   xCF
04ECA:  MOVWF  xCE
04ECC:  MOVLW  20
04ECE:  ADDWF  xCE,W
04ED0:  MOVWF  FE9
04ED2:  MOVLW  00
04ED4:  ADDWFC xCF,W
04ED6:  MOVWF  FEA
04ED8:  MOVFF  FEF,5D5
04EDC:  MOVFF  FEC,5D6
04EE0:  MOVFF  FEC,5D7
04EE4:  MOVFF  FEC,5D8
04EE8:  MOVFF  5CD,4CD
04EEC:  MOVFF  5CC,4CC
04EF0:  MOVLW  89
04EF2:  MOVWF  FE9
04EF4:  MOVLW  02
04EF6:  MOVWF  xD9
04EF8:  MOVLB  0
04EFA:  RCALL  4B82
04EFC:  MOVLW  2C
04EFE:  MOVLB  5
04F00:  MOVWF  xE2
04F02:  MOVLB  0
04F04:  CALL   3E76
04F08:  BRA    5008
04F0A:  MOVLB  5
....................    else if ('I' == arg2) sprintf(retData+strlen(retData), "%f,", PID[arg1-1].kI);
04F0C:  MOVF   xCB,W
04F0E:  SUBLW  49
04F10:  BNZ   4F86
04F12:  MOVLW  04
04F14:  MOVWF  xE7
04F16:  MOVLW  28
04F18:  MOVWF  xE6
04F1A:  MOVLB  0
04F1C:  CALL   3DC6
04F20:  MOVF   01,W
04F22:  ADDLW  28
04F24:  MOVLB  5
04F26:  MOVWF  xCC
04F28:  MOVLW  04
04F2A:  ADDWFC 02,W
04F2C:  MOVWF  xCD
04F2E:  MOVLW  01
04F30:  SUBWF  xCA,W
04F32:  MULLW  20
04F34:  MOVF   FF3,W
04F36:  CLRF   xCF
04F38:  MOVWF  xCE
04F3A:  MOVLW  04
04F3C:  ADDWF  xCE,W
04F3E:  MOVWF  01
04F40:  MOVLW  00
04F42:  ADDWFC xCF,W
04F44:  MOVWF  03
04F46:  MOVF   01,W
04F48:  ADDLW  20
04F4A:  MOVWF  FE9
04F4C:  MOVLW  00
04F4E:  ADDWFC 03,W
04F50:  MOVWF  FEA
04F52:  MOVFF  FEF,5D5
04F56:  MOVFF  FEC,5D6
04F5A:  MOVFF  FEC,5D7
04F5E:  MOVFF  FEC,5D8
04F62:  MOVFF  5CD,4CD
04F66:  MOVFF  5CC,4CC
04F6A:  MOVLW  89
04F6C:  MOVWF  FE9
04F6E:  MOVLW  02
04F70:  MOVWF  xD9
04F72:  MOVLB  0
04F74:  RCALL  4B82
04F76:  MOVLW  2C
04F78:  MOVLB  5
04F7A:  MOVWF  xE2
04F7C:  MOVLB  0
04F7E:  CALL   3E76
04F82:  BRA    5008
04F84:  MOVLB  5
....................    else if ('D' == arg2) sprintf(retData+strlen(retData), "%f,", PID[arg1-1].kD);
04F86:  MOVF   xCB,W
04F88:  SUBLW  44
04F8A:  BNZ   5000
04F8C:  MOVLW  04
04F8E:  MOVWF  xE7
04F90:  MOVLW  28
04F92:  MOVWF  xE6
04F94:  MOVLB  0
04F96:  CALL   3DC6
04F9A:  MOVF   01,W
04F9C:  ADDLW  28
04F9E:  MOVLB  5
04FA0:  MOVWF  xCC
04FA2:  MOVLW  04
04FA4:  ADDWFC 02,W
04FA6:  MOVWF  xCD
04FA8:  MOVLW  01
04FAA:  SUBWF  xCA,W
04FAC:  MULLW  20
04FAE:  MOVF   FF3,W
04FB0:  CLRF   xCF
04FB2:  MOVWF  xCE
04FB4:  MOVLW  08
04FB6:  ADDWF  xCE,W
04FB8:  MOVWF  01
04FBA:  MOVLW  00
04FBC:  ADDWFC xCF,W
04FBE:  MOVWF  03
04FC0:  MOVF   01,W
04FC2:  ADDLW  20
04FC4:  MOVWF  FE9
04FC6:  MOVLW  00
04FC8:  ADDWFC 03,W
04FCA:  MOVWF  FEA
04FCC:  MOVFF  FEF,5D5
04FD0:  MOVFF  FEC,5D6
04FD4:  MOVFF  FEC,5D7
04FD8:  MOVFF  FEC,5D8
04FDC:  MOVFF  5CD,4CD
04FE0:  MOVFF  5CC,4CC
04FE4:  MOVLW  89
04FE6:  MOVWF  FE9
04FE8:  MOVLW  02
04FEA:  MOVWF  xD9
04FEC:  MOVLB  0
04FEE:  RCALL  4B82
04FF0:  MOVLW  2C
04FF2:  MOVLB  5
04FF4:  MOVWF  xE2
04FF6:  MOVLB  0
04FF8:  CALL   3E76
04FFC:  BRA    5008
04FFE:  MOVLB  5
....................    else return INV_PARAM;
05000:  MOVLW  02
05002:  MOVWF  01
05004:  MOVLB  0
05006:  BRA    500C
....................    
....................    return SUCCESS;
05008:  MOVLW  00
0500A:  MOVWF  01
0500C:  RETURN 0
.................... }
.................... 
.................... int8 setPIDvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char  arg2;
....................    float arg3;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
05330:  MOVLB  5
05332:  CLRF   xE3
05334:  MOVFF  5BE,5E2
05338:  CLRF   xE5
0533A:  MOVLW  B5
0533C:  MOVWF  xE4
0533E:  MOVLB  0
05340:  CALL   07CC
05344:  MOVFF  02,5D1
05348:  MOVFF  01,5D0
0534C:  MOVLW  06
0534E:  MOVLB  5
05350:  ADDWF  xD0,F
05352:  MOVLW  00
05354:  ADDWFC xD1,F
05356:  MOVLW  32
05358:  ADDWF  xD0,W
0535A:  MOVWF  01
0535C:  MOVLW  00
0535E:  ADDWFC xD1,W
05360:  MOVWF  03
05362:  MOVF   01,W
05364:  ADDLW  52
05366:  MOVWF  01
05368:  MOVLW  01
0536A:  ADDWFC 03,F
0536C:  MOVFF  01,5D0
05370:  MOVFF  03,5D1
05374:  MOVFF  03,5E5
05378:  MOVFF  01,5E4
0537C:  MOVLB  0
0537E:  CALL   3F3E
05382:  MOVF   01,F
05384:  BNZ   538E
05386:  MOVLW  02
05388:  MOVWF  01
0538A:  BRA    5638
0538C:  BRA    53EC
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
0538E:  MOVLB  5
05390:  CLRF   xE3
05392:  MOVFF  5BE,5E2
05396:  CLRF   xE5
05398:  MOVLW  B5
0539A:  MOVWF  xE4
0539C:  MOVLB  0
0539E:  CALL   07CC
053A2:  MOVFF  02,5D1
053A6:  MOVFF  01,5D0
053AA:  MOVLW  06
053AC:  MOVLB  5
053AE:  ADDWF  xD0,F
053B0:  MOVLW  00
053B2:  ADDWFC xD1,F
053B4:  MOVLW  32
053B6:  ADDWF  xD0,W
053B8:  MOVWF  01
053BA:  MOVLW  00
053BC:  ADDWFC xD1,W
053BE:  MOVWF  03
053C0:  MOVF   01,W
053C2:  ADDLW  52
053C4:  MOVWF  01
053C6:  MOVLW  01
053C8:  ADDWFC 03,F
053CA:  MOVFF  01,5D0
053CE:  MOVFF  03,5D1
053D2:  MOVFF  03,5E5
053D6:  MOVFF  01,5E4
053DA:  CLRF   xE7
053DC:  CLRF   xE6
053DE:  MOVLW  0A
053E0:  MOVWF  xE8
053E2:  MOVLB  0
053E4:  CALL   402E
053E8:  MOVFF  01,5CA
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
053EC:  MOVLB  5
053EE:  CLRF   xE3
053F0:  MOVFF  5BE,5E2
053F4:  CLRF   xE5
053F6:  MOVLW  B5
053F8:  MOVWF  xE4
053FA:  MOVLB  0
053FC:  CALL   07CC
05400:  MOVFF  02,5D1
05404:  MOVFF  01,5D0
05408:  MOVLW  06
0540A:  MOVLB  5
0540C:  ADDWF  xD0,F
0540E:  MOVLW  00
05410:  ADDWFC xD1,F
05412:  MOVLW  4B
05414:  ADDWF  xD0,W
05416:  MOVWF  01
05418:  MOVLW  00
0541A:  ADDWFC xD1,W
0541C:  MOVWF  03
0541E:  MOVF   01,W
05420:  ADDLW  52
05422:  MOVWF  01
05424:  MOVLW  01
05426:  ADDWFC 03,F
05428:  MOVFF  01,5D0
0542C:  MOVFF  03,5D1
05430:  MOVFF  03,5E7
05434:  MOVFF  01,5E6
05438:  MOVLB  0
0543A:  CALL   3DC6
0543E:  MOVFF  02,03
05442:  MOVF   01,W
05444:  SUBLW  01
05446:  BNZ   544C
05448:  MOVF   03,F
0544A:  BZ    5454
0544C:  MOVLW  02
0544E:  MOVWF  01
05450:  BRA    5638
05452:  BRA    5494
....................    else arg2 = SERcmd[rec].p[3][0];
05454:  MOVLB  5
05456:  CLRF   xE3
05458:  MOVFF  5BE,5E2
0545C:  CLRF   xE5
0545E:  MOVLW  B5
05460:  MOVWF  xE4
05462:  MOVLB  0
05464:  CALL   07CC
05468:  MOVFF  02,5D1
0546C:  MOVFF  01,5D0
05470:  MOVLW  06
05472:  MOVLB  5
05474:  ADDWF  xD0,F
05476:  MOVLW  00
05478:  ADDWFC xD1,F
0547A:  MOVLW  4B
0547C:  ADDWF  xD0,F
0547E:  MOVLW  00
05480:  ADDWFC xD1,F
05482:  MOVLW  52
05484:  ADDWF  xD0,W
05486:  MOVWF  FE9
05488:  MOVLW  01
0548A:  ADDWFC xD1,W
0548C:  MOVWF  FEA
0548E:  MOVFF  FEF,5CB
05492:  MOVLB  0
....................    
....................    if (!arg_is_float(strtod(SERcmd[rec].p[4], '\0'))) return INV_PARAM;
05494:  MOVLB  5
05496:  CLRF   xE3
05498:  MOVFF  5BE,5E2
0549C:  CLRF   xE5
0549E:  MOVLW  B5
054A0:  MOVWF  xE4
054A2:  MOVLB  0
054A4:  CALL   07CC
054A8:  MOVFF  02,5D1
054AC:  MOVFF  01,5D0
054B0:  MOVLW  06
054B2:  MOVLB  5
054B4:  ADDWF  xD0,F
054B6:  MOVLW  00
054B8:  ADDWFC xD1,F
054BA:  MOVLW  64
054BC:  ADDWF  xD0,W
054BE:  MOVWF  01
054C0:  MOVLW  00
054C2:  ADDWFC xD1,W
054C4:  MOVWF  03
054C6:  MOVF   01,W
054C8:  ADDLW  52
054CA:  MOVWF  01
054CC:  MOVLW  01
054CE:  ADDWFC 03,F
054D0:  MOVFF  01,5D0
054D4:  MOVFF  03,5D1
054D8:  MOVFF  03,5D4
054DC:  MOVFF  01,5D3
054E0:  CLRF   xD6
054E2:  CLRF   xD5
054E4:  MOVLB  0
054E6:  RCALL  500E
054E8:  MOVFF  03,616
054EC:  MOVFF  02,615
054F0:  MOVFF  01,614
054F4:  MOVFF  00,613
054F8:  CALL   1CDA
054FC:  MOVFF  02,5D1
05500:  MOVFF  01,5D0
05504:  MOVFF  02,5D4
05508:  MOVFF  01,5D3
0550C:  RCALL  526E
0550E:  MOVF   01,F
05510:  BNZ   551A
05512:  MOVLW  02
05514:  MOVWF  01
05516:  BRA    5638
05518:  BRA    557E
....................    else arg3 = strtod(SERcmd[rec].p[4], '\0');
0551A:  MOVLB  5
0551C:  CLRF   xE3
0551E:  MOVFF  5BE,5E2
05522:  CLRF   xE5
05524:  MOVLW  B5
05526:  MOVWF  xE4
05528:  MOVLB  0
0552A:  CALL   07CC
0552E:  MOVFF  02,5D1
05532:  MOVFF  01,5D0
05536:  MOVLW  06
05538:  MOVLB  5
0553A:  ADDWF  xD0,F
0553C:  MOVLW  00
0553E:  ADDWFC xD1,F
05540:  MOVLW  64
05542:  ADDWF  xD0,W
05544:  MOVWF  01
05546:  MOVLW  00
05548:  ADDWFC xD1,W
0554A:  MOVWF  03
0554C:  MOVF   01,W
0554E:  ADDLW  52
05550:  MOVWF  01
05552:  MOVLW  01
05554:  ADDWFC 03,F
05556:  MOVFF  01,5D0
0555A:  MOVFF  03,5D1
0555E:  MOVFF  03,5D4
05562:  MOVFF  01,5D3
05566:  CLRF   xD6
05568:  CLRF   xD5
0556A:  MOVLB  0
0556C:  RCALL  500E
0556E:  MOVFF  03,5CF
05572:  MOVFF  02,5CE
05576:  MOVFF  01,5CD
0557A:  MOVFF  00,5CC
....................    
....................    /*** SET P, I, or D VALUE **********/
....................    if      ('P' == arg2) PID[arg1-1].kP = arg3;
0557E:  MOVLB  5
05580:  MOVF   xCB,W
05582:  SUBLW  50
05584:  BNZ   55B0
05586:  MOVLW  01
05588:  SUBWF  xCA,W
0558A:  MULLW  20
0558C:  MOVF   FF3,W
0558E:  CLRF   xD1
05590:  MOVWF  xD0
05592:  MOVLW  20
05594:  ADDWF  xD0,W
05596:  MOVWF  FE9
05598:  MOVLW  00
0559A:  ADDWFC xD1,W
0559C:  MOVWF  FEA
0559E:  MOVFF  5CC,FEF
055A2:  MOVFF  5CD,FEC
055A6:  MOVFF  5CE,FEC
055AA:  MOVFF  5CF,FEC
055AE:  BRA    5632
....................    else if ('I' == arg2) PID[arg1-1].kI = arg3;
055B0:  MOVF   xCB,W
055B2:  SUBLW  49
055B4:  BNZ   55EC
055B6:  MOVLW  01
055B8:  SUBWF  xCA,W
055BA:  MULLW  20
055BC:  MOVF   FF3,W
055BE:  CLRF   xD1
055C0:  MOVWF  xD0
055C2:  MOVLW  04
055C4:  ADDWF  xD0,W
055C6:  MOVWF  01
055C8:  MOVLW  00
055CA:  ADDWFC xD1,W
055CC:  MOVWF  03
055CE:  MOVF   01,W
055D0:  ADDLW  20
055D2:  MOVWF  FE9
055D4:  MOVLW  00
055D6:  ADDWFC 03,W
055D8:  MOVWF  FEA
055DA:  MOVFF  5CC,FEF
055DE:  MOVFF  5CD,FEC
055E2:  MOVFF  5CE,FEC
055E6:  MOVFF  5CF,FEC
055EA:  BRA    5632
....................    else if ('D' == arg2) PID[arg1-1].kD = arg3;
055EC:  MOVF   xCB,W
055EE:  SUBLW  44
055F0:  BNZ   5628
055F2:  MOVLW  01
055F4:  SUBWF  xCA,W
055F6:  MULLW  20
055F8:  MOVF   FF3,W
055FA:  CLRF   xD1
055FC:  MOVWF  xD0
055FE:  MOVLW  08
05600:  ADDWF  xD0,W
05602:  MOVWF  01
05604:  MOVLW  00
05606:  ADDWFC xD1,W
05608:  MOVWF  03
0560A:  MOVF   01,W
0560C:  ADDLW  20
0560E:  MOVWF  FE9
05610:  MOVLW  00
05612:  ADDWFC 03,W
05614:  MOVWF  FEA
05616:  MOVFF  5CC,FEF
0561A:  MOVFF  5CD,FEC
0561E:  MOVFF  5CE,FEC
05622:  MOVFF  5CF,FEC
05626:  BRA    5632
....................    else return INV_PARAM;
05628:  MOVLW  02
0562A:  MOVWF  01
0562C:  MOVLB  0
0562E:  BRA    5638
05630:  MOVLB  5
....................    
....................    return SUCCESS;
05632:  MOVLW  00
05634:  MOVWF  01
05636:  MOVLB  0
05638:  RETURN 0
.................... }
.................... 
.................... int8 getSetPoint(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0563A:  MOVLB  5
0563C:  CLRF   xE3
0563E:  MOVFF  5BE,5E2
05642:  CLRF   xE5
05644:  MOVLW  B5
05646:  MOVWF  xE4
05648:  MOVLB  0
0564A:  CALL   07CC
0564E:  MOVFF  02,5CC
05652:  MOVFF  01,5CB
05656:  MOVLW  06
05658:  MOVLB  5
0565A:  ADDWF  xCB,F
0565C:  MOVLW  00
0565E:  ADDWFC xCC,F
05660:  MOVLW  32
05662:  ADDWF  xCB,W
05664:  MOVWF  01
05666:  MOVLW  00
05668:  ADDWFC xCC,W
0566A:  MOVWF  03
0566C:  MOVF   01,W
0566E:  ADDLW  52
05670:  MOVWF  01
05672:  MOVLW  01
05674:  ADDWFC 03,F
05676:  MOVFF  01,5CB
0567A:  MOVFF  03,5CC
0567E:  MOVFF  03,5E5
05682:  MOVFF  01,5E4
05686:  MOVLB  0
05688:  CALL   3F3E
0568C:  MOVF   01,F
0568E:  BNZ   5698
05690:  MOVLW  02
05692:  MOVWF  01
05694:  BRA    576E
05696:  BRA    56F6
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
05698:  MOVLB  5
0569A:  CLRF   xE3
0569C:  MOVFF  5BE,5E2
056A0:  CLRF   xE5
056A2:  MOVLW  B5
056A4:  MOVWF  xE4
056A6:  MOVLB  0
056A8:  CALL   07CC
056AC:  MOVFF  02,5CC
056B0:  MOVFF  01,5CB
056B4:  MOVLW  06
056B6:  MOVLB  5
056B8:  ADDWF  xCB,F
056BA:  MOVLW  00
056BC:  ADDWFC xCC,F
056BE:  MOVLW  32
056C0:  ADDWF  xCB,W
056C2:  MOVWF  01
056C4:  MOVLW  00
056C6:  ADDWFC xCC,W
056C8:  MOVWF  03
056CA:  MOVF   01,W
056CC:  ADDLW  52
056CE:  MOVWF  01
056D0:  MOVLW  01
056D2:  ADDWFC 03,F
056D4:  MOVFF  01,5CB
056D8:  MOVFF  03,5CC
056DC:  MOVFF  03,5E5
056E0:  MOVFF  01,5E4
056E4:  CLRF   xE7
056E6:  CLRF   xE6
056E8:  MOVLW  0A
056EA:  MOVWF  xE8
056EC:  MOVLB  0
056EE:  CALL   402E
056F2:  MOVFF  01,5CA
....................    
....................    /*** GET SETPOINT ******************/ 
....................    sprintf(retData+strlen(retData), "%f,", PID[arg1-1].SP);
056F6:  MOVLW  04
056F8:  MOVLB  5
056FA:  MOVWF  xE7
056FC:  MOVLW  28
056FE:  MOVWF  xE6
05700:  MOVLB  0
05702:  CALL   3DC6
05706:  MOVF   01,W
05708:  ADDLW  28
0570A:  MOVLB  5
0570C:  MOVWF  xCB
0570E:  MOVLW  04
05710:  ADDWFC 02,W
05712:  MOVWF  xCC
05714:  MOVLW  01
05716:  SUBWF  xCA,W
05718:  MULLW  20
0571A:  MOVF   FF3,W
0571C:  CLRF   xCE
0571E:  MOVWF  xCD
05720:  MOVLW  0C
05722:  ADDWF  xCD,W
05724:  MOVWF  01
05726:  MOVLW  00
05728:  ADDWFC xCE,W
0572A:  MOVWF  03
0572C:  MOVF   01,W
0572E:  ADDLW  20
05730:  MOVWF  FE9
05732:  MOVLW  00
05734:  ADDWFC 03,W
05736:  MOVWF  FEA
05738:  MOVFF  FEF,5D5
0573C:  MOVFF  FEC,5D6
05740:  MOVFF  FEC,5D7
05744:  MOVFF  FEC,5D8
05748:  MOVFF  5CC,4CD
0574C:  MOVFF  5CB,4CC
05750:  MOVLW  89
05752:  MOVWF  FE9
05754:  MOVLW  02
05756:  MOVWF  xD9
05758:  MOVLB  0
0575A:  CALL   4B82
0575E:  MOVLW  2C
05760:  MOVLB  5
05762:  MOVWF  xE2
05764:  MOVLB  0
05766:  CALL   3E76
....................    return SUCCESS;
0576A:  MOVLW  00
0576C:  MOVWF  01
0576E:  RETURN 0
.................... }
.................... 
.................... int8 setSetPoint(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/   
....................    int8  arg1;
....................    float arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
05770:  MOVLB  5
05772:  CLRF   xE3
05774:  MOVFF  5BE,5E2
05778:  CLRF   xE5
0577A:  MOVLW  B5
0577C:  MOVWF  xE4
0577E:  MOVLB  0
05780:  CALL   07CC
05784:  MOVFF  02,5D0
05788:  MOVFF  01,5CF
0578C:  MOVLW  06
0578E:  MOVLB  5
05790:  ADDWF  xCF,F
05792:  MOVLW  00
05794:  ADDWFC xD0,F
05796:  MOVLW  32
05798:  ADDWF  xCF,W
0579A:  MOVWF  01
0579C:  MOVLW  00
0579E:  ADDWFC xD0,W
057A0:  MOVWF  03
057A2:  MOVF   01,W
057A4:  ADDLW  52
057A6:  MOVWF  01
057A8:  MOVLW  01
057AA:  ADDWFC 03,F
057AC:  MOVFF  01,5CF
057B0:  MOVFF  03,5D0
057B4:  MOVFF  03,5E5
057B8:  MOVFF  01,5E4
057BC:  MOVLB  0
057BE:  CALL   3F3E
057C2:  MOVF   01,F
057C4:  BNZ   57CE
057C6:  MOVLW  02
057C8:  MOVWF  01
057CA:  BRA    5956
057CC:  BRA    582C
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
057CE:  MOVLB  5
057D0:  CLRF   xE3
057D2:  MOVFF  5BE,5E2
057D6:  CLRF   xE5
057D8:  MOVLW  B5
057DA:  MOVWF  xE4
057DC:  MOVLB  0
057DE:  CALL   07CC
057E2:  MOVFF  02,5D0
057E6:  MOVFF  01,5CF
057EA:  MOVLW  06
057EC:  MOVLB  5
057EE:  ADDWF  xCF,F
057F0:  MOVLW  00
057F2:  ADDWFC xD0,F
057F4:  MOVLW  32
057F6:  ADDWF  xCF,W
057F8:  MOVWF  01
057FA:  MOVLW  00
057FC:  ADDWFC xD0,W
057FE:  MOVWF  03
05800:  MOVF   01,W
05802:  ADDLW  52
05804:  MOVWF  01
05806:  MOVLW  01
05808:  ADDWFC 03,F
0580A:  MOVFF  01,5CF
0580E:  MOVFF  03,5D0
05812:  MOVFF  03,5E5
05816:  MOVFF  01,5E4
0581A:  CLRF   xE7
0581C:  CLRF   xE6
0581E:  MOVLW  0A
05820:  MOVWF  xE8
05822:  MOVLB  0
05824:  CALL   402E
05828:  MOVFF  01,5CA
....................    
....................    if (!arg_is_float(strtod(SERcmd[rec].p[3], '\0'))) return INV_PARAM;
0582C:  MOVLB  5
0582E:  CLRF   xE3
05830:  MOVFF  5BE,5E2
05834:  CLRF   xE5
05836:  MOVLW  B5
05838:  MOVWF  xE4
0583A:  MOVLB  0
0583C:  CALL   07CC
05840:  MOVFF  02,5D0
05844:  MOVFF  01,5CF
05848:  MOVLW  06
0584A:  MOVLB  5
0584C:  ADDWF  xCF,F
0584E:  MOVLW  00
05850:  ADDWFC xD0,F
05852:  MOVLW  4B
05854:  ADDWF  xCF,W
05856:  MOVWF  01
05858:  MOVLW  00
0585A:  ADDWFC xD0,W
0585C:  MOVWF  03
0585E:  MOVF   01,W
05860:  ADDLW  52
05862:  MOVWF  01
05864:  MOVLW  01
05866:  ADDWFC 03,F
05868:  MOVFF  01,5CF
0586C:  MOVFF  03,5D0
05870:  MOVFF  03,5D4
05874:  MOVFF  01,5D3
05878:  CLRF   xD6
0587A:  CLRF   xD5
0587C:  MOVLB  0
0587E:  CALL   500E
05882:  MOVFF  03,616
05886:  MOVFF  02,615
0588A:  MOVFF  01,614
0588E:  MOVFF  00,613
05892:  CALL   1CDA
05896:  MOVFF  02,5D0
0589A:  MOVFF  01,5CF
0589E:  MOVFF  02,5D4
058A2:  MOVFF  01,5D3
058A6:  RCALL  526E
058A8:  MOVF   01,F
058AA:  BNZ   58B4
058AC:  MOVLW  02
058AE:  MOVWF  01
058B0:  BRA    5956
058B2:  BRA    591A
....................    else arg2 = strtod(SERcmd[rec].p[3], '\0');
058B4:  MOVLB  5
058B6:  CLRF   xE3
058B8:  MOVFF  5BE,5E2
058BC:  CLRF   xE5
058BE:  MOVLW  B5
058C0:  MOVWF  xE4
058C2:  MOVLB  0
058C4:  CALL   07CC
058C8:  MOVFF  02,5D0
058CC:  MOVFF  01,5CF
058D0:  MOVLW  06
058D2:  MOVLB  5
058D4:  ADDWF  xCF,F
058D6:  MOVLW  00
058D8:  ADDWFC xD0,F
058DA:  MOVLW  4B
058DC:  ADDWF  xCF,W
058DE:  MOVWF  01
058E0:  MOVLW  00
058E2:  ADDWFC xD0,W
058E4:  MOVWF  03
058E6:  MOVF   01,W
058E8:  ADDLW  52
058EA:  MOVWF  01
058EC:  MOVLW  01
058EE:  ADDWFC 03,F
058F0:  MOVFF  01,5CF
058F4:  MOVFF  03,5D0
058F8:  MOVFF  03,5D4
058FC:  MOVFF  01,5D3
05900:  CLRF   xD6
05902:  CLRF   xD5
05904:  MOVLB  0
05906:  CALL   500E
0590A:  MOVFF  03,5CE
0590E:  MOVFF  02,5CD
05912:  MOVFF  01,5CC
05916:  MOVFF  00,5CB
....................    
....................    /*** SET SETPOINT ******************/ 
....................    PID[arg1-1].SP = arg2;
0591A:  MOVLW  01
0591C:  MOVLB  5
0591E:  SUBWF  xCA,W
05920:  MULLW  20
05922:  MOVF   FF3,W
05924:  CLRF   xD0
05926:  MOVWF  xCF
05928:  MOVLW  0C
0592A:  ADDWF  xCF,W
0592C:  MOVWF  01
0592E:  MOVLW  00
05930:  ADDWFC xD0,W
05932:  MOVWF  03
05934:  MOVF   01,W
05936:  ADDLW  20
05938:  MOVWF  FE9
0593A:  MOVLW  00
0593C:  ADDWFC 03,W
0593E:  MOVWF  FEA
05940:  MOVFF  5CB,FEF
05944:  MOVFF  5CC,FEC
05948:  MOVFF  5CD,FEC
0594C:  MOVFF  5CE,FEC
....................    
....................    return SUCCESS;
05950:  MOVLW  00
05952:  MOVWF  01
05954:  MOVLB  0
05956:  RETURN 0
.................... }
.................... 
.................... int8 getAllSensorCalParams(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
05958:  MOVLB  5
0595A:  CLRF   xE3
0595C:  MOVFF  5BE,5E2
05960:  CLRF   xE5
05962:  MOVLW  B5
05964:  MOVWF  xE4
05966:  MOVLB  0
05968:  CALL   07CC
0596C:  MOVFF  02,5CC
05970:  MOVFF  01,5CB
05974:  MOVLW  06
05976:  MOVLB  5
05978:  ADDWF  xCB,F
0597A:  MOVLW  00
0597C:  ADDWFC xCC,F
0597E:  MOVLW  32
05980:  ADDWF  xCB,W
05982:  MOVWF  01
05984:  MOVLW  00
05986:  ADDWFC xCC,W
05988:  MOVWF  03
0598A:  MOVF   01,W
0598C:  ADDLW  52
0598E:  MOVWF  01
05990:  MOVLW  01
05992:  ADDWFC 03,F
05994:  MOVFF  01,5CB
05998:  MOVFF  03,5CC
0599C:  MOVFF  03,5E5
059A0:  MOVFF  01,5E4
059A4:  MOVLB  0
059A6:  CALL   3F3E
059AA:  MOVF   01,F
059AC:  BNZ   59B6
059AE:  MOVLW  02
059B0:  MOVWF  01
059B2:  BRA    5CC8
059B4:  BRA    5A14
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
059B6:  MOVLB  5
059B8:  CLRF   xE3
059BA:  MOVFF  5BE,5E2
059BE:  CLRF   xE5
059C0:  MOVLW  B5
059C2:  MOVWF  xE4
059C4:  MOVLB  0
059C6:  CALL   07CC
059CA:  MOVFF  02,5CC
059CE:  MOVFF  01,5CB
059D2:  MOVLW  06
059D4:  MOVLB  5
059D6:  ADDWF  xCB,F
059D8:  MOVLW  00
059DA:  ADDWFC xCC,F
059DC:  MOVLW  32
059DE:  ADDWF  xCB,W
059E0:  MOVWF  01
059E2:  MOVLW  00
059E4:  ADDWFC xCC,W
059E6:  MOVWF  03
059E8:  MOVF   01,W
059EA:  ADDLW  52
059EC:  MOVWF  01
059EE:  MOVLW  01
059F0:  ADDWFC 03,F
059F2:  MOVFF  01,5CB
059F6:  MOVFF  03,5CC
059FA:  MOVFF  03,5E5
059FE:  MOVFF  01,5E4
05A02:  CLRF   xE7
05A04:  CLRF   xE6
05A06:  MOVLW  0A
05A08:  MOVWF  xE8
05A0A:  MOVLB  0
05A0C:  CALL   402E
05A10:  MOVFF  01,5CA
....................    
....................    /*** GET ALL SENSOR CAL PARAMS *****/
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c0);
05A14:  MOVLW  04
05A16:  MOVLB  5
05A18:  MOVWF  xE7
05A1A:  MOVLW  28
05A1C:  MOVWF  xE6
05A1E:  MOVLB  0
05A20:  CALL   3DC6
05A24:  MOVFF  02,03
05A28:  MOVF   01,W
05A2A:  ADDLW  28
05A2C:  MOVLB  5
05A2E:  MOVWF  xCB
05A30:  MOVLW  04
05A32:  ADDWFC 02,W
05A34:  MOVWF  xCC
05A36:  MOVLW  01
05A38:  SUBWF  xCA,W
05A3A:  MULLW  18
05A3C:  MOVF   FF3,W
05A3E:  CLRF   xCE
05A40:  MOVWF  xCD
05A42:  MOVLW  82
05A44:  ADDWF  xCD,W
05A46:  MOVWF  FE9
05A48:  MOVLW  00
05A4A:  ADDWFC xCE,W
05A4C:  MOVWF  FEA
05A4E:  MOVFF  FEF,5D5
05A52:  MOVFF  FEC,5D6
05A56:  MOVFF  FEC,5D7
05A5A:  MOVFF  FEC,5D8
05A5E:  MOVFF  5CC,4CD
05A62:  MOVFF  5CB,4CC
05A66:  MOVLW  89
05A68:  MOVWF  FE9
05A6A:  MOVLW  02
05A6C:  MOVWF  xD9
05A6E:  MOVLB  0
05A70:  CALL   4B82
05A74:  MOVLW  2C
05A76:  MOVLB  5
05A78:  MOVWF  xE2
05A7A:  MOVLB  0
05A7C:  CALL   3E76
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c1);
05A80:  MOVLW  04
05A82:  MOVLB  5
05A84:  MOVWF  xE7
05A86:  MOVLW  28
05A88:  MOVWF  xE6
05A8A:  MOVLB  0
05A8C:  CALL   3DC6
05A90:  MOVF   01,W
05A92:  ADDLW  28
05A94:  MOVLB  5
05A96:  MOVWF  xCB
05A98:  MOVLW  04
05A9A:  ADDWFC 02,W
05A9C:  MOVWF  xCC
05A9E:  MOVLW  01
05AA0:  SUBWF  xCA,W
05AA2:  MULLW  18
05AA4:  MOVF   FF3,W
05AA6:  CLRF   xCE
05AA8:  MOVWF  xCD
05AAA:  MOVLW  04
05AAC:  ADDWF  xCD,W
05AAE:  MOVWF  01
05AB0:  MOVLW  00
05AB2:  ADDWFC xCE,W
05AB4:  MOVWF  03
05AB6:  MOVF   01,W
05AB8:  ADDLW  82
05ABA:  MOVWF  FE9
05ABC:  MOVLW  00
05ABE:  ADDWFC 03,W
05AC0:  MOVWF  FEA
05AC2:  MOVFF  FEF,5D5
05AC6:  MOVFF  FEC,5D6
05ACA:  MOVFF  FEC,5D7
05ACE:  MOVFF  FEC,5D8
05AD2:  MOVFF  5CC,4CD
05AD6:  MOVFF  5CB,4CC
05ADA:  MOVLW  89
05ADC:  MOVWF  FE9
05ADE:  MOVLW  02
05AE0:  MOVWF  xD9
05AE2:  MOVLB  0
05AE4:  CALL   4B82
05AE8:  MOVLW  2C
05AEA:  MOVLB  5
05AEC:  MOVWF  xE2
05AEE:  MOVLB  0
05AF0:  CALL   3E76
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c2);
05AF4:  MOVLW  04
05AF6:  MOVLB  5
05AF8:  MOVWF  xE7
05AFA:  MOVLW  28
05AFC:  MOVWF  xE6
05AFE:  MOVLB  0
05B00:  CALL   3DC6
05B04:  MOVF   01,W
05B06:  ADDLW  28
05B08:  MOVLB  5
05B0A:  MOVWF  xCB
05B0C:  MOVLW  04
05B0E:  ADDWFC 02,W
05B10:  MOVWF  xCC
05B12:  MOVLW  01
05B14:  SUBWF  xCA,W
05B16:  MULLW  18
05B18:  MOVF   FF3,W
05B1A:  CLRF   xCE
05B1C:  MOVWF  xCD
05B1E:  MOVLW  08
05B20:  ADDWF  xCD,W
05B22:  MOVWF  01
05B24:  MOVLW  00
05B26:  ADDWFC xCE,W
05B28:  MOVWF  03
05B2A:  MOVF   01,W
05B2C:  ADDLW  82
05B2E:  MOVWF  FE9
05B30:  MOVLW  00
05B32:  ADDWFC 03,W
05B34:  MOVWF  FEA
05B36:  MOVFF  FEF,5D5
05B3A:  MOVFF  FEC,5D6
05B3E:  MOVFF  FEC,5D7
05B42:  MOVFF  FEC,5D8
05B46:  MOVFF  5CC,4CD
05B4A:  MOVFF  5CB,4CC
05B4E:  MOVLW  89
05B50:  MOVWF  FE9
05B52:  MOVLW  02
05B54:  MOVWF  xD9
05B56:  MOVLB  0
05B58:  CALL   4B82
05B5C:  MOVLW  2C
05B5E:  MOVLB  5
05B60:  MOVWF  xE2
05B62:  MOVLB  0
05B64:  CALL   3E76
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c3);
05B68:  MOVLW  04
05B6A:  MOVLB  5
05B6C:  MOVWF  xE7
05B6E:  MOVLW  28
05B70:  MOVWF  xE6
05B72:  MOVLB  0
05B74:  CALL   3DC6
05B78:  MOVF   01,W
05B7A:  ADDLW  28
05B7C:  MOVLB  5
05B7E:  MOVWF  xCB
05B80:  MOVLW  04
05B82:  ADDWFC 02,W
05B84:  MOVWF  xCC
05B86:  MOVLW  01
05B88:  SUBWF  xCA,W
05B8A:  MULLW  18
05B8C:  MOVF   FF3,W
05B8E:  CLRF   xCE
05B90:  MOVWF  xCD
05B92:  MOVLW  0C
05B94:  ADDWF  xCD,W
05B96:  MOVWF  01
05B98:  MOVLW  00
05B9A:  ADDWFC xCE,W
05B9C:  MOVWF  03
05B9E:  MOVF   01,W
05BA0:  ADDLW  82
05BA2:  MOVWF  FE9
05BA4:  MOVLW  00
05BA6:  ADDWFC 03,W
05BA8:  MOVWF  FEA
05BAA:  MOVFF  FEF,5D5
05BAE:  MOVFF  FEC,5D6
05BB2:  MOVFF  FEC,5D7
05BB6:  MOVFF  FEC,5D8
05BBA:  MOVFF  5CC,4CD
05BBE:  MOVFF  5CB,4CC
05BC2:  MOVLW  89
05BC4:  MOVWF  FE9
05BC6:  MOVLW  02
05BC8:  MOVWF  xD9
05BCA:  MOVLB  0
05BCC:  CALL   4B82
05BD0:  MOVLW  2C
05BD2:  MOVLB  5
05BD4:  MOVWF  xE2
05BD6:  MOVLB  0
05BD8:  CALL   3E76
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c4);
05BDC:  MOVLW  04
05BDE:  MOVLB  5
05BE0:  MOVWF  xE7
05BE2:  MOVLW  28
05BE4:  MOVWF  xE6
05BE6:  MOVLB  0
05BE8:  CALL   3DC6
05BEC:  MOVF   01,W
05BEE:  ADDLW  28
05BF0:  MOVLB  5
05BF2:  MOVWF  xCB
05BF4:  MOVLW  04
05BF6:  ADDWFC 02,W
05BF8:  MOVWF  xCC
05BFA:  MOVLW  01
05BFC:  SUBWF  xCA,W
05BFE:  MULLW  18
05C00:  MOVF   FF3,W
05C02:  CLRF   xCE
05C04:  MOVWF  xCD
05C06:  MOVLW  10
05C08:  ADDWF  xCD,W
05C0A:  MOVWF  01
05C0C:  MOVLW  00
05C0E:  ADDWFC xCE,W
05C10:  MOVWF  03
05C12:  MOVF   01,W
05C14:  ADDLW  82
05C16:  MOVWF  FE9
05C18:  MOVLW  00
05C1A:  ADDWFC 03,W
05C1C:  MOVWF  FEA
05C1E:  MOVFF  FEF,5D5
05C22:  MOVFF  FEC,5D6
05C26:  MOVFF  FEC,5D7
05C2A:  MOVFF  FEC,5D8
05C2E:  MOVFF  5CC,4CD
05C32:  MOVFF  5CB,4CC
05C36:  MOVLW  89
05C38:  MOVWF  FE9
05C3A:  MOVLW  02
05C3C:  MOVWF  xD9
05C3E:  MOVLB  0
05C40:  CALL   4B82
05C44:  MOVLW  2C
05C46:  MOVLB  5
05C48:  MOVWF  xE2
05C4A:  MOVLB  0
05C4C:  CALL   3E76
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c5);
05C50:  MOVLW  04
05C52:  MOVLB  5
05C54:  MOVWF  xE7
05C56:  MOVLW  28
05C58:  MOVWF  xE6
05C5A:  MOVLB  0
05C5C:  CALL   3DC6
05C60:  MOVF   01,W
05C62:  ADDLW  28
05C64:  MOVLB  5
05C66:  MOVWF  xCB
05C68:  MOVLW  04
05C6A:  ADDWFC 02,W
05C6C:  MOVWF  xCC
05C6E:  MOVLW  01
05C70:  SUBWF  xCA,W
05C72:  MULLW  18
05C74:  MOVF   FF3,W
05C76:  CLRF   xCE
05C78:  MOVWF  xCD
05C7A:  MOVLW  14
05C7C:  ADDWF  xCD,W
05C7E:  MOVWF  01
05C80:  MOVLW  00
05C82:  ADDWFC xCE,W
05C84:  MOVWF  03
05C86:  MOVF   01,W
05C88:  ADDLW  82
05C8A:  MOVWF  FE9
05C8C:  MOVLW  00
05C8E:  ADDWFC 03,W
05C90:  MOVWF  FEA
05C92:  MOVFF  FEF,5D5
05C96:  MOVFF  FEC,5D6
05C9A:  MOVFF  FEC,5D7
05C9E:  MOVFF  FEC,5D8
05CA2:  MOVFF  5CC,4CD
05CA6:  MOVFF  5CB,4CC
05CAA:  MOVLW  89
05CAC:  MOVWF  FE9
05CAE:  MOVLW  02
05CB0:  MOVWF  xD9
05CB2:  MOVLB  0
05CB4:  CALL   4B82
05CB8:  MOVLW  2C
05CBA:  MOVLB  5
05CBC:  MOVWF  xE2
05CBE:  MOVLB  0
05CC0:  CALL   3E76
....................    
....................    return SUCCESS;
05CC4:  MOVLW  00
05CC6:  MOVWF  01
05CC8:  RETURN 0
.................... }
.................... 
.................... int8 getSensorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
05CCA:  MOVLB  5
05CCC:  CLRF   xE3
05CCE:  MOVFF  5BE,5E2
05CD2:  CLRF   xE5
05CD4:  MOVLW  B5
05CD6:  MOVWF  xE4
05CD8:  MOVLB  0
05CDA:  CALL   07CC
05CDE:  MOVFF  02,5CD
05CE2:  MOVFF  01,5CC
05CE6:  MOVLW  06
05CE8:  MOVLB  5
05CEA:  ADDWF  xCC,F
05CEC:  MOVLW  00
05CEE:  ADDWFC xCD,F
05CF0:  MOVLW  32
05CF2:  ADDWF  xCC,W
05CF4:  MOVWF  01
05CF6:  MOVLW  00
05CF8:  ADDWFC xCD,W
05CFA:  MOVWF  03
05CFC:  MOVF   01,W
05CFE:  ADDLW  52
05D00:  MOVWF  01
05D02:  MOVLW  01
05D04:  ADDWFC 03,F
05D06:  MOVFF  01,5CC
05D0A:  MOVFF  03,5CD
05D0E:  MOVFF  03,5E5
05D12:  MOVFF  01,5E4
05D16:  MOVLB  0
05D18:  CALL   3F3E
05D1C:  MOVF   01,F
05D1E:  BNZ   5D28
05D20:  MOVLW  02
05D22:  MOVWF  01
05D24:  BRA    611C
05D26:  BRA    5D86
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
05D28:  MOVLB  5
05D2A:  CLRF   xE3
05D2C:  MOVFF  5BE,5E2
05D30:  CLRF   xE5
05D32:  MOVLW  B5
05D34:  MOVWF  xE4
05D36:  MOVLB  0
05D38:  CALL   07CC
05D3C:  MOVFF  02,5CD
05D40:  MOVFF  01,5CC
05D44:  MOVLW  06
05D46:  MOVLB  5
05D48:  ADDWF  xCC,F
05D4A:  MOVLW  00
05D4C:  ADDWFC xCD,F
05D4E:  MOVLW  32
05D50:  ADDWF  xCC,W
05D52:  MOVWF  01
05D54:  MOVLW  00
05D56:  ADDWFC xCD,W
05D58:  MOVWF  03
05D5A:  MOVF   01,W
05D5C:  ADDLW  52
05D5E:  MOVWF  01
05D60:  MOVLW  01
05D62:  ADDWFC 03,F
05D64:  MOVFF  01,5CC
05D68:  MOVFF  03,5CD
05D6C:  MOVFF  03,5E5
05D70:  MOVFF  01,5E4
05D74:  CLRF   xE7
05D76:  CLRF   xE6
05D78:  MOVLW  0A
05D7A:  MOVWF  xE8
05D7C:  MOVLB  0
05D7E:  CALL   402E
05D82:  MOVFF  01,5CA
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
05D86:  MOVLB  5
05D88:  CLRF   xE3
05D8A:  MOVFF  5BE,5E2
05D8E:  CLRF   xE5
05D90:  MOVLW  B5
05D92:  MOVWF  xE4
05D94:  MOVLB  0
05D96:  CALL   07CC
05D9A:  MOVFF  02,5CD
05D9E:  MOVFF  01,5CC
05DA2:  MOVLW  06
05DA4:  MOVLB  5
05DA6:  ADDWF  xCC,F
05DA8:  MOVLW  00
05DAA:  ADDWFC xCD,F
05DAC:  MOVLW  4B
05DAE:  ADDWF  xCC,W
05DB0:  MOVWF  01
05DB2:  MOVLW  00
05DB4:  ADDWFC xCD,W
05DB6:  MOVWF  03
05DB8:  MOVF   01,W
05DBA:  ADDLW  52
05DBC:  MOVWF  01
05DBE:  MOVLW  01
05DC0:  ADDWFC 03,F
05DC2:  MOVFF  01,5CC
05DC6:  MOVFF  03,5CD
05DCA:  MOVFF  03,5E7
05DCE:  MOVFF  01,5E6
05DD2:  MOVLB  0
05DD4:  CALL   3DC6
05DD8:  MOVFF  02,03
05DDC:  MOVF   01,W
05DDE:  SUBLW  01
05DE0:  BNZ   5DE6
05DE2:  MOVF   03,F
05DE4:  BZ    5DEE
05DE6:  MOVLW  02
05DE8:  MOVWF  01
05DEA:  BRA    611C
05DEC:  BRA    5E2E
....................    else arg2 = SERcmd[rec].p[3][0];
05DEE:  MOVLB  5
05DF0:  CLRF   xE3
05DF2:  MOVFF  5BE,5E2
05DF6:  CLRF   xE5
05DF8:  MOVLW  B5
05DFA:  MOVWF  xE4
05DFC:  MOVLB  0
05DFE:  CALL   07CC
05E02:  MOVFF  02,5CD
05E06:  MOVFF  01,5CC
05E0A:  MOVLW  06
05E0C:  MOVLB  5
05E0E:  ADDWF  xCC,F
05E10:  MOVLW  00
05E12:  ADDWFC xCD,F
05E14:  MOVLW  4B
05E16:  ADDWF  xCC,F
05E18:  MOVLW  00
05E1A:  ADDWFC xCD,F
05E1C:  MOVLW  52
05E1E:  ADDWF  xCC,W
05E20:  MOVWF  FE9
05E22:  MOVLW  01
05E24:  ADDWFC xCD,W
05E26:  MOVWF  FEA
05E28:  MOVFF  FEF,5CB
05E2C:  MOVLB  0
....................    
....................    /*** GET SENSOR CAL PARAM **********/
....................    if      ('0' == arg2) sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c0);
05E2E:  MOVLB  5
05E30:  MOVF   xCB,W
05E32:  SUBLW  30
05E34:  BNZ   5EA4
05E36:  MOVLW  04
05E38:  MOVWF  xE7
05E3A:  MOVLW  28
05E3C:  MOVWF  xE6
05E3E:  MOVLB  0
05E40:  CALL   3DC6
05E44:  MOVFF  02,03
05E48:  MOVF   01,W
05E4A:  ADDLW  28
05E4C:  MOVLB  5
05E4E:  MOVWF  xCC
05E50:  MOVLW  04
05E52:  ADDWFC 02,W
05E54:  MOVWF  xCD
05E56:  MOVLW  01
05E58:  SUBWF  xCA,W
05E5A:  MULLW  18
05E5C:  MOVF   FF3,W
05E5E:  CLRF   xCF
05E60:  MOVWF  xCE
05E62:  MOVLW  82
05E64:  ADDWF  xCE,W
05E66:  MOVWF  FE9
05E68:  MOVLW  00
05E6A:  ADDWFC xCF,W
05E6C:  MOVWF  FEA
05E6E:  MOVFF  FEF,5D5
05E72:  MOVFF  FEC,5D6
05E76:  MOVFF  FEC,5D7
05E7A:  MOVFF  FEC,5D8
05E7E:  MOVFF  5CD,4CD
05E82:  MOVFF  5CC,4CC
05E86:  MOVLW  89
05E88:  MOVWF  FE9
05E8A:  MOVLW  02
05E8C:  MOVWF  xD9
05E8E:  MOVLB  0
05E90:  CALL   4B82
05E94:  MOVLW  2C
05E96:  MOVLB  5
05E98:  MOVWF  xE2
05E9A:  MOVLB  0
05E9C:  CALL   3E76
05EA0:  BRA    6118
05EA2:  MOVLB  5
....................    else if ('1' == arg2) sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c1);
05EA4:  MOVF   xCB,W
05EA6:  SUBLW  31
05EA8:  BNZ   5F20
05EAA:  MOVLW  04
05EAC:  MOVWF  xE7
05EAE:  MOVLW  28
05EB0:  MOVWF  xE6
05EB2:  MOVLB  0
05EB4:  CALL   3DC6
05EB8:  MOVF   01,W
05EBA:  ADDLW  28
05EBC:  MOVLB  5
05EBE:  MOVWF  xCC
05EC0:  MOVLW  04
05EC2:  ADDWFC 02,W
05EC4:  MOVWF  xCD
05EC6:  MOVLW  01
05EC8:  SUBWF  xCA,W
05ECA:  MULLW  18
05ECC:  MOVF   FF3,W
05ECE:  CLRF   xCF
05ED0:  MOVWF  xCE
05ED2:  MOVLW  04
05ED4:  ADDWF  xCE,W
05ED6:  MOVWF  01
05ED8:  MOVLW  00
05EDA:  ADDWFC xCF,W
05EDC:  MOVWF  03
05EDE:  MOVF   01,W
05EE0:  ADDLW  82
05EE2:  MOVWF  FE9
05EE4:  MOVLW  00
05EE6:  ADDWFC 03,W
05EE8:  MOVWF  FEA
05EEA:  MOVFF  FEF,5D5
05EEE:  MOVFF  FEC,5D6
05EF2:  MOVFF  FEC,5D7
05EF6:  MOVFF  FEC,5D8
05EFA:  MOVFF  5CD,4CD
05EFE:  MOVFF  5CC,4CC
05F02:  MOVLW  89
05F04:  MOVWF  FE9
05F06:  MOVLW  02
05F08:  MOVWF  xD9
05F0A:  MOVLB  0
05F0C:  CALL   4B82
05F10:  MOVLW  2C
05F12:  MOVLB  5
05F14:  MOVWF  xE2
05F16:  MOVLB  0
05F18:  CALL   3E76
05F1C:  BRA    6118
05F1E:  MOVLB  5
....................    else if ('2' == arg2) sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c2);
05F20:  MOVF   xCB,W
05F22:  SUBLW  32
05F24:  BNZ   5F9C
05F26:  MOVLW  04
05F28:  MOVWF  xE7
05F2A:  MOVLW  28
05F2C:  MOVWF  xE6
05F2E:  MOVLB  0
05F30:  CALL   3DC6
05F34:  MOVF   01,W
05F36:  ADDLW  28
05F38:  MOVLB  5
05F3A:  MOVWF  xCC
05F3C:  MOVLW  04
05F3E:  ADDWFC 02,W
05F40:  MOVWF  xCD
05F42:  MOVLW  01
05F44:  SUBWF  xCA,W
05F46:  MULLW  18
05F48:  MOVF   FF3,W
05F4A:  CLRF   xCF
05F4C:  MOVWF  xCE
05F4E:  MOVLW  08
05F50:  ADDWF  xCE,W
05F52:  MOVWF  01
05F54:  MOVLW  00
05F56:  ADDWFC xCF,W
05F58:  MOVWF  03
05F5A:  MOVF   01,W
05F5C:  ADDLW  82
05F5E:  MOVWF  FE9
05F60:  MOVLW  00
05F62:  ADDWFC 03,W
05F64:  MOVWF  FEA
05F66:  MOVFF  FEF,5D5
05F6A:  MOVFF  FEC,5D6
05F6E:  MOVFF  FEC,5D7
05F72:  MOVFF  FEC,5D8
05F76:  MOVFF  5CD,4CD
05F7A:  MOVFF  5CC,4CC
05F7E:  MOVLW  89
05F80:  MOVWF  FE9
05F82:  MOVLW  02
05F84:  MOVWF  xD9
05F86:  MOVLB  0
05F88:  CALL   4B82
05F8C:  MOVLW  2C
05F8E:  MOVLB  5
05F90:  MOVWF  xE2
05F92:  MOVLB  0
05F94:  CALL   3E76
05F98:  BRA    6118
05F9A:  MOVLB  5
....................    else if ('3' == arg2) sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c3);
05F9C:  MOVF   xCB,W
05F9E:  SUBLW  33
05FA0:  BNZ   6018
05FA2:  MOVLW  04
05FA4:  MOVWF  xE7
05FA6:  MOVLW  28
05FA8:  MOVWF  xE6
05FAA:  MOVLB  0
05FAC:  CALL   3DC6
05FB0:  MOVF   01,W
05FB2:  ADDLW  28
05FB4:  MOVLB  5
05FB6:  MOVWF  xCC
05FB8:  MOVLW  04
05FBA:  ADDWFC 02,W
05FBC:  MOVWF  xCD
05FBE:  MOVLW  01
05FC0:  SUBWF  xCA,W
05FC2:  MULLW  18
05FC4:  MOVF   FF3,W
05FC6:  CLRF   xCF
05FC8:  MOVWF  xCE
05FCA:  MOVLW  0C
05FCC:  ADDWF  xCE,W
05FCE:  MOVWF  01
05FD0:  MOVLW  00
05FD2:  ADDWFC xCF,W
05FD4:  MOVWF  03
05FD6:  MOVF   01,W
05FD8:  ADDLW  82
05FDA:  MOVWF  FE9
05FDC:  MOVLW  00
05FDE:  ADDWFC 03,W
05FE0:  MOVWF  FEA
05FE2:  MOVFF  FEF,5D5
05FE6:  MOVFF  FEC,5D6
05FEA:  MOVFF  FEC,5D7
05FEE:  MOVFF  FEC,5D8
05FF2:  MOVFF  5CD,4CD
05FF6:  MOVFF  5CC,4CC
05FFA:  MOVLW  89
05FFC:  MOVWF  FE9
05FFE:  MOVLW  02
06000:  MOVWF  xD9
06002:  MOVLB  0
06004:  CALL   4B82
06008:  MOVLW  2C
0600A:  MOVLB  5
0600C:  MOVWF  xE2
0600E:  MOVLB  0
06010:  CALL   3E76
06014:  BRA    6118
06016:  MOVLB  5
....................    else if ('4' == arg2) sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c4);
06018:  MOVF   xCB,W
0601A:  SUBLW  34
0601C:  BNZ   6094
0601E:  MOVLW  04
06020:  MOVWF  xE7
06022:  MOVLW  28
06024:  MOVWF  xE6
06026:  MOVLB  0
06028:  CALL   3DC6
0602C:  MOVF   01,W
0602E:  ADDLW  28
06030:  MOVLB  5
06032:  MOVWF  xCC
06034:  MOVLW  04
06036:  ADDWFC 02,W
06038:  MOVWF  xCD
0603A:  MOVLW  01
0603C:  SUBWF  xCA,W
0603E:  MULLW  18
06040:  MOVF   FF3,W
06042:  CLRF   xCF
06044:  MOVWF  xCE
06046:  MOVLW  10
06048:  ADDWF  xCE,W
0604A:  MOVWF  01
0604C:  MOVLW  00
0604E:  ADDWFC xCF,W
06050:  MOVWF  03
06052:  MOVF   01,W
06054:  ADDLW  82
06056:  MOVWF  FE9
06058:  MOVLW  00
0605A:  ADDWFC 03,W
0605C:  MOVWF  FEA
0605E:  MOVFF  FEF,5D5
06062:  MOVFF  FEC,5D6
06066:  MOVFF  FEC,5D7
0606A:  MOVFF  FEC,5D8
0606E:  MOVFF  5CD,4CD
06072:  MOVFF  5CC,4CC
06076:  MOVLW  89
06078:  MOVWF  FE9
0607A:  MOVLW  02
0607C:  MOVWF  xD9
0607E:  MOVLB  0
06080:  CALL   4B82
06084:  MOVLW  2C
06086:  MOVLB  5
06088:  MOVWF  xE2
0608A:  MOVLB  0
0608C:  CALL   3E76
06090:  BRA    6118
06092:  MOVLB  5
....................    else if ('5' == arg2) sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c5);
06094:  MOVF   xCB,W
06096:  SUBLW  35
06098:  BNZ   6110
0609A:  MOVLW  04
0609C:  MOVWF  xE7
0609E:  MOVLW  28
060A0:  MOVWF  xE6
060A2:  MOVLB  0
060A4:  CALL   3DC6
060A8:  MOVF   01,W
060AA:  ADDLW  28
060AC:  MOVLB  5
060AE:  MOVWF  xCC
060B0:  MOVLW  04
060B2:  ADDWFC 02,W
060B4:  MOVWF  xCD
060B6:  MOVLW  01
060B8:  SUBWF  xCA,W
060BA:  MULLW  18
060BC:  MOVF   FF3,W
060BE:  CLRF   xCF
060C0:  MOVWF  xCE
060C2:  MOVLW  14
060C4:  ADDWF  xCE,W
060C6:  MOVWF  01
060C8:  MOVLW  00
060CA:  ADDWFC xCF,W
060CC:  MOVWF  03
060CE:  MOVF   01,W
060D0:  ADDLW  82
060D2:  MOVWF  FE9
060D4:  MOVLW  00
060D6:  ADDWFC 03,W
060D8:  MOVWF  FEA
060DA:  MOVFF  FEF,5D5
060DE:  MOVFF  FEC,5D6
060E2:  MOVFF  FEC,5D7
060E6:  MOVFF  FEC,5D8
060EA:  MOVFF  5CD,4CD
060EE:  MOVFF  5CC,4CC
060F2:  MOVLW  89
060F4:  MOVWF  FE9
060F6:  MOVLW  02
060F8:  MOVWF  xD9
060FA:  MOVLB  0
060FC:  CALL   4B82
06100:  MOVLW  2C
06102:  MOVLB  5
06104:  MOVWF  xE2
06106:  MOVLB  0
06108:  CALL   3E76
0610C:  BRA    6118
0610E:  MOVLB  5
....................    else return INV_PARAM;
06110:  MOVLW  02
06112:  MOVWF  01
06114:  MOVLB  0
06116:  BRA    611C
....................    
....................    return SUCCESS;
06118:  MOVLW  00
0611A:  MOVWF  01
0611C:  RETURN 0
.................... }
.................... 
.................... int8 setSensorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char  arg2;
....................    float arg3;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0611E:  MOVLB  5
06120:  CLRF   xE3
06122:  MOVFF  5BE,5E2
06126:  CLRF   xE5
06128:  MOVLW  B5
0612A:  MOVWF  xE4
0612C:  MOVLB  0
0612E:  CALL   07CC
06132:  MOVFF  02,5D1
06136:  MOVFF  01,5D0
0613A:  MOVLW  06
0613C:  MOVLB  5
0613E:  ADDWF  xD0,F
06140:  MOVLW  00
06142:  ADDWFC xD1,F
06144:  MOVLW  32
06146:  ADDWF  xD0,W
06148:  MOVWF  01
0614A:  MOVLW  00
0614C:  ADDWFC xD1,W
0614E:  MOVWF  03
06150:  MOVF   01,W
06152:  ADDLW  52
06154:  MOVWF  01
06156:  MOVLW  01
06158:  ADDWFC 03,F
0615A:  MOVFF  01,5D0
0615E:  MOVFF  03,5D1
06162:  MOVFF  03,5E5
06166:  MOVFF  01,5E4
0616A:  MOVLB  0
0616C:  CALL   3F3E
06170:  MOVF   01,F
06172:  BNZ   617C
06174:  MOVLW  02
06176:  MOVWF  01
06178:  BRA    64E0
0617A:  BRA    61DA
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
0617C:  MOVLB  5
0617E:  CLRF   xE3
06180:  MOVFF  5BE,5E2
06184:  CLRF   xE5
06186:  MOVLW  B5
06188:  MOVWF  xE4
0618A:  MOVLB  0
0618C:  CALL   07CC
06190:  MOVFF  02,5D1
06194:  MOVFF  01,5D0
06198:  MOVLW  06
0619A:  MOVLB  5
0619C:  ADDWF  xD0,F
0619E:  MOVLW  00
061A0:  ADDWFC xD1,F
061A2:  MOVLW  32
061A4:  ADDWF  xD0,W
061A6:  MOVWF  01
061A8:  MOVLW  00
061AA:  ADDWFC xD1,W
061AC:  MOVWF  03
061AE:  MOVF   01,W
061B0:  ADDLW  52
061B2:  MOVWF  01
061B4:  MOVLW  01
061B6:  ADDWFC 03,F
061B8:  MOVFF  01,5D0
061BC:  MOVFF  03,5D1
061C0:  MOVFF  03,5E5
061C4:  MOVFF  01,5E4
061C8:  CLRF   xE7
061CA:  CLRF   xE6
061CC:  MOVLW  0A
061CE:  MOVWF  xE8
061D0:  MOVLB  0
061D2:  CALL   402E
061D6:  MOVFF  01,5CA
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
061DA:  MOVLB  5
061DC:  CLRF   xE3
061DE:  MOVFF  5BE,5E2
061E2:  CLRF   xE5
061E4:  MOVLW  B5
061E6:  MOVWF  xE4
061E8:  MOVLB  0
061EA:  CALL   07CC
061EE:  MOVFF  02,5D1
061F2:  MOVFF  01,5D0
061F6:  MOVLW  06
061F8:  MOVLB  5
061FA:  ADDWF  xD0,F
061FC:  MOVLW  00
061FE:  ADDWFC xD1,F
06200:  MOVLW  4B
06202:  ADDWF  xD0,W
06204:  MOVWF  01
06206:  MOVLW  00
06208:  ADDWFC xD1,W
0620A:  MOVWF  03
0620C:  MOVF   01,W
0620E:  ADDLW  52
06210:  MOVWF  01
06212:  MOVLW  01
06214:  ADDWFC 03,F
06216:  MOVFF  01,5D0
0621A:  MOVFF  03,5D1
0621E:  MOVFF  03,5E7
06222:  MOVFF  01,5E6
06226:  MOVLB  0
06228:  CALL   3DC6
0622C:  MOVFF  02,03
06230:  MOVF   01,W
06232:  SUBLW  01
06234:  BNZ   623A
06236:  MOVF   03,F
06238:  BZ    6242
0623A:  MOVLW  02
0623C:  MOVWF  01
0623E:  BRA    64E0
06240:  BRA    6282
....................    else arg2 = SERcmd[rec].p[3][0];
06242:  MOVLB  5
06244:  CLRF   xE3
06246:  MOVFF  5BE,5E2
0624A:  CLRF   xE5
0624C:  MOVLW  B5
0624E:  MOVWF  xE4
06250:  MOVLB  0
06252:  CALL   07CC
06256:  MOVFF  02,5D1
0625A:  MOVFF  01,5D0
0625E:  MOVLW  06
06260:  MOVLB  5
06262:  ADDWF  xD0,F
06264:  MOVLW  00
06266:  ADDWFC xD1,F
06268:  MOVLW  4B
0626A:  ADDWF  xD0,F
0626C:  MOVLW  00
0626E:  ADDWFC xD1,F
06270:  MOVLW  52
06272:  ADDWF  xD0,W
06274:  MOVWF  FE9
06276:  MOVLW  01
06278:  ADDWFC xD1,W
0627A:  MOVWF  FEA
0627C:  MOVFF  FEF,5CB
06280:  MOVLB  0
....................    
....................    if (!arg_is_float(strtod(SERcmd[rec].p[3], '\0'))) return INV_PARAM;
06282:  MOVLB  5
06284:  CLRF   xE3
06286:  MOVFF  5BE,5E2
0628A:  CLRF   xE5
0628C:  MOVLW  B5
0628E:  MOVWF  xE4
06290:  MOVLB  0
06292:  CALL   07CC
06296:  MOVFF  02,5D1
0629A:  MOVFF  01,5D0
0629E:  MOVLW  06
062A0:  MOVLB  5
062A2:  ADDWF  xD0,F
062A4:  MOVLW  00
062A6:  ADDWFC xD1,F
062A8:  MOVLW  4B
062AA:  ADDWF  xD0,W
062AC:  MOVWF  01
062AE:  MOVLW  00
062B0:  ADDWFC xD1,W
062B2:  MOVWF  03
062B4:  MOVF   01,W
062B6:  ADDLW  52
062B8:  MOVWF  01
062BA:  MOVLW  01
062BC:  ADDWFC 03,F
062BE:  MOVFF  01,5D0
062C2:  MOVFF  03,5D1
062C6:  MOVFF  03,5D4
062CA:  MOVFF  01,5D3
062CE:  CLRF   xD6
062D0:  CLRF   xD5
062D2:  MOVLB  0
062D4:  CALL   500E
062D8:  MOVFF  03,616
062DC:  MOVFF  02,615
062E0:  MOVFF  01,614
062E4:  MOVFF  00,613
062E8:  CALL   1CDA
062EC:  MOVFF  02,5D1
062F0:  MOVFF  01,5D0
062F4:  MOVFF  02,5D4
062F8:  MOVFF  01,5D3
062FC:  CALL   526E
06300:  MOVF   01,F
06302:  BNZ   630C
06304:  MOVLW  02
06306:  MOVWF  01
06308:  BRA    64E0
0630A:  BRA    6372
....................    else arg3 = strtod(SERcmd[rec].p[4], '\0');
0630C:  MOVLB  5
0630E:  CLRF   xE3
06310:  MOVFF  5BE,5E2
06314:  CLRF   xE5
06316:  MOVLW  B5
06318:  MOVWF  xE4
0631A:  MOVLB  0
0631C:  CALL   07CC
06320:  MOVFF  02,5D1
06324:  MOVFF  01,5D0
06328:  MOVLW  06
0632A:  MOVLB  5
0632C:  ADDWF  xD0,F
0632E:  MOVLW  00
06330:  ADDWFC xD1,F
06332:  MOVLW  64
06334:  ADDWF  xD0,W
06336:  MOVWF  01
06338:  MOVLW  00
0633A:  ADDWFC xD1,W
0633C:  MOVWF  03
0633E:  MOVF   01,W
06340:  ADDLW  52
06342:  MOVWF  01
06344:  MOVLW  01
06346:  ADDWFC 03,F
06348:  MOVFF  01,5D0
0634C:  MOVFF  03,5D1
06350:  MOVFF  03,5D4
06354:  MOVFF  01,5D3
06358:  CLRF   xD6
0635A:  CLRF   xD5
0635C:  MOVLB  0
0635E:  CALL   500E
06362:  MOVFF  03,5CF
06366:  MOVFF  02,5CE
0636A:  MOVFF  01,5CD
0636E:  MOVFF  00,5CC
....................    
....................    /*** SET SENSOR CAL PARAM **********/
....................    if      ('0' == arg2) sensorCal[arg1-1].c0 = arg3;
06372:  MOVLB  5
06374:  MOVF   xCB,W
06376:  SUBLW  30
06378:  BNZ   63A4
0637A:  MOVLW  01
0637C:  SUBWF  xCA,W
0637E:  MULLW  18
06380:  MOVF   FF3,W
06382:  CLRF   xD1
06384:  MOVWF  xD0
06386:  MOVLW  82
06388:  ADDWF  xD0,W
0638A:  MOVWF  FE9
0638C:  MOVLW  00
0638E:  ADDWFC xD1,W
06390:  MOVWF  FEA
06392:  MOVFF  5CC,FEF
06396:  MOVFF  5CD,FEC
0639A:  MOVFF  5CE,FEC
0639E:  MOVFF  5CF,FEC
063A2:  BRA    64DA
....................    else if ('1' == arg2) sensorCal[arg1-1].c1 = arg3;
063A4:  MOVF   xCB,W
063A6:  SUBLW  31
063A8:  BNZ   63E0
063AA:  MOVLW  01
063AC:  SUBWF  xCA,W
063AE:  MULLW  18
063B0:  MOVF   FF3,W
063B2:  CLRF   xD1
063B4:  MOVWF  xD0
063B6:  MOVLW  04
063B8:  ADDWF  xD0,W
063BA:  MOVWF  01
063BC:  MOVLW  00
063BE:  ADDWFC xD1,W
063C0:  MOVWF  03
063C2:  MOVF   01,W
063C4:  ADDLW  82
063C6:  MOVWF  FE9
063C8:  MOVLW  00
063CA:  ADDWFC 03,W
063CC:  MOVWF  FEA
063CE:  MOVFF  5CC,FEF
063D2:  MOVFF  5CD,FEC
063D6:  MOVFF  5CE,FEC
063DA:  MOVFF  5CF,FEC
063DE:  BRA    64DA
....................    else if ('2' == arg2) sensorCal[arg1-1].c2 = arg3;
063E0:  MOVF   xCB,W
063E2:  SUBLW  32
063E4:  BNZ   641C
063E6:  MOVLW  01
063E8:  SUBWF  xCA,W
063EA:  MULLW  18
063EC:  MOVF   FF3,W
063EE:  CLRF   xD1
063F0:  MOVWF  xD0
063F2:  MOVLW  08
063F4:  ADDWF  xD0,W
063F6:  MOVWF  01
063F8:  MOVLW  00
063FA:  ADDWFC xD1,W
063FC:  MOVWF  03
063FE:  MOVF   01,W
06400:  ADDLW  82
06402:  MOVWF  FE9
06404:  MOVLW  00
06406:  ADDWFC 03,W
06408:  MOVWF  FEA
0640A:  MOVFF  5CC,FEF
0640E:  MOVFF  5CD,FEC
06412:  MOVFF  5CE,FEC
06416:  MOVFF  5CF,FEC
0641A:  BRA    64DA
....................    else if ('3' == arg2) sensorCal[arg1-1].c3 = arg3;
0641C:  MOVF   xCB,W
0641E:  SUBLW  33
06420:  BNZ   6458
06422:  MOVLW  01
06424:  SUBWF  xCA,W
06426:  MULLW  18
06428:  MOVF   FF3,W
0642A:  CLRF   xD1
0642C:  MOVWF  xD0
0642E:  MOVLW  0C
06430:  ADDWF  xD0,W
06432:  MOVWF  01
06434:  MOVLW  00
06436:  ADDWFC xD1,W
06438:  MOVWF  03
0643A:  MOVF   01,W
0643C:  ADDLW  82
0643E:  MOVWF  FE9
06440:  MOVLW  00
06442:  ADDWFC 03,W
06444:  MOVWF  FEA
06446:  MOVFF  5CC,FEF
0644A:  MOVFF  5CD,FEC
0644E:  MOVFF  5CE,FEC
06452:  MOVFF  5CF,FEC
06456:  BRA    64DA
....................    else if ('4' == arg2) sensorCal[arg1-1].c4 = arg3;
06458:  MOVF   xCB,W
0645A:  SUBLW  34
0645C:  BNZ   6494
0645E:  MOVLW  01
06460:  SUBWF  xCA,W
06462:  MULLW  18
06464:  MOVF   FF3,W
06466:  CLRF   xD1
06468:  MOVWF  xD0
0646A:  MOVLW  10
0646C:  ADDWF  xD0,W
0646E:  MOVWF  01
06470:  MOVLW  00
06472:  ADDWFC xD1,W
06474:  MOVWF  03
06476:  MOVF   01,W
06478:  ADDLW  82
0647A:  MOVWF  FE9
0647C:  MOVLW  00
0647E:  ADDWFC 03,W
06480:  MOVWF  FEA
06482:  MOVFF  5CC,FEF
06486:  MOVFF  5CD,FEC
0648A:  MOVFF  5CE,FEC
0648E:  MOVFF  5CF,FEC
06492:  BRA    64DA
....................    else if ('5' == arg2) sensorCal[arg1-1].c5 = arg3;
06494:  MOVF   xCB,W
06496:  SUBLW  35
06498:  BNZ   64D0
0649A:  MOVLW  01
0649C:  SUBWF  xCA,W
0649E:  MULLW  18
064A0:  MOVF   FF3,W
064A2:  CLRF   xD1
064A4:  MOVWF  xD0
064A6:  MOVLW  14
064A8:  ADDWF  xD0,W
064AA:  MOVWF  01
064AC:  MOVLW  00
064AE:  ADDWFC xD1,W
064B0:  MOVWF  03
064B2:  MOVF   01,W
064B4:  ADDLW  82
064B6:  MOVWF  FE9
064B8:  MOVLW  00
064BA:  ADDWFC 03,W
064BC:  MOVWF  FEA
064BE:  MOVFF  5CC,FEF
064C2:  MOVFF  5CD,FEC
064C6:  MOVFF  5CE,FEC
064CA:  MOVFF  5CF,FEC
064CE:  BRA    64DA
....................    else return INV_PARAM;
064D0:  MOVLW  02
064D2:  MOVWF  01
064D4:  MOVLB  0
064D6:  BRA    64E0
064D8:  MOVLB  5
....................    
....................    return SUCCESS;
064DA:  MOVLW  00
064DC:  MOVWF  01
064DE:  MOVLB  0
064E0:  RETURN 0
.................... }
.................... 
.................... int8 getMonitorCalParam(unsigned int8 rec){
....................    
....................    return SUCCESS;
064E2:  MOVLW  00
064E4:  MOVWF  01
064E6:  RETURN 0
.................... }
.................... 
.................... int8 setMonitorCalParam(unsigned int8 rec){
.................... 
....................    return SUCCESS;
064E8:  MOVLW  00
064EA:  MOVWF  01
064EC:  RETURN 0
.................... }
.................... 
.................... int8 getMonitorValue(unsigned int8 rec){
....................    
....................    return SUCCESS;
064EE:  MOVLW  00
064F0:  MOVWF  01
064F2:  RETURN 0
.................... }
.................... 
.................... int8 getPIDdata(unsigned int8 rec){
....................    
....................    return SUCCESS;
064F4:  MOVLW  00
064F6:  MOVWF  01
064F8:  RETURN 0
.................... }
.................... 
.................... int8 getIPdata(unsigned int8 rec){
....................    
....................    return SUCCESS;
064FA:  MOVLW  00
064FC:  MOVWF  01
064FE:  RETURN 0
.................... }
.................... 
.................... int8 invalidCmd(unsigned int8 rec){
.................... 
....................    return INV_CMD;
06500:  MOVLW  01
06502:  MOVWF  01
06504:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* ARG VALIDATION HELPER FUNCS                                               */
.................... /*****************************************************************************/
.................... BOOLEAN arg_is_float(char *arg){
*
0526E:  MOVLB  5
05270:  BCF    xD5.0
....................    BOOLEAN decimal = FALSE;
....................    for (int i=0; i<strlen(arg); i++){
05272:  CLRF   xD6
05274:  MOVFF  5D4,5E7
05278:  MOVFF  5D3,5E6
0527C:  MOVLB  0
0527E:  CALL   3DC6
05282:  MOVFF  02,03
05286:  MOVF   01,W
05288:  MOVF   03,F
0528A:  BNZ   5296
0528C:  MOVF   01,W
0528E:  MOVLB  5
05290:  SUBWF  xD6,W
05292:  BC    5328
05294:  MOVLB  0
....................       if (!isdigit(arg[i])){
05296:  MOVLB  5
05298:  MOVF   xD6,W
0529A:  ADDWF  xD3,W
0529C:  MOVWF  FE9
0529E:  MOVLW  00
052A0:  ADDWFC xD4,W
052A2:  MOVWF  FEA
052A4:  MOVFF  FEF,5D7
052A8:  MOVF   xD7,W
052AA:  SUBLW  2F
052AC:  BC    52B4
052AE:  MOVF   xD7,W
052B0:  SUBLW  39
052B2:  BC    5320
....................          // Check for negative sign
....................          if ('-' != arg[i]){
052B4:  MOVF   xD6,W
052B6:  ADDWF  xD3,W
052B8:  MOVWF  FE9
052BA:  MOVLW  00
052BC:  ADDWFC xD4,W
052BE:  MOVWF  FEA
052C0:  MOVF   FEF,W
052C2:  SUBLW  2D
052C4:  BZ    52F0
....................             // Check for decimal
....................             if ('.' != arg[i]) return FALSE;
052C6:  MOVF   xD6,W
052C8:  ADDWF  xD3,W
052CA:  MOVWF  FE9
052CC:  MOVLW  00
052CE:  ADDWFC xD4,W
052D0:  MOVWF  FEA
052D2:  MOVF   FEF,W
052D4:  SUBLW  2E
052D6:  BZ    52E0
052D8:  MOVLW  00
052DA:  MOVWF  01
052DC:  BRA    532C
052DE:  BRA    52EE
....................             else if  (decimal) return FALSE;
052E0:  BTFSS  xD5.0
052E2:  BRA    52EC
052E4:  MOVLW  00
052E6:  MOVWF  01
052E8:  BRA    532C
052EA:  BRA    52EE
....................             else decimal = TRUE;
052EC:  BSF    xD5.0
....................          }
052EE:  BRA    5320
....................          else if (0 != i) return FALSE;
052F0:  MOVF   xD6,F
052F2:  BZ    52FC
052F4:  MOVLW  00
052F6:  MOVWF  01
052F8:  BRA    532C
052FA:  BRA    5320
....................          else if (1 == strlen(arg)) return FALSE;
052FC:  MOVFF  5D4,5E7
05300:  MOVFF  5D3,5E6
05304:  MOVLB  0
05306:  CALL   3DC6
0530A:  MOVFF  02,03
0530E:  MOVF   01,W
05310:  SUBLW  01
05312:  BNZ   5322
05314:  MOVF   03,F
05316:  BNZ   5322
05318:  MOVLW  00
0531A:  MOVWF  01
0531C:  MOVLB  5
0531E:  BRA    532C
05320:  MOVLB  0
....................       }
05322:  MOVLB  5
05324:  INCF   xD6,F
05326:  BRA    5274
....................    }
....................    return TRUE;
05328:  MOVLW  01
0532A:  MOVWF  01
0532C:  MOVLB  0
0532E:  RETURN 0
.................... }
.................... 
.................... BOOLEAN is_valid_channel(char *arg){
....................     if (1 != strlen(arg)) return FALSE;
*
03F3E:  MOVFF  5E5,5E7
03F42:  MOVFF  5E4,5E6
03F46:  RCALL  3DC6
03F48:  MOVFF  02,03
03F4C:  MOVF   01,W
03F4E:  SUBLW  01
03F50:  BNZ   3F56
03F52:  MOVF   03,F
03F54:  BZ    3F5E
03F56:  MOVLW  00
03F58:  MOVWF  01
03F5A:  BRA    3F8C
03F5C:  BRA    3F84
....................     else if ('1' != arg[0] && '2' != arg[0]) return FALSE;
03F5E:  MOVLB  5
03F60:  MOVFF  5E4,FE9
03F64:  MOVFF  5E5,FEA
03F68:  MOVF   FEF,W
03F6A:  SUBLW  31
03F6C:  BZ    3F86
03F6E:  MOVFF  5E4,FE9
03F72:  MOVFF  5E5,FEA
03F76:  MOVF   FEF,W
03F78:  SUBLW  32
03F7A:  BZ    3F86
03F7C:  MOVLW  00
03F7E:  MOVWF  01
03F80:  MOVLB  0
03F82:  BRA    3F8C
03F84:  MOVLB  5
....................     return TRUE;
03F86:  MOVLW  01
03F88:  MOVWF  01
03F8A:  MOVLB  0
03F8C:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* ASCII HEX CHARACTER TO INT                                                */
.................... /*****************************************************************************/
.................... int8 hex_to_int(char ascii){
....................    if (ascii >= '0' && ascii <= '9') return ascii-'0';
*
03D8C:  MOVLB  5
03D8E:  MOVF   xC9,W
03D90:  SUBLW  2F
03D92:  BC    3DA4
03D94:  MOVF   xC9,W
03D96:  SUBLW  39
03D98:  BNC   3DA4
03D9A:  MOVLW  30
03D9C:  SUBWF  xC9,W
03D9E:  MOVWF  01
03DA0:  BRA    3DC0
03DA2:  BRA    3DC0
....................    else if (ascii >= 'A' && ascii <= 'F') return ascii-'A'+10;
03DA4:  MOVF   xC9,W
03DA6:  SUBLW  40
03DA8:  BC    3DBC
03DAA:  MOVF   xC9,W
03DAC:  SUBLW  46
03DAE:  BNC   3DBC
03DB0:  MOVLW  41
03DB2:  SUBWF  xC9,W
03DB4:  ADDLW  0A
03DB6:  MOVWF  01
03DB8:  BRA    3DC0
03DBA:  BRA    3DC0
....................    else return 0xFF;
03DBC:  MOVLW  FF
03DBE:  MOVWF  01
03DC0:  MOVLB  0
03DC2:  GOTO   65AA (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* COMMAND HANDLER/PARSER FUNCS                                              */
.................... /*****************************************************************************/
.................... void echo_cmd(unsigned int8 rec){
....................    fprintf(SERIAL, "%c", SERcmd[rec].t);
....................    while (SERcmd[rec].recReadIndex <= SERcmd[rec].recWriteIndex)
....................    {
....................       if (SERcmd[rec].recReadIndex != 0) fprintf(SERIAL, "%c", delimiter);
....................       fprintf(SERIAL, "%s", SERcmd[rec].p[SERcmd[rec].recReadIndex]);
....................       SERcmd[rec].recReadIndex++;
....................    }
....................    SERcmd[rec].recReadIndex=0;
.................... }
.................... 
.................... int8 command_parser(unsigned int8 rec){
*
06506:  MOVLB  5
06508:  CLRF   xE3
0650A:  MOVFF  5C0,5E2
0650E:  CLRF   xE5
06510:  MOVLW  B5
06512:  MOVWF  xE4
06514:  MOVLB  0
06516:  CALL   07CC
0651A:  MOVFF  02,5C9
0651E:  MOVFF  01,5C8
06522:  MOVLW  06
06524:  MOVLB  5
06526:  ADDWF  xC8,F
06528:  MOVLW  00
0652A:  ADDWFC xC9,F
0652C:  MOVLW  52
0652E:  ADDWF  xC8,W
06530:  MOVWF  01
06532:  MOVLW  01
06534:  ADDWFC xC9,W
06536:  MOVWF  03
06538:  MOVFF  01,5C1
0653C:  MOVWF  xC2
0653E:  CLRF   xE3
06540:  MOVFF  5C0,5E2
06544:  CLRF   xE5
06546:  MOVLW  B5
06548:  MOVWF  xE4
0654A:  MOVLB  0
0654C:  CALL   07CC
06550:  MOVFF  02,5CB
06554:  MOVFF  01,5CA
06558:  MOVLW  06
0655A:  MOVLB  5
0655C:  ADDWF  xCA,F
0655E:  MOVLW  00
06560:  ADDWFC xCB,F
06562:  MOVLW  19
06564:  ADDWF  xCA,W
06566:  MOVWF  01
06568:  MOVLW  00
0656A:  ADDWFC xCB,W
0656C:  MOVWF  03
0656E:  MOVF   01,W
06570:  ADDLW  52
06572:  MOVWF  01
06574:  MOVLW  01
06576:  ADDWFC 03,F
06578:  MOVFF  01,5C3
0657C:  MOVFF  03,5C4
06580:  CLRF   xC5
06582:  CLRF   xC6
....................    char *cmd_adr = SERcmd[rec].p[0];
....................    char *cmd_str = SERcmd[rec].p[1];
.................... //!   int8 devID = input_a();
....................    int8 devID = 0;
....................    int8 i = 0;
....................    
....................    if (hwID == cmd_adr[0]){
06584:  MOVFF  5C1,FE9
06588:  MOVFF  5C2,FEA
0658C:  MOVF   FEF,W
0658E:  SUBLW  44
06590:  BTFSS  FD8.2
06592:  BRA    6682
....................       if (hex_to_int(cmd_adr[1]) == (devID & 0x0F)){
06594:  MOVLW  01
06596:  ADDWF  xC1,W
06598:  MOVWF  FE9
0659A:  MOVLW  00
0659C:  ADDWFC xC2,W
0659E:  MOVWF  FEA
065A0:  MOVFF  FEF,5C9
065A4:  MOVLB  0
065A6:  GOTO   3D8C
065AA:  MOVFF  01,5C8
065AE:  MOVLB  5
065B0:  MOVF   xC5,W
065B2:  ANDLW  0F
065B4:  SUBWF  01,W
065B6:  BNZ   667A
....................          while (0 != strlen(cmd_list[i].cmd_name)){
065B8:  MOVF   xC6,W
065BA:  MULLW  04
065BC:  MOVF   FF3,W
065BE:  CLRF   xC9
065C0:  MOVWF  xC8
065C2:  MOVLW  D2
065C4:  ADDWF  xC8,W
065C6:  MOVWF  FE9
065C8:  MOVLW  04
065CA:  ADDWFC xC9,W
065CC:  MOVWF  FEA
065CE:  MOVFF  FEC,5E7
065D2:  MOVF   FED,F
065D4:  MOVFF  FEF,5E6
065D8:  MOVLB  0
065DA:  CALL   3DC6
065DE:  MOVFF  02,03
065E2:  MOVF   01,W
065E4:  BNZ   65EA
065E6:  MOVF   03,F
065E8:  BZ    6670
....................             if (0 == strcmp(cmd_str, cmd_list[i].cmd_name))
065EA:  MOVLB  5
065EC:  MOVF   xC6,W
065EE:  MULLW  04
065F0:  MOVF   FF3,W
065F2:  CLRF   xC9
065F4:  MOVWF  xC8
065F6:  MOVLW  D2
065F8:  ADDWF  xC8,W
065FA:  MOVWF  FE9
065FC:  MOVLW  04
065FE:  ADDWFC xC9,W
06600:  MOVWF  FEA
06602:  MOVFF  FEC,5E5
06606:  MOVF   FED,F
06608:  MOVFF  FEF,5E4
0660C:  MOVFF  5C4,5E3
06610:  MOVFF  5C3,5E2
06614:  MOVLB  0
06616:  CALL   3DFE
0661A:  MOVF   01,F
0661C:  BNZ   6668
....................             {
....................                int8 return_code = cmd_list[i].cmd_func(rec);
0661E:  MOVLB  5
06620:  MOVF   xC6,W
06622:  MULLW  04
06624:  MOVF   FF3,W
06626:  CLRF   xC9
06628:  MOVWF  xC8
0662A:  MOVLW  02
0662C:  ADDWF  xC8,W
0662E:  MOVWF  01
06630:  MOVLW  00
06632:  ADDWFC xC9,W
06634:  MOVWF  03
06636:  MOVF   01,W
06638:  ADDLW  D2
0663A:  MOVWF  01
0663C:  MOVLW  04
0663E:  ADDWFC 03,F
06640:  MOVFF  01,5C8
06644:  MOVFF  03,5C9
06648:  MOVFF  03,FEA
0664C:  MOVFF  01,FE9
06650:  MOVFF  5C0,5BE
06654:  MOVLB  0
06656:  CALL   00BC
0665A:  MOVFF  01,5C7
....................                return return_code;
0665E:  MOVLB  5
06660:  MOVFF  5C7,01
06664:  BRA    6686
06666:  MOVLB  0
....................             }
....................             i++;
06668:  MOVLB  5
0666A:  INCF   xC6,F
0666C:  BRA    65B8
0666E:  MOVLB  0
....................          }
....................          return INV_CMD; // INVALID_CMD
06670:  MOVLW  01
06672:  MOVWF  01
06674:  MOVLB  5
06676:  BRA    6686
....................       } else return 254; // NOT THIS ADDRESS
06678:  BRA    6680
0667A:  MOVLW  FE
0667C:  MOVWF  01
0667E:  BRA    6686
....................    } else return 255; // NOT THIS DEVICE TYPE
06680:  BRA    6686
06682:  MOVLW  FF
06684:  MOVWF  01
06686:  MOVLB  0
06688:  GOTO   66C2 (RETURN)
.................... }
.................... 
.................... void command_handler_task(){
....................    while (getNextSERReadIndex())
*
066B4:  GOTO   3D32
066B8:  MOVF   01,F
066BA:  BZ    6794
....................    {
....................       int8 return_code = command_parser(SRI);
066BC:  MOVFF  426,5C0
066C0:  BRA    6506
066C2:  MOVFF  01,5BF
....................       //echo_cmd(SRI);
....................       sprintf(retData + strlen(retData), "%s", resp_list[return_code].msg);
066C6:  MOVLW  04
066C8:  MOVLB  5
066CA:  MOVWF  xE7
066CC:  MOVLW  28
066CE:  MOVWF  xE6
066D0:  MOVLB  0
066D2:  CALL   3DC6
066D6:  MOVF   01,W
066D8:  ADDLW  28
066DA:  MOVLB  5
066DC:  MOVWF  xC0
066DE:  MOVLW  04
066E0:  ADDWFC 02,W
066E2:  MOVWF  xC1
066E4:  MOVF   xBF,W
066E6:  MULLW  03
066E8:  MOVF   FF3,W
066EA:  CLRF   xC3
066EC:  MOVWF  xC2
066EE:  MOVLW  01
066F0:  ADDWF  xC2,W
066F2:  MOVWF  01
066F4:  MOVLW  00
066F6:  ADDWFC xC3,W
066F8:  MOVWF  03
066FA:  MOVF   01,W
066FC:  ADDLW  8B
066FE:  MOVWF  FE9
06700:  MOVLW  05
06702:  ADDWFC 03,W
06704:  MOVWF  FEA
06706:  MOVFF  FEC,5C3
0670A:  MOVF   FED,F
0670C:  MOVFF  FEF,5C2
06710:  MOVFF  5C1,4CD
06714:  MOVFF  5C0,4CC
06718:  MOVFF  4CD,FEA
0671C:  MOVFF  4CC,FE9
06720:  CLRF   FEF
06722:  MOVFF  5C3,FEA
06726:  MOVFF  5C2,FE9
0672A:  MOVLB  0
0672C:  BRA    668C
....................       fprintf(SERIAL, "%s,%s", SERcmd[SRI].p[0], retData);
0672E:  MOVLB  5
06730:  CLRF   xE3
06732:  MOVFF  426,5E2
06736:  CLRF   xE5
06738:  MOVLW  B5
0673A:  MOVWF  xE4
0673C:  MOVLB  0
0673E:  CALL   07CC
06742:  MOVFF  02,5C1
06746:  MOVFF  01,5C0
0674A:  MOVLW  06
0674C:  MOVLB  5
0674E:  ADDWF  xC0,F
06750:  MOVLW  00
06752:  ADDWFC xC1,F
06754:  MOVLW  52
06756:  ADDWF  xC0,W
06758:  MOVWF  01
0675A:  MOVLW  01
0675C:  ADDWFC xC1,W
0675E:  MOVWF  03
06760:  MOVFF  01,5C2
06764:  MOVWF  xC3
06766:  MOVWF  FEA
06768:  MOVFF  01,FE9
0676C:  MOVLB  0
0676E:  CALL   3816
06772:  MOVLW  2C
06774:  MOVLB  5
06776:  MOVWF  xC6
06778:  MOVLB  0
0677A:  CALL   37EE
0677E:  MOVLW  04
06780:  MOVWF  FEA
06782:  MOVLW  28
06784:  MOVWF  FE9
06786:  CALL   3816
....................       
....................       resetSERcmd(SRI);
0678A:  MOVFF  426,5C0
0678E:  CALL   07EE
06792:  BRA    66B4
....................    }
06794:  GOTO   6AD2 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... void main()
06798:  CLRF   FF8
0679A:  BCF    FF2.5
0679C:  BSF    07.7
0679E:  MOVLB  E
067A0:  MOVLW  55
067A2:  MOVWF  x9B
067A4:  MOVLW  AA
067A6:  MOVWF  x9B
067A8:  BCF    x9B.0
067AA:  MOVLW  17
067AC:  MOVWF  xB0
067AE:  MOVLW  09
067B0:  MOVWF  x8A
067B2:  MOVLW  0A
067B4:  MOVWF  x8B
067B6:  MOVLW  11
067B8:  MOVWF  xEB
067BA:  MOVLW  12
067BC:  MOVWF  xED
067BE:  MOVLW  09
067C0:  MOVWF  xF8
067C2:  MOVLW  55
067C4:  MOVWF  x9B
067C6:  MOVLW  AA
067C8:  MOVWF  x9B
067CA:  BSF    x9B.0
067CC:  CLRF   xD8
067CE:  CLRF   xD5
067D0:  CLRF   xD7
067D2:  MOVLW  08
067D4:  MOVWF  xD9
067D6:  MOVLW  60
067D8:  MOVWF  xD3
067DA:  MOVLW  AA
067DC:  MOVLB  0
067DE:  MOVWF  xF2
067E0:  MOVLB  1
067E2:  CLRF   x44
067E4:  CLRF   x43
067E6:  CLRF   x42
067E8:  CLRF   x41
067EA:  CLRF   x48
067EC:  CLRF   x47
067EE:  CLRF   x46
067F0:  CLRF   x45
067F2:  CLRF   x4C
067F4:  CLRF   x4B
067F6:  CLRF   x4A
067F8:  CLRF   x49
067FA:  CLRF   x4E
067FC:  CLRF   x4D
067FE:  MOVLB  E
06800:  BCF    x91.5
06802:  MOVLW  00
06804:  MOVWF  x90
06806:  MOVLW  0F
06808:  MOVWF  x8E
0680A:  MOVLW  2A
0680C:  MOVWF  x91
0680E:  MOVLW  F4
06810:  MOVWF  F88
06812:  MOVWF  F88
06814:  MOVWF  F88
06816:  MOVLB  4
06818:  CLRF   x26
0681A:  CLRF   x27
0681C:  CLRF   xC8
0681E:  CLRF   xC9
06820:  BCF    xCA.0
06822:  CLRF   xCB
06824:  BSF    F9E.3
06826:  MOVLW  7C
06828:  MOVWF  F9A
0682A:  MOVLW  00
0682C:  MOVWF  F9B
0682E:  MOVLW  A6
06830:  MOVWF  F9D
06832:  MOVLW  90
06834:  MOVWF  F9C
06836:  MOVLW  93
06838:  MOVWF  F89
0683A:  BCF    F84.5
0683C:  CLRF   xCD
0683E:  CLRF   xCC
06840:  CLRF   xD1
06842:  CLRF   xD0
06844:  CLRF   xCF
06846:  CLRF   xCE
06848:  MOVLB  F
0684A:  CLRF   x0C
0684C:  CLRF   x14
0684E:  CLRF   x1C
06850:  CLRF   x21
06852:  CLRF   x29
06854:  CLRF   x35
06856:  CLRF   x36
06858:  CLRF   x37
0685A:  CLRF   x34
0685C:  CLRF   x31
0685E:  CLRF   x32
06860:  CLRF   x33
06862:  CLRF   x30
06864:  MOVLW  3E
06866:  MOVLB  4
06868:  MOVWF  xD5
0686A:  MOVLW  B6
0686C:  MOVWF  xD4
0686E:  MOVLW  3E
06870:  MOVWF  xD9
06872:  MOVLW  FA
06874:  MOVWF  xD8
06876:  MOVLW  43
06878:  MOVWF  xDD
0687A:  MOVLW  C8
0687C:  MOVWF  xDC
0687E:  MOVLW  45
06880:  MOVWF  xE1
06882:  MOVLW  72
06884:  MOVWF  xE0
06886:  MOVLW  47
06888:  MOVWF  xE5
0688A:  MOVLW  22
0688C:  MOVWF  xE4
0688E:  MOVLW  48
06890:  MOVWF  xE9
06892:  MOVLW  88
06894:  MOVWF  xE8
06896:  MOVLW  4D
06898:  MOVWF  xED
0689A:  MOVLW  34
0689C:  MOVWF  xEC
0689E:  MOVLW  53
068A0:  MOVWF  xF1
068A2:  MOVLW  30
068A4:  MOVWF  xF0
068A6:  MOVLW  56
068A8:  MOVWF  xF5
068AA:  MOVLW  3A
068AC:  MOVWF  xF4
068AE:  MOVLW  57
068B0:  MOVWF  xF9
068B2:  MOVLW  70
068B4:  MOVWF  xF8
068B6:  MOVLW  59
068B8:  MOVWF  xFD
068BA:  MOVLW  58
068BC:  MOVWF  xFC
068BE:  MOVLW  5C
068C0:  MOVLB  5
068C2:  MOVWF  x01
068C4:  MOVLW  CA
068C6:  MOVWF  x00
068C8:  MOVLW  61
068CA:  MOVWF  x05
068CC:  MOVLW  1E
068CE:  MOVWF  x04
068D0:  MOVLW  64
068D2:  MOVWF  x09
068D4:  MOVLW  E2
068D6:  MOVWF  x08
068D8:  MOVLW  64
068DA:  MOVWF  x0D
068DC:  MOVLW  E8
068DE:  MOVWF  x0C
068E0:  MOVLW  64
068E2:  MOVWF  x11
068E4:  MOVLW  EE
068E6:  MOVWF  x10
068E8:  MOVLW  64
068EA:  MOVWF  x15
068EC:  MOVLW  F4
068EE:  MOVWF  x14
068F0:  MOVLW  64
068F2:  MOVWF  x19
068F4:  MOVLW  FA
068F6:  MOVWF  x18
068F8:  MOVLW  65
068FA:  MOVWF  x1D
068FC:  MOVLW  00
068FE:  MOVWF  x1C
06900:  BRA    6A6C
06902:  DATA 02,00
06904:  DATA 1A,00
06906:  DATA 00,02
06908:  DATA 00,60
0690A:  DATA 02,03
0690C:  DATA 08,C0
0690E:  DATA 00,05
06910:  DATA 80,7F
06912:  DATA 00,00
06914:  DATA 00,7F
06916:  DATA 0B,C0
06918:  DATA 00,05
0691A:  DATA 80,7F
0691C:  DATA 00,00
0691E:  DATA 00,7F
06920:  DATA 07,C0
06922:  DATA 00,01
06924:  DATA 80,7F
06926:  DATA 17,C0
06928:  DATA 00,01
0692A:  DATA 80,7F
0692C:  DATA 17,C0
0692E:  DATA 00,01
06930:  DATA 80,7F
06932:  DATA 07,C0
06934:  DATA 00,01
06936:  DATA 80,7F
06938:  DATA 07,C0
0693A:  DATA 00,01
0693C:  DATA 80,7F
0693E:  DATA 07,C0
06940:  DATA 00,01
06942:  DATA 80,7F
06944:  DATA 07,C0
06946:  DATA 00,01
06948:  DATA 80,7F
0694A:  DATA 07,C0
0694C:  DATA 00,01
0694E:  DATA 80,7F
06950:  DATA 07,C0
06952:  DATA 00,01
06954:  DATA 80,7F
06956:  DATA 0B,C0
06958:  DATA 00,32
0695A:  DATA 41,0F
0695C:  DATA 00,03
0695E:  DATA 01,4F
06960:  DATA 00,00
06962:  DATA 00,3C
06964:  DATA 44,8C
06966:  DATA 00,02
06968:  DATA 04,D2
0696A:  DATA 1E,05
0696C:  DATA 02,04
0696E:  DATA D6,21
06970:  DATA 05,02
06972:  DATA 04,DA
06974:  DATA 24,05
06976:  DATA 02,04
06978:  DATA DE,2B
0697A:  DATA 05,02
0697C:  DATA 04,E2
0697E:  DATA 32,05
06980:  DATA 02,04
06982:  DATA E6,3A
06984:  DATA 05,02
06986:  DATA 04,EA
06988:  DATA 42,05
0698A:  DATA 02,04
0698C:  DATA EE,47
0698E:  DATA 05,02
06990:  DATA 04,F2
06992:  DATA 4C,05
06994:  DATA 02,04
06996:  DATA F6,50
06998:  DATA 05,02
0699A:  DATA 04,FA
0699C:  DATA 54,05
0699E:  DATA 02,04
069A0:  DATA FE,5B
069A2:  DATA 05,02
069A4:  DATA 05,02
069A6:  DATA 61,05
069A8:  DATA 02,05
069AA:  DATA 06,67
069AC:  DATA 05,02
069AE:  DATA 05,0A
069B0:  DATA 6D,05
069B2:  DATA 02,05
069B4:  DATA 0E,73
069B6:  DATA 05,02
069B8:  DATA 05,12
069BA:  DATA 78,05
069BC:  DATA 02,05
069BE:  DATA 16,81
069C0:  DATA 05,02
069C2:  DATA 05,1A
069C4:  DATA 89,05
069C6:  DATA 6A,05
069C8:  DATA 1E,67
069CA:  DATA 72,00
069CC:  DATA 67,73
069CE:  DATA 00,67
069D0:  DATA 43,68
069D2:  DATA 4D,61
069D4:  DATA 70,00
069D6:  DATA 73,43
069D8:  DATA 68,4D
069DA:  DATA 61,70
069DC:  DATA 00,67
069DE:  DATA 43,68
069E0:  DATA 4D,6F
069E2:  DATA 64,65
069E4:  DATA 00,73
069E6:  DATA 43,68
069E8:  DATA 4D,6F
069EA:  DATA 64,65
069EC:  DATA 00,67
069EE:  DATA 50,49
069F0:  DATA 44,00
069F2:  DATA 73,50
069F4:  DATA 49,44
069F6:  DATA 00,67
069F8:  DATA 53,50
069FA:  DATA 00,73
069FC:  DATA 53,50
069FE:  DATA 00,67
06A00:  DATA 53,43
06A02:  DATA 61,6C
06A04:  DATA 73,00
06A06:  DATA 67,53
06A08:  DATA 43,61
06A0A:  DATA 6C,00
06A0C:  DATA 73,53
06A0E:  DATA 43,61
06A10:  DATA 6C,00
06A12:  DATA 67,4D
06A14:  DATA 43,61
06A16:  DATA 6C,00
06A18:  DATA 73,4D
06A1A:  DATA 43,61
06A1C:  DATA 6C,00
06A1E:  DATA 67,4D
06A20:  DATA 6F,6E
06A22:  DATA 00,67
06A24:  DATA 50,49
06A26:  DATA 44,64
06A28:  DATA 61,74
06A2A:  DATA 61,00
06A2C:  DATA 67,49
06A2E:  DATA 50,64
06A30:  DATA 61,74
06A32:  DATA 61,04
06A34:  DATA C0,00
06A36:  DATA 32,80
06A38:  DATA 94,05
06A3A:  DATA 01,9C
06A3C:  DATA 05,02
06A3E:  DATA AC,05
06A40:  DATA 53,55
06A42:  DATA 43,43
06A44:  DATA 45,53
06A46:  DATA 53,00
06A48:  DATA 49,4E
06A4A:  DATA 56,41
06A4C:  DATA 4C,49
06A4E:  DATA 44,20
06A50:  DATA 43,4F
06A52:  DATA 4D,4D
06A54:  DATA 41,4E
06A56:  DATA 44,00
06A58:  DATA 49,4E
06A5A:  DATA 56,41
06A5C:  DATA 4C,49
06A5E:  DATA 44,20
06A60:  DATA 50,41
06A62:  DATA 52,41
06A64:  DATA 4D,45
06A66:  DATA 54,45
06A68:  DATA 52,00
06A6A:  DATA 00,00
06A6C:  MOVLW  00
06A6E:  MOVWF  FF8
06A70:  MOVLW  69
06A72:  MOVWF  FF7
06A74:  MOVLW  02
06A76:  MOVWF  FF6
06A78:  TBLRD*+
06A7A:  MOVF   FF5,W
06A7C:  MOVWF  00
06A7E:  XORLW  00
06A80:  BZ    6AA8
06A82:  TBLRD*+
06A84:  MOVF   FF5,W
06A86:  MOVWF  01
06A88:  BTFSC  FE8.7
06A8A:  BRA    6A96
06A8C:  ANDLW  3F
06A8E:  MOVWF  FEA
06A90:  TBLRD*+
06A92:  MOVFF  FF5,FE9
06A96:  BTFSC  01.6
06A98:  TBLRD*+
06A9A:  BTFSS  01.6
06A9C:  TBLRD*+
06A9E:  MOVFF  FF5,FEE
06AA2:  DCFSNZ 00,F
06AA4:  BRA    6A78
06AA6:  BRA    6A9A
06AA8:  CLRF   FF8
.................... {
....................    IO_init();                    // set up IO 
06AAA:  MOVLB  0
06AAC:  GOTO   0316
....................    params_init();                // load parameters
06AB0:  GOTO   05BE
....................    monitor_init();               // initialize internal ADC for voltage and current telemetry
06AB4:  GOTO   075E
.................... //!   control_init();               // initialize the output control DACs
....................    serial_init();                // setup the serial port
06AB8:  GOTO   0968
....................    event_timer_init();
06ABC:  GOTO   098A
.................... //!   setup_wdt(WDT_512MS);
....................    enable_interrupts(GLOBAL);
06AC0:  MOVLW  C0
06AC2:  IORWF  FF2,F
.................... 
....................    while(TRUE)
....................    {
.................... //!      restart_wdt();
....................       internal_monitor_task();   //Update monitored voltage and currents etc
06AC4:  GOTO   0D68
....................       sensor_monitor_task();     //get magnetoresistive sensor data
06AC8:  GOTO   36C8
.................... //!      control_task();            //output control
....................       serial_task();             //serial port 
06ACC:  GOTO   383A
....................       command_handler_task();    //execute commands
06AD0:  BRA    66B4
....................       
....................       delay_ms(500);
06AD2:  MOVLW  02
06AD4:  MOVLB  5
06AD6:  MOVWF  xBF
06AD8:  MOVLW  FA
06ADA:  MOVWF  xC0
06ADC:  MOVLB  0
06ADE:  CALL   03AC
06AE2:  MOVLB  5
06AE4:  DECFSZ xBF,F
06AE6:  BRA    6AD8
06AE8:  MOVLB  0
06AEA:  BRA    6AC4
....................    }
.................... }
06AEC:  SLEEP 

Configuration Fuses:
   Word  1: FF8C   NOEXTOSC RSTOSC_HFINTRC_64MHZ NOCLKOUT CKS FCMEN
   Word  2: FFFD   MCLR PUT NOLPBOR BROWNOUT BORV19 ZCDDIS PPS1WAY STVREN NODEBUG NOXINST
   Word  3: FF9F   WDTSW NOWDT WDTWIN_SW WDTCLK_SW
   Word  4: DFFF   NOWRT NOWRTC NOWRTB NOWRTD SCANE NOLVP
   Word  5: FFFF   NOPROTECT NOCPD
   Word  6: FFFF   NOEBTR NOEBTRB
