CCS PCH C Compiler, Version 5.109, 62303               10-Dec-25 12:20

               Filename:   C:\Users\aidan\Documents\GitHub\DiFCS-Controller\src\main.lst

               ROM used:   45298 bytes (69%)
                           Largest free fragment is 20236
               RAM used:   1798 (50%) at main() level
                           1907 (53%) worst case
               Stack used: 8 locations (6 in main + 2 for interrupts)
               Stack size: 31

*
00000:  NOP   
00002:  GOTO   A8E2
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  MOVLB  E
00056:  BTFSS  xC0.5
00058:  GOTO   0062
0005C:  BTFSC  xC8.5
0005E:  GOTO   00E8
00062:  BTFSS  xC1.0
00064:  GOTO   006E
00068:  BTFSC  xC9.0
0006A:  GOTO   025C
0006E:  MOVFF  0E,00
00072:  MOVFF  0F,01
00076:  MOVFF  10,02
0007A:  MOVFF  11,03
0007E:  MOVFF  0C,FE9
00082:  MOVFF  07,FEA
00086:  BSF    07.7
00088:  MOVFF  08,FE1
0008C:  MOVFF  09,FE2
00090:  MOVFF  0A,FD9
00094:  MOVFF  0B,FDA
00098:  MOVFF  12,FF3
0009C:  MOVFF  13,FF4
000A0:  MOVFF  14,FFA
000A4:  MOVFF  15,FF5
000A8:  MOVFF  16,FF6
000AC:  MOVFF  17,FF7
000B0:  MOVF   04,W
000B2:  MOVFF  06,FE0
000B6:  MOVFF  05,FD8
000BA:  RETFIE 0
.................... #include <main.h>
.................... #include <18F46Q10.h>
.................... //////////// Standard Header file for the PIC18F46Q10 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F46Q10
000BC:  MOVFF  FEC,FFA
000C0:  MOVF   FED,F
000C2:  MOVFF  FEF,FE8
000C6:  MOVWF  FF9
000C8:  RETURN 0
*
00330:  DATA 32,30
00332:  DATA 32,35
00334:  DATA 31,32
00336:  DATA 30,38
00338:  DATA 00,00
0033A:  DATA 30,30
0033C:  DATA 30,30
0033E:  DATA 00,00
00340:  DATA 25,64
00342:  DATA 2C,4D
00344:  DATA 41,4E
00346:  DATA 55,41
00348:  DATA 4C,2C
0034A:  DATA 00,00
0034C:  DATA 25,64
0034E:  DATA 2C,4D
00350:  DATA 41,47
00352:  DATA 53,4E
00354:  DATA 53,2C
00356:  DATA 00,00
00358:  DATA 23,44
0035A:  DATA 30,2C
0035C:  DATA 43,4E
0035E:  DATA 54,2C
00360:  DATA 25,75
00362:  DATA 2C,25
00364:  DATA 2E,30
00366:  DATA 66,2C
00368:  DATA 25,2E
0036A:  DATA 30,66
0036C:  DATA 0A,00
0036E:  DATA 23,44
00370:  DATA 30,2C
00372:  DATA 50,4F
00374:  DATA 53,2C
00376:  DATA 25,75
00378:  DATA 2C,25
0037A:  DATA 33,2E
0037C:  DATA 33,66
0037E:  DATA 0A,00
00380:  DATA 23,44
00382:  DATA 30,2C
00384:  DATA 4F,55
00386:  DATA 54,2C
00388:  DATA 25,75
0038A:  DATA 2C,2D
0038C:  DATA 2C,25
0038E:  DATA 4C,75
00390:  DATA 0A,00
00392:  DATA 23,44
00394:  DATA 30,2C
00396:  DATA 4F,55
00398:  DATA 54,2C
0039A:  DATA 25,75
0039C:  DATA 2C,2B
0039E:  DATA 2C,25
003A0:  DATA 4C,75
003A2:  DATA 0A,00
*
006E8:  ADDWF  FE8,W
006EA:  CLRF   FF7
006EC:  RLCF   FF7,F
006EE:  ADDLW  03
006F0:  MOVWF  FF6
006F2:  MOVLW  07
006F4:  ADDWFC FF7,F
006F6:  TBLRD*-
006F8:  MOVF   FF5,W
006FA:  MOVWF  FFA
006FC:  TBLRD*
006FE:  MOVF   FF5,W
00700:  MOVWF  FF9
00702:  DATA B2,06
00704:  DATA BC,06
00706:  DATA C6,06
00708:  DATA D0,06
*
00890:  MOVLB  7
00892:  MOVF   x46,W
00894:  MULWF  x48
00896:  MOVFF  FF3,01
0089A:  MOVFF  FF4,00
0089E:  MULWF  x49
008A0:  MOVF   FF3,W
008A2:  ADDWF  00,F
008A4:  MOVF   x47,W
008A6:  MULWF  x48
008A8:  MOVF   FF3,W
008AA:  ADDWFC 00,W
008AC:  MOVWF  02
008AE:  MOVLB  0
008B0:  RETURN 0
008B2:  MOVLB  7
008B4:  MOVF   x4A,W
008B6:  CLRF   01
008B8:  SUBWF  x49,W
008BA:  BC    08C2
008BC:  MOVFF  749,00
008C0:  BRA    08DA
008C2:  CLRF   00
008C4:  MOVLW  08
008C6:  MOVWF  x4B
008C8:  RLCF   x49,F
008CA:  RLCF   00,F
008CC:  MOVF   x4A,W
008CE:  SUBWF  00,W
008D0:  BTFSC  FD8.0
008D2:  MOVWF  00
008D4:  RLCF   01,F
008D6:  DECFSZ x4B,F
008D8:  BRA    08C8
008DA:  MOVLB  0
008DC:  RETURN 0
*
00D42:  MOVLB  7
00D44:  MOVF   x22,W
00D46:  ANDLW  07
00D48:  MOVWF  00
00D4A:  RRCF   x22,W
00D4C:  MOVWF  01
00D4E:  RRCF   01,F
00D50:  RRCF   01,F
00D52:  MOVLW  1F
00D54:  ANDWF  01,F
00D56:  MOVF   01,W
00D58:  ADDWF  x24,W
00D5A:  MOVWF  FE9
00D5C:  MOVLW  00
00D5E:  ADDWFC x25,W
00D60:  MOVWF  FEA
00D62:  CLRF   01
00D64:  INCF   01,F
00D66:  INCF   00,F
00D68:  BRA    0D6C
00D6A:  RLCF   01,F
00D6C:  DECFSZ 00,F
00D6E:  BRA    0D6A
00D70:  MOVF   x23,F
00D72:  BZ    0D7A
00D74:  MOVF   01,W
00D76:  IORWF  FEF,F
00D78:  BRA    0D80
00D7A:  COMF   01,F
00D7C:  MOVF   01,W
00D7E:  ANDWF  FEF,F
00D80:  MOVLB  0
00D82:  RETURN 0
00D84:  MOVFF  757,75E
00D88:  MOVLB  7
00D8A:  MOVF   x5B,W
00D8C:  XORWF  x5E,F
00D8E:  BTFSS  x5E.7
00D90:  BRA    0D9C
00D92:  BCF    FD8.2
00D94:  BCF    FD8.0
00D96:  BTFSC  x57.7
00D98:  BSF    FD8.0
00D9A:  BRA    0DFA
00D9C:  MOVFF  757,75E
00DA0:  MOVFF  75A,75F
00DA4:  MOVF   x56,W
00DA6:  SUBWF  x5F,F
00DA8:  BZ    0DB6
00DAA:  BTFSS  x5E.7
00DAC:  BRA    0DFA
00DAE:  MOVF   FD8,W
00DB0:  XORLW  01
00DB2:  MOVWF  FD8
00DB4:  BRA    0DFA
00DB6:  MOVFF  75B,75F
00DBA:  MOVF   x57,W
00DBC:  SUBWF  x5F,F
00DBE:  BZ    0DCC
00DC0:  BTFSS  x5E.7
00DC2:  BRA    0DFA
00DC4:  MOVF   FD8,W
00DC6:  XORLW  01
00DC8:  MOVWF  FD8
00DCA:  BRA    0DFA
00DCC:  MOVFF  75C,75F
00DD0:  MOVF   x58,W
00DD2:  SUBWF  x5F,F
00DD4:  BZ    0DE2
00DD6:  BTFSS  x5E.7
00DD8:  BRA    0DFA
00DDA:  MOVF   FD8,W
00DDC:  XORLW  01
00DDE:  MOVWF  FD8
00DE0:  BRA    0DFA
00DE2:  MOVFF  75D,75F
00DE6:  MOVF   x59,W
00DE8:  SUBWF  x5F,F
00DEA:  BZ    0DF8
00DEC:  BTFSS  x5E.7
00DEE:  BRA    0DFA
00DF0:  MOVF   FD8,W
00DF2:  XORLW  01
00DF4:  MOVWF  FD8
00DF6:  BRA    0DFA
00DF8:  BCF    FD8.0
00DFA:  MOVLB  0
00DFC:  RETURN 0
00DFE:  MOVLW  80
00E00:  BTFSS  FD8.1
00E02:  BRA    0E08
00E04:  MOVLB  7
00E06:  XORWF  x5F,F
00E08:  MOVLB  7
00E0A:  CLRF   x64
00E0C:  CLRF   x65
00E0E:  MOVFF  75B,763
00E12:  MOVF   x5F,W
00E14:  XORWF  x63,F
00E16:  MOVF   x5A,W
00E18:  BTFSC  FD8.2
00E1A:  BRA    0FDA
00E1C:  MOVWF  x62
00E1E:  MOVWF  00
00E20:  MOVF   x5E,W
00E22:  BTFSC  FD8.2
00E24:  BRA    0FEC
00E26:  SUBWF  x62,F
00E28:  BTFSC  FD8.2
00E2A:  BRA    0F32
00E2C:  BNC   0EAA
00E2E:  MOVFF  75F,768
00E32:  BSF    x68.7
00E34:  MOVFF  760,767
00E38:  MOVFF  761,766
00E3C:  CLRF   x65
00E3E:  BCF    FD8.0
00E40:  RRCF   x68,F
00E42:  RRCF   x67,F
00E44:  RRCF   x66,F
00E46:  RRCF   x65,F
00E48:  DECFSZ x62,F
00E4A:  BRA    0E3C
00E4C:  BTFSS  x63.7
00E4E:  BRA    0E56
00E50:  BSF    x64.0
00E52:  BRA    1014
00E54:  BCF    x64.0
00E56:  BCF    x62.0
00E58:  BSF    x64.4
00E5A:  MOVLW  07
00E5C:  MOVWF  FEA
00E5E:  MOVLW  5D
00E60:  MOVWF  FE9
00E62:  BRA    103A
00E64:  BCF    x64.4
00E66:  BTFSC  x63.7
00E68:  BRA    0E7E
00E6A:  BTFSS  x62.0
00E6C:  BRA    0E94
00E6E:  RRCF   x68,F
00E70:  RRCF   x67,F
00E72:  RRCF   x66,F
00E74:  RRCF   x65,F
00E76:  INCF   00,F
00E78:  BTFSC  FD8.2
00E7A:  BRA    100A
00E7C:  BRA    0E94
00E7E:  BTFSC  x68.7
00E80:  BRA    0E9A
00E82:  BCF    FD8.0
00E84:  RLCF   x65,F
00E86:  RLCF   x66,F
00E88:  RLCF   x67,F
00E8A:  RLCF   x68,F
00E8C:  DECF   00,F
00E8E:  BTFSC  FD8.2
00E90:  BRA    100A
00E92:  BRA    0E7E
00E94:  BSF    x64.6
00E96:  BRA    0F72
00E98:  BCF    x64.6
00E9A:  MOVFF  75B,763
00E9E:  BTFSS  x5B.7
00EA0:  BRA    0EA6
00EA2:  BSF    x68.7
00EA4:  BRA    0FFC
00EA6:  BCF    x68.7
00EA8:  BRA    0FFC
00EAA:  MOVFF  75E,762
00EAE:  MOVFF  75E,00
00EB2:  MOVF   x5A,W
00EB4:  SUBWF  x62,F
00EB6:  MOVFF  75B,768
00EBA:  BSF    x68.7
00EBC:  MOVFF  75C,767
00EC0:  MOVFF  75D,766
00EC4:  CLRF   x65
00EC6:  BCF    FD8.0
00EC8:  RRCF   x68,F
00ECA:  RRCF   x67,F
00ECC:  RRCF   x66,F
00ECE:  RRCF   x65,F
00ED0:  DECFSZ x62,F
00ED2:  BRA    0EC4
00ED4:  BTFSS  x63.7
00ED6:  BRA    0EDE
00ED8:  BSF    x64.1
00EDA:  BRA    1014
00EDC:  BCF    x64.1
00EDE:  BCF    x62.0
00EE0:  BSF    x64.5
00EE2:  MOVLW  07
00EE4:  MOVWF  FEA
00EE6:  MOVLW  61
00EE8:  MOVWF  FE9
00EEA:  BRA    103A
00EEC:  BCF    x64.5
00EEE:  BTFSC  x63.7
00EF0:  BRA    0F06
00EF2:  BTFSS  x62.0
00EF4:  BRA    0F1C
00EF6:  RRCF   x68,F
00EF8:  RRCF   x67,F
00EFA:  RRCF   x66,F
00EFC:  RRCF   x65,F
00EFE:  INCF   00,F
00F00:  BTFSC  FD8.2
00F02:  BRA    100A
00F04:  BRA    0F1C
00F06:  BTFSC  x68.7
00F08:  BRA    0F22
00F0A:  BCF    FD8.0
00F0C:  RLCF   x65,F
00F0E:  RLCF   x66,F
00F10:  RLCF   x67,F
00F12:  RLCF   x68,F
00F14:  DECF   00,F
00F16:  BTFSC  FD8.2
00F18:  BRA    100A
00F1A:  BRA    0F06
00F1C:  BSF    x64.7
00F1E:  BRA    0F72
00F20:  BCF    x64.7
00F22:  MOVFF  75F,763
00F26:  BTFSS  x5F.7
00F28:  BRA    0F2E
00F2A:  BSF    x68.7
00F2C:  BRA    0FFC
00F2E:  BCF    x68.7
00F30:  BRA    0FFC
00F32:  MOVFF  75F,768
00F36:  BSF    x68.7
00F38:  MOVFF  760,767
00F3C:  MOVFF  761,766
00F40:  BTFSS  x63.7
00F42:  BRA    0F4C
00F44:  BCF    x68.7
00F46:  BSF    x64.2
00F48:  BRA    1014
00F4A:  BCF    x64.2
00F4C:  CLRF   x65
00F4E:  BCF    x62.0
00F50:  MOVLW  07
00F52:  MOVWF  FEA
00F54:  MOVLW  5D
00F56:  MOVWF  FE9
00F58:  BRA    103A
00F5A:  BTFSC  x63.7
00F5C:  BRA    0F96
00F5E:  MOVFF  75B,763
00F62:  BTFSS  x62.0
00F64:  BRA    0F72
00F66:  RRCF   x68,F
00F68:  RRCF   x67,F
00F6A:  RRCF   x66,F
00F6C:  RRCF   x65,F
00F6E:  INCF   00,F
00F70:  BZ    100A
00F72:  BTFSS  x65.7
00F74:  BRA    0F8C
00F76:  INCF   x66,F
00F78:  BNZ   0F8C
00F7A:  INCF   x67,F
00F7C:  BNZ   0F8C
00F7E:  INCF   x68,F
00F80:  BNZ   0F8C
00F82:  RRCF   x68,F
00F84:  RRCF   x67,F
00F86:  RRCF   x66,F
00F88:  INCF   00,F
00F8A:  BZ    100A
00F8C:  BTFSC  x64.6
00F8E:  BRA    0E98
00F90:  BTFSC  x64.7
00F92:  BRA    0F20
00F94:  BRA    0FCE
00F96:  MOVLW  80
00F98:  XORWF  x68,F
00F9A:  BTFSS  x68.7
00F9C:  BRA    0FA6
00F9E:  BRA    1014
00FA0:  MOVFF  75F,763
00FA4:  BRA    0FBA
00FA6:  MOVFF  75B,763
00FAA:  MOVF   x68,F
00FAC:  BNZ   0FBA
00FAE:  MOVF   x67,F
00FB0:  BNZ   0FBA
00FB2:  MOVF   x66,F
00FB4:  BNZ   0FBA
00FB6:  CLRF   00
00FB8:  BRA    0FFC
00FBA:  BTFSC  x68.7
00FBC:  BRA    0FCE
00FBE:  BCF    FD8.0
00FC0:  RLCF   x65,F
00FC2:  RLCF   x66,F
00FC4:  RLCF   x67,F
00FC6:  RLCF   x68,F
00FC8:  DECFSZ 00,F
00FCA:  BRA    0FBA
00FCC:  BRA    100A
00FCE:  BTFSS  x63.7
00FD0:  BRA    0FD6
00FD2:  BSF    x68.7
00FD4:  BRA    0FFC
00FD6:  BCF    x68.7
00FD8:  BRA    0FFC
00FDA:  MOVFF  75E,00
00FDE:  MOVFF  75F,768
00FE2:  MOVFF  760,767
00FE6:  MOVFF  761,766
00FEA:  BRA    0FFC
00FEC:  MOVFF  75A,00
00FF0:  MOVFF  75B,768
00FF4:  MOVFF  75C,767
00FF8:  MOVFF  75D,766
00FFC:  MOVFF  768,01
01000:  MOVFF  767,02
01004:  MOVFF  766,03
01008:  BRA    1072
0100A:  CLRF   00
0100C:  CLRF   01
0100E:  CLRF   02
01010:  CLRF   03
01012:  BRA    1072
01014:  CLRF   x65
01016:  COMF   x66,F
01018:  COMF   x67,F
0101A:  COMF   x68,F
0101C:  COMF   x65,F
0101E:  INCF   x65,F
01020:  BNZ   102C
01022:  INCF   x66,F
01024:  BNZ   102C
01026:  INCF   x67,F
01028:  BNZ   102C
0102A:  INCF   x68,F
0102C:  BTFSC  x64.0
0102E:  BRA    0E54
01030:  BTFSC  x64.1
01032:  BRA    0EDC
01034:  BTFSC  x64.2
01036:  BRA    0F4A
01038:  BRA    0FA0
0103A:  MOVF   FEF,W
0103C:  ADDWF  x66,F
0103E:  BNC   104A
01040:  INCF   x67,F
01042:  BNZ   104A
01044:  INCF   x68,F
01046:  BTFSC  FD8.2
01048:  BSF    x62.0
0104A:  MOVF   FED,F
0104C:  MOVF   FEF,W
0104E:  ADDWF  x67,F
01050:  BNC   1058
01052:  INCF   x68,F
01054:  BTFSC  FD8.2
01056:  BSF    x62.0
01058:  MOVF   FED,F
0105A:  MOVF   FEF,W
0105C:  BTFSC  FEF.7
0105E:  BRA    1062
01060:  XORLW  80
01062:  ADDWF  x68,F
01064:  BTFSC  FD8.0
01066:  BSF    x62.0
01068:  BTFSC  x64.4
0106A:  BRA    0E64
0106C:  BTFSC  x64.5
0106E:  BRA    0EEC
01070:  BRA    0F5A
01072:  MOVLB  0
01074:  RETURN 0
01076:  MOVLB  7
01078:  MOVF   x0F,W
0107A:  ANDLW  07
0107C:  MOVWF  00
0107E:  RRCF   x0F,W
01080:  MOVWF  01
01082:  RRCF   01,F
01084:  RRCF   01,F
01086:  MOVLW  1F
01088:  ANDWF  01,F
0108A:  MOVF   01,W
0108C:  ADDWF  x10,W
0108E:  MOVWF  FE9
01090:  MOVLW  00
01092:  ADDWFC x11,W
01094:  MOVWF  FEA
01096:  MOVFF  FEF,01
0109A:  INCF   00,F
0109C:  BRA    10A0
0109E:  RRCF   01,F
010A0:  DECFSZ 00,F
010A2:  BRA    109E
010A4:  MOVLW  01
010A6:  ANDWF  01,F
010A8:  MOVLB  0
010AA:  RETURN 0
*
01138:  MOVLB  7
0113A:  MOVF   x56,W
0113C:  BTFSC  FD8.2
0113E:  BRA    1222
01140:  MOVWF  00
01142:  MOVF   x5A,W
01144:  BTFSC  FD8.2
01146:  BRA    1222
01148:  ADDWF  00,F
0114A:  BNC   1154
0114C:  MOVLW  81
0114E:  ADDWF  00,F
01150:  BC    1222
01152:  BRA    115C
01154:  MOVLW  7F
01156:  SUBWF  00,F
01158:  BNC   1222
0115A:  BZ    1222
0115C:  MOVFF  757,75E
01160:  MOVF   x5B,W
01162:  XORWF  x5E,F
01164:  BSF    x57.7
01166:  BSF    x5B.7
01168:  MOVF   x59,W
0116A:  MULWF  x5D
0116C:  MOVFF  FF4,760
01170:  MOVF   x58,W
01172:  MULWF  x5C
01174:  MOVFF  FF4,03
01178:  MOVFF  FF3,75F
0117C:  MULWF  x5D
0117E:  MOVF   FF3,W
01180:  ADDWF  x60,F
01182:  MOVF   FF4,W
01184:  ADDWFC x5F,F
01186:  MOVLW  00
01188:  ADDWFC 03,F
0118A:  MOVF   x59,W
0118C:  MULWF  x5C
0118E:  MOVF   FF3,W
01190:  ADDWF  x60,F
01192:  MOVF   FF4,W
01194:  ADDWFC x5F,F
01196:  MOVLW  00
01198:  CLRF   02
0119A:  ADDWFC 03,F
0119C:  ADDWFC 02,F
0119E:  MOVF   x57,W
011A0:  MULWF  x5D
011A2:  MOVF   FF3,W
011A4:  ADDWF  x5F,F
011A6:  MOVF   FF4,W
011A8:  ADDWFC 03,F
011AA:  MOVLW  00
011AC:  ADDWFC 02,F
011AE:  MOVF   x57,W
011B0:  MULWF  x5C
011B2:  MOVF   FF3,W
011B4:  ADDWF  03,F
011B6:  MOVF   FF4,W
011B8:  ADDWFC 02,F
011BA:  MOVLW  00
011BC:  CLRF   01
011BE:  ADDWFC 01,F
011C0:  MOVF   x59,W
011C2:  MULWF  x5B
011C4:  MOVF   FF3,W
011C6:  ADDWF  x5F,F
011C8:  MOVF   FF4,W
011CA:  ADDWFC 03,F
011CC:  MOVLW  00
011CE:  ADDWFC 02,F
011D0:  ADDWFC 01,F
011D2:  MOVF   x58,W
011D4:  MULWF  x5B
011D6:  MOVF   FF3,W
011D8:  ADDWF  03,F
011DA:  MOVF   FF4,W
011DC:  ADDWFC 02,F
011DE:  MOVLW  00
011E0:  ADDWFC 01,F
011E2:  MOVF   x57,W
011E4:  MULWF  x5B
011E6:  MOVF   FF3,W
011E8:  ADDWF  02,F
011EA:  MOVF   FF4,W
011EC:  ADDWFC 01,F
011EE:  INCF   00,F
011F0:  BTFSC  01.7
011F2:  BRA    11FE
011F4:  RLCF   x5F,F
011F6:  RLCF   03,F
011F8:  RLCF   02,F
011FA:  RLCF   01,F
011FC:  DECF   00,F
011FE:  MOVLW  00
01200:  BTFSS  x5F.7
01202:  BRA    1218
01204:  INCF   03,F
01206:  ADDWFC 02,F
01208:  ADDWFC 01,F
0120A:  MOVF   01,W
0120C:  BNZ   1218
0120E:  MOVF   02,W
01210:  BNZ   1218
01212:  MOVF   03,W
01214:  BNZ   1218
01216:  INCF   00,F
01218:  BTFSC  x5E.7
0121A:  BSF    01.7
0121C:  BTFSS  x5E.7
0121E:  BCF    01.7
01220:  BRA    122A
01222:  CLRF   00
01224:  CLRF   01
01226:  CLRF   02
01228:  CLRF   03
0122A:  MOVLB  0
0122C:  RETURN 0
0122E:  MOVLW  8E
01230:  MOVWF  00
01232:  MOVLB  7
01234:  MOVF   x56,W
01236:  SUBWF  00,F
01238:  MOVFF  757,02
0123C:  MOVFF  758,01
01240:  BSF    02.7
01242:  MOVF   00,F
01244:  BZ    1258
01246:  BCF    FD8.0
01248:  MOVF   02,F
0124A:  BNZ   1250
0124C:  MOVF   01,F
0124E:  BZ    1258
01250:  RRCF   02,F
01252:  RRCF   01,F
01254:  DECFSZ 00,F
01256:  BRA    1246
01258:  BTFSS  x57.7
0125A:  BRA    1266
0125C:  COMF   01,F
0125E:  COMF   02,F
01260:  INCF   01,F
01262:  BTFSC  FD8.2
01264:  INCF   02,F
01266:  MOVLB  0
01268:  RETURN 0
*
01DB0:  BTFSC  FD8.1
01DB2:  BRA    1DBC
01DB4:  MOVLW  07
01DB6:  MOVWF  FEA
01DB8:  MOVLW  49
01DBA:  MOVWF  FE9
01DBC:  MOVLB  7
01DBE:  MOVF   x44,W
01DC0:  XORWF  x48,W
01DC2:  ANDLW  80
01DC4:  MOVWF  x4E
01DC6:  BTFSS  x44.7
01DC8:  BRA    1DE0
01DCA:  COMF   x41,F
01DCC:  COMF   x42,F
01DCE:  COMF   x43,F
01DD0:  COMF   x44,F
01DD2:  INCF   x41,F
01DD4:  BTFSC  FD8.2
01DD6:  INCF   x42,F
01DD8:  BTFSC  FD8.2
01DDA:  INCF   x43,F
01DDC:  BTFSC  FD8.2
01DDE:  INCF   x44,F
01DE0:  BTFSS  x48.7
01DE2:  BRA    1DFA
01DE4:  COMF   x45,F
01DE6:  COMF   x46,F
01DE8:  COMF   x47,F
01DEA:  COMF   x48,F
01DEC:  INCF   x45,F
01DEE:  BTFSC  FD8.2
01DF0:  INCF   x46,F
01DF2:  BTFSC  FD8.2
01DF4:  INCF   x47,F
01DF6:  BTFSC  FD8.2
01DF8:  INCF   x48,F
01DFA:  CLRF   00
01DFC:  CLRF   01
01DFE:  CLRF   02
01E00:  CLRF   03
01E02:  CLRF   x49
01E04:  CLRF   x4A
01E06:  CLRF   x4B
01E08:  CLRF   x4C
01E0A:  MOVF   x48,W
01E0C:  IORWF  x47,W
01E0E:  IORWF  x46,W
01E10:  IORWF  x45,W
01E12:  BZ    1E6C
01E14:  MOVLW  20
01E16:  MOVWF  x4D
01E18:  BCF    FD8.0
01E1A:  RLCF   x41,F
01E1C:  RLCF   x42,F
01E1E:  RLCF   x43,F
01E20:  RLCF   x44,F
01E22:  RLCF   x49,F
01E24:  RLCF   x4A,F
01E26:  RLCF   x4B,F
01E28:  RLCF   x4C,F
01E2A:  MOVF   x48,W
01E2C:  SUBWF  x4C,W
01E2E:  BNZ   1E40
01E30:  MOVF   x47,W
01E32:  SUBWF  x4B,W
01E34:  BNZ   1E40
01E36:  MOVF   x46,W
01E38:  SUBWF  x4A,W
01E3A:  BNZ   1E40
01E3C:  MOVF   x45,W
01E3E:  SUBWF  x49,W
01E40:  BNC   1E60
01E42:  MOVF   x45,W
01E44:  SUBWF  x49,F
01E46:  MOVF   x46,W
01E48:  BTFSS  FD8.0
01E4A:  INCFSZ x46,W
01E4C:  SUBWF  x4A,F
01E4E:  MOVF   x47,W
01E50:  BTFSS  FD8.0
01E52:  INCFSZ x47,W
01E54:  SUBWF  x4B,F
01E56:  MOVF   x48,W
01E58:  BTFSS  FD8.0
01E5A:  INCFSZ x48,W
01E5C:  SUBWF  x4C,F
01E5E:  BSF    FD8.0
01E60:  RLCF   00,F
01E62:  RLCF   01,F
01E64:  RLCF   02,F
01E66:  RLCF   03,F
01E68:  DECFSZ x4D,F
01E6A:  BRA    1E18
01E6C:  BTFSS  x4E.7
01E6E:  BRA    1E86
01E70:  COMF   00,F
01E72:  COMF   01,F
01E74:  COMF   02,F
01E76:  COMF   03,F
01E78:  INCF   00,F
01E7A:  BTFSC  FD8.2
01E7C:  INCF   01,F
01E7E:  BTFSC  FD8.2
01E80:  INCF   02,F
01E82:  BTFSC  FD8.2
01E84:  INCF   03,F
01E86:  MOVFF  749,FEF
01E8A:  MOVFF  74A,FEC
01E8E:  MOVFF  74B,FEC
01E92:  MOVFF  74C,FEC
01E96:  MOVLB  0
01E98:  RETURN 0
*
023F6:  MOVLW  B6
023F8:  MOVWF  00
023FA:  CLRF   03
023FC:  CLRF   02
023FE:  CLRF   01
02400:  MOVLB  7
02402:  BCF    x24.0
02404:  BTFSS  x23.7
02406:  BRA    2420
02408:  BSF    x24.0
0240A:  COMF   x20,F
0240C:  COMF   x21,F
0240E:  COMF   x22,F
02410:  COMF   x23,F
02412:  INCF   x20,F
02414:  BNZ   2420
02416:  INCF   x21,F
02418:  BNZ   2420
0241A:  INCF   x22,F
0241C:  BTFSC  FD8.2
0241E:  INCF   x23,F
02420:  MOVF   x20,W
02422:  IORWF  x21,W
02424:  IORWF  x22,W
02426:  IORWF  x23,W
02428:  BNZ   242E
0242A:  CLRF   00
0242C:  BRA    244C
0242E:  BCF    FD8.0
02430:  BTFSC  01.7
02432:  BRA    2446
02434:  RLCF   x20,F
02436:  RLCF   x21,F
02438:  RLCF   x22,F
0243A:  RLCF   x23,F
0243C:  RLCF   03,F
0243E:  RLCF   02,F
02440:  RLCF   01,F
02442:  DECFSZ 00,F
02444:  BRA    242E
02446:  BCF    01.7
02448:  BTFSC  x24.0
0244A:  BSF    01.7
0244C:  MOVLB  0
0244E:  RETURN 0
02450:  MOVLB  7
02452:  MOVF   x4F,W
02454:  BTFSC  FD8.2
02456:  BRA    25A2
02458:  MOVWF  x5B
0245A:  MOVF   x53,W
0245C:  BTFSC  FD8.2
0245E:  BRA    25A2
02460:  SUBWF  x5B,F
02462:  BNC   246E
02464:  MOVLW  7F
02466:  ADDWF  x5B,F
02468:  BTFSC  FD8.0
0246A:  BRA    25A2
0246C:  BRA    247A
0246E:  MOVLW  81
02470:  SUBWF  x5B,F
02472:  BTFSS  FD8.0
02474:  BRA    25A2
02476:  BTFSC  FD8.2
02478:  BRA    25A2
0247A:  MOVFF  75B,00
0247E:  CLRF   01
02480:  CLRF   02
02482:  CLRF   03
02484:  CLRF   x5A
02486:  MOVFF  750,759
0248A:  BSF    x59.7
0248C:  MOVFF  751,758
02490:  MOVFF  752,757
02494:  MOVLW  19
02496:  MOVWF  x5B
02498:  MOVF   x56,W
0249A:  SUBWF  x57,F
0249C:  BC    24B8
0249E:  MOVLW  01
024A0:  SUBWF  x58,F
024A2:  BC    24B8
024A4:  SUBWF  x59,F
024A6:  BC    24B8
024A8:  SUBWF  x5A,F
024AA:  BC    24B8
024AC:  INCF   x5A,F
024AE:  INCF   x59,F
024B0:  INCF   x58,F
024B2:  MOVF   x56,W
024B4:  ADDWF  x57,F
024B6:  BRA    2508
024B8:  MOVF   x55,W
024BA:  SUBWF  x58,F
024BC:  BC    24E2
024BE:  MOVLW  01
024C0:  SUBWF  x59,F
024C2:  BC    24E2
024C4:  SUBWF  x5A,F
024C6:  BC    24E2
024C8:  INCF   x5A,F
024CA:  INCF   x59,F
024CC:  MOVF   x55,W
024CE:  ADDWF  x58,F
024D0:  MOVF   x56,W
024D2:  ADDWF  x57,F
024D4:  BNC   2508
024D6:  INCF   x58,F
024D8:  BNZ   2508
024DA:  INCF   x59,F
024DC:  BNZ   2508
024DE:  INCF   x5A,F
024E0:  BRA    2508
024E2:  MOVF   x54,W
024E4:  IORLW  80
024E6:  SUBWF  x59,F
024E8:  BC    2506
024EA:  MOVLW  01
024EC:  SUBWF  x5A,F
024EE:  BC    2506
024F0:  INCF   x5A,F
024F2:  MOVF   x54,W
024F4:  IORLW  80
024F6:  ADDWF  x59,F
024F8:  MOVF   x55,W
024FA:  ADDWF  x58,F
024FC:  BNC   24D0
024FE:  INCF   x59,F
02500:  BNZ   24D0
02502:  INCF   x5A,F
02504:  BRA    24D0
02506:  BSF    03.0
02508:  DECFSZ x5B,F
0250A:  BRA    250E
0250C:  BRA    2524
0250E:  BCF    FD8.0
02510:  RLCF   x57,F
02512:  RLCF   x58,F
02514:  RLCF   x59,F
02516:  RLCF   x5A,F
02518:  BCF    FD8.0
0251A:  RLCF   03,F
0251C:  RLCF   02,F
0251E:  RLCF   01,F
02520:  RLCF   x5C,F
02522:  BRA    2498
02524:  BTFSS  x5C.0
02526:  BRA    2534
02528:  BCF    FD8.0
0252A:  RRCF   01,F
0252C:  RRCF   02,F
0252E:  RRCF   03,F
02530:  RRCF   x5C,F
02532:  BRA    2538
02534:  DECF   00,F
02536:  BZ    25A2
02538:  BTFSC  x5C.7
0253A:  BRA    2578
0253C:  BCF    FD8.0
0253E:  RLCF   x57,F
02540:  RLCF   x58,F
02542:  RLCF   x59,F
02544:  RLCF   x5A,F
02546:  MOVF   x56,W
02548:  SUBWF  x57,F
0254A:  BC    255A
0254C:  MOVLW  01
0254E:  SUBWF  x58,F
02550:  BC    255A
02552:  SUBWF  x59,F
02554:  BC    255A
02556:  SUBWF  x5A,F
02558:  BNC   258E
0255A:  MOVF   x55,W
0255C:  SUBWF  x58,F
0255E:  BC    256A
02560:  MOVLW  01
02562:  SUBWF  x59,F
02564:  BC    256A
02566:  SUBWF  x5A,F
02568:  BNC   258E
0256A:  MOVF   x54,W
0256C:  IORLW  80
0256E:  SUBWF  x59,F
02570:  BC    2578
02572:  MOVLW  01
02574:  SUBWF  x5A,F
02576:  BNC   258E
02578:  INCF   03,F
0257A:  BNZ   258E
0257C:  INCF   02,F
0257E:  BNZ   258E
02580:  INCF   01,F
02582:  BNZ   258E
02584:  INCF   00,F
02586:  BZ    25A2
02588:  RRCF   01,F
0258A:  RRCF   02,F
0258C:  RRCF   03,F
0258E:  MOVFF  750,75B
02592:  MOVF   x54,W
02594:  XORWF  x5B,F
02596:  BTFSS  x5B.7
02598:  BRA    259E
0259A:  BSF    01.7
0259C:  BRA    25AA
0259E:  BCF    01.7
025A0:  BRA    25AA
025A2:  CLRF   00
025A4:  CLRF   01
025A6:  CLRF   02
025A8:  CLRF   03
025AA:  MOVLB  0
025AC:  RETURN 0
*
02D68:  ADDWF  FE8,W
02D6A:  CLRF   FF7
02D6C:  RLCF   FF7,F
02D6E:  ADDLW  83
02D70:  MOVWF  FF6
02D72:  MOVLW  2D
02D74:  ADDWFC FF7,F
02D76:  TBLRD*-
02D78:  MOVF   FF5,W
02D7A:  MOVWF  FFA
02D7C:  TBLRD*
02D7E:  MOVF   FF5,W
02D80:  MOVWF  FF9
02D82:  DATA 70,2C
02D84:  DATA 8A,2C
02D86:  DATA DE,2C
02D88:  DATA 42,2D
02D8A:  MOVLW  8E
02D8C:  MOVWF  00
02D8E:  MOVFF  74D,01
02D92:  MOVFF  74C,02
02D96:  CLRF   03
02D98:  BTFSS  01.7
02D9A:  BRA    2DA6
02D9C:  COMF   01,F
02D9E:  COMF   02,F
02DA0:  INCF   02,F
02DA2:  BNZ   2DA6
02DA4:  INCF   01,F
02DA6:  MOVF   01,F
02DA8:  BNZ   2DBC
02DAA:  MOVFF  02,01
02DAE:  CLRF   02
02DB0:  MOVLW  08
02DB2:  SUBWF  00,F
02DB4:  MOVF   01,F
02DB6:  BNZ   2DBC
02DB8:  CLRF   00
02DBA:  BRA    2DD8
02DBC:  BCF    FD8.0
02DBE:  BTFSC  01.7
02DC0:  BRA    2DCA
02DC2:  RLCF   02,F
02DC4:  RLCF   01,F
02DC6:  DECF   00,F
02DC8:  BRA    2DBC
02DCA:  MOVLB  7
02DCC:  BTFSS  x4D.7
02DCE:  BRA    2DD4
02DD0:  MOVLB  0
02DD2:  BRA    2DD8
02DD4:  BCF    01.7
02DD6:  MOVLB  0
02DD8:  RETURN 0
02DDA:  MOVLW  8E
02DDC:  MOVWF  00
02DDE:  MOVFF  75B,01
02DE2:  MOVFF  75A,02
02DE6:  CLRF   03
02DE8:  MOVF   01,F
02DEA:  BNZ   2DFE
02DEC:  MOVFF  02,01
02DF0:  CLRF   02
02DF2:  MOVLW  08
02DF4:  SUBWF  00,F
02DF6:  MOVF   01,F
02DF8:  BNZ   2DFE
02DFA:  CLRF   00
02DFC:  BRA    2E0E
02DFE:  BCF    FD8.0
02E00:  BTFSC  01.7
02E02:  BRA    2E0C
02E04:  RLCF   02,F
02E06:  RLCF   01,F
02E08:  DECF   00,F
02E0A:  BRA    2DFE
02E0C:  BCF    01.7
02E0E:  RETURN 0
*
055B8:  ADDWF  FE8,W
055BA:  CLRF   FF7
055BC:  RLCF   FF7,F
055BE:  ADDLW  D3
055C0:  MOVWF  FF6
055C2:  MOVLW  55
055C4:  ADDWFC FF7,F
055C6:  TBLRD*-
055C8:  MOVF   FF5,W
055CA:  MOVWF  FFA
055CC:  TBLRD*
055CE:  MOVF   FF5,W
055D0:  MOVWF  FF9
055D2:  DATA 54,50
055D4:  DATA 1A,51
055D6:  DATA E0,51
055D8:  DATA A6,52
055DA:  DATA 6C,53
055DC:  DATA 32,54
055DE:  DATA F8,54
*
05664:  MOVF   FEF,F
05666:  BZ    568C
05668:  MOVFF  FEA,704
0566C:  MOVFF  FE9,703
05670:  MOVF   FEF,W
05672:  MOVLB  E
05674:  BTFSS  xC8.4
05676:  BRA    5674
05678:  MOVWF  F99
0567A:  MOVFF  704,FEA
0567E:  MOVFF  703,FE9
05682:  INCF   FE9,F
05684:  BTFSC  FD8.2
05686:  INCF   FEA,F
05688:  MOVLB  0
0568A:  BRA    5664
0568C:  RETURN 0
*
05BDE:  MOVFF  565,FEA
05BE2:  MOVFF  564,FE9
05BE6:  MOVFF  750,FEF
05BEA:  INCF   FE9,F
05BEC:  BTFSC  FD8.2
05BEE:  INCF   FEA,F
05BF0:  CLRF   FEF
05BF2:  MOVLB  5
05BF4:  INCF   x64,F
05BF6:  BTFSC  FD8.2
05BF8:  INCF   x65,F
05BFA:  MOVLB  0
05BFC:  RETURN 0
05BFE:  TBLRD*+
05C00:  MOVFF  FF6,710
05C04:  MOVFF  FF7,711
05C08:  MOVFF  FF5,750
05C0C:  RCALL  5BDE
05C0E:  MOVFF  710,FF6
05C12:  MOVFF  711,FF7
05C16:  MOVLB  7
05C18:  DECFSZ x0F,F
05C1A:  BRA    5C1E
05C1C:  BRA    5C22
05C1E:  MOVLB  0
05C20:  BRA    5BFE
05C22:  MOVLB  0
05C24:  RETURN 0
05C26:  MOVF   01,W
05C28:  MOVFF  706,749
05C2C:  MOVLW  64
05C2E:  MOVLB  7
05C30:  MOVWF  x4A
05C32:  MOVLB  0
05C34:  CALL   08B2
05C38:  MOVFF  00,706
05C3C:  MOVF   01,W
05C3E:  MOVLW  30
05C40:  BNZ   5C52
05C42:  MOVLB  7
05C44:  BTFSS  x07.1
05C46:  BRA    5C66
05C48:  BTFSC  x07.3
05C4A:  BRA    5C66
05C4C:  BTFSC  x07.4
05C4E:  MOVLW  20
05C50:  BRA    5C5A
05C52:  MOVLB  7
05C54:  BCF    x07.3
05C56:  BCF    x07.4
05C58:  BSF    x07.0
05C5A:  ADDWF  01,F
05C5C:  MOVFF  01,750
05C60:  MOVLB  0
05C62:  RCALL  5BDE
05C64:  MOVLB  7
05C66:  MOVFF  706,749
05C6A:  MOVLW  0A
05C6C:  MOVWF  x4A
05C6E:  MOVLB  0
05C70:  CALL   08B2
05C74:  MOVFF  00,706
05C78:  MOVF   01,W
05C7A:  MOVLW  30
05C7C:  BNZ   5C8E
05C7E:  MOVLB  7
05C80:  BTFSC  x07.3
05C82:  BRA    5C98
05C84:  BTFSS  x07.0
05C86:  BRA    5C98
05C88:  BTFSC  x07.4
05C8A:  MOVLW  20
05C8C:  MOVLB  0
05C8E:  ADDWF  01,F
05C90:  MOVFF  01,750
05C94:  RCALL  5BDE
05C96:  MOVLB  7
05C98:  MOVLW  30
05C9A:  ADDWF  x06,F
05C9C:  MOVFF  706,750
05CA0:  MOVLB  0
05CA2:  RCALL  5BDE
05CA4:  RETURN 0
05CA6:  MOVLB  7
05CA8:  MOVF   x50,W
05CAA:  SUBLW  B6
05CAC:  MOVWF  x50
05CAE:  CLRF   03
05CB0:  MOVFF  751,754
05CB4:  BSF    x51.7
05CB6:  BCF    FD8.0
05CB8:  RRCF   x51,F
05CBA:  RRCF   x52,F
05CBC:  RRCF   x53,F
05CBE:  RRCF   03,F
05CC0:  RRCF   02,F
05CC2:  RRCF   01,F
05CC4:  RRCF   00,F
05CC6:  DECFSZ x50,F
05CC8:  BRA    5CB6
05CCA:  BTFSS  x54.7
05CCC:  BRA    5CE4
05CCE:  COMF   00,F
05CD0:  COMF   01,F
05CD2:  COMF   02,F
05CD4:  COMF   03,F
05CD6:  INCF   00,F
05CD8:  BTFSC  FD8.2
05CDA:  INCF   01,F
05CDC:  BTFSC  FD8.2
05CDE:  INCF   02,F
05CE0:  BTFSC  FD8.2
05CE2:  INCF   03,F
05CE4:  MOVLB  0
05CE6:  RETURN 0
05CE8:  BTFSC  FD8.1
05CEA:  BRA    5CF4
05CEC:  MOVLW  07
05CEE:  MOVWF  FEA
05CF0:  MOVLW  58
05CF2:  MOVWF  FE9
05CF4:  CLRF   00
05CF6:  CLRF   01
05CF8:  CLRF   02
05CFA:  CLRF   03
05CFC:  MOVLB  7
05CFE:  CLRF   x58
05D00:  CLRF   x59
05D02:  CLRF   x5A
05D04:  CLRF   x5B
05D06:  MOVF   x57,W
05D08:  IORWF  x56,W
05D0A:  IORWF  x55,W
05D0C:  IORWF  x54,W
05D0E:  BZ    5D68
05D10:  MOVLW  20
05D12:  MOVWF  x5C
05D14:  BCF    FD8.0
05D16:  RLCF   x50,F
05D18:  RLCF   x51,F
05D1A:  RLCF   x52,F
05D1C:  RLCF   x53,F
05D1E:  RLCF   x58,F
05D20:  RLCF   x59,F
05D22:  RLCF   x5A,F
05D24:  RLCF   x5B,F
05D26:  MOVF   x57,W
05D28:  SUBWF  x5B,W
05D2A:  BNZ   5D3C
05D2C:  MOVF   x56,W
05D2E:  SUBWF  x5A,W
05D30:  BNZ   5D3C
05D32:  MOVF   x55,W
05D34:  SUBWF  x59,W
05D36:  BNZ   5D3C
05D38:  MOVF   x54,W
05D3A:  SUBWF  x58,W
05D3C:  BNC   5D5C
05D3E:  MOVF   x54,W
05D40:  SUBWF  x58,F
05D42:  MOVF   x55,W
05D44:  BTFSS  FD8.0
05D46:  INCFSZ x55,W
05D48:  SUBWF  x59,F
05D4A:  MOVF   x56,W
05D4C:  BTFSS  FD8.0
05D4E:  INCFSZ x56,W
05D50:  SUBWF  x5A,F
05D52:  MOVF   x57,W
05D54:  BTFSS  FD8.0
05D56:  INCFSZ x57,W
05D58:  SUBWF  x5B,F
05D5A:  BSF    FD8.0
05D5C:  RLCF   00,F
05D5E:  RLCF   01,F
05D60:  RLCF   02,F
05D62:  RLCF   03,F
05D64:  DECFSZ x5C,F
05D66:  BRA    5D14
05D68:  MOVFF  758,FEF
05D6C:  MOVFF  759,FEC
05D70:  MOVFF  75A,FEC
05D74:  MOVFF  75B,FEC
05D78:  MOVLB  0
05D7A:  RETURN 0
05D7C:  MOVF   FE9,W
05D7E:  MOVLB  7
05D80:  MOVWF  x48
05D82:  MOVF   x47,W
05D84:  MOVWF  x4A
05D86:  BZ    5DC0
05D88:  MOVFF  746,759
05D8C:  MOVFF  745,758
05D90:  MOVFF  744,757
05D94:  MOVFF  743,756
05D98:  CLRF   x5D
05D9A:  CLRF   x5C
05D9C:  MOVLW  20
05D9E:  MOVWF  x5B
05DA0:  MOVLW  82
05DA2:  MOVWF  x5A
05DA4:  MOVLB  0
05DA6:  CALL   1138
05DAA:  MOVFF  03,746
05DAE:  MOVFF  02,745
05DB2:  MOVFF  01,744
05DB6:  MOVFF  00,743
05DBA:  MOVLB  7
05DBC:  DECFSZ x4A,F
05DBE:  BRA    5D88
05DC0:  MOVFF  746,753
05DC4:  MOVFF  745,752
05DC8:  MOVFF  744,751
05DCC:  MOVFF  743,750
05DD0:  MOVLB  0
05DD2:  RCALL  5CA6
05DD4:  MOVFF  03,746
05DD8:  MOVFF  02,745
05DDC:  MOVFF  01,744
05DE0:  MOVFF  00,743
05DE4:  MOVLB  7
05DE6:  BTFSS  x46.7
05DE8:  BRA    5E04
05DEA:  DECF   x48,F
05DEC:  BSF    x48.5
05DEE:  COMF   x43,F
05DF0:  COMF   x44,F
05DF2:  COMF   x45,F
05DF4:  COMF   x46,F
05DF6:  INCF   x43,F
05DF8:  BTFSC  FD8.2
05DFA:  INCF   x44,F
05DFC:  BTFSC  FD8.2
05DFE:  INCF   x45,F
05E00:  BTFSC  FD8.2
05E02:  INCF   x46,F
05E04:  MOVLW  3B
05E06:  MOVWF  x4F
05E08:  MOVLW  9A
05E0A:  MOVWF  x4E
05E0C:  MOVLW  CA
05E0E:  MOVWF  x4D
05E10:  CLRF   x4C
05E12:  MOVLW  0A
05E14:  MOVWF  x4A
05E16:  MOVF   x47,W
05E18:  BTFSC  FD8.2
05E1A:  INCF   x48,F
05E1C:  BSF    FD8.1
05E1E:  MOVLW  07
05E20:  MOVWF  FEA
05E22:  MOVLW  43
05E24:  MOVWF  FE9
05E26:  MOVFF  746,753
05E2A:  MOVFF  745,752
05E2E:  MOVFF  744,751
05E32:  MOVFF  743,750
05E36:  MOVFF  74F,757
05E3A:  MOVFF  74E,756
05E3E:  MOVFF  74D,755
05E42:  MOVFF  74C,754
05E46:  MOVLB  0
05E48:  RCALL  5CE8
05E4A:  MOVF   01,W
05E4C:  MOVF   00,F
05E4E:  BNZ   5E76
05E50:  MOVLB  7
05E52:  INCF   x47,W
05E54:  SUBWF  x4A,W
05E56:  BTFSS  FD8.2
05E58:  BRA    5E5E
05E5A:  MOVLB  0
05E5C:  BRA    5E76
05E5E:  MOVF   x48,W
05E60:  BZ    5E7C
05E62:  ANDLW  0F
05E64:  SUBWF  x4A,W
05E66:  BZ    5E6A
05E68:  BC    5EEA
05E6A:  BTFSC  x48.7
05E6C:  BRA    5EEA
05E6E:  BTFSC  x48.6
05E70:  BRA    5E7C
05E72:  MOVLW  20
05E74:  BRA    5EDE
05E76:  MOVLW  20
05E78:  MOVLB  7
05E7A:  ANDWF  x48,F
05E7C:  BTFSS  x48.5
05E7E:  BRA    5E9C
05E80:  BCF    x48.5
05E82:  MOVF   x47,W
05E84:  BTFSS  FD8.2
05E86:  DECF   x48,F
05E88:  MOVF   00,W
05E8A:  MOVWF  x48
05E8C:  MOVLW  2D
05E8E:  MOVWF  x50
05E90:  MOVLB  0
05E92:  RCALL  5BDE
05E94:  MOVLB  7
05E96:  MOVF   x48,W
05E98:  MOVWF  00
05E9A:  CLRF   x48
05E9C:  MOVF   x47,W
05E9E:  SUBWF  x4A,W
05EA0:  BNZ   5EBA
05EA2:  MOVF   00,W
05EA4:  MOVWF  x48
05EA6:  MOVLW  2E
05EA8:  MOVWF  x50
05EAA:  MOVLB  0
05EAC:  RCALL  5BDE
05EAE:  MOVLB  7
05EB0:  MOVF   x48,W
05EB2:  MOVWF  00
05EB4:  MOVLW  20
05EB6:  ANDWF  x48,F
05EB8:  MOVLW  00
05EBA:  MOVLW  30
05EBC:  BTFSS  x48.5
05EBE:  BRA    5EDE
05EC0:  BCF    x48.5
05EC2:  MOVF   x47,W
05EC4:  BTFSS  FD8.2
05EC6:  DECF   x48,F
05EC8:  MOVF   00,W
05ECA:  MOVWF  x48
05ECC:  MOVLW  2D
05ECE:  MOVWF  x50
05ED0:  MOVLB  0
05ED2:  RCALL  5BDE
05ED4:  MOVLB  7
05ED6:  MOVF   x48,W
05ED8:  MOVWF  00
05EDA:  CLRF   x48
05EDC:  MOVLW  30
05EDE:  ADDWF  00,F
05EE0:  MOVFF  00,750
05EE4:  MOVLB  0
05EE6:  RCALL  5BDE
05EE8:  MOVLB  7
05EEA:  BCF    FD8.1
05EEC:  MOVFF  74F,753
05EF0:  MOVFF  74E,752
05EF4:  MOVFF  74D,751
05EF8:  MOVFF  74C,750
05EFC:  CLRF   x57
05EFE:  CLRF   x56
05F00:  CLRF   x55
05F02:  MOVLW  0A
05F04:  MOVWF  x54
05F06:  MOVLB  0
05F08:  RCALL  5CE8
05F0A:  MOVFF  03,74F
05F0E:  MOVFF  02,74E
05F12:  MOVFF  01,74D
05F16:  MOVFF  00,74C
05F1A:  MOVLB  7
05F1C:  DECFSZ x4A,F
05F1E:  BRA    5E1C
05F20:  MOVLB  0
05F22:  RETURN 0
05F24:  MOVFF  FEA,708
05F28:  MOVFF  FE9,707
05F2C:  MOVLB  7
05F2E:  SWAPF  x01,W
05F30:  IORLW  F0
05F32:  MOVWF  x03
05F34:  ADDWF  x03,F
05F36:  ADDLW  E2
05F38:  MOVWF  x04
05F3A:  ADDLW  32
05F3C:  MOVWF  x06
05F3E:  MOVF   x01,W
05F40:  ANDLW  0F
05F42:  ADDWF  x04,F
05F44:  ADDWF  x04,F
05F46:  ADDWF  x06,F
05F48:  ADDLW  E9
05F4A:  MOVWF  x05
05F4C:  ADDWF  x05,F
05F4E:  ADDWF  x05,F
05F50:  SWAPF  x00,W
05F52:  ANDLW  0F
05F54:  ADDWF  x05,F
05F56:  ADDWF  x06,F
05F58:  RLCF   x05,F
05F5A:  RLCF   x06,F
05F5C:  COMF   x06,F
05F5E:  RLCF   x06,F
05F60:  MOVF   x00,W
05F62:  ANDLW  0F
05F64:  ADDWF  x06,F
05F66:  RLCF   x03,F
05F68:  MOVLW  07
05F6A:  MOVWF  x02
05F6C:  MOVLW  0A
05F6E:  DECF   x05,F
05F70:  ADDWF  x06,F
05F72:  BNC   5F6E
05F74:  DECF   x04,F
05F76:  ADDWF  x05,F
05F78:  BNC   5F74
05F7A:  DECF   x03,F
05F7C:  ADDWF  x04,F
05F7E:  BNC   5F7A
05F80:  DECF   x02,F
05F82:  ADDWF  x03,F
05F84:  BNC   5F80
05F86:  MOVLW  07
05F88:  MOVWF  FEA
05F8A:  MOVLW  02
05F8C:  MOVWF  FE9
05F8E:  MOVLW  07
05F90:  ANDWF  x07,W
05F92:  BCF    x07.6
05F94:  ADDWF  FE9,F
05F96:  MOVLW  00
05F98:  ADDWFC FEA,F
05F9A:  MOVF   FE9,W
05F9C:  SUBLW  06
05F9E:  BNZ   5FA8
05FA0:  MOVF   FEA,W
05FA2:  SUBLW  07
05FA4:  BNZ   5FA8
05FA6:  BSF    x07.6
05FA8:  MOVF   FEF,W
05FAA:  MOVWF  00
05FAC:  BNZ   5FBE
05FAE:  BTFSC  x07.6
05FB0:  BRA    5FBE
05FB2:  BTFSC  x07.4
05FB4:  BRA    5FE0
05FB6:  BTFSC  x07.3
05FB8:  BRA    5FBE
05FBA:  MOVLW  20
05FBC:  BRA    5FC4
05FBE:  BSF    x07.3
05FC0:  BCF    x07.4
05FC2:  MOVLW  30
05FC4:  ADDWF  00,F
05FC6:  MOVFF  FEA,701
05FCA:  MOVFF  FE9,700
05FCE:  MOVFF  00,750
05FD2:  MOVLB  0
05FD4:  RCALL  5BDE
05FD6:  MOVFF  701,FEA
05FDA:  MOVFF  700,FE9
05FDE:  MOVLB  7
05FE0:  MOVF   FEE,W
05FE2:  BTFSS  x07.6
05FE4:  BRA    5F9A
05FE6:  MOVLB  0
05FE8:  RETURN 0
*
0603E:  MOVF   FEF,F
06040:  BZ    6060
06042:  MOVFF  FEA,6FC
06046:  MOVFF  FE9,6FB
0604A:  MOVFF  FEF,6FD
0604E:  BRA    5FEA
06050:  MOVFF  6FC,FEA
06054:  MOVFF  6FB,FE9
06058:  INCF   FE9,F
0605A:  BTFSC  FD8.2
0605C:  INCF   FEA,F
0605E:  BRA    603E
06060:  GOTO   B0C6 (RETURN)
*
060BE:  MOVF   FEF,F
060C0:  BZ    60E0
060C2:  MOVFF  FEA,708
060C6:  MOVFF  FE9,707
060CA:  MOVFF  FEF,750
060CE:  RCALL  5BDE
060D0:  MOVFF  708,FEA
060D4:  MOVFF  707,FE9
060D8:  INCF   FE9,F
060DA:  BTFSC  FD8.2
060DC:  INCF   FEA,F
060DE:  BRA    60BE
060E0:  RETURN 0
*
06194:  TBLRD*+
06196:  MOVF   FF5,F
06198:  BZ    61B2
0619A:  MOVFF  FF6,70E
0619E:  MOVFF  FF7,70F
061A2:  MOVFF  FF5,750
061A6:  RCALL  5BDE
061A8:  MOVFF  70E,FF6
061AC:  MOVFF  70F,FF7
061B0:  BRA    6194
061B2:  RETURN 0
*
062D6:  MOVLB  7
062D8:  MOVF   x68,W
062DA:  XORWF  x6A,W
062DC:  ANDLW  80
062DE:  MOVWF  x6C
062E0:  BTFSS  x68.7
062E2:  BRA    62EE
062E4:  COMF   x67,F
062E6:  COMF   x68,F
062E8:  INCF   x67,F
062EA:  BTFSC  FD8.2
062EC:  INCF   x68,F
062EE:  BTFSS  x6A.7
062F0:  BRA    62FC
062F2:  COMF   x69,F
062F4:  COMF   x6A,F
062F6:  INCF   x69,F
062F8:  BTFSC  FD8.2
062FA:  INCF   x6A,F
062FC:  MOVF   x67,W
062FE:  MULWF  x69
06300:  MOVFF  FF3,01
06304:  MOVFF  FF4,00
06308:  MULWF  x6A
0630A:  MOVF   FF3,W
0630C:  ADDWF  00,F
0630E:  MOVF   x68,W
06310:  MULWF  x69
06312:  MOVF   FF3,W
06314:  ADDWFC 00,W
06316:  MOVWF  02
06318:  BTFSS  x6C.7
0631A:  BRA    6326
0631C:  COMF   01,F
0631E:  COMF   02,F
06320:  INCF   01,F
06322:  BTFSC  FD8.2
06324:  INCF   02,F
06326:  MOVLB  0
06328:  GOTO   65BC (RETURN)
*
06680:  MOVLW  20
06682:  MOVLB  7
06684:  BTFSS  x35.4
06686:  MOVLW  30
06688:  MOVWF  x36
0668A:  MOVFF  734,00
0668E:  BTFSS  00.7
06690:  BRA    66A2
06692:  COMF   00,F
06694:  INCF   00,F
06696:  MOVFF  00,734
0669A:  MOVLW  2D
0669C:  MOVWF  x36
0669E:  BSF    x35.7
066A0:  BSF    x35.0
066A2:  MOVF   01,W
066A4:  MOVFF  734,749
066A8:  MOVLW  64
066AA:  MOVWF  x4A
066AC:  MOVLB  0
066AE:  CALL   08B2
066B2:  MOVFF  00,734
066B6:  MOVLW  30
066B8:  ADDWF  01,W
066BA:  MOVLB  7
066BC:  MOVWF  x37
066BE:  MOVFF  734,749
066C2:  MOVLW  0A
066C4:  MOVWF  x4A
066C6:  MOVLB  0
066C8:  CALL   08B2
066CC:  MOVLW  30
066CE:  ADDWF  00,W
066D0:  MOVLB  7
066D2:  MOVWF  x39
066D4:  MOVLW  30
066D6:  ADDWF  01,W
066D8:  MOVWF  x38
066DA:  MOVFF  736,00
066DE:  MOVLW  30
066E0:  SUBWF  x37,W
066E2:  BZ    66EC
066E4:  BSF    x35.1
066E6:  BTFSC  x35.7
066E8:  BSF    x35.2
066EA:  BRA    6710
066EC:  MOVFF  736,737
066F0:  MOVLW  20
066F2:  MOVWF  x36
066F4:  MOVLW  30
066F6:  SUBWF  x38,W
066F8:  BZ    6702
066FA:  BSF    x35.0
066FC:  BTFSC  x35.7
066FE:  BSF    x35.1
06700:  BRA    6710
06702:  BTFSS  FD8.2
06704:  BSF    x35.0
06706:  BNZ   6710
06708:  MOVFF  737,738
0670C:  MOVLW  20
0670E:  MOVWF  x37
06710:  BTFSC  x35.2
06712:  BRA    671E
06714:  BTFSC  x35.1
06716:  BRA    6728
06718:  BTFSC  x35.0
0671A:  BRA    6732
0671C:  BRA    673C
0671E:  MOVFF  736,750
06722:  MOVLB  0
06724:  CALL   5BDE
06728:  MOVFF  737,750
0672C:  MOVLB  0
0672E:  CALL   5BDE
06732:  MOVFF  738,750
06736:  MOVLB  0
06738:  CALL   5BDE
0673C:  MOVFF  739,750
06740:  MOVLB  0
06742:  CALL   5BDE
06746:  RETURN 0
*
098C8:  MOVF   FE9,W
098CA:  MOVLB  7
098CC:  MOVWF  x3D
098CE:  BTFSS  x3C.7
098D0:  BRA    98EC
098D2:  DECF   x3D,F
098D4:  BSF    x3D.5
098D6:  COMF   x39,F
098D8:  COMF   x3A,F
098DA:  COMF   x3B,F
098DC:  COMF   x3C,F
098DE:  INCF   x39,F
098E0:  BTFSC  FD8.2
098E2:  INCF   x3A,F
098E4:  BTFSC  FD8.2
098E6:  INCF   x3B,F
098E8:  BTFSC  FD8.2
098EA:  INCF   x3C,F
098EC:  MOVLW  3B
098EE:  MOVWF  x44
098F0:  MOVLW  9A
098F2:  MOVWF  x43
098F4:  MOVLW  CA
098F6:  MOVWF  x42
098F8:  CLRF   x41
098FA:  MOVLW  0A
098FC:  MOVWF  x3F
098FE:  BSF    FD8.1
09900:  MOVLW  07
09902:  MOVWF  FEA
09904:  MOVLW  39
09906:  MOVWF  FE9
09908:  MOVFF  73C,753
0990C:  MOVFF  73B,752
09910:  MOVFF  73A,751
09914:  MOVFF  739,750
09918:  MOVFF  744,757
0991C:  MOVFF  743,756
09920:  MOVFF  742,755
09924:  MOVFF  741,754
09928:  MOVLB  0
0992A:  CALL   5CE8
0992E:  MOVF   01,W
09930:  MOVF   00,F
09932:  BNZ   995A
09934:  MOVLB  7
09936:  MOVF   x3F,W
09938:  XORLW  01
0993A:  BTFSS  FD8.2
0993C:  BRA    9942
0993E:  MOVLB  0
09940:  BRA    995A
09942:  MOVF   x3D,W
09944:  BZ    9960
09946:  ANDLW  0F
09948:  SUBWF  x3F,W
0994A:  BZ    994E
0994C:  BC    99AA
0994E:  BTFSC  x3D.7
09950:  BRA    99AA
09952:  BTFSC  x3D.6
09954:  BRA    9960
09956:  MOVLW  20
09958:  BRA    999C
0995A:  MOVLW  20
0995C:  MOVLB  7
0995E:  ANDWF  x3D,F
09960:  BTFSS  x3D.5
09962:  BRA    997C
09964:  BCF    x3D.5
09966:  MOVFF  00,73D
0996A:  MOVLW  2D
0996C:  MOVWF  x50
0996E:  MOVLB  0
09970:  CALL   5BDE
09974:  MOVLB  7
09976:  MOVFF  73D,00
0997A:  CLRF   x3D
0997C:  MOVLW  30
0997E:  BTFSS  x3D.5
09980:  BRA    999C
09982:  BCF    x3D.5
09984:  MOVFF  00,73D
09988:  MOVLW  2D
0998A:  MOVWF  x50
0998C:  MOVLB  0
0998E:  CALL   5BDE
09992:  MOVLB  7
09994:  MOVFF  73D,00
09998:  CLRF   x3D
0999A:  MOVLW  30
0999C:  ADDWF  00,F
0999E:  MOVFF  00,750
099A2:  MOVLB  0
099A4:  CALL   5BDE
099A8:  MOVLB  7
099AA:  BCF    FD8.1
099AC:  MOVFF  744,753
099B0:  MOVFF  743,752
099B4:  MOVFF  742,751
099B8:  MOVFF  741,750
099BC:  CLRF   x57
099BE:  CLRF   x56
099C0:  CLRF   x55
099C2:  MOVLW  0A
099C4:  MOVWF  x54
099C6:  MOVLB  0
099C8:  CALL   5CE8
099CC:  MOVFF  03,744
099D0:  MOVFF  02,743
099D4:  MOVFF  01,742
099D8:  MOVFF  00,741
099DC:  MOVLB  7
099DE:  DECFSZ x3F,F
099E0:  BRA    98FE
099E2:  MOVLB  0
099E4:  RETURN 0
.................... 
.................... #list
.................... 
.................... 
.................... #device ADC=10
.................... 
.................... //!#FUSES WDT                      //Watch Dog Timer
.................... //!#FUSES WDT4096                  //Watch Dog Timer uses 1:4096 Postscale
.................... 
.................... #use delay(internal=64000000)
*
003A4:  MOVLW  07
003A6:  MOVWF  FEA
003A8:  MOVLW  0F
003AA:  MOVWF  FE9
003AC:  MOVF   FEF,W
003AE:  BZ    03CC
003B0:  MOVLW  14
003B2:  MOVWF  01
003B4:  CLRF   00
003B6:  DECFSZ 00,F
003B8:  BRA    03B6
003BA:  DECFSZ 01,F
003BC:  BRA    03B4
003BE:  MOVLW  BF
003C0:  MOVWF  00
003C2:  DECFSZ 00,F
003C4:  BRA    03C2
003C6:  BRA    03C8
003C8:  DECFSZ FEF,F
003CA:  BRA    03B0
003CC:  RETURN 0
*
00720:  MOVLW  01
00722:  MOVLB  7
00724:  SUBWF  x07,F
00726:  BNC   073E
00728:  MOVLW  07
0072A:  MOVWF  FEA
0072C:  MOVWF  FE9
0072E:  MOVF   FEF,W
00730:  BZ    073E
00732:  MOVLW  04
00734:  MOVWF  00
00736:  DECFSZ 00,F
00738:  BRA    0736
0073A:  DECFSZ FEF,F
0073C:  BRA    0732
0073E:  MOVLB  0
00740:  RETURN 0
.................... #define baudRate 128000
.................... #define numChannels 2
.................... 
.................... #define version  "20251208" // SW Version
.................... #define serialID "0000"     // Unique Serial ID
.................... #define magPP 1             // Magnetoresistive Sensor Pole Pitch in mm   
.................... #define gainLvl 16          // 1, 2, 4, 8, 16, 32, 64, 128
.................... 
.................... 
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
*
003CE:  MOVLW  CF
003D0:  MOVWF  F87
003D2:  CLRF   F82
....................    output_b(portB_reset);
003D4:  MOVLW  C4
003D6:  MOVWF  F88
003D8:  CLRF   F83
....................    output_c(portC_reset);
003DA:  MOVLW  93
003DC:  MOVWF  F89
003DE:  CLRF   F84
....................    output_d(portD_reset);
003E0:  MOVLW  1F
003E2:  MOVWF  F8A
003E4:  CLRF   F85
....................    output_e(portE_reset);
003E6:  BCF    F8B.0
003E8:  BCF    F8B.1
003EA:  BCF    F8B.2
003EC:  BCF    F8B.3
003EE:  CLRF   F86
....................    
....................    port_a_pullups(portA_pullups);
003F0:  MOVLB  F
003F2:  SETF   x0B
....................    port_b_pullups(portB_pullups);
003F4:  CLRF   x13
....................    port_c_pullups(portC_pullups);
003F6:  CLRF   x1B
....................    port_d_pullups(portD_pullups);
003F8:  SETF   x20
....................    port_e_pullups(portE_pullups);
003FA:  CLRF   x28
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
003FC:  MOVLW  40
003FE:  MOVWF  x0C
00400:  CLRF   x14
00402:  MOVLW  03
00404:  MOVWF  x1C
00406:  MOVLW  0F
00408:  MOVWF  x21
0040A:  CLRF   x29
0040C:  MOVLB  0
0040E:  GOTO   ACF0 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
*
0611C:  MOVFF  742,FEA
06120:  MOVLB  7
06122:  MOVFF  741,FE9
06126:  MOVFF  FEF,745
0612A:  MOVFF  744,FEA
0612E:  MOVFF  743,FE9
06132:  MOVF   FEF,W
06134:  SUBWF  x45,W
06136:  BNZ   6166
....................       if (*s1 == '\0')
06138:  MOVFF  742,03
0613C:  MOVFF  741,FE9
06140:  MOVFF  03,FEA
06144:  MOVF   FEF,F
06146:  BNZ   614E
....................          return(0);
06148:  MOVLW  00
0614A:  MOVWF  01
0614C:  BRA    6190
0614E:  MOVFF  742,03
06152:  MOVF   x41,W
06154:  INCF   x41,F
06156:  BTFSC  FD8.2
06158:  INCF   x42,F
0615A:  INCF   x43,F
0615C:  BTFSC  FD8.2
0615E:  INCF   x44,F
06160:  MOVLB  0
06162:  BRA    611C
06164:  MOVLB  7
....................    return((*s1 < *s2) ? -1: 1);
06166:  MOVFF  742,03
0616A:  MOVFF  741,FE9
0616E:  MOVFF  03,FEA
06172:  MOVFF  FEF,745
06176:  MOVFF  744,03
0617A:  MOVFF  743,FE9
0617E:  MOVFF  03,FEA
06182:  MOVF   FEF,W
06184:  SUBWF  x45,W
06186:  BC    618C
06188:  MOVLW  FF
0618A:  BRA    618E
0618C:  MOVLW  01
0618E:  MOVWF  01
06190:  MOVLB  0
06192:  RETURN 0
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
*
0628C:  MOVFF  768,76B
....................    for(su=s;0<n;++su,--n)
06290:  MOVFF  767,76D
06294:  MOVFF  766,76C
06298:  MOVLB  7
0629A:  MOVF   x6A,F
0629C:  BNZ   62A4
0629E:  MOVF   x69,W
062A0:  SUBLW  00
062A2:  BC    62CC
....................       if(*su==uc)
062A4:  MOVFF  76D,FEA
062A8:  MOVFF  76C,FE9
062AC:  MOVF   x6B,W
062AE:  SUBWF  FEF,W
062B0:  BNZ   62BC
....................       return su;
062B2:  MOVFF  76C,01
062B6:  MOVFF  76D,02
062BA:  BRA    62D2
062BC:  INCF   x6C,F
062BE:  BTFSC  FD8.2
062C0:  INCF   x6D,F
062C2:  MOVF   x69,W
062C4:  BTFSC  FD8.2
062C6:  DECF   x6A,F
062C8:  DECF   x69,F
062CA:  BRA    629A
....................    return NULL;
062CC:  MOVLW  00
062CE:  MOVWF  01
062D0:  MOVWF  02
062D2:  MOVLB  0
062D4:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
*
05BA6:  MOVFF  742,744
05BAA:  MOVFF  741,743
05BAE:  MOVFF  744,FEA
05BB2:  MOVLB  7
05BB4:  MOVFF  743,FE9
05BB8:  MOVF   FEF,F
05BBA:  BZ    5BC8
05BBC:  INCF   x43,F
05BBE:  BTFSC  FD8.2
05BC0:  INCF   x44,F
05BC2:  MOVLB  0
05BC4:  BRA    5BAE
05BC6:  MOVLB  7
....................    return(sc - s);
05BC8:  MOVF   x41,W
05BCA:  SUBWF  x43,W
05BCC:  MOVWF  00
05BCE:  MOVF   x42,W
05BD0:  SUBWFB x44,W
05BD2:  MOVWF  03
05BD4:  MOVFF  00,01
05BD8:  MOVWF  02
05BDA:  MOVLB  0
05BDC:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
*
073D8:  MOVLB  7
073DA:  CLRF   x1B
073DC:  CLRF   x1A
073DE:  CLRF   x19
073E0:  MOVLW  7F
073E2:  MOVWF  x18
073E4:  CLRF   x1F
073E6:  CLRF   x1E
073E8:  CLRF   x1D
073EA:  CLRF   x1C
073EC:  BSF    x20.0
073EE:  BCF    x20.1
073F0:  BCF    x20.2
073F2:  CLRF   x22
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
073F4:  MOVF   x14,W
073F6:  IORWF  x15,W
073F8:  BNZ   7404
....................       return 0;
073FA:  CLRF   00
073FC:  CLRF   01
073FE:  CLRF   02
07400:  CLRF   03
07402:  BRA    762E
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
07404:  MOVF   x22,W
07406:  INCF   x22,F
07408:  ADDWF  x14,W
0740A:  MOVWF  FE9
0740C:  MOVLW  00
0740E:  ADDWFC x15,W
07410:  MOVWF  FEA
07412:  MOVFF  FEF,721
07416:  MOVF   x21,F
07418:  BTFSC  FD8.2
0741A:  BRA    75B2
....................    {
....................       if (skip && !isspace(c))
0741C:  BTFSS  x20.0
0741E:  BRA    743E
07420:  MOVF   x21,W
07422:  SUBLW  20
07424:  BZ    743E
....................       {
....................          skip = 0;
07426:  BCF    x20.0
....................          if (c == '+')
07428:  MOVF   x21,W
0742A:  SUBLW  2B
0742C:  BNZ   7434
....................          {
....................             sign = 0;
0742E:  BCF    x20.1
....................             continue;
07430:  BRA    759A
....................          }            
07432:  BRA    743E
....................          else if (c == '-')
07434:  MOVF   x21,W
07436:  SUBLW  2D
07438:  BNZ   743E
....................          {
....................             sign = 1;
0743A:  BSF    x20.1
....................             continue;
0743C:  BRA    759A
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
0743E:  BTFSC  x20.0
07440:  BRA    7450
07442:  MOVF   x21,W
07444:  SUBLW  2E
07446:  BNZ   7450
07448:  BTFSC  x20.2
0744A:  BRA    7450
....................          point = 1;
0744C:  BSF    x20.2
0744E:  BRA    759A
....................       else if (!skip && isdigit(c))
07450:  BTFSC  x20.0
07452:  BRA    7594
07454:  MOVF   x21,W
07456:  SUBLW  2F
07458:  BTFSC  FD8.0
0745A:  BRA    7594
0745C:  MOVF   x21,W
0745E:  SUBLW  39
07460:  BTFSS  FD8.0
07462:  BRA    7594
....................       {
....................          c -= '0';
07464:  MOVLW  30
07466:  SUBWF  x21,F
....................          if (point)
07468:  BTFSS  x20.2
0746A:  BRA    751A
....................          {
....................             pow10 = pow10 * 10.0;
0746C:  MOVFF  71B,759
07470:  MOVFF  71A,758
07474:  MOVFF  719,757
07478:  MOVFF  718,756
0747C:  CLRF   x5D
0747E:  CLRF   x5C
07480:  MOVLW  20
07482:  MOVWF  x5B
07484:  MOVLW  82
07486:  MOVWF  x5A
07488:  MOVLB  0
0748A:  CALL   1138
0748E:  MOVFF  03,71B
07492:  MOVFF  02,71A
07496:  MOVFF  01,719
0749A:  MOVFF  00,718
....................             result += (float)c / pow10;   
0749E:  MOVLB  7
074A0:  CLRF   x5B
074A2:  MOVFF  721,75A
074A6:  MOVLB  0
074A8:  CALL   2DDA
074AC:  MOVFF  03,726
074B0:  MOVFF  02,725
074B4:  MOVFF  01,724
074B8:  MOVFF  00,723
074BC:  MOVFF  03,752
074C0:  MOVFF  02,751
074C4:  MOVFF  01,750
074C8:  MOVFF  00,74F
074CC:  MOVFF  71B,756
074D0:  MOVFF  71A,755
074D4:  MOVFF  719,754
074D8:  MOVFF  718,753
074DC:  CALL   2450
074E0:  BCF    FD8.1
074E2:  MOVFF  71F,75D
074E6:  MOVFF  71E,75C
074EA:  MOVFF  71D,75B
074EE:  MOVFF  71C,75A
074F2:  MOVFF  03,761
074F6:  MOVFF  02,760
074FA:  MOVFF  01,75F
074FE:  MOVFF  00,75E
07502:  CALL   0DFE
07506:  MOVFF  03,71F
0750A:  MOVFF  02,71E
0750E:  MOVFF  01,71D
07512:  MOVFF  00,71C
....................          }
07516:  BRA    7590
07518:  MOVLB  7
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
0751A:  CLRF   x59
0751C:  CLRF   x58
0751E:  MOVLW  20
07520:  MOVWF  x57
07522:  MOVLW  82
07524:  MOVWF  x56
07526:  MOVFF  71F,75D
0752A:  MOVFF  71E,75C
0752E:  MOVFF  71D,75B
07532:  MOVFF  71C,75A
07536:  MOVLB  0
07538:  CALL   1138
0753C:  MOVFF  03,726
07540:  MOVFF  02,725
07544:  MOVFF  01,724
07548:  MOVFF  00,723
0754C:  MOVLB  7
0754E:  CLRF   x5B
07550:  MOVFF  721,75A
07554:  MOVLB  0
07556:  CALL   2DDA
0755A:  BCF    FD8.1
0755C:  MOVFF  726,75D
07560:  MOVFF  725,75C
07564:  MOVFF  724,75B
07568:  MOVFF  723,75A
0756C:  MOVFF  03,761
07570:  MOVFF  02,760
07574:  MOVFF  01,75F
07578:  MOVFF  00,75E
0757C:  CALL   0DFE
07580:  MOVFF  03,71F
07584:  MOVFF  02,71E
07588:  MOVFF  01,71D
0758C:  MOVFF  00,71C
....................          }
....................       }
07590:  BRA    759C
07592:  MOVLB  7
....................       else if (!skip)
07594:  BTFSC  x20.0
07596:  BRA    759A
....................          break;
07598:  BRA    75B2
0759A:  MOVLB  0
0759C:  MOVLB  7
0759E:  MOVF   x22,W
075A0:  INCF   x22,F
075A2:  ADDWF  x14,W
075A4:  MOVWF  FE9
075A6:  MOVLW  00
075A8:  ADDWFC x15,W
075AA:  MOVWF  FEA
075AC:  MOVFF  FEF,721
075B0:  BRA    7416
....................    }
.................... 
....................    if (sign)
075B2:  BTFSS  x20.1
075B4:  BRA    75EA
....................       result = -1*result;
075B6:  CLRF   x59
075B8:  CLRF   x58
075BA:  MOVLW  80
075BC:  MOVWF  x57
075BE:  MOVLW  7F
075C0:  MOVWF  x56
075C2:  MOVFF  71F,75D
075C6:  MOVFF  71E,75C
075CA:  MOVFF  71D,75B
075CE:  MOVFF  71C,75A
075D2:  MOVLB  0
075D4:  CALL   1138
075D8:  MOVFF  03,71F
075DC:  MOVFF  02,71E
075E0:  MOVFF  01,71D
075E4:  MOVFF  00,71C
075E8:  MOVLB  7
....................       
....................    if(endptr)
075EA:  MOVF   x16,W
075EC:  IORWF  x17,W
075EE:  BZ    761E
....................    {
....................       if (ptr) {
075F0:  MOVF   x22,F
075F2:  BZ    760C
....................          ptr--;
075F4:  DECF   x22,F
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
075F6:  MOVFF  717,FEA
075FA:  MOVFF  716,FE9
075FE:  MOVF   x22,W
07600:  ADDWF  x14,W
07602:  MOVWF  FEF
07604:  MOVLW  00
07606:  ADDWFC x15,W
07608:  MOVWF  FEC
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
0760A:  BRA    761E
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
0760C:  MOVFF  717,FEA
07610:  MOVFF  716,FE9
07614:  MOVFF  715,FEC
07618:  MOVF   FED,F
0761A:  MOVFF  714,FEF
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
0761E:  MOVFF  71C,00
07622:  MOVFF  71D,01
07626:  MOVFF  71E,02
0762A:  MOVFF  71F,03
0762E:  MOVLB  0
07630:  RETURN 0
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
*
0632C:  MOVLB  7
0632E:  CLRF   x3F
06330:  CLRF   x3E
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
06332:  MOVLW  30
06334:  MOVWF  x41
06336:  MOVLW  31
06338:  MOVWF  x42
0633A:  MOVLW  32
0633C:  MOVWF  x43
0633E:  MOVLW  33
06340:  MOVWF  x44
06342:  MOVLW  34
06344:  MOVWF  x45
06346:  MOVLW  35
06348:  MOVWF  x46
0634A:  MOVLW  36
0634C:  MOVWF  x47
0634E:  MOVLW  37
06350:  MOVWF  x48
06352:  MOVLW  38
06354:  MOVWF  x49
06356:  MOVLW  39
06358:  MOVWF  x4A
0635A:  MOVLW  61
0635C:  MOVWF  x4B
0635E:  MOVLW  62
06360:  MOVWF  x4C
06362:  MOVLW  63
06364:  MOVWF  x4D
06366:  MOVLW  64
06368:  MOVWF  x4E
0636A:  MOVLW  65
0636C:  MOVWF  x4F
0636E:  MOVLW  66
06370:  MOVWF  x50
06372:  MOVLW  67
06374:  MOVWF  x51
06376:  MOVLW  68
06378:  MOVWF  x52
0637A:  MOVLW  69
0637C:  MOVWF  x53
0637E:  MOVLW  6A
06380:  MOVWF  x54
06382:  MOVLW  6B
06384:  MOVWF  x55
06386:  MOVLW  6C
06388:  MOVWF  x56
0638A:  MOVLW  6D
0638C:  MOVWF  x57
0638E:  MOVLW  6E
06390:  MOVWF  x58
06392:  MOVLW  6F
06394:  MOVWF  x59
06396:  MOVLW  70
06398:  MOVWF  x5A
0639A:  MOVLW  71
0639C:  MOVWF  x5B
0639E:  MOVLW  73
063A0:  MOVWF  x5C
063A2:  MOVLW  74
063A4:  MOVWF  x5D
063A6:  MOVLW  75
063A8:  MOVWF  x5E
063AA:  MOVLW  76
063AC:  MOVWF  x5F
063AE:  MOVLW  77
063B0:  MOVWF  x60
063B2:  MOVLW  78
063B4:  MOVWF  x61
063B6:  MOVLW  79
063B8:  MOVWF  x62
063BA:  MOVLW  7A
063BC:  MOVWF  x63
063BE:  CLRF   x64
....................    for(sc=s;isspace(*sc);++sc);
063C0:  MOVFF  734,739
063C4:  MOVFF  733,738
063C8:  MOVFF  739,FEA
063CC:  MOVFF  738,FE9
063D0:  MOVF   FEF,W
063D2:  SUBLW  20
063D4:  BNZ   63DE
063D6:  INCF   x38,F
063D8:  BTFSC  FD8.2
063DA:  INCF   x39,F
063DC:  BRA    63C8
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
063DE:  MOVFF  739,03
063E2:  MOVFF  738,FE9
063E6:  MOVFF  03,FEA
063EA:  MOVF   FEF,W
063EC:  SUBLW  2D
063EE:  BZ    63FE
063F0:  MOVFF  739,FEA
063F4:  MOVFF  738,FE9
063F8:  MOVF   FEF,W
063FA:  SUBLW  2B
063FC:  BNZ   6410
063FE:  MOVFF  739,FEA
06402:  MOVF   x38,W
06404:  INCF   x38,F
06406:  BTFSC  FD8.2
06408:  INCF   x39,F
0640A:  MOVWF  FE9
0640C:  MOVF   FEF,W
0640E:  BRA    6412
06410:  MOVLW  2B
06412:  MOVWF  x40
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
06414:  MOVF   x40,W
06416:  SUBLW  2D
06418:  BZ    642E
0641A:  BTFSC  x37.7
0641C:  BRA    642E
0641E:  DECFSZ x37,W
06420:  BRA    6424
06422:  BRA    642E
06424:  BTFSC  x37.7
06426:  BRA    6432
06428:  MOVF   x37,W
0642A:  SUBLW  24
0642C:  BC    6432
....................    goto StrtoulGO;
0642E:  BRA    663A
06430:  BRA    652A
.................... 
....................    else if (base)
06432:  MOVF   x37,F
06434:  BZ    64C2
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
06436:  MOVF   x37,W
06438:  SUBLW  10
0643A:  BNZ   6476
0643C:  MOVFF  739,FEA
06440:  MOVFF  738,FE9
06444:  MOVF   FEF,W
06446:  SUBLW  30
06448:  BNZ   6476
0644A:  MOVLW  01
0644C:  ADDWF  x38,W
0644E:  MOVWF  FE9
06450:  MOVLW  00
06452:  ADDWFC x39,W
06454:  MOVWF  FEA
06456:  MOVF   FEF,W
06458:  SUBLW  78
0645A:  BZ    646E
0645C:  MOVLW  01
0645E:  ADDWF  x38,W
06460:  MOVWF  FE9
06462:  MOVLW  00
06464:  ADDWFC x39,W
06466:  MOVWF  FEA
06468:  MOVF   FEF,W
0646A:  SUBLW  58
0646C:  BNZ   6476
....................          sc+=2;
0646E:  MOVLW  02
06470:  ADDWF  x38,F
06472:  MOVLW  00
06474:  ADDWFC x39,F
....................       if(base==8 && *sc =='0')
06476:  MOVF   x37,W
06478:  SUBLW  08
0647A:  BNZ   6492
0647C:  MOVFF  739,FEA
06480:  MOVFF  738,FE9
06484:  MOVF   FEF,W
06486:  SUBLW  30
06488:  BNZ   6492
....................          sc+=1;
0648A:  MOVLW  01
0648C:  ADDWF  x38,F
0648E:  MOVLW  00
06490:  ADDWFC x39,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
06492:  MOVF   x37,W
06494:  SUBLW  02
06496:  BNZ   64C0
06498:  MOVFF  739,FEA
0649C:  MOVFF  738,FE9
064A0:  MOVF   FEF,W
064A2:  SUBLW  30
064A4:  BNZ   64C0
064A6:  MOVLW  01
064A8:  ADDWF  x38,W
064AA:  MOVWF  FE9
064AC:  MOVLW  00
064AE:  ADDWFC x39,W
064B0:  MOVWF  FEA
064B2:  MOVF   FEF,W
064B4:  SUBLW  62
064B6:  BNZ   64C0
....................          sc+=2;
064B8:  MOVLW  02
064BA:  ADDWF  x38,F
064BC:  MOVLW  00
064BE:  ADDWFC x39,F
.................... 
....................    }
064C0:  BRA    652A
....................    else if(*sc!='0') // base is 0, find base
064C2:  MOVFF  739,FEA
064C6:  MOVFF  738,FE9
064CA:  MOVF   FEF,W
064CC:  SUBLW  30
064CE:  BZ    64D6
....................       base=10;
064D0:  MOVLW  0A
064D2:  MOVWF  x37
064D4:  BRA    652A
....................    else if (sc[1]=='x' || sc[1]=='X')
064D6:  MOVLW  01
064D8:  ADDWF  x38,W
064DA:  MOVWF  FE9
064DC:  MOVLW  00
064DE:  ADDWFC x39,W
064E0:  MOVWF  FEA
064E2:  MOVF   FEF,W
064E4:  SUBLW  78
064E6:  BZ    64FA
064E8:  MOVLW  01
064EA:  ADDWF  x38,W
064EC:  MOVWF  FE9
064EE:  MOVLW  00
064F0:  ADDWFC x39,W
064F2:  MOVWF  FEA
064F4:  MOVF   FEF,W
064F6:  SUBLW  58
064F8:  BNZ   6508
....................       base =16,sc+=2;
064FA:  MOVLW  10
064FC:  MOVWF  x37
064FE:  MOVLW  02
06500:  ADDWF  x38,F
06502:  MOVLW  00
06504:  ADDWFC x39,F
06506:  BRA    652A
....................    else if(sc[1]=='b')
06508:  MOVLW  01
0650A:  ADDWF  x38,W
0650C:  MOVWF  FE9
0650E:  MOVLW  00
06510:  ADDWFC x39,W
06512:  MOVWF  FEA
06514:  MOVF   FEF,W
06516:  SUBLW  62
06518:  BNZ   6526
....................       base=2,sc+=2;
0651A:  MOVLW  02
0651C:  MOVWF  x37
0651E:  ADDWF  x38,F
06520:  MOVLW  00
06522:  ADDWFC x39,F
06524:  BRA    652A
....................    else
....................       base=8;
06526:  MOVLW  08
06528:  MOVWF  x37
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
0652A:  MOVFF  739,73B
0652E:  MOVFF  738,73A
06532:  MOVFF  739,FEA
06536:  MOVFF  738,FE9
0653A:  MOVF   FEF,W
0653C:  SUBLW  30
0653E:  BNZ   6548
06540:  INCF   x38,F
06542:  BTFSC  FD8.2
06544:  INCF   x39,F
06546:  BRA    6532
....................    sd=memchr(digits,tolower(*sc),base);
06548:  MOVFF  739,03
0654C:  MOVFF  738,FE9
06550:  MOVFF  03,FEA
06554:  MOVFF  FEF,765
06558:  MOVF   x65,W
0655A:  SUBLW  40
0655C:  BC    656A
0655E:  MOVF   x65,W
06560:  SUBLW  5A
06562:  BNC   656A
06564:  MOVF   x65,W
06566:  IORLW  20
06568:  BRA    656C
0656A:  MOVF   x65,W
0656C:  MOVWF  x65
0656E:  MOVLW  07
06570:  MOVWF  x67
06572:  MOVLW  41
06574:  MOVWF  x66
06576:  MOVFF  765,768
0657A:  CLRF   x6A
0657C:  MOVFF  737,769
06580:  BTFSC  x69.7
06582:  DECF   x6A,F
06584:  MOVLB  0
06586:  RCALL  628C
06588:  MOVFF  02,73D
0658C:  MOVFF  01,73C
....................    for(; sd!=0; )
06590:  MOVLB  7
06592:  MOVF   x3C,F
06594:  BNZ   659A
06596:  MOVF   x3D,F
06598:  BZ    662E
....................    {
....................       x=x*base+(int16)(sd-digits);
0659A:  CLRF   03
0659C:  MOVF   x37,W
0659E:  MOVWF  00
065A0:  BTFSC  FE8.7
065A2:  DECF   03,F
065A4:  MOVWF  x65
065A6:  MOVFF  03,766
065AA:  MOVFF  73F,768
065AE:  MOVFF  73E,767
065B2:  MOVFF  03,76A
065B6:  MOVWF  x69
065B8:  MOVLB  0
065BA:  BRA    62D6
065BC:  MOVFF  01,765
065C0:  MOVLW  41
065C2:  MOVLB  7
065C4:  SUBWF  x3C,W
065C6:  MOVWF  00
065C8:  MOVLW  07
065CA:  SUBWFB x3D,W
065CC:  MOVWF  03
065CE:  MOVF   00,W
065D0:  ADDWF  01,W
065D2:  MOVWF  01
065D4:  MOVF   02,W
065D6:  ADDWFC 03,F
065D8:  MOVFF  01,73E
065DC:  MOVFF  03,73F
....................       ++sc;
065E0:  INCF   x38,F
065E2:  BTFSC  FD8.2
065E4:  INCF   x39,F
....................       sd=memchr(digits,tolower(*sc),base);
065E6:  MOVFF  739,FEA
065EA:  MOVFF  738,FE9
065EE:  MOVFF  FEF,765
065F2:  MOVF   x65,W
065F4:  SUBLW  40
065F6:  BC    6604
065F8:  MOVF   x65,W
065FA:  SUBLW  5A
065FC:  BNC   6604
065FE:  MOVF   x65,W
06600:  IORLW  20
06602:  BRA    6606
06604:  MOVF   x65,W
06606:  MOVWF  x65
06608:  MOVLW  07
0660A:  MOVWF  x67
0660C:  MOVLW  41
0660E:  MOVWF  x66
06610:  MOVFF  765,768
06614:  CLRF   x6A
06616:  MOVFF  737,769
0661A:  BTFSC  x69.7
0661C:  DECF   x6A,F
0661E:  MOVLB  0
06620:  RCALL  628C
06622:  MOVFF  02,73D
06626:  MOVFF  01,73C
0662A:  BRA    6590
0662C:  MOVLB  7
....................    }
....................    if(s1==sc)
0662E:  MOVF   x38,W
06630:  SUBWF  x3A,W
06632:  BNZ   665C
06634:  MOVF   x39,W
06636:  SUBWF  x3B,W
06638:  BNZ   665C
....................    {
....................    StrtoulGO:
....................       if (endptr)
0663A:  MOVLB  7
0663C:  MOVF   x35,W
0663E:  IORWF  x36,W
06640:  BZ    6654
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
06642:  MOVFF  736,FEA
06646:  MOVFF  735,FE9
0664A:  MOVFF  734,FEC
0664E:  MOVF   FED,F
06650:  MOVFF  733,FEF
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
06654:  MOVLW  00
06656:  MOVWF  01
06658:  MOVWF  02
0665A:  BRA    667C
....................    }
....................    if (endptr)
0665C:  MOVF   x35,W
0665E:  IORWF  x36,W
06660:  BZ    6674
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
06662:  MOVFF  736,FEA
06666:  MOVFF  735,FE9
0666A:  MOVFF  739,FEC
0666E:  MOVF   FED,F
06670:  MOVFF  738,FEF
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
06674:  MOVFF  73E,01
06678:  MOVFF  73F,02
0667C:  MOVLB  0
0667E:  RETURN 0
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................     float kP;      // proportional gain
....................     float kI;      // integral gain
....................     float kD;      // derivative gain
....................     float SP;      // set point-- desired output
....................     float PV;      // process variable-- measured output
....................     float PVold;   // oldPV value  
....................     float CV;      // control variable-- output -- 0 to 100%
....................     float I;       // integral value
....................     float maxSP;   // Max setpoint in microns
....................     float minSP;   // Min setpoint in microns
.................... }PID[2] = {
....................    //  P     I     D
....................    //0.01    0.3   0.1
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}, 
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}
....................     };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... //!#define op_upper_bound 63  // CRYO
.................... //!#define op_lower_bound -63 // CRYO
.................... 
.................... #define op_upper_bound 63  // AMBIENT 
.................... #define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    BOOLEAN homeFlag;       // Flag to trigger the homing routine
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,FALSE},
....................    {0,0,0,0,0,0,0,0,0,0,FALSE}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................     BOOLEAN invV;
....................     unsigned int16 ipVal;
....................     float opPcnt;
....................    
.................... }dacVals[2] = 
.................... {
....................     {FALSE,0,0},
....................     {FALSE,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
*
00474:  MOVLB  7
00476:  CLRF   x00
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
00478:  CLRF   x00
0047A:  MOVLB  6
0047C:  MOVF   xFF,W
0047E:  MOVLB  7
00480:  SUBWF  x00,W
00482:  BC    04E4
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
00484:  MOVF   x00,W
00486:  MOVLB  6
00488:  ADDWF  xFD,W
0048A:  MOVLB  7
0048C:  MOVWF  x01
0048E:  MOVLW  00
00490:  MOVLB  6
00492:  ADDWFC xFE,W
00494:  MOVLB  7
00496:  MOVWF  x02
00498:  MOVF   x00,W
0049A:  MOVLB  6
0049C:  ADDWF  xFB,W
0049E:  MOVWF  01
004A0:  MOVLW  00
004A2:  ADDWFC xFC,W
004A4:  MOVWF  03
004A6:  MOVF   01,W
004A8:  MOVWF  FE9
004AA:  MOVFF  03,FEA
004AE:  MOVFF  FEF,703
004B2:  BSF    F7F.7
004B4:  MOVF   FF2,W
004B6:  MOVWF  00
004B8:  BCF    FF2.7
004BA:  MOVFF  702,F7A
004BE:  MOVFF  701,F79
004C2:  MOVLW  31
004C4:  MOVWF  F7B
004C6:  MOVFF  703,F7C
004CA:  MOVLB  F
004CC:  MOVLW  55
004CE:  MOVWF  F81
004D0:  MOVLW  AA
004D2:  MOVWF  F81
004D4:  BSF    F80.4
004D6:  BTFSC  F80.4
004D8:  BRA    04D6
004DA:  MOVF   00,W
004DC:  IORWF  FF2,F
004DE:  MOVLB  7
004E0:  INCF   x00,F
004E2:  BRA    047A
....................    }
004E4:  MOVLB  0
004E6:  RETURN 0
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
*
00412:  MOVLB  7
00414:  CLRF   x00
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
00416:  CLRF   x00
00418:  MOVLB  6
0041A:  MOVF   xFF,W
0041C:  MOVLB  7
0041E:  SUBWF  x00,W
00420:  BC    0470
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
00422:  MOVF   x00,W
00424:  MOVLB  6
00426:  ADDWF  xFB,W
00428:  MOVWF  01
0042A:  MOVLW  00
0042C:  ADDWFC xFC,W
0042E:  MOVWF  03
00430:  MOVF   01,W
00432:  MOVWF  FE9
00434:  MOVFF  03,FEA
00438:  MOVLB  7
0043A:  MOVF   x00,W
0043C:  MOVLB  6
0043E:  ADDWF  xFD,W
00440:  MOVLB  7
00442:  MOVWF  x03
00444:  MOVLW  00
00446:  MOVLB  6
00448:  ADDWFC xFE,W
0044A:  MOVLB  7
0044C:  MOVWF  x04
0044E:  BSF    F7F.7
00450:  MOVFF  FF2,705
00454:  BCF    FF2.7
00456:  MOVFF  704,F7A
0045A:  MOVFF  703,F79
0045E:  MOVLW  31
00460:  MOVWF  F7B
00462:  BSF    F80.0
00464:  MOVF   F7C,W
00466:  BTFSC  x05.7
00468:  BSF    FF2.7
0046A:  MOVWF  FEF
0046C:  INCF   x00,F
0046E:  BRA    0418
....................    }
00470:  MOVLB  0
00472:  RETURN 0
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
*
004E8:  MOVLB  6
004EA:  CLRF   xFC
004EC:  MOVLW  20
004EE:  MOVWF  xFB
004F0:  CLRF   xFE
004F2:  CLRF   xFD
004F4:  MOVLW  80
004F6:  MOVWF  xFF
004F8:  MOVLB  0
004FA:  RCALL  0474
....................    delay_ms(1);
004FC:  MOVLW  01
004FE:  MOVLB  7
00500:  MOVWF  x0F
00502:  MOVLB  0
00504:  RCALL  03A4
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
00506:  MOVLB  6
00508:  CLRF   xFC
0050A:  MOVLW  70
0050C:  MOVWF  xFB
0050E:  CLRF   xFE
00510:  MOVLW  80
00512:  MOVWF  xFD
00514:  MOVLW  02
00516:  MOVWF  xFF
00518:  MOVLB  0
0051A:  RCALL  0474
....................    delay_ms(1);
0051C:  MOVLW  01
0051E:  MOVLB  7
00520:  MOVWF  x0F
00522:  MOVLB  0
00524:  RCALL  03A4
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
00526:  MOVLB  6
00528:  CLRF   xFC
0052A:  MOVLW  71
0052C:  MOVWF  xFB
0052E:  CLRF   xFE
00530:  MOVLW  90
00532:  MOVWF  xFD
00534:  MOVLW  02
00536:  MOVWF  xFF
00538:  MOVLB  0
0053A:  RCALL  0474
....................    delay_ms(1);
0053C:  MOVLW  01
0053E:  MOVLB  7
00540:  MOVWF  x0F
00542:  MOVLB  0
00544:  RCALL  03A4
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
00546:  MOVLB  6
00548:  CLRF   xFC
0054A:  MOVLW  72
0054C:  MOVWF  xFB
0054E:  CLRF   xFE
00550:  MOVLW  A0
00552:  MOVWF  xFD
00554:  MOVLW  20
00556:  MOVWF  xFF
00558:  MOVLB  0
0055A:  RCALL  0474
....................    delay_ms(1);
0055C:  MOVLW  01
0055E:  MOVLB  7
00560:  MOVWF  x0F
00562:  MOVLB  0
00564:  RCALL  03A4
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
00566:  MOVLB  6
00568:  CLRF   xFC
0056A:  MOVLW  92
0056C:  MOVWF  xFB
0056E:  CLRF   xFE
00570:  MOVLW  C0
00572:  MOVWF  xFD
00574:  MOVLW  30
00576:  MOVWF  xFF
00578:  MOVLB  0
0057A:  RCALL  0474
....................    delay_ms(1);
0057C:  MOVLW  01
0057E:  MOVLB  7
00580:  MOVWF  x0F
00582:  MOVLB  0
00584:  RCALL  03A4
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
00586:  MOVLB  6
00588:  CLRF   xFC
0058A:  MOVLW  C2
0058C:  MOVWF  xFB
0058E:  CLRF   xFE
00590:  MOVLW  F0
00592:  MOVWF  xFD
00594:  MOVLW  38
00596:  MOVWF  xFF
00598:  MOVLB  0
0059A:  RCALL  0474
....................    delay_ms(1);
0059C:  MOVLW  01
0059E:  MOVLB  7
005A0:  MOVWF  x0F
005A2:  MOVLB  0
005A4:  RCALL  03A4
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
005A6:  MOVLB  6
005A8:  CLRF   xFC
005AA:  MOVLW  FA
005AC:  MOVWF  xFB
005AE:  MOVLW  01
005B0:  MOVWF  xFE
005B2:  MOVLW  40
005B4:  MOVWF  xFD
005B6:  MOVLW  01
005B8:  MOVWF  xFF
005BA:  MOVLB  0
005BC:  RCALL  0474
....................    delay_ms(1);
005BE:  MOVLW  01
005C0:  MOVLB  7
005C2:  MOVWF  x0F
005C4:  MOVLB  0
005C6:  RCALL  03A4
005C8:  GOTO   0698 (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
005CC:  MOVLB  6
005CE:  CLRF   xFC
005D0:  MOVLW  20
005D2:  MOVWF  xFB
005D4:  CLRF   xFE
005D6:  CLRF   xFD
005D8:  MOVLW  80
005DA:  MOVWF  xFF
005DC:  MOVLB  0
005DE:  RCALL  0412
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
005E0:  MOVLB  6
005E2:  CLRF   xFC
005E4:  MOVLW  70
005E6:  MOVWF  xFB
005E8:  CLRF   xFE
005EA:  MOVLW  80
005EC:  MOVWF  xFD
005EE:  MOVLW  02
005F0:  MOVWF  xFF
005F2:  MOVLB  0
005F4:  RCALL  0412
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
005F6:  MOVLB  6
005F8:  CLRF   xFC
005FA:  MOVLW  71
005FC:  MOVWF  xFB
005FE:  CLRF   xFE
00600:  MOVLW  90
00602:  MOVWF  xFD
00604:  MOVLW  02
00606:  MOVWF  xFF
00608:  MOVLB  0
0060A:  RCALL  0412
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
0060C:  MOVLB  6
0060E:  CLRF   xFC
00610:  MOVLW  72
00612:  MOVWF  xFB
00614:  CLRF   xFE
00616:  MOVLW  A0
00618:  MOVWF  xFD
0061A:  MOVLW  20
0061C:  MOVWF  xFF
0061E:  MOVLB  0
00620:  RCALL  0412
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
00622:  MOVLB  6
00624:  CLRF   xFC
00626:  MOVLW  92
00628:  MOVWF  xFB
0062A:  CLRF   xFE
0062C:  MOVLW  C0
0062E:  MOVWF  xFD
00630:  MOVLW  30
00632:  MOVWF  xFF
00634:  MOVLB  0
00636:  RCALL  0412
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
00638:  MOVLB  6
0063A:  CLRF   xFC
0063C:  MOVLW  C2
0063E:  MOVWF  xFB
00640:  CLRF   xFE
00642:  MOVLW  F0
00644:  MOVWF  xFD
00646:  MOVLW  38
00648:  MOVWF  xFF
0064A:  MOVLB  0
0064C:  RCALL  0412
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
0064E:  MOVLB  6
00650:  CLRF   xFC
00652:  MOVLW  FA
00654:  MOVWF  xFB
00656:  MOVLW  01
00658:  MOVWF  xFE
0065A:  MOVLW  40
0065C:  MOVWF  xFD
0065E:  MOVLW  01
00660:  MOVWF  xFF
00662:  MOVLB  0
00664:  RCALL  0412
00666:  GOTO   069C (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
0066A:  MOVLB  6
0066C:  CLRF   xFC
0066E:  MOVLW  FA
00670:  MOVWF  xFB
00672:  MOVLW  01
00674:  MOVWF  xFE
00676:  MOVLW  40
00678:  MOVWF  xFD
0067A:  MOVLW  01
0067C:  MOVWF  xFF
0067E:  MOVLB  0
00680:  RCALL  0412
....................    delay_ms(1);
00682:  MOVLW  01
00684:  MOVLB  7
00686:  MOVWF  x0F
00688:  MOVLB  0
0068A:  RCALL  03A4
....................    if (paramsValid != isValid)
0068C:  MOVF   xFA,W
0068E:  SUBLW  AA
00690:  BZ    069A
....................    {
....................       paramsValid = isValid;
00692:  MOVLW  AA
00694:  MOVWF  xFA
....................       params_save_to_ee(); // saves the base parameters on first boot
00696:  BRA    04E8
....................    }
00698:  BRA    069C
....................    else
....................    {
....................       params_load_from_ee();
0069A:  BRA    05CC
....................    }
0069C:  GOTO   ACF4 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <monitor.h>
.................... #ifndef monitor
.................... #define monitor
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
....................    output_b(portB_reset);
....................    output_c(portC_reset);
....................    output_d(portD_reset);
....................    output_e(portE_reset);
....................    
....................    port_a_pullups(portA_pullups);
....................    port_b_pullups(portB_pullups);
....................    port_c_pullups(portC_pullups);
....................    port_d_pullups(portD_pullups);
....................    port_e_pullups(portE_pullups);
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................     float kP;      // proportional gain
....................     float kI;      // integral gain
....................     float kD;      // derivative gain
....................     float SP;      // set point-- desired output
....................     float PV;      // process variable-- measured output
....................     float PVold;   // oldPV value  
....................     float CV;      // control variable-- output -- 0 to 100%
....................     float I;       // integral value
....................     float maxSP;   // Max setpoint in microns
....................     float minSP;   // Min setpoint in microns
.................... }PID[2] = {
....................    //  P     I     D
....................    //0.01    0.3   0.1
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}, 
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}
....................     };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... //!#define op_upper_bound 63  // CRYO
.................... //!#define op_lower_bound -63 // CRYO
.................... 
.................... #define op_upper_bound 63  // AMBIENT 
.................... #define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    BOOLEAN homeFlag;       // Flag to trigger the homing routine
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,FALSE},
....................    {0,0,0,0,0,0,0,0,0,0,FALSE}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................     BOOLEAN invV;
....................     unsigned int16 ipVal;
....................     float opPcnt;
....................    
.................... }dacVals[2] = 
.................... {
....................     {FALSE,0,0},
....................     {FALSE,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <ADS1220.h>
.................... #ifndef ADS1220
.................... #define ADS1220
.................... 
.................... /*****************************************************************************/
.................... /* SET UP PORTS FOR USE WITH DRIVER                                          */
.................... /*****************************************************************************/
.................... #define _CS0  PIN_D5 // chip select pins 
.................... #define _CS1  PIN_D6
.................... #define _CS2  PIN_D7
.................... #define _CS3  PIN_B0
.................... 
.................... #pin_select SCK2=PIN_B1
.................... #pin_select SDI2=PIN_B2
.................... #pin_select SDO2=PIN_B3
.................... #use spi(MASTER, SPI2, BAUD=4096000, MODE=1, STREAM=SPI_mon)
.................... //!setup_spi2(SPI_MASTER | SPI_SCK_IDLE_LOW | SPI_XMIT_H_TO_L | SPI_CLK_DIV_64);
.................... 
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* REGISTER DEFINITIONS                                                      */
.................... /*****************************************************************************/
.................... typedef enum {reg0 = 0x00,reg1 = 0x04 ,reg2 = 0x08, reg3 = 0x0C}adsReg;
.................... 
.................... //REGISTER 0 OPTIONS
.................... 
.................... #define IPp0n1 0x00
.................... #define IPp0n2 0x10
.................... #define IPp0n3 0x20
.................... #define IPp1n2 0x30
.................... #define IPp1n3 0x40
.................... #define IPp2n3 0x50
.................... #define IPp1n0 0x60
.................... #define IPp3n2 0x70
.................... #define IPp0nVss 0x80
.................... #define IPp1nVss 0x90
.................... #define IPp2nVss 0xA0
.................... #define IPp3nVss 0xB0
.................... #define IPVrpVrn 0xC0
.................... #define IPVddVss 0xD0
.................... #define IPhalfRail 0xE0
.................... 
.................... #define g1 0x00
.................... #define g2 0x02
.................... #define g4 0x04
.................... #define g8 0x06
.................... #define g16 0x08
.................... #define g32 0x0A
.................... #define g64 0x0C
.................... #define g128 0x0E
.................... 
.................... #define PGAenabled 0x00
.................... #define PGAbypass 0x01
.................... 
.................... //REGISTER 1 OPTIONS
.................... 
.................... #define DRn20 0x00
.................... #define DRn45 0x20
.................... #define DRn90 0x40
.................... #define DRn175 0x60
.................... #define DRn330 0x80
.................... #define DRn600 0xA0
.................... #define DRn1000 0xC0
.................... 
.................... #define MDnormal 0x00
.................... #define MDduty 0x80
.................... #define MDturbo 0x10
.................... 
.................... #define CMsingle 0x00
.................... #define CMcont 0x40
.................... 
.................... #define TSdisable 0x00
.................... #define TSenable 0x20
.................... 
.................... #define BCSoff 0x00
.................... #define BCSon 0x01
.................... 
.................... //REGISTER 2 OPTIONS
.................... 
.................... #define REFinternal 0x00
.................... #define REFp0n0 0x40
.................... #define REFp1n1 0x80
.................... #define REFVddVss 0xC0
.................... 
.................... #define FIRoff 0x00
.................... #define FIR5060 0x10
.................... #define FIR50 0x20
.................... #define FIR60 0x30
.................... 
.................... #define PSWopen 0x00
.................... #define PSWstart 0x08
.................... 
.................... #define Ioff 0x00
.................... #define Iu10 0x01
.................... #define Iu50 0x02
.................... #define Iu100 0x03
.................... #define Iu250 0x04
.................... #define Iu500 0x05
.................... #define Iu1000 0x06
.................... #define Iu1500 0x07  
.................... 
.................... //REGISTER 3 OPTIONS
.................... 
.................... #define I1disabled 0x00
.................... #define I1a0p1 0x20
.................... #define I1a1 0x40
.................... #define I1a2 0x60
.................... #define I1a3n1 0x80
.................... #define I1p0 0xA0
.................... #define I1n0 0xC0
.................... 
.................... #define I2disabled 0x00
.................... #define I2a0p1 0x04
.................... #define I2a1 0x08
.................... #define I2a2 0x0A
.................... #define I2a3n1 0x10
.................... #define I2p0 0x14
.................... #define I2n0 0x18
.................... 
.................... #define drdyPin 0x00
.................... #define doutPin 0x20
.................... 
.................... // REGISTER CONGIGURATIONS FOR THIS APP
.................... #define reg0config IPp1n2|g1|PGAenabled // 0x30//
.................... #define reg1config DRn20|MDturbo|CMsingle|TSDisable|BCSoff //0x10
.................... #define reg2config REFinternal|FIRoff|PSWopen|Ioff //0x30
.................... #define reg3config I1disabled|I2disabled|drdyPin //0x00
.................... 
.................... //COMMANDS
.................... #define ADSreset 0x06
.................... #define ADSstart 0x08
.................... #define ADSpowerDn 0x02
.................... #define ADSreadData 0x10
.................... #define ADSreadReg 0x20
.................... #define ADSwriteReg 0x40
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* DESELECT ALL ADCs                                                         */
.................... /*****************************************************************************/
.................... void ads_deselect_all()
.................... {   
....................    output_high(_CS0); // deselect all chip select pins
*
00138:  MOVLW  1F
0013A:  MOVWF  F8A
0013C:  BSF    F85.5
....................    output_high(_CS1);
0013E:  MOVWF  F8A
00140:  BSF    F85.6
....................    output_high(_CS2);
00142:  MOVWF  F8A
00144:  BSF    F85.7
....................    output_high(_CS3); 
00146:  MOVLW  C4
00148:  MOVWF  F88
0014A:  BSF    F83.0
....................    delay_us(10);
0014C:  MOVLW  35
0014E:  MOVWF  00
00150:  DECFSZ 00,F
00152:  BRA    0150
00154:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT DESIRED ADC                                                        */
.................... /*****************************************************************************/
.................... void ads_select_ch(int8 ch)
.................... {
....................    ads_deselect_all();
*
006A0:  RCALL  0138
....................    switch(ch)
006A2:  MOVLB  7
006A4:  MOVF   x1B,W
006A6:  ADDLW  FC
006A8:  BC    06DC
006AA:  ADDLW  04
006AC:  MOVLB  0
006AE:  GOTO   06E8
....................    {
....................       case 0:
....................          output_low(_CS0);
006B2:  MOVLW  1F
006B4:  MOVWF  F8A
006B6:  BCF    F85.5
....................       break; 
006B8:  MOVLB  7
006BA:  BRA    06DC
....................       case 1:
....................          output_low(_CS1);
006BC:  MOVLW  1F
006BE:  MOVWF  F8A
006C0:  BCF    F85.6
....................       break;   
006C2:  MOVLB  7
006C4:  BRA    06DC
....................       case 2:
....................          output_low(_CS2);
006C6:  MOVLW  1F
006C8:  MOVWF  F8A
006CA:  BCF    F85.7
....................       break;
006CC:  MOVLB  7
006CE:  BRA    06DC
....................       case 3:
....................          output_low(_CS3);
006D0:  MOVLW  C4
006D2:  MOVWF  F88
006D4:  BCF    F83.0
....................       break;              
006D6:  MOVLB  7
006D8:  BRA    06DC
006DA:  MOVLB  7
....................    }
....................    delay_us(10);
006DC:  MOVLW  35
006DE:  MOVWF  00
006E0:  DECFSZ 00,F
006E2:  BRA    06E0
006E4:  MOVLB  0
006E6:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT ADC BLOCK (2 ADCs/BLOCK)                                           */
.................... /*****************************************************************************/
.................... void ads_select_block(int8 block)
.................... {
....................    ads_deselect_all();
*
00156:  RCALL  0138
....................    switch(block)
00158:  MOVLB  7
0015A:  MOVF   x72,W
0015C:  XORLW  00
0015E:  MOVLB  0
00160:  BZ    0168
00162:  XORLW  01
00164:  BZ    0174
00166:  BRA    0180
....................    {
....................       case 0:
....................          output_low(_CS0);
00168:  MOVLW  1F
0016A:  MOVWF  F8A
0016C:  BCF    F85.5
....................          output_low(_CS1);
0016E:  MOVWF  F8A
00170:  BCF    F85.6
....................       break; 
00172:  BRA    0180
....................       case 1:         
....................          output_low(_CS2);
00174:  MOVLW  1F
00176:  MOVWF  F8A
00178:  BCF    F85.7
....................          output_low(_CS3);
0017A:  MOVLW  C4
0017C:  MOVWF  F88
0017E:  BCF    F83.0
....................       break;         
....................    }
....................    delay_us(10);
00180:  MOVLW  35
00182:  MOVWF  00
00184:  DECFSZ 00,F
00186:  BRA    0184
00188:  GOTO   0192 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT ALL ADCs                                                           */
.................... /*****************************************************************************/
.................... void ads_select_all()
.................... {
....................    output_low(_CS0);
*
007D2:  MOVLW  1F
007D4:  MOVWF  F8A
007D6:  BCF    F85.5
....................    output_low(_CS1);
007D8:  MOVWF  F8A
007DA:  BCF    F85.6
....................    output_low(_CS2);
007DC:  MOVWF  F8A
007DE:  BCF    F85.7
....................    output_low(_CS3);
007E0:  MOVLW  C4
007E2:  MOVWF  F88
007E4:  BCF    F83.0
....................    delay_us(10);
007E6:  MOVLW  35
007E8:  MOVWF  00
007EA:  DECFSZ 00,F
007EC:  BRA    07EA
007EE:  GOTO   07F4 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO AN ADC                                          */
.................... /*****************************************************************************/
.................... void ads_write_command(int8 ch, unsigned int8 command)
.................... {
....................    ads_select_ch(ch);
*
0070A:  MOVFF  70A,71B
0070E:  RCALL  06A0
....................    spi_write2(command);
00710:  MOVLB  E
00712:  MOVF   x8D,W
00714:  MOVFF  70B,E8D
00718:  RRCF   x90,W
0071A:  BNC   0718
0071C:  MOVLB  0
0071E:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO A BLOCK OF ADCs                                 */
.................... /*****************************************************************************/
.................... void ads_write_command_block(int8 block, unsigned int8 command)
.................... {
....................    ads_select_block(block);
*
0018C:  MOVFF  770,772
00190:  BRA    0156
....................    spi_write2(command);
00192:  MOVLB  E
00194:  MOVF   x8D,W
00196:  MOVFF  771,E8D
0019A:  RRCF   x90,W
0019C:  BNC   019A
0019E:  MOVLB  0
001A0:  GOTO   01B2 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO ALL ADCs                                        */
.................... /*****************************************************************************/
.................... void ads_write_command_all(unsigned int8 command)
.................... {
....................    ads_select_all();
*
007F2:  BRA    07D2
....................    spi_write2(command);
007F4:  MOVLB  E
007F6:  MOVF   x8D,W
007F8:  MOVFF  701,E8D
007FC:  RRCF   x90,W
007FE:  BNC   07FC
00800:  MOVLB  0
00802:  GOTO   0810 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PREPARE TO READ FROM AN ADC                                               */
.................... /*****************************************************************************/
.................... void ads_read_command(int8 ch, unsigned int8 command)
.................... {
....................    ads_select_ch(ch);
*
0081E:  MOVFF  719,71B
00822:  RCALL  06A0
....................    spi_read2(command);
00824:  MOVLB  E
00826:  MOVF   x8D,W
00828:  MOVFF  71A,E8D
0082C:  RRCF   x90,W
0082E:  BNC   082C
00830:  MOVLB  0
00832:  GOTO   0844 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE TO THE CONFIGURATION REGISTERS                                      */
.................... /*****************************************************************************/
.................... void ads_write_reg(int8 ch, adsReg regID, int8 data)
*
00742:  MOVLB  7
00744:  MOVF   x07,W
00746:  IORLW  40
00748:  MOVWF  x09
.................... {
....................    unsigned int8 command = ADSwriteReg | regID | 0; // 0 is numbytes to write-1
....................    ads_write_command(ch, command);
0074A:  MOVFF  706,70A
0074E:  MOVFF  709,70B
00752:  MOVLB  0
00754:  RCALL  070A
....................    spi_write2(data);
00756:  MOVLB  E
00758:  MOVF   x8D,W
0075A:  MOVFF  708,E8D
0075E:  RRCF   x90,W
00760:  BNC   075E
....................    ads_deselect_all();
00762:  MOVLB  0
00764:  RCALL  0138
00766:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* READ FROM THE CONFIGURATION REGISTERS                                     */
.................... /*****************************************************************************/
.................... unsigned int8 ads_read_reg(int8 ch, adsReg regID)
.................... {
....................    unsigned int8 command = ADSreadReg | regID | 0;
....................    ads_read_command(ch, command);
....................    unsigned int8 data = spi_read2(0);
....................    ads_deselect_all();
....................    return data;
.................... }
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* START BLOCK CONVERSION                                                    */
.................... /*****************************************************************************/
.................... void ads_start_conv_block(int8 block)
.................... {
....................    ads_write_command_block(block, ADSstart);
*
001A4:  MOVFF  76F,770
001A8:  MOVLW  08
001AA:  MOVLB  7
001AC:  MOVWF  x71
001AE:  MOVLB  0
001B0:  BRA    018C
....................    delay_us(10);
001B2:  MOVLW  35
001B4:  MOVWF  00
001B6:  DECFSZ 00,F
001B8:  BRA    01B6
....................    ads_deselect_all();
001BA:  RCALL  0138
001BC:  GOTO   0202 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* START ALL CONVERSION                                                      */
.................... /*****************************************************************************/
.................... void ads_start_conv_all()
.................... {
....................    ads_write_command_all(ADSstart);
*
00806:  MOVLW  08
00808:  MOVLB  7
0080A:  MOVWF  x01
0080C:  MOVLB  0
0080E:  BRA    07F2
....................    delay_us(10);
00810:  MOVLW  35
00812:  MOVWF  00
00814:  DECFSZ 00,F
00816:  BRA    0814
....................    ads_deselect_all();
00818:  RCALL  0138
0081A:  GOTO   09A0 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* READ THE MOST RECENT CONVERSION                                           */
.................... /*****************************************************************************/
.................... signed int32 ads_read_data(int8 ch)
.................... {
....................    union Data
....................    {
....................       unsigned int8 dBytes[4];
....................       signed int32 dWord;
....................    }data;
....................    
....................    ads_read_command(ch, ADSreadData);
*
00836:  MOVFF  714,719
0083A:  MOVLW  10
0083C:  MOVLB  7
0083E:  MOVWF  x1A
00840:  MOVLB  0
00842:  BRA    081E
....................    data.dBytes[3] = 0;
00844:  MOVLB  7
00846:  CLRF   x18
....................    data.dBytes[2] = spi_read2(0);
00848:  MOVLB  E
0084A:  MOVF   x8D,W
0084C:  CLRF   x8D
0084E:  RRCF   x90,W
00850:  BNC   084E
00852:  MOVFF  E8D,717
....................    data.dBytes[1] = spi_read2(0);
00856:  MOVF   x8D,W
00858:  CLRF   x8D
0085A:  RRCF   x90,W
0085C:  BNC   085A
0085E:  MOVFF  E8D,716
....................    data.dBytes[0] = spi_read2(0);
00862:  MOVF   x8D,W
00864:  CLRF   x8D
00866:  RRCF   x90,W
00868:  BNC   0866
0086A:  MOVFF  E8D,715
....................    
....................    //convert 24-bit 2's complement to 32-bit 2's complement
....................    if (0x80 & data.dBytes[2]) data.dBytes[3] |= 0xFF;
0086E:  MOVLB  7
00870:  MOVF   x17,W
00872:  ANDLW  80
00874:  BZ    087A
00876:  MOVLW  FF
00878:  IORWF  x18,F
....................    
....................    ads_deselect_all();
0087A:  MOVLB  0
0087C:  RCALL  0138
....................    return data.dWord;
0087E:  MOVFF  715,00
00882:  MOVFF  716,01
00886:  MOVFF  717,02
0088A:  MOVFF  718,03
0088E:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE A CHANNEL                                                      */
.................... /*****************************************************************************/
.................... 
.................... void ADS1220init(int8 ch, rc0=reg0config, rc1=reg1config, rc2=reg2config, rc3=reg3config)
.................... {
....................    ads_write_command(ch, ADSreset);   //reset the device
*
00768:  MOVFF  701,70A
0076C:  MOVLW  06
0076E:  MOVLB  7
00770:  MOVWF  x0B
00772:  MOVLB  0
00774:  RCALL  070A
....................    delay_us(300);                    
00776:  MOVLW  02
00778:  MOVLB  7
0077A:  MOVWF  x06
0077C:  MOVLW  96
0077E:  MOVWF  x07
00780:  MOVLB  0
00782:  RCALL  0720
00784:  MOVLB  7
00786:  DECFSZ x06,F
00788:  BRA    077C
....................    ads_write_reg(ch, reg0, rc0);   //send default configurations
0078A:  MOVFF  701,706
0078E:  CLRF   x07
00790:  MOVFF  702,708
00794:  MOVLB  0
00796:  RCALL  0742
....................    ads_write_reg(ch, reg1, rc1);
00798:  MOVFF  701,706
0079C:  MOVLW  04
0079E:  MOVLB  7
007A0:  MOVWF  x07
007A2:  MOVFF  703,708
007A6:  MOVLB  0
007A8:  RCALL  0742
....................    ads_write_reg(ch, reg2, rc2);
007AA:  MOVFF  701,706
007AE:  MOVLW  08
007B0:  MOVLB  7
007B2:  MOVWF  x07
007B4:  MOVFF  704,708
007B8:  MOVLB  0
007BA:  RCALL  0742
....................    ads_write_reg(ch, reg3, rc3);  
007BC:  MOVFF  701,706
007C0:  MOVLW  0C
007C2:  MOVLB  7
007C4:  MOVWF  x07
007C6:  MOVFF  705,708
007CA:  MOVLB  0
007CC:  RCALL  0742
007CE:  GOTO   097A (RETURN)
.................... }
.................... #endif 
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
*
02E10:  MOVLB  7
02E12:  BCF    x55.0
....................    y = x;
02E14:  MOVFF  749,74E
02E18:  MOVFF  748,74D
02E1C:  MOVFF  747,74C
02E20:  MOVFF  746,74B
.................... 
....................    if (x < 0)
02E24:  MOVFF  749,759
02E28:  MOVFF  748,758
02E2C:  MOVFF  747,757
02E30:  MOVFF  746,756
02E34:  CLRF   x5D
02E36:  CLRF   x5C
02E38:  CLRF   x5B
02E3A:  CLRF   x5A
02E3C:  MOVLB  0
02E3E:  CALL   0D84
02E42:  BNC   2E50
....................    {
....................       s = 1;
02E44:  MOVLB  7
02E46:  BSF    x55.0
....................       y = -y;
02E48:  MOVF   x4C,W
02E4A:  XORLW  80
02E4C:  MOVWF  x4C
02E4E:  MOVLB  0
....................    }
.................... 
....................    if (y <= 32768.0)
02E50:  MOVFF  74E,759
02E54:  MOVFF  74D,758
02E58:  MOVFF  74C,757
02E5C:  MOVFF  74B,756
02E60:  MOVLB  7
02E62:  CLRF   x5D
02E64:  CLRF   x5C
02E66:  CLRF   x5B
02E68:  MOVLW  8E
02E6A:  MOVWF  x5A
02E6C:  MOVLB  0
02E6E:  CALL   0D84
02E72:  BC    2E76
02E74:  BNZ   2EA6
....................       res = (float32)(unsigned int16)y;
02E76:  MOVFF  74E,759
02E7A:  MOVFF  74D,758
02E7E:  MOVFF  74C,757
02E82:  MOVFF  74B,756
02E86:  CALL   122E
02E8A:  MOVFF  02,75B
02E8E:  MOVFF  01,75A
02E92:  RCALL  2DDA
02E94:  MOVFF  03,752
02E98:  MOVFF  02,751
02E9C:  MOVFF  01,750
02EA0:  MOVFF  00,74F
02EA4:  BRA    3046
.................... 
....................  else if (y < 10000000.0)
02EA6:  MOVFF  74E,759
02EAA:  MOVFF  74D,758
02EAE:  MOVFF  74C,757
02EB2:  MOVFF  74B,756
02EB6:  MOVLW  80
02EB8:  MOVLB  7
02EBA:  MOVWF  x5D
02EBC:  MOVLW  96
02EBE:  MOVWF  x5C
02EC0:  MOVLW  18
02EC2:  MOVWF  x5B
02EC4:  MOVLW  96
02EC6:  MOVWF  x5A
02EC8:  MOVLB  0
02ECA:  CALL   0D84
02ECE:  BTFSS  FD8.0
02ED0:  BRA    3036
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
02ED2:  MOVFF  74E,759
02ED6:  MOVFF  74D,758
02EDA:  MOVFF  74C,757
02EDE:  MOVFF  74B,756
02EE2:  MOVLB  7
02EE4:  CLRF   x5D
02EE6:  CLRF   x5C
02EE8:  CLRF   x5B
02EEA:  MOVLW  70
02EEC:  MOVWF  x5A
02EEE:  MOVLB  0
02EF0:  CALL   1138
02EF4:  MOVFF  03,759
02EF8:  MOVFF  02,758
02EFC:  MOVFF  01,757
02F00:  MOVFF  00,756
02F04:  CALL   122E
02F08:  MOVFF  02,754
02F0C:  MOVFF  01,753
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
02F10:  MOVFF  74E,759
02F14:  MOVFF  74D,758
02F18:  MOVFF  74C,757
02F1C:  MOVFF  74B,756
02F20:  MOVLB  7
02F22:  CLRF   x5D
02F24:  CLRF   x5C
02F26:  CLRF   x5B
02F28:  MOVLW  70
02F2A:  MOVWF  x5A
02F2C:  MOVLB  0
02F2E:  CALL   1138
02F32:  MOVFF  03,759
02F36:  MOVFF  02,758
02F3A:  MOVFF  01,757
02F3E:  MOVFF  00,756
02F42:  MOVFF  754,75B
02F46:  MOVFF  753,75A
02F4A:  RCALL  2DDA
02F4C:  BSF    FD8.1
02F4E:  MOVFF  759,75D
02F52:  MOVFF  758,75C
02F56:  MOVFF  757,75B
02F5A:  MOVFF  756,75A
02F5E:  MOVFF  03,761
02F62:  MOVFF  02,760
02F66:  MOVFF  01,75F
02F6A:  MOVFF  00,75E
02F6E:  CALL   0DFE
02F72:  MOVLB  7
02F74:  CLRF   x59
02F76:  CLRF   x58
02F78:  CLRF   x57
02F7A:  MOVLW  8E
02F7C:  MOVWF  x56
02F7E:  MOVFF  03,75D
02F82:  MOVFF  02,75C
02F86:  MOVFF  01,75B
02F8A:  MOVFF  00,75A
02F8E:  MOVLB  0
02F90:  CALL   1138
02F94:  MOVFF  03,74E
02F98:  MOVFF  02,74D
02F9C:  MOVFF  01,74C
02FA0:  MOVFF  00,74B
....................       res = 32768.0*(float32)l;
02FA4:  MOVFF  754,75B
02FA8:  MOVFF  753,75A
02FAC:  RCALL  2DDA
02FAE:  MOVLB  7
02FB0:  CLRF   x59
02FB2:  CLRF   x58
02FB4:  CLRF   x57
02FB6:  MOVLW  8E
02FB8:  MOVWF  x56
02FBA:  MOVFF  03,75D
02FBE:  MOVFF  02,75C
02FC2:  MOVFF  01,75B
02FC6:  MOVFF  00,75A
02FCA:  MOVLB  0
02FCC:  CALL   1138
02FD0:  MOVFF  03,752
02FD4:  MOVFF  02,751
02FD8:  MOVFF  01,750
02FDC:  MOVFF  00,74F
....................       res += (float32)(unsigned int16)y;
02FE0:  MOVFF  74E,759
02FE4:  MOVFF  74D,758
02FE8:  MOVFF  74C,757
02FEC:  MOVFF  74B,756
02FF0:  CALL   122E
02FF4:  MOVFF  02,75B
02FF8:  MOVFF  01,75A
02FFC:  RCALL  2DDA
02FFE:  BCF    FD8.1
03000:  MOVFF  752,75D
03004:  MOVFF  751,75C
03008:  MOVFF  750,75B
0300C:  MOVFF  74F,75A
03010:  MOVFF  03,761
03014:  MOVFF  02,760
03018:  MOVFF  01,75F
0301C:  MOVFF  00,75E
03020:  CALL   0DFE
03024:  MOVFF  03,752
03028:  MOVFF  02,751
0302C:  MOVFF  01,750
03030:  MOVFF  00,74F
....................    }
03034:  BRA    3046
.................... 
....................  else
....................   res = y;
03036:  MOVFF  74E,752
0303A:  MOVFF  74D,751
0303E:  MOVFF  74C,750
03042:  MOVFF  74B,74F
.................... 
....................  y = y - (float32)(unsigned int16)y;
03046:  MOVFF  74E,759
0304A:  MOVFF  74D,758
0304E:  MOVFF  74C,757
03052:  MOVFF  74B,756
03056:  CALL   122E
0305A:  MOVFF  02,75B
0305E:  MOVFF  01,75A
03062:  RCALL  2DDA
03064:  BSF    FD8.1
03066:  MOVFF  74E,75D
0306A:  MOVFF  74D,75C
0306E:  MOVFF  74C,75B
03072:  MOVFF  74B,75A
03076:  MOVFF  03,761
0307A:  MOVFF  02,760
0307E:  MOVFF  01,75F
03082:  MOVFF  00,75E
03086:  CALL   0DFE
0308A:  MOVFF  03,74E
0308E:  MOVFF  02,74D
03092:  MOVFF  01,74C
03096:  MOVFF  00,74B
.................... 
....................  if (s)
0309A:  MOVLB  7
0309C:  BTFSS  x55.0
0309E:  BRA    30A6
....................   res = -res;
030A0:  MOVF   x50,W
030A2:  XORLW  80
030A4:  MOVWF  x50
.................... 
....................  if (y != 0)
030A6:  MOVFF  74E,759
030AA:  MOVFF  74D,758
030AE:  MOVFF  74C,757
030B2:  MOVFF  74B,756
030B6:  CLRF   x5D
030B8:  CLRF   x5C
030BA:  CLRF   x5B
030BC:  CLRF   x5A
030BE:  MOVLB  0
030C0:  CALL   0D84
030C4:  BZ    313E
....................  {
....................   if (s == 1 && n == 0)
030C6:  MOVLB  7
030C8:  BTFSS  x55.0
030CA:  BRA    3104
030CC:  MOVF   x4A,F
030CE:  BNZ   3104
....................    res -= 1.0;
030D0:  BSF    FD8.1
030D2:  MOVFF  752,75D
030D6:  MOVFF  751,75C
030DA:  MOVFF  750,75B
030DE:  MOVFF  74F,75A
030E2:  CLRF   x61
030E4:  CLRF   x60
030E6:  CLRF   x5F
030E8:  MOVLW  7F
030EA:  MOVWF  x5E
030EC:  MOVLB  0
030EE:  CALL   0DFE
030F2:  MOVFF  03,752
030F6:  MOVFF  02,751
030FA:  MOVFF  01,750
030FE:  MOVFF  00,74F
03102:  MOVLB  7
.................... 
....................   if (s == 0 && n == 1)
03104:  BTFSC  x55.0
03106:  BRA    3140
03108:  DECFSZ x4A,W
0310A:  BRA    3140
....................    res += 1.0;
0310C:  BCF    FD8.1
0310E:  MOVFF  752,75D
03112:  MOVFF  751,75C
03116:  MOVFF  750,75B
0311A:  MOVFF  74F,75A
0311E:  CLRF   x61
03120:  CLRF   x60
03122:  CLRF   x5F
03124:  MOVLW  7F
03126:  MOVWF  x5E
03128:  MOVLB  0
0312A:  CALL   0DFE
0312E:  MOVFF  03,752
03132:  MOVFF  02,751
03136:  MOVFF  01,750
0313A:  MOVFF  00,74F
0313E:  MOVLB  7
....................  }
....................  if (x == 0)
03140:  MOVFF  749,759
03144:  MOVFF  748,758
03148:  MOVFF  747,757
0314C:  MOVFF  746,756
03150:  CLRF   x5D
03152:  CLRF   x5C
03154:  CLRF   x5B
03156:  CLRF   x5A
03158:  MOVLB  0
0315A:  CALL   0D84
0315E:  BNZ   316C
....................     res = 0;
03160:  MOVLB  7
03162:  CLRF   x52
03164:  CLRF   x51
03166:  CLRF   x50
03168:  CLRF   x4F
0316A:  MOVLB  0
.................... 
....................  return (res);
0316C:  MOVFF  74F,00
03170:  MOVFF  750,01
03174:  MOVFF  751,02
03178:  MOVFF  752,03
0317C:  RETURN 0
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
*
0319C:  MOVFF  745,749
031A0:  MOVFF  744,748
031A4:  MOVFF  743,747
031A8:  MOVFF  742,746
031AC:  MOVLB  7
031AE:  CLRF   x4A
031B0:  MOVLB  0
031B2:  RCALL  2E10
031B4:  GOTO   32C0 (RETURN)
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
*
0317E:  MOVFF  745,749
03182:  MOVFF  744,748
03186:  MOVFF  743,747
0318A:  MOVFF  742,746
0318E:  MOVLW  01
03190:  MOVLB  7
03192:  MOVWF  x4A
03194:  MOVLB  0
03196:  RCALL  2E10
03198:  GOTO   3278 (RETURN)
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
*
031B8:  MOVFF  739,759
031BC:  MOVFF  738,758
031C0:  MOVFF  737,757
031C4:  MOVFF  736,756
031C8:  MOVLB  7
031CA:  CLRF   x5D
031CC:  CLRF   x5C
031CE:  CLRF   x5B
031D0:  CLRF   x5A
031D2:  MOVLB  0
031D4:  CALL   0D84
031D8:  BTFSC  FD8.2
031DA:  BRA    331C
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
031DC:  MOVFF  735,752
031E0:  MOVFF  734,751
031E4:  MOVFF  733,750
031E8:  MOVFF  732,74F
031EC:  MOVFF  739,756
031F0:  MOVFF  738,755
031F4:  MOVFF  737,754
031F8:  MOVFF  736,753
031FC:  CALL   2450
03200:  MOVFF  03,741
03204:  MOVFF  02,740
03208:  MOVFF  01,73F
0320C:  MOVFF  00,73E
03210:  MOVFF  03,759
03214:  MOVFF  02,758
03218:  MOVFF  01,757
0321C:  MOVFF  00,756
03220:  MOVLB  7
03222:  CLRF   x5D
03224:  CLRF   x5C
03226:  CLRF   x5B
03228:  CLRF   x5A
0322A:  MOVLB  0
0322C:  CALL   0D84
03230:  BNC   327A
03232:  MOVFF  735,752
03236:  MOVFF  734,751
0323A:  MOVFF  733,750
0323E:  MOVFF  732,74F
03242:  MOVFF  739,756
03246:  MOVFF  738,755
0324A:  MOVFF  737,754
0324E:  MOVFF  736,753
03252:  CALL   2450
03256:  MOVFF  03,741
0325A:  MOVFF  02,740
0325E:  MOVFF  01,73F
03262:  MOVFF  00,73E
03266:  MOVFF  03,745
0326A:  MOVFF  02,744
0326E:  MOVFF  01,743
03272:  MOVFF  00,742
03276:  BRA    317E
03278:  BRA    32C0
0327A:  MOVFF  735,752
0327E:  MOVFF  734,751
03282:  MOVFF  733,750
03286:  MOVFF  732,74F
0328A:  MOVFF  739,756
0328E:  MOVFF  738,755
03292:  MOVFF  737,754
03296:  MOVFF  736,753
0329A:  CALL   2450
0329E:  MOVFF  03,741
032A2:  MOVFF  02,740
032A6:  MOVFF  01,73F
032AA:  MOVFF  00,73E
032AE:  MOVFF  03,745
032B2:  MOVFF  02,744
032B6:  MOVFF  01,743
032BA:  MOVFF  00,742
032BE:  BRA    319C
032C0:  MOVFF  03,73D
032C4:  MOVFF  02,73C
032C8:  MOVFF  01,73B
032CC:  MOVFF  00,73A
....................       return(x-(i*y));
032D0:  MOVFF  73D,759
032D4:  MOVFF  73C,758
032D8:  MOVFF  73B,757
032DC:  MOVFF  73A,756
032E0:  MOVFF  739,75D
032E4:  MOVFF  738,75C
032E8:  MOVFF  737,75B
032EC:  MOVFF  736,75A
032F0:  CALL   1138
032F4:  BSF    FD8.1
032F6:  MOVFF  735,75D
032FA:  MOVFF  734,75C
032FE:  MOVFF  733,75B
03302:  MOVFF  732,75A
03306:  MOVFF  03,761
0330A:  MOVFF  02,760
0330E:  MOVFF  01,75F
03312:  MOVFF  00,75E
03316:  CALL   0DFE
0331A:  BRA    331C
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
0331C:  RETURN 0
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
*
036B2:  MOVFF  739,759
036B6:  MOVFF  738,758
036BA:  MOVFF  737,757
036BE:  MOVFF  736,756
036C2:  MOVLW  3B
036C4:  MOVLB  7
036C6:  MOVWF  x5D
036C8:  MOVLW  AA
036CA:  MOVWF  x5C
036CC:  MOVLW  38
036CE:  MOVWF  x5B
036D0:  MOVLW  7F
036D2:  MOVWF  x5A
036D4:  MOVLB  0
036D6:  CALL   1138
036DA:  MOVFF  03,759
036DE:  MOVFF  02,758
036E2:  MOVFF  01,757
036E6:  MOVFF  00,756
036EA:  CALL   122E
036EE:  MOVFF  01,746
....................    s = 0;
036F2:  MOVLB  7
036F4:  BCF    x47.0
....................    y = x;
036F6:  MOVFF  739,73D
036FA:  MOVFF  738,73C
036FE:  MOVFF  737,73B
03702:  MOVFF  736,73A
.................... 
....................    if (x < 0)
03706:  MOVFF  739,759
0370A:  MOVFF  738,758
0370E:  MOVFF  737,757
03712:  MOVFF  736,756
03716:  CLRF   x5D
03718:  CLRF   x5C
0371A:  CLRF   x5B
0371C:  CLRF   x5A
0371E:  MOVLB  0
03720:  CALL   0D84
03724:  BNC   3734
....................    {
....................       s = 1;
03726:  MOVLB  7
03728:  BSF    x47.0
....................       n = -n;
0372A:  NEGF   x46
....................       y = -y;
0372C:  MOVF   x3B,W
0372E:  XORLW  80
03730:  MOVWF  x3B
03732:  MOVLB  0
....................    }
.................... 
....................    res = 0.0;
03734:  MOVLB  7
03736:  CLRF   x41
03738:  CLRF   x40
0373A:  CLRF   x3F
0373C:  CLRF   x3E
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
0373E:  MOVLW  07
03740:  MOVWF  x49
03742:  MOVLW  3E
03744:  MOVFF  749,FEA
03748:  MOVWF  FE9
0374A:  MOVLW  7F
0374C:  ADDWF  x46,W
0374E:  MOVWF  FEF
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
03750:  MOVFF  73D,759
03754:  MOVFF  73C,758
03758:  MOVFF  73B,757
0375C:  MOVFF  73A,756
03760:  MOVLW  3B
03762:  MOVWF  x5D
03764:  MOVLW  AA
03766:  MOVWF  x5C
03768:  MOVLW  38
0376A:  MOVWF  x5B
0376C:  MOVLW  7F
0376E:  MOVWF  x5A
03770:  MOVLB  0
03772:  CALL   1138
03776:  MOVFF  03,74B
0377A:  MOVFF  02,74A
0377E:  MOVFF  01,749
03782:  MOVFF  00,748
03786:  MOVLB  7
03788:  CLRF   x4D
0378A:  MOVFF  746,74C
0378E:  BTFSC  x4C.7
03790:  DECF   x4D,F
03792:  MOVLB  0
03794:  CALL   2D8A
03798:  BSF    FD8.1
0379A:  MOVFF  74B,75D
0379E:  MOVFF  74A,75C
037A2:  MOVFF  749,75B
037A6:  MOVFF  748,75A
037AA:  MOVFF  03,761
037AE:  MOVFF  02,760
037B2:  MOVFF  01,75F
037B6:  MOVFF  00,75E
037BA:  CALL   0DFE
037BE:  MOVFF  03,73D
037C2:  MOVFF  02,73C
037C6:  MOVFF  01,73B
037CA:  MOVFF  00,73A
.................... 
....................    r = pe[0]*y + pe[1];
037CE:  MOVLW  7C
037D0:  MOVLB  7
037D2:  MOVWF  x59
037D4:  MOVLW  88
037D6:  MOVWF  x58
037D8:  MOVLW  59
037DA:  MOVWF  x57
037DC:  MOVLW  72
037DE:  MOVWF  x56
037E0:  MOVFF  73D,75D
037E4:  MOVFF  73C,75C
037E8:  MOVFF  73B,75B
037EC:  MOVFF  73A,75A
037F0:  MOVLB  0
037F2:  CALL   1138
037F6:  MOVFF  03,74B
037FA:  MOVFF  02,74A
037FE:  MOVFF  01,749
03802:  MOVFF  00,748
03806:  BCF    FD8.1
03808:  MOVFF  03,75D
0380C:  MOVFF  02,75C
03810:  MOVFF  01,75B
03814:  MOVFF  00,75A
03818:  MOVLW  E0
0381A:  MOVLB  7
0381C:  MOVWF  x61
0381E:  MOVLW  97
03820:  MOVWF  x60
03822:  MOVLW  26
03824:  MOVWF  x5F
03826:  MOVLW  75
03828:  MOVWF  x5E
0382A:  MOVLB  0
0382C:  CALL   0DFE
03830:  MOVFF  03,745
03834:  MOVFF  02,744
03838:  MOVFF  01,743
0383C:  MOVFF  00,742
....................    r = r*y + pe[2];
03840:  MOVFF  745,759
03844:  MOVFF  744,758
03848:  MOVFF  743,757
0384C:  MOVFF  742,756
03850:  MOVFF  73D,75D
03854:  MOVFF  73C,75C
03858:  MOVFF  73B,75B
0385C:  MOVFF  73A,75A
03860:  CALL   1138
03864:  MOVFF  03,74B
03868:  MOVFF  02,74A
0386C:  MOVFF  01,749
03870:  MOVFF  00,748
03874:  BCF    FD8.1
03876:  MOVFF  03,75D
0387A:  MOVFF  02,75C
0387E:  MOVFF  01,75B
03882:  MOVFF  00,75A
03886:  MOVLW  C4
03888:  MOVLB  7
0388A:  MOVWF  x61
0388C:  MOVLW  1D
0388E:  MOVWF  x60
03890:  MOVLW  1E
03892:  MOVWF  x5F
03894:  MOVLW  78
03896:  MOVWF  x5E
03898:  MOVLB  0
0389A:  CALL   0DFE
0389E:  MOVFF  03,745
038A2:  MOVFF  02,744
038A6:  MOVFF  01,743
038AA:  MOVFF  00,742
....................    r = r*y + pe[3];
038AE:  MOVFF  745,759
038B2:  MOVFF  744,758
038B6:  MOVFF  743,757
038BA:  MOVFF  742,756
038BE:  MOVFF  73D,75D
038C2:  MOVFF  73C,75C
038C6:  MOVFF  73B,75B
038CA:  MOVFF  73A,75A
038CE:  CALL   1138
038D2:  MOVFF  03,74B
038D6:  MOVFF  02,74A
038DA:  MOVFF  01,749
038DE:  MOVFF  00,748
038E2:  BCF    FD8.1
038E4:  MOVFF  03,75D
038E8:  MOVFF  02,75C
038EC:  MOVFF  01,75B
038F0:  MOVFF  00,75A
038F4:  MOVLW  5E
038F6:  MOVLB  7
038F8:  MOVWF  x61
038FA:  MOVLW  50
038FC:  MOVWF  x60
038FE:  MOVLW  63
03900:  MOVWF  x5F
03902:  MOVLW  7A
03904:  MOVWF  x5E
03906:  MOVLB  0
03908:  CALL   0DFE
0390C:  MOVFF  03,745
03910:  MOVFF  02,744
03914:  MOVFF  01,743
03918:  MOVFF  00,742
....................    r = r*y + pe[4];
0391C:  MOVFF  745,759
03920:  MOVFF  744,758
03924:  MOVFF  743,757
03928:  MOVFF  742,756
0392C:  MOVFF  73D,75D
03930:  MOVFF  73C,75C
03934:  MOVFF  73B,75B
03938:  MOVFF  73A,75A
0393C:  CALL   1138
03940:  MOVFF  03,74B
03944:  MOVFF  02,74A
03948:  MOVFF  01,749
0394C:  MOVFF  00,748
03950:  BCF    FD8.1
03952:  MOVFF  03,75D
03956:  MOVFF  02,75C
0395A:  MOVFF  01,75B
0395E:  MOVFF  00,75A
03962:  MOVLW  1A
03964:  MOVLB  7
03966:  MOVWF  x61
03968:  MOVLW  FE
0396A:  MOVWF  x60
0396C:  MOVLW  75
0396E:  MOVWF  x5F
03970:  MOVLW  7C
03972:  MOVWF  x5E
03974:  MOVLB  0
03976:  CALL   0DFE
0397A:  MOVFF  03,745
0397E:  MOVFF  02,744
03982:  MOVFF  01,743
03986:  MOVFF  00,742
....................    r = r*y + pe[5];
0398A:  MOVFF  745,759
0398E:  MOVFF  744,758
03992:  MOVFF  743,757
03996:  MOVFF  742,756
0399A:  MOVFF  73D,75D
0399E:  MOVFF  73C,75C
039A2:  MOVFF  73B,75B
039A6:  MOVFF  73A,75A
039AA:  CALL   1138
039AE:  MOVFF  03,74B
039B2:  MOVFF  02,74A
039B6:  MOVFF  01,749
039BA:  MOVFF  00,748
039BE:  BCF    FD8.1
039C0:  MOVFF  03,75D
039C4:  MOVFF  02,75C
039C8:  MOVFF  01,75B
039CC:  MOVFF  00,75A
039D0:  MOVLW  18
039D2:  MOVLB  7
039D4:  MOVWF  x61
039D6:  MOVLW  72
039D8:  MOVWF  x60
039DA:  MOVLW  31
039DC:  MOVWF  x5F
039DE:  MOVLW  7E
039E0:  MOVWF  x5E
039E2:  MOVLB  0
039E4:  CALL   0DFE
039E8:  MOVFF  03,745
039EC:  MOVFF  02,744
039F0:  MOVFF  01,743
039F4:  MOVFF  00,742
.................... 
....................    res = res*(1.0 + y*r);
039F8:  MOVFF  73D,759
039FC:  MOVFF  73C,758
03A00:  MOVFF  73B,757
03A04:  MOVFF  73A,756
03A08:  MOVFF  745,75D
03A0C:  MOVFF  744,75C
03A10:  MOVFF  743,75B
03A14:  MOVFF  742,75A
03A18:  CALL   1138
03A1C:  BCF    FD8.1
03A1E:  MOVLB  7
03A20:  CLRF   x5D
03A22:  CLRF   x5C
03A24:  CLRF   x5B
03A26:  MOVLW  7F
03A28:  MOVWF  x5A
03A2A:  MOVFF  03,761
03A2E:  MOVFF  02,760
03A32:  MOVFF  01,75F
03A36:  MOVFF  00,75E
03A3A:  MOVLB  0
03A3C:  CALL   0DFE
03A40:  MOVFF  741,759
03A44:  MOVFF  740,758
03A48:  MOVFF  73F,757
03A4C:  MOVFF  73E,756
03A50:  MOVFF  03,75D
03A54:  MOVFF  02,75C
03A58:  MOVFF  01,75B
03A5C:  MOVFF  00,75A
03A60:  CALL   1138
03A64:  MOVFF  03,741
03A68:  MOVFF  02,740
03A6C:  MOVFF  01,73F
03A70:  MOVFF  00,73E
.................... 
....................    if (s)
03A74:  MOVLB  7
03A76:  BTFSS  x47.0
03A78:  BRA    3AAC
....................       res = 1.0/res;
03A7A:  CLRF   x52
03A7C:  CLRF   x51
03A7E:  CLRF   x50
03A80:  MOVLW  7F
03A82:  MOVWF  x4F
03A84:  MOVFF  741,756
03A88:  MOVFF  740,755
03A8C:  MOVFF  73F,754
03A90:  MOVFF  73E,753
03A94:  MOVLB  0
03A96:  CALL   2450
03A9A:  MOVFF  03,741
03A9E:  MOVFF  02,740
03AA2:  MOVFF  01,73F
03AA6:  MOVFF  00,73E
03AAA:  MOVLB  7
....................    return(res);
03AAC:  MOVFF  73E,00
03AB0:  MOVFF  73F,01
03AB4:  MOVFF  740,02
03AB8:  MOVFF  741,03
03ABC:  MOVLB  0
03ABE:  RETURN 0
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
*
0331E:  MOVFF  739,73D
03322:  MOVFF  738,73C
03326:  MOVFF  737,73B
0332A:  MOVFF  736,73A
.................... 
....................    if (y != 1.0)
0332E:  MOVFF  73D,759
03332:  MOVFF  73C,758
03336:  MOVFF  73B,757
0333A:  MOVFF  73A,756
0333E:  MOVLB  7
03340:  CLRF   x5D
03342:  CLRF   x5C
03344:  CLRF   x5B
03346:  MOVLW  7F
03348:  MOVWF  x5A
0334A:  MOVLB  0
0334C:  CALL   0D84
03350:  BTFSC  FD8.2
03352:  BRA    3694
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
03354:  MOVLW  07
03356:  MOVLB  7
03358:  MOVWF  x4C
0335A:  MOVLW  3A
0335C:  MOVFF  74C,FEA
03360:  MOVWF  FE9
03362:  MOVLW  7E
03364:  MOVWF  FEF
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
03366:  BSF    FD8.1
03368:  MOVFF  73D,75D
0336C:  MOVFF  73C,75C
03370:  MOVFF  73B,75B
03374:  MOVFF  73A,75A
03378:  CLRF   x61
0337A:  CLRF   x60
0337C:  CLRF   x5F
0337E:  MOVLW  7F
03380:  MOVWF  x5E
03382:  MOVLB  0
03384:  CALL   0DFE
03388:  MOVFF  03,74E
0338C:  MOVFF  02,74D
03390:  MOVFF  01,74C
03394:  MOVFF  00,74B
03398:  BCF    FD8.1
0339A:  MOVFF  73D,75D
0339E:  MOVFF  73C,75C
033A2:  MOVFF  73B,75B
033A6:  MOVFF  73A,75A
033AA:  MOVLB  7
033AC:  CLRF   x61
033AE:  CLRF   x60
033B0:  CLRF   x5F
033B2:  MOVLW  7F
033B4:  MOVWF  x5E
033B6:  MOVLB  0
033B8:  CALL   0DFE
033BC:  MOVFF  74E,752
033C0:  MOVFF  74D,751
033C4:  MOVFF  74C,750
033C8:  MOVFF  74B,74F
033CC:  MOVFF  03,756
033D0:  MOVFF  02,755
033D4:  MOVFF  01,754
033D8:  MOVFF  00,753
033DC:  CALL   2450
033E0:  MOVFF  03,73D
033E4:  MOVFF  02,73C
033E8:  MOVFF  01,73B
033EC:  MOVFF  00,73A
.................... 
....................       y2=y*y;
033F0:  MOVFF  73D,759
033F4:  MOVFF  73C,758
033F8:  MOVFF  73B,757
033FC:  MOVFF  73A,756
03400:  MOVFF  73D,75D
03404:  MOVFF  73C,75C
03408:  MOVFF  73B,75B
0340C:  MOVFF  73A,75A
03410:  CALL   1138
03414:  MOVFF  03,749
03418:  MOVFF  02,748
0341C:  MOVFF  01,747
03420:  MOVFF  00,746
.................... 
....................       res = pl[0]*y2 + pl[1];
03424:  MOVLW  99
03426:  MOVLB  7
03428:  MOVWF  x59
0342A:  MOVLW  47
0342C:  MOVWF  x58
0342E:  MOVLW  8A
03430:  MOVWF  x57
03432:  MOVLW  7F
03434:  MOVWF  x56
03436:  MOVFF  749,75D
0343A:  MOVFF  748,75C
0343E:  MOVFF  747,75B
03442:  MOVFF  746,75A
03446:  MOVLB  0
03448:  CALL   1138
0344C:  MOVFF  03,74E
03450:  MOVFF  02,74D
03454:  MOVFF  01,74C
03458:  MOVFF  00,74B
0345C:  BCF    FD8.1
0345E:  MOVFF  03,75D
03462:  MOVFF  02,75C
03466:  MOVFF  01,75B
0346A:  MOVFF  00,75A
0346E:  MOVLB  7
03470:  CLRF   x61
03472:  CLRF   x60
03474:  CLRF   x5F
03476:  MOVLW  80
03478:  MOVWF  x5E
0347A:  MOVLB  0
0347C:  CALL   0DFE
03480:  MOVFF  03,741
03484:  MOVFF  02,740
03488:  MOVFF  01,73F
0348C:  MOVFF  00,73E
.................... 
....................       r = ql[0]*y2 + ql[1];
03490:  MOVLW  4C
03492:  MOVLB  7
03494:  MOVWF  x59
03496:  MOVLW  F3
03498:  MOVWF  x58
0349A:  MOVLW  3A
0349C:  MOVWF  x57
0349E:  MOVLW  7B
034A0:  MOVWF  x56
034A2:  MOVFF  749,75D
034A6:  MOVFF  748,75C
034AA:  MOVFF  747,75B
034AE:  MOVFF  746,75A
034B2:  MOVLB  0
034B4:  CALL   1138
034B8:  MOVFF  03,74E
034BC:  MOVFF  02,74D
034C0:  MOVFF  01,74C
034C4:  MOVFF  00,74B
034C8:  BCF    FD8.1
034CA:  MOVFF  03,75D
034CE:  MOVFF  02,75C
034D2:  MOVFF  01,75B
034D6:  MOVFF  00,75A
034DA:  MOVLW  2B
034DC:  MOVLB  7
034DE:  MOVWF  x61
034E0:  MOVLW  9D
034E2:  MOVWF  x60
034E4:  MOVLW  DF
034E6:  MOVWF  x5F
034E8:  MOVLW  7E
034EA:  MOVWF  x5E
034EC:  MOVLB  0
034EE:  CALL   0DFE
034F2:  MOVFF  03,745
034F6:  MOVFF  02,744
034FA:  MOVFF  01,743
034FE:  MOVFF  00,742
....................       r = r*y2 + 1.0;
03502:  MOVFF  745,759
03506:  MOVFF  744,758
0350A:  MOVFF  743,757
0350E:  MOVFF  742,756
03512:  MOVFF  749,75D
03516:  MOVFF  748,75C
0351A:  MOVFF  747,75B
0351E:  MOVFF  746,75A
03522:  CALL   1138
03526:  MOVFF  03,74E
0352A:  MOVFF  02,74D
0352E:  MOVFF  01,74C
03532:  MOVFF  00,74B
03536:  BCF    FD8.1
03538:  MOVFF  03,75D
0353C:  MOVFF  02,75C
03540:  MOVFF  01,75B
03544:  MOVFF  00,75A
03548:  MOVLB  7
0354A:  CLRF   x61
0354C:  CLRF   x60
0354E:  CLRF   x5F
03550:  MOVLW  7F
03552:  MOVWF  x5E
03554:  MOVLB  0
03556:  CALL   0DFE
0355A:  MOVFF  03,745
0355E:  MOVFF  02,744
03562:  MOVFF  01,743
03566:  MOVFF  00,742
.................... 
....................       res = y*res/r;
0356A:  MOVFF  73D,759
0356E:  MOVFF  73C,758
03572:  MOVFF  73B,757
03576:  MOVFF  73A,756
0357A:  MOVFF  741,75D
0357E:  MOVFF  740,75C
03582:  MOVFF  73F,75B
03586:  MOVFF  73E,75A
0358A:  CALL   1138
0358E:  MOVFF  03,74E
03592:  MOVFF  02,74D
03596:  MOVFF  01,74C
0359A:  MOVFF  00,74B
0359E:  MOVFF  03,752
035A2:  MOVFF  02,751
035A6:  MOVFF  01,750
035AA:  MOVFF  00,74F
035AE:  MOVFF  745,756
035B2:  MOVFF  744,755
035B6:  MOVFF  743,754
035BA:  MOVFF  742,753
035BE:  CALL   2450
035C2:  MOVFF  03,741
035C6:  MOVFF  02,740
035CA:  MOVFF  01,73F
035CE:  MOVFF  00,73E
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
035D2:  MOVLW  07
035D4:  MOVLB  7
035D6:  MOVWF  x4C
035D8:  MOVLW  36
035DA:  MOVFF  74C,FEA
035DE:  MOVWF  FE9
035E0:  MOVLW  7E
035E2:  SUBWF  FEF,W
035E4:  MOVWF  x4A
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
035E6:  BTFSS  x4A.7
035E8:  BRA    3614
....................          r = -(float32)-n;
035EA:  MOVLW  00
035EC:  BSF    FD8.0
035EE:  SUBFWB x4A,W
035F0:  CLRF   x4D
035F2:  MOVWF  x4C
035F4:  BTFSC  x4C.7
035F6:  DECF   x4D,F
035F8:  MOVLB  0
035FA:  CALL   2D8A
035FE:  MOVFF  00,742
03602:  MOVF   01,W
03604:  XORLW  80
03606:  MOVLB  7
03608:  MOVWF  x43
0360A:  MOVFF  02,744
0360E:  MOVFF  03,745
03612:  BRA    3636
....................       else
....................          r = (float32)n;
03614:  CLRF   x4D
03616:  MOVFF  74A,74C
0361A:  BTFSC  x4C.7
0361C:  DECF   x4D,F
0361E:  MOVLB  0
03620:  CALL   2D8A
03624:  MOVFF  03,745
03628:  MOVFF  02,744
0362C:  MOVFF  01,743
03630:  MOVFF  00,742
03634:  MOVLB  7
.................... 
....................       res += r*LN2;
03636:  MOVFF  745,759
0363A:  MOVFF  744,758
0363E:  MOVFF  743,757
03642:  MOVFF  742,756
03646:  MOVLW  18
03648:  MOVWF  x5D
0364A:  MOVLW  72
0364C:  MOVWF  x5C
0364E:  MOVLW  31
03650:  MOVWF  x5B
03652:  MOVLW  7E
03654:  MOVWF  x5A
03656:  MOVLB  0
03658:  CALL   1138
0365C:  BCF    FD8.1
0365E:  MOVFF  741,75D
03662:  MOVFF  740,75C
03666:  MOVFF  73F,75B
0366A:  MOVFF  73E,75A
0366E:  MOVFF  03,761
03672:  MOVFF  02,760
03676:  MOVFF  01,75F
0367A:  MOVFF  00,75E
0367E:  CALL   0DFE
03682:  MOVFF  03,741
03686:  MOVFF  02,740
0368A:  MOVFF  01,73F
0368E:  MOVFF  00,73E
....................    }
03692:  BRA    36A0
.................... 
....................    else
....................       res = 0.0;
03694:  MOVLB  7
03696:  CLRF   x41
03698:  CLRF   x40
0369A:  CLRF   x3F
0369C:  CLRF   x3E
0369E:  MOVLB  0
.................... 
....................    return(res);
036A0:  MOVFF  73E,00
036A4:  MOVFF  73F,01
036A8:  MOVFF  740,02
036AC:  MOVFF  741,03
036B0:  RETURN 0
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
*
03AC0:  MOVFF  72D,759
03AC4:  MOVFF  72C,758
03AC8:  MOVFF  72B,757
03ACC:  MOVFF  72A,756
03AD0:  MOVLB  7
03AD2:  CLRF   x5D
03AD4:  CLRF   x5C
03AD6:  CLRF   x5B
03AD8:  CLRF   x5A
03ADA:  MOVLB  0
03ADC:  CALL   0D84
03AE0:  BTFSS  FD8.0
03AE2:  BRA    3C7E
03AE4:  MOVFF  731,735
03AE8:  MOVFF  730,734
03AEC:  MOVFF  72F,733
03AF0:  MOVFF  72E,732
03AF4:  MOVLB  7
03AF6:  CLRF   x39
03AF8:  CLRF   x38
03AFA:  CLRF   x37
03AFC:  MOVLW  7F
03AFE:  MOVWF  x36
03B00:  MOVLB  0
03B02:  CALL   31B8
03B06:  MOVFF  03,735
03B0A:  MOVFF  02,734
03B0E:  MOVFF  01,733
03B12:  MOVFF  00,732
03B16:  MOVFF  03,759
03B1A:  MOVFF  02,758
03B1E:  MOVFF  01,757
03B22:  MOVFF  00,756
03B26:  MOVLB  7
03B28:  CLRF   x5D
03B2A:  CLRF   x5C
03B2C:  CLRF   x5B
03B2E:  CLRF   x5A
03B30:  MOVLB  0
03B32:  CALL   0D84
03B36:  BTFSS  FD8.2
03B38:  BRA    3C7E
....................       if(fmod(y, 2) == 0) {
03B3A:  MOVFF  731,735
03B3E:  MOVFF  730,734
03B42:  MOVFF  72F,733
03B46:  MOVFF  72E,732
03B4A:  MOVLB  7
03B4C:  CLRF   x39
03B4E:  CLRF   x38
03B50:  CLRF   x37
03B52:  MOVLW  80
03B54:  MOVWF  x36
03B56:  MOVLB  0
03B58:  CALL   31B8
03B5C:  MOVFF  03,735
03B60:  MOVFF  02,734
03B64:  MOVFF  01,733
03B68:  MOVFF  00,732
03B6C:  MOVFF  03,759
03B70:  MOVFF  02,758
03B74:  MOVFF  01,757
03B78:  MOVFF  00,756
03B7C:  MOVLB  7
03B7E:  CLRF   x5D
03B80:  CLRF   x5C
03B82:  CLRF   x5B
03B84:  CLRF   x5A
03B86:  MOVLB  0
03B88:  CALL   0D84
03B8C:  BNZ   3C04
....................          return (exp(log(-x) * y));
03B8E:  MOVLB  7
03B90:  MOVF   x2B,W
03B92:  XORLW  80
03B94:  MOVWF  x33
03B96:  MOVFF  72D,739
03B9A:  MOVFF  72C,738
03B9E:  MOVWF  x37
03BA0:  MOVFF  72A,736
03BA4:  MOVLB  0
03BA6:  CALL   331E
03BAA:  MOVFF  03,735
03BAE:  MOVFF  02,734
03BB2:  MOVFF  01,733
03BB6:  MOVFF  00,732
03BBA:  MOVFF  03,759
03BBE:  MOVFF  02,758
03BC2:  MOVFF  01,757
03BC6:  MOVFF  00,756
03BCA:  MOVFF  731,75D
03BCE:  MOVFF  730,75C
03BD2:  MOVFF  72F,75B
03BD6:  MOVFF  72E,75A
03BDA:  CALL   1138
03BDE:  MOVFF  03,735
03BE2:  MOVFF  02,734
03BE6:  MOVFF  01,733
03BEA:  MOVFF  00,732
03BEE:  MOVFF  03,739
03BF2:  MOVFF  02,738
03BF6:  MOVFF  01,737
03BFA:  MOVFF  00,736
03BFE:  RCALL  36B2
03C00:  BRA    3DBC
....................       } else {
03C02:  BRA    3C7C
....................          return (-exp(log(-x) * y));
03C04:  MOVLB  7
03C06:  MOVF   x2B,W
03C08:  XORLW  80
03C0A:  MOVWF  x33
03C0C:  MOVFF  72D,739
03C10:  MOVFF  72C,738
03C14:  MOVWF  x37
03C16:  MOVFF  72A,736
03C1A:  MOVLB  0
03C1C:  CALL   331E
03C20:  MOVFF  03,735
03C24:  MOVFF  02,734
03C28:  MOVFF  01,733
03C2C:  MOVFF  00,732
03C30:  MOVFF  03,759
03C34:  MOVFF  02,758
03C38:  MOVFF  01,757
03C3C:  MOVFF  00,756
03C40:  MOVFF  731,75D
03C44:  MOVFF  730,75C
03C48:  MOVFF  72F,75B
03C4C:  MOVFF  72E,75A
03C50:  CALL   1138
03C54:  MOVFF  03,735
03C58:  MOVFF  02,734
03C5C:  MOVFF  01,733
03C60:  MOVFF  00,732
03C64:  MOVFF  03,739
03C68:  MOVFF  02,738
03C6C:  MOVFF  01,737
03C70:  MOVFF  00,736
03C74:  RCALL  36B2
03C76:  MOVLW  80
03C78:  XORWF  01,F
03C7A:  BRA    3DBC
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
03C7C:  BRA    3DBC
03C7E:  MOVFF  72D,759
03C82:  MOVFF  72C,758
03C86:  MOVFF  72B,757
03C8A:  MOVFF  72A,756
03C8E:  MOVLB  7
03C90:  CLRF   x5D
03C92:  CLRF   x5C
03C94:  CLRF   x5B
03C96:  CLRF   x5A
03C98:  MOVLB  0
03C9A:  CALL   0D84
03C9E:  BNC   3D00
03CA0:  MOVFF  731,735
03CA4:  MOVFF  730,734
03CA8:  MOVFF  72F,733
03CAC:  MOVFF  72E,732
03CB0:  MOVLB  7
03CB2:  CLRF   x39
03CB4:  CLRF   x38
03CB6:  CLRF   x37
03CB8:  MOVLW  7F
03CBA:  MOVWF  x36
03CBC:  MOVLB  0
03CBE:  CALL   31B8
03CC2:  MOVFF  03,735
03CC6:  MOVFF  02,734
03CCA:  MOVFF  01,733
03CCE:  MOVFF  00,732
03CD2:  MOVFF  03,759
03CD6:  MOVFF  02,758
03CDA:  MOVFF  01,757
03CDE:  MOVFF  00,756
03CE2:  MOVLB  7
03CE4:  CLRF   x5D
03CE6:  CLRF   x5C
03CE8:  CLRF   x5B
03CEA:  CLRF   x5A
03CEC:  MOVLB  0
03CEE:  CALL   0D84
03CF2:  BZ    3D00
....................       return 0;
03CF4:  CLRF   00
03CF6:  CLRF   01
03CF8:  CLRF   02
03CFA:  CLRF   03
03CFC:  BRA    3DBC
....................    } else {
03CFE:  BRA    3DBC
....................       if(x != 0 || 0 >= y) {
03D00:  MOVFF  72D,759
03D04:  MOVFF  72C,758
03D08:  MOVFF  72B,757
03D0C:  MOVFF  72A,756
03D10:  MOVLB  7
03D12:  CLRF   x5D
03D14:  CLRF   x5C
03D16:  CLRF   x5B
03D18:  CLRF   x5A
03D1A:  MOVLB  0
03D1C:  CALL   0D84
03D20:  BNZ   3D46
03D22:  MOVFF  731,759
03D26:  MOVFF  730,758
03D2A:  MOVFF  72F,757
03D2E:  MOVFF  72E,756
03D32:  MOVLB  7
03D34:  CLRF   x5D
03D36:  CLRF   x5C
03D38:  CLRF   x5B
03D3A:  CLRF   x5A
03D3C:  MOVLB  0
03D3E:  CALL   0D84
03D42:  BC    3D46
03D44:  BNZ   3DB4
....................          return (exp(log(x) * y));
03D46:  MOVFF  72D,739
03D4A:  MOVFF  72C,738
03D4E:  MOVFF  72B,737
03D52:  MOVFF  72A,736
03D56:  CALL   331E
03D5A:  MOVFF  03,735
03D5E:  MOVFF  02,734
03D62:  MOVFF  01,733
03D66:  MOVFF  00,732
03D6A:  MOVFF  03,759
03D6E:  MOVFF  02,758
03D72:  MOVFF  01,757
03D76:  MOVFF  00,756
03D7A:  MOVFF  731,75D
03D7E:  MOVFF  730,75C
03D82:  MOVFF  72F,75B
03D86:  MOVFF  72E,75A
03D8A:  CALL   1138
03D8E:  MOVFF  03,735
03D92:  MOVFF  02,734
03D96:  MOVFF  01,733
03D9A:  MOVFF  00,732
03D9E:  MOVFF  03,739
03DA2:  MOVFF  02,738
03DA6:  MOVFF  01,737
03DAA:  MOVFF  00,736
03DAE:  RCALL  36B2
03DB0:  BRA    3DBC
....................       } else return 0;
03DB2:  BRA    3DBC
03DB4:  CLRF   00
03DB6:  CLRF   01
03DB8:  CLRF   02
03DBA:  CLRF   03
....................    }
03DBC:  RETURN 0
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
*
025AE:  MOVLB  7
025B0:  BCF    x48.0
....................    flag = 0;
025B2:  BCF    x48.1
....................    y = x;
025B4:  MOVFF  73B,73F
025B8:  MOVFF  73A,73E
025BC:  MOVFF  739,73D
025C0:  MOVFF  738,73C
.................... 
....................    if (x < 0)
025C4:  MOVFF  73B,759
025C8:  MOVFF  73A,758
025CC:  MOVFF  739,757
025D0:  MOVFF  738,756
025D4:  CLRF   x5D
025D6:  CLRF   x5C
025D8:  CLRF   x5B
025DA:  CLRF   x5A
025DC:  MOVLB  0
025DE:  CALL   0D84
025E2:  BNC   25F0
....................    {
....................       s = 1;
025E4:  MOVLB  7
025E6:  BSF    x48.0
....................       y = -y;
025E8:  MOVF   x3D,W
025EA:  XORLW  80
025EC:  MOVWF  x3D
025EE:  MOVLB  0
....................    }
.................... 
....................    if (y > 1.0)
025F0:  MOVLB  7
025F2:  CLRF   x59
025F4:  CLRF   x58
025F6:  CLRF   x57
025F8:  MOVLW  7F
025FA:  MOVWF  x56
025FC:  MOVFF  73F,75D
02600:  MOVFF  73E,75C
02604:  MOVFF  73D,75B
02608:  MOVFF  73C,75A
0260C:  MOVLB  0
0260E:  CALL   0D84
02612:  BNC   264A
....................    {
....................       y = 1.0/y;
02614:  MOVLB  7
02616:  CLRF   x52
02618:  CLRF   x51
0261A:  CLRF   x50
0261C:  MOVLW  7F
0261E:  MOVWF  x4F
02620:  MOVFF  73F,756
02624:  MOVFF  73E,755
02628:  MOVFF  73D,754
0262C:  MOVFF  73C,753
02630:  MOVLB  0
02632:  RCALL  2450
02634:  MOVFF  03,73F
02638:  MOVFF  02,73E
0263C:  MOVFF  01,73D
02640:  MOVFF  00,73C
....................       flag = 1;
02644:  MOVLB  7
02646:  BSF    x48.1
02648:  MOVLB  0
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
0264A:  MOVLW  0A
0264C:  MOVLB  7
0264E:  MOVWF  x59
02650:  MOVLW  89
02652:  MOVWF  x58
02654:  MOVLW  34
02656:  MOVWF  x57
02658:  MOVLW  7C
0265A:  MOVWF  x56
0265C:  MOVFF  73F,75D
02660:  MOVFF  73E,75C
02664:  MOVFF  73D,75B
02668:  MOVFF  73C,75A
0266C:  MOVLB  0
0266E:  CALL   1138
02672:  MOVFF  03,74C
02676:  MOVFF  02,74B
0267A:  MOVFF  01,74A
0267E:  MOVFF  00,749
02682:  MOVFF  03,759
02686:  MOVFF  02,758
0268A:  MOVFF  01,757
0268E:  MOVFF  00,756
02692:  MOVFF  73F,75D
02696:  MOVFF  73E,75C
0269A:  MOVFF  73D,75B
0269E:  MOVFF  73C,75A
026A2:  CALL   1138
026A6:  MOVFF  03,74C
026AA:  MOVFF  02,74B
026AE:  MOVFF  01,74A
026B2:  MOVFF  00,749
026B6:  BCF    FD8.1
026B8:  MOVFF  03,75D
026BC:  MOVFF  02,75C
026C0:  MOVFF  01,75B
026C4:  MOVFF  00,75A
026C8:  MOVLW  7C
026CA:  MOVLB  7
026CC:  MOVWF  x61
026CE:  MOVLW  79
026D0:  MOVWF  x60
026D2:  MOVLW  35
026D4:  MOVWF  x5F
026D6:  MOVLW  81
026D8:  MOVWF  x5E
026DA:  MOVLB  0
026DC:  CALL   0DFE
026E0:  MOVFF  03,743
026E4:  MOVFF  02,742
026E8:  MOVFF  01,741
026EC:  MOVFF  00,740
....................    res = res*y*y + pat[2];
026F0:  MOVFF  743,759
026F4:  MOVFF  742,758
026F8:  MOVFF  741,757
026FC:  MOVFF  740,756
02700:  MOVFF  73F,75D
02704:  MOVFF  73E,75C
02708:  MOVFF  73D,75B
0270C:  MOVFF  73C,75A
02710:  CALL   1138
02714:  MOVFF  03,74C
02718:  MOVFF  02,74B
0271C:  MOVFF  01,74A
02720:  MOVFF  00,749
02724:  MOVFF  03,759
02728:  MOVFF  02,758
0272C:  MOVFF  01,757
02730:  MOVFF  00,756
02734:  MOVFF  73F,75D
02738:  MOVFF  73E,75C
0273C:  MOVFF  73D,75B
02740:  MOVFF  73C,75A
02744:  CALL   1138
02748:  MOVFF  03,74C
0274C:  MOVFF  02,74B
02750:  MOVFF  01,74A
02754:  MOVFF  00,749
02758:  BCF    FD8.1
0275A:  MOVFF  03,75D
0275E:  MOVFF  02,75C
02762:  MOVFF  01,75B
02766:  MOVFF  00,75A
0276A:  MOVLW  3F
0276C:  MOVLB  7
0276E:  MOVWF  x61
02770:  MOVLW  02
02772:  MOVWF  x60
02774:  MOVLW  33
02776:  MOVWF  x5F
02778:  MOVLW  83
0277A:  MOVWF  x5E
0277C:  MOVLB  0
0277E:  CALL   0DFE
02782:  MOVFF  03,743
02786:  MOVFF  02,742
0278A:  MOVFF  01,741
0278E:  MOVFF  00,740
....................    res = res*y*y + pat[3];
02792:  MOVFF  743,759
02796:  MOVFF  742,758
0279A:  MOVFF  741,757
0279E:  MOVFF  740,756
027A2:  MOVFF  73F,75D
027A6:  MOVFF  73E,75C
027AA:  MOVFF  73D,75B
027AE:  MOVFF  73C,75A
027B2:  CALL   1138
027B6:  MOVFF  03,74C
027BA:  MOVFF  02,74B
027BE:  MOVFF  01,74A
027C2:  MOVFF  00,749
027C6:  MOVFF  03,759
027CA:  MOVFF  02,758
027CE:  MOVFF  01,757
027D2:  MOVFF  00,756
027D6:  MOVFF  73F,75D
027DA:  MOVFF  73E,75C
027DE:  MOVFF  73D,75B
027E2:  MOVFF  73C,75A
027E6:  CALL   1138
027EA:  MOVFF  03,74C
027EE:  MOVFF  02,74B
027F2:  MOVFF  01,74A
027F6:  MOVFF  00,749
027FA:  BCF    FD8.1
027FC:  MOVFF  03,75D
02800:  MOVFF  02,75C
02804:  MOVFF  01,75B
02808:  MOVFF  00,75A
0280C:  MOVLW  33
0280E:  MOVLB  7
02810:  MOVWF  x61
02812:  MOVLW  8C
02814:  MOVWF  x60
02816:  MOVLW  1E
02818:  MOVWF  x5F
0281A:  MOVLW  83
0281C:  MOVWF  x5E
0281E:  MOVLB  0
02820:  CALL   0DFE
02824:  MOVFF  03,743
02828:  MOVFF  02,742
0282C:  MOVFF  01,741
02830:  MOVFF  00,740
.................... 
....................    r = qat[0]*y*y + qat[1];
02834:  MOVLB  7
02836:  CLRF   x59
02838:  CLRF   x58
0283A:  CLRF   x57
0283C:  MOVLW  7F
0283E:  MOVWF  x56
02840:  MOVFF  73F,75D
02844:  MOVFF  73E,75C
02848:  MOVFF  73D,75B
0284C:  MOVFF  73C,75A
02850:  MOVLB  0
02852:  CALL   1138
02856:  MOVFF  03,74C
0285A:  MOVFF  02,74B
0285E:  MOVFF  01,74A
02862:  MOVFF  00,749
02866:  MOVFF  03,759
0286A:  MOVFF  02,758
0286E:  MOVFF  01,757
02872:  MOVFF  00,756
02876:  MOVFF  73F,75D
0287A:  MOVFF  73E,75C
0287E:  MOVFF  73D,75B
02882:  MOVFF  73C,75A
02886:  CALL   1138
0288A:  MOVFF  03,74C
0288E:  MOVFF  02,74B
02892:  MOVFF  01,74A
02896:  MOVFF  00,749
0289A:  BCF    FD8.1
0289C:  MOVFF  03,75D
028A0:  MOVFF  02,75C
028A4:  MOVFF  01,75B
028A8:  MOVFF  00,75A
028AC:  MOVLW  1B
028AE:  MOVLB  7
028B0:  MOVWF  x61
028B2:  MOVLW  E4
028B4:  MOVWF  x60
028B6:  MOVLW  35
028B8:  MOVWF  x5F
028BA:  MOVLW  82
028BC:  MOVWF  x5E
028BE:  MOVLB  0
028C0:  CALL   0DFE
028C4:  MOVFF  03,747
028C8:  MOVFF  02,746
028CC:  MOVFF  01,745
028D0:  MOVFF  00,744
....................    r = r*y*y + qat[2];
028D4:  MOVFF  747,759
028D8:  MOVFF  746,758
028DC:  MOVFF  745,757
028E0:  MOVFF  744,756
028E4:  MOVFF  73F,75D
028E8:  MOVFF  73E,75C
028EC:  MOVFF  73D,75B
028F0:  MOVFF  73C,75A
028F4:  CALL   1138
028F8:  MOVFF  03,74C
028FC:  MOVFF  02,74B
02900:  MOVFF  01,74A
02904:  MOVFF  00,749
02908:  MOVFF  03,759
0290C:  MOVFF  02,758
02910:  MOVFF  01,757
02914:  MOVFF  00,756
02918:  MOVFF  73F,75D
0291C:  MOVFF  73E,75C
02920:  MOVFF  73D,75B
02924:  MOVFF  73C,75A
02928:  CALL   1138
0292C:  MOVFF  03,74C
02930:  MOVFF  02,74B
02934:  MOVFF  01,74A
02938:  MOVFF  00,749
0293C:  BCF    FD8.1
0293E:  MOVFF  03,75D
02942:  MOVFF  02,75C
02946:  MOVFF  01,75B
0294A:  MOVFF  00,75A
0294E:  MOVLW  A4
02950:  MOVLB  7
02952:  MOVWF  x61
02954:  MOVLW  DB
02956:  MOVWF  x60
02958:  MOVLW  67
0295A:  MOVWF  x5F
0295C:  MOVLW  83
0295E:  MOVWF  x5E
02960:  MOVLB  0
02962:  CALL   0DFE
02966:  MOVFF  03,747
0296A:  MOVFF  02,746
0296E:  MOVFF  01,745
02972:  MOVFF  00,744
....................    r = r*y*y + qat[3];
02976:  MOVFF  747,759
0297A:  MOVFF  746,758
0297E:  MOVFF  745,757
02982:  MOVFF  744,756
02986:  MOVFF  73F,75D
0298A:  MOVFF  73E,75C
0298E:  MOVFF  73D,75B
02992:  MOVFF  73C,75A
02996:  CALL   1138
0299A:  MOVFF  03,74C
0299E:  MOVFF  02,74B
029A2:  MOVFF  01,74A
029A6:  MOVFF  00,749
029AA:  MOVFF  03,759
029AE:  MOVFF  02,758
029B2:  MOVFF  01,757
029B6:  MOVFF  00,756
029BA:  MOVFF  73F,75D
029BE:  MOVFF  73E,75C
029C2:  MOVFF  73D,75B
029C6:  MOVFF  73C,75A
029CA:  CALL   1138
029CE:  MOVFF  03,74C
029D2:  MOVFF  02,74B
029D6:  MOVFF  01,74A
029DA:  MOVFF  00,749
029DE:  BCF    FD8.1
029E0:  MOVFF  03,75D
029E4:  MOVFF  02,75C
029E8:  MOVFF  01,75B
029EC:  MOVFF  00,75A
029F0:  MOVLW  33
029F2:  MOVLB  7
029F4:  MOVWF  x61
029F6:  MOVLW  8C
029F8:  MOVWF  x60
029FA:  MOVLW  1E
029FC:  MOVWF  x5F
029FE:  MOVLW  83
02A00:  MOVWF  x5E
02A02:  MOVLB  0
02A04:  CALL   0DFE
02A08:  MOVFF  03,747
02A0C:  MOVFF  02,746
02A10:  MOVFF  01,745
02A14:  MOVFF  00,744
.................... 
....................    res = y*res/r;
02A18:  MOVFF  73F,759
02A1C:  MOVFF  73E,758
02A20:  MOVFF  73D,757
02A24:  MOVFF  73C,756
02A28:  MOVFF  743,75D
02A2C:  MOVFF  742,75C
02A30:  MOVFF  741,75B
02A34:  MOVFF  740,75A
02A38:  CALL   1138
02A3C:  MOVFF  03,74C
02A40:  MOVFF  02,74B
02A44:  MOVFF  01,74A
02A48:  MOVFF  00,749
02A4C:  MOVFF  03,752
02A50:  MOVFF  02,751
02A54:  MOVFF  01,750
02A58:  MOVFF  00,74F
02A5C:  MOVFF  747,756
02A60:  MOVFF  746,755
02A64:  MOVFF  745,754
02A68:  MOVFF  744,753
02A6C:  RCALL  2450
02A6E:  MOVFF  03,743
02A72:  MOVFF  02,742
02A76:  MOVFF  01,741
02A7A:  MOVFF  00,740
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
02A7E:  MOVLB  7
02A80:  BTFSS  x48.1
02A82:  BRA    2ABE
....................       res = PI_DIV_BY_TWO - res;
02A84:  BSF    FD8.1
02A86:  MOVLW  DB
02A88:  MOVWF  x5D
02A8A:  MOVLW  0F
02A8C:  MOVWF  x5C
02A8E:  MOVLW  49
02A90:  MOVWF  x5B
02A92:  MOVLW  7F
02A94:  MOVWF  x5A
02A96:  MOVFF  743,761
02A9A:  MOVFF  742,760
02A9E:  MOVFF  741,75F
02AA2:  MOVFF  740,75E
02AA6:  MOVLB  0
02AA8:  CALL   0DFE
02AAC:  MOVFF  03,743
02AB0:  MOVFF  02,742
02AB4:  MOVFF  01,741
02AB8:  MOVFF  00,740
02ABC:  MOVLB  7
....................    if (s)
02ABE:  BTFSS  x48.0
02AC0:  BRA    2AC8
....................       res = -res;
02AC2:  MOVF   x41,W
02AC4:  XORLW  80
02AC6:  MOVWF  x41
.................... 
....................    return(res);
02AC8:  MOVFF  740,00
02ACC:  MOVFF  741,01
02AD0:  MOVFF  742,02
02AD4:  MOVFF  743,03
02AD8:  MOVLB  0
02ADA:  RETURN 0
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
02ADC:  MOVLB  7
02ADE:  BCF    x36.0
....................    quad=0; //quadrant
02AE0:  CLRF   x37
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
02AE2:  MOVFF  72D,759
02AE6:  MOVFF  72C,758
02AEA:  MOVFF  72B,757
02AEE:  MOVFF  72A,756
02AF2:  CLRF   x5D
02AF4:  CLRF   x5C
02AF6:  CLRF   x5B
02AF8:  CLRF   x5A
02AFA:  MOVLB  0
02AFC:  CALL   0D84
02B00:  BC    2B04
02B02:  BNZ   2B30
02B04:  MOVFF  731,759
02B08:  MOVFF  730,758
02B0C:  MOVFF  72F,757
02B10:  MOVFF  72E,756
02B14:  MOVLB  7
02B16:  CLRF   x5D
02B18:  CLRF   x5C
02B1A:  CLRF   x5B
02B1C:  CLRF   x5A
02B1E:  MOVLB  0
02B20:  CALL   0D84
02B24:  BC    2B28
02B26:  BNZ   2B2C
02B28:  MOVLW  03
02B2A:  BRA    2B2E
02B2C:  MOVLW  04
02B2E:  BRA    2B58
02B30:  MOVFF  731,759
02B34:  MOVFF  730,758
02B38:  MOVFF  72F,757
02B3C:  MOVFF  72E,756
02B40:  MOVLB  7
02B42:  CLRF   x5D
02B44:  CLRF   x5C
02B46:  CLRF   x5B
02B48:  CLRF   x5A
02B4A:  MOVLB  0
02B4C:  CALL   0D84
02B50:  BNC   2B56
02B52:  MOVLW  02
02B54:  BRA    2B58
02B56:  MOVLW  01
02B58:  MOVLB  7
02B5A:  MOVWF  x37
....................    if(y<0.0)
02B5C:  MOVFF  72D,759
02B60:  MOVFF  72C,758
02B64:  MOVFF  72B,757
02B68:  MOVFF  72A,756
02B6C:  CLRF   x5D
02B6E:  CLRF   x5C
02B70:  CLRF   x5B
02B72:  CLRF   x5A
02B74:  MOVLB  0
02B76:  CALL   0D84
02B7A:  BNC   2B88
....................    {
....................       sign=1;
02B7C:  MOVLB  7
02B7E:  BSF    x36.0
....................       y=-y;
02B80:  MOVF   x2B,W
02B82:  XORLW  80
02B84:  MOVWF  x2B
02B86:  MOVLB  0
....................    }
....................    if(x<0.0)
02B88:  MOVFF  731,759
02B8C:  MOVFF  730,758
02B90:  MOVFF  72F,757
02B94:  MOVFF  72E,756
02B98:  MOVLB  7
02B9A:  CLRF   x5D
02B9C:  CLRF   x5C
02B9E:  CLRF   x5B
02BA0:  CLRF   x5A
02BA2:  MOVLB  0
02BA4:  CALL   0D84
02BA8:  BNC   2BB4
....................    {
....................       x=-x;
02BAA:  MOVLB  7
02BAC:  MOVF   x2F,W
02BAE:  XORLW  80
02BB0:  MOVWF  x2F
02BB2:  MOVLB  0
....................    }
....................    if (x==0.0)
02BB4:  MOVFF  731,759
02BB8:  MOVFF  730,758
02BBC:  MOVFF  72F,757
02BC0:  MOVFF  72E,756
02BC4:  MOVLB  7
02BC6:  CLRF   x5D
02BC8:  CLRF   x5C
02BCA:  CLRF   x5B
02BCC:  CLRF   x5A
02BCE:  MOVLB  0
02BD0:  CALL   0D84
02BD4:  BNZ   2C2A
....................    {
....................       if(y==0.0)
02BD6:  MOVFF  72D,759
02BDA:  MOVFF  72C,758
02BDE:  MOVFF  72B,757
02BE2:  MOVFF  72A,756
02BE6:  MOVLB  7
02BE8:  CLRF   x5D
02BEA:  CLRF   x5C
02BEC:  CLRF   x5B
02BEE:  CLRF   x5A
02BF0:  MOVLB  0
02BF2:  CALL   0D84
02BF6:  BNZ   2BFA
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
02BF8:  BRA    2C28
....................       else
....................       {
....................          if(sign)
02BFA:  MOVLB  7
02BFC:  BTFSS  x36.0
02BFE:  BRA    2C14
....................          {
....................          return (-(PI_DIV_BY_TWO));
02C00:  MOVLW  7F
02C02:  MOVWF  00
02C04:  MOVLW  C9
02C06:  MOVWF  01
02C08:  MOVLW  0F
02C0A:  MOVWF  02
02C0C:  MOVLW  DB
02C0E:  MOVWF  03
02C10:  BRA    2D62
....................          }
02C12:  BRA    2C26
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
02C14:  MOVLW  7F
02C16:  MOVWF  00
02C18:  MOVLW  49
02C1A:  MOVWF  01
02C1C:  MOVLW  0F
02C1E:  MOVWF  02
02C20:  MOVLW  DB
02C22:  MOVWF  03
02C24:  BRA    2D62
02C26:  MOVLB  0
....................          }
....................       }
....................    }
02C28:  BRA    2D60
....................    else
....................    {
....................       z=y/x;
02C2A:  MOVFF  72D,752
02C2E:  MOVFF  72C,751
02C32:  MOVFF  72B,750
02C36:  MOVFF  72A,74F
02C3A:  MOVFF  731,756
02C3E:  MOVFF  730,755
02C42:  MOVFF  72F,754
02C46:  MOVFF  72E,753
02C4A:  RCALL  2450
02C4C:  MOVFF  03,735
02C50:  MOVFF  02,734
02C54:  MOVFF  01,733
02C58:  MOVFF  00,732
....................       switch(quad)
02C5C:  MOVLW  01
02C5E:  MOVLB  7
02C60:  SUBWF  x37,W
02C62:  ADDLW  FC
02C64:  BTFSC  FD8.0
02C66:  BRA    2D62
02C68:  ADDLW  04
02C6A:  MOVLB  0
02C6C:  GOTO   2D68
....................       {
....................          case 1:
....................          {
....................             return atan(z);
02C70:  MOVFF  735,73B
02C74:  MOVFF  734,73A
02C78:  MOVFF  733,739
02C7C:  MOVFF  732,738
02C80:  RCALL  25AE
02C82:  MOVLB  7
02C84:  BRA    2D62
....................             break;
02C86:  BRA    2D62
02C88:  MOVLB  0
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
02C8A:  MOVFF  735,73B
02C8E:  MOVFF  734,73A
02C92:  MOVFF  733,739
02C96:  MOVFF  732,738
02C9A:  RCALL  25AE
02C9C:  MOVFF  FEA,739
02CA0:  MOVFF  FE9,738
02CA4:  BSF    FD8.1
02CA6:  MOVLW  DB
02CA8:  MOVLB  7
02CAA:  MOVWF  x5D
02CAC:  MOVLW  0F
02CAE:  MOVWF  x5C
02CB0:  MOVLW  49
02CB2:  MOVWF  x5B
02CB4:  MOVLW  80
02CB6:  MOVWF  x5A
02CB8:  MOVFF  03,761
02CBC:  MOVFF  02,760
02CC0:  MOVFF  01,75F
02CC4:  MOVFF  00,75E
02CC8:  MOVLB  0
02CCA:  CALL   0DFE
02CCE:  MOVFF  739,FEA
02CD2:  MOVFF  738,FE9
02CD6:  MOVLB  7
02CD8:  BRA    2D62
....................             break;
02CDA:  BRA    2D62
02CDC:  MOVLB  0
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
02CDE:  MOVFF  735,73B
02CE2:  MOVFF  734,73A
02CE6:  MOVFF  733,739
02CEA:  MOVFF  732,738
02CEE:  RCALL  25AE
02CF0:  MOVFF  03,73B
02CF4:  MOVFF  02,73A
02CF8:  MOVFF  01,739
02CFC:  MOVFF  00,738
02D00:  MOVFF  FEA,73D
02D04:  MOVFF  FE9,73C
02D08:  BSF    FD8.1
02D0A:  MOVFF  03,75D
02D0E:  MOVFF  02,75C
02D12:  MOVFF  01,75B
02D16:  MOVFF  00,75A
02D1A:  MOVLW  DB
02D1C:  MOVLB  7
02D1E:  MOVWF  x61
02D20:  MOVLW  0F
02D22:  MOVWF  x60
02D24:  MOVLW  49
02D26:  MOVWF  x5F
02D28:  MOVLW  80
02D2A:  MOVWF  x5E
02D2C:  MOVLB  0
02D2E:  CALL   0DFE
02D32:  MOVFF  73D,FEA
02D36:  MOVFF  73C,FE9
02D3A:  MOVLB  7
02D3C:  BRA    2D62
....................             break;
02D3E:  BRA    2D62
02D40:  MOVLB  0
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
02D42:  MOVFF  735,73B
02D46:  MOVFF  734,73A
02D4A:  MOVFF  733,739
02D4E:  MOVFF  732,738
02D52:  RCALL  25AE
02D54:  MOVLW  80
02D56:  XORWF  01,F
02D58:  MOVLB  7
02D5A:  BRA    2D62
....................             break;
02D5C:  BRA    2D62
02D5E:  MOVLB  0
02D60:  MOVLB  7
....................          }
....................       }
....................    }
02D62:  MOVLB  0
02D64:  GOTO   4466 (RETURN)
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... #define sensorSampleRate 50 // 50mS delay between each sensor sample = 100ms cadence 
.................... 
.................... #define maxCount 16777216.0   // ADC max count
.................... #define vRef 2.048            // ADC vRef
.................... 
.................... #define sc sensorCal
.................... 
.................... #define vMonN15   6
.................... #define vMon200   16
.................... #define vMon5V6   24
.................... #define vMon5VA   25
.................... #define vMon3V6X  17
.................... #define vMon3V3A  27
.................... #define vMon3V3D  26
.................... 
.................... #define BUFFER_SIZE 5
.................... 
.................... signed int32 sQ_x[BUFFER_SIZE];
.................... signed int32 cQ_x[BUFFER_SIZE];
.................... signed int32 sQ_y[BUFFER_SIZE];
.................... signed int32 cQ_y[BUFFER_SIZE];
.................... int sIn_x=0;
.................... int cIn_x=0;
.................... int sIn_y=0;
.................... int cIn_y=0;
.................... 
.................... struct sensorMonitorData
.................... {
....................    boolean dataReady;
....................    boolean adcBusy;
....................    signed int32 avgSin;
....................    signed int32 avgCos;
.................... } smData[2] = 
.................... {
....................    {false, false, 0, 0},
....................    {false, false, 0, 0}
.................... };
.................... 
.................... void push(signed int32* buff, int* idx, signed int32 newData) {
....................    buff[*idx]=newData;
*
008DE:  MOVFF  740,FEA
008E2:  MOVLB  7
008E4:  MOVFF  73F,FE9
008E8:  CLRF   x47
008EA:  MOVFF  FEF,746
008EE:  CLRF   x49
008F0:  MOVLW  04
008F2:  MOVWF  x48
008F4:  MOVLB  0
008F6:  RCALL  0890
008F8:  MOVF   01,W
008FA:  MOVLB  7
008FC:  ADDWF  x3D,W
008FE:  MOVWF  FE9
00900:  MOVF   x3E,W
00902:  ADDWFC 02,W
00904:  MOVWF  FEA
00906:  MOVFF  741,FEF
0090A:  MOVFF  742,FEC
0090E:  MOVFF  743,FEC
00912:  MOVFF  744,FEC
....................    *idx=(*idx+1) % BUFFER_SIZE;
00916:  MOVFF  740,746
0091A:  MOVFF  740,FEA
0091E:  MOVFF  73F,FE9
00922:  MOVLW  01
00924:  ADDWF  FEF,W
00926:  MOVWF  x48
00928:  MOVWF  x49
0092A:  MOVLW  05
0092C:  MOVWF  x4A
0092E:  MOVLB  0
00930:  RCALL  08B2
00932:  MOVLB  7
00934:  MOVFF  746,FEA
00938:  MOVFF  73F,FE9
0093C:  MOVFF  00,FEF
00940:  MOVLB  0
00942:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INTERNAL MONITOR task - gets voltages                                     */
.................... /* gets one value each time the task is run                                  */
.................... /*****************************************************************************/
.................... void internal_monitor_task(){
....................    static int8 state = 0;
....................    if (adc_done()){
*
0503C:  MOVLB  F
0503E:  BTFSC  x5B.0
05040:  BRA    55B2
....................       switch (state)
05042:  MOVLB  1
05044:  MOVF   xE6,W
05046:  ADDLW  F9
05048:  BTFSC  FD8.0
0504A:  BRA    55B0
0504C:  ADDLW  07
0504E:  MOVLB  0
05050:  GOTO   55B8
....................       {
....................          case 0:     // vMonN15
....................             monitorVals.vN15 = read_adc(ADC_READ_ONLY) * monCal.vN15[1] + monCal.vN15[0];
05054:  MOVLB  F
05056:  BTFSC  x5B.0
05058:  BRA    5056
0505A:  MOVFF  F5F,02
0505E:  MOVFF  F5E,01
05062:  MOVFF  02,6FC
05066:  MOVFF  01,6FB
0506A:  MOVFF  02,75B
0506E:  MOVFF  01,75A
05072:  MOVLB  0
05074:  CALL   2DDA
05078:  MOVFF  03,759
0507C:  MOVFF  02,758
05080:  MOVFF  01,757
05084:  MOVFF  00,756
05088:  MOVFF  C9,75D
0508C:  MOVFF  C8,75C
05090:  MOVFF  C7,75B
05094:  MOVFF  C6,75A
05098:  CALL   1138
0509C:  MOVFF  03,6FE
050A0:  MOVFF  02,6FD
050A4:  MOVFF  01,6FC
050A8:  MOVFF  00,6FB
050AC:  BCF    FD8.1
050AE:  MOVFF  03,75D
050B2:  MOVFF  02,75C
050B6:  MOVFF  01,75B
050BA:  MOVFF  00,75A
050BE:  MOVFF  C5,761
050C2:  MOVFF  C4,760
050C6:  MOVFF  C3,75F
050CA:  MOVFF  C2,75E
050CE:  CALL   0DFE
050D2:  MOVFF  03,FE
050D6:  MOVFF  02,FD
050DA:  MOVFF  01,FC
050DE:  MOVFF  00,FB
....................             set_adc_channel(vMon200);
050E2:  MOVLB  F
050E4:  MOVF   x5A,W
050E6:  ANDLW  3F
050E8:  MOVWF  01
050EA:  MOVLW  10
050EC:  MOVWF  x5A
050EE:  BTFSS  x5B.7
050F0:  BRA    5100
050F2:  MOVF   01,W
050F4:  SUBLW  10
050F6:  BZ    5100
050F8:  BSF    x5B.0
050FA:  NOP   
050FC:  BTFSC  x5B.0
050FE:  BRA    50FC
....................             delay_ms(10);
05100:  MOVLW  0A
05102:  MOVLB  7
05104:  MOVWF  x0F
05106:  MOVLB  0
05108:  CALL   03A4
....................             read_adc(ADC_START_ONLY);
0510C:  MOVLB  F
0510E:  BSF    x5B.0
05110:  NOP   
....................             state = 1;
05112:  MOVLW  01
05114:  MOVLB  1
05116:  MOVWF  xE6
....................          break;
05118:  BRA    55B0
....................          
....................          case 1:     // vMon200
....................             monitorVals.v200 = read_adc(ADC_READ_ONLY) * monCal.v200[1] + monCal.v200[0];
0511A:  MOVLB  F
0511C:  BTFSC  x5B.0
0511E:  BRA    511C
05120:  MOVFF  F5F,02
05124:  MOVFF  F5E,01
05128:  MOVFF  02,6FC
0512C:  MOVFF  01,6FB
05130:  MOVFF  02,75B
05134:  MOVFF  01,75A
05138:  MOVLB  0
0513A:  CALL   2DDA
0513E:  MOVFF  03,759
05142:  MOVFF  02,758
05146:  MOVFF  01,757
0514A:  MOVFF  00,756
0514E:  MOVFF  D1,75D
05152:  MOVFF  D0,75C
05156:  MOVFF  CF,75B
0515A:  MOVFF  CE,75A
0515E:  CALL   1138
05162:  MOVFF  03,6FE
05166:  MOVFF  02,6FD
0516A:  MOVFF  01,6FC
0516E:  MOVFF  00,6FB
05172:  BCF    FD8.1
05174:  MOVFF  03,75D
05178:  MOVFF  02,75C
0517C:  MOVFF  01,75B
05180:  MOVFF  00,75A
05184:  MOVFF  CD,761
05188:  MOVFF  CC,760
0518C:  MOVFF  CB,75F
05190:  MOVFF  CA,75E
05194:  CALL   0DFE
05198:  MOVFF  03,102
0519C:  MOVFF  02,101
051A0:  MOVFF  01,100
051A4:  MOVFF  00,FF
....................             set_adc_channel(vMon5V6);
051A8:  MOVLB  F
051AA:  MOVF   x5A,W
051AC:  ANDLW  3F
051AE:  MOVWF  01
051B0:  MOVLW  18
051B2:  MOVWF  x5A
051B4:  BTFSS  x5B.7
051B6:  BRA    51C6
051B8:  MOVF   01,W
051BA:  SUBLW  18
051BC:  BZ    51C6
051BE:  BSF    x5B.0
051C0:  NOP   
051C2:  BTFSC  x5B.0
051C4:  BRA    51C2
....................             delay_ms(10);
051C6:  MOVLW  0A
051C8:  MOVLB  7
051CA:  MOVWF  x0F
051CC:  MOVLB  0
051CE:  CALL   03A4
....................             read_adc(ADC_START_ONLY);
051D2:  MOVLB  F
051D4:  BSF    x5B.0
051D6:  NOP   
....................             state = 2;
051D8:  MOVLW  02
051DA:  MOVLB  1
051DC:  MOVWF  xE6
....................          break;
051DE:  BRA    55B0
....................          
....................          case 2:     // vMon5V6
....................             monitorVals.v5V6 = read_adc(ADC_READ_ONLY) * monCal.v5V6[1] + monCal.v5V6[0];
051E0:  MOVLB  F
051E2:  BTFSC  x5B.0
051E4:  BRA    51E2
051E6:  MOVFF  F5F,02
051EA:  MOVFF  F5E,01
051EE:  MOVFF  02,6FC
051F2:  MOVFF  01,6FB
051F6:  MOVFF  02,75B
051FA:  MOVFF  01,75A
051FE:  MOVLB  0
05200:  CALL   2DDA
05204:  MOVFF  03,759
05208:  MOVFF  02,758
0520C:  MOVFF  01,757
05210:  MOVFF  00,756
05214:  MOVFF  D9,75D
05218:  MOVFF  D8,75C
0521C:  MOVFF  D7,75B
05220:  MOVFF  D6,75A
05224:  CALL   1138
05228:  MOVFF  03,6FE
0522C:  MOVFF  02,6FD
05230:  MOVFF  01,6FC
05234:  MOVFF  00,6FB
05238:  BCF    FD8.1
0523A:  MOVFF  03,75D
0523E:  MOVFF  02,75C
05242:  MOVFF  01,75B
05246:  MOVFF  00,75A
0524A:  MOVFF  D5,761
0524E:  MOVFF  D4,760
05252:  MOVFF  D3,75F
05256:  MOVFF  D2,75E
0525A:  CALL   0DFE
0525E:  MOVFF  03,106
05262:  MOVFF  02,105
05266:  MOVFF  01,104
0526A:  MOVFF  00,103
....................             set_adc_channel(vMon5VA);
0526E:  MOVLB  F
05270:  MOVF   x5A,W
05272:  ANDLW  3F
05274:  MOVWF  01
05276:  MOVLW  19
05278:  MOVWF  x5A
0527A:  BTFSS  x5B.7
0527C:  BRA    528C
0527E:  MOVF   01,W
05280:  SUBLW  19
05282:  BZ    528C
05284:  BSF    x5B.0
05286:  NOP   
05288:  BTFSC  x5B.0
0528A:  BRA    5288
....................             delay_ms(10);
0528C:  MOVLW  0A
0528E:  MOVLB  7
05290:  MOVWF  x0F
05292:  MOVLB  0
05294:  CALL   03A4
....................             read_adc(ADC_START_ONLY);
05298:  MOVLB  F
0529A:  BSF    x5B.0
0529C:  NOP   
....................             state = 3;
0529E:  MOVLW  03
052A0:  MOVLB  1
052A2:  MOVWF  xE6
....................          break;
052A4:  BRA    55B0
....................          
....................          case 3:     // vMon5VA
....................             monitorVals.v5VA = read_adc(ADC_READ_ONLY) * monCal.v5VA[1] + monCal.v5VA[0];
052A6:  MOVLB  F
052A8:  BTFSC  x5B.0
052AA:  BRA    52A8
052AC:  MOVFF  F5F,02
052B0:  MOVFF  F5E,01
052B4:  MOVFF  02,6FC
052B8:  MOVFF  01,6FB
052BC:  MOVFF  02,75B
052C0:  MOVFF  01,75A
052C4:  MOVLB  0
052C6:  CALL   2DDA
052CA:  MOVFF  03,759
052CE:  MOVFF  02,758
052D2:  MOVFF  01,757
052D6:  MOVFF  00,756
052DA:  MOVFF  E1,75D
052DE:  MOVFF  E0,75C
052E2:  MOVFF  DF,75B
052E6:  MOVFF  DE,75A
052EA:  CALL   1138
052EE:  MOVFF  03,6FE
052F2:  MOVFF  02,6FD
052F6:  MOVFF  01,6FC
052FA:  MOVFF  00,6FB
052FE:  BCF    FD8.1
05300:  MOVFF  03,75D
05304:  MOVFF  02,75C
05308:  MOVFF  01,75B
0530C:  MOVFF  00,75A
05310:  MOVFF  DD,761
05314:  MOVFF  DC,760
05318:  MOVFF  DB,75F
0531C:  MOVFF  DA,75E
05320:  CALL   0DFE
05324:  MOVFF  03,10A
05328:  MOVFF  02,109
0532C:  MOVFF  01,108
05330:  MOVFF  00,107
....................             set_adc_channel(vMon3V6X);
05334:  MOVLB  F
05336:  MOVF   x5A,W
05338:  ANDLW  3F
0533A:  MOVWF  01
0533C:  MOVLW  11
0533E:  MOVWF  x5A
05340:  BTFSS  x5B.7
05342:  BRA    5352
05344:  MOVF   01,W
05346:  SUBLW  11
05348:  BZ    5352
0534A:  BSF    x5B.0
0534C:  NOP   
0534E:  BTFSC  x5B.0
05350:  BRA    534E
....................             delay_ms(10);
05352:  MOVLW  0A
05354:  MOVLB  7
05356:  MOVWF  x0F
05358:  MOVLB  0
0535A:  CALL   03A4
....................             read_adc(ADC_START_ONLY);
0535E:  MOVLB  F
05360:  BSF    x5B.0
05362:  NOP   
....................             state = 4;
05364:  MOVLW  04
05366:  MOVLB  1
05368:  MOVWF  xE6
....................          break;
0536A:  BRA    55B0
....................          
....................          case 4:     // vMon3V6X
....................             monitorVals.v3V6X = read_adc(ADC_READ_ONLY) * monCal.v3V6X[1] + monCal.v3V6X[0];
0536C:  MOVLB  F
0536E:  BTFSC  x5B.0
05370:  BRA    536E
05372:  MOVFF  F5F,02
05376:  MOVFF  F5E,01
0537A:  MOVFF  02,6FC
0537E:  MOVFF  01,6FB
05382:  MOVFF  02,75B
05386:  MOVFF  01,75A
0538A:  MOVLB  0
0538C:  CALL   2DDA
05390:  MOVFF  03,759
05394:  MOVFF  02,758
05398:  MOVFF  01,757
0539C:  MOVFF  00,756
053A0:  MOVFF  E9,75D
053A4:  MOVFF  E8,75C
053A8:  MOVFF  E7,75B
053AC:  MOVFF  E6,75A
053B0:  CALL   1138
053B4:  MOVFF  03,6FE
053B8:  MOVFF  02,6FD
053BC:  MOVFF  01,6FC
053C0:  MOVFF  00,6FB
053C4:  BCF    FD8.1
053C6:  MOVFF  03,75D
053CA:  MOVFF  02,75C
053CE:  MOVFF  01,75B
053D2:  MOVFF  00,75A
053D6:  MOVFF  E5,761
053DA:  MOVFF  E4,760
053DE:  MOVFF  E3,75F
053E2:  MOVFF  E2,75E
053E6:  CALL   0DFE
053EA:  MOVFF  03,10E
053EE:  MOVFF  02,10D
053F2:  MOVFF  01,10C
053F6:  MOVFF  00,10B
....................             set_adc_channel(vMon3V3A);
053FA:  MOVLB  F
053FC:  MOVF   x5A,W
053FE:  ANDLW  3F
05400:  MOVWF  01
05402:  MOVLW  1B
05404:  MOVWF  x5A
05406:  BTFSS  x5B.7
05408:  BRA    5418
0540A:  MOVF   01,W
0540C:  SUBLW  1B
0540E:  BZ    5418
05410:  BSF    x5B.0
05412:  NOP   
05414:  BTFSC  x5B.0
05416:  BRA    5414
....................             delay_ms(10);
05418:  MOVLW  0A
0541A:  MOVLB  7
0541C:  MOVWF  x0F
0541E:  MOVLB  0
05420:  CALL   03A4
....................             read_adc(ADC_START_ONLY);
05424:  MOVLB  F
05426:  BSF    x5B.0
05428:  NOP   
....................             state = 5;
0542A:  MOVLW  05
0542C:  MOVLB  1
0542E:  MOVWF  xE6
....................          break;
05430:  BRA    55B0
....................          
....................          case 5:     // vMon3V3A
....................             monitorVals.v3V3A = read_adc(ADC_READ_ONLY) * monCal.v3V3A[1] + monCal.v3V3A[0];
05432:  MOVLB  F
05434:  BTFSC  x5B.0
05436:  BRA    5434
05438:  MOVFF  F5F,02
0543C:  MOVFF  F5E,01
05440:  MOVFF  02,6FC
05444:  MOVFF  01,6FB
05448:  MOVFF  02,75B
0544C:  MOVFF  01,75A
05450:  MOVLB  0
05452:  CALL   2DDA
05456:  MOVFF  03,759
0545A:  MOVFF  02,758
0545E:  MOVFF  01,757
05462:  MOVFF  00,756
05466:  MOVFF  F1,75D
0546A:  MOVFF  F0,75C
0546E:  MOVFF  EF,75B
05472:  MOVFF  EE,75A
05476:  CALL   1138
0547A:  MOVFF  03,6FE
0547E:  MOVFF  02,6FD
05482:  MOVFF  01,6FC
05486:  MOVFF  00,6FB
0548A:  BCF    FD8.1
0548C:  MOVFF  03,75D
05490:  MOVFF  02,75C
05494:  MOVFF  01,75B
05498:  MOVFF  00,75A
0549C:  MOVFF  ED,761
054A0:  MOVFF  EC,760
054A4:  MOVFF  EB,75F
054A8:  MOVFF  EA,75E
054AC:  CALL   0DFE
054B0:  MOVFF  03,112
054B4:  MOVFF  02,111
054B8:  MOVFF  01,110
054BC:  MOVFF  00,10F
....................             set_adc_channel(vMon3V3D);
054C0:  MOVLB  F
054C2:  MOVF   x5A,W
054C4:  ANDLW  3F
054C6:  MOVWF  01
054C8:  MOVLW  1A
054CA:  MOVWF  x5A
054CC:  BTFSS  x5B.7
054CE:  BRA    54DE
054D0:  MOVF   01,W
054D2:  SUBLW  1A
054D4:  BZ    54DE
054D6:  BSF    x5B.0
054D8:  NOP   
054DA:  BTFSC  x5B.0
054DC:  BRA    54DA
....................             delay_ms(10);
054DE:  MOVLW  0A
054E0:  MOVLB  7
054E2:  MOVWF  x0F
054E4:  MOVLB  0
054E6:  CALL   03A4
....................             read_adc(ADC_START_ONLY);
054EA:  MOVLB  F
054EC:  BSF    x5B.0
054EE:  NOP   
....................             state = 6;
054F0:  MOVLW  06
054F2:  MOVLB  1
054F4:  MOVWF  xE6
....................          break;
054F6:  BRA    55B0
....................          
....................          case 6:    // vMon3V3D
....................             monitorVals.v3V3D = read_adc(ADC_READ_ONLY) * monCal.v3V3D[1] + monCal.v3V3D[0];
054F8:  MOVLB  F
054FA:  BTFSC  x5B.0
054FC:  BRA    54FA
054FE:  MOVFF  F5F,02
05502:  MOVFF  F5E,01
05506:  MOVFF  02,6FC
0550A:  MOVFF  01,6FB
0550E:  MOVFF  02,75B
05512:  MOVFF  01,75A
05516:  MOVLB  0
05518:  CALL   2DDA
0551C:  MOVFF  03,759
05520:  MOVFF  02,758
05524:  MOVFF  01,757
05528:  MOVFF  00,756
0552C:  MOVFF  F9,75D
05530:  MOVFF  F8,75C
05534:  MOVFF  F7,75B
05538:  MOVFF  F6,75A
0553C:  CALL   1138
05540:  MOVFF  03,6FE
05544:  MOVFF  02,6FD
05548:  MOVFF  01,6FC
0554C:  MOVFF  00,6FB
05550:  BCF    FD8.1
05552:  MOVFF  03,75D
05556:  MOVFF  02,75C
0555A:  MOVFF  01,75B
0555E:  MOVFF  00,75A
05562:  MOVFF  F5,761
05566:  MOVFF  F4,760
0556A:  MOVFF  F3,75F
0556E:  MOVFF  F2,75E
05572:  CALL   0DFE
05576:  MOVFF  03,116
0557A:  MOVFF  02,115
0557E:  MOVFF  01,114
05582:  MOVFF  00,113
....................             set_adc_channel(vMonN15);
05586:  MOVLB  F
05588:  MOVF   x5A,W
0558A:  ANDLW  3F
0558C:  MOVWF  01
0558E:  MOVLW  06
05590:  MOVWF  x5A
05592:  BTFSS  x5B.7
05594:  BRA    55A4
05596:  MOVF   01,W
05598:  SUBLW  06
0559A:  BZ    55A4
0559C:  BSF    x5B.0
0559E:  NOP   
055A0:  BTFSC  x5B.0
055A2:  BRA    55A0
....................             read_adc(ADC_START_ONLY);
055A4:  BSF    x5B.0
055A6:  NOP   
....................             state = 0;
055A8:  MOVLB  1
055AA:  CLRF   xE6
....................          break;   
055AC:  BRA    55B0
055AE:  MOVLB  1
055B0:  MOVLB  F
....................       }
....................    }
055B2:  MOVLB  0
055B4:  GOTO   AD36 (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* PROCESS ADC SENSOR DATA                                                   */
.................... /*****************************************************************************/
.................... void sensor_process_data(int8 ch){
....................    adcVals[ch].sinLast = adcVals[ch].sinCounts;
*
03DBE:  MOVLB  7
03DC0:  MOVF   x13,W
03DC2:  MULLW  26
03DC4:  MOVF   FF3,W
03DC6:  CLRF   x1D
03DC8:  MOVWF  x1C
03DCA:  MOVLW  10
03DCC:  ADDWF  x1C,W
03DCE:  MOVWF  01
03DD0:  MOVLW  00
03DD2:  ADDWFC x1D,W
03DD4:  MOVWF  03
03DD6:  MOVF   01,W
03DD8:  ADDLW  17
03DDA:  MOVWF  01
03DDC:  MOVLW  01
03DDE:  ADDWFC 03,F
03DE0:  MOVFF  01,71C
03DE4:  MOVFF  03,71D
03DE8:  MOVF   x13,W
03DEA:  MULLW  26
03DEC:  MOVF   FF3,W
03DEE:  CLRF   x1F
03DF0:  MOVWF  x1E
03DF2:  MOVLW  08
03DF4:  ADDWF  x1E,W
03DF6:  MOVWF  01
03DF8:  MOVLW  00
03DFA:  ADDWFC x1F,W
03DFC:  MOVWF  03
03DFE:  MOVF   01,W
03E00:  ADDLW  17
03E02:  MOVWF  FE9
03E04:  MOVLW  01
03E06:  ADDWFC 03,W
03E08:  MOVWF  FEA
03E0A:  MOVFF  FEF,00
03E0E:  MOVFF  FEC,01
03E12:  MOVFF  FEC,02
03E16:  MOVFF  FEC,03
03E1A:  MOVFF  71D,FEA
03E1E:  MOVFF  71C,FE9
03E22:  MOVFF  00,FEF
03E26:  MOVFF  01,FEC
03E2A:  MOVFF  02,FEC
03E2E:  MOVFF  03,FEC
....................    adcVals[ch].cosLast = adcVals[ch].cosCounts;
03E32:  MOVF   x13,W
03E34:  MULLW  26
03E36:  MOVF   FF3,W
03E38:  CLRF   x1D
03E3A:  MOVWF  x1C
03E3C:  MOVLW  14
03E3E:  ADDWF  x1C,W
03E40:  MOVWF  01
03E42:  MOVLW  00
03E44:  ADDWFC x1D,W
03E46:  MOVWF  03
03E48:  MOVF   01,W
03E4A:  ADDLW  17
03E4C:  MOVWF  01
03E4E:  MOVLW  01
03E50:  ADDWFC 03,F
03E52:  MOVFF  01,71C
03E56:  MOVFF  03,71D
03E5A:  MOVF   x13,W
03E5C:  MULLW  26
03E5E:  MOVF   FF3,W
03E60:  CLRF   x1F
03E62:  MOVWF  x1E
03E64:  MOVLW  0C
03E66:  ADDWF  x1E,W
03E68:  MOVWF  01
03E6A:  MOVLW  00
03E6C:  ADDWFC x1F,W
03E6E:  MOVWF  03
03E70:  MOVF   01,W
03E72:  ADDLW  17
03E74:  MOVWF  FE9
03E76:  MOVLW  01
03E78:  ADDWFC 03,W
03E7A:  MOVWF  FEA
03E7C:  MOVFF  FEF,00
03E80:  MOVFF  FEC,01
03E84:  MOVFF  FEC,02
03E88:  MOVFF  FEC,03
03E8C:  MOVFF  71D,FEA
03E90:  MOVFF  71C,FE9
03E94:  MOVFF  00,FEF
03E98:  MOVFF  01,FEC
03E9C:  MOVFF  02,FEC
03EA0:  MOVFF  03,FEC
....................    
....................    adcVals[ch].sinRaw = (float)smData[ch].avgSin;
03EA4:  MOVF   x13,W
03EA6:  MULLW  26
03EA8:  MOVF   FF3,W
03EAA:  CLRF   x1D
03EAC:  MOVWF  x1C
03EAE:  MOVLW  17
03EB0:  ADDWF  x1C,W
03EB2:  MOVWF  01
03EB4:  MOVLW  01
03EB6:  ADDWFC x1D,W
03EB8:  MOVWF  03
03EBA:  MOVFF  01,71E
03EBE:  MOVWF  x1F
03EC0:  MOVF   x13,W
03EC2:  MULLW  09
03EC4:  MOVF   FF3,W
03EC6:  CLRF   x21
03EC8:  MOVWF  x20
03ECA:  MOVLW  01
03ECC:  ADDWF  x20,W
03ECE:  MOVWF  01
03ED0:  MOVLW  00
03ED2:  ADDWFC x21,W
03ED4:  MOVWF  03
03ED6:  MOVF   01,W
03ED8:  ADDLW  D4
03EDA:  MOVWF  FE9
03EDC:  MOVLW  01
03EDE:  ADDWFC 03,W
03EE0:  MOVWF  FEA
03EE2:  MOVFF  FEF,720
03EE6:  MOVFF  FEC,01
03EEA:  MOVFF  FEC,02
03EEE:  MOVFF  FEC,03
03EF2:  MOVFF  03,723
03EF6:  MOVFF  02,722
03EFA:  MOVFF  01,721
03EFE:  MOVLB  0
03F00:  CALL   23F6
03F04:  MOVFF  71F,FEA
03F08:  MOVFF  71E,FE9
03F0C:  MOVFF  00,FEF
03F10:  MOVFF  01,FEC
03F14:  MOVFF  02,FEC
03F18:  MOVFF  03,FEC
....................    adcVals[ch].cosRaw = (float)smData[ch].avgCos;
03F1C:  MOVLB  7
03F1E:  MOVF   x13,W
03F20:  MULLW  26
03F22:  MOVF   FF3,W
03F24:  CLRF   x1D
03F26:  MOVWF  x1C
03F28:  MOVLW  04
03F2A:  ADDWF  x1C,W
03F2C:  MOVWF  01
03F2E:  MOVLW  00
03F30:  ADDWFC x1D,W
03F32:  MOVWF  03
03F34:  MOVF   01,W
03F36:  ADDLW  17
03F38:  MOVWF  01
03F3A:  MOVLW  01
03F3C:  ADDWFC 03,F
03F3E:  MOVFF  01,71C
03F42:  MOVFF  03,71D
03F46:  MOVF   x13,W
03F48:  MULLW  09
03F4A:  MOVF   FF3,W
03F4C:  CLRF   x1F
03F4E:  MOVWF  x1E
03F50:  MOVLW  05
03F52:  ADDWF  x1E,W
03F54:  MOVWF  01
03F56:  MOVLW  00
03F58:  ADDWFC x1F,W
03F5A:  MOVWF  03
03F5C:  MOVF   01,W
03F5E:  ADDLW  D4
03F60:  MOVWF  FE9
03F62:  MOVLW  01
03F64:  ADDWFC 03,W
03F66:  MOVWF  FEA
03F68:  MOVFF  FEF,720
03F6C:  MOVFF  FEC,01
03F70:  MOVFF  FEC,02
03F74:  MOVFF  FEC,03
03F78:  MOVFF  03,723
03F7C:  MOVFF  02,722
03F80:  MOVFF  01,721
03F84:  MOVLB  0
03F86:  CALL   23F6
03F8A:  MOVFF  71D,FEA
03F8E:  MOVFF  71C,FE9
03F92:  MOVFF  00,FEF
03F96:  MOVFF  01,FEC
03F9A:  MOVFF  02,FEC
03F9E:  MOVFF  03,FEC
....................    
....................    adcVals[ch].sinCounts = adcVals[ch].sinRaw * adcCal[ch].sinGain + adcCal[ch].sinOS;
03FA2:  MOVLB  7
03FA4:  MOVF   x13,W
03FA6:  MULLW  26
03FA8:  MOVF   FF3,W
03FAA:  CLRF   x1D
03FAC:  MOVWF  x1C
03FAE:  MOVLW  08
03FB0:  ADDWF  x1C,W
03FB2:  MOVWF  01
03FB4:  MOVLW  00
03FB6:  ADDWFC x1D,W
03FB8:  MOVWF  03
03FBA:  MOVF   01,W
03FBC:  ADDLW  17
03FBE:  MOVWF  01
03FC0:  MOVLW  01
03FC2:  ADDWFC 03,F
03FC4:  MOVFF  01,71C
03FC8:  MOVFF  03,71D
03FCC:  MOVF   x13,W
03FCE:  MULLW  26
03FD0:  MOVF   FF3,W
03FD2:  CLRF   x1F
03FD4:  MOVWF  x1E
03FD6:  MOVLW  17
03FD8:  ADDWF  x1E,W
03FDA:  MOVWF  FE9
03FDC:  MOVLW  01
03FDE:  ADDWFC x1F,W
03FE0:  MOVWF  FEA
03FE2:  MOVFF  FEF,756
03FE6:  MOVFF  FEC,757
03FEA:  MOVFF  FEC,758
03FEE:  MOVFF  FEC,759
03FF2:  MOVF   x13,W
03FF4:  MULLW  10
03FF6:  MOVF   FF3,W
03FF8:  CLRF   x25
03FFA:  MOVWF  x24
03FFC:  MOVLW  08
03FFE:  ADDWF  x24,W
04000:  MOVWF  01
04002:  MOVLW  00
04004:  ADDWFC x25,W
04006:  MOVWF  03
04008:  MOVF   01,W
0400A:  ADDLW  72
0400C:  MOVWF  FE9
0400E:  MOVLW  00
04010:  ADDWFC 03,W
04012:  MOVWF  FEA
04014:  MOVFF  FEF,75A
04018:  MOVFF  FEC,01
0401C:  MOVFF  FEC,02
04020:  MOVFF  FEC,03
04024:  MOVFF  03,75D
04028:  MOVFF  02,75C
0402C:  MOVFF  01,75B
04030:  MOVLB  0
04032:  CALL   1138
04036:  MOVFF  03,75D
0403A:  MOVFF  02,75C
0403E:  MOVFF  01,75B
04042:  MOVFF  00,75A
04046:  MOVLB  7
04048:  MOVF   x13,W
0404A:  MULLW  10
0404C:  MOVF   FF3,W
0404E:  CLRF   x25
04050:  MOVWF  x24
04052:  MOVLW  72
04054:  ADDWF  x24,W
04056:  MOVWF  FE9
04058:  MOVLW  00
0405A:  ADDWFC x25,W
0405C:  MOVWF  FEA
0405E:  MOVFF  FEF,75E
04062:  MOVFF  FEC,01
04066:  MOVFF  FEC,02
0406A:  MOVFF  FEC,03
0406E:  BCF    FD8.1
04070:  MOVFF  03,761
04074:  MOVFF  02,760
04078:  MOVFF  01,75F
0407C:  MOVLB  0
0407E:  CALL   0DFE
04082:  MOVFF  71D,FEA
04086:  MOVFF  71C,FE9
0408A:  MOVFF  00,FEF
0408E:  MOVFF  01,FEC
04092:  MOVFF  02,FEC
04096:  MOVFF  03,FEC
....................    adcVals[ch].cosCounts = adcVals[ch].cosRaw * adcCal[ch].cosGain + adcCal[ch].cosOS;
0409A:  MOVLB  7
0409C:  MOVF   x13,W
0409E:  MULLW  26
040A0:  MOVF   FF3,W
040A2:  CLRF   x1D
040A4:  MOVWF  x1C
040A6:  MOVLW  0C
040A8:  ADDWF  x1C,W
040AA:  MOVWF  01
040AC:  MOVLW  00
040AE:  ADDWFC x1D,W
040B0:  MOVWF  03
040B2:  MOVF   01,W
040B4:  ADDLW  17
040B6:  MOVWF  01
040B8:  MOVLW  01
040BA:  ADDWFC 03,F
040BC:  MOVFF  01,71C
040C0:  MOVFF  03,71D
040C4:  MOVF   x13,W
040C6:  MULLW  26
040C8:  MOVF   FF3,W
040CA:  CLRF   x1F
040CC:  MOVWF  x1E
040CE:  MOVLW  04
040D0:  ADDWF  x1E,W
040D2:  MOVWF  01
040D4:  MOVLW  00
040D6:  ADDWFC x1F,W
040D8:  MOVWF  03
040DA:  MOVF   01,W
040DC:  ADDLW  17
040DE:  MOVWF  FE9
040E0:  MOVLW  01
040E2:  ADDWFC 03,W
040E4:  MOVWF  FEA
040E6:  MOVFF  FEF,756
040EA:  MOVFF  FEC,757
040EE:  MOVFF  FEC,758
040F2:  MOVFF  FEC,759
040F6:  MOVF   x13,W
040F8:  MULLW  10
040FA:  MOVF   FF3,W
040FC:  CLRF   x23
040FE:  MOVWF  x22
04100:  MOVLW  0C
04102:  ADDWF  x22,W
04104:  MOVWF  01
04106:  MOVLW  00
04108:  ADDWFC x23,W
0410A:  MOVWF  03
0410C:  MOVF   01,W
0410E:  ADDLW  72
04110:  MOVWF  FE9
04112:  MOVLW  00
04114:  ADDWFC 03,W
04116:  MOVWF  FEA
04118:  MOVFF  FEF,75A
0411C:  MOVFF  FEC,01
04120:  MOVFF  FEC,02
04124:  MOVFF  FEC,03
04128:  MOVFF  03,75D
0412C:  MOVFF  02,75C
04130:  MOVFF  01,75B
04134:  MOVLB  0
04136:  CALL   1138
0413A:  MOVFF  03,75D
0413E:  MOVFF  02,75C
04142:  MOVFF  01,75B
04146:  MOVFF  00,75A
0414A:  MOVLB  7
0414C:  MOVF   x13,W
0414E:  MULLW  10
04150:  MOVF   FF3,W
04152:  CLRF   x23
04154:  MOVWF  x22
04156:  MOVLW  04
04158:  ADDWF  x22,W
0415A:  MOVWF  01
0415C:  MOVLW  00
0415E:  ADDWFC x23,W
04160:  MOVWF  03
04162:  MOVF   01,W
04164:  ADDLW  72
04166:  MOVWF  FE9
04168:  MOVLW  00
0416A:  ADDWFC 03,W
0416C:  MOVWF  FEA
0416E:  MOVFF  FEF,75E
04172:  MOVFF  FEC,01
04176:  MOVFF  FEC,02
0417A:  MOVFF  FEC,03
0417E:  BCF    FD8.1
04180:  MOVFF  03,761
04184:  MOVFF  02,760
04188:  MOVFF  01,75F
0418C:  MOVLB  0
0418E:  CALL   0DFE
04192:  MOVFF  71D,FEA
04196:  MOVFF  71C,FE9
0419A:  MOVFF  00,FEF
0419E:  MOVFF  01,FEC
041A2:  MOVFF  02,FEC
041A6:  MOVFF  03,FEC
....................    float pTmp = 0;
....................    float polePitch = magPP;
041AA:  MOVLB  7
041AC:  CLRF   x17
041AE:  CLRF   x16
041B0:  CLRF   x15
041B2:  CLRF   x14
041B4:  CLRF   x1B
041B6:  CLRF   x1A
041B8:  CLRF   x19
041BA:  MOVLW  7F
041BC:  MOVWF  x18
....................    
....................    if (adcVals[ch].cosCounts < 0){
041BE:  MOVF   x13,W
041C0:  MULLW  26
041C2:  MOVF   FF3,W
041C4:  CLRF   x1D
041C6:  MOVWF  x1C
041C8:  MOVLW  0C
041CA:  ADDWF  x1C,W
041CC:  MOVWF  01
041CE:  MOVLW  00
041D0:  ADDWFC x1D,W
041D2:  MOVWF  03
041D4:  MOVF   01,W
041D6:  ADDLW  17
041D8:  MOVWF  FE9
041DA:  MOVLW  01
041DC:  ADDWFC 03,W
041DE:  MOVWF  FEA
041E0:  MOVFF  FEF,756
041E4:  MOVFF  FEC,757
041E8:  MOVFF  FEC,758
041EC:  MOVFF  FEC,759
041F0:  CLRF   x5D
041F2:  CLRF   x5C
041F4:  CLRF   x5B
041F6:  CLRF   x5A
041F8:  MOVLB  0
041FA:  CALL   0D84
041FE:  BTFSS  FD8.0
04200:  BRA    436A
....................       if ((adcVals[ch].sinCounts > 0) && (adcVals[ch].sinLast < 0)){
04202:  MOVLB  7
04204:  MOVF   x13,W
04206:  MULLW  26
04208:  MOVF   FF3,W
0420A:  CLRF   x1D
0420C:  MOVWF  x1C
0420E:  MOVLW  08
04210:  ADDWF  x1C,W
04212:  MOVWF  01
04214:  MOVLW  00
04216:  ADDWFC x1D,W
04218:  MOVWF  03
0421A:  MOVF   01,W
0421C:  ADDLW  17
0421E:  MOVWF  FE9
04220:  MOVLW  01
04222:  ADDWFC 03,W
04224:  MOVWF  FEA
04226:  MOVFF  FEF,75A
0422A:  MOVFF  FEC,71D
0422E:  MOVFF  FEC,75C
04232:  MOVFF  FEC,75D
04236:  CLRF   x59
04238:  CLRF   x58
0423A:  CLRF   x57
0423C:  CLRF   x56
0423E:  MOVFF  71D,75B
04242:  MOVLB  0
04244:  CALL   0D84
04248:  BNC   42B6
0424A:  MOVLB  7
0424C:  MOVF   x13,W
0424E:  MULLW  26
04250:  MOVF   FF3,W
04252:  CLRF   x1D
04254:  MOVWF  x1C
04256:  MOVLW  10
04258:  ADDWF  x1C,W
0425A:  MOVWF  01
0425C:  MOVLW  00
0425E:  ADDWFC x1D,W
04260:  MOVWF  03
04262:  MOVF   01,W
04264:  ADDLW  17
04266:  MOVWF  FE9
04268:  MOVLW  01
0426A:  ADDWFC 03,W
0426C:  MOVWF  FEA
0426E:  MOVFF  FEF,756
04272:  MOVFF  FEC,757
04276:  MOVFF  FEC,758
0427A:  MOVFF  FEC,759
0427E:  CLRF   x5D
04280:  CLRF   x5C
04282:  CLRF   x5B
04284:  CLRF   x5A
04286:  MOVLB  0
04288:  CALL   0D84
0428C:  BNC   42B6
....................          adcVals[ch].npoles--;
0428E:  MOVLB  7
04290:  MOVF   x13,W
04292:  MULLW  26
04294:  MOVF   FF3,W
04296:  CLRF   x1D
04298:  MOVWF  x1C
0429A:  MOVLW  1C
0429C:  ADDWF  x1C,W
0429E:  MOVWF  01
042A0:  MOVLW  00
042A2:  ADDWFC x1D,W
042A4:  MOVWF  03
042A6:  MOVF   01,W
042A8:  ADDLW  17
042AA:  MOVWF  FE9
042AC:  MOVLW  01
042AE:  ADDWFC 03,W
042B0:  MOVWF  FEA
042B2:  DECF   FEF,F
....................       }
042B4:  BRA    4368
....................       else if ((adcVals[ch].sinCounts < 0) && (adcVals[ch].sinLast > 0)){
042B6:  MOVLB  7
042B8:  MOVF   x13,W
042BA:  MULLW  26
042BC:  MOVF   FF3,W
042BE:  CLRF   x1D
042C0:  MOVWF  x1C
042C2:  MOVLW  08
042C4:  ADDWF  x1C,W
042C6:  MOVWF  01
042C8:  MOVLW  00
042CA:  ADDWFC x1D,W
042CC:  MOVWF  03
042CE:  MOVF   01,W
042D0:  ADDLW  17
042D2:  MOVWF  FE9
042D4:  MOVLW  01
042D6:  ADDWFC 03,W
042D8:  MOVWF  FEA
042DA:  MOVFF  FEF,756
042DE:  MOVFF  FEC,71D
042E2:  MOVFF  FEC,758
042E6:  MOVFF  FEC,759
042EA:  MOVFF  71D,757
042EE:  CLRF   x5D
042F0:  CLRF   x5C
042F2:  CLRF   x5B
042F4:  CLRF   x5A
042F6:  MOVLB  0
042F8:  CALL   0D84
042FC:  BNC   436A
042FE:  MOVLB  7
04300:  MOVF   x13,W
04302:  MULLW  26
04304:  MOVF   FF3,W
04306:  CLRF   x1D
04308:  MOVWF  x1C
0430A:  MOVLW  10
0430C:  ADDWF  x1C,W
0430E:  MOVWF  01
04310:  MOVLW  00
04312:  ADDWFC x1D,W
04314:  MOVWF  03
04316:  MOVF   01,W
04318:  ADDLW  17
0431A:  MOVWF  FE9
0431C:  MOVLW  01
0431E:  ADDWFC 03,W
04320:  MOVWF  FEA
04322:  MOVFF  FEF,75A
04326:  MOVFF  FEC,75B
0432A:  MOVFF  FEC,75C
0432E:  MOVFF  FEC,75D
04332:  CLRF   x59
04334:  CLRF   x58
04336:  CLRF   x57
04338:  CLRF   x56
0433A:  MOVLB  0
0433C:  CALL   0D84
04340:  BNC   436A
....................          adcVals[ch].npoles++;
04342:  MOVLB  7
04344:  MOVF   x13,W
04346:  MULLW  26
04348:  MOVF   FF3,W
0434A:  CLRF   x1D
0434C:  MOVWF  x1C
0434E:  MOVLW  1C
04350:  ADDWF  x1C,W
04352:  MOVWF  01
04354:  MOVLW  00
04356:  ADDWFC x1D,W
04358:  MOVWF  03
0435A:  MOVF   01,W
0435C:  ADDLW  17
0435E:  MOVWF  FE9
04360:  MOVLW  01
04362:  ADDWFC 03,W
04364:  MOVWF  FEA
04366:  INCF   FEF,F
04368:  MOVLB  0
....................       }
....................    }
....................    
....................    adcVals[ch].p0 = polePitch * ( 1000 / (2*PI) ) * atan2( (float)adcVals[ch].sinCounts, (float)adcVals[ch].cosCounts );
0436A:  MOVLB  7
0436C:  MOVF   x13,W
0436E:  MULLW  26
04370:  MOVF   FF3,W
04372:  CLRF   x1D
04374:  MOVWF  x1C
04376:  MOVLW  18
04378:  ADDWF  x1C,W
0437A:  MOVWF  01
0437C:  MOVLW  00
0437E:  ADDWFC x1D,W
04380:  MOVWF  03
04382:  MOVF   01,W
04384:  ADDLW  17
04386:  MOVWF  01
04388:  MOVLW  01
0438A:  ADDWFC 03,F
0438C:  MOVFF  01,71C
04390:  MOVFF  03,71D
04394:  MOVFF  71B,759
04398:  MOVFF  71A,758
0439C:  MOVFF  719,757
043A0:  MOVFF  718,756
043A4:  MOVLW  AA
043A6:  MOVWF  x5D
043A8:  MOVLW  27
043AA:  MOVWF  x5C
043AC:  MOVLW  1F
043AE:  MOVWF  x5B
043B0:  MOVLW  86
043B2:  MOVWF  x5A
043B4:  MOVLB  0
043B6:  CALL   1138
043BA:  MOVFF  03,721
043BE:  MOVFF  02,720
043C2:  MOVFF  01,71F
043C6:  MOVFF  00,71E
043CA:  MOVLB  7
043CC:  MOVF   x13,W
043CE:  MULLW  26
043D0:  MOVF   FF3,W
043D2:  CLRF   x23
043D4:  MOVWF  x22
043D6:  MOVLW  08
043D8:  ADDWF  x22,W
043DA:  MOVWF  01
043DC:  MOVLW  00
043DE:  ADDWFC x23,W
043E0:  MOVWF  03
043E2:  MOVF   01,W
043E4:  ADDLW  17
043E6:  MOVWF  FE9
043E8:  MOVLW  01
043EA:  ADDWFC 03,W
043EC:  MOVWF  FEA
043EE:  MOVFF  FEF,722
043F2:  MOVFF  FEC,723
043F6:  MOVFF  FEC,724
043FA:  MOVFF  FEC,725
043FE:  MOVF   x13,W
04400:  MULLW  26
04402:  MOVF   FF3,W
04404:  CLRF   x27
04406:  MOVWF  x26
04408:  MOVLW  0C
0440A:  ADDWF  x26,W
0440C:  MOVWF  01
0440E:  MOVLW  00
04410:  ADDWFC x27,W
04412:  MOVWF  03
04414:  MOVF   01,W
04416:  ADDLW  17
04418:  MOVWF  FE9
0441A:  MOVLW  01
0441C:  ADDWFC 03,W
0441E:  MOVWF  FEA
04420:  MOVFF  FEF,00
04424:  MOVFF  FEC,01
04428:  MOVFF  FEC,02
0442C:  MOVFF  FEC,03
04430:  MOVFF  03,729
04434:  MOVFF  02,728
04438:  MOVFF  01,727
0443C:  MOVFF  00,726
04440:  MOVFF  725,72D
04444:  MOVFF  724,72C
04448:  MOVFF  723,72B
0444C:  MOVFF  722,72A
04450:  MOVFF  03,731
04454:  MOVFF  02,730
04458:  MOVFF  01,72F
0445C:  MOVFF  00,72E
04460:  MOVLB  0
04462:  GOTO   2ADC
04466:  MOVFF  721,759
0446A:  MOVFF  720,758
0446E:  MOVFF  71F,757
04472:  MOVFF  71E,756
04476:  MOVFF  03,75D
0447A:  MOVFF  02,75C
0447E:  MOVFF  01,75B
04482:  MOVFF  00,75A
04486:  CALL   1138
0448A:  MOVFF  71D,FEA
0448E:  MOVFF  71C,FE9
04492:  MOVFF  00,FEF
04496:  MOVFF  01,FEC
0449A:  MOVFF  02,FEC
0449E:  MOVFF  03,FEC
....................    pTmp = adcVals[ch].p0 + ( 1000 * polePitch * (float)adcVals[ch].npoles );
044A2:  MOVLB  7
044A4:  MOVF   x13,W
044A6:  MULLW  26
044A8:  MOVF   FF3,W
044AA:  CLRF   x1D
044AC:  MOVWF  x1C
044AE:  MOVLW  18
044B0:  ADDWF  x1C,W
044B2:  MOVWF  01
044B4:  MOVLW  00
044B6:  ADDWFC x1D,W
044B8:  MOVWF  03
044BA:  MOVF   01,W
044BC:  ADDLW  17
044BE:  MOVWF  FE9
044C0:  MOVLW  01
044C2:  ADDWFC 03,W
044C4:  MOVWF  FEA
044C6:  MOVFF  FEF,71C
044CA:  MOVFF  FEC,71D
044CE:  MOVFF  FEC,71E
044D2:  MOVFF  FEC,71F
044D6:  CLRF   x59
044D8:  CLRF   x58
044DA:  MOVLW  7A
044DC:  MOVWF  x57
044DE:  MOVLW  88
044E0:  MOVWF  x56
044E2:  MOVFF  71B,75D
044E6:  MOVFF  71A,75C
044EA:  MOVFF  719,75B
044EE:  MOVFF  718,75A
044F2:  MOVLB  0
044F4:  CALL   1138
044F8:  MOVFF  03,723
044FC:  MOVFF  02,722
04500:  MOVFF  01,721
04504:  MOVFF  00,720
04508:  MOVLB  7
0450A:  MOVF   x13,W
0450C:  MULLW  26
0450E:  MOVF   FF3,W
04510:  CLRF   x25
04512:  MOVWF  x24
04514:  MOVLW  1C
04516:  ADDWF  x24,W
04518:  MOVWF  01
0451A:  MOVLW  00
0451C:  ADDWFC x25,W
0451E:  MOVWF  03
04520:  MOVF   01,W
04522:  ADDLW  17
04524:  MOVWF  FE9
04526:  MOVLW  01
04528:  ADDWFC 03,W
0452A:  MOVWF  FEA
0452C:  MOVF   FEF,W
0452E:  CLRF   x4D
04530:  MOVWF  x4C
04532:  BTFSC  x4C.7
04534:  DECF   x4D,F
04536:  MOVLB  0
04538:  CALL   2D8A
0453C:  MOVFF  723,759
04540:  MOVFF  722,758
04544:  MOVFF  721,757
04548:  MOVFF  720,756
0454C:  MOVFF  03,75D
04550:  MOVFF  02,75C
04554:  MOVFF  01,75B
04558:  MOVFF  00,75A
0455C:  CALL   1138
04560:  MOVFF  FEA,721
04564:  MOVFF  FE9,720
04568:  BCF    FD8.1
0456A:  MOVFF  71F,75D
0456E:  MOVFF  71E,75C
04572:  MOVFF  71D,75B
04576:  MOVFF  71C,75A
0457A:  MOVFF  03,761
0457E:  MOVFF  02,760
04582:  MOVFF  01,75F
04586:  MOVFF  00,75E
0458A:  CALL   0DFE
0458E:  MOVFF  721,FEA
04592:  MOVFF  720,FE9
04596:  MOVFF  03,717
0459A:  MOVFF  02,716
0459E:  MOVFF  01,715
045A2:  MOVFF  00,714
....................    
....................    adcVals[ch].pReal = (pow(pTmp*sc[ch].c5,5) + pow(pTmp*sc[ch].c4,4) + pow(pTmp*sc[ch].c3,3) + pow(pTmp*sc[ch].c2,2) + pTmp*sc[ch].c1 + sc[ch].c0);
045A6:  MOVLB  7
045A8:  MOVF   x13,W
045AA:  MULLW  26
045AC:  MOVF   FF3,W
045AE:  CLRF   x1D
045B0:  MOVWF  x1C
045B2:  MOVLW  1D
045B4:  ADDWF  x1C,W
045B6:  MOVWF  01
045B8:  MOVLW  00
045BA:  ADDWFC x1D,W
045BC:  MOVWF  03
045BE:  MOVF   01,W
045C0:  ADDLW  17
045C2:  MOVWF  01
045C4:  MOVLW  01
045C6:  ADDWFC 03,F
045C8:  MOVFF  01,71C
045CC:  MOVFF  03,71D
045D0:  MOVF   x13,W
045D2:  MULLW  18
045D4:  MOVF   FF3,W
045D6:  CLRF   x1F
045D8:  MOVWF  x1E
045DA:  MOVLW  14
045DC:  ADDWF  x1E,W
045DE:  MOVWF  01
045E0:  MOVLW  00
045E2:  ADDWFC x1F,W
045E4:  MOVWF  03
045E6:  MOVF   01,W
045E8:  ADDLW  92
045EA:  MOVWF  FE9
045EC:  MOVLW  00
045EE:  ADDWFC 03,W
045F0:  MOVWF  FEA
045F2:  MOVFF  FEF,75A
045F6:  MOVFF  FEC,01
045FA:  MOVFF  FEC,02
045FE:  MOVFF  FEC,03
04602:  MOVFF  717,759
04606:  MOVFF  716,758
0460A:  MOVFF  715,757
0460E:  MOVFF  714,756
04612:  MOVFF  03,75D
04616:  MOVFF  02,75C
0461A:  MOVFF  01,75B
0461E:  MOVLB  0
04620:  CALL   1138
04624:  MOVFF  03,721
04628:  MOVFF  02,720
0462C:  MOVFF  01,71F
04630:  MOVFF  00,71E
04634:  MOVFF  03,72D
04638:  MOVFF  02,72C
0463C:  MOVFF  01,72B
04640:  MOVFF  00,72A
04644:  MOVLB  7
04646:  CLRF   x31
04648:  CLRF   x30
0464A:  MOVLW  20
0464C:  MOVWF  x2F
0464E:  MOVLW  81
04650:  MOVWF  x2E
04652:  MOVLB  0
04654:  CALL   3AC0
04658:  MOVFF  03,721
0465C:  MOVFF  02,720
04660:  MOVFF  01,71F
04664:  MOVFF  00,71E
04668:  MOVLB  7
0466A:  MOVF   x13,W
0466C:  MULLW  18
0466E:  MOVF   FF3,W
04670:  CLRF   x23
04672:  MOVWF  x22
04674:  MOVLW  10
04676:  ADDWF  x22,W
04678:  MOVWF  01
0467A:  MOVLW  00
0467C:  ADDWFC x23,W
0467E:  MOVWF  03
04680:  MOVF   01,W
04682:  ADDLW  92
04684:  MOVWF  FE9
04686:  MOVLW  00
04688:  ADDWFC 03,W
0468A:  MOVWF  FEA
0468C:  MOVFF  FEF,75A
04690:  MOVFF  FEC,01
04694:  MOVFF  FEC,02
04698:  MOVFF  FEC,03
0469C:  MOVFF  717,759
046A0:  MOVFF  716,758
046A4:  MOVFF  715,757
046A8:  MOVFF  714,756
046AC:  MOVFF  03,75D
046B0:  MOVFF  02,75C
046B4:  MOVFF  01,75B
046B8:  MOVLB  0
046BA:  CALL   1138
046BE:  MOVFF  03,725
046C2:  MOVFF  02,724
046C6:  MOVFF  01,723
046CA:  MOVFF  00,722
046CE:  MOVFF  03,72D
046D2:  MOVFF  02,72C
046D6:  MOVFF  01,72B
046DA:  MOVFF  00,72A
046DE:  MOVLB  7
046E0:  CLRF   x31
046E2:  CLRF   x30
046E4:  CLRF   x2F
046E6:  MOVLW  81
046E8:  MOVWF  x2E
046EA:  MOVLB  0
046EC:  CALL   3AC0
046F0:  MOVFF  FEA,723
046F4:  MOVFF  FE9,722
046F8:  BCF    FD8.1
046FA:  MOVFF  721,75D
046FE:  MOVFF  720,75C
04702:  MOVFF  71F,75B
04706:  MOVFF  71E,75A
0470A:  MOVFF  03,761
0470E:  MOVFF  02,760
04712:  MOVFF  01,75F
04716:  MOVFF  00,75E
0471A:  CALL   0DFE
0471E:  MOVFF  723,FEA
04722:  MOVFF  722,FE9
04726:  MOVFF  03,721
0472A:  MOVFF  02,720
0472E:  MOVFF  01,71F
04732:  MOVFF  00,71E
04736:  MOVLB  7
04738:  MOVF   x13,W
0473A:  MULLW  18
0473C:  MOVF   FF3,W
0473E:  CLRF   x25
04740:  MOVWF  x24
04742:  MOVLW  0C
04744:  ADDWF  x24,W
04746:  MOVWF  01
04748:  MOVLW  00
0474A:  ADDWFC x25,W
0474C:  MOVWF  03
0474E:  MOVF   01,W
04750:  ADDLW  92
04752:  MOVWF  FE9
04754:  MOVLW  00
04756:  ADDWFC 03,W
04758:  MOVWF  FEA
0475A:  MOVFF  FEF,75A
0475E:  MOVFF  FEC,01
04762:  MOVFF  FEC,02
04766:  MOVFF  FEC,03
0476A:  MOVFF  717,759
0476E:  MOVFF  716,758
04772:  MOVFF  715,757
04776:  MOVFF  714,756
0477A:  MOVFF  03,75D
0477E:  MOVFF  02,75C
04782:  MOVFF  01,75B
04786:  MOVLB  0
04788:  CALL   1138
0478C:  MOVFF  03,727
04790:  MOVFF  02,726
04794:  MOVFF  01,725
04798:  MOVFF  00,724
0479C:  MOVFF  03,72D
047A0:  MOVFF  02,72C
047A4:  MOVFF  01,72B
047A8:  MOVFF  00,72A
047AC:  MOVLB  7
047AE:  CLRF   x31
047B0:  CLRF   x30
047B2:  MOVLW  40
047B4:  MOVWF  x2F
047B6:  MOVLW  80
047B8:  MOVWF  x2E
047BA:  MOVLB  0
047BC:  CALL   3AC0
047C0:  MOVFF  FEA,725
047C4:  MOVFF  FE9,724
047C8:  BCF    FD8.1
047CA:  MOVFF  721,75D
047CE:  MOVFF  720,75C
047D2:  MOVFF  71F,75B
047D6:  MOVFF  71E,75A
047DA:  MOVFF  03,761
047DE:  MOVFF  02,760
047E2:  MOVFF  01,75F
047E6:  MOVFF  00,75E
047EA:  CALL   0DFE
047EE:  MOVFF  725,FEA
047F2:  MOVFF  724,FE9
047F6:  MOVFF  03,721
047FA:  MOVFF  02,720
047FE:  MOVFF  01,71F
04802:  MOVFF  00,71E
04806:  MOVLB  7
04808:  MOVF   x13,W
0480A:  MULLW  18
0480C:  MOVF   FF3,W
0480E:  CLRF   x27
04810:  MOVWF  x26
04812:  MOVLW  08
04814:  ADDWF  x26,W
04816:  MOVWF  01
04818:  MOVLW  00
0481A:  ADDWFC x27,W
0481C:  MOVWF  03
0481E:  MOVF   01,W
04820:  ADDLW  92
04822:  MOVWF  FE9
04824:  MOVLW  00
04826:  ADDWFC 03,W
04828:  MOVWF  FEA
0482A:  MOVFF  FEF,75A
0482E:  MOVFF  FEC,01
04832:  MOVFF  FEC,02
04836:  MOVFF  FEC,03
0483A:  MOVFF  717,759
0483E:  MOVFF  716,758
04842:  MOVFF  715,757
04846:  MOVFF  714,756
0484A:  MOVFF  03,75D
0484E:  MOVFF  02,75C
04852:  MOVFF  01,75B
04856:  MOVLB  0
04858:  CALL   1138
0485C:  MOVFF  03,729
04860:  MOVFF  02,728
04864:  MOVFF  01,727
04868:  MOVFF  00,726
0486C:  MOVFF  03,72D
04870:  MOVFF  02,72C
04874:  MOVFF  01,72B
04878:  MOVFF  00,72A
0487C:  MOVLB  7
0487E:  CLRF   x31
04880:  CLRF   x30
04882:  CLRF   x2F
04884:  MOVLW  80
04886:  MOVWF  x2E
04888:  MOVLB  0
0488A:  CALL   3AC0
0488E:  MOVFF  FEA,727
04892:  MOVFF  FE9,726
04896:  BCF    FD8.1
04898:  MOVFF  721,75D
0489C:  MOVFF  720,75C
048A0:  MOVFF  71F,75B
048A4:  MOVFF  71E,75A
048A8:  MOVFF  03,761
048AC:  MOVFF  02,760
048B0:  MOVFF  01,75F
048B4:  MOVFF  00,75E
048B8:  CALL   0DFE
048BC:  MOVFF  727,FEA
048C0:  MOVFF  726,FE9
048C4:  MOVFF  03,721
048C8:  MOVFF  02,720
048CC:  MOVFF  01,71F
048D0:  MOVFF  00,71E
048D4:  MOVLB  7
048D6:  MOVF   x13,W
048D8:  MULLW  18
048DA:  MOVF   FF3,W
048DC:  CLRF   x29
048DE:  MOVWF  x28
048E0:  MOVLW  04
048E2:  ADDWF  x28,W
048E4:  MOVWF  01
048E6:  MOVLW  00
048E8:  ADDWFC x29,W
048EA:  MOVWF  03
048EC:  MOVF   01,W
048EE:  ADDLW  92
048F0:  MOVWF  FE9
048F2:  MOVLW  00
048F4:  ADDWFC 03,W
048F6:  MOVWF  FEA
048F8:  MOVFF  FEF,75A
048FC:  MOVFF  FEC,01
04900:  MOVFF  FEC,02
04904:  MOVFF  FEC,03
04908:  MOVFF  717,759
0490C:  MOVFF  716,758
04910:  MOVFF  715,757
04914:  MOVFF  714,756
04918:  MOVFF  03,75D
0491C:  MOVFF  02,75C
04920:  MOVFF  01,75B
04924:  MOVLB  0
04926:  CALL   1138
0492A:  MOVFF  FEA,729
0492E:  MOVFF  FE9,728
04932:  BCF    FD8.1
04934:  MOVFF  721,75D
04938:  MOVFF  720,75C
0493C:  MOVFF  71F,75B
04940:  MOVFF  71E,75A
04944:  MOVFF  03,761
04948:  MOVFF  02,760
0494C:  MOVFF  01,75F
04950:  MOVFF  00,75E
04954:  CALL   0DFE
04958:  MOVFF  729,FEA
0495C:  MOVFF  728,FE9
04960:  MOVFF  03,75D
04964:  MOVFF  02,75C
04968:  MOVFF  01,75B
0496C:  MOVFF  00,75A
04970:  MOVLB  7
04972:  MOVF   x13,W
04974:  MULLW  18
04976:  MOVF   FF3,W
04978:  CLRF   x2B
0497A:  MOVWF  x2A
0497C:  MOVLW  92
0497E:  ADDWF  x2A,W
04980:  MOVWF  FE9
04982:  MOVLW  00
04984:  ADDWFC x2B,W
04986:  MOVWF  FEA
04988:  MOVFF  FEF,75E
0498C:  MOVFF  FEC,01
04990:  MOVFF  FEC,02
04994:  MOVFF  FEC,03
04998:  BCF    FD8.1
0499A:  MOVFF  03,761
0499E:  MOVFF  02,760
049A2:  MOVFF  01,75F
049A6:  MOVLB  0
049A8:  CALL   0DFE
049AC:  MOVFF  71D,FEA
049B0:  MOVFF  71C,FE9
049B4:  MOVFF  00,FEF
049B8:  MOVFF  01,FEC
049BC:  MOVFF  02,FEC
049C0:  MOVFF  03,FEC
....................    if (ch == chX) adcVals[ch].pReal *= -1;
049C4:  MOVLB  7
049C6:  MOVF   x13,F
049C8:  BNZ   4A26
049CA:  MOVF   x13,W
049CC:  MULLW  26
049CE:  MOVF   FF3,W
049D0:  CLRF   x1D
049D2:  MOVWF  x1C
049D4:  MOVLW  1D
049D6:  ADDWF  x1C,W
049D8:  MOVWF  01
049DA:  MOVLW  00
049DC:  ADDWFC x1D,W
049DE:  MOVWF  03
049E0:  MOVF   01,W
049E2:  ADDLW  17
049E4:  MOVWF  FE9
049E6:  MOVLW  01
049E8:  ADDWFC 03,W
049EA:  MOVWF  FEA
049EC:  MOVFF  FEF,756
049F0:  MOVFF  FEC,757
049F4:  MOVFF  FEC,758
049F8:  MOVFF  FEC,759
049FC:  MOVF   FED,F
049FE:  MOVF   FED,F
04A00:  MOVF   FED,F
04A02:  CLRF   x5D
04A04:  CLRF   x5C
04A06:  MOVLW  80
04A08:  MOVWF  x5B
04A0A:  MOVLW  7F
04A0C:  MOVWF  x5A
04A0E:  MOVLB  0
04A10:  CALL   1138
04A14:  MOVFF  00,FEF
04A18:  MOVFF  01,FEC
04A1C:  MOVFF  02,FEC
04A20:  MOVFF  03,FEC
04A24:  MOVLB  7
....................    PID[ch].PVold = PID[ch].PV;
04A26:  MOVF   x13,W
04A28:  MULLW  28
04A2A:  MOVF   FF3,W
04A2C:  CLRF   x1D
04A2E:  MOVWF  x1C
04A30:  MOVLW  14
04A32:  ADDWF  x1C,W
04A34:  MOVWF  01
04A36:  MOVLW  00
04A38:  ADDWFC x1D,W
04A3A:  MOVWF  03
04A3C:  MOVF   01,W
04A3E:  ADDLW  20
04A40:  MOVWF  01
04A42:  MOVLW  00
04A44:  ADDWFC 03,F
04A46:  MOVFF  01,71C
04A4A:  MOVFF  03,71D
04A4E:  MOVF   x13,W
04A50:  MULLW  28
04A52:  MOVF   FF3,W
04A54:  CLRF   x1F
04A56:  MOVWF  x1E
04A58:  MOVLW  10
04A5A:  ADDWF  x1E,W
04A5C:  MOVWF  01
04A5E:  MOVLW  00
04A60:  ADDWFC x1F,W
04A62:  MOVWF  03
04A64:  MOVF   01,W
04A66:  ADDLW  20
04A68:  MOVWF  FE9
04A6A:  MOVLW  00
04A6C:  ADDWFC 03,W
04A6E:  MOVWF  FEA
04A70:  MOVFF  FEF,00
04A74:  MOVFF  FEC,01
04A78:  MOVFF  FEC,02
04A7C:  MOVFF  FEC,03
04A80:  MOVFF  71D,FEA
04A84:  MOVFF  71C,FE9
04A88:  MOVFF  00,FEF
04A8C:  MOVFF  01,FEC
04A90:  MOVFF  02,FEC
04A94:  MOVFF  03,FEC
....................    PID[ch].PV = adcVals[ch].pReal;
04A98:  MOVF   x13,W
04A9A:  MULLW  28
04A9C:  MOVF   FF3,W
04A9E:  CLRF   x1D
04AA0:  MOVWF  x1C
04AA2:  MOVLW  10
04AA4:  ADDWF  x1C,W
04AA6:  MOVWF  01
04AA8:  MOVLW  00
04AAA:  ADDWFC x1D,W
04AAC:  MOVWF  03
04AAE:  MOVF   01,W
04AB0:  ADDLW  20
04AB2:  MOVWF  01
04AB4:  MOVLW  00
04AB6:  ADDWFC 03,F
04AB8:  MOVFF  01,71C
04ABC:  MOVFF  03,71D
04AC0:  MOVF   x13,W
04AC2:  MULLW  26
04AC4:  MOVF   FF3,W
04AC6:  CLRF   x1F
04AC8:  MOVWF  x1E
04ACA:  MOVLW  1D
04ACC:  ADDWF  x1E,W
04ACE:  MOVWF  01
04AD0:  MOVLW  00
04AD2:  ADDWFC x1F,W
04AD4:  MOVWF  03
04AD6:  MOVF   01,W
04AD8:  ADDLW  17
04ADA:  MOVWF  FE9
04ADC:  MOVLW  01
04ADE:  ADDWFC 03,W
04AE0:  MOVWF  FEA
04AE2:  MOVFF  FEF,00
04AE6:  MOVFF  FEC,01
04AEA:  MOVFF  FEC,02
04AEE:  MOVFF  FEC,03
04AF2:  MOVFF  71D,FEA
04AF6:  MOVFF  71C,FE9
04AFA:  MOVFF  00,FEF
04AFE:  MOVFF  01,FEC
04B02:  MOVFF  02,FEC
04B06:  MOVFF  03,FEC
04B0A:  MOVLB  0
04B0C:  GOTO   4C68 (RETURN)
.................... }  
.................... 
.................... /*****************************************************************************/
.................... /* SENSOR MONITOR INTERRUPT TASK                                             */
.................... /* starts conversion of the other two ADCs                                   */
.................... /*****************************************************************************/
.................... void sensor_monitor_interrupt_task(){
....................    static int8 ch = 0;
....................    
....................    if (!smData[ch].adcBusy){
*
001C0:  MOVLB  1
001C2:  MOVF   xE7,W
001C4:  MULLW  09
001C6:  MOVF   FF3,W
001C8:  MOVLB  7
001CA:  CLRF   x70
001CC:  MOVWF  x6F
001CE:  MOVLW  D4
001D0:  ADDWF  x6F,W
001D2:  MOVWF  FE9
001D4:  MOVLW  01
001D6:  ADDWFC x70,W
001D8:  MOVWF  FEA
001DA:  BTFSC  FEF.1
001DC:  BRA    0256
....................       smData[ch].adcBusy = true;
001DE:  MOVLB  1
001E0:  MOVF   xE7,W
001E2:  MULLW  09
001E4:  MOVF   FF3,W
001E6:  MOVLB  7
001E8:  CLRF   x70
001EA:  MOVWF  x6F
001EC:  MOVLW  D4
001EE:  ADDWF  x6F,W
001F0:  MOVWF  FE9
001F2:  MOVLW  01
001F4:  ADDWFC x70,W
001F6:  MOVWF  FEA
001F8:  BSF    FEF.1
....................          
....................       ads_start_conv_block(ch);
001FA:  MOVFF  1E7,76F
001FE:  MOVLB  0
00200:  BRA    01A4
....................       ch = !ch;
00202:  MOVLB  1
00204:  MOVF   xE7,F
00206:  BZ    020C
00208:  MOVLW  00
0020A:  BRA    020E
0020C:  MOVLW  01
0020E:  MOVWF  xE7
....................          
....................       smData[!ch].dataReady = true;
00210:  MOVF   xE7,F
00212:  BZ    0218
00214:  MOVLW  00
00216:  BRA    021A
00218:  MOVLW  01
0021A:  MULLW  09
0021C:  MOVF   FF3,W
0021E:  MOVLB  7
00220:  CLRF   x70
00222:  MOVWF  x6F
00224:  MOVLW  D4
00226:  ADDWF  x6F,W
00228:  MOVWF  FE9
0022A:  MOVLW  01
0022C:  ADDWFC x70,W
0022E:  MOVWF  FEA
00230:  BSF    FEF.0
....................       smData[!ch].adcBusy = false;
00232:  MOVLB  1
00234:  MOVF   xE7,F
00236:  BZ    023C
00238:  MOVLW  00
0023A:  BRA    023E
0023C:  MOVLW  01
0023E:  MULLW  09
00240:  MOVF   FF3,W
00242:  MOVLB  7
00244:  CLRF   x70
00246:  MOVWF  x6F
00248:  MOVLW  D4
0024A:  ADDWF  x6F,W
0024C:  MOVWF  FE9
0024E:  MOVLW  01
00250:  ADDWFC x70,W
00252:  MOVWF  FEA
00254:  BCF    FEF.1
....................    }
00256:  MOVLB  0
00258:  GOTO   031A (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Interquartile Mean Ring Buffer                                            */
.................... /* Filters the ADC data to remove spurious readings                          */
.................... /*****************************************************************************/
.................... void iqm_ring_buffer(int8 ch, signed int32 sinCnts, signed int32 cosCnts){
*
01E9A:  MOVLB  7
01E9C:  CLRF   x27
01E9E:  CLRF   x26
01EA0:  CLRF   x25
01EA2:  CLRF   x24
01EA4:  CLRF   x2B
01EA6:  CLRF   x2A
01EA8:  CLRF   x29
01EAA:  CLRF   x28
01EAC:  CLRF   x2F
01EAE:  CLRF   x2E
01EB0:  CLRF   x2D
01EB2:  CLRF   x2C
01EB4:  CLRF   x33
01EB6:  CLRF   x32
01EB8:  CLRF   x31
01EBA:  CLRF   x30
01EBC:  CLRF   x37
01EBE:  CLRF   x36
01EC0:  CLRF   x35
01EC2:  CLRF   x34
01EC4:  CLRF   x3B
01EC6:  CLRF   x3A
01EC8:  CLRF   x39
01ECA:  CLRF   x38
....................    signed int32* sQ_ch;
....................    signed int32* cQ_ch;
....................    int* sIn_ch;
....................    int* cIn_ch;
.................... 
....................    signed int32 sumSin=0;
....................    signed int32 sumCos=0;
....................    
....................    signed int32 sinMax=0;
....................    signed int32 sinMin=0;
....................    signed int32 cosMax=0;
....................    signed int32 cosMin=0;
....................    
....................    if (ch==0){
01ECC:  MOVF   x13,F
01ECE:  BNZ   1EF2
....................       sQ_ch = sQ_x;
01ED0:  MOVLW  01
01ED2:  MOVWF  x1D
01ED4:  MOVLW  80
01ED6:  MOVWF  x1C
....................       cQ_ch = cQ_x;
01ED8:  MOVLW  01
01EDA:  MOVWF  x1F
01EDC:  MOVLW  94
01EDE:  MOVWF  x1E
....................       sIn_ch = &sIn_x;
01EE0:  MOVLW  01
01EE2:  MOVWF  x21
01EE4:  MOVLW  D0
01EE6:  MOVWF  x20
....................       cIn_ch = &cIn_x;
01EE8:  MOVLW  01
01EEA:  MOVWF  x23
01EEC:  MOVLW  D1
01EEE:  MOVWF  x22
....................    }
01EF0:  BRA    1F16
....................    else if (ch==1){
01EF2:  DECFSZ x13,W
01EF4:  BRA    1F16
....................       sQ_ch = sQ_y;
01EF6:  MOVLW  01
01EF8:  MOVWF  x1D
01EFA:  MOVLW  A8
01EFC:  MOVWF  x1C
....................       cQ_ch = cQ_y;
01EFE:  MOVLW  01
01F00:  MOVWF  x1F
01F02:  MOVLW  BC
01F04:  MOVWF  x1E
....................       sIn_ch = &sIn_y;
01F06:  MOVLW  01
01F08:  MOVWF  x21
01F0A:  MOVLW  D2
01F0C:  MOVWF  x20
....................       cIn_ch = &cIn_y;
01F0E:  MOVLW  01
01F10:  MOVWF  x23
01F12:  MOVLW  D3
01F14:  MOVWF  x22
....................    }
.................... 
....................    push(sQ_ch, sIn_ch, sinCnts); // push new data into queues
01F16:  MOVFF  71D,73E
01F1A:  MOVFF  71C,73D
01F1E:  MOVFF  721,740
01F22:  MOVFF  720,73F
01F26:  MOVFF  717,744
01F2A:  MOVFF  716,743
01F2E:  MOVFF  715,742
01F32:  MOVFF  714,741
01F36:  MOVLB  0
01F38:  CALL   08DE
....................    push(cQ_ch, cIn_ch, cosCnts);
01F3C:  MOVFF  71F,73E
01F40:  MOVFF  71E,73D
01F44:  MOVFF  723,740
01F48:  MOVFF  722,73F
01F4C:  MOVFF  71B,744
01F50:  MOVFF  71A,743
01F54:  MOVFF  719,742
01F58:  MOVFF  718,741
01F5C:  CALL   08DE
....................    
....................    // MAX and MIN of the rolling buffer initial vals
....................    sinMax=sQ_ch[0];
01F60:  MOVLB  7
01F62:  MOVFF  71C,FE9
01F66:  MOVFF  71D,FEA
01F6A:  MOVFF  FEF,72C
01F6E:  MOVFF  FEC,72D
01F72:  MOVFF  FEC,72E
01F76:  MOVFF  FEC,72F
....................    sinMin=sQ_ch[0];
01F7A:  MOVFF  71C,FE9
01F7E:  MOVFF  71D,FEA
01F82:  MOVFF  FEF,730
01F86:  MOVFF  FEC,731
01F8A:  MOVFF  FEC,732
01F8E:  MOVFF  FEC,733
....................    cosMax=cQ_ch[0];
01F92:  MOVFF  71E,FE9
01F96:  MOVFF  71F,FEA
01F9A:  MOVFF  FEF,734
01F9E:  MOVFF  FEC,735
01FA2:  MOVFF  FEC,736
01FA6:  MOVFF  FEC,737
....................    cosMin=cQ_ch[0];
01FAA:  MOVFF  71E,FE9
01FAE:  MOVFF  71F,FEA
01FB2:  MOVFF  FEF,738
01FB6:  MOVFF  FEC,739
01FBA:  MOVFF  FEC,73A
01FBE:  MOVFF  FEC,73B
....................    
....................    // step thru buffer, adding up all vals and finding MAX and MIN
....................    for (int i=1; i<BUFFER_SIZE; i++){
01FC2:  MOVLW  01
01FC4:  MOVWF  x3C
01FC6:  MOVF   x3C,W
01FC8:  SUBLW  04
01FCA:  BTFSS  FD8.0
01FCC:  BRA    22DC
....................       (sinMax < sQ_ch[i]) ? (sinMax=sQ_ch[i]) : (0);
01FCE:  CLRF   x47
01FD0:  MOVFF  73C,746
01FD4:  CLRF   x49
01FD6:  MOVLW  04
01FD8:  MOVWF  x48
01FDA:  MOVLB  0
01FDC:  CALL   0890
01FE0:  MOVFF  02,03
01FE4:  MOVF   01,W
01FE6:  MOVLB  7
01FE8:  ADDWF  x1C,W
01FEA:  MOVWF  FE9
01FEC:  MOVF   x1D,W
01FEE:  ADDWFC 02,W
01FF0:  MOVWF  FEA
01FF2:  MOVFF  FEF,00
01FF6:  MOVFF  FEC,01
01FFA:  MOVFF  FEC,02
01FFE:  MOVFF  FEC,03
02002:  BTFSS  x2F.7
02004:  BRA    200C
02006:  BTFSS  03.7
02008:  BRA    202E
0200A:  BRA    2010
0200C:  BTFSC  03.7
0200E:  BRA    2064
02010:  MOVF   x2F,W
02012:  SUBWF  03,W
02014:  BNC   2064
02016:  BNZ   202E
02018:  MOVF   x2E,W
0201A:  SUBWF  02,W
0201C:  BNC   2064
0201E:  BNZ   202E
02020:  MOVF   x2D,W
02022:  SUBWF  01,W
02024:  BNC   2064
02026:  BNZ   202E
02028:  MOVF   00,W
0202A:  SUBWF  x2C,W
0202C:  BC    2064
0202E:  CLRF   x47
02030:  MOVFF  73C,746
02034:  CLRF   x49
02036:  MOVLW  04
02038:  MOVWF  x48
0203A:  MOVLB  0
0203C:  CALL   0890
02040:  MOVFF  02,03
02044:  MOVF   01,W
02046:  MOVLB  7
02048:  ADDWF  x1C,W
0204A:  MOVWF  FE9
0204C:  MOVF   x1D,W
0204E:  ADDWFC 02,W
02050:  MOVWF  FEA
02052:  MOVFF  FEF,72C
02056:  MOVFF  FEC,72D
0205A:  MOVFF  FEC,72E
0205E:  MOVFF  FEC,72F
02062:  MOVF   x2C,W
....................       (sinMin > sQ_ch[i]) ? (sinMin=sQ_ch[i]) : (0);
02064:  CLRF   x47
02066:  MOVFF  73C,746
0206A:  CLRF   x49
0206C:  MOVLW  04
0206E:  MOVWF  x48
02070:  MOVLB  0
02072:  CALL   0890
02076:  MOVFF  02,03
0207A:  MOVF   01,W
0207C:  MOVLB  7
0207E:  ADDWF  x1C,W
02080:  MOVWF  FE9
02082:  MOVF   x1D,W
02084:  ADDWFC 02,W
02086:  MOVWF  FEA
02088:  MOVFF  FEF,00
0208C:  MOVFF  FEC,01
02090:  MOVFF  FEC,02
02094:  MOVFF  FEC,03
02098:  BTFSS  03.7
0209A:  BRA    20A2
0209C:  BTFSS  x33.7
0209E:  BRA    20C4
020A0:  BRA    20A6
020A2:  BTFSC  x33.7
020A4:  BRA    2108
020A6:  MOVF   03,W
020A8:  SUBWF  x33,W
020AA:  BNC   2108
020AC:  BNZ   20C4
020AE:  MOVF   02,W
020B0:  SUBWF  x32,W
020B2:  BNC   2108
020B4:  BNZ   20C4
020B6:  MOVF   01,W
020B8:  SUBWF  x31,W
020BA:  BNC   2108
020BC:  BNZ   20C4
020BE:  MOVF   x30,W
020C0:  SUBWF  00,W
020C2:  BC    2108
020C4:  CLRF   x47
020C6:  MOVFF  73C,746
020CA:  CLRF   x49
020CC:  MOVLW  04
020CE:  MOVWF  x48
020D0:  MOVLB  0
020D2:  CALL   0890
020D6:  MOVFF  02,03
020DA:  MOVF   01,W
020DC:  MOVLB  7
020DE:  ADDWF  x1C,W
020E0:  MOVWF  FE9
020E2:  MOVF   x1D,W
020E4:  ADDWFC 02,W
020E6:  MOVWF  FEA
020E8:  MOVFF  FEF,730
020EC:  MOVFF  FEC,731
020F0:  MOVFF  FEC,732
020F4:  MOVFF  FEC,733
020F8:  MOVFF  730,00
020FC:  MOVFF  731,01
02100:  MOVFF  732,02
02104:  MOVFF  733,03
....................       (cosMax < cQ_ch[i]) ? (cosMax=cQ_ch[i]) : (0);
02108:  CLRF   x47
0210A:  MOVFF  73C,746
0210E:  CLRF   x49
02110:  MOVLW  04
02112:  MOVWF  x48
02114:  MOVLB  0
02116:  CALL   0890
0211A:  MOVFF  02,03
0211E:  MOVF   01,W
02120:  MOVLB  7
02122:  ADDWF  x1E,W
02124:  MOVWF  FE9
02126:  MOVF   x1F,W
02128:  ADDWFC 02,W
0212A:  MOVWF  FEA
0212C:  MOVFF  FEF,00
02130:  MOVFF  FEC,01
02134:  MOVFF  FEC,02
02138:  MOVFF  FEC,03
0213C:  BTFSS  x37.7
0213E:  BRA    2146
02140:  BTFSS  03.7
02142:  BRA    2168
02144:  BRA    214A
02146:  BTFSC  03.7
02148:  BRA    21AC
0214A:  MOVF   x37,W
0214C:  SUBWF  03,W
0214E:  BNC   21AC
02150:  BNZ   2168
02152:  MOVF   x36,W
02154:  SUBWF  02,W
02156:  BNC   21AC
02158:  BNZ   2168
0215A:  MOVF   x35,W
0215C:  SUBWF  01,W
0215E:  BNC   21AC
02160:  BNZ   2168
02162:  MOVF   00,W
02164:  SUBWF  x34,W
02166:  BC    21AC
02168:  CLRF   x47
0216A:  MOVFF  73C,746
0216E:  CLRF   x49
02170:  MOVLW  04
02172:  MOVWF  x48
02174:  MOVLB  0
02176:  CALL   0890
0217A:  MOVFF  02,03
0217E:  MOVF   01,W
02180:  MOVLB  7
02182:  ADDWF  x1E,W
02184:  MOVWF  FE9
02186:  MOVF   x1F,W
02188:  ADDWFC 02,W
0218A:  MOVWF  FEA
0218C:  MOVFF  FEF,734
02190:  MOVFF  FEC,735
02194:  MOVFF  FEC,736
02198:  MOVFF  FEC,737
0219C:  MOVFF  734,00
021A0:  MOVFF  735,01
021A4:  MOVFF  736,02
021A8:  MOVFF  737,03
....................       (cosMin > cQ_ch[i]) ? (cosMin=cQ_ch[i]) : (0);
021AC:  CLRF   x47
021AE:  MOVFF  73C,746
021B2:  CLRF   x49
021B4:  MOVLW  04
021B6:  MOVWF  x48
021B8:  MOVLB  0
021BA:  CALL   0890
021BE:  MOVFF  02,03
021C2:  MOVF   01,W
021C4:  MOVLB  7
021C6:  ADDWF  x1E,W
021C8:  MOVWF  FE9
021CA:  MOVF   x1F,W
021CC:  ADDWFC 02,W
021CE:  MOVWF  FEA
021D0:  MOVFF  FEF,00
021D4:  MOVFF  FEC,01
021D8:  MOVFF  FEC,02
021DC:  MOVFF  FEC,03
021E0:  BTFSS  03.7
021E2:  BRA    21EA
021E4:  BTFSS  x3B.7
021E6:  BRA    220C
021E8:  BRA    21EE
021EA:  BTFSC  x3B.7
021EC:  BRA    2250
021EE:  MOVF   03,W
021F0:  SUBWF  x3B,W
021F2:  BNC   2250
021F4:  BNZ   220C
021F6:  MOVF   02,W
021F8:  SUBWF  x3A,W
021FA:  BNC   2250
021FC:  BNZ   220C
021FE:  MOVF   01,W
02200:  SUBWF  x39,W
02202:  BNC   2250
02204:  BNZ   220C
02206:  MOVF   x38,W
02208:  SUBWF  00,W
0220A:  BC    2250
0220C:  CLRF   x47
0220E:  MOVFF  73C,746
02212:  CLRF   x49
02214:  MOVLW  04
02216:  MOVWF  x48
02218:  MOVLB  0
0221A:  CALL   0890
0221E:  MOVFF  02,03
02222:  MOVF   01,W
02224:  MOVLB  7
02226:  ADDWF  x1E,W
02228:  MOVWF  FE9
0222A:  MOVF   x1F,W
0222C:  ADDWFC 02,W
0222E:  MOVWF  FEA
02230:  MOVFF  FEF,738
02234:  MOVFF  FEC,739
02238:  MOVFF  FEC,73A
0223C:  MOVFF  FEC,73B
02240:  MOVFF  738,00
02244:  MOVFF  739,01
02248:  MOVFF  73A,02
0224C:  MOVFF  73B,03
....................       sumSin+=sQ_ch[i];
02250:  CLRF   x47
02252:  MOVFF  73C,746
02256:  CLRF   x49
02258:  MOVLW  04
0225A:  MOVWF  x48
0225C:  MOVLB  0
0225E:  CALL   0890
02262:  MOVFF  02,03
02266:  MOVF   01,W
02268:  MOVLB  7
0226A:  ADDWF  x1C,W
0226C:  MOVWF  FE9
0226E:  MOVF   x1D,W
02270:  ADDWFC 02,W
02272:  MOVWF  FEA
02274:  MOVFF  FEF,00
02278:  MOVFF  FEC,01
0227C:  MOVFF  FEC,02
02280:  MOVFF  FEC,03
02284:  MOVF   00,W
02286:  ADDWF  x24,F
02288:  MOVF   01,W
0228A:  ADDWFC x25,F
0228C:  MOVF   02,W
0228E:  ADDWFC x26,F
02290:  MOVF   03,W
02292:  ADDWFC x27,F
....................       sumCos+=cQ_ch[i];
02294:  CLRF   x47
02296:  MOVFF  73C,746
0229A:  CLRF   x49
0229C:  MOVLW  04
0229E:  MOVWF  x48
022A0:  MOVLB  0
022A2:  CALL   0890
022A6:  MOVFF  02,03
022AA:  MOVF   01,W
022AC:  MOVLB  7
022AE:  ADDWF  x1E,W
022B0:  MOVWF  FE9
022B2:  MOVF   x1F,W
022B4:  ADDWFC 02,W
022B6:  MOVWF  FEA
022B8:  MOVFF  FEF,00
022BC:  MOVFF  FEC,01
022C0:  MOVFF  FEC,02
022C4:  MOVFF  FEC,03
022C8:  MOVF   00,W
022CA:  ADDWF  x28,F
022CC:  MOVF   01,W
022CE:  ADDWFC x29,F
022D0:  MOVF   02,W
022D2:  ADDWFC x2A,F
022D4:  MOVF   03,W
022D6:  ADDWFC x2B,F
022D8:  INCF   x3C,F
022DA:  BRA    1FC6
....................    }
....................    
....................    // subtract MAX and MIN from sum
....................    sumSin-=(sinMax+sinMin);
022DC:  MOVF   x30,W
022DE:  ADDWF  x2C,W
022E0:  MOVWF  00
022E2:  MOVF   x31,W
022E4:  ADDWFC x2D,W
022E6:  MOVWF  01
022E8:  MOVF   x32,W
022EA:  ADDWFC x2E,W
022EC:  MOVWF  02
022EE:  MOVF   x33,W
022F0:  ADDWFC x2F,W
022F2:  MOVWF  03
022F4:  MOVF   00,W
022F6:  SUBWF  x24,F
022F8:  MOVF   01,W
022FA:  SUBWFB x25,F
022FC:  MOVF   02,W
022FE:  SUBWFB x26,F
02300:  MOVF   03,W
02302:  SUBWFB x27,F
....................    sumCos-=(cosMax+cosMin);
02304:  MOVF   x38,W
02306:  ADDWF  x34,W
02308:  MOVWF  00
0230A:  MOVF   x39,W
0230C:  ADDWFC x35,W
0230E:  MOVWF  01
02310:  MOVF   x3A,W
02312:  ADDWFC x36,W
02314:  MOVWF  02
02316:  MOVF   x3B,W
02318:  ADDWFC x37,W
0231A:  MOVWF  03
0231C:  MOVF   00,W
0231E:  SUBWF  x28,F
02320:  MOVF   01,W
02322:  SUBWFB x29,F
02324:  MOVF   02,W
02326:  SUBWFB x2A,F
02328:  MOVF   03,W
0232A:  SUBWFB x2B,F
....................    
....................    // calc AVG
....................    smData[ch].avgSin = sumSin / (BUFFER_SIZE-2);
0232C:  MOVF   x13,W
0232E:  MULLW  09
02330:  MOVF   FF3,W
02332:  CLRF   x3E
02334:  MOVWF  x3D
02336:  MOVLW  01
02338:  ADDWF  x3D,W
0233A:  MOVWF  01
0233C:  MOVLW  00
0233E:  ADDWFC x3E,W
02340:  MOVWF  03
02342:  MOVF   01,W
02344:  ADDLW  D4
02346:  MOVWF  FE9
02348:  MOVLW  01
0234A:  ADDWFC 03,W
0234C:  MOVWF  FEA
0234E:  MOVFF  FEA,740
02352:  MOVFF  FE9,73F
02356:  BCF    FD8.1
02358:  MOVFF  727,744
0235C:  MOVFF  726,743
02360:  MOVFF  725,742
02364:  MOVFF  724,741
02368:  CLRF   x48
0236A:  CLRF   x47
0236C:  CLRF   x46
0236E:  MOVLW  03
02370:  MOVWF  x45
02372:  MOVLB  0
02374:  RCALL  1DB0
02376:  MOVFF  740,FEA
0237A:  MOVFF  73F,FE9
0237E:  MOVFF  00,FEF
02382:  MOVFF  01,FEC
02386:  MOVFF  02,FEC
0238A:  MOVFF  03,FEC
....................    smData[ch].avgCos = sumCos / (BUFFER_SIZE-2);
0238E:  MOVLB  7
02390:  MOVF   x13,W
02392:  MULLW  09
02394:  MOVF   FF3,W
02396:  CLRF   x3E
02398:  MOVWF  x3D
0239A:  MOVLW  05
0239C:  ADDWF  x3D,W
0239E:  MOVWF  01
023A0:  MOVLW  00
023A2:  ADDWFC x3E,W
023A4:  MOVWF  03
023A6:  MOVF   01,W
023A8:  ADDLW  D4
023AA:  MOVWF  FE9
023AC:  MOVLW  01
023AE:  ADDWFC 03,W
023B0:  MOVWF  FEA
023B2:  MOVFF  FEA,740
023B6:  MOVFF  FE9,73F
023BA:  BCF    FD8.1
023BC:  MOVFF  72B,744
023C0:  MOVFF  72A,743
023C4:  MOVFF  729,742
023C8:  MOVFF  728,741
023CC:  CLRF   x48
023CE:  CLRF   x47
023D0:  CLRF   x46
023D2:  MOVLW  03
023D4:  MOVWF  x45
023D6:  MOVLB  0
023D8:  RCALL  1DB0
023DA:  MOVFF  740,FEA
023DE:  MOVFF  73F,FE9
023E2:  MOVFF  00,FEF
023E6:  MOVFF  01,FEC
023EA:  MOVFF  02,FEC
023EE:  MOVFF  03,FEC
023F2:  GOTO   4BF0 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SENSOR MONITOR task - gets magnetoresistive sensor counts                 */
.................... /* gets two values each time the task is run                                 */
.................... /*****************************************************************************/
.................... void sensor_monitor_task(){
*
04B10:  MOVLB  7
04B12:  CLRF   x0E
04B14:  CLRF   x0D
04B16:  CLRF   x0C
04B18:  CLRF   x0B
04B1A:  CLRF   x12
04B1C:  CLRF   x11
04B1E:  CLRF   x10
04B20:  CLRF   x0F
....................    static int8 ch = 0;
....................    signed int32 sinNew = 0;
....................    signed int32 cosNew = 0;
....................    
....................    if ( (!smData[ch].adcBusy) && smData[ch].dataReady ){
04B22:  MOVLB  1
04B24:  MOVF   xE8,W
04B26:  MULLW  09
04B28:  MOVF   FF3,W
04B2A:  MOVLB  7
04B2C:  CLRF   x14
04B2E:  MOVWF  x13
04B30:  MOVLW  D4
04B32:  ADDWF  x13,W
04B34:  MOVWF  FE9
04B36:  MOVLW  01
04B38:  ADDWFC x14,W
04B3A:  MOVWF  FEA
04B3C:  BTFSC  FEF.1
04B3E:  BRA    4CBC
04B40:  MOVLB  1
04B42:  MOVF   xE8,W
04B44:  MULLW  09
04B46:  MOVF   FF3,W
04B48:  MOVLB  7
04B4A:  CLRF   x16
04B4C:  MOVWF  x15
04B4E:  MOVLW  D4
04B50:  ADDWF  x15,W
04B52:  MOVWF  FE9
04B54:  MOVLW  01
04B56:  ADDWFC x16,W
04B58:  MOVWF  FEA
04B5A:  BTFSS  FEF.0
04B5C:  BRA    4CBC
....................       smData[ch].adcBusy = true;
04B5E:  MOVLB  1
04B60:  MOVF   xE8,W
04B62:  MULLW  09
04B64:  MOVF   FF3,W
04B66:  MOVLB  7
04B68:  CLRF   x14
04B6A:  MOVWF  x13
04B6C:  MOVLW  D4
04B6E:  ADDWF  x13,W
04B70:  MOVWF  FE9
04B72:  MOVLW  01
04B74:  ADDWFC x14,W
04B76:  MOVWF  FEA
04B78:  BSF    FEF.1
....................       
....................       sinNew = ads_read_data(ch*2);
04B7A:  BCF    FD8.0
04B7C:  MOVLB  1
04B7E:  RLCF   xE8,W
04B80:  MOVLB  7
04B82:  MOVWF  x13
04B84:  MOVWF  x14
04B86:  MOVLB  0
04B88:  CALL   0836
04B8C:  MOVFF  03,70E
04B90:  MOVFF  02,70D
04B94:  MOVFF  01,70C
04B98:  MOVFF  00,70B
....................       cosNew = ads_read_data(ch*2+1);      
04B9C:  BCF    FD8.0
04B9E:  MOVLB  1
04BA0:  RLCF   xE8,W
04BA2:  ADDLW  01
04BA4:  MOVLB  7
04BA6:  MOVWF  x13
04BA8:  MOVWF  x14
04BAA:  MOVLB  0
04BAC:  CALL   0836
04BB0:  MOVFF  03,712
04BB4:  MOVFF  02,711
04BB8:  MOVFF  01,710
04BBC:  MOVFF  00,70F
....................       
....................       if (adcFilter){
04BC0:  MOVLB  1
04BC2:  BTFSS  x63.0
04BC4:  BRA    4BF4
....................          iqm_ring_buffer(ch, sinNew, cosNew);
04BC6:  MOVFF  1E8,713
04BCA:  MOVFF  70E,717
04BCE:  MOVFF  70D,716
04BD2:  MOVFF  70C,715
04BD6:  MOVFF  70B,714
04BDA:  MOVFF  712,71B
04BDE:  MOVFF  711,71A
04BE2:  MOVFF  710,719
04BE6:  MOVFF  70F,718
04BEA:  MOVLB  0
04BEC:  GOTO   1E9A
....................       }
04BF0:  BRA    4C60
04BF2:  MOVLB  1
....................       else{
....................          smData[ch].avgSin = sinNew;
04BF4:  MOVF   xE8,W
04BF6:  MULLW  09
04BF8:  MOVF   FF3,W
04BFA:  MOVLB  7
04BFC:  CLRF   x14
04BFE:  MOVWF  x13
04C00:  MOVLW  01
04C02:  ADDWF  x13,W
04C04:  MOVWF  01
04C06:  MOVLW  00
04C08:  ADDWFC x14,W
04C0A:  MOVWF  03
04C0C:  MOVF   01,W
04C0E:  ADDLW  D4
04C10:  MOVWF  FE9
04C12:  MOVLW  01
04C14:  ADDWFC 03,W
04C16:  MOVWF  FEA
04C18:  MOVFF  70B,FEF
04C1C:  MOVFF  70C,FEC
04C20:  MOVFF  70D,FEC
04C24:  MOVFF  70E,FEC
....................          smData[ch].avgCos = cosNew;
04C28:  MOVLB  1
04C2A:  MOVF   xE8,W
04C2C:  MULLW  09
04C2E:  MOVF   FF3,W
04C30:  MOVLB  7
04C32:  CLRF   x14
04C34:  MOVWF  x13
04C36:  MOVLW  05
04C38:  ADDWF  x13,W
04C3A:  MOVWF  01
04C3C:  MOVLW  00
04C3E:  ADDWFC x14,W
04C40:  MOVWF  03
04C42:  MOVF   01,W
04C44:  ADDLW  D4
04C46:  MOVWF  FE9
04C48:  MOVLW  01
04C4A:  ADDWFC 03,W
04C4C:  MOVWF  FEA
04C4E:  MOVFF  70F,FEF
04C52:  MOVFF  710,FEC
04C56:  MOVFF  711,FEC
04C5A:  MOVFF  712,FEC
04C5E:  MOVLB  0
....................       }
....................       
....................       sensor_process_data(ch);
04C60:  MOVFF  1E8,713
04C64:  GOTO   3DBE
....................       ch = !ch;
04C68:  MOVLB  1
04C6A:  MOVF   xE8,F
04C6C:  BZ    4C72
04C6E:  MOVLW  00
04C70:  BRA    4C74
04C72:  MOVLW  01
04C74:  MOVWF  xE8
....................       
....................       smData[!ch].dataReady = false;
04C76:  MOVF   xE8,F
04C78:  BZ    4C7E
04C7A:  MOVLW  00
04C7C:  BRA    4C80
04C7E:  MOVLW  01
04C80:  MULLW  09
04C82:  MOVF   FF3,W
04C84:  MOVLB  7
04C86:  CLRF   x14
04C88:  MOVWF  x13
04C8A:  MOVLW  D4
04C8C:  ADDWF  x13,W
04C8E:  MOVWF  FE9
04C90:  MOVLW  01
04C92:  ADDWFC x14,W
04C94:  MOVWF  FEA
04C96:  BCF    FEF.0
....................       smData[!ch].adcBusy = false;
04C98:  MOVLB  1
04C9A:  MOVF   xE8,F
04C9C:  BZ    4CA2
04C9E:  MOVLW  00
04CA0:  BRA    4CA4
04CA2:  MOVLW  01
04CA4:  MULLW  09
04CA6:  MOVF   FF3,W
04CA8:  MOVLB  7
04CAA:  CLRF   x14
04CAC:  MOVWF  x13
04CAE:  MOVLW  D4
04CB0:  ADDWF  x13,W
04CB2:  MOVWF  FE9
04CB4:  MOVLW  01
04CB6:  ADDWFC x14,W
04CB8:  MOVWF  FEA
04CBA:  BCF    FEF.1
....................    }
04CBC:  MOVLB  0
04CBE:  RETURN 0
.................... }
.................... /*****************************************************************************/
.................... /* INITIALIZE ADC's                                                          */
.................... /*****************************************************************************/
.................... void setup_external_ADCs(){
*
00944:  MOVLB  6
00946:  CLRF   xFB
00948:  CLRF   xFC
0094A:  CLRF   xFD
0094C:  CLRF   xFE
....................    unsigned int8 rc0=0;
....................    unsigned int8 rc1=0;
....................    unsigned int8 rc2=0;
....................    unsigned int8 rc3=0;
....................    
....................    for (int ch = 0; ch < 4; ch++){
0094E:  CLRF   xFF
00950:  MOVF   xFF,W
00952:  SUBLW  03
00954:  BNC   098A
....................       rc0=reg0config;
00956:  MOVLW  30
00958:  MOVWF  xFB
....................       rc1=reg1config;
0095A:  MOVLW  10
0095C:  MOVWF  xFC
....................       rc2=reg2config;
0095E:  CLRF   xFD
....................       rc3=reg3config;
00960:  CLRF   xFE
....................       
....................       ADS1220init(ch, rc0, rc1, rc2, rc3);
00962:  MOVFF  6FF,701
00966:  MOVFF  6FB,702
0096A:  MOVFF  6FC,703
0096E:  MOVFF  6FD,704
00972:  MOVFF  6FE,705
00976:  MOVLB  0
00978:  BRA    0768
....................       delay_ms(100);
0097A:  MOVLW  64
0097C:  MOVLB  7
0097E:  MOVWF  x0F
00980:  MOVLB  0
00982:  RCALL  03A4
00984:  MOVLB  6
00986:  INCF   xFF,F
00988:  BRA    0950
....................    }
....................    
....................    if (adcFilter){
0098A:  MOVLB  1
0098C:  BTFSS  x63.0
0098E:  BRA    0AB0
....................       for (int i = 0; i < BUFFER_SIZE; i++){
00990:  MOVLB  7
00992:  CLRF   x00
00994:  MOVF   x00,W
00996:  SUBLW  04
00998:  BTFSS  FD8.0
0099A:  BRA    0AAE
....................          ads_start_conv_all();
0099C:  MOVLB  0
0099E:  BRA    0806
....................          delay_ms(50);
009A0:  MOVLW  32
009A2:  MOVLB  7
009A4:  MOVWF  x0F
009A6:  MOVLB  0
009A8:  RCALL  03A4
....................          push(sQ_x, &sIn_x, ads_read_data(0));
009AA:  MOVLB  7
009AC:  CLRF   x14
009AE:  MOVLB  0
009B0:  RCALL  0836
009B2:  MOVFF  03,704
009B6:  MOVFF  02,703
009BA:  MOVFF  01,702
009BE:  MOVFF  00,701
009C2:  MOVLW  01
009C4:  MOVLB  7
009C6:  MOVWF  x3E
009C8:  MOVLW  80
009CA:  MOVWF  x3D
009CC:  MOVLW  01
009CE:  MOVWF  x40
009D0:  MOVLW  D0
009D2:  MOVWF  x3F
009D4:  MOVFF  03,744
009D8:  MOVFF  02,743
009DC:  MOVFF  01,742
009E0:  MOVFF  00,741
009E4:  MOVLB  0
009E6:  RCALL  08DE
....................          push(cQ_x, &cIn_x, ads_read_data(1));      
009E8:  MOVLW  01
009EA:  MOVLB  7
009EC:  MOVWF  x14
009EE:  MOVLB  0
009F0:  RCALL  0836
009F2:  MOVFF  03,704
009F6:  MOVFF  02,703
009FA:  MOVFF  01,702
009FE:  MOVFF  00,701
00A02:  MOVLW  01
00A04:  MOVLB  7
00A06:  MOVWF  x3E
00A08:  MOVLW  94
00A0A:  MOVWF  x3D
00A0C:  MOVLW  01
00A0E:  MOVWF  x40
00A10:  MOVLW  D1
00A12:  MOVWF  x3F
00A14:  MOVFF  03,744
00A18:  MOVFF  02,743
00A1C:  MOVFF  01,742
00A20:  MOVFF  00,741
00A24:  MOVLB  0
00A26:  RCALL  08DE
....................          push(sQ_y, &sIn_y, ads_read_data(2));
00A28:  MOVLW  02
00A2A:  MOVLB  7
00A2C:  MOVWF  x14
00A2E:  MOVLB  0
00A30:  RCALL  0836
00A32:  MOVFF  03,704
00A36:  MOVFF  02,703
00A3A:  MOVFF  01,702
00A3E:  MOVFF  00,701
00A42:  MOVLW  01
00A44:  MOVLB  7
00A46:  MOVWF  x3E
00A48:  MOVLW  A8
00A4A:  MOVWF  x3D
00A4C:  MOVLW  01
00A4E:  MOVWF  x40
00A50:  MOVLW  D2
00A52:  MOVWF  x3F
00A54:  MOVFF  03,744
00A58:  MOVFF  02,743
00A5C:  MOVFF  01,742
00A60:  MOVFF  00,741
00A64:  MOVLB  0
00A66:  RCALL  08DE
....................          push(cQ_y, &cIn_y, ads_read_data(3));      
00A68:  MOVLW  03
00A6A:  MOVLB  7
00A6C:  MOVWF  x14
00A6E:  MOVLB  0
00A70:  RCALL  0836
00A72:  MOVFF  03,704
00A76:  MOVFF  02,703
00A7A:  MOVFF  01,702
00A7E:  MOVFF  00,701
00A82:  MOVLW  01
00A84:  MOVLB  7
00A86:  MOVWF  x3E
00A88:  MOVLW  BC
00A8A:  MOVWF  x3D
00A8C:  MOVLW  01
00A8E:  MOVWF  x40
00A90:  MOVLW  D3
00A92:  MOVWF  x3F
00A94:  MOVFF  03,744
00A98:  MOVFF  02,743
00A9C:  MOVFF  01,742
00AA0:  MOVFF  00,741
00AA4:  MOVLB  0
00AA6:  RCALL  08DE
00AA8:  MOVLB  7
00AAA:  INCF   x00,F
00AAC:  BRA    0994
00AAE:  MOVLB  1
....................       }
....................    }
00AB0:  MOVLB  0
00AB2:  GOTO   0B16 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE MONITOR -- sets up ADC channels                                */
.................... /*****************************************************************************/
.................... void monitor_init(){
....................    setup_adc_ports(sAN6 | sAN16 | sAN17 | sAN24 | sAN25 | sAN26 | sAN27, NO_ANALOGS_P2, VSS_VDD);
00AB6:  MOVLW  00
00AB8:  MOVLB  F
00ABA:  MOVWF  x53
00ABC:  MOVLW  40
00ABE:  MOVWF  x0C
00AC0:  MOVLW  00
00AC2:  MOVWF  x14
00AC4:  MOVLW  03
00AC6:  MOVWF  x1C
00AC8:  MOVLW  0F
00ACA:  MOVWF  x21
00ACC:  MOVLW  00
00ACE:  MOVWF  x29
....................    setup_adc(ADC_CLOCK_INTERNAL | ADC_TAD_MUL_255 | ADC_LEGACY_MODE | ADC_THRESHOLD_INT_DISABLED);
00AD0:  MOVLW  08
00AD2:  MOVWF  x55
00AD4:  CLRF   x56
00AD6:  CLRF   x52
00AD8:  SETF   x57
00ADA:  CLRF   F61
00ADC:  MOVLW  94
00ADE:  MOVWF  x5B
....................    output_high(EN_EXC);
00AE0:  MOVLW  E8
00AE2:  MOVWF  F8B
00AE4:  BSF    F86.0
....................    set_adc_channel(vMonN15); // internal MUX
00AE6:  MOVF   x5A,W
00AE8:  ANDLW  3F
00AEA:  MOVWF  01
00AEC:  MOVLW  06
00AEE:  MOVWF  x5A
00AF0:  BTFSS  x5B.7
00AF2:  BRA    0B02
00AF4:  MOVF   01,W
00AF6:  SUBLW  06
00AF8:  BZ    0B02
00AFA:  BSF    x5B.0
00AFC:  NOP   
00AFE:  BTFSC  x5B.0
00B00:  BRA    0AFE
....................    delay_ms(10);
00B02:  MOVLW  0A
00B04:  MOVLB  7
00B06:  MOVWF  x0F
00B08:  MOVLB  0
00B0A:  RCALL  03A4
....................    read_adc(ADC_START_ONLY);
00B0C:  MOVLB  F
00B0E:  BSF    x5B.0
00B10:  NOP   
....................    setup_external_ADCs();
00B12:  MOVLB  0
00B14:  BRA    0944
....................    intTimeoutReg = sensorSampleRate;
00B16:  MOVLB  1
00B18:  CLRF   x7F
00B1A:  MOVLW  32
00B1C:  MOVWF  x7E
00B1E:  MOVLB  0
00B20:  GOTO   ACF8 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <control.h>
.................... #ifndef control
.................... #define control
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................     float kP;      // proportional gain
....................     float kI;      // integral gain
....................     float kD;      // derivative gain
....................     float SP;      // set point-- desired output
....................     float PV;      // process variable-- measured output
....................     float PVold;   // oldPV value  
....................     float CV;      // control variable-- output -- 0 to 100%
....................     float I;       // integral value
....................     float maxSP;   // Max setpoint in microns
....................     float minSP;   // Min setpoint in microns
.................... }PID[2] = {
....................    //  P     I     D
....................    //0.01    0.3   0.1
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}, 
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}
....................     };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... //!#define op_upper_bound 63  // CRYO
.................... //!#define op_lower_bound -63 // CRYO
.................... 
.................... #define op_upper_bound 63  // AMBIENT 
.................... #define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    BOOLEAN homeFlag;       // Flag to trigger the homing routine
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,FALSE},
....................    {0,0,0,0,0,0,0,0,0,0,FALSE}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................     BOOLEAN invV;
....................     unsigned int16 ipVal;
....................     float opPcnt;
....................    
.................... }dacVals[2] = 
.................... {
....................     {FALSE,0,0},
....................     {FALSE,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <pid.h>
.................... #ifndef pidcontroller
.................... #define pidcontroller
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................     float kP;      // proportional gain
....................     float kI;      // integral gain
....................     float kD;      // derivative gain
....................     float SP;      // set point-- desired output
....................     float PV;      // process variable-- measured output
....................     float PVold;   // oldPV value  
....................     float CV;      // control variable-- output -- 0 to 100%
....................     float I;       // integral value
....................     float maxSP;   // Max setpoint in microns
....................     float minSP;   // Min setpoint in microns
.................... }PID[2] = {
....................    //  P     I     D
....................    //0.01    0.3   0.1
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}, 
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}
....................     };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... //!#define op_upper_bound 63  // CRYO
.................... //!#define op_lower_bound -63 // CRYO
.................... 
.................... #define op_upper_bound 63  // AMBIENT 
.................... #define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    BOOLEAN homeFlag;       // Flag to trigger the homing routine
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,FALSE},
....................    {0,0,0,0,0,0,0,0,0,0,FALSE}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................     BOOLEAN invV;
....................     unsigned int16 ipVal;
....................     float opPcnt;
....................    
.................... }dacVals[2] = 
.................... {
....................     {FALSE,0,0},
....................     {FALSE,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float32)(unsigned int16)y;
.................... 
....................  else if (y < 10000000.0)
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
....................       res = 32768.0*(float32)l;
....................       res += (float32)(unsigned int16)y;
....................    }
.................... 
....................  else
....................   res = y;
.................... 
....................  y = y - (float32)(unsigned int16)y;
.................... 
....................  if (s)
....................   res = -res;
.................... 
....................  if (y != 0)
....................  {
....................   if (s == 1 && n == 0)
....................    res -= 1.0;
.................... 
....................   if (s == 0 && n == 1)
....................    res += 1.0;
....................  }
....................  if (x == 0)
....................     res = 0;
.................... 
....................  return (res);
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl[0]*y2 + pl[1];
.................... 
....................       r = ql[0]*y2 + ql[1];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
....................          r = -(float32)-n;
....................       else
....................          r = (float32)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* UPDATE the Control Variable (CV)                                          */
.................... /*****************************************************************************/
.................... void pid_update (channelMap ch){
*
0126A:  MOVLB  7
0126C:  MOVF   x10,W
0126E:  MULLW  28
01270:  MOVF   FF3,W
01272:  CLRF   x1E
01274:  MOVWF  x1D
01276:  MOVLW  0C
01278:  ADDWF  x1D,W
0127A:  MOVWF  01
0127C:  MOVLW  00
0127E:  ADDWFC x1E,W
01280:  MOVWF  03
01282:  MOVF   01,W
01284:  ADDLW  20
01286:  MOVWF  FE9
01288:  MOVLW  00
0128A:  ADDWFC 03,W
0128C:  MOVWF  FEA
0128E:  MOVFF  FEF,75A
01292:  MOVFF  FEC,75B
01296:  MOVFF  FEC,75C
0129A:  MOVFF  FEC,75D
0129E:  MOVF   x10,W
012A0:  MULLW  28
012A2:  MOVF   FF3,W
012A4:  CLRF   x22
012A6:  MOVWF  x21
012A8:  MOVLW  10
012AA:  ADDWF  x21,W
012AC:  MOVWF  01
012AE:  MOVLW  00
012B0:  ADDWFC x22,W
012B2:  MOVWF  03
012B4:  MOVF   01,W
012B6:  ADDLW  20
012B8:  MOVWF  FE9
012BA:  MOVLW  00
012BC:  ADDWFC 03,W
012BE:  MOVWF  FEA
012C0:  MOVFF  FEF,75E
012C4:  MOVFF  FEC,01
012C8:  MOVFF  FEC,02
012CC:  MOVFF  FEC,03
012D0:  MOVFF  FEA,722
012D4:  MOVFF  FE9,721
012D8:  BSF    FD8.1
012DA:  MOVFF  03,761
012DE:  MOVFF  02,760
012E2:  MOVFF  01,75F
012E6:  MOVLB  0
012E8:  RCALL  0DFE
012EA:  MOVFF  722,FEA
012EE:  MOVFF  721,FE9
012F2:  MOVFF  03,714
012F6:  MOVFF  02,713
012FA:  MOVFF  01,712
012FE:  MOVFF  00,711
....................    float err = PID[ch].SP - PID[ch].PV;  // error = set value - measured
....................    
....................    PID[ch].I += err*PID[ch].kI;
01302:  MOVLB  7
01304:  MOVF   x10,W
01306:  MULLW  28
01308:  MOVF   FF3,W
0130A:  CLRF   x1E
0130C:  MOVWF  x1D
0130E:  MOVLW  1C
01310:  ADDWF  x1D,W
01312:  MOVWF  01
01314:  MOVLW  00
01316:  ADDWFC x1E,W
01318:  MOVWF  03
0131A:  MOVF   01,W
0131C:  ADDLW  20
0131E:  MOVWF  01
01320:  MOVLW  00
01322:  ADDWFC 03,F
01324:  MOVFF  01,71D
01328:  MOVFF  03,71E
0132C:  MOVFF  03,FEA
01330:  MOVFF  01,FE9
01334:  MOVFF  FEF,71F
01338:  MOVFF  FEC,720
0133C:  MOVFF  FEC,721
01340:  MOVFF  FEC,722
01344:  MOVF   x10,W
01346:  MULLW  28
01348:  MOVF   FF3,W
0134A:  CLRF   x24
0134C:  MOVWF  x23
0134E:  MOVLW  04
01350:  ADDWF  x23,W
01352:  MOVWF  01
01354:  MOVLW  00
01356:  ADDWFC x24,W
01358:  MOVWF  03
0135A:  MOVF   01,W
0135C:  ADDLW  20
0135E:  MOVWF  FE9
01360:  MOVLW  00
01362:  ADDWFC 03,W
01364:  MOVWF  FEA
01366:  MOVFF  FEF,75A
0136A:  MOVFF  FEC,01
0136E:  MOVFF  FEC,02
01372:  MOVFF  FEC,03
01376:  MOVFF  714,759
0137A:  MOVFF  713,758
0137E:  MOVFF  712,757
01382:  MOVFF  711,756
01386:  MOVFF  03,75D
0138A:  MOVFF  02,75C
0138E:  MOVFF  01,75B
01392:  MOVLB  0
01394:  RCALL  1138
01396:  BCF    FD8.1
01398:  MOVFF  722,75D
0139C:  MOVFF  721,75C
013A0:  MOVFF  720,75B
013A4:  MOVFF  71F,75A
013A8:  MOVFF  03,761
013AC:  MOVFF  02,760
013B0:  MOVFF  01,75F
013B4:  MOVFF  00,75E
013B8:  RCALL  0DFE
013BA:  MOVFF  71E,FEA
013BE:  MOVFF  71D,FE9
013C2:  MOVFF  00,FEF
013C6:  MOVFF  01,FEC
013CA:  MOVFF  02,FEC
013CE:  MOVFF  03,FEC
....................    if (PID[ch].I > op_upper_bound) PID[ch].I = op_upper_bound; // anti-windup
013D2:  MOVLB  7
013D4:  MOVF   x10,W
013D6:  MULLW  28
013D8:  MOVF   FF3,W
013DA:  CLRF   x1E
013DC:  MOVWF  x1D
013DE:  MOVLW  1C
013E0:  ADDWF  x1D,W
013E2:  MOVWF  01
013E4:  MOVLW  00
013E6:  ADDWFC x1E,W
013E8:  MOVWF  03
013EA:  MOVF   01,W
013EC:  ADDLW  20
013EE:  MOVWF  FE9
013F0:  MOVLW  00
013F2:  ADDWFC 03,W
013F4:  MOVWF  FEA
013F6:  MOVFF  FEF,75A
013FA:  MOVFF  FEC,71E
013FE:  MOVFF  FEC,75C
01402:  MOVFF  FEC,75D
01406:  CLRF   x59
01408:  CLRF   x58
0140A:  MOVLW  7C
0140C:  MOVWF  x57
0140E:  MOVLW  84
01410:  MOVWF  x56
01412:  MOVFF  71E,75B
01416:  MOVLB  0
01418:  RCALL  0D84
0141A:  BNC   144E
0141C:  MOVLB  7
0141E:  MOVF   x10,W
01420:  MULLW  28
01422:  MOVF   FF3,W
01424:  CLRF   x1E
01426:  MOVWF  x1D
01428:  MOVLW  1C
0142A:  ADDWF  x1D,W
0142C:  MOVWF  01
0142E:  MOVLW  00
01430:  ADDWFC x1E,W
01432:  MOVWF  03
01434:  MOVF   01,W
01436:  ADDLW  20
01438:  MOVWF  FE9
0143A:  MOVLW  00
0143C:  ADDWFC 03,W
0143E:  MOVWF  FEA
01440:  MOVLW  84
01442:  MOVWF  FEF
01444:  MOVLW  7C
01446:  MOVWF  FEC
01448:  CLRF   FEC
0144A:  CLRF   FEC
0144C:  BRA    14C8
....................    else if (PID[ch].I < op_lower_bound) PID[ch].I = op_lower_bound;
0144E:  MOVLB  7
01450:  MOVF   x10,W
01452:  MULLW  28
01454:  MOVF   FF3,W
01456:  CLRF   x1E
01458:  MOVWF  x1D
0145A:  MOVLW  1C
0145C:  ADDWF  x1D,W
0145E:  MOVWF  01
01460:  MOVLW  00
01462:  ADDWFC x1E,W
01464:  MOVWF  03
01466:  MOVF   01,W
01468:  ADDLW  20
0146A:  MOVWF  FE9
0146C:  MOVLW  00
0146E:  ADDWFC 03,W
01470:  MOVWF  FEA
01472:  MOVFF  FEF,756
01476:  MOVFF  FEC,71E
0147A:  MOVFF  FEC,758
0147E:  MOVFF  FEC,759
01482:  MOVFF  71E,757
01486:  CLRF   x5D
01488:  CLRF   x5C
0148A:  MOVLW  C0
0148C:  MOVWF  x5B
0148E:  MOVLW  82
01490:  MOVWF  x5A
01492:  MOVLB  0
01494:  RCALL  0D84
01496:  BNC   14CA
01498:  MOVLB  7
0149A:  MOVF   x10,W
0149C:  MULLW  28
0149E:  MOVF   FF3,W
014A0:  CLRF   x1E
014A2:  MOVWF  x1D
014A4:  MOVLW  1C
014A6:  ADDWF  x1D,W
014A8:  MOVWF  01
014AA:  MOVLW  00
014AC:  ADDWFC x1E,W
014AE:  MOVWF  03
014B0:  MOVF   01,W
014B2:  ADDLW  20
014B4:  MOVWF  FE9
014B6:  MOVLW  00
014B8:  ADDWFC 03,W
014BA:  MOVWF  FEA
014BC:  MOVLW  82
014BE:  MOVWF  FEF
014C0:  MOVLW  C0
014C2:  MOVWF  FEC
014C4:  CLRF   FEC
014C6:  CLRF   FEC
014C8:  MOVLB  0
....................    
....................    float P = err * PID[ch].kP;  // proportional value
....................    
....................    float D = PID[ch].kD * (PID[ch].PV - PID[ch].PVold);  // derivative value
014CA:  MOVLB  7
014CC:  MOVF   x10,W
014CE:  MULLW  28
014D0:  MOVF   FF3,W
014D2:  CLRF   x1E
014D4:  MOVWF  x1D
014D6:  MOVLW  20
014D8:  ADDWF  x1D,W
014DA:  MOVWF  FE9
014DC:  MOVLW  00
014DE:  ADDWFC x1E,W
014E0:  MOVWF  FEA
014E2:  MOVFF  FEF,75A
014E6:  MOVFF  FEC,01
014EA:  MOVFF  FEC,02
014EE:  MOVFF  FEC,03
014F2:  MOVFF  714,759
014F6:  MOVFF  713,758
014FA:  MOVFF  712,757
014FE:  MOVFF  711,756
01502:  MOVFF  03,75D
01506:  MOVFF  02,75C
0150A:  MOVFF  01,75B
0150E:  MOVLB  0
01510:  RCALL  1138
01512:  MOVFF  03,718
01516:  MOVFF  02,717
0151A:  MOVFF  01,716
0151E:  MOVFF  00,715
01522:  MOVLB  7
01524:  MOVF   x10,W
01526:  MULLW  28
01528:  MOVF   FF3,W
0152A:  CLRF   x20
0152C:  MOVWF  x1F
0152E:  MOVLW  08
01530:  ADDWF  x1F,W
01532:  MOVWF  01
01534:  MOVLW  00
01536:  ADDWFC x20,W
01538:  MOVWF  03
0153A:  MOVF   01,W
0153C:  ADDLW  20
0153E:  MOVWF  FE9
01540:  MOVLW  00
01542:  ADDWFC 03,W
01544:  MOVWF  FEA
01546:  MOVFF  FEF,71F
0154A:  MOVFF  FEC,720
0154E:  MOVFF  FEC,721
01552:  MOVFF  FEC,722
01556:  MOVF   x10,W
01558:  MULLW  28
0155A:  MOVF   FF3,W
0155C:  CLRF   x24
0155E:  MOVWF  x23
01560:  MOVLW  10
01562:  ADDWF  x23,W
01564:  MOVWF  01
01566:  MOVLW  00
01568:  ADDWFC x24,W
0156A:  MOVWF  03
0156C:  MOVF   01,W
0156E:  ADDLW  20
01570:  MOVWF  FE9
01572:  MOVLW  00
01574:  ADDWFC 03,W
01576:  MOVWF  FEA
01578:  MOVFF  FEF,75A
0157C:  MOVFF  FEC,75B
01580:  MOVFF  FEC,75C
01584:  MOVFF  FEC,75D
01588:  MOVF   x10,W
0158A:  MULLW  28
0158C:  MOVF   FF3,W
0158E:  CLRF   x28
01590:  MOVWF  x27
01592:  MOVLW  14
01594:  ADDWF  x27,W
01596:  MOVWF  01
01598:  MOVLW  00
0159A:  ADDWFC x28,W
0159C:  MOVWF  03
0159E:  MOVF   01,W
015A0:  ADDLW  20
015A2:  MOVWF  FE9
015A4:  MOVLW  00
015A6:  ADDWFC 03,W
015A8:  MOVWF  FEA
015AA:  MOVFF  FEF,75E
015AE:  MOVFF  FEC,01
015B2:  MOVFF  FEC,02
015B6:  MOVFF  FEC,03
015BA:  MOVFF  FEA,728
015BE:  MOVFF  FE9,727
015C2:  BSF    FD8.1
015C4:  MOVFF  03,761
015C8:  MOVFF  02,760
015CC:  MOVFF  01,75F
015D0:  MOVLB  0
015D2:  RCALL  0DFE
015D4:  MOVFF  728,FEA
015D8:  MOVFF  727,FE9
015DC:  MOVFF  722,759
015E0:  MOVFF  721,758
015E4:  MOVFF  720,757
015E8:  MOVFF  71F,756
015EC:  MOVFF  03,75D
015F0:  MOVFF  02,75C
015F4:  MOVFF  01,75B
015F8:  MOVFF  00,75A
015FC:  RCALL  1138
015FE:  MOVFF  03,71C
01602:  MOVFF  02,71B
01606:  MOVFF  01,71A
0160A:  MOVFF  00,719
....................    
....................    PID[ch].CV = P + PID[ch].I + D;  // new control variable
0160E:  MOVLB  7
01610:  MOVF   x10,W
01612:  MULLW  28
01614:  MOVF   FF3,W
01616:  CLRF   x1E
01618:  MOVWF  x1D
0161A:  MOVLW  18
0161C:  ADDWF  x1D,W
0161E:  MOVWF  01
01620:  MOVLW  00
01622:  ADDWFC x1E,W
01624:  MOVWF  03
01626:  MOVF   01,W
01628:  ADDLW  20
0162A:  MOVWF  01
0162C:  MOVLW  00
0162E:  ADDWFC 03,F
01630:  MOVFF  01,71D
01634:  MOVFF  03,71E
01638:  MOVF   x10,W
0163A:  MULLW  28
0163C:  MOVF   FF3,W
0163E:  CLRF   x20
01640:  MOVWF  x1F
01642:  MOVLW  1C
01644:  ADDWF  x1F,W
01646:  MOVWF  01
01648:  MOVLW  00
0164A:  ADDWFC x20,W
0164C:  MOVWF  03
0164E:  MOVF   01,W
01650:  ADDLW  20
01652:  MOVWF  FE9
01654:  MOVLW  00
01656:  ADDWFC 03,W
01658:  MOVWF  FEA
0165A:  MOVFF  FEF,75E
0165E:  MOVFF  FEC,01
01662:  MOVFF  FEC,02
01666:  MOVFF  FEC,03
0166A:  MOVFF  FEA,720
0166E:  MOVFF  FE9,71F
01672:  BCF    FD8.1
01674:  MOVFF  718,75D
01678:  MOVFF  717,75C
0167C:  MOVFF  716,75B
01680:  MOVFF  715,75A
01684:  MOVFF  03,761
01688:  MOVFF  02,760
0168C:  MOVFF  01,75F
01690:  MOVLB  0
01692:  CALL   0DFE
01696:  MOVFF  720,FEA
0169A:  MOVFF  71F,FE9
0169E:  MOVFF  03,724
016A2:  MOVFF  02,723
016A6:  MOVFF  01,722
016AA:  MOVFF  00,721
016AE:  BCF    FD8.1
016B0:  MOVFF  03,75D
016B4:  MOVFF  02,75C
016B8:  MOVFF  01,75B
016BC:  MOVFF  00,75A
016C0:  MOVFF  71C,761
016C4:  MOVFF  71B,760
016C8:  MOVFF  71A,75F
016CC:  MOVFF  719,75E
016D0:  CALL   0DFE
016D4:  MOVFF  71E,FEA
016D8:  MOVFF  71D,FE9
016DC:  MOVFF  00,FEF
016E0:  MOVFF  01,FEC
016E4:  MOVFF  02,FEC
016E8:  MOVFF  03,FEC
....................    if (PID[ch].CV > op_upper_bound) PID[ch].CV = op_upper_bound; // limit positive output
016EC:  MOVLB  7
016EE:  MOVF   x10,W
016F0:  MULLW  28
016F2:  MOVF   FF3,W
016F4:  CLRF   x1E
016F6:  MOVWF  x1D
016F8:  MOVLW  18
016FA:  ADDWF  x1D,W
016FC:  MOVWF  01
016FE:  MOVLW  00
01700:  ADDWFC x1E,W
01702:  MOVWF  03
01704:  MOVF   01,W
01706:  ADDLW  20
01708:  MOVWF  FE9
0170A:  MOVLW  00
0170C:  ADDWFC 03,W
0170E:  MOVWF  FEA
01710:  MOVFF  FEF,75A
01714:  MOVFF  FEC,71E
01718:  MOVFF  FEC,75C
0171C:  MOVFF  FEC,75D
01720:  CLRF   x59
01722:  CLRF   x58
01724:  MOVLW  7C
01726:  MOVWF  x57
01728:  MOVLW  84
0172A:  MOVWF  x56
0172C:  MOVFF  71E,75B
01730:  MOVLB  0
01732:  CALL   0D84
01736:  BNC   176A
01738:  MOVLB  7
0173A:  MOVF   x10,W
0173C:  MULLW  28
0173E:  MOVF   FF3,W
01740:  CLRF   x1E
01742:  MOVWF  x1D
01744:  MOVLW  18
01746:  ADDWF  x1D,W
01748:  MOVWF  01
0174A:  MOVLW  00
0174C:  ADDWFC x1E,W
0174E:  MOVWF  03
01750:  MOVF   01,W
01752:  ADDLW  20
01754:  MOVWF  FE9
01756:  MOVLW  00
01758:  ADDWFC 03,W
0175A:  MOVWF  FEA
0175C:  MOVLW  84
0175E:  MOVWF  FEF
01760:  MOVLW  7C
01762:  MOVWF  FEC
01764:  CLRF   FEC
01766:  CLRF   FEC
01768:  BRA    17E6
....................    else if (PID[ch].CV < op_lower_bound) PID[ch].CV = op_lower_bound; // limit negative output
0176A:  MOVLB  7
0176C:  MOVF   x10,W
0176E:  MULLW  28
01770:  MOVF   FF3,W
01772:  CLRF   x1E
01774:  MOVWF  x1D
01776:  MOVLW  18
01778:  ADDWF  x1D,W
0177A:  MOVWF  01
0177C:  MOVLW  00
0177E:  ADDWFC x1E,W
01780:  MOVWF  03
01782:  MOVF   01,W
01784:  ADDLW  20
01786:  MOVWF  FE9
01788:  MOVLW  00
0178A:  ADDWFC 03,W
0178C:  MOVWF  FEA
0178E:  MOVFF  FEF,756
01792:  MOVFF  FEC,71E
01796:  MOVFF  FEC,758
0179A:  MOVFF  FEC,759
0179E:  MOVFF  71E,757
017A2:  CLRF   x5D
017A4:  CLRF   x5C
017A6:  MOVLW  C0
017A8:  MOVWF  x5B
017AA:  MOVLW  82
017AC:  MOVWF  x5A
017AE:  MOVLB  0
017B0:  CALL   0D84
017B4:  BNC   17E6
017B6:  MOVLB  7
017B8:  MOVF   x10,W
017BA:  MULLW  28
017BC:  MOVF   FF3,W
017BE:  CLRF   x1E
017C0:  MOVWF  x1D
017C2:  MOVLW  18
017C4:  ADDWF  x1D,W
017C6:  MOVWF  01
017C8:  MOVLW  00
017CA:  ADDWFC x1E,W
017CC:  MOVWF  03
017CE:  MOVF   01,W
017D0:  ADDLW  20
017D2:  MOVWF  FE9
017D4:  MOVLW  00
017D6:  ADDWFC 03,W
017D8:  MOVWF  FEA
017DA:  MOVLW  82
017DC:  MOVWF  FEF
017DE:  MOVLW  C0
017E0:  MOVWF  FEC
017E2:  CLRF   FEC
017E4:  CLRF   FEC
017E6:  MOVLB  0
017E8:  GOTO   1860 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PID Task - looks for change to PV and updates CV                          */
.................... /*****************************************************************************/
.................... void pid_task(channelMap ch){
....................    static int index = 0;
....................    if (PID[ch].SP != PID[ch].PV) pid_update(ch);
017EC:  MOVLB  7
017EE:  MOVF   x0F,W
017F0:  MULLW  28
017F2:  MOVF   FF3,W
017F4:  CLRF   x11
017F6:  MOVWF  x10
017F8:  MOVLW  0C
017FA:  ADDWF  x10,W
017FC:  MOVWF  01
017FE:  MOVLW  00
01800:  ADDWFC x11,W
01802:  MOVWF  03
01804:  MOVF   01,W
01806:  ADDLW  20
01808:  MOVWF  FE9
0180A:  MOVLW  00
0180C:  ADDWFC 03,W
0180E:  MOVWF  FEA
01810:  MOVFF  FEF,756
01814:  MOVFF  FEC,757
01818:  MOVFF  FEC,758
0181C:  MOVFF  FEC,759
01820:  MOVF   x0F,W
01822:  MULLW  28
01824:  MOVF   FF3,W
01826:  CLRF   x15
01828:  MOVWF  x14
0182A:  MOVLW  10
0182C:  ADDWF  x14,W
0182E:  MOVWF  01
01830:  MOVLW  00
01832:  ADDWFC x15,W
01834:  MOVWF  03
01836:  MOVF   01,W
01838:  ADDLW  20
0183A:  MOVWF  FE9
0183C:  MOVLW  00
0183E:  ADDWFC 03,W
01840:  MOVWF  FEA
01842:  MOVFF  FEF,75A
01846:  MOVFF  FEC,75B
0184A:  MOVFF  FEC,75C
0184E:  MOVFF  FEC,75D
01852:  MOVLB  0
01854:  CALL   0D84
01858:  BZ    1860
0185A:  MOVFF  70F,710
0185E:  BRA    126A
....................    if ((index++) >= numChannels) index = 0;
01860:  MOVLB  1
01862:  MOVF   xE9,W
01864:  INCF   xE9,F
01866:  SUBLW  01
01868:  BC    186C
0186A:  CLRF   xE9
0186C:  MOVLB  0
0186E:  GOTO   197E (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... #pin_select SCK1=PIN_C3
.................... #pin_select SDO1=PIN_C2
.................... #use spi (MASTER, SPI1, BAUD=100000, MODE=2, STREAM=SPI_ctrl)
*
00B24:  CLRF   03
00B26:  MOVF   F91,W
00B28:  MOVFF  711,F91
00B2C:  RRCF   F94,W
00B2E:  BNC   0B2C
00B30:  MOVF   F91,W
00B32:  MOVWF  02
00B34:  MOVFF  710,F91
00B38:  RRCF   F94,W
00B3A:  BNC   0B38
00B3C:  MOVF   F91,W
00B3E:  MOVWF  01
00B40:  MOVFF  70F,F91
00B44:  RRCF   F94,W
00B46:  BNC   0B44
00B48:  MOVFF  F91,00
00B4C:  RETURN 0
.................... 
.................... #define DACfullScale 655.35 // full scale/100 because CV = %
.................... 
.................... /*****************************************************************************/
.................... /*  Inverts the output voltage ( -180V - 0V )                                */ 
.................... /*****************************************************************************/
.................... void invert_voltage(channelMap ch, BOOLEAN inv_v){
....................    if ( inv_v ) {
*
010AC:  MOVLB  7
010AE:  MOVF   x10,F
010B0:  BZ    10F4
....................       if (chMap[0] == ch) output_low(INV_HVX);
010B2:  MOVLW  00
010B4:  MOVLB  0
010B6:  BTFSC  x70.0
010B8:  MOVLW  01
010BA:  MOVLB  7
010BC:  SUBWF  x0F,W
010BE:  BNZ   10C6
010C0:  MOVLW  C4
010C2:  MOVWF  F88
010C4:  BCF    F83.4
....................       if (chMap[1] == ch) output_low(INV_HVY);
010C6:  MOVLW  00
010C8:  MOVLB  0
010CA:  BTFSC  x70.1
010CC:  MOVLW  01
010CE:  MOVLB  7
010D0:  SUBWF  x0F,W
010D2:  BNZ   10DA
010D4:  MOVLW  C4
010D6:  MOVWF  F88
010D8:  BCF    F83.5
....................       dacVals[ch].invV = TRUE;
010DA:  MOVF   x0F,W
010DC:  MULLW  07
010DE:  MOVF   FF3,W
010E0:  CLRF   x12
010E2:  MOVWF  x11
010E4:  MOVLW  64
010E6:  ADDWF  x11,W
010E8:  MOVWF  FE9
010EA:  MOVLW  01
010EC:  ADDWFC x12,W
010EE:  MOVWF  FEA
010F0:  BSF    FEF.0
....................    }
010F2:  BRA    1134
....................    else {
....................       if (chMap[0] == ch) output_high(INV_HVX);
010F4:  MOVLW  00
010F6:  MOVLB  0
010F8:  BTFSC  x70.0
010FA:  MOVLW  01
010FC:  MOVLB  7
010FE:  SUBWF  x0F,W
01100:  BNZ   1108
01102:  MOVLW  C4
01104:  MOVWF  F88
01106:  BSF    F83.4
....................       if (chMap[1] == ch) output_high(INV_HVY);
01108:  MOVLW  00
0110A:  MOVLB  0
0110C:  BTFSC  x70.1
0110E:  MOVLW  01
01110:  MOVLB  7
01112:  SUBWF  x0F,W
01114:  BNZ   111C
01116:  MOVLW  C4
01118:  MOVWF  F88
0111A:  BSF    F83.5
....................       dacVals[ch].invV = FALSE;
0111C:  MOVF   x0F,W
0111E:  MULLW  07
01120:  MOVF   FF3,W
01122:  CLRF   x12
01124:  MOVWF  x11
01126:  MOVLW  64
01128:  ADDWF  x11,W
0112A:  MOVWF  FE9
0112C:  MOVLW  01
0112E:  ADDWFC x12,W
01130:  MOVWF  FEA
01132:  BCF    FEF.0
....................    }
01134:  MOVLB  0
01136:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  Nano DAC's have a 16bit serial shift register. Data is sync'ed to output */ 
.................... /*****************************************************************************/
.................... void set_nanoDAC_outputs(channelMap ch){
*
01872:  MOVLB  7
01874:  CLRF   x0E
01876:  CLRF   x0D
....................     unsigned int16 txData = 0;
....................    
....................     // use dacVals.opPcnt values if channel is manual mode
....................     // else, use PID control variable
....................     if (chMode[ch] == MANUAL){
01878:  MOVFF  70C,70F
0187C:  CLRF   x11
0187E:  MOVLW  71
01880:  MOVWF  x10
01882:  MOVLB  0
01884:  CALL   1076
01888:  MOVF   01,F
0188A:  BNZ   1978
....................         if ( dacVals[ch].opPcnt < 0) invert_voltage(ch, TRUE); 
0188C:  MOVLB  7
0188E:  MOVF   x0C,W
01890:  MULLW  07
01892:  MOVF   FF3,W
01894:  CLRF   x10
01896:  MOVWF  x0F
01898:  MOVLW  03
0189A:  ADDWF  x0F,W
0189C:  MOVWF  01
0189E:  MOVLW  00
018A0:  ADDWFC x10,W
018A2:  MOVWF  03
018A4:  MOVF   01,W
018A6:  ADDLW  64
018A8:  MOVWF  FE9
018AA:  MOVLW  01
018AC:  ADDWFC 03,W
018AE:  MOVWF  FEA
018B0:  MOVFF  FEF,756
018B4:  MOVFF  FEC,757
018B8:  MOVFF  FEC,758
018BC:  MOVFF  FEC,759
018C0:  CLRF   x5D
018C2:  CLRF   x5C
018C4:  CLRF   x5B
018C6:  CLRF   x5A
018C8:  MOVLB  0
018CA:  CALL   0D84
018CE:  BNC   18E2
018D0:  MOVFF  70C,70F
018D4:  MOVLW  01
018D6:  MOVLB  7
018D8:  MOVWF  x10
018DA:  MOVLB  0
018DC:  CALL   10AC
018E0:  BRA    18F0
....................         else                         invert_voltage(ch, FALSE);
018E2:  MOVFF  70C,70F
018E6:  MOVLB  7
018E8:  CLRF   x10
018EA:  MOVLB  0
018EC:  CALL   10AC
....................       
....................         txData = (unsigned int16)(abs(dacVals[ch].opPcnt) * DACfullScale);
018F0:  MOVLB  7
018F2:  MOVF   x0C,W
018F4:  MULLW  07
018F6:  MOVF   FF3,W
018F8:  CLRF   x10
018FA:  MOVWF  x0F
018FC:  MOVLW  03
018FE:  ADDWF  x0F,W
01900:  MOVWF  01
01902:  MOVLW  00
01904:  ADDWFC x10,W
01906:  MOVWF  03
01908:  MOVF   01,W
0190A:  ADDLW  64
0190C:  MOVWF  FE9
0190E:  MOVLW  01
01910:  ADDWFC 03,W
01912:  MOVWF  FEA
01914:  MOVFF  FEF,00
01918:  MOVFF  FEC,01
0191C:  MOVFF  FEC,02
01920:  MOVFF  FEC,03
01924:  BCF    01.7
01926:  MOVFF  03,712
0192A:  MOVFF  02,711
0192E:  MOVFF  01,710
01932:  MOVFF  00,70F
01936:  MOVFF  03,759
0193A:  MOVFF  02,758
0193E:  MOVFF  01,757
01942:  MOVFF  00,756
01946:  MOVLW  66
01948:  MOVWF  x5D
0194A:  MOVLW  D6
0194C:  MOVWF  x5C
0194E:  MOVLW  23
01950:  MOVWF  x5B
01952:  MOVLW  88
01954:  MOVWF  x5A
01956:  MOVLB  0
01958:  CALL   1138
0195C:  MOVFF  03,759
01960:  MOVFF  02,758
01964:  MOVFF  01,757
01968:  MOVFF  00,756
0196C:  RCALL  122E
0196E:  MOVFF  02,70E
01972:  MOVFF  01,70D
....................     }
01976:  BRA    1A6A
....................     else {
....................         pid_task(ch);
01978:  MOVFF  70C,70F
0197C:  BRA    17EC
....................         if ( PID[(int)ch].CV < 0 ) invert_voltage(ch, TRUE); 
0197E:  MOVLB  7
01980:  MOVF   x0C,W
01982:  MULLW  28
01984:  MOVF   FF3,W
01986:  CLRF   x10
01988:  MOVWF  x0F
0198A:  MOVLW  18
0198C:  ADDWF  x0F,W
0198E:  MOVWF  01
01990:  MOVLW  00
01992:  ADDWFC x10,W
01994:  MOVWF  03
01996:  MOVF   01,W
01998:  ADDLW  20
0199A:  MOVWF  FE9
0199C:  MOVLW  00
0199E:  ADDWFC 03,W
019A0:  MOVWF  FEA
019A2:  MOVFF  FEF,756
019A6:  MOVFF  FEC,757
019AA:  MOVFF  FEC,758
019AE:  MOVFF  FEC,759
019B2:  CLRF   x5D
019B4:  CLRF   x5C
019B6:  CLRF   x5B
019B8:  CLRF   x5A
019BA:  MOVLB  0
019BC:  CALL   0D84
019C0:  BNC   19D4
019C2:  MOVFF  70C,70F
019C6:  MOVLW  01
019C8:  MOVLB  7
019CA:  MOVWF  x10
019CC:  MOVLB  0
019CE:  CALL   10AC
019D2:  BRA    19E2
....................         else                       invert_voltage(ch, FALSE);
019D4:  MOVFF  70C,70F
019D8:  MOVLB  7
019DA:  CLRF   x10
019DC:  MOVLB  0
019DE:  CALL   10AC
....................       
....................         txData = (unsigned int16)(abs(PID[(int)ch].CV) * DACfullScale);
019E2:  MOVLB  7
019E4:  MOVF   x0C,W
019E6:  MULLW  28
019E8:  MOVF   FF3,W
019EA:  CLRF   x10
019EC:  MOVWF  x0F
019EE:  MOVLW  18
019F0:  ADDWF  x0F,W
019F2:  MOVWF  01
019F4:  MOVLW  00
019F6:  ADDWFC x10,W
019F8:  MOVWF  03
019FA:  MOVF   01,W
019FC:  ADDLW  20
019FE:  MOVWF  FE9
01A00:  MOVLW  00
01A02:  ADDWFC 03,W
01A04:  MOVWF  FEA
01A06:  MOVFF  FEF,00
01A0A:  MOVFF  FEC,01
01A0E:  MOVFF  FEC,02
01A12:  MOVFF  FEC,03
01A16:  BCF    01.7
01A18:  MOVFF  03,712
01A1C:  MOVFF  02,711
01A20:  MOVFF  01,710
01A24:  MOVFF  00,70F
01A28:  MOVFF  03,759
01A2C:  MOVFF  02,758
01A30:  MOVFF  01,757
01A34:  MOVFF  00,756
01A38:  MOVLW  66
01A3A:  MOVWF  x5D
01A3C:  MOVLW  D6
01A3E:  MOVWF  x5C
01A40:  MOVLW  23
01A42:  MOVWF  x5B
01A44:  MOVLW  88
01A46:  MOVWF  x5A
01A48:  MOVLB  0
01A4A:  CALL   1138
01A4E:  MOVFF  03,759
01A52:  MOVFF  02,758
01A56:  MOVFF  01,757
01A5A:  MOVFF  00,756
01A5E:  CALL   122E
01A62:  MOVFF  02,70E
01A66:  MOVFF  01,70D
....................     }
....................    
....................     dacVals[ch].ipVal = txData;
01A6A:  MOVLB  7
01A6C:  MOVF   x0C,W
01A6E:  MULLW  07
01A70:  MOVF   FF3,W
01A72:  CLRF   x10
01A74:  MOVWF  x0F
01A76:  MOVLW  01
01A78:  ADDWF  x0F,W
01A7A:  MOVWF  01
01A7C:  MOVLW  00
01A7E:  ADDWFC x10,W
01A80:  MOVWF  03
01A82:  MOVF   01,W
01A84:  ADDLW  64
01A86:  MOVWF  FE9
01A88:  MOVLW  01
01A8A:  ADDWFC 03,W
01A8C:  MOVWF  FEA
01A8E:  MOVFF  70E,FEC
01A92:  MOVF   FED,F
01A94:  MOVFF  70D,FEF
....................    
....................     // use channel map to decide which outputs channels to update
....................     // strobe _sync low to push data to the outputs
....................     if (chMap[0] == ch) output_high(_SYNC_X);
01A98:  MOVLW  00
01A9A:  MOVLB  0
01A9C:  BTFSC  x70.0
01A9E:  MOVLW  01
01AA0:  MOVLB  7
01AA2:  SUBWF  x0C,W
01AA4:  BNZ   1AAC
01AA6:  MOVLW  E8
01AA8:  MOVWF  F8B
01AAA:  BSF    F86.2
....................     if (chMap[1] == ch) output_high(_SYNC_Y);
01AAC:  MOVLW  00
01AAE:  MOVLB  0
01AB0:  BTFSC  x70.1
01AB2:  MOVLW  01
01AB4:  MOVLB  7
01AB6:  SUBWF  x0C,W
01AB8:  BNZ   1AC0
01ABA:  MOVLW  E8
01ABC:  MOVWF  F8B
01ABE:  BSF    F86.1
....................    
....................     delay_ms(1);
01AC0:  MOVLW  01
01AC2:  MOVWF  x0F
01AC4:  MOVLB  0
01AC6:  CALL   03A4
....................    
....................     if (chMap[0] == ch) output_low(_SYNC_X);
01ACA:  MOVLW  00
01ACC:  BTFSC  x70.0
01ACE:  MOVLW  01
01AD0:  MOVLB  7
01AD2:  SUBWF  x0C,W
01AD4:  BNZ   1ADC
01AD6:  MOVLW  E8
01AD8:  MOVWF  F8B
01ADA:  BCF    F86.2
....................     if (chMap[1] == ch) output_low(_SYNC_Y);
01ADC:  MOVLW  00
01ADE:  MOVLB  0
01AE0:  BTFSC  x70.1
01AE2:  MOVLW  01
01AE4:  MOVLB  7
01AE6:  SUBWF  x0C,W
01AE8:  BNZ   1AF0
01AEA:  MOVLW  E8
01AEC:  MOVWF  F8B
01AEE:  BCF    F86.1
....................     delay_ms(1);
01AF0:  MOVLW  01
01AF2:  MOVWF  x0F
01AF4:  MOVLB  0
01AF6:  CALL   03A4
....................    
....................     // shift 16 bits of data
....................     spi_xfer(SPI_ctrl, txData, 24);
01AFA:  MOVLB  7
01AFC:  CLRF   x12
01AFE:  CLRF   x11
01B00:  MOVFF  70E,710
01B04:  MOVFF  70D,70F
01B08:  MOVLB  0
01B0A:  CALL   0B24
....................     delay_ms(1);
01B0E:  MOVLW  01
01B10:  MOVLB  7
01B12:  MOVWF  x0F
01B14:  MOVLB  0
01B16:  CALL   03A4
....................    
....................     if (chMap[0] == ch) output_high(_SYNC_X);
01B1A:  MOVLW  00
01B1C:  BTFSC  x70.0
01B1E:  MOVLW  01
01B20:  MOVLB  7
01B22:  SUBWF  x0C,W
01B24:  BNZ   1B2C
01B26:  MOVLW  E8
01B28:  MOVWF  F8B
01B2A:  BSF    F86.2
....................     if (chMap[1] == ch) output_high(_SYNC_Y);
01B2C:  MOVLW  00
01B2E:  MOVLB  0
01B30:  BTFSC  x70.1
01B32:  MOVLW  01
01B34:  MOVLB  7
01B36:  SUBWF  x0C,W
01B38:  BNZ   1B40
01B3A:  MOVLW  E8
01B3C:  MOVWF  F8B
01B3E:  BSF    F86.1
01B40:  MOVLB  0
01B42:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  Axis homing routines and helper functions                                */ 
.................... /*****************************************************************************/
.................... void slew_to_upper_bound(channelMap ch){
....................     chMode[ch] = MANUAL;        // set channel to manual
01B44:  MOVFF  70B,722
01B48:  MOVLB  7
01B4A:  CLRF   x23
01B4C:  CLRF   x25
01B4E:  MOVLW  71
01B50:  MOVWF  x24
01B52:  MOVLB  0
01B54:  CALL   0D42
....................     
....................     while (dacVals[ch].opPcnt < op_upper_bound){
01B58:  MOVLB  7
01B5A:  MOVF   x0B,W
01B5C:  MULLW  07
01B5E:  MOVF   FF3,W
01B60:  CLRF   x0D
01B62:  MOVWF  x0C
01B64:  MOVLW  03
01B66:  ADDWF  x0C,W
01B68:  MOVWF  01
01B6A:  MOVLW  00
01B6C:  ADDWFC x0D,W
01B6E:  MOVWF  03
01B70:  MOVF   01,W
01B72:  ADDLW  64
01B74:  MOVWF  FE9
01B76:  MOVLW  01
01B78:  ADDWFC 03,W
01B7A:  MOVWF  FEA
01B7C:  MOVFF  FEF,756
01B80:  MOVFF  FEC,757
01B84:  MOVFF  FEC,758
01B88:  MOVFF  FEC,759
01B8C:  CLRF   x5D
01B8E:  CLRF   x5C
01B90:  MOVLW  7C
01B92:  MOVWF  x5B
01B94:  MOVLW  84
01B96:  MOVWF  x5A
01B98:  MOVLB  0
01B9A:  CALL   0D84
01B9E:  BNC   1C28
....................         dacVals[ch].opPcnt += 10;   // increase output by 10%
01BA0:  MOVLB  7
01BA2:  MOVF   x0B,W
01BA4:  MULLW  07
01BA6:  MOVF   FF3,W
01BA8:  CLRF   x0D
01BAA:  MOVWF  x0C
01BAC:  MOVLW  03
01BAE:  ADDWF  x0C,W
01BB0:  MOVWF  01
01BB2:  MOVLW  00
01BB4:  ADDWFC x0D,W
01BB6:  MOVWF  03
01BB8:  MOVF   01,W
01BBA:  ADDLW  64
01BBC:  MOVWF  FE9
01BBE:  MOVLW  01
01BC0:  ADDWFC 03,W
01BC2:  MOVWF  FEA
01BC4:  MOVFF  FEA,713
01BC8:  MOVFF  FE9,712
01BCC:  BCF    FD8.1
01BCE:  MOVFF  FEF,75A
01BD2:  MOVFF  FEC,75B
01BD6:  MOVFF  FEC,75C
01BDA:  MOVFF  FEC,75D
01BDE:  CLRF   x61
01BE0:  CLRF   x60
01BE2:  MOVLW  20
01BE4:  MOVWF  x5F
01BE6:  MOVLW  82
01BE8:  MOVWF  x5E
01BEA:  MOVLB  0
01BEC:  CALL   0DFE
01BF0:  MOVFF  713,FEA
01BF4:  MOVFF  712,FE9
01BF8:  MOVFF  00,FEF
01BFC:  MOVFF  01,FEC
01C00:  MOVFF  02,FEC
01C04:  MOVFF  03,FEC
....................         set_nanoDAC_outputs(ch);
01C08:  MOVFF  70B,70C
01C0C:  RCALL  1872
....................         delay_ms(500);
01C0E:  MOVLW  02
01C10:  MOVLB  7
01C12:  MOVWF  x0C
01C14:  MOVLW  FA
01C16:  MOVWF  x0F
01C18:  MOVLB  0
01C1A:  CALL   03A4
01C1E:  MOVLB  7
01C20:  DECFSZ x0C,F
01C22:  BRA    1C14
01C24:  BRA    1B5A
01C26:  MOVLB  0
....................     }
....................     dacVals[ch].opPcnt = op_upper_bound;    // set output to upper bound
01C28:  MOVLB  7
01C2A:  MOVF   x0B,W
01C2C:  MULLW  07
01C2E:  MOVF   FF3,W
01C30:  CLRF   x0D
01C32:  MOVWF  x0C
01C34:  MOVLW  03
01C36:  ADDWF  x0C,W
01C38:  MOVWF  01
01C3A:  MOVLW  00
01C3C:  ADDWFC x0D,W
01C3E:  MOVWF  03
01C40:  MOVF   01,W
01C42:  ADDLW  64
01C44:  MOVWF  FE9
01C46:  MOVLW  01
01C48:  ADDWFC 03,W
01C4A:  MOVWF  FEA
01C4C:  MOVLW  84
01C4E:  MOVWF  FEF
01C50:  MOVLW  7C
01C52:  MOVWF  FEC
01C54:  CLRF   FEC
01C56:  CLRF   FEC
....................     set_nanoDAC_outputs(ch);
01C58:  MOVFF  70B,70C
01C5C:  MOVLB  0
01C5E:  RCALL  1872
....................     delay_ms(500);
01C60:  MOVLW  02
01C62:  MOVLB  7
01C64:  MOVWF  x0C
01C66:  MOVLW  FA
01C68:  MOVWF  x0F
01C6A:  MOVLB  0
01C6C:  CALL   03A4
01C70:  MOVLB  7
01C72:  DECFSZ x0C,F
01C74:  BRA    1C66
01C76:  MOVLB  0
01C78:  RETURN 0
.................... }
.................... 
.................... void slew_to_lower_bound(channelMap ch){
....................     chMode[ch] = MANUAL;        // set channel to manual
01C7A:  MOVFF  70B,722
01C7E:  MOVLB  7
01C80:  CLRF   x23
01C82:  CLRF   x25
01C84:  MOVLW  71
01C86:  MOVWF  x24
01C88:  MOVLB  0
01C8A:  CALL   0D42
....................     
....................     while (dacVals[ch].opPcnt > op_lower_bound){
01C8E:  MOVLB  7
01C90:  MOVF   x0B,W
01C92:  MULLW  07
01C94:  MOVF   FF3,W
01C96:  CLRF   x0D
01C98:  MOVWF  x0C
01C9A:  MOVLW  03
01C9C:  ADDWF  x0C,W
01C9E:  MOVWF  01
01CA0:  MOVLW  00
01CA2:  ADDWFC x0D,W
01CA4:  MOVWF  03
01CA6:  MOVF   01,W
01CA8:  ADDLW  64
01CAA:  MOVWF  FE9
01CAC:  MOVLW  01
01CAE:  ADDWFC 03,W
01CB0:  MOVWF  FEA
01CB2:  MOVFF  FEF,75A
01CB6:  MOVFF  FEC,75B
01CBA:  MOVFF  FEC,75C
01CBE:  MOVFF  FEC,75D
01CC2:  CLRF   x59
01CC4:  CLRF   x58
01CC6:  MOVLW  C0
01CC8:  MOVWF  x57
01CCA:  MOVLW  82
01CCC:  MOVWF  x56
01CCE:  MOVLB  0
01CD0:  CALL   0D84
01CD4:  BNC   1D5E
....................         dacVals[ch].opPcnt -= 10;   // decrease output by 10%
01CD6:  MOVLB  7
01CD8:  MOVF   x0B,W
01CDA:  MULLW  07
01CDC:  MOVF   FF3,W
01CDE:  CLRF   x0D
01CE0:  MOVWF  x0C
01CE2:  MOVLW  03
01CE4:  ADDWF  x0C,W
01CE6:  MOVWF  01
01CE8:  MOVLW  00
01CEA:  ADDWFC x0D,W
01CEC:  MOVWF  03
01CEE:  MOVF   01,W
01CF0:  ADDLW  64
01CF2:  MOVWF  FE9
01CF4:  MOVLW  01
01CF6:  ADDWFC 03,W
01CF8:  MOVWF  FEA
01CFA:  MOVFF  FEA,713
01CFE:  MOVFF  FE9,712
01D02:  BSF    FD8.1
01D04:  MOVFF  FEF,75A
01D08:  MOVFF  FEC,75B
01D0C:  MOVFF  FEC,75C
01D10:  MOVFF  FEC,75D
01D14:  CLRF   x61
01D16:  CLRF   x60
01D18:  MOVLW  20
01D1A:  MOVWF  x5F
01D1C:  MOVLW  82
01D1E:  MOVWF  x5E
01D20:  MOVLB  0
01D22:  CALL   0DFE
01D26:  MOVFF  713,FEA
01D2A:  MOVFF  712,FE9
01D2E:  MOVFF  00,FEF
01D32:  MOVFF  01,FEC
01D36:  MOVFF  02,FEC
01D3A:  MOVFF  03,FEC
....................         set_nanoDAC_outputs(ch);
01D3E:  MOVFF  70B,70C
01D42:  RCALL  1872
....................         delay_ms(500);
01D44:  MOVLW  02
01D46:  MOVLB  7
01D48:  MOVWF  x0C
01D4A:  MOVLW  FA
01D4C:  MOVWF  x0F
01D4E:  MOVLB  0
01D50:  CALL   03A4
01D54:  MOVLB  7
01D56:  DECFSZ x0C,F
01D58:  BRA    1D4A
01D5A:  BRA    1C90
01D5C:  MOVLB  0
....................     }
....................     dacVals[ch].opPcnt = op_lower_bound;    // set output to lower bound
01D5E:  MOVLB  7
01D60:  MOVF   x0B,W
01D62:  MULLW  07
01D64:  MOVF   FF3,W
01D66:  CLRF   x0D
01D68:  MOVWF  x0C
01D6A:  MOVLW  03
01D6C:  ADDWF  x0C,W
01D6E:  MOVWF  01
01D70:  MOVLW  00
01D72:  ADDWFC x0D,W
01D74:  MOVWF  03
01D76:  MOVF   01,W
01D78:  ADDLW  64
01D7A:  MOVWF  FE9
01D7C:  MOVLW  01
01D7E:  ADDWFC 03,W
01D80:  MOVWF  FEA
01D82:  MOVLW  82
01D84:  MOVWF  FEF
01D86:  MOVLW  C0
01D88:  MOVWF  FEC
01D8A:  CLRF   FEC
01D8C:  CLRF   FEC
....................     set_nanoDAC_outputs(ch);
01D8E:  MOVFF  70B,70C
01D92:  MOVLB  0
01D94:  RCALL  1872
....................     delay_ms(500);
01D96:  MOVLW  02
01D98:  MOVLB  7
01D9A:  MOVWF  x0C
01D9C:  MOVLW  FA
01D9E:  MOVWF  x0F
01DA0:  MOVLB  0
01DA2:  CALL   03A4
01DA6:  MOVLB  7
01DA8:  DECFSZ x0C,F
01DAA:  BRA    1D9C
01DAC:  MOVLB  0
01DAE:  RETURN 0
.................... }
.................... 
.................... void home_axis(channelMap ch){
*
04CC0:  MOVLB  6
04CC2:  CLRF   xFF
04CC4:  CLRF   xFE
04CC6:  CLRF   xFD
04CC8:  CLRF   xFC
04CCA:  MOVLB  7
04CCC:  CLRF   x03
04CCE:  CLRF   x02
04CD0:  CLRF   x01
04CD2:  CLRF   x00
04CD4:  MOVLW  03
04CD6:  MOVWF  x04
....................     float maxSP = 0;
....................     float minSP = 0;
....................     int loops = 3;
....................     
....................     // Slew up and down a couple times then set output to 0 to settle the piezo
....................     slew_to_upper_bound(ch);
04CD8:  MOVFF  6FB,70B
04CDC:  MOVLB  0
04CDE:  CALL   1B44
....................     slew_to_lower_bound(ch);
04CE2:  MOVFF  6FB,70B
04CE6:  CALL   1C7A
....................     slew_to_upper_bound(ch);
04CEA:  MOVFF  6FB,70B
04CEE:  CALL   1B44
....................     slew_to_lower_bound(ch);
04CF2:  MOVFF  6FB,70B
04CF6:  CALL   1C7A
....................     dacVals[ch].opPcnt = 0;
04CFA:  MOVLB  6
04CFC:  MOVF   xFB,W
04CFE:  MULLW  07
04D00:  MOVF   FF3,W
04D02:  MOVLB  7
04D04:  CLRF   x07
04D06:  MOVWF  x06
04D08:  MOVLW  03
04D0A:  ADDWF  x06,W
04D0C:  MOVWF  01
04D0E:  MOVLW  00
04D10:  ADDWFC x07,W
04D12:  MOVWF  03
04D14:  MOVF   01,W
04D16:  ADDLW  64
04D18:  MOVWF  FE9
04D1A:  MOVLW  01
04D1C:  ADDWFC 03,W
04D1E:  MOVWF  FEA
04D20:  CLRF   FEF
04D22:  CLRF   FEC
04D24:  CLRF   FEC
04D26:  CLRF   FEC
....................     set_nanoDAC_outputs(ch);
04D28:  MOVFF  6FB,70C
04D2C:  MOVLB  0
04D2E:  CALL   1872
....................     delay_ms(500);
04D32:  MOVLW  02
04D34:  MOVLB  7
04D36:  MOVWF  x06
04D38:  MOVLW  FA
04D3A:  MOVWF  x0F
04D3C:  MOVLB  0
04D3E:  CALL   03A4
04D42:  MOVLB  7
04D44:  DECFSZ x06,F
04D46:  BRA    4D38
....................     
....................     for (int i=0; i<loops; i++){
04D48:  CLRF   x05
04D4A:  MOVF   x04,W
04D4C:  SUBWF  x05,W
04D4E:  BTFSC  FD8.0
04D50:  BRA    4E62
....................         slew_to_upper_bound(ch);
04D52:  MOVFF  6FB,70B
04D56:  MOVLB  0
04D58:  CALL   1B44
....................         sensor_monitor_task();
04D5C:  RCALL  4B10
....................         maxSP+=adcVals[ch].pReal;
04D5E:  MOVLB  6
04D60:  MOVF   xFB,W
04D62:  MULLW  26
04D64:  MOVF   FF3,W
04D66:  MOVLB  7
04D68:  CLRF   x07
04D6A:  MOVWF  x06
04D6C:  MOVLW  1D
04D6E:  ADDWF  x06,W
04D70:  MOVWF  01
04D72:  MOVLW  00
04D74:  ADDWFC x07,W
04D76:  MOVWF  03
04D78:  MOVF   01,W
04D7A:  ADDLW  17
04D7C:  MOVWF  FE9
04D7E:  MOVLW  01
04D80:  ADDWFC 03,W
04D82:  MOVWF  FEA
04D84:  MOVFF  FEF,75E
04D88:  MOVFF  FEC,01
04D8C:  MOVFF  FEC,02
04D90:  MOVFF  FEC,03
04D94:  MOVFF  FEA,707
04D98:  MOVFF  FE9,706
04D9C:  BCF    FD8.1
04D9E:  MOVFF  6FF,75D
04DA2:  MOVFF  6FE,75C
04DA6:  MOVFF  6FD,75B
04DAA:  MOVFF  6FC,75A
04DAE:  MOVFF  03,761
04DB2:  MOVFF  02,760
04DB6:  MOVFF  01,75F
04DBA:  MOVLB  0
04DBC:  CALL   0DFE
04DC0:  MOVFF  707,FEA
04DC4:  MOVFF  706,FE9
04DC8:  MOVFF  03,6FF
04DCC:  MOVFF  02,6FE
04DD0:  MOVFF  01,6FD
04DD4:  MOVFF  00,6FC
....................         
....................         slew_to_lower_bound(ch);
04DD8:  MOVFF  6FB,70B
04DDC:  CALL   1C7A
....................         sensor_monitor_task();
04DE0:  RCALL  4B10
....................         minSP+=adcVals[ch].pReal;
04DE2:  MOVLB  6
04DE4:  MOVF   xFB,W
04DE6:  MULLW  26
04DE8:  MOVF   FF3,W
04DEA:  MOVLB  7
04DEC:  CLRF   x07
04DEE:  MOVWF  x06
04DF0:  MOVLW  1D
04DF2:  ADDWF  x06,W
04DF4:  MOVWF  01
04DF6:  MOVLW  00
04DF8:  ADDWFC x07,W
04DFA:  MOVWF  03
04DFC:  MOVF   01,W
04DFE:  ADDLW  17
04E00:  MOVWF  FE9
04E02:  MOVLW  01
04E04:  ADDWFC 03,W
04E06:  MOVWF  FEA
04E08:  MOVFF  FEF,75E
04E0C:  MOVFF  FEC,01
04E10:  MOVFF  FEC,02
04E14:  MOVFF  FEC,03
04E18:  MOVFF  FEA,707
04E1C:  MOVFF  FE9,706
04E20:  BCF    FD8.1
04E22:  MOVFF  703,75D
04E26:  MOVFF  702,75C
04E2A:  MOVFF  701,75B
04E2E:  MOVFF  700,75A
04E32:  MOVFF  03,761
04E36:  MOVFF  02,760
04E3A:  MOVFF  01,75F
04E3E:  MOVLB  0
04E40:  CALL   0DFE
04E44:  MOVFF  707,FEA
04E48:  MOVFF  706,FE9
04E4C:  MOVFF  03,703
04E50:  MOVFF  02,702
04E54:  MOVFF  01,701
04E58:  MOVFF  00,700
04E5C:  MOVLB  7
04E5E:  INCF   x05,F
04E60:  BRA    4D4A
....................     }
....................     
....................     PID[ch].maxSP = maxSP / (float)loops;
04E62:  MOVLB  6
04E64:  MOVF   xFB,W
04E66:  MULLW  28
04E68:  MOVF   FF3,W
04E6A:  MOVLB  7
04E6C:  CLRF   x07
04E6E:  MOVWF  x06
04E70:  MOVLW  20
04E72:  ADDWF  x06,W
04E74:  MOVWF  01
04E76:  MOVLW  00
04E78:  ADDWFC x07,W
04E7A:  MOVWF  03
04E7C:  MOVF   01,W
04E7E:  ADDLW  20
04E80:  MOVWF  FE9
04E82:  MOVLW  00
04E84:  ADDWFC 03,W
04E86:  MOVWF  FEA
04E88:  CLRF   x5B
04E8A:  MOVFF  704,75A
04E8E:  MOVLB  0
04E90:  CALL   2DDA
04E94:  MOVFF  6FF,752
04E98:  MOVFF  6FE,751
04E9C:  MOVFF  6FD,750
04EA0:  MOVFF  6FC,74F
04EA4:  MOVFF  03,756
04EA8:  MOVFF  02,755
04EAC:  MOVFF  01,754
04EB0:  MOVFF  00,753
04EB4:  CALL   2450
04EB8:  MOVFF  00,FEF
04EBC:  MOVFF  01,FEC
04EC0:  MOVFF  02,FEC
04EC4:  MOVFF  03,FEC
....................     PID[ch].minSP = minSP / (float)loops;
04EC8:  MOVLB  6
04ECA:  MOVF   xFB,W
04ECC:  MULLW  28
04ECE:  MOVF   FF3,W
04ED0:  MOVLB  7
04ED2:  CLRF   x07
04ED4:  MOVWF  x06
04ED6:  MOVLW  24
04ED8:  ADDWF  x06,W
04EDA:  MOVWF  01
04EDC:  MOVLW  00
04EDE:  ADDWFC x07,W
04EE0:  MOVWF  03
04EE2:  MOVF   01,W
04EE4:  ADDLW  20
04EE6:  MOVWF  FE9
04EE8:  MOVLW  00
04EEA:  ADDWFC 03,W
04EEC:  MOVWF  FEA
04EEE:  CLRF   x5B
04EF0:  MOVFF  704,75A
04EF4:  MOVLB  0
04EF6:  CALL   2DDA
04EFA:  MOVFF  703,752
04EFE:  MOVFF  702,751
04F02:  MOVFF  701,750
04F06:  MOVFF  700,74F
04F0A:  MOVFF  03,756
04F0E:  MOVFF  02,755
04F12:  MOVFF  01,754
04F16:  MOVFF  00,753
04F1A:  CALL   2450
04F1E:  MOVFF  00,FEF
04F22:  MOVFF  01,FEC
04F26:  MOVFF  02,FEC
04F2A:  MOVFF  03,FEC
....................     adcVals[ch].pHome = (maxSP+minSP) / ((float)loops*2);
04F2E:  MOVLB  6
04F30:  MOVF   xFB,W
04F32:  MULLW  26
04F34:  MOVF   FF3,W
04F36:  MOVLB  7
04F38:  CLRF   x07
04F3A:  MOVWF  x06
04F3C:  MOVLW  21
04F3E:  ADDWF  x06,W
04F40:  MOVWF  01
04F42:  MOVLW  00
04F44:  ADDWFC x07,W
04F46:  MOVWF  03
04F48:  MOVF   01,W
04F4A:  ADDLW  17
04F4C:  MOVWF  FE9
04F4E:  MOVLW  01
04F50:  ADDWFC 03,W
04F52:  MOVWF  FEA
04F54:  MOVFF  FEA,709
04F58:  MOVFF  FE9,708
04F5C:  BCF    FD8.1
04F5E:  MOVFF  6FF,75D
04F62:  MOVFF  6FE,75C
04F66:  MOVFF  6FD,75B
04F6A:  MOVFF  6FC,75A
04F6E:  MOVFF  703,761
04F72:  MOVFF  702,760
04F76:  MOVFF  701,75F
04F7A:  MOVFF  700,75E
04F7E:  MOVLB  0
04F80:  CALL   0DFE
04F84:  MOVFF  709,FEA
04F88:  MOVFF  708,FE9
04F8C:  MOVFF  03,70D
04F90:  MOVFF  02,70C
04F94:  MOVFF  01,70B
04F98:  MOVFF  00,70A
04F9C:  MOVLB  7
04F9E:  CLRF   x5B
04FA0:  MOVFF  704,75A
04FA4:  MOVLB  0
04FA6:  CALL   2DDA
04FAA:  MOVFF  03,711
04FAE:  MOVFF  02,710
04FB2:  MOVFF  01,70F
04FB6:  MOVFF  00,70E
04FBA:  MOVFF  03,759
04FBE:  MOVFF  02,758
04FC2:  MOVFF  01,757
04FC6:  MOVFF  00,756
04FCA:  MOVLB  7
04FCC:  CLRF   x5D
04FCE:  CLRF   x5C
04FD0:  CLRF   x5B
04FD2:  MOVLW  80
04FD4:  MOVWF  x5A
04FD6:  MOVLB  0
04FD8:  CALL   1138
04FDC:  MOVFF  70D,752
04FE0:  MOVFF  70C,751
04FE4:  MOVFF  70B,750
04FE8:  MOVFF  70A,74F
04FEC:  MOVFF  03,756
04FF0:  MOVFF  02,755
04FF4:  MOVFF  01,754
04FF8:  MOVFF  00,753
04FFC:  CALL   2450
05000:  MOVFF  00,FEF
05004:  MOVFF  01,FEC
05008:  MOVFF  02,FEC
0500C:  MOVFF  03,FEC
....................     adcVals[ch].homeFlag = False;
05010:  MOVLB  6
05012:  MOVF   xFB,W
05014:  MULLW  26
05016:  MOVF   FF3,W
05018:  MOVLB  7
0501A:  CLRF   x07
0501C:  MOVWF  x06
0501E:  MOVLW  25
05020:  ADDWF  x06,W
05022:  MOVWF  01
05024:  MOVLW  00
05026:  ADDWFC x07,W
05028:  MOVWF  03
0502A:  MOVF   01,W
0502C:  ADDLW  17
0502E:  MOVWF  FE9
05030:  MOVLW  01
05032:  ADDWFC 03,W
05034:  MOVWF  FEA
05036:  BCF    FEF.0
05038:  MOVLB  0
0503A:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  control task sets up the outputs channels                                */ 
.................... /*****************************************************************************/
.................... void control_task(){
....................    static int state = 0;
....................    
....................    switch (state)
*
055E0:  MOVLB  1
055E2:  MOVF   xEA,W
055E4:  XORLW  00
055E6:  MOVLB  0
055E8:  BZ    55F0
055EA:  XORLW  01
055EC:  BZ    5604
055EE:  BRA    5616
....................    {
....................       case 0:
....................          set_nanoDAC_outputs(chX);
055F0:  MOVLB  7
055F2:  CLRF   x0C
055F4:  MOVLB  0
055F6:  CALL   1872
....................          state = 1;
055FA:  MOVLW  01
055FC:  MOVLB  1
055FE:  MOVWF  xEA
....................       break;
05600:  MOVLB  0
05602:  BRA    5616
....................       case 1:
....................          set_nanoDAC_outputs(chY);
05604:  MOVLW  01
05606:  MOVLB  7
05608:  MOVWF  x0C
0560A:  MOVLB  0
0560C:  CALL   1872
....................          state = 0;
05610:  MOVLB  1
05612:  CLRF   xEA
....................       break;
05614:  MOVLB  0
....................    }
05616:  GOTO   AD4C (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  control task sets up the outputs channels                                */ 
.................... /*****************************************************************************/
.................... void control_init(){
....................    spi_xfer(SPI_ctrl, 0, 24);
*
00B4E:  MOVLB  7
00B50:  CLRF   x12
00B52:  CLRF   x11
00B54:  CLRF   x10
00B56:  CLRF   x0F
00B58:  MOVLB  0
00B5A:  RCALL  0B24
....................    output_low(_SYNC_X);
00B5C:  MOVLW  E8
00B5E:  MOVWF  F8B
00B60:  BCF    F86.2
....................    output_low(_SYNC_Y);
00B62:  MOVWF  F8B
00B64:  BCF    F86.1
....................    output_high(_SYNC_X);
00B66:  MOVWF  F8B
00B68:  BSF    F86.2
....................    output_high(_SYNC_Y);
00B6A:  MOVWF  F8B
00B6C:  BSF    F86.1
00B6E:  GOTO   ACFC (RETURN)
.................... }
.................... #endif
.................... 
.................... #include <serialport.h>
.................... #ifndef serialPort
.................... #define serialPort
.................... #include <cmdBuffer.h>
.................... #ifndef cmd_buffer
.................... #define cmd_buffer
.................... 
.................... /*****************************************************************************/
.................... /* DIFCS COMMAND BUFFER                                                      */
.................... /* The beginning of a message is signified by an address record. The address */
.................... /* is 4 characters. The first 2 are the hardware identifier (TC - temperature*/
.................... /* controller, DC - difics controller, etc..) The second 2 characters dev-   */
.................... /* ice ID... Valid values are 00 thru 0F. A device ID of FF writes to all    */
.................... /* boards. This might be used to feed angles data to all listeners.          */
.................... /*****************************************************************************/
.................... 
.................... // t,p0,p1,p2,p3,p4,p5,p6
.................... // t is the start character, p0 is the address, p1 is command, p2-6 are params
.................... // these characters used for storing messages
.................... 
.................... #define startChr '~' // start character. Also diagnostic command type
.................... #define diagCmdType startChr
.................... #define endChr '\n'
.................... #define delimiter ','
.................... #define ignoreChr1 '\r'
.................... #define ignoreChr2 ' '
.................... #define noRecordFound (char)0xFF
.................... 
.................... #define numRecords 4
.................... #define numParam 7
.................... #define lenParam 25
.................... 
.................... #define useSerial
.................... //#define useTCPIP
.................... 
.................... typedef enum cmdMode {tcp, ser};
.................... 
.................... // this structure holds a command. This is used by the serial routine as well
.................... // as the TCP routine to store an incoming command + parameters
.................... // in the case of TCP socket id is also passed in this structure
.................... typedef struct cmd 
.................... {
....................    BOOLEAN full;        // if full, command is ready to execute
....................    unsigned int8 chrIndex;
....................    unsigned int8 paramIndex;
....................    unsigned int8 recReadIndex;
....................    unsigned int8 recWriteIndex;
....................    #ifdef useTCPIP
....................    TCP_SOCKET s;              // socket ID for TCP commands 
....................    #endif
....................    char t;
....................    char p[numParam][lenParam];   // only used with ~ type command
.................... };
.................... 
.................... #ifdef useSerial
.................... struct cmd SERcmd[numRecords]; // holds serial command 
.................... unsigned int8 SRI = 0; //usb readindex
.................... unsigned int8 SWI = 0; //usb write index
.................... #endif
.................... 
.................... #ifdef useTCPIP
.................... struct cmd TCPcmd[numRecords]; // holds TCP command
.................... unsigned int8 TRI = 0; //usb readindex
.................... unsigned int8 TWI = 0; //usb write index
.................... #endif
.................... 
.................... char retData[100]; // this is used to hold return data 
.................... 
.................... #ifdef useSerial
.................... /*****************************************************************************/
.................... /* RESET SER COMMAND -- ready for a new command                              */
.................... /*****************************************************************************/
.................... void resetSERcmd(unsigned int8 recNum)
.................... {
....................    if (recNum < numRecords)
00B72:  MOVLB  7
00B74:  MOVF   x01,W
00B76:  SUBLW  03
00B78:  BTFSS  FD8.0
00B7A:  BRA    0CE8
....................    {
....................       for (int i = 0; i <numParam; i ++)
00B7C:  CLRF   x02
00B7E:  MOVF   x02,W
00B80:  SUBLW  06
00B82:  BNC   0BD2
....................       {
....................          SERcmd[recNum].p[i][0] = '\0';
00B84:  CLRF   x47
00B86:  MOVFF  701,746
00B8A:  CLRF   x49
00B8C:  MOVLW  B5
00B8E:  MOVWF  x48
00B90:  MOVLB  0
00B92:  RCALL  0890
00B94:  MOVFF  02,704
00B98:  MOVFF  01,703
00B9C:  MOVLW  06
00B9E:  MOVLB  7
00BA0:  ADDWF  x03,F
00BA2:  MOVLW  00
00BA4:  ADDWFC x04,F
00BA6:  CLRF   x47
00BA8:  MOVFF  702,746
00BAC:  CLRF   x49
00BAE:  MOVLW  19
00BB0:  MOVWF  x48
00BB2:  MOVLB  0
00BB4:  RCALL  0890
00BB6:  MOVF   01,W
00BB8:  MOVLB  7
00BBA:  ADDWF  x03,F
00BBC:  MOVF   02,W
00BBE:  ADDWFC x04,F
00BC0:  MOVLW  EB
00BC2:  ADDWF  x03,W
00BC4:  MOVWF  FE9
00BC6:  MOVLW  01
00BC8:  ADDWFC x04,W
00BCA:  MOVWF  FEA
00BCC:  CLRF   FEF
00BCE:  INCF   x02,F
00BD0:  BRA    0B7E
....................       }
....................       SERcmd[recNum].t = 0;
00BD2:  CLRF   x47
00BD4:  MOVFF  701,746
00BD8:  CLRF   x49
00BDA:  MOVLW  B5
00BDC:  MOVWF  x48
00BDE:  MOVLB  0
00BE0:  RCALL  0890
00BE2:  MOVFF  01,703
00BE6:  MOVLW  05
00BE8:  MOVLB  7
00BEA:  ADDWF  01,W
00BEC:  MOVWF  01
00BEE:  MOVLW  00
00BF0:  ADDWFC 02,W
00BF2:  MOVWF  03
00BF4:  MOVF   01,W
00BF6:  ADDLW  EB
00BF8:  MOVWF  FE9
00BFA:  MOVLW  01
00BFC:  ADDWFC 03,W
00BFE:  MOVWF  FEA
00C00:  CLRF   FEF
....................       SERcmd[recNum].chrIndex = 0;
00C02:  CLRF   x47
00C04:  MOVFF  701,746
00C08:  CLRF   x49
00C0A:  MOVLW  B5
00C0C:  MOVWF  x48
00C0E:  MOVLB  0
00C10:  RCALL  0890
00C12:  MOVFF  01,703
00C16:  MOVLW  01
00C18:  MOVLB  7
00C1A:  ADDWF  01,W
00C1C:  MOVWF  01
00C1E:  MOVLW  00
00C20:  ADDWFC 02,W
00C22:  MOVWF  03
00C24:  MOVF   01,W
00C26:  ADDLW  EB
00C28:  MOVWF  FE9
00C2A:  MOVLW  01
00C2C:  ADDWFC 03,W
00C2E:  MOVWF  FEA
00C30:  CLRF   FEF
....................       SERcmd[recNum].paramIndex = 0;
00C32:  CLRF   x47
00C34:  MOVFF  701,746
00C38:  CLRF   x49
00C3A:  MOVLW  B5
00C3C:  MOVWF  x48
00C3E:  MOVLB  0
00C40:  RCALL  0890
00C42:  MOVFF  01,703
00C46:  MOVLW  02
00C48:  MOVLB  7
00C4A:  ADDWF  01,W
00C4C:  MOVWF  01
00C4E:  MOVLW  00
00C50:  ADDWFC 02,W
00C52:  MOVWF  03
00C54:  MOVF   01,W
00C56:  ADDLW  EB
00C58:  MOVWF  FE9
00C5A:  MOVLW  01
00C5C:  ADDWFC 03,W
00C5E:  MOVWF  FEA
00C60:  CLRF   FEF
....................       SERcmd[recNum].recReadIndex = 0;
00C62:  CLRF   x47
00C64:  MOVFF  701,746
00C68:  CLRF   x49
00C6A:  MOVLW  B5
00C6C:  MOVWF  x48
00C6E:  MOVLB  0
00C70:  RCALL  0890
00C72:  MOVFF  01,703
00C76:  MOVLW  03
00C78:  MOVLB  7
00C7A:  ADDWF  01,W
00C7C:  MOVWF  01
00C7E:  MOVLW  00
00C80:  ADDWFC 02,W
00C82:  MOVWF  03
00C84:  MOVF   01,W
00C86:  ADDLW  EB
00C88:  MOVWF  FE9
00C8A:  MOVLW  01
00C8C:  ADDWFC 03,W
00C8E:  MOVWF  FEA
00C90:  CLRF   FEF
....................       SERcmd[recNum].recWriteIndex = 0;
00C92:  CLRF   x47
00C94:  MOVFF  701,746
00C98:  CLRF   x49
00C9A:  MOVLW  B5
00C9C:  MOVWF  x48
00C9E:  MOVLB  0
00CA0:  RCALL  0890
00CA2:  MOVFF  01,703
00CA6:  MOVLW  04
00CA8:  MOVLB  7
00CAA:  ADDWF  01,W
00CAC:  MOVWF  01
00CAE:  MOVLW  00
00CB0:  ADDWFC 02,W
00CB2:  MOVWF  03
00CB4:  MOVF   01,W
00CB6:  ADDLW  EB
00CB8:  MOVWF  FE9
00CBA:  MOVLW  01
00CBC:  ADDWFC 03,W
00CBE:  MOVWF  FEA
00CC0:  CLRF   FEF
....................       SERcmd[recNum].full = FALSE;
00CC2:  CLRF   x47
00CC4:  MOVFF  701,746
00CC8:  CLRF   x49
00CCA:  MOVLW  B5
00CCC:  MOVWF  x48
00CCE:  MOVLB  0
00CD0:  RCALL  0890
00CD2:  MOVLW  EB
00CD4:  MOVLB  7
00CD6:  ADDWF  01,W
00CD8:  MOVWF  FE9
00CDA:  MOVLW  01
00CDC:  ADDWFC 02,W
00CDE:  MOVWF  FEA
00CE0:  BCF    FEF.0
....................       retData[0] = '\0';
00CE2:  MOVLB  4
00CE4:  CLRF   xC1
00CE6:  MOVLB  7
....................    }
00CE8:  MOVLB  0
00CEA:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next serial read index (SRI)                                          */
.................... /*****************************************************************************/
.................... BOOLEAN getNextSERReadIndex()
.................... {
....................    while (!SERcmd[SRI].full)
*
06064:  MOVLB  7
06066:  CLRF   x47
06068:  MOVFF  4BF,746
0606C:  CLRF   x49
0606E:  MOVLW  B5
06070:  MOVWF  x48
06072:  MOVLB  0
06074:  CALL   0890
06078:  MOVFF  02,702
0607C:  MOVFF  01,701
06080:  MOVLW  EB
06082:  MOVLB  7
06084:  ADDWF  01,W
06086:  MOVWF  FE9
06088:  MOVLW  01
0608A:  ADDWFC 02,W
0608C:  MOVWF  FEA
0608E:  BTFSC  FEF.0
06090:  BRA    60B2
....................    {
....................       if (SRI == SWI) return FALSE;
06092:  MOVLB  4
06094:  MOVF   xC0,W
06096:  SUBWF  xBF,W
06098:  BNZ   60A0
0609A:  MOVLW  00
0609C:  MOVWF  01
0609E:  BRA    60B8
....................       SRI +=1;
060A0:  MOVLW  01
060A2:  ADDWF  xBF,F
....................       if (SRI >= numRecords) SRI=0;
060A4:  MOVF   xBF,W
060A6:  SUBLW  03
060A8:  BC    60AC
060AA:  CLRF   xBF
060AC:  MOVLB  0
060AE:  BRA    6064
060B0:  MOVLB  7
....................    }
....................    return TRUE;
060B2:  MOVLW  01
060B4:  MOVWF  01
060B6:  MOVLB  4
060B8:  MOVLB  0
060BA:  GOTO   A7BC (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next serial write index (SWI)                                         */
.................... /*****************************************************************************/
.................... void setNextSERWriteIndex()
.................... {
....................    SWI +=1;
*
05652:  MOVLW  01
05654:  MOVLB  4
05656:  ADDWF  xC0,F
....................    if (SWI >= numRecords) SWI=0;
05658:  MOVF   xC0,W
0565A:  SUBLW  03
0565C:  BC    5660
0565E:  CLRF   xC0
05660:  MOVLB  0
05662:  RETURN 0
.................... }
.................... #endif
.................... 
.................... #ifdef useTCPIP
.................... /*****************************************************************************/
.................... /* RESET TCP COMMAND -- ready for a new command                              */
.................... /*****************************************************************************/
.................... void resetTCPcmd(unsigned int8 recNum)
.................... {
....................    if(recNum < numRecords)
....................    {
....................       for (int i = 0; i <numParam; i ++)
....................       {
....................          TCPcmd[recNum].p[i][0] = '\0';
....................       }
....................       TCPcmd[recNum].t = 0;
....................       TCPcmd[recNum].chrIndex = 0;
....................       TCPcmd[recNum].paramIndex = 0;
....................       TCPcmd[recNum].full = FALSE;
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next TCP read index (TRI)                                             */
.................... /*****************************************************************************/
.................... BOOLEAN getNextTCPReadIndex()
.................... {
....................    while (!TCPcmd[TRI].full)
....................    {
....................       if (TRI == TWI) return FALSE;
....................       TRI +=1;
....................       if (TRI >= numRecords) TRI=0;
....................    }
....................    return TRUE;
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next TCP write index (TWI)                                            */
.................... /*****************************************************************************/
.................... void setNextTCPWriteIndex()
.................... {
....................    TWI +=1;
....................    if (TWI >= numRecords) TWI=0;
.................... }
.................... #endif
.................... #endif
.................... 
.................... 
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
....................    output_b(portB_reset);
....................    output_c(portC_reset);
....................    output_d(portD_reset);
....................    output_e(portE_reset);
....................    
....................    port_a_pullups(portA_pullups);
....................    port_b_pullups(portB_pullups);
....................    port_c_pullups(portC_pullups);
....................    port_d_pullups(portD_pullups);
....................    port_e_pullups(portE_pullups);
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... #define use_RS485 // adds RX enable pin//
.................... 
.................... #define oneByteCmdTestValue 128
.................... #define UART_BUFFER_SIZE 60
.................... #define UART_EOT_CHAR1 0x0D //Carriage Return
.................... #define UART_EOT_CHAR2 0x0A //Line Feed
.................... #define UART_SOT_CHAR  '~' // START CHARACTER
.................... #define line_turnaround_char 0xFF
.................... 
.................... #bit UART_TXBuffer_Empty = 0x0FAC.1
.................... 
.................... char UART_BUFFER[UART_BUFFER_SIZE] = {0};
.................... unsigned int8 UART_WR_PTR = 0;
.................... unsigned int8 UART_RD_PTR = 0;
.................... boolean BYTES_AVAILABLE= FALSE;
.................... 
.................... #ifdef use_RS485
.................... #use rs232(baud=baudRate, xmit=TX_PIN, rcv=RX_PIN, stream=SERIAL, ERRORS)
*
000CA:  MOVLB  E
000CC:  BTFSS  xC8.5
000CE:  BRA    00CC
000D0:  MOVFF  F9C,563
000D4:  MOVLB  5
000D6:  MOVFF  F98,01
000DA:  BTFSS  x63.1
000DC:  BRA    00E2
000DE:  BCF    F9C.4
000E0:  BSF    F9C.4
000E2:  MOVLB  0
000E4:  GOTO   010C (RETURN)
.................... #else
.................... #use rs232(baud=baudRate, xmit=TX_PIN, rcv=RX_PIN, stream=SERIAL)
.................... #endif
.................... 
.................... // Message format: [SOT]addr ,cmd, arg1, arg2, arg3[EOT]} 
.................... // arguments are optional
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* SERIAL PRINTOUT                                                           */
.................... /*****************************************************************************/
.................... void serial_out(char* pBuff){
....................     output_high(TX_ENABLE);
*
0A76C:  MOVLW  93
0A76E:  MOVWF  F89
0A770:  BSF    F84.5
....................     delay_us(500);
0A772:  MOVLW  02
0A774:  MOVLB  7
0A776:  MOVWF  x03
0A778:  MOVLW  FA
0A77A:  MOVWF  x07
0A77C:  MOVLB  0
0A77E:  CALL   0720
0A782:  MOVLB  7
0A784:  DECFSZ x03,F
0A786:  BRA    A778
....................     
....................     fprintf(SERIAL, "%s", pBuff);
0A788:  MOVFF  702,FEA
0A78C:  MOVFF  701,FE9
0A790:  MOVLB  0
0A792:  CALL   5664
....................     delay_us(500);
0A796:  MOVLW  02
0A798:  MOVLB  7
0A79A:  MOVWF  x03
0A79C:  MOVLW  FA
0A79E:  MOVWF  x07
0A7A0:  MOVLB  0
0A7A2:  CALL   0720
0A7A6:  MOVLB  7
0A7A8:  DECFSZ x03,F
0A7AA:  BRA    A79C
....................     
....................     output_low(TX_ENABLE);
0A7AC:  MOVLW  93
0A7AE:  MOVWF  F89
0A7B0:  BCF    F84.5
0A7B2:  MOVLB  0
0A7B4:  GOTO   A8D4 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SERIAL PORT ISR                                                           */
.................... /*****************************************************************************/
.................... #INT_RDA
.................... void RX_isr()
*
000E8:  MOVLB  0
.................... {
....................    while (kbhit())
000EA:  MOVLB  E
000EC:  BTFSS  xC8.5
000EE:  BRA    0130
....................    {
....................       UART_BUFFER[UART_WR_PTR]=getch();
000F0:  CLRF   03
000F2:  MOVLB  5
000F4:  MOVF   x61,W
000F6:  ADDLW  25
000F8:  MOVWF  FE9
000FA:  MOVLW  05
000FC:  ADDWFC 03,W
000FE:  MOVWF  FEA
00100:  MOVFF  FEA,772
00104:  MOVFF  FE9,771
00108:  MOVLB  0
0010A:  BRA    00CA
0010C:  MOVFF  772,FEA
00110:  MOVFF  771,FE9
00114:  MOVFF  01,FEF
....................       UART_WR_PTR +=1;
00118:  MOVLW  01
0011A:  MOVLB  5
0011C:  ADDWF  x61,F
....................       if (UART_WR_PTR>=UART_BUFFER_SIZE) UART_WR_PTR=0;
0011E:  MOVF   x61,W
00120:  SUBLW  3B
00122:  BC    0126
00124:  CLRF   x61
....................       BYTES_AVAILABLE=TRUE;
00126:  MOVLB  1
00128:  BSF    x63.1
0012A:  MOVLB  0
0012C:  BRA    00EA
0012E:  MOVLB  E
....................    }
00130:  BCF    xC8.5
00132:  MOVLB  0
00134:  GOTO   006E
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get character from buffer                                                 */
.................... /*****************************************************************************/
.................... char getchFromBuffer()
*
0561A:  CLRF   03
0561C:  MOVLB  5
0561E:  MOVF   x62,W
05620:  ADDLW  25
05622:  MOVWF  FE9
05624:  MOVLW  05
05626:  ADDWFC 03,W
05628:  MOVWF  FEA
0562A:  MOVFF  FEF,6FC
.................... {
....................    char data = UART_BUFFER[UART_RD_PTR];
....................    UART_RD_PTR +=1;
0562E:  MOVLW  01
05630:  ADDWF  x62,F
....................    if (UART_RD_PTR>=UART_BUFFER_SIZE) UART_RD_PTR=0;
05632:  MOVF   x62,W
05634:  SUBLW  3B
05636:  BC    563A
05638:  CLRF   x62
....................    if (UART_RD_PTR == UART_WR_PTR) BYTES_AVAILABLE=FALSE;
0563A:  MOVF   x61,W
0563C:  SUBWF  x62,W
0563E:  BNZ   5646
05640:  MOVLB  1
05642:  BCF    x63.1
05644:  MOVLB  5
....................    return data;
05646:  MOVLB  6
05648:  MOVFF  6FC,01
0564C:  MOVLB  0
0564E:  GOTO   56D0 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Serial Task transfers bytes to command buffer                             */
.................... /*****************************************************************************/
.................... void serial_task()
.................... {
....................    while(BYTES_AVAILABLE && SERcmd[SWI].full==FALSE)
*
0568E:  MOVLB  1
05690:  BTFSS  x63.1
05692:  BRA    5BA0
05694:  MOVLB  7
05696:  CLRF   x47
05698:  MOVFF  4C0,746
0569C:  CLRF   x49
0569E:  MOVLW  B5
056A0:  MOVWF  x48
056A2:  MOVLB  0
056A4:  CALL   0890
056A8:  MOVFF  02,6FD
056AC:  MOVFF  01,6FC
056B0:  MOVLW  EB
056B2:  MOVLB  6
056B4:  ADDWF  01,W
056B6:  MOVWF  01
056B8:  MOVLW  01
056BA:  ADDWFC 02,W
056BC:  MOVWF  03
056BE:  MOVFF  01,FE9
056C2:  MOVWF  FEA
056C4:  BTFSS  FEF.0
056C6:  BRA    56CC
056C8:  MOVLB  1
056CA:  BRA    5BA0
....................    {  
....................       unsigned int8 rxChar = getchFromBuffer();
056CC:  MOVLB  0
056CE:  BRA    561A
056D0:  MOVFF  01,6FB
....................       if (rxChar == ignoreChr1 || rxChar == ignoreChr2)
056D4:  MOVLB  6
056D6:  MOVF   xFB,W
056D8:  SUBLW  0D
056DA:  BZ    56E2
056DC:  MOVF   xFB,W
056DE:  SUBLW  20
056E0:  BNZ   56E4
....................       {
....................       }
056E2:  BRA    5B9A
....................       else if (rxChar == UART_SOT_CHAR)
056E4:  MOVF   xFB,W
056E6:  SUBLW  7E
056E8:  BNZ   572C
....................       {
....................          resetSERcmd(SWI);
056EA:  MOVFF  4C0,701
056EE:  MOVLB  0
056F0:  CALL   0B72
....................          SERcmd[SWI].t = rxChar;
056F4:  MOVLB  7
056F6:  CLRF   x47
056F8:  MOVFF  4C0,746
056FC:  CLRF   x49
056FE:  MOVLW  B5
05700:  MOVWF  x48
05702:  MOVLB  0
05704:  CALL   0890
05708:  MOVFF  01,6FC
0570C:  MOVLW  05
0570E:  MOVLB  6
05710:  ADDWF  01,W
05712:  MOVWF  01
05714:  MOVLW  00
05716:  ADDWFC 02,W
05718:  MOVWF  03
0571A:  MOVF   01,W
0571C:  ADDLW  EB
0571E:  MOVWF  FE9
05720:  MOVLW  01
05722:  ADDWFC 03,W
05724:  MOVWF  FEA
05726:  MOVFF  6FB,FEF
....................       }
0572A:  BRA    5B9A
....................       else if (rxChar >= oneByteCmdTestValue)
0572C:  MOVF   xFB,W
0572E:  SUBLW  7F
05730:  BC    579E
....................       {
....................          resetSERcmd(SWI);
05732:  MOVFF  4C0,701
05736:  MOVLB  0
05738:  CALL   0B72
....................          SERcmd[SWI].t = rxChar;
0573C:  MOVLB  7
0573E:  CLRF   x47
05740:  MOVFF  4C0,746
05744:  CLRF   x49
05746:  MOVLW  B5
05748:  MOVWF  x48
0574A:  MOVLB  0
0574C:  CALL   0890
05750:  MOVFF  01,6FC
05754:  MOVLW  05
05756:  MOVLB  6
05758:  ADDWF  01,W
0575A:  MOVWF  01
0575C:  MOVLW  00
0575E:  ADDWFC 02,W
05760:  MOVWF  03
05762:  MOVF   01,W
05764:  ADDLW  EB
05766:  MOVWF  FE9
05768:  MOVLW  01
0576A:  ADDWFC 03,W
0576C:  MOVWF  FEA
0576E:  MOVFF  6FB,FEF
....................          SERcmd[SWI].full = TRUE;
05772:  MOVLB  7
05774:  CLRF   x47
05776:  MOVFF  4C0,746
0577A:  CLRF   x49
0577C:  MOVLW  B5
0577E:  MOVWF  x48
05780:  MOVLB  0
05782:  CALL   0890
05786:  MOVLW  EB
05788:  MOVLB  6
0578A:  ADDWF  01,W
0578C:  MOVWF  FE9
0578E:  MOVLW  01
05790:  ADDWFC 02,W
05792:  MOVWF  FEA
05794:  BSF    FEF.0
....................          setNextSERWriteIndex();
05796:  MOVLB  0
05798:  RCALL  5652
....................       }
0579A:  BRA    5B98
0579C:  MOVLB  6
....................       else if (rxChar == UART_EOT_CHAR2)
0579E:  MOVF   xFB,W
057A0:  SUBLW  0A
057A2:  BTFSS  FD8.2
057A4:  BRA    58B2
....................       {
....................          SERcmd[SWI].full = TRUE;
057A6:  MOVLB  7
057A8:  CLRF   x47
057AA:  MOVFF  4C0,746
057AE:  CLRF   x49
057B0:  MOVLW  B5
057B2:  MOVWF  x48
057B4:  MOVLB  0
057B6:  CALL   0890
057BA:  MOVLW  EB
057BC:  MOVLB  6
057BE:  ADDWF  01,W
057C0:  MOVWF  FE9
057C2:  MOVLW  01
057C4:  ADDWFC 02,W
057C6:  MOVWF  FEA
057C8:  BSF    FEF.0
....................          SERcmd[SWI].recWriteIndex = SERcmd[SWI].paramIndex;
057CA:  MOVLB  7
057CC:  CLRF   x47
057CE:  MOVFF  4C0,746
057D2:  CLRF   x49
057D4:  MOVLW  B5
057D6:  MOVWF  x48
057D8:  MOVLB  0
057DA:  CALL   0890
057DE:  MOVFF  01,6FC
057E2:  MOVLW  04
057E4:  ADDWF  01,W
057E6:  MOVWF  01
057E8:  MOVLW  00
057EA:  ADDWFC 02,W
057EC:  MOVWF  03
057EE:  MOVF   01,W
057F0:  ADDLW  EB
057F2:  MOVWF  01
057F4:  MOVLW  01
057F6:  ADDWFC 03,F
057F8:  MOVFF  01,6FC
057FC:  MOVFF  03,6FD
05800:  MOVLB  7
05802:  CLRF   x47
05804:  MOVFF  4C0,746
05808:  CLRF   x49
0580A:  MOVLW  B5
0580C:  MOVWF  x48
0580E:  MOVLB  0
05810:  CALL   0890
05814:  MOVFF  01,6FE
05818:  MOVLW  02
0581A:  MOVLB  6
0581C:  ADDWF  01,W
0581E:  MOVWF  01
05820:  MOVLW  00
05822:  ADDWFC 02,W
05824:  MOVWF  03
05826:  MOVF   01,W
05828:  ADDLW  EB
0582A:  MOVWF  FE9
0582C:  MOVLW  01
0582E:  ADDWFC 03,W
05830:  MOVWF  FEA
05832:  MOVFF  FEF,6FE
05836:  MOVFF  6FD,FEA
0583A:  MOVFF  6FC,FE9
0583E:  MOVFF  6FE,FEF
....................          SERcmd[SWI].chrIndex = 0;
05842:  MOVLB  7
05844:  CLRF   x47
05846:  MOVFF  4C0,746
0584A:  CLRF   x49
0584C:  MOVLW  B5
0584E:  MOVWF  x48
05850:  MOVLB  0
05852:  CALL   0890
05856:  MOVFF  01,6FC
0585A:  MOVLW  01
0585C:  MOVLB  6
0585E:  ADDWF  01,W
05860:  MOVWF  01
05862:  MOVLW  00
05864:  ADDWFC 02,W
05866:  MOVWF  03
05868:  MOVF   01,W
0586A:  ADDLW  EB
0586C:  MOVWF  FE9
0586E:  MOVLW  01
05870:  ADDWFC 03,W
05872:  MOVWF  FEA
05874:  CLRF   FEF
....................          SERcmd[SWI].paramIndex = 0;
05876:  MOVLB  7
05878:  CLRF   x47
0587A:  MOVFF  4C0,746
0587E:  CLRF   x49
05880:  MOVLW  B5
05882:  MOVWF  x48
05884:  MOVLB  0
05886:  CALL   0890
0588A:  MOVFF  01,6FC
0588E:  MOVLW  02
05890:  MOVLB  6
05892:  ADDWF  01,W
05894:  MOVWF  01
05896:  MOVLW  00
05898:  ADDWFC 02,W
0589A:  MOVWF  03
0589C:  MOVF   01,W
0589E:  ADDLW  EB
058A0:  MOVWF  FE9
058A2:  MOVLW  01
058A4:  ADDWFC 03,W
058A6:  MOVWF  FEA
058A8:  CLRF   FEF
....................          setNextSERWriteIndex();
058AA:  MOVLB  0
058AC:  RCALL  5652
....................       }
058AE:  BRA    5B98
058B0:  MOVLB  6
....................       else if (rxChar == delimiter)
058B2:  MOVF   xFB,W
058B4:  SUBLW  2C
058B6:  BNZ   597A
....................       {
....................          if (SERcmd[SWI].paramIndex < numParam-1)
058B8:  MOVLB  7
058BA:  CLRF   x47
058BC:  MOVFF  4C0,746
058C0:  CLRF   x49
058C2:  MOVLW  B5
058C4:  MOVWF  x48
058C6:  MOVLB  0
058C8:  CALL   0890
058CC:  MOVFF  02,6FD
058D0:  MOVFF  01,6FC
058D4:  MOVLW  02
058D6:  MOVLB  6
058D8:  ADDWF  01,W
058DA:  MOVWF  01
058DC:  MOVLW  00
058DE:  ADDWFC 02,W
058E0:  MOVWF  03
058E2:  MOVF   01,W
058E4:  ADDLW  EB
058E6:  MOVWF  FE9
058E8:  MOVLW  01
058EA:  ADDWFC 03,W
058EC:  MOVWF  FEA
058EE:  MOVF   FEF,W
058F0:  SUBLW  05
058F2:  BNC   5962
....................          {
....................             SERcmd[SWI].paramIndex +=1;
058F4:  MOVLB  7
058F6:  CLRF   x47
058F8:  MOVFF  4C0,746
058FC:  CLRF   x49
058FE:  MOVLW  B5
05900:  MOVWF  x48
05902:  MOVLB  0
05904:  CALL   0890
05908:  MOVFF  01,6FC
0590C:  MOVLW  02
0590E:  MOVLB  6
05910:  ADDWF  01,W
05912:  MOVWF  01
05914:  MOVLW  00
05916:  ADDWFC 02,W
05918:  MOVWF  03
0591A:  MOVF   01,W
0591C:  ADDLW  EB
0591E:  MOVWF  FE9
05920:  MOVLW  01
05922:  ADDWFC 03,W
05924:  MOVWF  FEA
05926:  MOVLW  01
05928:  ADDWF  FEF,W
0592A:  MOVWF  FEF
....................             SERcmd[SWI].chrIndex = 0;
0592C:  MOVLB  7
0592E:  CLRF   x47
05930:  MOVFF  4C0,746
05934:  CLRF   x49
05936:  MOVLW  B5
05938:  MOVWF  x48
0593A:  MOVLB  0
0593C:  CALL   0890
05940:  MOVFF  01,6FC
05944:  MOVLW  01
05946:  MOVLB  6
05948:  ADDWF  01,W
0594A:  MOVWF  01
0594C:  MOVLW  00
0594E:  ADDWFC 02,W
05950:  MOVWF  03
05952:  MOVF   01,W
05954:  ADDLW  EB
05956:  MOVWF  FE9
05958:  MOVLW  01
0595A:  ADDWFC 03,W
0595C:  MOVWF  FEA
0595E:  CLRF   FEF
....................          }
05960:  BRA    5978
....................          else
....................          {
....................             resetSERcmd(SWI); // exceed number of params... reset capture
05962:  MOVFF  4C0,701
05966:  MOVLB  0
05968:  CALL   0B72
....................             fprintf(SERIAL, retData);
0596C:  MOVLW  04
0596E:  MOVWF  FEA
05970:  MOVLW  C1
05972:  MOVWF  FE9
05974:  RCALL  5664
05976:  MOVLB  6
....................          }
....................       }
05978:  BRA    5B9A
....................       
....................       else
....................       {
....................          if (SERcmd[SWI].chrIndex < lenParam)
0597A:  MOVLB  7
0597C:  CLRF   x47
0597E:  MOVFF  4C0,746
05982:  CLRF   x49
05984:  MOVLW  B5
05986:  MOVWF  x48
05988:  MOVLB  0
0598A:  CALL   0890
0598E:  MOVFF  02,6FD
05992:  MOVFF  01,6FC
05996:  MOVLW  01
05998:  MOVLB  6
0599A:  ADDWF  01,W
0599C:  MOVWF  01
0599E:  MOVLW  00
059A0:  ADDWFC 02,W
059A2:  MOVWF  03
059A4:  MOVF   01,W
059A6:  ADDLW  EB
059A8:  MOVWF  FE9
059AA:  MOVLW  01
059AC:  ADDWFC 03,W
059AE:  MOVWF  FEA
059B0:  MOVF   FEF,W
059B2:  SUBLW  18
059B4:  BTFSS  FD8.0
059B6:  BRA    5B84
....................          {
....................             SERcmd[SWI].p[SERcmd[SWI].paramIndex][SERcmd[SWI].chrIndex] = rxChar;
059B8:  MOVLB  7
059BA:  CLRF   x47
059BC:  MOVFF  4C0,746
059C0:  CLRF   x49
059C2:  MOVLW  B5
059C4:  MOVWF  x48
059C6:  MOVLB  0
059C8:  CALL   0890
059CC:  MOVFF  02,6FD
059D0:  MOVFF  01,6FC
059D4:  MOVLW  06
059D6:  MOVLB  6
059D8:  ADDWF  xFC,F
059DA:  MOVLW  00
059DC:  ADDWFC xFD,F
059DE:  MOVLB  7
059E0:  CLRF   x47
059E2:  MOVFF  4C0,746
059E6:  CLRF   x49
059E8:  MOVLW  B5
059EA:  MOVWF  x48
059EC:  MOVLB  0
059EE:  CALL   0890
059F2:  MOVFF  02,6FF
059F6:  MOVFF  01,6FE
059FA:  MOVLW  02
059FC:  ADDWF  01,W
059FE:  MOVWF  01
05A00:  MOVLW  00
05A02:  ADDWFC 02,W
05A04:  MOVWF  03
05A06:  MOVF   01,W
05A08:  ADDLW  EB
05A0A:  MOVWF  FE9
05A0C:  MOVLW  01
05A0E:  ADDWFC 03,W
05A10:  MOVWF  FEA
05A12:  MOVLB  7
05A14:  CLRF   x47
05A16:  MOVFF  FEF,746
05A1A:  CLRF   x49
05A1C:  MOVLW  19
05A1E:  MOVWF  x48
05A20:  MOVLB  0
05A22:  CALL   0890
05A26:  MOVFF  02,03
05A2A:  MOVF   01,W
05A2C:  MOVLB  6
05A2E:  ADDWF  xFC,F
05A30:  MOVF   02,W
05A32:  ADDWFC xFD,F
05A34:  MOVLB  7
05A36:  CLRF   x47
05A38:  MOVFF  4C0,746
05A3C:  CLRF   x49
05A3E:  MOVLW  B5
05A40:  MOVWF  x48
05A42:  MOVLB  0
05A44:  CALL   0890
05A48:  MOVFF  01,6FE
05A4C:  MOVLW  01
05A4E:  MOVLB  6
05A50:  ADDWF  01,W
05A52:  MOVWF  01
05A54:  MOVLW  00
05A56:  ADDWFC 02,W
05A58:  MOVWF  03
05A5A:  MOVF   01,W
05A5C:  ADDLW  EB
05A5E:  MOVWF  FE9
05A60:  MOVLW  01
05A62:  ADDWFC 03,W
05A64:  MOVWF  FEA
05A66:  MOVF   FEF,W
05A68:  ADDWF  xFC,W
05A6A:  MOVWF  01
05A6C:  MOVLW  00
05A6E:  ADDWFC xFD,W
05A70:  MOVWF  03
05A72:  MOVF   01,W
05A74:  ADDLW  EB
05A76:  MOVWF  FE9
05A78:  MOVLW  01
05A7A:  ADDWFC 03,W
05A7C:  MOVWF  FEA
05A7E:  MOVFF  6FB,FEF
....................             SERcmd[SWI].chrIndex += 1;
05A82:  MOVLB  7
05A84:  CLRF   x47
05A86:  MOVFF  4C0,746
05A8A:  CLRF   x49
05A8C:  MOVLW  B5
05A8E:  MOVWF  x48
05A90:  MOVLB  0
05A92:  CALL   0890
05A96:  MOVFF  01,6FC
05A9A:  MOVLW  01
05A9C:  MOVLB  6
05A9E:  ADDWF  01,W
05AA0:  MOVWF  01
05AA2:  MOVLW  00
05AA4:  ADDWFC 02,W
05AA6:  MOVWF  03
05AA8:  MOVF   01,W
05AAA:  ADDLW  EB
05AAC:  MOVWF  FE9
05AAE:  MOVLW  01
05AB0:  ADDWFC 03,W
05AB2:  MOVWF  FEA
05AB4:  MOVLW  01
05AB6:  ADDWF  FEF,W
05AB8:  MOVWF  FEF
....................             SERcmd[SWI].p[SERcmd[SWI].paramIndex][SERcmd[SWI].chrIndex] = '\0';
05ABA:  MOVLB  7
05ABC:  CLRF   x47
05ABE:  MOVFF  4C0,746
05AC2:  CLRF   x49
05AC4:  MOVLW  B5
05AC6:  MOVWF  x48
05AC8:  MOVLB  0
05ACA:  CALL   0890
05ACE:  MOVFF  02,6FD
05AD2:  MOVFF  01,6FC
05AD6:  MOVLW  06
05AD8:  MOVLB  6
05ADA:  ADDWF  xFC,F
05ADC:  MOVLW  00
05ADE:  ADDWFC xFD,F
05AE0:  MOVLB  7
05AE2:  CLRF   x47
05AE4:  MOVFF  4C0,746
05AE8:  CLRF   x49
05AEA:  MOVLW  B5
05AEC:  MOVWF  x48
05AEE:  MOVLB  0
05AF0:  CALL   0890
05AF4:  MOVFF  02,6FF
05AF8:  MOVFF  01,6FE
05AFC:  MOVLW  02
05AFE:  ADDWF  01,W
05B00:  MOVWF  01
05B02:  MOVLW  00
05B04:  ADDWFC 02,W
05B06:  MOVWF  03
05B08:  MOVF   01,W
05B0A:  ADDLW  EB
05B0C:  MOVWF  FE9
05B0E:  MOVLW  01
05B10:  ADDWFC 03,W
05B12:  MOVWF  FEA
05B14:  MOVLB  7
05B16:  CLRF   x47
05B18:  MOVFF  FEF,746
05B1C:  CLRF   x49
05B1E:  MOVLW  19
05B20:  MOVWF  x48
05B22:  MOVLB  0
05B24:  CALL   0890
05B28:  MOVFF  02,03
05B2C:  MOVF   01,W
05B2E:  MOVLB  6
05B30:  ADDWF  xFC,F
05B32:  MOVF   02,W
05B34:  ADDWFC xFD,F
05B36:  MOVLB  7
05B38:  CLRF   x47
05B3A:  MOVFF  4C0,746
05B3E:  CLRF   x49
05B40:  MOVLW  B5
05B42:  MOVWF  x48
05B44:  MOVLB  0
05B46:  CALL   0890
05B4A:  MOVFF  01,6FE
05B4E:  MOVLW  01
05B50:  MOVLB  6
05B52:  ADDWF  01,W
05B54:  MOVWF  01
05B56:  MOVLW  00
05B58:  ADDWFC 02,W
05B5A:  MOVWF  03
05B5C:  MOVF   01,W
05B5E:  ADDLW  EB
05B60:  MOVWF  FE9
05B62:  MOVLW  01
05B64:  ADDWFC 03,W
05B66:  MOVWF  FEA
05B68:  MOVF   FEF,W
05B6A:  ADDWF  xFC,W
05B6C:  MOVWF  01
05B6E:  MOVLW  00
05B70:  ADDWFC xFD,W
05B72:  MOVWF  03
05B74:  MOVF   01,W
05B76:  ADDLW  EB
05B78:  MOVWF  FE9
05B7A:  MOVLW  01
05B7C:  ADDWFC 03,W
05B7E:  MOVWF  FEA
05B80:  CLRF   FEF
....................          }
05B82:  BRA    5B9A
....................          else
....................          {
....................             resetSERcmd(SWI); // exceed number of characters... reset capture
05B84:  MOVFF  4C0,701
05B88:  MOVLB  0
05B8A:  CALL   0B72
....................             fprintf(SERIAL, retData);
05B8E:  MOVLW  04
05B90:  MOVWF  FEA
05B92:  MOVLW  C1
05B94:  MOVWF  FE9
05B96:  RCALL  5664
05B98:  MOVLB  6
....................          }
....................       }
05B9A:  MOVLB  0
05B9C:  BRA    568E
05B9E:  MOVLB  1
....................    }          
05BA0:  MOVLB  0
05BA2:  GOTO   AD60 (RETURN)
.................... }
....................            
.................... /*****************************************************************************/
.................... /* serialInit ROUTINE  - Sets up serial port                                 */
.................... /*****************************************************************************/ 
.................... void serial_init()
.................... {
....................    for (int i = 0; i < numRecords; i++) 
*
00CEC:  MOVLB  6
00CEE:  CLRF   xFB
00CF0:  MOVF   xFB,W
00CF2:  SUBLW  03
00CF4:  BNC   0D04
....................    {
....................       resetSERcmd(i);
00CF6:  MOVFF  6FB,701
00CFA:  MOVLB  0
00CFC:  RCALL  0B72
00CFE:  MOVLB  6
00D00:  INCF   xFB,F
00D02:  BRA    0CF0
....................    }
....................    enable_interrupts(INT_RDA);
00D04:  MOVLB  E
00D06:  BSF    xC0.5
00D08:  MOVLB  0
00D0A:  GOTO   AD00 (RETURN)
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #include <pid.h>
.................... #ifndef pidcontroller
.................... #define pidcontroller
.................... #include <parameters.h>
.................... #include <math.h>
.................... 
.................... /*****************************************************************************/
.................... /* UPDATE the Control Variable (CV)                                          */
.................... /*****************************************************************************/
.................... void pid_update (channelMap ch){
....................    float err = PID[ch].SP - PID[ch].PV;  // error = set value - measured
....................    
....................    PID[ch].I += err*PID[ch].kI;
....................    if (PID[ch].I > op_upper_bound) PID[ch].I = op_upper_bound; // anti-windup
....................    else if (PID[ch].I < op_lower_bound) PID[ch].I = op_lower_bound;
....................    
....................    float P = err * PID[ch].kP;  // proportional value
....................    
....................    float D = PID[ch].kD * (PID[ch].PV - PID[ch].PVold);  // derivative value
....................    
....................    PID[ch].CV = P + PID[ch].I + D;  // new control variable
....................    if (PID[ch].CV > op_upper_bound) PID[ch].CV = op_upper_bound; // limit positive output
....................    else if (PID[ch].CV < op_lower_bound) PID[ch].CV = op_lower_bound; // limit negative output
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PID Task - looks for change to PV and updates CV                          */
.................... /*****************************************************************************/
.................... void pid_task(channelMap ch){
....................    static int index = 0;
....................    if (PID[ch].SP != PID[ch].PV) pid_update(ch);
....................    if ((index++) >= numChannels) index = 0;
.................... }
.................... 
.................... #endif
.................... 
.................... #include <eventTimer.h>
.................... #ifndef timeout
.................... #define timeout
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................     float kP;      // proportional gain
....................     float kI;      // integral gain
....................     float kD;      // derivative gain
....................     float SP;      // set point-- desired output
....................     float PV;      // process variable-- measured output
....................     float PVold;   // oldPV value  
....................     float CV;      // control variable-- output -- 0 to 100%
....................     float I;       // integral value
....................     float maxSP;   // Max setpoint in microns
....................     float minSP;   // Min setpoint in microns
.................... }PID[2] = {
....................    //  P     I     D
....................    //0.01    0.3   0.1
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}, 
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}
....................     };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... //!#define op_upper_bound 63  // CRYO
.................... //!#define op_lower_bound -63 // CRYO
.................... 
.................... #define op_upper_bound 63  // AMBIENT 
.................... #define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    BOOLEAN homeFlag;       // Flag to trigger the homing routine
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,FALSE},
....................    {0,0,0,0,0,0,0,0,0,0,FALSE}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................     BOOLEAN invV;
....................     unsigned int16 ipVal;
....................     float opPcnt;
....................    
.................... }dacVals[2] = 
.................... {
....................     {FALSE,0,0},
....................     {FALSE,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/           
.................... /* Global timers used by all routnes                                         */
.................... /* timeoutReg0-2 are used for timeouts. Other routines monitor the value of  */
.................... /* intTimeoutReg. On boot, they will be loaded from EEProm. Any              */
.................... /* configuration changes will be changed in EEprom, hence will be restored on*/
.................... /* subsequent boot.                                                          */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* Register definitions                                                      */
.................... /*****************************************************************************/
.................... //!unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... //!unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... //!unsigned int32 timeoutReg2 = 0;
.................... //!unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... unsigned int32 timeCounter = 0;
.................... 
.................... /*****************************************************************************/
.................... /* TIMEOUT_INIT initializes the timer                                        */
.................... /*****************************************************************************/
.................... void event_timer_init()
.................... {        
....................    disable_interrupts(INT_TIMER1);
00D0E:  MOVLB  E
00D10:  BCF    xC1.0
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_1);
00D12:  MOVLW  01
00D14:  MOVWF  FD1
00D16:  MOVLW  07
00D18:  MOVWF  FCE
00D1A:  CLRF   FCF
00D1C:  CLRF   FD0
....................    timeoutReg0 = 0;  // clear all the timers
00D1E:  MOVLB  1
00D20:  CLRF   x75
00D22:  CLRF   x74
00D24:  CLRF   x73
00D26:  CLRF   x72
....................    timeoutReg1 = 0;
00D28:  CLRF   x79
00D2A:  CLRF   x78
00D2C:  CLRF   x77
00D2E:  CLRF   x76
....................    timeoutReg2 = 0;
00D30:  CLRF   x7D
00D32:  CLRF   x7C
00D34:  CLRF   x7B
00D36:  CLRF   x7A
.................... //!   intTimeoutReg = 50;
....................    enable_interrupts(INT_TIMER1);
00D38:  MOVLB  E
00D3A:  BSF    xC1.0
00D3C:  MOVLB  0
00D3E:  GOTO   AD04 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* TIMEOUT INTERRUPT decrements the timeout registers every second           */
.................... /*****************************************************************************/
.................... #INT_TIMER1
.................... void TIMER1_isr(void) 
*
0025C:  MOVLB  0
.................... {
....................    set_timer1(0x0BDB); // load timer register to allow 10 millisecond interupts
0025E:  MOVLW  0B
00260:  MOVWF  FCD
00262:  MOVLW  DB
00264:  MOVWF  FCC
00266:  NOP   
....................    if (timeoutReg0 > 10) timeoutReg0 -= 10; else timeoutReg0 = 0;
00268:  MOVLB  1
0026A:  MOVF   x75,F
0026C:  BNZ   027C
0026E:  MOVF   x74,F
00270:  BNZ   027C
00272:  MOVF   x73,F
00274:  BNZ   027C
00276:  MOVF   x72,W
00278:  SUBLW  0A
0027A:  BC    028A
0027C:  MOVLW  0A
0027E:  SUBWF  x72,F
00280:  MOVLW  00
00282:  SUBWFB x73,F
00284:  SUBWFB x74,F
00286:  SUBWFB x75,F
00288:  BRA    0292
0028A:  CLRF   x75
0028C:  CLRF   x74
0028E:  CLRF   x73
00290:  CLRF   x72
....................    if (timeoutReg1 > 10) timeoutReg1 -= 10; else timeoutReg1 = 0;
00292:  MOVF   x79,F
00294:  BNZ   02A4
00296:  MOVF   x78,F
00298:  BNZ   02A4
0029A:  MOVF   x77,F
0029C:  BNZ   02A4
0029E:  MOVF   x76,W
002A0:  SUBLW  0A
002A2:  BC    02B2
002A4:  MOVLW  0A
002A6:  SUBWF  x76,F
002A8:  MOVLW  00
002AA:  SUBWFB x77,F
002AC:  SUBWFB x78,F
002AE:  SUBWFB x79,F
002B0:  BRA    02BA
002B2:  CLRF   x79
002B4:  CLRF   x78
002B6:  CLRF   x77
002B8:  CLRF   x76
....................    if (timeoutReg2 > 10) timeoutReg2 -= 10; else timeoutReg2 = 0;
002BA:  MOVF   x7D,F
002BC:  BNZ   02CC
002BE:  MOVF   x7C,F
002C0:  BNZ   02CC
002C2:  MOVF   x7B,F
002C4:  BNZ   02CC
002C6:  MOVF   x7A,W
002C8:  SUBLW  0A
002CA:  BC    02DA
002CC:  MOVLW  0A
002CE:  SUBWF  x7A,F
002D0:  MOVLW  00
002D2:  SUBWFB x7B,F
002D4:  SUBWFB x7C,F
002D6:  SUBWFB x7D,F
002D8:  BRA    02E2
002DA:  CLRF   x7D
002DC:  CLRF   x7C
002DE:  CLRF   x7B
002E0:  CLRF   x7A
....................    if (intTimeoutReg != 0) // INTERRUPTING TIMER
002E2:  MOVF   x7E,F
002E4:  BNZ   02EA
002E6:  MOVF   x7F,F
002E8:  BZ    0326
....................    {
....................       timeCounter+=10;
002EA:  MOVLW  0A
002EC:  MOVLB  5
002EE:  ADDWF  x66,F
002F0:  MOVLW  00
002F2:  ADDWFC x67,F
002F4:  ADDWFC x68,F
002F6:  ADDWFC x69,F
....................       if (timeCounter >= intTimeoutReg)
002F8:  MOVF   x69,F
002FA:  BNZ   0316
002FC:  MOVF   x68,F
002FE:  BNZ   0316
00300:  MOVLB  1
00302:  MOVF   x7F,W
00304:  MOVLB  5
00306:  SUBWF  x67,W
00308:  BNC   0324
0030A:  BNZ   0316
0030C:  MOVLB  1
0030E:  MOVF   x7E,W
00310:  MOVLB  5
00312:  SUBWF  x66,W
00314:  BNC   0324
....................       {
....................          sensor_monitor_interrupt_task();
00316:  MOVLB  0
00318:  BRA    01C0
....................          timeCounter = 0;
0031A:  MOVLB  5
0031C:  CLRF   x69
0031E:  CLRF   x68
00320:  CLRF   x67
00322:  CLRF   x66
00324:  MOVLB  1
....................       }
....................    }
.................... }
.................... 
.................... #endif
.................... 
.................... #include <commandHandler.c>
.................... #ifndef cmdHandlerC
.................... #define cmdHandlerC
.................... #include <commandHandler.h>
.................... #ifndef cmdHandler
.................... #define cmdHandler
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................     float kP;      // proportional gain
....................     float kI;      // integral gain
....................     float kD;      // derivative gain
....................     float SP;      // set point-- desired output
....................     float PV;      // process variable-- measured output
....................     float PVold;   // oldPV value  
....................     float CV;      // control variable-- output -- 0 to 100%
....................     float I;       // integral value
....................     float maxSP;   // Max setpoint in microns
....................     float minSP;   // Min setpoint in microns
.................... }PID[2] = {
....................    //  P     I     D
....................    //0.01    0.3   0.1
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}, 
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}
....................     };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... //!#define op_upper_bound 63  // CRYO
.................... //!#define op_lower_bound -63 // CRYO
.................... 
.................... #define op_upper_bound 63  // AMBIENT 
.................... #define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    BOOLEAN homeFlag;       // Flag to trigger the homing routine
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,FALSE},
....................    {0,0,0,0,0,0,0,0,0,0,FALSE}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................     BOOLEAN invV;
....................     unsigned int16 ipVal;
....................     float opPcnt;
....................    
.................... }dacVals[2] = 
.................... {
....................     {FALSE,0,0},
....................     {FALSE,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... 
00326:  MOVLB  E
00328:  BCF    xC9.0
0032A:  MOVLB  0
0032C:  GOTO   006E
.................... #define hwID 'D'   // DiFCS
.................... 
.................... /*****************************************************************************/
.................... /* RESPONSE MESSAGES                                                         */
.................... /*****************************************************************************/
.................... typedef struct response {
....................     int8 id;
....................     char *msg;
.................... } resp;
.................... 
.................... //!#define INVALID_DATA "error - invalid data"
.................... //!#define invalidTime "error - invalid TO value"
.................... //!#define overrun "error - buffer overrun"
.................... //!#define dcVoltage "VDC:%f1"
.................... //!#define USBVoltage "VUSB:%f"
.................... //!#define USBupstream "VUSBup:%f"
.................... //!#define plus5V "5V Rail:%f"
.................... //!#define plus3V3 "3V3 Rai:%f"
.................... //!#define allVoltages "All Voltages = %f, %f, %f, %f, %f"
.................... //!#define USBdownstream "USB downstream status:\r\nPG:%s\r\nch0:%s\r\nch1:%s"
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC MESSGAGE DUMP                                                  */
.................... /*****************************************************************************/
.................... //!#define voltageMsg "V0:%f\r\nV1:%f\r\nV2:%f\r\nV3:%f\r\nV4:%f"
.................... //!#define TimerMsg "T0:%Lu\r\nT1:%Lu\r\nT2:%Lu\r\Tint:%Lu\r\nTtick:%Lu"
.................... //!#define ioStatusMsg "Inputs:%u\r\nOutputs:%u\r\nStatus:%u"
.................... //!#define diagnosticMsg "V0:%f\r\nV1:%f\r\nV2:%f\r\nV3:%f\r\nV4:%f\r\nT0:%Lu\r\nT1:%Lu\r\nT2:%Lu\r\nTint:%Lu\r\nTtick:%Lu\r\nInputs:%u\r\nOutputs:%u\r\nStatus:%u"
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC COMMAND PROTOTYPES                                             */
.................... /*****************************************************************************/
.................... int8 getRev(unsigned int8);                 // gr 
.................... int8 getSN(unsigned int8);                  // gs
.................... 
.................... int8 getOPchMap(unsigned int8);             // gChMap,   {1|2}
.................... int8 setOPchMap(unsigned int8);             // sChMap,   {1|2}, {X|Y}
.................... 
.................... int8 getIPchMode(unsigned int8);            // gChMode,  {1|2}
.................... int8 setIPchMode(unsigned int8);            // sChMode,  {1|2}, {MANUAL|MAGSNS}
....................    
.................... int8 getPIDvals(unsigned int8);             // gPID,     {1|2}, {P|I|D}
.................... int8 setPIDvals(unsigned int8);             // sPID,     {1|2}, {P|I|D}, <float>
.................... 
.................... int8 enablePID(unsigned int8);              // enaPID,   {1|2}
.................... int8 disablePID(unsigned int8);             // disPID,   {1|2}
.................... 
.................... int8 getSetPoint(unsigned int8);            // gSP,      {1|2}
.................... int8 setSetPoint(unsigned int8);            // sSP,      {1|2}, <float>
.................... 
.................... int8 getAllSensorCalParams(unsigned int8);  // gSCals,   {1|2}
.................... int8 getSensorCalParam(unsigned int8);      // gSCal,    {1|2}, {0|1|2|3|4|5}
.................... int8 setSensorCalParam(unsigned int8);      // sSCal,    {1|2}, {0|1|2|3|4|5}, <float>
.................... 
.................... int8 getMonitorCalParam(unsigned int8);     // gMCal,    {N15|200|5V6|5VA|3V6X|3V3A|3V3D}
.................... int8 setMonitorCalParam(unsigned int8);     // sMCal,    {N15|200|5V6|5VA|3V6X|3V3A|3V3D}, <float>, <float>
.................... int8 getMonitorValue(unsigned int8);        // gMon,     {N15|200|5V6|5VA|3V6X|3V3A|3V3D|all}
.................... 
.................... int8 getPIDdata(unsigned int8);             // gPIDdata, {1|2}, {PV|CV|PVold|I}
.................... 
.................... int8 getIPdata(unsigned int8);              // gIPdata,  {1|2}, {raw|calib|p0|poles|real}
....................    
.................... int8 getManOPvals(unsigned int8);           // gManOP,   {1|2}  
.................... int8 setManOPvals(unsigned int8);           // sManOP,   {1|2}, <float>  
.................... 
.................... int8 setFilterOn(unsigned int8);            // sFiltOn
.................... int8 setFilterOff(unsigned int8);           // sFiltOff
.................... 
.................... int8 setHomeAxis(unsigned int8);            // sHome,    {1|2}      
....................                                                        
.................... int8 invalidCmd(unsigned int8);
.................... 
.................... struct command {
....................     char *cmd_name;
....................     int8 (*cmd_func)(unsigned int8);
.................... };
.................... 
.................... BOOLEAN arg_is_float(char *);
.................... BOOLEAN is_valid_channel(char *);
.................... int8 hex_to_int(char);
.................... void echo_cmd(unsigned int8 rec);
.................... int8 command_parser(unsigned int8 rec);
.................... void command_handler_task();
.................... 
.................... #endif
.................... 
.................... 
.................... /* LIST OF DIAGNOSTIC COMMAND KEYWORDS AND THEIR FUNCTIONS */
.................... struct command cmd_list[] = {
....................     {"gr",       &getRev},
....................     {"gs",       &getSN},
....................     {"gChMap",   &getOPchMap},
....................     {"sChMap",   &setOPchMap},
....................     {"gChMode",  &getIPchMode},
....................     {"sChMode",  &setIPchMode},
....................     {"gPID",     &getPIDvals},
....................     {"sPID",     &setPIDvals},
....................     {"gSP",      &getSetPoint},
....................     {"sSP",      &setSetPoint},
....................     {"gSCals",   &getAllSensorCalParams},
....................     {"gSCal",    &getSensorCalParam},
....................     {"sSCal",    &setSensorCalParam},
....................     {"gMCal",    &getMonitorCalParam},
....................     {"sMCal",    &setMonitorCalParam},
....................     {"gMon",     &getMonitorValue},
....................     {"gPIDdata", &getPIDdata},
....................     {"gIPdata",  &getIPdata},
....................     {"gManOP",   &getManOPvals},
....................     {"sManOP",   &setManOPvals},
....................     {"sFiltOn",  &setFilterOn},
....................     {"sFiltOff", &setFilterOff},
....................     {"sHome",    &setHomeAxis},
....................     {"\0", &invalidCmd}
.................... };
.................... 
.................... /* LIST OF RESPONSE MESSAGES */
.................... enum resp_e { 
....................    SUCCESS,
....................    INV_CMD,
....................    INV_PARAM 
.................... };
.................... 
.................... resp resp_list[] = {
....................    {SUCCESS, "SUCCESS"},
....................    {INV_CMD, "INVALID COMMAND"},
....................    {INV_PARAM, "INVALID PARAMETER"}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC COMMAND DEFINITIONS                                            */
.................... /*****************************************************************************/
....................                           
.................... int8 getRev(unsigned int8 rec){
....................    sprintf(retData+strlen(retData), "%s,", version);
*
061B4:  MOVLW  04
061B6:  MOVLB  7
061B8:  MOVWF  x42
061BA:  MOVLW  C1
061BC:  MOVWF  x41
061BE:  MOVLB  0
061C0:  RCALL  5BA6
061C2:  MOVFF  02,03
061C6:  MOVF   01,W
061C8:  ADDLW  C1
061CA:  MOVLB  7
061CC:  MOVWF  x0B
061CE:  MOVLW  04
061D0:  ADDWFC 02,W
061D2:  MOVWF  x0C
061D4:  MOVFF  FE8,565
061D8:  MOVFF  70B,564
061DC:  MOVLW  30
061DE:  MOVWF  FF6
061E0:  MOVLW  03
061E2:  MOVWF  FF7
061E4:  MOVLB  0
061E6:  RCALL  6194
061E8:  MOVLW  2C
061EA:  MOVLB  7
061EC:  MOVWF  x50
061EE:  MOVLB  0
061F0:  RCALL  5BDE
....................    return SUCCESS;
061F2:  MOVLW  00
061F4:  MOVWF  01
061F6:  RETURN 0
.................... }
.................... 
.................... int8 getSN(unsigned int8 rec){
....................    sprintf(retData+strlen(retData), "%s,", serialID);
061F8:  MOVLW  04
061FA:  MOVLB  7
061FC:  MOVWF  x42
061FE:  MOVLW  C1
06200:  MOVWF  x41
06202:  MOVLB  0
06204:  RCALL  5BA6
06206:  MOVFF  02,03
0620A:  MOVF   01,W
0620C:  ADDLW  C1
0620E:  MOVLB  7
06210:  MOVWF  x0B
06212:  MOVLW  04
06214:  ADDWFC 02,W
06216:  MOVWF  x0C
06218:  MOVFF  FE8,565
0621C:  MOVFF  70B,564
06220:  MOVLW  3A
06222:  MOVWF  FF6
06224:  MOVLW  03
06226:  MOVWF  FF7
06228:  MOVLB  0
0622A:  RCALL  6194
0622C:  MOVLW  2C
0622E:  MOVLB  7
06230:  MOVWF  x50
06232:  MOVLB  0
06234:  RCALL  5BDE
....................    return SUCCESS;
06236:  MOVLW  00
06238:  MOVWF  01
0623A:  RETURN 0
.................... }
.................... 
.................... int8 getOPchMap(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
06748:  MOVLB  7
0674A:  CLRF   x47
0674C:  MOVFF  690,746
06750:  CLRF   x49
06752:  MOVLW  B5
06754:  MOVWF  x48
06756:  MOVLB  0
06758:  CALL   0890
0675C:  MOVFF  02,70D
06760:  MOVFF  01,70C
06764:  MOVLW  06
06766:  MOVLB  7
06768:  ADDWF  x0C,F
0676A:  MOVLW  00
0676C:  ADDWFC x0D,F
0676E:  MOVLW  32
06770:  ADDWF  x0C,W
06772:  MOVWF  01
06774:  MOVLW  00
06776:  ADDWFC x0D,W
06778:  MOVWF  03
0677A:  MOVF   01,W
0677C:  ADDLW  EB
0677E:  MOVWF  01
06780:  MOVLW  01
06782:  ADDWFC 03,F
06784:  MOVFF  01,70C
06788:  MOVFF  03,70D
0678C:  MOVFF  03,734
06790:  MOVFF  01,733
06794:  MOVLB  0
06796:  RCALL  623C
06798:  MOVF   01,F
0679A:  BNZ   67A4
0679C:  MOVLW  02
0679E:  MOVWF  01
067A0:  BRA    68F2
067A2:  BRA    6800
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
067A4:  MOVLB  7
067A6:  CLRF   x47
067A8:  MOVFF  690,746
067AC:  CLRF   x49
067AE:  MOVLW  B5
067B0:  MOVWF  x48
067B2:  MOVLB  0
067B4:  CALL   0890
067B8:  MOVFF  02,70D
067BC:  MOVFF  01,70C
067C0:  MOVLW  06
067C2:  MOVLB  7
067C4:  ADDWF  x0C,F
067C6:  MOVLW  00
067C8:  ADDWFC x0D,F
067CA:  MOVLW  32
067CC:  ADDWF  x0C,W
067CE:  MOVWF  01
067D0:  MOVLW  00
067D2:  ADDWFC x0D,W
067D4:  MOVWF  03
067D6:  MOVF   01,W
067D8:  ADDLW  EB
067DA:  MOVWF  01
067DC:  MOVLW  01
067DE:  ADDWFC 03,F
067E0:  MOVFF  01,70C
067E4:  MOVFF  03,70D
067E8:  MOVFF  03,734
067EC:  MOVFF  01,733
067F0:  CLRF   x36
067F2:  CLRF   x35
067F4:  MOVLW  0A
067F6:  MOVWF  x37
067F8:  MOVLB  0
067FA:  RCALL  632C
067FC:  MOVFF  01,70B
....................    
....................    /*** GET CHANNEL MAP ***************/ 
....................    if      (0 == chMap[arg1-1]) sprintf(retData+strlen(retData), "%d,%c,", arg1, 'X');
06800:  MOVLW  01
06802:  MOVLB  7
06804:  SUBWF  x0B,W
06806:  MOVWF  x0F
06808:  CLRF   x11
0680A:  MOVLW  70
0680C:  MOVWF  x10
0680E:  MOVLB  0
06810:  CALL   1076
06814:  BTFSC  01.0
06816:  BRA    6874
06818:  MOVLW  04
0681A:  MOVLB  7
0681C:  MOVWF  x42
0681E:  MOVLW  C1
06820:  MOVWF  x41
06822:  MOVLB  0
06824:  CALL   5BA6
06828:  MOVFF  02,03
0682C:  MOVF   01,W
0682E:  ADDLW  C1
06830:  MOVLB  7
06832:  MOVWF  x0C
06834:  MOVLW  04
06836:  ADDWFC 02,W
06838:  MOVWF  x0D
0683A:  MOVFF  FE8,565
0683E:  MOVFF  70C,564
06842:  MOVFF  70B,734
06846:  MOVLW  18
06848:  MOVWF  x35
0684A:  MOVLB  0
0684C:  RCALL  6680
0684E:  MOVLW  2C
06850:  MOVLB  7
06852:  MOVWF  x50
06854:  MOVLB  0
06856:  CALL   5BDE
0685A:  MOVLW  58
0685C:  MOVLB  7
0685E:  MOVWF  x50
06860:  MOVLB  0
06862:  CALL   5BDE
06866:  MOVLW  2C
06868:  MOVLB  7
0686A:  MOVWF  x50
0686C:  MOVLB  0
0686E:  CALL   5BDE
06872:  BRA    68EE
....................    else if (1 == chMap[arg1-1]) sprintf(retData+strlen(retData), "%d,%c,", arg1, 'Y');
06874:  MOVLW  01
06876:  MOVLB  7
06878:  SUBWF  x0B,W
0687A:  MOVWF  x0F
0687C:  CLRF   x11
0687E:  MOVLW  70
06880:  MOVWF  x10
06882:  MOVLB  0
06884:  CALL   1076
06888:  BTFSS  01.0
0688A:  BRA    68E8
0688C:  MOVLW  04
0688E:  MOVLB  7
06890:  MOVWF  x42
06892:  MOVLW  C1
06894:  MOVWF  x41
06896:  MOVLB  0
06898:  CALL   5BA6
0689C:  MOVFF  02,03
068A0:  MOVF   01,W
068A2:  ADDLW  C1
068A4:  MOVLB  7
068A6:  MOVWF  x0C
068A8:  MOVLW  04
068AA:  ADDWFC 02,W
068AC:  MOVWF  x0D
068AE:  MOVFF  FE8,565
068B2:  MOVFF  70C,564
068B6:  MOVFF  70B,734
068BA:  MOVLW  18
068BC:  MOVWF  x35
068BE:  MOVLB  0
068C0:  RCALL  6680
068C2:  MOVLW  2C
068C4:  MOVLB  7
068C6:  MOVWF  x50
068C8:  MOVLB  0
068CA:  CALL   5BDE
068CE:  MOVLW  59
068D0:  MOVLB  7
068D2:  MOVWF  x50
068D4:  MOVLB  0
068D6:  CALL   5BDE
068DA:  MOVLW  2C
068DC:  MOVLB  7
068DE:  MOVWF  x50
068E0:  MOVLB  0
068E2:  CALL   5BDE
068E6:  BRA    68EE
....................    else return INV_PARAM;
068E8:  MOVLW  02
068EA:  MOVWF  01
068EC:  BRA    68F2
....................    
....................    return SUCCESS;
068EE:  MOVLW  00
068F0:  MOVWF  01
068F2:  RETURN 0
.................... }
.................... 
.................... int8 setOPchMap(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
068F4:  MOVLB  7
068F6:  CLRF   x47
068F8:  MOVFF  690,746
068FC:  CLRF   x49
068FE:  MOVLW  B5
06900:  MOVWF  x48
06902:  MOVLB  0
06904:  CALL   0890
06908:  MOVFF  02,70E
0690C:  MOVFF  01,70D
06910:  MOVLW  06
06912:  MOVLB  7
06914:  ADDWF  x0D,F
06916:  MOVLW  00
06918:  ADDWFC x0E,F
0691A:  MOVLW  32
0691C:  ADDWF  x0D,W
0691E:  MOVWF  01
06920:  MOVLW  00
06922:  ADDWFC x0E,W
06924:  MOVWF  03
06926:  MOVF   01,W
06928:  ADDLW  EB
0692A:  MOVWF  01
0692C:  MOVLW  01
0692E:  ADDWFC 03,F
06930:  MOVFF  01,70D
06934:  MOVFF  03,70E
06938:  MOVFF  03,734
0693C:  MOVFF  01,733
06940:  MOVLB  0
06942:  RCALL  623C
06944:  MOVF   01,F
06946:  BNZ   6950
06948:  MOVLW  02
0694A:  MOVWF  01
0694C:  BRA    6AA4
0694E:  BRA    69AC
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06950:  MOVLB  7
06952:  CLRF   x47
06954:  MOVFF  690,746
06958:  CLRF   x49
0695A:  MOVLW  B5
0695C:  MOVWF  x48
0695E:  MOVLB  0
06960:  CALL   0890
06964:  MOVFF  02,70E
06968:  MOVFF  01,70D
0696C:  MOVLW  06
0696E:  MOVLB  7
06970:  ADDWF  x0D,F
06972:  MOVLW  00
06974:  ADDWFC x0E,F
06976:  MOVLW  32
06978:  ADDWF  x0D,W
0697A:  MOVWF  01
0697C:  MOVLW  00
0697E:  ADDWFC x0E,W
06980:  MOVWF  03
06982:  MOVF   01,W
06984:  ADDLW  EB
06986:  MOVWF  01
06988:  MOVLW  01
0698A:  ADDWFC 03,F
0698C:  MOVFF  01,70D
06990:  MOVFF  03,70E
06994:  MOVFF  03,734
06998:  MOVFF  01,733
0699C:  CLRF   x36
0699E:  CLRF   x35
069A0:  MOVLW  0A
069A2:  MOVWF  x37
069A4:  MOVLB  0
069A6:  RCALL  632C
069A8:  MOVFF  01,70B
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
069AC:  MOVLB  7
069AE:  CLRF   x47
069B0:  MOVFF  690,746
069B4:  CLRF   x49
069B6:  MOVLW  B5
069B8:  MOVWF  x48
069BA:  MOVLB  0
069BC:  CALL   0890
069C0:  MOVFF  02,70E
069C4:  MOVFF  01,70D
069C8:  MOVLW  06
069CA:  MOVLB  7
069CC:  ADDWF  x0D,F
069CE:  MOVLW  00
069D0:  ADDWFC x0E,F
069D2:  MOVLW  4B
069D4:  ADDWF  x0D,W
069D6:  MOVWF  01
069D8:  MOVLW  00
069DA:  ADDWFC x0E,W
069DC:  MOVWF  03
069DE:  MOVF   01,W
069E0:  ADDLW  EB
069E2:  MOVWF  01
069E4:  MOVLW  01
069E6:  ADDWFC 03,F
069E8:  MOVFF  01,70D
069EC:  MOVFF  03,70E
069F0:  MOVFF  03,742
069F4:  MOVFF  01,741
069F8:  MOVLB  0
069FA:  CALL   5BA6
069FE:  MOVFF  02,03
06A02:  MOVF   01,W
06A04:  SUBLW  01
06A06:  BNZ   6A0C
06A08:  MOVF   03,F
06A0A:  BZ    6A14
06A0C:  MOVLW  02
06A0E:  MOVWF  01
06A10:  BRA    6AA4
06A12:  BRA    6A54
....................    else arg2 = SERcmd[rec].p[3][0];
06A14:  MOVLB  7
06A16:  CLRF   x47
06A18:  MOVFF  690,746
06A1C:  CLRF   x49
06A1E:  MOVLW  B5
06A20:  MOVWF  x48
06A22:  MOVLB  0
06A24:  CALL   0890
06A28:  MOVFF  02,70E
06A2C:  MOVFF  01,70D
06A30:  MOVLW  06
06A32:  MOVLB  7
06A34:  ADDWF  x0D,F
06A36:  MOVLW  00
06A38:  ADDWFC x0E,F
06A3A:  MOVLW  4B
06A3C:  ADDWF  x0D,F
06A3E:  MOVLW  00
06A40:  ADDWFC x0E,F
06A42:  MOVLW  EB
06A44:  ADDWF  x0D,W
06A46:  MOVWF  FE9
06A48:  MOVLW  01
06A4A:  ADDWFC x0E,W
06A4C:  MOVWF  FEA
06A4E:  MOVFF  FEF,70C
06A52:  MOVLB  0
....................    
....................    /*** SET CHANNEL MAP ***************/
....................    if      ('X' == arg2) chMap[arg1-1] = chX;
06A54:  MOVLB  7
06A56:  MOVF   x0C,W
06A58:  SUBLW  58
06A5A:  BNZ   6A76
06A5C:  MOVLW  01
06A5E:  SUBWF  x0B,W
06A60:  MOVWF  x0D
06A62:  MOVWF  x22
06A64:  CLRF   x23
06A66:  CLRF   x25
06A68:  MOVLW  70
06A6A:  MOVWF  x24
06A6C:  MOVLB  0
06A6E:  CALL   0D42
06A72:  BRA    6AA0
06A74:  MOVLB  7
....................    else if ('Y' == arg2) chMap[arg1-1] = chY;
06A76:  MOVF   x0C,W
06A78:  SUBLW  59
06A7A:  BNZ   6A98
06A7C:  MOVLW  01
06A7E:  SUBWF  x0B,W
06A80:  MOVWF  x0D
06A82:  MOVWF  x22
06A84:  MOVLW  01
06A86:  MOVWF  x23
06A88:  CLRF   x25
06A8A:  MOVLW  70
06A8C:  MOVWF  x24
06A8E:  MOVLB  0
06A90:  CALL   0D42
06A94:  BRA    6AA0
06A96:  MOVLB  7
....................    else return INV_PARAM;
06A98:  MOVLW  02
06A9A:  MOVWF  01
06A9C:  MOVLB  0
06A9E:  BRA    6AA4
....................    
....................    return SUCCESS;
06AA0:  MOVLW  00
06AA2:  MOVWF  01
06AA4:  RETURN 0
.................... }
.................... 
.................... int8 getIPchMode(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
06AA6:  MOVLB  7
06AA8:  CLRF   x47
06AAA:  MOVFF  690,746
06AAE:  CLRF   x49
06AB0:  MOVLW  B5
06AB2:  MOVWF  x48
06AB4:  MOVLB  0
06AB6:  CALL   0890
06ABA:  MOVFF  02,70D
06ABE:  MOVFF  01,70C
06AC2:  MOVLW  06
06AC4:  MOVLB  7
06AC6:  ADDWF  x0C,F
06AC8:  MOVLW  00
06ACA:  ADDWFC x0D,F
06ACC:  MOVLW  32
06ACE:  ADDWF  x0C,W
06AD0:  MOVWF  01
06AD2:  MOVLW  00
06AD4:  ADDWFC x0D,W
06AD6:  MOVWF  03
06AD8:  MOVF   01,W
06ADA:  ADDLW  EB
06ADC:  MOVWF  01
06ADE:  MOVLW  01
06AE0:  ADDWFC 03,F
06AE2:  MOVFF  01,70C
06AE6:  MOVFF  03,70D
06AEA:  MOVFF  03,734
06AEE:  MOVFF  01,733
06AF2:  MOVLB  0
06AF4:  CALL   623C
06AF8:  MOVF   01,F
06AFA:  BNZ   6B04
06AFC:  MOVLW  02
06AFE:  MOVWF  01
06B00:  BRA    6C34
06B02:  BRA    6B62
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06B04:  MOVLB  7
06B06:  CLRF   x47
06B08:  MOVFF  690,746
06B0C:  CLRF   x49
06B0E:  MOVLW  B5
06B10:  MOVWF  x48
06B12:  MOVLB  0
06B14:  CALL   0890
06B18:  MOVFF  02,70D
06B1C:  MOVFF  01,70C
06B20:  MOVLW  06
06B22:  MOVLB  7
06B24:  ADDWF  x0C,F
06B26:  MOVLW  00
06B28:  ADDWFC x0D,F
06B2A:  MOVLW  32
06B2C:  ADDWF  x0C,W
06B2E:  MOVWF  01
06B30:  MOVLW  00
06B32:  ADDWFC x0D,W
06B34:  MOVWF  03
06B36:  MOVF   01,W
06B38:  ADDLW  EB
06B3A:  MOVWF  01
06B3C:  MOVLW  01
06B3E:  ADDWFC 03,F
06B40:  MOVFF  01,70C
06B44:  MOVFF  03,70D
06B48:  MOVFF  03,734
06B4C:  MOVFF  01,733
06B50:  CLRF   x36
06B52:  CLRF   x35
06B54:  MOVLW  0A
06B56:  MOVWF  x37
06B58:  MOVLB  0
06B5A:  CALL   632C
06B5E:  MOVFF  01,70B
....................    
....................    /*** GET INPUT MAP *****************/
....................    if      (0 == chMode[arg1-1]) sprintf(retData+strlen(retData), "%d,MANUAL,", arg1);
06B62:  MOVLW  01
06B64:  MOVLB  7
06B66:  SUBWF  x0B,W
06B68:  MOVWF  x0F
06B6A:  CLRF   x11
06B6C:  MOVLW  71
06B6E:  MOVWF  x10
06B70:  MOVLB  0
06B72:  CALL   1076
06B76:  BTFSC  01.0
06B78:  BRA    6BC6
06B7A:  MOVLW  04
06B7C:  MOVLB  7
06B7E:  MOVWF  x42
06B80:  MOVLW  C1
06B82:  MOVWF  x41
06B84:  MOVLB  0
06B86:  CALL   5BA6
06B8A:  MOVFF  02,03
06B8E:  MOVF   01,W
06B90:  ADDLW  C1
06B92:  MOVLB  7
06B94:  MOVWF  x0C
06B96:  MOVLW  04
06B98:  ADDWFC 02,W
06B9A:  MOVWF  x0D
06B9C:  MOVFF  FE8,565
06BA0:  MOVFF  70C,564
06BA4:  MOVFF  70B,734
06BA8:  MOVLW  18
06BAA:  MOVWF  x35
06BAC:  MOVLB  0
06BAE:  RCALL  6680
06BB0:  MOVLW  42
06BB2:  MOVWF  FF6
06BB4:  MOVLW  03
06BB6:  MOVWF  FF7
06BB8:  MOVLW  08
06BBA:  MOVLB  7
06BBC:  MOVWF  x0F
06BBE:  MOVLB  0
06BC0:  CALL   5BFE
06BC4:  BRA    6C30
....................    else if (1 == chMode[arg1-1]) sprintf(retData+strlen(retData), "%d,MAGSNS,", arg1);
06BC6:  MOVLW  01
06BC8:  MOVLB  7
06BCA:  SUBWF  x0B,W
06BCC:  MOVWF  x0F
06BCE:  CLRF   x11
06BD0:  MOVLW  71
06BD2:  MOVWF  x10
06BD4:  MOVLB  0
06BD6:  CALL   1076
06BDA:  BTFSS  01.0
06BDC:  BRA    6C2A
06BDE:  MOVLW  04
06BE0:  MOVLB  7
06BE2:  MOVWF  x42
06BE4:  MOVLW  C1
06BE6:  MOVWF  x41
06BE8:  MOVLB  0
06BEA:  CALL   5BA6
06BEE:  MOVFF  02,03
06BF2:  MOVF   01,W
06BF4:  ADDLW  C1
06BF6:  MOVLB  7
06BF8:  MOVWF  x0C
06BFA:  MOVLW  04
06BFC:  ADDWFC 02,W
06BFE:  MOVWF  x0D
06C00:  MOVFF  FE8,565
06C04:  MOVFF  70C,564
06C08:  MOVFF  70B,734
06C0C:  MOVLW  18
06C0E:  MOVWF  x35
06C10:  MOVLB  0
06C12:  RCALL  6680
06C14:  MOVLW  4E
06C16:  MOVWF  FF6
06C18:  MOVLW  03
06C1A:  MOVWF  FF7
06C1C:  MOVLW  08
06C1E:  MOVLB  7
06C20:  MOVWF  x0F
06C22:  MOVLB  0
06C24:  CALL   5BFE
06C28:  BRA    6C30
....................    else return INV_PARAM;
06C2A:  MOVLW  02
06C2C:  MOVWF  01
06C2E:  BRA    6C34
....................    
....................    return SUCCESS;
06C30:  MOVLW  00
06C32:  MOVWF  01
06C34:  RETURN 0
.................... }
.................... 
.................... int8 setIPchMode(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char *arg2;
....................    char *s_manual = "MANUAL";
06C36:  MOVLW  4D
06C38:  MOVLB  7
06C3A:  MOVWF  x10
06C3C:  MOVLW  41
06C3E:  MOVWF  x11
06C40:  MOVLW  4E
06C42:  MOVWF  x12
06C44:  MOVLW  55
06C46:  MOVWF  x13
06C48:  MOVLW  41
06C4A:  MOVWF  x14
06C4C:  MOVLW  4C
06C4E:  MOVWF  x15
06C50:  CLRF   x16
06C52:  MOVLW  07
06C54:  MOVWF  x0F
06C56:  MOVLW  10
06C58:  MOVWF  x0E
....................    char *s_magsns = "MAGSNS";
06C5A:  MOVLW  4D
06C5C:  MOVWF  x19
06C5E:  MOVLW  41
06C60:  MOVWF  x1A
06C62:  MOVLW  47
06C64:  MOVWF  x1B
06C66:  MOVLW  53
06C68:  MOVWF  x1C
06C6A:  MOVLW  4E
06C6C:  MOVWF  x1D
06C6E:  MOVLW  53
06C70:  MOVWF  x1E
06C72:  CLRF   x1F
06C74:  MOVLW  07
06C76:  MOVWF  x18
06C78:  MOVLW  19
06C7A:  MOVWF  x17
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
06C7C:  CLRF   x47
06C7E:  MOVFF  690,746
06C82:  CLRF   x49
06C84:  MOVLW  B5
06C86:  MOVWF  x48
06C88:  MOVLB  0
06C8A:  CALL   0890
06C8E:  MOVFF  02,721
06C92:  MOVFF  01,720
06C96:  MOVLW  06
06C98:  MOVLB  7
06C9A:  ADDWF  x20,F
06C9C:  MOVLW  00
06C9E:  ADDWFC x21,F
06CA0:  MOVLW  32
06CA2:  ADDWF  x20,W
06CA4:  MOVWF  01
06CA6:  MOVLW  00
06CA8:  ADDWFC x21,W
06CAA:  MOVWF  03
06CAC:  MOVF   01,W
06CAE:  ADDLW  EB
06CB0:  MOVWF  01
06CB2:  MOVLW  01
06CB4:  ADDWFC 03,F
06CB6:  MOVFF  01,720
06CBA:  MOVFF  03,721
06CBE:  MOVFF  03,734
06CC2:  MOVFF  01,733
06CC6:  MOVLB  0
06CC8:  CALL   623C
06CCC:  MOVF   01,F
06CCE:  BNZ   6CD8
06CD0:  MOVLW  02
06CD2:  MOVWF  01
06CD4:  BRA    6E52
06CD6:  BRA    6D36
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06CD8:  MOVLB  7
06CDA:  CLRF   x47
06CDC:  MOVFF  690,746
06CE0:  CLRF   x49
06CE2:  MOVLW  B5
06CE4:  MOVWF  x48
06CE6:  MOVLB  0
06CE8:  CALL   0890
06CEC:  MOVFF  02,721
06CF0:  MOVFF  01,720
06CF4:  MOVLW  06
06CF6:  MOVLB  7
06CF8:  ADDWF  x20,F
06CFA:  MOVLW  00
06CFC:  ADDWFC x21,F
06CFE:  MOVLW  32
06D00:  ADDWF  x20,W
06D02:  MOVWF  01
06D04:  MOVLW  00
06D06:  ADDWFC x21,W
06D08:  MOVWF  03
06D0A:  MOVF   01,W
06D0C:  ADDLW  EB
06D0E:  MOVWF  01
06D10:  MOVLW  01
06D12:  ADDWFC 03,F
06D14:  MOVFF  01,720
06D18:  MOVFF  03,721
06D1C:  MOVFF  03,734
06D20:  MOVFF  01,733
06D24:  CLRF   x36
06D26:  CLRF   x35
06D28:  MOVLW  0A
06D2A:  MOVWF  x37
06D2C:  MOVLB  0
06D2E:  CALL   632C
06D32:  MOVFF  01,70B
....................    
....................    if (0 == strlen(SERcmd[rec].p[3])) return INV_PARAM;
06D36:  MOVLB  7
06D38:  CLRF   x47
06D3A:  MOVFF  690,746
06D3E:  CLRF   x49
06D40:  MOVLW  B5
06D42:  MOVWF  x48
06D44:  MOVLB  0
06D46:  CALL   0890
06D4A:  MOVFF  02,721
06D4E:  MOVFF  01,720
06D52:  MOVLW  06
06D54:  MOVLB  7
06D56:  ADDWF  x20,F
06D58:  MOVLW  00
06D5A:  ADDWFC x21,F
06D5C:  MOVLW  4B
06D5E:  ADDWF  x20,W
06D60:  MOVWF  01
06D62:  MOVLW  00
06D64:  ADDWFC x21,W
06D66:  MOVWF  03
06D68:  MOVF   01,W
06D6A:  ADDLW  EB
06D6C:  MOVWF  01
06D6E:  MOVLW  01
06D70:  ADDWFC 03,F
06D72:  MOVFF  01,720
06D76:  MOVFF  03,721
06D7A:  MOVFF  03,742
06D7E:  MOVFF  01,741
06D82:  MOVLB  0
06D84:  CALL   5BA6
06D88:  MOVFF  02,03
06D8C:  MOVF   01,W
06D8E:  BNZ   6D9C
06D90:  MOVF   03,F
06D92:  BNZ   6D9C
06D94:  MOVLW  02
06D96:  MOVWF  01
06D98:  BRA    6E52
06D9A:  BRA    6DE2
....................    else arg2 = SERcmd[rec].p[3];
06D9C:  MOVLB  7
06D9E:  CLRF   x47
06DA0:  MOVFF  690,746
06DA4:  CLRF   x49
06DA6:  MOVLW  B5
06DA8:  MOVWF  x48
06DAA:  MOVLB  0
06DAC:  CALL   0890
06DB0:  MOVFF  02,721
06DB4:  MOVFF  01,720
06DB8:  MOVLW  06
06DBA:  MOVLB  7
06DBC:  ADDWF  x20,F
06DBE:  MOVLW  00
06DC0:  ADDWFC x21,F
06DC2:  MOVLW  4B
06DC4:  ADDWF  x20,W
06DC6:  MOVWF  01
06DC8:  MOVLW  00
06DCA:  ADDWFC x21,W
06DCC:  MOVWF  03
06DCE:  MOVF   01,W
06DD0:  ADDLW  EB
06DD2:  MOVWF  01
06DD4:  MOVLW  01
06DD6:  ADDWFC 03,F
06DD8:  MOVFF  01,70C
06DDC:  MOVFF  03,70D
06DE0:  MOVLB  0
....................    
....................    /*** SET INPUT MAP *****************/
....................    if      (0 == strcmp(s_manual, arg2)) chMode[arg1-1] = MANUAL;
06DE2:  MOVFF  70F,742
06DE6:  MOVFF  70E,741
06DEA:  MOVFF  70D,744
06DEE:  MOVFF  70C,743
06DF2:  CALL   611C
06DF6:  MOVF   01,F
06DF8:  BNZ   6E14
06DFA:  MOVLW  01
06DFC:  MOVLB  7
06DFE:  SUBWF  x0B,W
06E00:  MOVWF  x20
06E02:  MOVWF  x22
06E04:  CLRF   x23
06E06:  CLRF   x25
06E08:  MOVLW  71
06E0A:  MOVWF  x24
06E0C:  MOVLB  0
06E0E:  CALL   0D42
06E12:  BRA    6E4E
....................    else if (0 == strcmp(s_magsns, arg2)) chMode[arg1-1] = MAGSNS;
06E14:  MOVFF  718,742
06E18:  MOVFF  717,741
06E1C:  MOVFF  70D,744
06E20:  MOVFF  70C,743
06E24:  CALL   611C
06E28:  MOVF   01,F
06E2A:  BNZ   6E48
06E2C:  MOVLW  01
06E2E:  MOVLB  7
06E30:  SUBWF  x0B,W
06E32:  MOVWF  x20
06E34:  MOVWF  x22
06E36:  MOVLW  01
06E38:  MOVWF  x23
06E3A:  CLRF   x25
06E3C:  MOVLW  71
06E3E:  MOVWF  x24
06E40:  MOVLB  0
06E42:  CALL   0D42
06E46:  BRA    6E4E
....................    else return INV_PARAM;
06E48:  MOVLW  02
06E4A:  MOVWF  01
06E4C:  BRA    6E52
....................    
....................    return SUCCESS;
06E4E:  MOVLW  00
06E50:  MOVWF  01
06E52:  RETURN 0
.................... }
.................... 
.................... int8 getPIDvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/ 
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
06E54:  MOVLB  7
06E56:  CLRF   x47
06E58:  MOVFF  690,746
06E5C:  CLRF   x49
06E5E:  MOVLW  B5
06E60:  MOVWF  x48
06E62:  MOVLB  0
06E64:  CALL   0890
06E68:  MOVFF  02,70E
06E6C:  MOVFF  01,70D
06E70:  MOVLW  06
06E72:  MOVLB  7
06E74:  ADDWF  x0D,F
06E76:  MOVLW  00
06E78:  ADDWFC x0E,F
06E7A:  MOVLW  32
06E7C:  ADDWF  x0D,W
06E7E:  MOVWF  01
06E80:  MOVLW  00
06E82:  ADDWFC x0E,W
06E84:  MOVWF  03
06E86:  MOVF   01,W
06E88:  ADDLW  EB
06E8A:  MOVWF  01
06E8C:  MOVLW  01
06E8E:  ADDWFC 03,F
06E90:  MOVFF  01,70D
06E94:  MOVFF  03,70E
06E98:  MOVFF  03,734
06E9C:  MOVFF  01,733
06EA0:  MOVLB  0
06EA2:  CALL   623C
06EA6:  MOVF   01,F
06EA8:  BNZ   6EB2
06EAA:  MOVLW  02
06EAC:  MOVWF  01
06EAE:  BRA    7314
06EB0:  BRA    6F10
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06EB2:  MOVLB  7
06EB4:  CLRF   x47
06EB6:  MOVFF  690,746
06EBA:  CLRF   x49
06EBC:  MOVLW  B5
06EBE:  MOVWF  x48
06EC0:  MOVLB  0
06EC2:  CALL   0890
06EC6:  MOVFF  02,70E
06ECA:  MOVFF  01,70D
06ECE:  MOVLW  06
06ED0:  MOVLB  7
06ED2:  ADDWF  x0D,F
06ED4:  MOVLW  00
06ED6:  ADDWFC x0E,F
06ED8:  MOVLW  32
06EDA:  ADDWF  x0D,W
06EDC:  MOVWF  01
06EDE:  MOVLW  00
06EE0:  ADDWFC x0E,W
06EE2:  MOVWF  03
06EE4:  MOVF   01,W
06EE6:  ADDLW  EB
06EE8:  MOVWF  01
06EEA:  MOVLW  01
06EEC:  ADDWFC 03,F
06EEE:  MOVFF  01,70D
06EF2:  MOVFF  03,70E
06EF6:  MOVFF  03,734
06EFA:  MOVFF  01,733
06EFE:  CLRF   x36
06F00:  CLRF   x35
06F02:  MOVLW  0A
06F04:  MOVWF  x37
06F06:  MOVLB  0
06F08:  CALL   632C
06F0C:  MOVFF  01,70B
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
06F10:  MOVLB  7
06F12:  CLRF   x47
06F14:  MOVFF  690,746
06F18:  CLRF   x49
06F1A:  MOVLW  B5
06F1C:  MOVWF  x48
06F1E:  MOVLB  0
06F20:  CALL   0890
06F24:  MOVFF  02,70E
06F28:  MOVFF  01,70D
06F2C:  MOVLW  06
06F2E:  MOVLB  7
06F30:  ADDWF  x0D,F
06F32:  MOVLW  00
06F34:  ADDWFC x0E,F
06F36:  MOVLW  4B
06F38:  ADDWF  x0D,W
06F3A:  MOVWF  01
06F3C:  MOVLW  00
06F3E:  ADDWFC x0E,W
06F40:  MOVWF  03
06F42:  MOVF   01,W
06F44:  ADDLW  EB
06F46:  MOVWF  01
06F48:  MOVLW  01
06F4A:  ADDWFC 03,F
06F4C:  MOVFF  01,70D
06F50:  MOVFF  03,70E
06F54:  MOVFF  03,742
06F58:  MOVFF  01,741
06F5C:  MOVLB  0
06F5E:  CALL   5BA6
06F62:  MOVFF  02,03
06F66:  MOVF   01,W
06F68:  SUBLW  01
06F6A:  BNZ   6F70
06F6C:  MOVF   03,F
06F6E:  BZ    6F78
06F70:  MOVLW  02
06F72:  MOVWF  01
06F74:  BRA    7314
06F76:  BRA    6FB8
....................    else arg2 = SERcmd[rec].p[3][0];
06F78:  MOVLB  7
06F7A:  CLRF   x47
06F7C:  MOVFF  690,746
06F80:  CLRF   x49
06F82:  MOVLW  B5
06F84:  MOVWF  x48
06F86:  MOVLB  0
06F88:  CALL   0890
06F8C:  MOVFF  02,70E
06F90:  MOVFF  01,70D
06F94:  MOVLW  06
06F96:  MOVLB  7
06F98:  ADDWF  x0D,F
06F9A:  MOVLW  00
06F9C:  ADDWFC x0E,F
06F9E:  MOVLW  4B
06FA0:  ADDWF  x0D,F
06FA2:  MOVLW  00
06FA4:  ADDWFC x0E,F
06FA6:  MOVLW  EB
06FA8:  ADDWF  x0D,W
06FAA:  MOVWF  FE9
06FAC:  MOVLW  01
06FAE:  ADDWFC x0E,W
06FB0:  MOVWF  FEA
06FB2:  MOVFF  FEF,70C
06FB6:  MOVLB  0
....................    
....................    /*** GET P, I, D, or A(LL) VALUE **********/
....................    if      ('P' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kP);
06FB8:  MOVLB  7
06FBA:  MOVF   x0C,W
06FBC:  SUBLW  50
06FBE:  BNZ   705A
06FC0:  MOVLW  04
06FC2:  MOVWF  x42
06FC4:  MOVLW  C1
06FC6:  MOVWF  x41
06FC8:  MOVLB  0
06FCA:  CALL   5BA6
06FCE:  MOVFF  02,03
06FD2:  MOVF   01,W
06FD4:  ADDLW  C1
06FD6:  MOVLB  7
06FD8:  MOVWF  x0D
06FDA:  MOVLW  04
06FDC:  ADDWFC 02,W
06FDE:  MOVWF  x0E
06FE0:  MOVLW  01
06FE2:  SUBWF  x0B,W
06FE4:  MULLW  28
06FE6:  MOVF   FF3,W
06FE8:  CLRF   x10
06FEA:  MOVWF  x0F
06FEC:  MOVLW  20
06FEE:  ADDWF  x0F,W
06FF0:  MOVWF  FE9
06FF2:  MOVLW  00
06FF4:  ADDWFC x10,W
06FF6:  MOVWF  FEA
06FF8:  MOVFF  FEF,711
06FFC:  MOVFF  FEC,712
07000:  MOVFF  FEC,713
07004:  MOVFF  FEC,714
07008:  MOVFF  70E,565
0700C:  MOVFF  70D,564
07010:  MOVFF  70B,734
07014:  MOVLW  18
07016:  MOVWF  x35
07018:  MOVLB  0
0701A:  CALL   6680
0701E:  MOVLW  2C
07020:  MOVLB  7
07022:  MOVWF  x50
07024:  MOVLB  0
07026:  CALL   5BDE
0702A:  MOVLW  89
0702C:  MOVWF  FE9
0702E:  MOVFF  714,746
07032:  MOVFF  713,745
07036:  MOVFF  712,744
0703A:  MOVFF  711,743
0703E:  MOVLW  02
07040:  MOVLB  7
07042:  MOVWF  x47
07044:  MOVLB  0
07046:  CALL   5D7C
0704A:  MOVLW  2C
0704C:  MOVLB  7
0704E:  MOVWF  x50
07050:  MOVLB  0
07052:  CALL   5BDE
07056:  BRA    7310
07058:  MOVLB  7
....................    else if ('I' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kI);
0705A:  MOVF   x0C,W
0705C:  SUBLW  49
0705E:  BNZ   7102
07060:  MOVLW  04
07062:  MOVWF  x42
07064:  MOVLW  C1
07066:  MOVWF  x41
07068:  MOVLB  0
0706A:  CALL   5BA6
0706E:  MOVF   01,W
07070:  ADDLW  C1
07072:  MOVLB  7
07074:  MOVWF  x0D
07076:  MOVLW  04
07078:  ADDWFC 02,W
0707A:  MOVWF  x0E
0707C:  MOVLW  01
0707E:  SUBWF  x0B,W
07080:  MULLW  28
07082:  MOVF   FF3,W
07084:  CLRF   x10
07086:  MOVWF  x0F
07088:  MOVLW  04
0708A:  ADDWF  x0F,W
0708C:  MOVWF  01
0708E:  MOVLW  00
07090:  ADDWFC x10,W
07092:  MOVWF  03
07094:  MOVF   01,W
07096:  ADDLW  20
07098:  MOVWF  FE9
0709A:  MOVLW  00
0709C:  ADDWFC 03,W
0709E:  MOVWF  FEA
070A0:  MOVFF  FEF,70F
070A4:  MOVFF  FEC,710
070A8:  MOVFF  FEC,711
070AC:  MOVFF  FEC,712
070B0:  MOVFF  70E,565
070B4:  MOVFF  70D,564
070B8:  MOVFF  70B,734
070BC:  MOVLW  18
070BE:  MOVWF  x35
070C0:  MOVLB  0
070C2:  CALL   6680
070C6:  MOVLW  2C
070C8:  MOVLB  7
070CA:  MOVWF  x50
070CC:  MOVLB  0
070CE:  CALL   5BDE
070D2:  MOVLW  89
070D4:  MOVWF  FE9
070D6:  MOVFF  712,746
070DA:  MOVFF  711,745
070DE:  MOVFF  710,744
070E2:  MOVFF  70F,743
070E6:  MOVLW  02
070E8:  MOVLB  7
070EA:  MOVWF  x47
070EC:  MOVLB  0
070EE:  CALL   5D7C
070F2:  MOVLW  2C
070F4:  MOVLB  7
070F6:  MOVWF  x50
070F8:  MOVLB  0
070FA:  CALL   5BDE
070FE:  BRA    7310
07100:  MOVLB  7
....................    else if ('D' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kD);
07102:  MOVF   x0C,W
07104:  SUBLW  44
07106:  BNZ   71AA
07108:  MOVLW  04
0710A:  MOVWF  x42
0710C:  MOVLW  C1
0710E:  MOVWF  x41
07110:  MOVLB  0
07112:  CALL   5BA6
07116:  MOVF   01,W
07118:  ADDLW  C1
0711A:  MOVLB  7
0711C:  MOVWF  x0D
0711E:  MOVLW  04
07120:  ADDWFC 02,W
07122:  MOVWF  x0E
07124:  MOVLW  01
07126:  SUBWF  x0B,W
07128:  MULLW  28
0712A:  MOVF   FF3,W
0712C:  CLRF   x10
0712E:  MOVWF  x0F
07130:  MOVLW  08
07132:  ADDWF  x0F,W
07134:  MOVWF  01
07136:  MOVLW  00
07138:  ADDWFC x10,W
0713A:  MOVWF  03
0713C:  MOVF   01,W
0713E:  ADDLW  20
07140:  MOVWF  FE9
07142:  MOVLW  00
07144:  ADDWFC 03,W
07146:  MOVWF  FEA
07148:  MOVFF  FEF,70F
0714C:  MOVFF  FEC,710
07150:  MOVFF  FEC,711
07154:  MOVFF  FEC,712
07158:  MOVFF  70E,565
0715C:  MOVFF  70D,564
07160:  MOVFF  70B,734
07164:  MOVLW  18
07166:  MOVWF  x35
07168:  MOVLB  0
0716A:  CALL   6680
0716E:  MOVLW  2C
07170:  MOVLB  7
07172:  MOVWF  x50
07174:  MOVLB  0
07176:  CALL   5BDE
0717A:  MOVLW  89
0717C:  MOVWF  FE9
0717E:  MOVFF  712,746
07182:  MOVFF  711,745
07186:  MOVFF  710,744
0718A:  MOVFF  70F,743
0718E:  MOVLW  02
07190:  MOVLB  7
07192:  MOVWF  x47
07194:  MOVLB  0
07196:  CALL   5D7C
0719A:  MOVLW  2C
0719C:  MOVLB  7
0719E:  MOVWF  x50
071A0:  MOVLB  0
071A2:  CALL   5BDE
071A6:  BRA    7310
071A8:  MOVLB  7
....................    else if ('A' == arg2) sprintf(retData+strlen(retData), "%d,%f,%f,%f,", arg1, PID[arg1-1].kP, PID[arg1-1].kI, PID[arg1-1].kD);
071AA:  MOVF   x0C,W
071AC:  SUBLW  41
071AE:  BTFSS  FD8.2
071B0:  BRA    7308
071B2:  MOVLW  04
071B4:  MOVWF  x42
071B6:  MOVLW  C1
071B8:  MOVWF  x41
071BA:  MOVLB  0
071BC:  CALL   5BA6
071C0:  MOVF   01,W
071C2:  ADDLW  C1
071C4:  MOVLB  7
071C6:  MOVWF  x0D
071C8:  MOVLW  04
071CA:  ADDWFC 02,W
071CC:  MOVWF  x0E
071CE:  MOVLW  01
071D0:  SUBWF  x0B,W
071D2:  MULLW  28
071D4:  MOVF   FF3,W
071D6:  CLRF   x10
071D8:  MOVWF  x0F
071DA:  MOVLW  20
071DC:  ADDWF  x0F,W
071DE:  MOVWF  FE9
071E0:  MOVLW  00
071E2:  ADDWFC x10,W
071E4:  MOVWF  FEA
071E6:  MOVFF  FEF,711
071EA:  MOVFF  FEC,712
071EE:  MOVFF  FEC,713
071F2:  MOVFF  FEC,714
071F6:  MOVLW  01
071F8:  SUBWF  x0B,W
071FA:  MULLW  28
071FC:  MOVF   FF3,W
071FE:  CLRF   x16
07200:  MOVWF  x15
07202:  MOVLW  04
07204:  ADDWF  x15,W
07206:  MOVWF  01
07208:  MOVLW  00
0720A:  ADDWFC x16,W
0720C:  MOVWF  03
0720E:  MOVF   01,W
07210:  ADDLW  20
07212:  MOVWF  FE9
07214:  MOVLW  00
07216:  ADDWFC 03,W
07218:  MOVWF  FEA
0721A:  MOVFF  FEF,715
0721E:  MOVFF  FEC,716
07222:  MOVFF  FEC,717
07226:  MOVFF  FEC,718
0722A:  MOVLW  01
0722C:  SUBWF  x0B,W
0722E:  MULLW  28
07230:  MOVF   FF3,W
07232:  CLRF   x1A
07234:  MOVWF  x19
07236:  MOVLW  08
07238:  ADDWF  x19,W
0723A:  MOVWF  01
0723C:  MOVLW  00
0723E:  ADDWFC x1A,W
07240:  MOVWF  03
07242:  MOVF   01,W
07244:  ADDLW  20
07246:  MOVWF  FE9
07248:  MOVLW  00
0724A:  ADDWFC 03,W
0724C:  MOVWF  FEA
0724E:  MOVFF  FEF,719
07252:  MOVFF  FEC,71A
07256:  MOVFF  FEC,71B
0725A:  MOVFF  FEC,71C
0725E:  MOVFF  70E,565
07262:  MOVFF  70D,564
07266:  MOVFF  70B,734
0726A:  MOVLW  18
0726C:  MOVWF  x35
0726E:  MOVLB  0
07270:  CALL   6680
07274:  MOVLW  2C
07276:  MOVLB  7
07278:  MOVWF  x50
0727A:  MOVLB  0
0727C:  CALL   5BDE
07280:  MOVLW  89
07282:  MOVWF  FE9
07284:  MOVFF  714,746
07288:  MOVFF  713,745
0728C:  MOVFF  712,744
07290:  MOVFF  711,743
07294:  MOVLW  02
07296:  MOVLB  7
07298:  MOVWF  x47
0729A:  MOVLB  0
0729C:  CALL   5D7C
072A0:  MOVLW  2C
072A2:  MOVLB  7
072A4:  MOVWF  x50
072A6:  MOVLB  0
072A8:  CALL   5BDE
072AC:  MOVLW  89
072AE:  MOVWF  FE9
072B0:  MOVFF  718,746
072B4:  MOVFF  717,745
072B8:  MOVFF  716,744
072BC:  MOVFF  715,743
072C0:  MOVLW  02
072C2:  MOVLB  7
072C4:  MOVWF  x47
072C6:  MOVLB  0
072C8:  CALL   5D7C
072CC:  MOVLW  2C
072CE:  MOVLB  7
072D0:  MOVWF  x50
072D2:  MOVLB  0
072D4:  CALL   5BDE
072D8:  MOVLW  89
072DA:  MOVWF  FE9
072DC:  MOVFF  71C,746
072E0:  MOVFF  71B,745
072E4:  MOVFF  71A,744
072E8:  MOVFF  719,743
072EC:  MOVLW  02
072EE:  MOVLB  7
072F0:  MOVWF  x47
072F2:  MOVLB  0
072F4:  CALL   5D7C
072F8:  MOVLW  2C
072FA:  MOVLB  7
072FC:  MOVWF  x50
072FE:  MOVLB  0
07300:  CALL   5BDE
07304:  BRA    7310
07306:  MOVLB  7
....................    else return INV_PARAM;
07308:  MOVLW  02
0730A:  MOVWF  01
0730C:  MOVLB  0
0730E:  BRA    7314
....................    
....................    return SUCCESS;
07310:  MOVLW  00
07312:  MOVWF  01
07314:  RETURN 0
.................... }
.................... 
.................... int8 setPIDvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char  arg2;
....................    float arg3;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
07632:  MOVLB  7
07634:  CLRF   x47
07636:  MOVFF  690,746
0763A:  CLRF   x49
0763C:  MOVLW  B5
0763E:  MOVWF  x48
07640:  MOVLB  0
07642:  CALL   0890
07646:  MOVFF  02,712
0764A:  MOVFF  01,711
0764E:  MOVLW  06
07650:  MOVLB  7
07652:  ADDWF  x11,F
07654:  MOVLW  00
07656:  ADDWFC x12,F
07658:  MOVLW  32
0765A:  ADDWF  x11,W
0765C:  MOVWF  01
0765E:  MOVLW  00
07660:  ADDWFC x12,W
07662:  MOVWF  03
07664:  MOVF   01,W
07666:  ADDLW  EB
07668:  MOVWF  01
0766A:  MOVLW  01
0766C:  ADDWFC 03,F
0766E:  MOVFF  01,711
07672:  MOVFF  03,712
07676:  MOVFF  03,734
0767A:  MOVFF  01,733
0767E:  MOVLB  0
07680:  CALL   623C
07684:  MOVF   01,F
07686:  BNZ   7690
07688:  MOVLW  02
0768A:  MOVWF  01
0768C:  BRA    7910
0768E:  BRA    76EE
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07690:  MOVLB  7
07692:  CLRF   x47
07694:  MOVFF  690,746
07698:  CLRF   x49
0769A:  MOVLW  B5
0769C:  MOVWF  x48
0769E:  MOVLB  0
076A0:  CALL   0890
076A4:  MOVFF  02,712
076A8:  MOVFF  01,711
076AC:  MOVLW  06
076AE:  MOVLB  7
076B0:  ADDWF  x11,F
076B2:  MOVLW  00
076B4:  ADDWFC x12,F
076B6:  MOVLW  32
076B8:  ADDWF  x11,W
076BA:  MOVWF  01
076BC:  MOVLW  00
076BE:  ADDWFC x12,W
076C0:  MOVWF  03
076C2:  MOVF   01,W
076C4:  ADDLW  EB
076C6:  MOVWF  01
076C8:  MOVLW  01
076CA:  ADDWFC 03,F
076CC:  MOVFF  01,711
076D0:  MOVFF  03,712
076D4:  MOVFF  03,734
076D8:  MOVFF  01,733
076DC:  CLRF   x36
076DE:  CLRF   x35
076E0:  MOVLW  0A
076E2:  MOVWF  x37
076E4:  MOVLB  0
076E6:  CALL   632C
076EA:  MOVFF  01,70B
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
076EE:  MOVLB  7
076F0:  CLRF   x47
076F2:  MOVFF  690,746
076F6:  CLRF   x49
076F8:  MOVLW  B5
076FA:  MOVWF  x48
076FC:  MOVLB  0
076FE:  CALL   0890
07702:  MOVFF  02,712
07706:  MOVFF  01,711
0770A:  MOVLW  06
0770C:  MOVLB  7
0770E:  ADDWF  x11,F
07710:  MOVLW  00
07712:  ADDWFC x12,F
07714:  MOVLW  4B
07716:  ADDWF  x11,W
07718:  MOVWF  01
0771A:  MOVLW  00
0771C:  ADDWFC x12,W
0771E:  MOVWF  03
07720:  MOVF   01,W
07722:  ADDLW  EB
07724:  MOVWF  01
07726:  MOVLW  01
07728:  ADDWFC 03,F
0772A:  MOVFF  01,711
0772E:  MOVFF  03,712
07732:  MOVFF  03,742
07736:  MOVFF  01,741
0773A:  MOVLB  0
0773C:  CALL   5BA6
07740:  MOVFF  02,03
07744:  MOVF   01,W
07746:  SUBLW  01
07748:  BNZ   774E
0774A:  MOVF   03,F
0774C:  BZ    7756
0774E:  MOVLW  02
07750:  MOVWF  01
07752:  BRA    7910
07754:  BRA    7796
....................    else arg2 = SERcmd[rec].p[3][0];
07756:  MOVLB  7
07758:  CLRF   x47
0775A:  MOVFF  690,746
0775E:  CLRF   x49
07760:  MOVLW  B5
07762:  MOVWF  x48
07764:  MOVLB  0
07766:  CALL   0890
0776A:  MOVFF  02,712
0776E:  MOVFF  01,711
07772:  MOVLW  06
07774:  MOVLB  7
07776:  ADDWF  x11,F
07778:  MOVLW  00
0777A:  ADDWFC x12,F
0777C:  MOVLW  4B
0777E:  ADDWF  x11,F
07780:  MOVLW  00
07782:  ADDWFC x12,F
07784:  MOVLW  EB
07786:  ADDWF  x11,W
07788:  MOVWF  FE9
0778A:  MOVLW  01
0778C:  ADDWFC x12,W
0778E:  MOVWF  FEA
07790:  MOVFF  FEF,70C
07794:  MOVLB  0
....................    
....................    if (!arg_is_float(SERcmd[rec].p[4])) return INV_PARAM;
07796:  MOVLB  7
07798:  CLRF   x47
0779A:  MOVFF  690,746
0779E:  CLRF   x49
077A0:  MOVLW  B5
077A2:  MOVWF  x48
077A4:  MOVLB  0
077A6:  CALL   0890
077AA:  MOVFF  02,712
077AE:  MOVFF  01,711
077B2:  MOVLW  06
077B4:  MOVLB  7
077B6:  ADDWF  x11,F
077B8:  MOVLW  00
077BA:  ADDWFC x12,F
077BC:  MOVLW  64
077BE:  ADDWF  x11,W
077C0:  MOVWF  01
077C2:  MOVLW  00
077C4:  ADDWFC x12,W
077C6:  MOVWF  03
077C8:  MOVF   01,W
077CA:  ADDLW  EB
077CC:  MOVWF  01
077CE:  MOVLW  01
077D0:  ADDWFC 03,F
077D2:  MOVFF  01,711
077D6:  MOVFF  03,712
077DA:  MOVFF  03,715
077DE:  MOVFF  01,714
077E2:  MOVLB  0
077E4:  RCALL  7316
077E6:  MOVF   01,F
077E8:  BNZ   77F2
077EA:  MOVLW  02
077EC:  MOVWF  01
077EE:  BRA    7910
077F0:  BRA    7856
....................    else arg3 = strtod(SERcmd[rec].p[4], '\0');
077F2:  MOVLB  7
077F4:  CLRF   x47
077F6:  MOVFF  690,746
077FA:  CLRF   x49
077FC:  MOVLW  B5
077FE:  MOVWF  x48
07800:  MOVLB  0
07802:  CALL   0890
07806:  MOVFF  02,712
0780A:  MOVFF  01,711
0780E:  MOVLW  06
07810:  MOVLB  7
07812:  ADDWF  x11,F
07814:  MOVLW  00
07816:  ADDWFC x12,F
07818:  MOVLW  64
0781A:  ADDWF  x11,W
0781C:  MOVWF  01
0781E:  MOVLW  00
07820:  ADDWFC x12,W
07822:  MOVWF  03
07824:  MOVF   01,W
07826:  ADDLW  EB
07828:  MOVWF  01
0782A:  MOVLW  01
0782C:  ADDWFC 03,F
0782E:  MOVFF  01,711
07832:  MOVFF  03,712
07836:  MOVFF  03,715
0783A:  MOVFF  01,714
0783E:  CLRF   x17
07840:  CLRF   x16
07842:  MOVLB  0
07844:  RCALL  73D8
07846:  MOVFF  03,710
0784A:  MOVFF  02,70F
0784E:  MOVFF  01,70E
07852:  MOVFF  00,70D
....................    
....................    /*** SET P, I, or D VALUE **********/
....................    if      ('P' == arg2) PID[arg1-1].kP = arg3;
07856:  MOVLB  7
07858:  MOVF   x0C,W
0785A:  SUBLW  50
0785C:  BNZ   7888
0785E:  MOVLW  01
07860:  SUBWF  x0B,W
07862:  MULLW  28
07864:  MOVF   FF3,W
07866:  CLRF   x12
07868:  MOVWF  x11
0786A:  MOVLW  20
0786C:  ADDWF  x11,W
0786E:  MOVWF  FE9
07870:  MOVLW  00
07872:  ADDWFC x12,W
07874:  MOVWF  FEA
07876:  MOVFF  70D,FEF
0787A:  MOVFF  70E,FEC
0787E:  MOVFF  70F,FEC
07882:  MOVFF  710,FEC
07886:  BRA    790A
....................    else if ('I' == arg2) PID[arg1-1].kI = arg3;
07888:  MOVF   x0C,W
0788A:  SUBLW  49
0788C:  BNZ   78C4
0788E:  MOVLW  01
07890:  SUBWF  x0B,W
07892:  MULLW  28
07894:  MOVF   FF3,W
07896:  CLRF   x12
07898:  MOVWF  x11
0789A:  MOVLW  04
0789C:  ADDWF  x11,W
0789E:  MOVWF  01
078A0:  MOVLW  00
078A2:  ADDWFC x12,W
078A4:  MOVWF  03
078A6:  MOVF   01,W
078A8:  ADDLW  20
078AA:  MOVWF  FE9
078AC:  MOVLW  00
078AE:  ADDWFC 03,W
078B0:  MOVWF  FEA
078B2:  MOVFF  70D,FEF
078B6:  MOVFF  70E,FEC
078BA:  MOVFF  70F,FEC
078BE:  MOVFF  710,FEC
078C2:  BRA    790A
....................    else if ('D' == arg2) PID[arg1-1].kD = arg3;
078C4:  MOVF   x0C,W
078C6:  SUBLW  44
078C8:  BNZ   7900
078CA:  MOVLW  01
078CC:  SUBWF  x0B,W
078CE:  MULLW  28
078D0:  MOVF   FF3,W
078D2:  CLRF   x12
078D4:  MOVWF  x11
078D6:  MOVLW  08
078D8:  ADDWF  x11,W
078DA:  MOVWF  01
078DC:  MOVLW  00
078DE:  ADDWFC x12,W
078E0:  MOVWF  03
078E2:  MOVF   01,W
078E4:  ADDLW  20
078E6:  MOVWF  FE9
078E8:  MOVLW  00
078EA:  ADDWFC 03,W
078EC:  MOVWF  FEA
078EE:  MOVFF  70D,FEF
078F2:  MOVFF  70E,FEC
078F6:  MOVFF  70F,FEC
078FA:  MOVFF  710,FEC
078FE:  BRA    790A
....................    else return INV_PARAM;
07900:  MOVLW  02
07902:  MOVWF  01
07904:  MOVLB  0
07906:  BRA    7910
07908:  MOVLB  7
....................    
....................    return SUCCESS;
0790A:  MOVLW  00
0790C:  MOVWF  01
0790E:  MOVLB  0
07910:  RETURN 0
.................... }
.................... 
.................... int8 getSetPoint(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
07912:  MOVLB  7
07914:  CLRF   x47
07916:  MOVFF  690,746
0791A:  CLRF   x49
0791C:  MOVLW  B5
0791E:  MOVWF  x48
07920:  MOVLB  0
07922:  CALL   0890
07926:  MOVFF  02,70D
0792A:  MOVFF  01,70C
0792E:  MOVLW  06
07930:  MOVLB  7
07932:  ADDWF  x0C,F
07934:  MOVLW  00
07936:  ADDWFC x0D,F
07938:  MOVLW  32
0793A:  ADDWF  x0C,W
0793C:  MOVWF  01
0793E:  MOVLW  00
07940:  ADDWFC x0D,W
07942:  MOVWF  03
07944:  MOVF   01,W
07946:  ADDLW  EB
07948:  MOVWF  01
0794A:  MOVLW  01
0794C:  ADDWFC 03,F
0794E:  MOVFF  01,70C
07952:  MOVFF  03,70D
07956:  MOVFF  03,734
0795A:  MOVFF  01,733
0795E:  MOVLB  0
07960:  CALL   623C
07964:  MOVF   01,F
07966:  BNZ   7970
07968:  MOVLW  02
0796A:  MOVWF  01
0796C:  BRA    7A72
0796E:  BRA    79CE
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07970:  MOVLB  7
07972:  CLRF   x47
07974:  MOVFF  690,746
07978:  CLRF   x49
0797A:  MOVLW  B5
0797C:  MOVWF  x48
0797E:  MOVLB  0
07980:  CALL   0890
07984:  MOVFF  02,70D
07988:  MOVFF  01,70C
0798C:  MOVLW  06
0798E:  MOVLB  7
07990:  ADDWF  x0C,F
07992:  MOVLW  00
07994:  ADDWFC x0D,F
07996:  MOVLW  32
07998:  ADDWF  x0C,W
0799A:  MOVWF  01
0799C:  MOVLW  00
0799E:  ADDWFC x0D,W
079A0:  MOVWF  03
079A2:  MOVF   01,W
079A4:  ADDLW  EB
079A6:  MOVWF  01
079A8:  MOVLW  01
079AA:  ADDWFC 03,F
079AC:  MOVFF  01,70C
079B0:  MOVFF  03,70D
079B4:  MOVFF  03,734
079B8:  MOVFF  01,733
079BC:  CLRF   x36
079BE:  CLRF   x35
079C0:  MOVLW  0A
079C2:  MOVWF  x37
079C4:  MOVLB  0
079C6:  CALL   632C
079CA:  MOVFF  01,70B
....................    
....................    /*** GET SETPOINT ******************/ 
....................    sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].SP);
079CE:  MOVLW  04
079D0:  MOVLB  7
079D2:  MOVWF  x42
079D4:  MOVLW  C1
079D6:  MOVWF  x41
079D8:  MOVLB  0
079DA:  CALL   5BA6
079DE:  MOVF   01,W
079E0:  ADDLW  C1
079E2:  MOVLB  7
079E4:  MOVWF  x0C
079E6:  MOVLW  04
079E8:  ADDWFC 02,W
079EA:  MOVWF  x0D
079EC:  MOVLW  01
079EE:  SUBWF  x0B,W
079F0:  MULLW  28
079F2:  MOVF   FF3,W
079F4:  CLRF   x0F
079F6:  MOVWF  x0E
079F8:  MOVLW  0C
079FA:  ADDWF  x0E,W
079FC:  MOVWF  01
079FE:  MOVLW  00
07A00:  ADDWFC x0F,W
07A02:  MOVWF  03
07A04:  MOVF   01,W
07A06:  ADDLW  20
07A08:  MOVWF  FE9
07A0A:  MOVLW  00
07A0C:  ADDWFC 03,W
07A0E:  MOVWF  FEA
07A10:  MOVFF  FEF,70E
07A14:  MOVFF  FEC,70F
07A18:  MOVFF  FEC,710
07A1C:  MOVFF  FEC,711
07A20:  MOVFF  70D,565
07A24:  MOVFF  70C,564
07A28:  MOVFF  70B,734
07A2C:  MOVLW  18
07A2E:  MOVWF  x35
07A30:  MOVLB  0
07A32:  CALL   6680
07A36:  MOVLW  2C
07A38:  MOVLB  7
07A3A:  MOVWF  x50
07A3C:  MOVLB  0
07A3E:  CALL   5BDE
07A42:  MOVLW  89
07A44:  MOVWF  FE9
07A46:  MOVFF  711,746
07A4A:  MOVFF  710,745
07A4E:  MOVFF  70F,744
07A52:  MOVFF  70E,743
07A56:  MOVLW  02
07A58:  MOVLB  7
07A5A:  MOVWF  x47
07A5C:  MOVLB  0
07A5E:  CALL   5D7C
07A62:  MOVLW  2C
07A64:  MOVLB  7
07A66:  MOVWF  x50
07A68:  MOVLB  0
07A6A:  CALL   5BDE
....................    return SUCCESS;
07A6E:  MOVLW  00
07A70:  MOVWF  01
07A72:  RETURN 0
.................... }
.................... 
.................... int8 setSetPoint(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/   
....................    int8  arg1;
....................    float arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
07A74:  MOVLB  7
07A76:  CLRF   x47
07A78:  MOVFF  690,746
07A7C:  CLRF   x49
07A7E:  MOVLW  B5
07A80:  MOVWF  x48
07A82:  MOVLB  0
07A84:  CALL   0890
07A88:  MOVFF  02,711
07A8C:  MOVFF  01,710
07A90:  MOVLW  06
07A92:  MOVLB  7
07A94:  ADDWF  x10,F
07A96:  MOVLW  00
07A98:  ADDWFC x11,F
07A9A:  MOVLW  32
07A9C:  ADDWF  x10,W
07A9E:  MOVWF  01
07AA0:  MOVLW  00
07AA2:  ADDWFC x11,W
07AA4:  MOVWF  03
07AA6:  MOVF   01,W
07AA8:  ADDLW  EB
07AAA:  MOVWF  01
07AAC:  MOVLW  01
07AAE:  ADDWFC 03,F
07AB0:  MOVFF  01,710
07AB4:  MOVFF  03,711
07AB8:  MOVFF  03,734
07ABC:  MOVFF  01,733
07AC0:  MOVLB  0
07AC2:  CALL   623C
07AC6:  MOVF   01,F
07AC8:  BNZ   7AD2
07ACA:  MOVLW  02
07ACC:  MOVWF  01
07ACE:  BRA    7C30
07AD0:  BRA    7B30
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07AD2:  MOVLB  7
07AD4:  CLRF   x47
07AD6:  MOVFF  690,746
07ADA:  CLRF   x49
07ADC:  MOVLW  B5
07ADE:  MOVWF  x48
07AE0:  MOVLB  0
07AE2:  CALL   0890
07AE6:  MOVFF  02,711
07AEA:  MOVFF  01,710
07AEE:  MOVLW  06
07AF0:  MOVLB  7
07AF2:  ADDWF  x10,F
07AF4:  MOVLW  00
07AF6:  ADDWFC x11,F
07AF8:  MOVLW  32
07AFA:  ADDWF  x10,W
07AFC:  MOVWF  01
07AFE:  MOVLW  00
07B00:  ADDWFC x11,W
07B02:  MOVWF  03
07B04:  MOVF   01,W
07B06:  ADDLW  EB
07B08:  MOVWF  01
07B0A:  MOVLW  01
07B0C:  ADDWFC 03,F
07B0E:  MOVFF  01,710
07B12:  MOVFF  03,711
07B16:  MOVFF  03,734
07B1A:  MOVFF  01,733
07B1E:  CLRF   x36
07B20:  CLRF   x35
07B22:  MOVLW  0A
07B24:  MOVWF  x37
07B26:  MOVLB  0
07B28:  CALL   632C
07B2C:  MOVFF  01,70B
....................    
....................    if (!arg_is_float(SERcmd[rec].p[3])) return INV_PARAM;
07B30:  MOVLB  7
07B32:  CLRF   x47
07B34:  MOVFF  690,746
07B38:  CLRF   x49
07B3A:  MOVLW  B5
07B3C:  MOVWF  x48
07B3E:  MOVLB  0
07B40:  CALL   0890
07B44:  MOVFF  02,711
07B48:  MOVFF  01,710
07B4C:  MOVLW  06
07B4E:  MOVLB  7
07B50:  ADDWF  x10,F
07B52:  MOVLW  00
07B54:  ADDWFC x11,F
07B56:  MOVLW  4B
07B58:  ADDWF  x10,W
07B5A:  MOVWF  01
07B5C:  MOVLW  00
07B5E:  ADDWFC x11,W
07B60:  MOVWF  03
07B62:  MOVF   01,W
07B64:  ADDLW  EB
07B66:  MOVWF  01
07B68:  MOVLW  01
07B6A:  ADDWFC 03,F
07B6C:  MOVFF  01,710
07B70:  MOVFF  03,711
07B74:  MOVFF  03,715
07B78:  MOVFF  01,714
07B7C:  MOVLB  0
07B7E:  CALL   7316
07B82:  MOVF   01,F
07B84:  BNZ   7B8E
07B86:  MOVLW  02
07B88:  MOVWF  01
07B8A:  BRA    7C30
07B8C:  BRA    7BF4
....................    else arg2 = strtod(SERcmd[rec].p[3], '\0');
07B8E:  MOVLB  7
07B90:  CLRF   x47
07B92:  MOVFF  690,746
07B96:  CLRF   x49
07B98:  MOVLW  B5
07B9A:  MOVWF  x48
07B9C:  MOVLB  0
07B9E:  CALL   0890
07BA2:  MOVFF  02,711
07BA6:  MOVFF  01,710
07BAA:  MOVLW  06
07BAC:  MOVLB  7
07BAE:  ADDWF  x10,F
07BB0:  MOVLW  00
07BB2:  ADDWFC x11,F
07BB4:  MOVLW  4B
07BB6:  ADDWF  x10,W
07BB8:  MOVWF  01
07BBA:  MOVLW  00
07BBC:  ADDWFC x11,W
07BBE:  MOVWF  03
07BC0:  MOVF   01,W
07BC2:  ADDLW  EB
07BC4:  MOVWF  01
07BC6:  MOVLW  01
07BC8:  ADDWFC 03,F
07BCA:  MOVFF  01,710
07BCE:  MOVFF  03,711
07BD2:  MOVFF  03,715
07BD6:  MOVFF  01,714
07BDA:  CLRF   x17
07BDC:  CLRF   x16
07BDE:  MOVLB  0
07BE0:  CALL   73D8
07BE4:  MOVFF  03,70F
07BE8:  MOVFF  02,70E
07BEC:  MOVFF  01,70D
07BF0:  MOVFF  00,70C
....................    
....................    /*** SET SETPOINT ******************/ 
....................    PID[arg1-1].SP = arg2;
07BF4:  MOVLW  01
07BF6:  MOVLB  7
07BF8:  SUBWF  x0B,W
07BFA:  MULLW  28
07BFC:  MOVF   FF3,W
07BFE:  CLRF   x11
07C00:  MOVWF  x10
07C02:  MOVLW  0C
07C04:  ADDWF  x10,W
07C06:  MOVWF  01
07C08:  MOVLW  00
07C0A:  ADDWFC x11,W
07C0C:  MOVWF  03
07C0E:  MOVF   01,W
07C10:  ADDLW  20
07C12:  MOVWF  FE9
07C14:  MOVLW  00
07C16:  ADDWFC 03,W
07C18:  MOVWF  FEA
07C1A:  MOVFF  70C,FEF
07C1E:  MOVFF  70D,FEC
07C22:  MOVFF  70E,FEC
07C26:  MOVFF  70F,FEC
....................    
....................    return SUCCESS;
07C2A:  MOVLW  00
07C2C:  MOVWF  01
07C2E:  MOVLB  0
07C30:  RETURN 0
.................... }
.................... 
.................... int8 getAllSensorCalParams(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
07C32:  MOVLB  7
07C34:  CLRF   x47
07C36:  MOVFF  690,746
07C3A:  CLRF   x49
07C3C:  MOVLW  B5
07C3E:  MOVWF  x48
07C40:  MOVLB  0
07C42:  CALL   0890
07C46:  MOVFF  02,70D
07C4A:  MOVFF  01,70C
07C4E:  MOVLW  06
07C50:  MOVLB  7
07C52:  ADDWF  x0C,F
07C54:  MOVLW  00
07C56:  ADDWFC x0D,F
07C58:  MOVLW  32
07C5A:  ADDWF  x0C,W
07C5C:  MOVWF  01
07C5E:  MOVLW  00
07C60:  ADDWFC x0D,W
07C62:  MOVWF  03
07C64:  MOVF   01,W
07C66:  ADDLW  EB
07C68:  MOVWF  01
07C6A:  MOVLW  01
07C6C:  ADDWFC 03,F
07C6E:  MOVFF  01,70C
07C72:  MOVFF  03,70D
07C76:  MOVFF  03,734
07C7A:  MOVFF  01,733
07C7E:  MOVLB  0
07C80:  CALL   623C
07C84:  MOVF   01,F
07C86:  BNZ   7C90
07C88:  MOVLW  02
07C8A:  MOVWF  01
07C8C:  BRA    7FE6
07C8E:  BRA    7CEE
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07C90:  MOVLB  7
07C92:  CLRF   x47
07C94:  MOVFF  690,746
07C98:  CLRF   x49
07C9A:  MOVLW  B5
07C9C:  MOVWF  x48
07C9E:  MOVLB  0
07CA0:  CALL   0890
07CA4:  MOVFF  02,70D
07CA8:  MOVFF  01,70C
07CAC:  MOVLW  06
07CAE:  MOVLB  7
07CB0:  ADDWF  x0C,F
07CB2:  MOVLW  00
07CB4:  ADDWFC x0D,F
07CB6:  MOVLW  32
07CB8:  ADDWF  x0C,W
07CBA:  MOVWF  01
07CBC:  MOVLW  00
07CBE:  ADDWFC x0D,W
07CC0:  MOVWF  03
07CC2:  MOVF   01,W
07CC4:  ADDLW  EB
07CC6:  MOVWF  01
07CC8:  MOVLW  01
07CCA:  ADDWFC 03,F
07CCC:  MOVFF  01,70C
07CD0:  MOVFF  03,70D
07CD4:  MOVFF  03,734
07CD8:  MOVFF  01,733
07CDC:  CLRF   x36
07CDE:  CLRF   x35
07CE0:  MOVLW  0A
07CE2:  MOVWF  x37
07CE4:  MOVLB  0
07CE6:  CALL   632C
07CEA:  MOVFF  01,70B
....................    
....................    /*** GET ALL SENSOR CAL PARAMS *****/
....................    sprintf(retData+strlen(retData), "%d,", arg1);
07CEE:  MOVLW  04
07CF0:  MOVLB  7
07CF2:  MOVWF  x42
07CF4:  MOVLW  C1
07CF6:  MOVWF  x41
07CF8:  MOVLB  0
07CFA:  CALL   5BA6
07CFE:  MOVFF  02,03
07D02:  MOVF   01,W
07D04:  ADDLW  C1
07D06:  MOVLB  7
07D08:  MOVWF  x0C
07D0A:  MOVLW  04
07D0C:  ADDWFC 02,W
07D0E:  MOVWF  x0D
07D10:  MOVFF  FE8,565
07D14:  MOVFF  70C,564
07D18:  MOVFF  70B,734
07D1C:  MOVLW  18
07D1E:  MOVWF  x35
07D20:  MOVLB  0
07D22:  CALL   6680
07D26:  MOVLW  2C
07D28:  MOVLB  7
07D2A:  MOVWF  x50
07D2C:  MOVLB  0
07D2E:  CALL   5BDE
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c0);
07D32:  MOVLW  04
07D34:  MOVLB  7
07D36:  MOVWF  x42
07D38:  MOVLW  C1
07D3A:  MOVWF  x41
07D3C:  MOVLB  0
07D3E:  CALL   5BA6
07D42:  MOVFF  02,03
07D46:  MOVF   01,W
07D48:  ADDLW  C1
07D4A:  MOVLB  7
07D4C:  MOVWF  x0C
07D4E:  MOVLW  04
07D50:  ADDWFC 02,W
07D52:  MOVWF  x0D
07D54:  MOVLW  01
07D56:  SUBWF  x0B,W
07D58:  MULLW  18
07D5A:  MOVF   FF3,W
07D5C:  CLRF   x0F
07D5E:  MOVWF  x0E
07D60:  MOVLW  92
07D62:  ADDWF  x0E,W
07D64:  MOVWF  FE9
07D66:  MOVLW  00
07D68:  ADDWFC x0F,W
07D6A:  MOVWF  FEA
07D6C:  MOVFF  FEF,743
07D70:  MOVFF  FEC,744
07D74:  MOVFF  FEC,745
07D78:  MOVFF  FEC,746
07D7C:  MOVFF  70D,565
07D80:  MOVFF  70C,564
07D84:  MOVLW  89
07D86:  MOVWF  FE9
07D88:  MOVLW  02
07D8A:  MOVWF  x47
07D8C:  MOVLB  0
07D8E:  CALL   5D7C
07D92:  MOVLW  2C
07D94:  MOVLB  7
07D96:  MOVWF  x50
07D98:  MOVLB  0
07D9A:  CALL   5BDE
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c1);
07D9E:  MOVLW  04
07DA0:  MOVLB  7
07DA2:  MOVWF  x42
07DA4:  MOVLW  C1
07DA6:  MOVWF  x41
07DA8:  MOVLB  0
07DAA:  CALL   5BA6
07DAE:  MOVF   01,W
07DB0:  ADDLW  C1
07DB2:  MOVLB  7
07DB4:  MOVWF  x0C
07DB6:  MOVLW  04
07DB8:  ADDWFC 02,W
07DBA:  MOVWF  x0D
07DBC:  MOVLW  01
07DBE:  SUBWF  x0B,W
07DC0:  MULLW  18
07DC2:  MOVF   FF3,W
07DC4:  CLRF   x0F
07DC6:  MOVWF  x0E
07DC8:  MOVLW  04
07DCA:  ADDWF  x0E,W
07DCC:  MOVWF  01
07DCE:  MOVLW  00
07DD0:  ADDWFC x0F,W
07DD2:  MOVWF  03
07DD4:  MOVF   01,W
07DD6:  ADDLW  92
07DD8:  MOVWF  FE9
07DDA:  MOVLW  00
07DDC:  ADDWFC 03,W
07DDE:  MOVWF  FEA
07DE0:  MOVFF  FEF,743
07DE4:  MOVFF  FEC,744
07DE8:  MOVFF  FEC,745
07DEC:  MOVFF  FEC,746
07DF0:  MOVFF  70D,565
07DF4:  MOVFF  70C,564
07DF8:  MOVLW  89
07DFA:  MOVWF  FE9
07DFC:  MOVLW  02
07DFE:  MOVWF  x47
07E00:  MOVLB  0
07E02:  CALL   5D7C
07E06:  MOVLW  2C
07E08:  MOVLB  7
07E0A:  MOVWF  x50
07E0C:  MOVLB  0
07E0E:  CALL   5BDE
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c2);
07E12:  MOVLW  04
07E14:  MOVLB  7
07E16:  MOVWF  x42
07E18:  MOVLW  C1
07E1A:  MOVWF  x41
07E1C:  MOVLB  0
07E1E:  CALL   5BA6
07E22:  MOVF   01,W
07E24:  ADDLW  C1
07E26:  MOVLB  7
07E28:  MOVWF  x0C
07E2A:  MOVLW  04
07E2C:  ADDWFC 02,W
07E2E:  MOVWF  x0D
07E30:  MOVLW  01
07E32:  SUBWF  x0B,W
07E34:  MULLW  18
07E36:  MOVF   FF3,W
07E38:  CLRF   x0F
07E3A:  MOVWF  x0E
07E3C:  MOVLW  08
07E3E:  ADDWF  x0E,W
07E40:  MOVWF  01
07E42:  MOVLW  00
07E44:  ADDWFC x0F,W
07E46:  MOVWF  03
07E48:  MOVF   01,W
07E4A:  ADDLW  92
07E4C:  MOVWF  FE9
07E4E:  MOVLW  00
07E50:  ADDWFC 03,W
07E52:  MOVWF  FEA
07E54:  MOVFF  FEF,743
07E58:  MOVFF  FEC,744
07E5C:  MOVFF  FEC,745
07E60:  MOVFF  FEC,746
07E64:  MOVFF  70D,565
07E68:  MOVFF  70C,564
07E6C:  MOVLW  89
07E6E:  MOVWF  FE9
07E70:  MOVLW  02
07E72:  MOVWF  x47
07E74:  MOVLB  0
07E76:  CALL   5D7C
07E7A:  MOVLW  2C
07E7C:  MOVLB  7
07E7E:  MOVWF  x50
07E80:  MOVLB  0
07E82:  CALL   5BDE
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c3);
07E86:  MOVLW  04
07E88:  MOVLB  7
07E8A:  MOVWF  x42
07E8C:  MOVLW  C1
07E8E:  MOVWF  x41
07E90:  MOVLB  0
07E92:  CALL   5BA6
07E96:  MOVF   01,W
07E98:  ADDLW  C1
07E9A:  MOVLB  7
07E9C:  MOVWF  x0C
07E9E:  MOVLW  04
07EA0:  ADDWFC 02,W
07EA2:  MOVWF  x0D
07EA4:  MOVLW  01
07EA6:  SUBWF  x0B,W
07EA8:  MULLW  18
07EAA:  MOVF   FF3,W
07EAC:  CLRF   x0F
07EAE:  MOVWF  x0E
07EB0:  MOVLW  0C
07EB2:  ADDWF  x0E,W
07EB4:  MOVWF  01
07EB6:  MOVLW  00
07EB8:  ADDWFC x0F,W
07EBA:  MOVWF  03
07EBC:  MOVF   01,W
07EBE:  ADDLW  92
07EC0:  MOVWF  FE9
07EC2:  MOVLW  00
07EC4:  ADDWFC 03,W
07EC6:  MOVWF  FEA
07EC8:  MOVFF  FEF,743
07ECC:  MOVFF  FEC,744
07ED0:  MOVFF  FEC,745
07ED4:  MOVFF  FEC,746
07ED8:  MOVFF  70D,565
07EDC:  MOVFF  70C,564
07EE0:  MOVLW  89
07EE2:  MOVWF  FE9
07EE4:  MOVLW  02
07EE6:  MOVWF  x47
07EE8:  MOVLB  0
07EEA:  CALL   5D7C
07EEE:  MOVLW  2C
07EF0:  MOVLB  7
07EF2:  MOVWF  x50
07EF4:  MOVLB  0
07EF6:  CALL   5BDE
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c4);
07EFA:  MOVLW  04
07EFC:  MOVLB  7
07EFE:  MOVWF  x42
07F00:  MOVLW  C1
07F02:  MOVWF  x41
07F04:  MOVLB  0
07F06:  CALL   5BA6
07F0A:  MOVF   01,W
07F0C:  ADDLW  C1
07F0E:  MOVLB  7
07F10:  MOVWF  x0C
07F12:  MOVLW  04
07F14:  ADDWFC 02,W
07F16:  MOVWF  x0D
07F18:  MOVLW  01
07F1A:  SUBWF  x0B,W
07F1C:  MULLW  18
07F1E:  MOVF   FF3,W
07F20:  CLRF   x0F
07F22:  MOVWF  x0E
07F24:  MOVLW  10
07F26:  ADDWF  x0E,W
07F28:  MOVWF  01
07F2A:  MOVLW  00
07F2C:  ADDWFC x0F,W
07F2E:  MOVWF  03
07F30:  MOVF   01,W
07F32:  ADDLW  92
07F34:  MOVWF  FE9
07F36:  MOVLW  00
07F38:  ADDWFC 03,W
07F3A:  MOVWF  FEA
07F3C:  MOVFF  FEF,743
07F40:  MOVFF  FEC,744
07F44:  MOVFF  FEC,745
07F48:  MOVFF  FEC,746
07F4C:  MOVFF  70D,565
07F50:  MOVFF  70C,564
07F54:  MOVLW  89
07F56:  MOVWF  FE9
07F58:  MOVLW  02
07F5A:  MOVWF  x47
07F5C:  MOVLB  0
07F5E:  CALL   5D7C
07F62:  MOVLW  2C
07F64:  MOVLB  7
07F66:  MOVWF  x50
07F68:  MOVLB  0
07F6A:  CALL   5BDE
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c5);
07F6E:  MOVLW  04
07F70:  MOVLB  7
07F72:  MOVWF  x42
07F74:  MOVLW  C1
07F76:  MOVWF  x41
07F78:  MOVLB  0
07F7A:  CALL   5BA6
07F7E:  MOVF   01,W
07F80:  ADDLW  C1
07F82:  MOVLB  7
07F84:  MOVWF  x0C
07F86:  MOVLW  04
07F88:  ADDWFC 02,W
07F8A:  MOVWF  x0D
07F8C:  MOVLW  01
07F8E:  SUBWF  x0B,W
07F90:  MULLW  18
07F92:  MOVF   FF3,W
07F94:  CLRF   x0F
07F96:  MOVWF  x0E
07F98:  MOVLW  14
07F9A:  ADDWF  x0E,W
07F9C:  MOVWF  01
07F9E:  MOVLW  00
07FA0:  ADDWFC x0F,W
07FA2:  MOVWF  03
07FA4:  MOVF   01,W
07FA6:  ADDLW  92
07FA8:  MOVWF  FE9
07FAA:  MOVLW  00
07FAC:  ADDWFC 03,W
07FAE:  MOVWF  FEA
07FB0:  MOVFF  FEF,743
07FB4:  MOVFF  FEC,744
07FB8:  MOVFF  FEC,745
07FBC:  MOVFF  FEC,746
07FC0:  MOVFF  70D,565
07FC4:  MOVFF  70C,564
07FC8:  MOVLW  89
07FCA:  MOVWF  FE9
07FCC:  MOVLW  02
07FCE:  MOVWF  x47
07FD0:  MOVLB  0
07FD2:  CALL   5D7C
07FD6:  MOVLW  2C
07FD8:  MOVLB  7
07FDA:  MOVWF  x50
07FDC:  MOVLB  0
07FDE:  CALL   5BDE
....................    
....................    return SUCCESS;
07FE2:  MOVLW  00
07FE4:  MOVWF  01
07FE6:  RETURN 0
.................... }
.................... 
.................... int8 getSensorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
07FE8:  MOVLB  7
07FEA:  CLRF   x47
07FEC:  MOVFF  690,746
07FF0:  CLRF   x49
07FF2:  MOVLW  B5
07FF4:  MOVWF  x48
07FF6:  MOVLB  0
07FF8:  CALL   0890
07FFC:  MOVFF  02,70E
08000:  MOVFF  01,70D
08004:  MOVLW  06
08006:  MOVLB  7
08008:  ADDWF  x0D,F
0800A:  MOVLW  00
0800C:  ADDWFC x0E,F
0800E:  MOVLW  32
08010:  ADDWF  x0D,W
08012:  MOVWF  01
08014:  MOVLW  00
08016:  ADDWFC x0E,W
08018:  MOVWF  03
0801A:  MOVF   01,W
0801C:  ADDLW  EB
0801E:  MOVWF  01
08020:  MOVLW  01
08022:  ADDWFC 03,F
08024:  MOVFF  01,70D
08028:  MOVFF  03,70E
0802C:  MOVFF  03,734
08030:  MOVFF  01,733
08034:  MOVLB  0
08036:  CALL   623C
0803A:  MOVF   01,F
0803C:  BNZ   8046
0803E:  MOVLW  02
08040:  MOVWF  01
08042:  BRA    8542
08044:  BRA    80A4
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
08046:  MOVLB  7
08048:  CLRF   x47
0804A:  MOVFF  690,746
0804E:  CLRF   x49
08050:  MOVLW  B5
08052:  MOVWF  x48
08054:  MOVLB  0
08056:  CALL   0890
0805A:  MOVFF  02,70E
0805E:  MOVFF  01,70D
08062:  MOVLW  06
08064:  MOVLB  7
08066:  ADDWF  x0D,F
08068:  MOVLW  00
0806A:  ADDWFC x0E,F
0806C:  MOVLW  32
0806E:  ADDWF  x0D,W
08070:  MOVWF  01
08072:  MOVLW  00
08074:  ADDWFC x0E,W
08076:  MOVWF  03
08078:  MOVF   01,W
0807A:  ADDLW  EB
0807C:  MOVWF  01
0807E:  MOVLW  01
08080:  ADDWFC 03,F
08082:  MOVFF  01,70D
08086:  MOVFF  03,70E
0808A:  MOVFF  03,734
0808E:  MOVFF  01,733
08092:  CLRF   x36
08094:  CLRF   x35
08096:  MOVLW  0A
08098:  MOVWF  x37
0809A:  MOVLB  0
0809C:  CALL   632C
080A0:  MOVFF  01,70B
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
080A4:  MOVLB  7
080A6:  CLRF   x47
080A8:  MOVFF  690,746
080AC:  CLRF   x49
080AE:  MOVLW  B5
080B0:  MOVWF  x48
080B2:  MOVLB  0
080B4:  CALL   0890
080B8:  MOVFF  02,70E
080BC:  MOVFF  01,70D
080C0:  MOVLW  06
080C2:  MOVLB  7
080C4:  ADDWF  x0D,F
080C6:  MOVLW  00
080C8:  ADDWFC x0E,F
080CA:  MOVLW  4B
080CC:  ADDWF  x0D,W
080CE:  MOVWF  01
080D0:  MOVLW  00
080D2:  ADDWFC x0E,W
080D4:  MOVWF  03
080D6:  MOVF   01,W
080D8:  ADDLW  EB
080DA:  MOVWF  01
080DC:  MOVLW  01
080DE:  ADDWFC 03,F
080E0:  MOVFF  01,70D
080E4:  MOVFF  03,70E
080E8:  MOVFF  03,742
080EC:  MOVFF  01,741
080F0:  MOVLB  0
080F2:  CALL   5BA6
080F6:  MOVFF  02,03
080FA:  MOVF   01,W
080FC:  SUBLW  01
080FE:  BNZ   8104
08100:  MOVF   03,F
08102:  BZ    810C
08104:  MOVLW  02
08106:  MOVWF  01
08108:  BRA    8542
0810A:  BRA    814C
....................    else arg2 = SERcmd[rec].p[3][0];
0810C:  MOVLB  7
0810E:  CLRF   x47
08110:  MOVFF  690,746
08114:  CLRF   x49
08116:  MOVLW  B5
08118:  MOVWF  x48
0811A:  MOVLB  0
0811C:  CALL   0890
08120:  MOVFF  02,70E
08124:  MOVFF  01,70D
08128:  MOVLW  06
0812A:  MOVLB  7
0812C:  ADDWF  x0D,F
0812E:  MOVLW  00
08130:  ADDWFC x0E,F
08132:  MOVLW  4B
08134:  ADDWF  x0D,F
08136:  MOVLW  00
08138:  ADDWFC x0E,F
0813A:  MOVLW  EB
0813C:  ADDWF  x0D,W
0813E:  MOVWF  FE9
08140:  MOVLW  01
08142:  ADDWFC x0E,W
08144:  MOVWF  FEA
08146:  MOVFF  FEF,70C
0814A:  MOVLB  0
....................    
....................    /*** GET SENSOR CAL PARAM **********/
....................    if      ('0' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c0);
0814C:  MOVLB  7
0814E:  MOVF   x0C,W
08150:  SUBLW  30
08152:  BNZ   81EE
08154:  MOVLW  04
08156:  MOVWF  x42
08158:  MOVLW  C1
0815A:  MOVWF  x41
0815C:  MOVLB  0
0815E:  CALL   5BA6
08162:  MOVFF  02,03
08166:  MOVF   01,W
08168:  ADDLW  C1
0816A:  MOVLB  7
0816C:  MOVWF  x0D
0816E:  MOVLW  04
08170:  ADDWFC 02,W
08172:  MOVWF  x0E
08174:  MOVLW  01
08176:  SUBWF  x0B,W
08178:  MULLW  18
0817A:  MOVF   FF3,W
0817C:  CLRF   x10
0817E:  MOVWF  x0F
08180:  MOVLW  92
08182:  ADDWF  x0F,W
08184:  MOVWF  FE9
08186:  MOVLW  00
08188:  ADDWFC x10,W
0818A:  MOVWF  FEA
0818C:  MOVFF  FEF,711
08190:  MOVFF  FEC,712
08194:  MOVFF  FEC,713
08198:  MOVFF  FEC,714
0819C:  MOVFF  70E,565
081A0:  MOVFF  70D,564
081A4:  MOVFF  70B,734
081A8:  MOVLW  18
081AA:  MOVWF  x35
081AC:  MOVLB  0
081AE:  CALL   6680
081B2:  MOVLW  2C
081B4:  MOVLB  7
081B6:  MOVWF  x50
081B8:  MOVLB  0
081BA:  CALL   5BDE
081BE:  MOVLW  89
081C0:  MOVWF  FE9
081C2:  MOVFF  714,746
081C6:  MOVFF  713,745
081CA:  MOVFF  712,744
081CE:  MOVFF  711,743
081D2:  MOVLW  02
081D4:  MOVLB  7
081D6:  MOVWF  x47
081D8:  MOVLB  0
081DA:  CALL   5D7C
081DE:  MOVLW  2C
081E0:  MOVLB  7
081E2:  MOVWF  x50
081E4:  MOVLB  0
081E6:  CALL   5BDE
081EA:  BRA    853E
081EC:  MOVLB  7
....................    else if ('1' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c1);
081EE:  MOVF   x0C,W
081F0:  SUBLW  31
081F2:  BNZ   8296
081F4:  MOVLW  04
081F6:  MOVWF  x42
081F8:  MOVLW  C1
081FA:  MOVWF  x41
081FC:  MOVLB  0
081FE:  CALL   5BA6
08202:  MOVF   01,W
08204:  ADDLW  C1
08206:  MOVLB  7
08208:  MOVWF  x0D
0820A:  MOVLW  04
0820C:  ADDWFC 02,W
0820E:  MOVWF  x0E
08210:  MOVLW  01
08212:  SUBWF  x0B,W
08214:  MULLW  18
08216:  MOVF   FF3,W
08218:  CLRF   x10
0821A:  MOVWF  x0F
0821C:  MOVLW  04
0821E:  ADDWF  x0F,W
08220:  MOVWF  01
08222:  MOVLW  00
08224:  ADDWFC x10,W
08226:  MOVWF  03
08228:  MOVF   01,W
0822A:  ADDLW  92
0822C:  MOVWF  FE9
0822E:  MOVLW  00
08230:  ADDWFC 03,W
08232:  MOVWF  FEA
08234:  MOVFF  FEF,70F
08238:  MOVFF  FEC,710
0823C:  MOVFF  FEC,711
08240:  MOVFF  FEC,712
08244:  MOVFF  70E,565
08248:  MOVFF  70D,564
0824C:  MOVFF  70B,734
08250:  MOVLW  18
08252:  MOVWF  x35
08254:  MOVLB  0
08256:  CALL   6680
0825A:  MOVLW  2C
0825C:  MOVLB  7
0825E:  MOVWF  x50
08260:  MOVLB  0
08262:  CALL   5BDE
08266:  MOVLW  89
08268:  MOVWF  FE9
0826A:  MOVFF  712,746
0826E:  MOVFF  711,745
08272:  MOVFF  710,744
08276:  MOVFF  70F,743
0827A:  MOVLW  02
0827C:  MOVLB  7
0827E:  MOVWF  x47
08280:  MOVLB  0
08282:  CALL   5D7C
08286:  MOVLW  2C
08288:  MOVLB  7
0828A:  MOVWF  x50
0828C:  MOVLB  0
0828E:  CALL   5BDE
08292:  BRA    853E
08294:  MOVLB  7
....................    else if ('2' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c2);
08296:  MOVF   x0C,W
08298:  SUBLW  32
0829A:  BNZ   833E
0829C:  MOVLW  04
0829E:  MOVWF  x42
082A0:  MOVLW  C1
082A2:  MOVWF  x41
082A4:  MOVLB  0
082A6:  CALL   5BA6
082AA:  MOVF   01,W
082AC:  ADDLW  C1
082AE:  MOVLB  7
082B0:  MOVWF  x0D
082B2:  MOVLW  04
082B4:  ADDWFC 02,W
082B6:  MOVWF  x0E
082B8:  MOVLW  01
082BA:  SUBWF  x0B,W
082BC:  MULLW  18
082BE:  MOVF   FF3,W
082C0:  CLRF   x10
082C2:  MOVWF  x0F
082C4:  MOVLW  08
082C6:  ADDWF  x0F,W
082C8:  MOVWF  01
082CA:  MOVLW  00
082CC:  ADDWFC x10,W
082CE:  MOVWF  03
082D0:  MOVF   01,W
082D2:  ADDLW  92
082D4:  MOVWF  FE9
082D6:  MOVLW  00
082D8:  ADDWFC 03,W
082DA:  MOVWF  FEA
082DC:  MOVFF  FEF,70F
082E0:  MOVFF  FEC,710
082E4:  MOVFF  FEC,711
082E8:  MOVFF  FEC,712
082EC:  MOVFF  70E,565
082F0:  MOVFF  70D,564
082F4:  MOVFF  70B,734
082F8:  MOVLW  18
082FA:  MOVWF  x35
082FC:  MOVLB  0
082FE:  CALL   6680
08302:  MOVLW  2C
08304:  MOVLB  7
08306:  MOVWF  x50
08308:  MOVLB  0
0830A:  CALL   5BDE
0830E:  MOVLW  89
08310:  MOVWF  FE9
08312:  MOVFF  712,746
08316:  MOVFF  711,745
0831A:  MOVFF  710,744
0831E:  MOVFF  70F,743
08322:  MOVLW  02
08324:  MOVLB  7
08326:  MOVWF  x47
08328:  MOVLB  0
0832A:  CALL   5D7C
0832E:  MOVLW  2C
08330:  MOVLB  7
08332:  MOVWF  x50
08334:  MOVLB  0
08336:  CALL   5BDE
0833A:  BRA    853E
0833C:  MOVLB  7
....................    else if ('3' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c3);
0833E:  MOVF   x0C,W
08340:  SUBLW  33
08342:  BNZ   83E6
08344:  MOVLW  04
08346:  MOVWF  x42
08348:  MOVLW  C1
0834A:  MOVWF  x41
0834C:  MOVLB  0
0834E:  CALL   5BA6
08352:  MOVF   01,W
08354:  ADDLW  C1
08356:  MOVLB  7
08358:  MOVWF  x0D
0835A:  MOVLW  04
0835C:  ADDWFC 02,W
0835E:  MOVWF  x0E
08360:  MOVLW  01
08362:  SUBWF  x0B,W
08364:  MULLW  18
08366:  MOVF   FF3,W
08368:  CLRF   x10
0836A:  MOVWF  x0F
0836C:  MOVLW  0C
0836E:  ADDWF  x0F,W
08370:  MOVWF  01
08372:  MOVLW  00
08374:  ADDWFC x10,W
08376:  MOVWF  03
08378:  MOVF   01,W
0837A:  ADDLW  92
0837C:  MOVWF  FE9
0837E:  MOVLW  00
08380:  ADDWFC 03,W
08382:  MOVWF  FEA
08384:  MOVFF  FEF,70F
08388:  MOVFF  FEC,710
0838C:  MOVFF  FEC,711
08390:  MOVFF  FEC,712
08394:  MOVFF  70E,565
08398:  MOVFF  70D,564
0839C:  MOVFF  70B,734
083A0:  MOVLW  18
083A2:  MOVWF  x35
083A4:  MOVLB  0
083A6:  CALL   6680
083AA:  MOVLW  2C
083AC:  MOVLB  7
083AE:  MOVWF  x50
083B0:  MOVLB  0
083B2:  CALL   5BDE
083B6:  MOVLW  89
083B8:  MOVWF  FE9
083BA:  MOVFF  712,746
083BE:  MOVFF  711,745
083C2:  MOVFF  710,744
083C6:  MOVFF  70F,743
083CA:  MOVLW  02
083CC:  MOVLB  7
083CE:  MOVWF  x47
083D0:  MOVLB  0
083D2:  CALL   5D7C
083D6:  MOVLW  2C
083D8:  MOVLB  7
083DA:  MOVWF  x50
083DC:  MOVLB  0
083DE:  CALL   5BDE
083E2:  BRA    853E
083E4:  MOVLB  7
....................    else if ('4' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c4);
083E6:  MOVF   x0C,W
083E8:  SUBLW  34
083EA:  BNZ   848E
083EC:  MOVLW  04
083EE:  MOVWF  x42
083F0:  MOVLW  C1
083F2:  MOVWF  x41
083F4:  MOVLB  0
083F6:  CALL   5BA6
083FA:  MOVF   01,W
083FC:  ADDLW  C1
083FE:  MOVLB  7
08400:  MOVWF  x0D
08402:  MOVLW  04
08404:  ADDWFC 02,W
08406:  MOVWF  x0E
08408:  MOVLW  01
0840A:  SUBWF  x0B,W
0840C:  MULLW  18
0840E:  MOVF   FF3,W
08410:  CLRF   x10
08412:  MOVWF  x0F
08414:  MOVLW  10
08416:  ADDWF  x0F,W
08418:  MOVWF  01
0841A:  MOVLW  00
0841C:  ADDWFC x10,W
0841E:  MOVWF  03
08420:  MOVF   01,W
08422:  ADDLW  92
08424:  MOVWF  FE9
08426:  MOVLW  00
08428:  ADDWFC 03,W
0842A:  MOVWF  FEA
0842C:  MOVFF  FEF,70F
08430:  MOVFF  FEC,710
08434:  MOVFF  FEC,711
08438:  MOVFF  FEC,712
0843C:  MOVFF  70E,565
08440:  MOVFF  70D,564
08444:  MOVFF  70B,734
08448:  MOVLW  18
0844A:  MOVWF  x35
0844C:  MOVLB  0
0844E:  CALL   6680
08452:  MOVLW  2C
08454:  MOVLB  7
08456:  MOVWF  x50
08458:  MOVLB  0
0845A:  CALL   5BDE
0845E:  MOVLW  89
08460:  MOVWF  FE9
08462:  MOVFF  712,746
08466:  MOVFF  711,745
0846A:  MOVFF  710,744
0846E:  MOVFF  70F,743
08472:  MOVLW  02
08474:  MOVLB  7
08476:  MOVWF  x47
08478:  MOVLB  0
0847A:  CALL   5D7C
0847E:  MOVLW  2C
08480:  MOVLB  7
08482:  MOVWF  x50
08484:  MOVLB  0
08486:  CALL   5BDE
0848A:  BRA    853E
0848C:  MOVLB  7
....................    else if ('5' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c5);
0848E:  MOVF   x0C,W
08490:  SUBLW  35
08492:  BNZ   8536
08494:  MOVLW  04
08496:  MOVWF  x42
08498:  MOVLW  C1
0849A:  MOVWF  x41
0849C:  MOVLB  0
0849E:  CALL   5BA6
084A2:  MOVF   01,W
084A4:  ADDLW  C1
084A6:  MOVLB  7
084A8:  MOVWF  x0D
084AA:  MOVLW  04
084AC:  ADDWFC 02,W
084AE:  MOVWF  x0E
084B0:  MOVLW  01
084B2:  SUBWF  x0B,W
084B4:  MULLW  18
084B6:  MOVF   FF3,W
084B8:  CLRF   x10
084BA:  MOVWF  x0F
084BC:  MOVLW  14
084BE:  ADDWF  x0F,W
084C0:  MOVWF  01
084C2:  MOVLW  00
084C4:  ADDWFC x10,W
084C6:  MOVWF  03
084C8:  MOVF   01,W
084CA:  ADDLW  92
084CC:  MOVWF  FE9
084CE:  MOVLW  00
084D0:  ADDWFC 03,W
084D2:  MOVWF  FEA
084D4:  MOVFF  FEF,70F
084D8:  MOVFF  FEC,710
084DC:  MOVFF  FEC,711
084E0:  MOVFF  FEC,712
084E4:  MOVFF  70E,565
084E8:  MOVFF  70D,564
084EC:  MOVFF  70B,734
084F0:  MOVLW  18
084F2:  MOVWF  x35
084F4:  MOVLB  0
084F6:  CALL   6680
084FA:  MOVLW  2C
084FC:  MOVLB  7
084FE:  MOVWF  x50
08500:  MOVLB  0
08502:  CALL   5BDE
08506:  MOVLW  89
08508:  MOVWF  FE9
0850A:  MOVFF  712,746
0850E:  MOVFF  711,745
08512:  MOVFF  710,744
08516:  MOVFF  70F,743
0851A:  MOVLW  02
0851C:  MOVLB  7
0851E:  MOVWF  x47
08520:  MOVLB  0
08522:  CALL   5D7C
08526:  MOVLW  2C
08528:  MOVLB  7
0852A:  MOVWF  x50
0852C:  MOVLB  0
0852E:  CALL   5BDE
08532:  BRA    853E
08534:  MOVLB  7
....................    else return INV_PARAM;
08536:  MOVLW  02
08538:  MOVWF  01
0853A:  MOVLB  0
0853C:  BRA    8542
....................    
....................    return SUCCESS;
0853E:  MOVLW  00
08540:  MOVWF  01
08542:  RETURN 0
.................... }
.................... 
.................... int8 setSensorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char  arg2;
....................    float arg3;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
08544:  MOVLB  7
08546:  CLRF   x47
08548:  MOVFF  690,746
0854C:  CLRF   x49
0854E:  MOVLW  B5
08550:  MOVWF  x48
08552:  MOVLB  0
08554:  CALL   0890
08558:  MOVFF  02,712
0855C:  MOVFF  01,711
08560:  MOVLW  06
08562:  MOVLB  7
08564:  ADDWF  x11,F
08566:  MOVLW  00
08568:  ADDWFC x12,F
0856A:  MOVLW  32
0856C:  ADDWF  x11,W
0856E:  MOVWF  01
08570:  MOVLW  00
08572:  ADDWFC x12,W
08574:  MOVWF  03
08576:  MOVF   01,W
08578:  ADDLW  EB
0857A:  MOVWF  01
0857C:  MOVLW  01
0857E:  ADDWFC 03,F
08580:  MOVFF  01,711
08584:  MOVFF  03,712
08588:  MOVFF  03,734
0858C:  MOVFF  01,733
08590:  MOVLB  0
08592:  CALL   623C
08596:  MOVF   01,F
08598:  BNZ   85A2
0859A:  MOVLW  02
0859C:  MOVWF  01
0859E:  BRA    88DA
085A0:  BRA    8600
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
085A2:  MOVLB  7
085A4:  CLRF   x47
085A6:  MOVFF  690,746
085AA:  CLRF   x49
085AC:  MOVLW  B5
085AE:  MOVWF  x48
085B0:  MOVLB  0
085B2:  CALL   0890
085B6:  MOVFF  02,712
085BA:  MOVFF  01,711
085BE:  MOVLW  06
085C0:  MOVLB  7
085C2:  ADDWF  x11,F
085C4:  MOVLW  00
085C6:  ADDWFC x12,F
085C8:  MOVLW  32
085CA:  ADDWF  x11,W
085CC:  MOVWF  01
085CE:  MOVLW  00
085D0:  ADDWFC x12,W
085D2:  MOVWF  03
085D4:  MOVF   01,W
085D6:  ADDLW  EB
085D8:  MOVWF  01
085DA:  MOVLW  01
085DC:  ADDWFC 03,F
085DE:  MOVFF  01,711
085E2:  MOVFF  03,712
085E6:  MOVFF  03,734
085EA:  MOVFF  01,733
085EE:  CLRF   x36
085F0:  CLRF   x35
085F2:  MOVLW  0A
085F4:  MOVWF  x37
085F6:  MOVLB  0
085F8:  CALL   632C
085FC:  MOVFF  01,70B
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
08600:  MOVLB  7
08602:  CLRF   x47
08604:  MOVFF  690,746
08608:  CLRF   x49
0860A:  MOVLW  B5
0860C:  MOVWF  x48
0860E:  MOVLB  0
08610:  CALL   0890
08614:  MOVFF  02,712
08618:  MOVFF  01,711
0861C:  MOVLW  06
0861E:  MOVLB  7
08620:  ADDWF  x11,F
08622:  MOVLW  00
08624:  ADDWFC x12,F
08626:  MOVLW  4B
08628:  ADDWF  x11,W
0862A:  MOVWF  01
0862C:  MOVLW  00
0862E:  ADDWFC x12,W
08630:  MOVWF  03
08632:  MOVF   01,W
08634:  ADDLW  EB
08636:  MOVWF  01
08638:  MOVLW  01
0863A:  ADDWFC 03,F
0863C:  MOVFF  01,711
08640:  MOVFF  03,712
08644:  MOVFF  03,742
08648:  MOVFF  01,741
0864C:  MOVLB  0
0864E:  CALL   5BA6
08652:  MOVFF  02,03
08656:  MOVF   01,W
08658:  SUBLW  01
0865A:  BNZ   8660
0865C:  MOVF   03,F
0865E:  BZ    8668
08660:  MOVLW  02
08662:  MOVWF  01
08664:  BRA    88DA
08666:  BRA    86A8
....................    else arg2 = SERcmd[rec].p[3][0];
08668:  MOVLB  7
0866A:  CLRF   x47
0866C:  MOVFF  690,746
08670:  CLRF   x49
08672:  MOVLW  B5
08674:  MOVWF  x48
08676:  MOVLB  0
08678:  CALL   0890
0867C:  MOVFF  02,712
08680:  MOVFF  01,711
08684:  MOVLW  06
08686:  MOVLB  7
08688:  ADDWF  x11,F
0868A:  MOVLW  00
0868C:  ADDWFC x12,F
0868E:  MOVLW  4B
08690:  ADDWF  x11,F
08692:  MOVLW  00
08694:  ADDWFC x12,F
08696:  MOVLW  EB
08698:  ADDWF  x11,W
0869A:  MOVWF  FE9
0869C:  MOVLW  01
0869E:  ADDWFC x12,W
086A0:  MOVWF  FEA
086A2:  MOVFF  FEF,70C
086A6:  MOVLB  0
....................    
....................    if (!arg_is_float(SERcmd[rec].p[4])) return INV_PARAM;
086A8:  MOVLB  7
086AA:  CLRF   x47
086AC:  MOVFF  690,746
086B0:  CLRF   x49
086B2:  MOVLW  B5
086B4:  MOVWF  x48
086B6:  MOVLB  0
086B8:  CALL   0890
086BC:  MOVFF  02,712
086C0:  MOVFF  01,711
086C4:  MOVLW  06
086C6:  MOVLB  7
086C8:  ADDWF  x11,F
086CA:  MOVLW  00
086CC:  ADDWFC x12,F
086CE:  MOVLW  64
086D0:  ADDWF  x11,W
086D2:  MOVWF  01
086D4:  MOVLW  00
086D6:  ADDWFC x12,W
086D8:  MOVWF  03
086DA:  MOVF   01,W
086DC:  ADDLW  EB
086DE:  MOVWF  01
086E0:  MOVLW  01
086E2:  ADDWFC 03,F
086E4:  MOVFF  01,711
086E8:  MOVFF  03,712
086EC:  MOVFF  03,715
086F0:  MOVFF  01,714
086F4:  MOVLB  0
086F6:  CALL   7316
086FA:  MOVF   01,F
086FC:  BNZ   8706
086FE:  MOVLW  02
08700:  MOVWF  01
08702:  BRA    88DA
08704:  BRA    876C
....................    else arg3 = strtod(SERcmd[rec].p[4], '\0');
08706:  MOVLB  7
08708:  CLRF   x47
0870A:  MOVFF  690,746
0870E:  CLRF   x49
08710:  MOVLW  B5
08712:  MOVWF  x48
08714:  MOVLB  0
08716:  CALL   0890
0871A:  MOVFF  02,712
0871E:  MOVFF  01,711
08722:  MOVLW  06
08724:  MOVLB  7
08726:  ADDWF  x11,F
08728:  MOVLW  00
0872A:  ADDWFC x12,F
0872C:  MOVLW  64
0872E:  ADDWF  x11,W
08730:  MOVWF  01
08732:  MOVLW  00
08734:  ADDWFC x12,W
08736:  MOVWF  03
08738:  MOVF   01,W
0873A:  ADDLW  EB
0873C:  MOVWF  01
0873E:  MOVLW  01
08740:  ADDWFC 03,F
08742:  MOVFF  01,711
08746:  MOVFF  03,712
0874A:  MOVFF  03,715
0874E:  MOVFF  01,714
08752:  CLRF   x17
08754:  CLRF   x16
08756:  MOVLB  0
08758:  CALL   73D8
0875C:  MOVFF  03,710
08760:  MOVFF  02,70F
08764:  MOVFF  01,70E
08768:  MOVFF  00,70D
....................    
....................    /*** SET SENSOR CAL PARAM **********/
....................    if      ('0' == arg2) sensorCal[arg1-1].c0 = arg3;
0876C:  MOVLB  7
0876E:  MOVF   x0C,W
08770:  SUBLW  30
08772:  BNZ   879E
08774:  MOVLW  01
08776:  SUBWF  x0B,W
08778:  MULLW  18
0877A:  MOVF   FF3,W
0877C:  CLRF   x12
0877E:  MOVWF  x11
08780:  MOVLW  92
08782:  ADDWF  x11,W
08784:  MOVWF  FE9
08786:  MOVLW  00
08788:  ADDWFC x12,W
0878A:  MOVWF  FEA
0878C:  MOVFF  70D,FEF
08790:  MOVFF  70E,FEC
08794:  MOVFF  70F,FEC
08798:  MOVFF  710,FEC
0879C:  BRA    88D4
....................    else if ('1' == arg2) sensorCal[arg1-1].c1 = arg3;
0879E:  MOVF   x0C,W
087A0:  SUBLW  31
087A2:  BNZ   87DA
087A4:  MOVLW  01
087A6:  SUBWF  x0B,W
087A8:  MULLW  18
087AA:  MOVF   FF3,W
087AC:  CLRF   x12
087AE:  MOVWF  x11
087B0:  MOVLW  04
087B2:  ADDWF  x11,W
087B4:  MOVWF  01
087B6:  MOVLW  00
087B8:  ADDWFC x12,W
087BA:  MOVWF  03
087BC:  MOVF   01,W
087BE:  ADDLW  92
087C0:  MOVWF  FE9
087C2:  MOVLW  00
087C4:  ADDWFC 03,W
087C6:  MOVWF  FEA
087C8:  MOVFF  70D,FEF
087CC:  MOVFF  70E,FEC
087D0:  MOVFF  70F,FEC
087D4:  MOVFF  710,FEC
087D8:  BRA    88D4
....................    else if ('2' == arg2) sensorCal[arg1-1].c2 = arg3;
087DA:  MOVF   x0C,W
087DC:  SUBLW  32
087DE:  BNZ   8816
087E0:  MOVLW  01
087E2:  SUBWF  x0B,W
087E4:  MULLW  18
087E6:  MOVF   FF3,W
087E8:  CLRF   x12
087EA:  MOVWF  x11
087EC:  MOVLW  08
087EE:  ADDWF  x11,W
087F0:  MOVWF  01
087F2:  MOVLW  00
087F4:  ADDWFC x12,W
087F6:  MOVWF  03
087F8:  MOVF   01,W
087FA:  ADDLW  92
087FC:  MOVWF  FE9
087FE:  MOVLW  00
08800:  ADDWFC 03,W
08802:  MOVWF  FEA
08804:  MOVFF  70D,FEF
08808:  MOVFF  70E,FEC
0880C:  MOVFF  70F,FEC
08810:  MOVFF  710,FEC
08814:  BRA    88D4
....................    else if ('3' == arg2) sensorCal[arg1-1].c3 = arg3;
08816:  MOVF   x0C,W
08818:  SUBLW  33
0881A:  BNZ   8852
0881C:  MOVLW  01
0881E:  SUBWF  x0B,W
08820:  MULLW  18
08822:  MOVF   FF3,W
08824:  CLRF   x12
08826:  MOVWF  x11
08828:  MOVLW  0C
0882A:  ADDWF  x11,W
0882C:  MOVWF  01
0882E:  MOVLW  00
08830:  ADDWFC x12,W
08832:  MOVWF  03
08834:  MOVF   01,W
08836:  ADDLW  92
08838:  MOVWF  FE9
0883A:  MOVLW  00
0883C:  ADDWFC 03,W
0883E:  MOVWF  FEA
08840:  MOVFF  70D,FEF
08844:  MOVFF  70E,FEC
08848:  MOVFF  70F,FEC
0884C:  MOVFF  710,FEC
08850:  BRA    88D4
....................    else if ('4' == arg2) sensorCal[arg1-1].c4 = arg3;
08852:  MOVF   x0C,W
08854:  SUBLW  34
08856:  BNZ   888E
08858:  MOVLW  01
0885A:  SUBWF  x0B,W
0885C:  MULLW  18
0885E:  MOVF   FF3,W
08860:  CLRF   x12
08862:  MOVWF  x11
08864:  MOVLW  10
08866:  ADDWF  x11,W
08868:  MOVWF  01
0886A:  MOVLW  00
0886C:  ADDWFC x12,W
0886E:  MOVWF  03
08870:  MOVF   01,W
08872:  ADDLW  92
08874:  MOVWF  FE9
08876:  MOVLW  00
08878:  ADDWFC 03,W
0887A:  MOVWF  FEA
0887C:  MOVFF  70D,FEF
08880:  MOVFF  70E,FEC
08884:  MOVFF  70F,FEC
08888:  MOVFF  710,FEC
0888C:  BRA    88D4
....................    else if ('5' == arg2) sensorCal[arg1-1].c5 = arg3;
0888E:  MOVF   x0C,W
08890:  SUBLW  35
08892:  BNZ   88CA
08894:  MOVLW  01
08896:  SUBWF  x0B,W
08898:  MULLW  18
0889A:  MOVF   FF3,W
0889C:  CLRF   x12
0889E:  MOVWF  x11
088A0:  MOVLW  14
088A2:  ADDWF  x11,W
088A4:  MOVWF  01
088A6:  MOVLW  00
088A8:  ADDWFC x12,W
088AA:  MOVWF  03
088AC:  MOVF   01,W
088AE:  ADDLW  92
088B0:  MOVWF  FE9
088B2:  MOVLW  00
088B4:  ADDWFC 03,W
088B6:  MOVWF  FEA
088B8:  MOVFF  70D,FEF
088BC:  MOVFF  70E,FEC
088C0:  MOVFF  70F,FEC
088C4:  MOVFF  710,FEC
088C8:  BRA    88D4
....................    else return INV_PARAM;
088CA:  MOVLW  02
088CC:  MOVWF  01
088CE:  MOVLB  0
088D0:  BRA    88DA
088D2:  MOVLB  7
....................    
....................    return SUCCESS;
088D4:  MOVLW  00
088D6:  MOVWF  01
088D8:  MOVLB  0
088DA:  RETURN 0
.................... }
.................... 
.................... int8 getMonitorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    char *arg1;
....................    char *s_N15 = "N15";
088DC:  MOVLW  4E
088DE:  MOVLB  7
088E0:  MOVWF  x0F
088E2:  MOVLW  31
088E4:  MOVWF  x10
088E6:  MOVLW  35
088E8:  MOVWF  x11
088EA:  CLRF   x12
088EC:  MOVLW  07
088EE:  MOVWF  x0E
088F0:  MOVLW  0F
088F2:  MOVWF  x0D
....................    char *s_200 = "200";
088F4:  MOVLW  32
088F6:  MOVWF  x15
088F8:  MOVLW  30
088FA:  MOVWF  x16
088FC:  MOVWF  x17
088FE:  CLRF   x18
08900:  MOVLW  07
08902:  MOVWF  x14
08904:  MOVLW  15
08906:  MOVWF  x13
....................    char *s_5V6 = "5V6";
08908:  MOVLW  35
0890A:  MOVWF  x1B
0890C:  MOVLW  56
0890E:  MOVWF  x1C
08910:  MOVLW  36
08912:  MOVWF  x1D
08914:  CLRF   x1E
08916:  MOVLW  07
08918:  MOVWF  x1A
0891A:  MOVLW  1B
0891C:  MOVWF  x19
....................    char *s_5VA = "5VA";
0891E:  MOVLW  35
08920:  MOVWF  x21
08922:  MOVLW  56
08924:  MOVWF  x22
08926:  MOVLW  41
08928:  MOVWF  x23
0892A:  CLRF   x24
0892C:  MOVLW  07
0892E:  MOVWF  x20
08930:  MOVLW  21
08932:  MOVWF  x1F
....................    char *s_3V6X = "3V6X";
08934:  MOVLW  33
08936:  MOVWF  x27
08938:  MOVLW  56
0893A:  MOVWF  x28
0893C:  MOVLW  36
0893E:  MOVWF  x29
08940:  MOVLW  58
08942:  MOVWF  x2A
08944:  CLRF   x2B
08946:  MOVLW  07
08948:  MOVWF  x26
0894A:  MOVLW  27
0894C:  MOVWF  x25
....................    char *s_3V3A = "3V3A";
0894E:  MOVLW  33
08950:  MOVWF  x2E
08952:  MOVLW  56
08954:  MOVWF  x2F
08956:  MOVLW  33
08958:  MOVWF  x30
0895A:  MOVLW  41
0895C:  MOVWF  x31
0895E:  CLRF   x32
08960:  MOVLW  07
08962:  MOVWF  x2D
08964:  MOVLW  2E
08966:  MOVWF  x2C
....................    char *s_3V3D = "3V3D";
08968:  MOVLW  33
0896A:  MOVWF  x35
0896C:  MOVLW  56
0896E:  MOVWF  x36
08970:  MOVLW  33
08972:  MOVWF  x37
08974:  MOVLW  44
08976:  MOVWF  x38
08978:  CLRF   x39
0897A:  MOVLW  07
0897C:  MOVWF  x34
0897E:  MOVLW  35
08980:  MOVWF  x33
.................... //!   char *s_all = "all";
....................    
....................    arg1 = SERcmd[rec].p[2];
08982:  CLRF   x47
08984:  MOVFF  690,746
08988:  CLRF   x49
0898A:  MOVLW  B5
0898C:  MOVWF  x48
0898E:  MOVLB  0
08990:  CALL   0890
08994:  MOVFF  02,73B
08998:  MOVFF  01,73A
0899C:  MOVLW  06
0899E:  MOVLB  7
089A0:  ADDWF  x3A,F
089A2:  MOVLW  00
089A4:  ADDWFC x3B,F
089A6:  MOVLW  32
089A8:  ADDWF  x3A,W
089AA:  MOVWF  01
089AC:  MOVLW  00
089AE:  ADDWFC x3B,W
089B0:  MOVWF  03
089B2:  MOVF   01,W
089B4:  ADDLW  EB
089B6:  MOVWF  01
089B8:  MOVLW  01
089BA:  ADDWFC 03,F
089BC:  MOVFF  01,70B
089C0:  MOVFF  03,70C
....................    
....................    /*** GET MONITOR VALUES ************/
....................    if      (0 == strcmp(s_N15, arg1)) {
089C4:  MOVFF  70E,742
089C8:  MOVFF  70D,741
089CC:  MOVFF  70C,744
089D0:  MOVFF  70B,743
089D4:  MOVLB  0
089D6:  CALL   611C
089DA:  MOVF   01,F
089DC:  BNZ   8A60
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.vN15[0],monCal.vN15[1]);
089DE:  MOVLW  04
089E0:  MOVLB  7
089E2:  MOVWF  x42
089E4:  MOVLW  C1
089E6:  MOVWF  x41
089E8:  MOVLB  0
089EA:  CALL   5BA6
089EE:  MOVFF  02,03
089F2:  MOVF   01,W
089F4:  ADDLW  C1
089F6:  MOVLB  7
089F8:  MOVWF  x3A
089FA:  MOVLW  04
089FC:  ADDWFC 02,W
089FE:  MOVWF  x3B
08A00:  MOVFF  FE8,565
08A04:  MOVFF  73A,564
08A08:  MOVLW  89
08A0A:  MOVWF  FE9
08A0C:  MOVFF  C5,746
08A10:  MOVFF  C4,745
08A14:  MOVFF  C3,744
08A18:  MOVFF  C2,743
08A1C:  MOVLW  02
08A1E:  MOVWF  x47
08A20:  MOVLB  0
08A22:  CALL   5D7C
08A26:  MOVLW  2C
08A28:  MOVLB  7
08A2A:  MOVWF  x50
08A2C:  MOVLB  0
08A2E:  CALL   5BDE
08A32:  MOVLW  89
08A34:  MOVWF  FE9
08A36:  MOVFF  C9,746
08A3A:  MOVFF  C8,745
08A3E:  MOVFF  C7,744
08A42:  MOVFF  C6,743
08A46:  MOVLW  02
08A48:  MOVLB  7
08A4A:  MOVWF  x47
08A4C:  MOVLB  0
08A4E:  CALL   5D7C
08A52:  MOVLW  2C
08A54:  MOVLB  7
08A56:  MOVWF  x50
08A58:  MOVLB  0
08A5A:  CALL   5BDE
....................    }
08A5E:  BRA    8E02
....................    else if (0 == strcmp(s_200, arg1)) {
08A60:  MOVFF  714,742
08A64:  MOVFF  713,741
08A68:  MOVFF  70C,744
08A6C:  MOVFF  70B,743
08A70:  CALL   611C
08A74:  MOVF   01,F
08A76:  BNZ   8AFA
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v200[0],monCal.v200[1]);
08A78:  MOVLW  04
08A7A:  MOVLB  7
08A7C:  MOVWF  x42
08A7E:  MOVLW  C1
08A80:  MOVWF  x41
08A82:  MOVLB  0
08A84:  CALL   5BA6
08A88:  MOVFF  02,03
08A8C:  MOVF   01,W
08A8E:  ADDLW  C1
08A90:  MOVLB  7
08A92:  MOVWF  x3A
08A94:  MOVLW  04
08A96:  ADDWFC 02,W
08A98:  MOVWF  x3B
08A9A:  MOVFF  FE8,565
08A9E:  MOVFF  73A,564
08AA2:  MOVLW  89
08AA4:  MOVWF  FE9
08AA6:  MOVFF  CD,746
08AAA:  MOVFF  CC,745
08AAE:  MOVFF  CB,744
08AB2:  MOVFF  CA,743
08AB6:  MOVLW  02
08AB8:  MOVWF  x47
08ABA:  MOVLB  0
08ABC:  CALL   5D7C
08AC0:  MOVLW  2C
08AC2:  MOVLB  7
08AC4:  MOVWF  x50
08AC6:  MOVLB  0
08AC8:  CALL   5BDE
08ACC:  MOVLW  89
08ACE:  MOVWF  FE9
08AD0:  MOVFF  D1,746
08AD4:  MOVFF  D0,745
08AD8:  MOVFF  CF,744
08ADC:  MOVFF  CE,743
08AE0:  MOVLW  02
08AE2:  MOVLB  7
08AE4:  MOVWF  x47
08AE6:  MOVLB  0
08AE8:  CALL   5D7C
08AEC:  MOVLW  2C
08AEE:  MOVLB  7
08AF0:  MOVWF  x50
08AF2:  MOVLB  0
08AF4:  CALL   5BDE
....................    }
08AF8:  BRA    8E02
....................    else if (0 == strcmp(s_5V6, arg1)) {
08AFA:  MOVFF  71A,742
08AFE:  MOVFF  719,741
08B02:  MOVFF  70C,744
08B06:  MOVFF  70B,743
08B0A:  CALL   611C
08B0E:  MOVF   01,F
08B10:  BNZ   8B94
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v5V6[0],monCal.v5V6[1]);
08B12:  MOVLW  04
08B14:  MOVLB  7
08B16:  MOVWF  x42
08B18:  MOVLW  C1
08B1A:  MOVWF  x41
08B1C:  MOVLB  0
08B1E:  CALL   5BA6
08B22:  MOVFF  02,03
08B26:  MOVF   01,W
08B28:  ADDLW  C1
08B2A:  MOVLB  7
08B2C:  MOVWF  x3A
08B2E:  MOVLW  04
08B30:  ADDWFC 02,W
08B32:  MOVWF  x3B
08B34:  MOVFF  FE8,565
08B38:  MOVFF  73A,564
08B3C:  MOVLW  89
08B3E:  MOVWF  FE9
08B40:  MOVFF  D5,746
08B44:  MOVFF  D4,745
08B48:  MOVFF  D3,744
08B4C:  MOVFF  D2,743
08B50:  MOVLW  02
08B52:  MOVWF  x47
08B54:  MOVLB  0
08B56:  CALL   5D7C
08B5A:  MOVLW  2C
08B5C:  MOVLB  7
08B5E:  MOVWF  x50
08B60:  MOVLB  0
08B62:  CALL   5BDE
08B66:  MOVLW  89
08B68:  MOVWF  FE9
08B6A:  MOVFF  D9,746
08B6E:  MOVFF  D8,745
08B72:  MOVFF  D7,744
08B76:  MOVFF  D6,743
08B7A:  MOVLW  02
08B7C:  MOVLB  7
08B7E:  MOVWF  x47
08B80:  MOVLB  0
08B82:  CALL   5D7C
08B86:  MOVLW  2C
08B88:  MOVLB  7
08B8A:  MOVWF  x50
08B8C:  MOVLB  0
08B8E:  CALL   5BDE
....................    }
08B92:  BRA    8E02
....................    else if (0 == strcmp(s_5VA, arg1)) {
08B94:  MOVFF  720,742
08B98:  MOVFF  71F,741
08B9C:  MOVFF  70C,744
08BA0:  MOVFF  70B,743
08BA4:  CALL   611C
08BA8:  MOVF   01,F
08BAA:  BNZ   8C2E
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v5VA[0],monCal.v5VA[1]);
08BAC:  MOVLW  04
08BAE:  MOVLB  7
08BB0:  MOVWF  x42
08BB2:  MOVLW  C1
08BB4:  MOVWF  x41
08BB6:  MOVLB  0
08BB8:  CALL   5BA6
08BBC:  MOVFF  02,03
08BC0:  MOVF   01,W
08BC2:  ADDLW  C1
08BC4:  MOVLB  7
08BC6:  MOVWF  x3A
08BC8:  MOVLW  04
08BCA:  ADDWFC 02,W
08BCC:  MOVWF  x3B
08BCE:  MOVFF  FE8,565
08BD2:  MOVFF  73A,564
08BD6:  MOVLW  89
08BD8:  MOVWF  FE9
08BDA:  MOVFF  DD,746
08BDE:  MOVFF  DC,745
08BE2:  MOVFF  DB,744
08BE6:  MOVFF  DA,743
08BEA:  MOVLW  02
08BEC:  MOVWF  x47
08BEE:  MOVLB  0
08BF0:  CALL   5D7C
08BF4:  MOVLW  2C
08BF6:  MOVLB  7
08BF8:  MOVWF  x50
08BFA:  MOVLB  0
08BFC:  CALL   5BDE
08C00:  MOVLW  89
08C02:  MOVWF  FE9
08C04:  MOVFF  E1,746
08C08:  MOVFF  E0,745
08C0C:  MOVFF  DF,744
08C10:  MOVFF  DE,743
08C14:  MOVLW  02
08C16:  MOVLB  7
08C18:  MOVWF  x47
08C1A:  MOVLB  0
08C1C:  CALL   5D7C
08C20:  MOVLW  2C
08C22:  MOVLB  7
08C24:  MOVWF  x50
08C26:  MOVLB  0
08C28:  CALL   5BDE
....................    }
08C2C:  BRA    8E02
....................    else if (0 == strcmp(s_3V6X, arg1)) {
08C2E:  MOVFF  726,742
08C32:  MOVFF  725,741
08C36:  MOVFF  70C,744
08C3A:  MOVFF  70B,743
08C3E:  CALL   611C
08C42:  MOVF   01,F
08C44:  BNZ   8CC8
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V6X[0],monCal.v3V6X[1]);
08C46:  MOVLW  04
08C48:  MOVLB  7
08C4A:  MOVWF  x42
08C4C:  MOVLW  C1
08C4E:  MOVWF  x41
08C50:  MOVLB  0
08C52:  CALL   5BA6
08C56:  MOVFF  02,03
08C5A:  MOVF   01,W
08C5C:  ADDLW  C1
08C5E:  MOVLB  7
08C60:  MOVWF  x3A
08C62:  MOVLW  04
08C64:  ADDWFC 02,W
08C66:  MOVWF  x3B
08C68:  MOVFF  FE8,565
08C6C:  MOVFF  73A,564
08C70:  MOVLW  89
08C72:  MOVWF  FE9
08C74:  MOVFF  E5,746
08C78:  MOVFF  E4,745
08C7C:  MOVFF  E3,744
08C80:  MOVFF  E2,743
08C84:  MOVLW  02
08C86:  MOVWF  x47
08C88:  MOVLB  0
08C8A:  CALL   5D7C
08C8E:  MOVLW  2C
08C90:  MOVLB  7
08C92:  MOVWF  x50
08C94:  MOVLB  0
08C96:  CALL   5BDE
08C9A:  MOVLW  89
08C9C:  MOVWF  FE9
08C9E:  MOVFF  E9,746
08CA2:  MOVFF  E8,745
08CA6:  MOVFF  E7,744
08CAA:  MOVFF  E6,743
08CAE:  MOVLW  02
08CB0:  MOVLB  7
08CB2:  MOVWF  x47
08CB4:  MOVLB  0
08CB6:  CALL   5D7C
08CBA:  MOVLW  2C
08CBC:  MOVLB  7
08CBE:  MOVWF  x50
08CC0:  MOVLB  0
08CC2:  CALL   5BDE
....................    }
08CC6:  BRA    8E02
....................    else if (0 == strcmp(s_3V3A, arg1)) {
08CC8:  MOVFF  72D,742
08CCC:  MOVFF  72C,741
08CD0:  MOVFF  70C,744
08CD4:  MOVFF  70B,743
08CD8:  CALL   611C
08CDC:  MOVF   01,F
08CDE:  BNZ   8D62
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3A[0],monCal.v3V3A[1]);
08CE0:  MOVLW  04
08CE2:  MOVLB  7
08CE4:  MOVWF  x42
08CE6:  MOVLW  C1
08CE8:  MOVWF  x41
08CEA:  MOVLB  0
08CEC:  CALL   5BA6
08CF0:  MOVFF  02,03
08CF4:  MOVF   01,W
08CF6:  ADDLW  C1
08CF8:  MOVLB  7
08CFA:  MOVWF  x3A
08CFC:  MOVLW  04
08CFE:  ADDWFC 02,W
08D00:  MOVWF  x3B
08D02:  MOVFF  FE8,565
08D06:  MOVFF  73A,564
08D0A:  MOVLW  89
08D0C:  MOVWF  FE9
08D0E:  MOVFF  ED,746
08D12:  MOVFF  EC,745
08D16:  MOVFF  EB,744
08D1A:  MOVFF  EA,743
08D1E:  MOVLW  02
08D20:  MOVWF  x47
08D22:  MOVLB  0
08D24:  CALL   5D7C
08D28:  MOVLW  2C
08D2A:  MOVLB  7
08D2C:  MOVWF  x50
08D2E:  MOVLB  0
08D30:  CALL   5BDE
08D34:  MOVLW  89
08D36:  MOVWF  FE9
08D38:  MOVFF  F1,746
08D3C:  MOVFF  F0,745
08D40:  MOVFF  EF,744
08D44:  MOVFF  EE,743
08D48:  MOVLW  02
08D4A:  MOVLB  7
08D4C:  MOVWF  x47
08D4E:  MOVLB  0
08D50:  CALL   5D7C
08D54:  MOVLW  2C
08D56:  MOVLB  7
08D58:  MOVWF  x50
08D5A:  MOVLB  0
08D5C:  CALL   5BDE
....................    }
08D60:  BRA    8E02
....................    else if (0 == strcmp(s_3V3D, arg1)) {
08D62:  MOVFF  734,742
08D66:  MOVFF  733,741
08D6A:  MOVFF  70C,744
08D6E:  MOVFF  70B,743
08D72:  CALL   611C
08D76:  MOVF   01,F
08D78:  BNZ   8DFC
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3D[0],monCal.v3V3D[1]);
08D7A:  MOVLW  04
08D7C:  MOVLB  7
08D7E:  MOVWF  x42
08D80:  MOVLW  C1
08D82:  MOVWF  x41
08D84:  MOVLB  0
08D86:  CALL   5BA6
08D8A:  MOVFF  02,03
08D8E:  MOVF   01,W
08D90:  ADDLW  C1
08D92:  MOVLB  7
08D94:  MOVWF  x3A
08D96:  MOVLW  04
08D98:  ADDWFC 02,W
08D9A:  MOVWF  x3B
08D9C:  MOVFF  FE8,565
08DA0:  MOVFF  73A,564
08DA4:  MOVLW  89
08DA6:  MOVWF  FE9
08DA8:  MOVFF  F5,746
08DAC:  MOVFF  F4,745
08DB0:  MOVFF  F3,744
08DB4:  MOVFF  F2,743
08DB8:  MOVLW  02
08DBA:  MOVWF  x47
08DBC:  MOVLB  0
08DBE:  CALL   5D7C
08DC2:  MOVLW  2C
08DC4:  MOVLB  7
08DC6:  MOVWF  x50
08DC8:  MOVLB  0
08DCA:  CALL   5BDE
08DCE:  MOVLW  89
08DD0:  MOVWF  FE9
08DD2:  MOVFF  F9,746
08DD6:  MOVFF  F8,745
08DDA:  MOVFF  F7,744
08DDE:  MOVFF  F6,743
08DE2:  MOVLW  02
08DE4:  MOVLB  7
08DE6:  MOVWF  x47
08DE8:  MOVLB  0
08DEA:  CALL   5D7C
08DEE:  MOVLW  2C
08DF0:  MOVLB  7
08DF2:  MOVWF  x50
08DF4:  MOVLB  0
08DF6:  CALL   5BDE
....................    }
08DFA:  BRA    8E02
....................    else return INV_PARAM;
08DFC:  MOVLW  02
08DFE:  MOVWF  01
08E00:  BRA    8E06
....................    
....................    return SUCCESS;
08E02:  MOVLW  00
08E04:  MOVWF  01
08E06:  RETURN 0
.................... }
.................... 
.................... int8 setMonitorCalParam(unsigned int8 rec){
....................    return SUCCESS;
08E08:  MOVLW  00
08E0A:  MOVWF  01
08E0C:  RETURN 0
.................... }
.................... 
.................... int8 getMonitorValue(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    char *arg1;
....................    char *s_N15 = "N15";
08E0E:  MOVLW  4E
08E10:  MOVLB  7
08E12:  MOVWF  x0F
08E14:  MOVLW  31
08E16:  MOVWF  x10
08E18:  MOVLW  35
08E1A:  MOVWF  x11
08E1C:  CLRF   x12
08E1E:  MOVLW  07
08E20:  MOVWF  x0E
08E22:  MOVLW  0F
08E24:  MOVWF  x0D
....................    char *s_200 = "200";
08E26:  MOVLW  32
08E28:  MOVWF  x15
08E2A:  MOVLW  30
08E2C:  MOVWF  x16
08E2E:  MOVWF  x17
08E30:  CLRF   x18
08E32:  MOVLW  07
08E34:  MOVWF  x14
08E36:  MOVLW  15
08E38:  MOVWF  x13
....................    char *s_5V6 = "5V6";
08E3A:  MOVLW  35
08E3C:  MOVWF  x1B
08E3E:  MOVLW  56
08E40:  MOVWF  x1C
08E42:  MOVLW  36
08E44:  MOVWF  x1D
08E46:  CLRF   x1E
08E48:  MOVLW  07
08E4A:  MOVWF  x1A
08E4C:  MOVLW  1B
08E4E:  MOVWF  x19
....................    char *s_5VA = "5VA";
08E50:  MOVLW  35
08E52:  MOVWF  x21
08E54:  MOVLW  56
08E56:  MOVWF  x22
08E58:  MOVLW  41
08E5A:  MOVWF  x23
08E5C:  CLRF   x24
08E5E:  MOVLW  07
08E60:  MOVWF  x20
08E62:  MOVLW  21
08E64:  MOVWF  x1F
....................    char *s_3V6X = "3V6X";
08E66:  MOVLW  33
08E68:  MOVWF  x27
08E6A:  MOVLW  56
08E6C:  MOVWF  x28
08E6E:  MOVLW  36
08E70:  MOVWF  x29
08E72:  MOVLW  58
08E74:  MOVWF  x2A
08E76:  CLRF   x2B
08E78:  MOVLW  07
08E7A:  MOVWF  x26
08E7C:  MOVLW  27
08E7E:  MOVWF  x25
....................    char *s_3V3A = "3V3A";
08E80:  MOVLW  33
08E82:  MOVWF  x2E
08E84:  MOVLW  56
08E86:  MOVWF  x2F
08E88:  MOVLW  33
08E8A:  MOVWF  x30
08E8C:  MOVLW  41
08E8E:  MOVWF  x31
08E90:  CLRF   x32
08E92:  MOVLW  07
08E94:  MOVWF  x2D
08E96:  MOVLW  2E
08E98:  MOVWF  x2C
....................    char *s_3V3D = "3V3D";
08E9A:  MOVLW  33
08E9C:  MOVWF  x35
08E9E:  MOVLW  56
08EA0:  MOVWF  x36
08EA2:  MOVLW  33
08EA4:  MOVWF  x37
08EA6:  MOVLW  44
08EA8:  MOVWF  x38
08EAA:  CLRF   x39
08EAC:  MOVLW  07
08EAE:  MOVWF  x34
08EB0:  MOVLW  35
08EB2:  MOVWF  x33
....................    char *s_all = "all";
08EB4:  MOVLW  61
08EB6:  MOVWF  x3C
08EB8:  MOVLW  6C
08EBA:  MOVWF  x3D
08EBC:  MOVWF  x3E
08EBE:  CLRF   x3F
08EC0:  MOVLW  07
08EC2:  MOVWF  x3B
08EC4:  MOVLW  3C
08EC6:  MOVWF  x3A
....................    
....................    arg1 = SERcmd[rec].p[2];
08EC8:  CLRF   x47
08ECA:  MOVFF  690,746
08ECE:  CLRF   x49
08ED0:  MOVLW  B5
08ED2:  MOVWF  x48
08ED4:  MOVLB  0
08ED6:  CALL   0890
08EDA:  MOVFF  02,741
08EDE:  MOVFF  01,740
08EE2:  MOVLW  06
08EE4:  MOVLB  7
08EE6:  ADDWF  x40,F
08EE8:  MOVLW  00
08EEA:  ADDWFC x41,F
08EEC:  MOVLW  32
08EEE:  ADDWF  x40,W
08EF0:  MOVWF  01
08EF2:  MOVLW  00
08EF4:  ADDWFC x41,W
08EF6:  MOVWF  03
08EF8:  MOVF   01,W
08EFA:  ADDLW  EB
08EFC:  MOVWF  01
08EFE:  MOVLW  01
08F00:  ADDWFC 03,F
08F02:  MOVFF  01,70B
08F06:  MOVFF  03,70C
....................    
....................    /*** GET MONITOR VALUES ************/
....................    if      (0 == strcmp(s_N15, arg1)) {
08F0A:  MOVFF  70E,742
08F0E:  MOVFF  70D,741
08F12:  MOVFF  70C,744
08F16:  MOVFF  70B,743
08F1A:  MOVLB  0
08F1C:  CALL   611C
08F20:  MOVF   01,F
08F22:  BNZ   8F7A
....................       sprintf(retData+strlen(retData), "%.2f,", monitorVals.vN15);
08F24:  MOVLW  04
08F26:  MOVLB  7
08F28:  MOVWF  x42
08F2A:  MOVLW  C1
08F2C:  MOVWF  x41
08F2E:  MOVLB  0
08F30:  CALL   5BA6
08F34:  MOVFF  02,03
08F38:  MOVF   01,W
08F3A:  ADDLW  C1
08F3C:  MOVLB  7
08F3E:  MOVWF  x40
08F40:  MOVLW  04
08F42:  ADDWFC 02,W
08F44:  MOVWF  x41
08F46:  MOVFF  FE8,565
08F4A:  MOVFF  740,564
08F4E:  MOVLW  89
08F50:  MOVWF  FE9
08F52:  MOVFF  FE,746
08F56:  MOVFF  FD,745
08F5A:  MOVFF  FC,744
08F5E:  MOVFF  FB,743
08F62:  MOVLW  02
08F64:  MOVWF  x47
08F66:  MOVLB  0
08F68:  CALL   5D7C
08F6C:  MOVLW  2C
08F6E:  MOVLB  7
08F70:  MOVWF  x50
08F72:  MOVLB  0
08F74:  CALL   5BDE
....................    }
08F78:  BRA    947C
....................    else if (0 == strcmp(s_200, arg1)) {
08F7A:  MOVFF  714,742
08F7E:  MOVFF  713,741
08F82:  MOVFF  70C,744
08F86:  MOVFF  70B,743
08F8A:  CALL   611C
08F8E:  MOVF   01,F
08F90:  BNZ   8FE8
....................       sprintf(retData+strlen(retData), "%.1f,", monitorVals.v200);
08F92:  MOVLW  04
08F94:  MOVLB  7
08F96:  MOVWF  x42
08F98:  MOVLW  C1
08F9A:  MOVWF  x41
08F9C:  MOVLB  0
08F9E:  CALL   5BA6
08FA2:  MOVFF  02,03
08FA6:  MOVF   01,W
08FA8:  ADDLW  C1
08FAA:  MOVLB  7
08FAC:  MOVWF  x40
08FAE:  MOVLW  04
08FB0:  ADDWFC 02,W
08FB2:  MOVWF  x41
08FB4:  MOVFF  FE8,565
08FB8:  MOVFF  740,564
08FBC:  MOVLW  89
08FBE:  MOVWF  FE9
08FC0:  MOVFF  102,746
08FC4:  MOVFF  101,745
08FC8:  MOVFF  100,744
08FCC:  MOVFF  FF,743
08FD0:  MOVLW  01
08FD2:  MOVWF  x47
08FD4:  MOVLB  0
08FD6:  CALL   5D7C
08FDA:  MOVLW  2C
08FDC:  MOVLB  7
08FDE:  MOVWF  x50
08FE0:  MOVLB  0
08FE2:  CALL   5BDE
....................    }
08FE6:  BRA    947C
....................    else if (0 == strcmp(s_5V6, arg1)) {
08FE8:  MOVFF  71A,742
08FEC:  MOVFF  719,741
08FF0:  MOVFF  70C,744
08FF4:  MOVFF  70B,743
08FF8:  CALL   611C
08FFC:  MOVF   01,F
08FFE:  BNZ   9056
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5V6);
09000:  MOVLW  04
09002:  MOVLB  7
09004:  MOVWF  x42
09006:  MOVLW  C1
09008:  MOVWF  x41
0900A:  MOVLB  0
0900C:  CALL   5BA6
09010:  MOVFF  02,03
09014:  MOVF   01,W
09016:  ADDLW  C1
09018:  MOVLB  7
0901A:  MOVWF  x40
0901C:  MOVLW  04
0901E:  ADDWFC 02,W
09020:  MOVWF  x41
09022:  MOVFF  FE8,565
09026:  MOVFF  740,564
0902A:  MOVLW  89
0902C:  MOVWF  FE9
0902E:  MOVFF  106,746
09032:  MOVFF  105,745
09036:  MOVFF  104,744
0903A:  MOVFF  103,743
0903E:  MOVLW  03
09040:  MOVWF  x47
09042:  MOVLB  0
09044:  CALL   5D7C
09048:  MOVLW  2C
0904A:  MOVLB  7
0904C:  MOVWF  x50
0904E:  MOVLB  0
09050:  CALL   5BDE
....................    }
09054:  BRA    947C
....................    else if (0 == strcmp(s_5VA, arg1)) {
09056:  MOVFF  720,742
0905A:  MOVFF  71F,741
0905E:  MOVFF  70C,744
09062:  MOVFF  70B,743
09066:  CALL   611C
0906A:  MOVF   01,F
0906C:  BNZ   90C4
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5VA);
0906E:  MOVLW  04
09070:  MOVLB  7
09072:  MOVWF  x42
09074:  MOVLW  C1
09076:  MOVWF  x41
09078:  MOVLB  0
0907A:  CALL   5BA6
0907E:  MOVFF  02,03
09082:  MOVF   01,W
09084:  ADDLW  C1
09086:  MOVLB  7
09088:  MOVWF  x40
0908A:  MOVLW  04
0908C:  ADDWFC 02,W
0908E:  MOVWF  x41
09090:  MOVFF  FE8,565
09094:  MOVFF  740,564
09098:  MOVLW  89
0909A:  MOVWF  FE9
0909C:  MOVFF  10A,746
090A0:  MOVFF  109,745
090A4:  MOVFF  108,744
090A8:  MOVFF  107,743
090AC:  MOVLW  03
090AE:  MOVWF  x47
090B0:  MOVLB  0
090B2:  CALL   5D7C
090B6:  MOVLW  2C
090B8:  MOVLB  7
090BA:  MOVWF  x50
090BC:  MOVLB  0
090BE:  CALL   5BDE
....................    }
090C2:  BRA    947C
....................    else if (0 == strcmp(s_3V6X, arg1)) {
090C4:  MOVFF  726,742
090C8:  MOVFF  725,741
090CC:  MOVFF  70C,744
090D0:  MOVFF  70B,743
090D4:  CALL   611C
090D8:  MOVF   01,F
090DA:  BNZ   9132
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V6X);
090DC:  MOVLW  04
090DE:  MOVLB  7
090E0:  MOVWF  x42
090E2:  MOVLW  C1
090E4:  MOVWF  x41
090E6:  MOVLB  0
090E8:  CALL   5BA6
090EC:  MOVFF  02,03
090F0:  MOVF   01,W
090F2:  ADDLW  C1
090F4:  MOVLB  7
090F6:  MOVWF  x40
090F8:  MOVLW  04
090FA:  ADDWFC 02,W
090FC:  MOVWF  x41
090FE:  MOVFF  FE8,565
09102:  MOVFF  740,564
09106:  MOVLW  89
09108:  MOVWF  FE9
0910A:  MOVFF  10E,746
0910E:  MOVFF  10D,745
09112:  MOVFF  10C,744
09116:  MOVFF  10B,743
0911A:  MOVLW  03
0911C:  MOVWF  x47
0911E:  MOVLB  0
09120:  CALL   5D7C
09124:  MOVLW  2C
09126:  MOVLB  7
09128:  MOVWF  x50
0912A:  MOVLB  0
0912C:  CALL   5BDE
....................    }
09130:  BRA    947C
....................    else if (0 == strcmp(s_3V3A, arg1)) {
09132:  MOVFF  72D,742
09136:  MOVFF  72C,741
0913A:  MOVFF  70C,744
0913E:  MOVFF  70B,743
09142:  CALL   611C
09146:  MOVF   01,F
09148:  BNZ   91A0
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3A);
0914A:  MOVLW  04
0914C:  MOVLB  7
0914E:  MOVWF  x42
09150:  MOVLW  C1
09152:  MOVWF  x41
09154:  MOVLB  0
09156:  CALL   5BA6
0915A:  MOVFF  02,03
0915E:  MOVF   01,W
09160:  ADDLW  C1
09162:  MOVLB  7
09164:  MOVWF  x40
09166:  MOVLW  04
09168:  ADDWFC 02,W
0916A:  MOVWF  x41
0916C:  MOVFF  FE8,565
09170:  MOVFF  740,564
09174:  MOVLW  89
09176:  MOVWF  FE9
09178:  MOVFF  112,746
0917C:  MOVFF  111,745
09180:  MOVFF  110,744
09184:  MOVFF  10F,743
09188:  MOVLW  03
0918A:  MOVWF  x47
0918C:  MOVLB  0
0918E:  CALL   5D7C
09192:  MOVLW  2C
09194:  MOVLB  7
09196:  MOVWF  x50
09198:  MOVLB  0
0919A:  CALL   5BDE
....................    }
0919E:  BRA    947C
....................    else if (0 == strcmp(s_3V3D, arg1)) {
091A0:  MOVFF  734,742
091A4:  MOVFF  733,741
091A8:  MOVFF  70C,744
091AC:  MOVFF  70B,743
091B0:  CALL   611C
091B4:  MOVF   01,F
091B6:  BNZ   920E
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3D);
091B8:  MOVLW  04
091BA:  MOVLB  7
091BC:  MOVWF  x42
091BE:  MOVLW  C1
091C0:  MOVWF  x41
091C2:  MOVLB  0
091C4:  CALL   5BA6
091C8:  MOVFF  02,03
091CC:  MOVF   01,W
091CE:  ADDLW  C1
091D0:  MOVLB  7
091D2:  MOVWF  x40
091D4:  MOVLW  04
091D6:  ADDWFC 02,W
091D8:  MOVWF  x41
091DA:  MOVFF  FE8,565
091DE:  MOVFF  740,564
091E2:  MOVLW  89
091E4:  MOVWF  FE9
091E6:  MOVFF  116,746
091EA:  MOVFF  115,745
091EE:  MOVFF  114,744
091F2:  MOVFF  113,743
091F6:  MOVLW  03
091F8:  MOVWF  x47
091FA:  MOVLB  0
091FC:  CALL   5D7C
09200:  MOVLW  2C
09202:  MOVLB  7
09204:  MOVWF  x50
09206:  MOVLB  0
09208:  CALL   5BDE
....................    }
0920C:  BRA    947C
....................    else if (0 == strcmp(s_all, arg1)) {
0920E:  MOVFF  73B,742
09212:  MOVFF  73A,741
09216:  MOVFF  70C,744
0921A:  MOVFF  70B,743
0921E:  CALL   611C
09222:  MOVF   01,F
09224:  BTFSS  FD8.2
09226:  BRA    9476
....................       sprintf(retData+strlen(retData), "%.2f,", monitorVals.vN15);
09228:  MOVLW  04
0922A:  MOVLB  7
0922C:  MOVWF  x42
0922E:  MOVLW  C1
09230:  MOVWF  x41
09232:  MOVLB  0
09234:  CALL   5BA6
09238:  MOVFF  02,03
0923C:  MOVF   01,W
0923E:  ADDLW  C1
09240:  MOVLB  7
09242:  MOVWF  x40
09244:  MOVLW  04
09246:  ADDWFC 02,W
09248:  MOVWF  x41
0924A:  MOVFF  FE8,565
0924E:  MOVFF  740,564
09252:  MOVLW  89
09254:  MOVWF  FE9
09256:  MOVFF  FE,746
0925A:  MOVFF  FD,745
0925E:  MOVFF  FC,744
09262:  MOVFF  FB,743
09266:  MOVLW  02
09268:  MOVWF  x47
0926A:  MOVLB  0
0926C:  CALL   5D7C
09270:  MOVLW  2C
09272:  MOVLB  7
09274:  MOVWF  x50
09276:  MOVLB  0
09278:  CALL   5BDE
....................       sprintf(retData+strlen(retData), "%.1f,", monitorVals.v200);
0927C:  MOVLW  04
0927E:  MOVLB  7
09280:  MOVWF  x42
09282:  MOVLW  C1
09284:  MOVWF  x41
09286:  MOVLB  0
09288:  CALL   5BA6
0928C:  MOVFF  02,03
09290:  MOVF   01,W
09292:  ADDLW  C1
09294:  MOVLB  7
09296:  MOVWF  x40
09298:  MOVLW  04
0929A:  ADDWFC 02,W
0929C:  MOVWF  x41
0929E:  MOVFF  FE8,565
092A2:  MOVFF  740,564
092A6:  MOVLW  89
092A8:  MOVWF  FE9
092AA:  MOVFF  102,746
092AE:  MOVFF  101,745
092B2:  MOVFF  100,744
092B6:  MOVFF  FF,743
092BA:  MOVLW  01
092BC:  MOVWF  x47
092BE:  MOVLB  0
092C0:  CALL   5D7C
092C4:  MOVLW  2C
092C6:  MOVLB  7
092C8:  MOVWF  x50
092CA:  MOVLB  0
092CC:  CALL   5BDE
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5V6);
092D0:  MOVLW  04
092D2:  MOVLB  7
092D4:  MOVWF  x42
092D6:  MOVLW  C1
092D8:  MOVWF  x41
092DA:  MOVLB  0
092DC:  CALL   5BA6
092E0:  MOVFF  02,03
092E4:  MOVF   01,W
092E6:  ADDLW  C1
092E8:  MOVLB  7
092EA:  MOVWF  x40
092EC:  MOVLW  04
092EE:  ADDWFC 02,W
092F0:  MOVWF  x41
092F2:  MOVFF  FE8,565
092F6:  MOVFF  740,564
092FA:  MOVLW  89
092FC:  MOVWF  FE9
092FE:  MOVFF  106,746
09302:  MOVFF  105,745
09306:  MOVFF  104,744
0930A:  MOVFF  103,743
0930E:  MOVLW  03
09310:  MOVWF  x47
09312:  MOVLB  0
09314:  CALL   5D7C
09318:  MOVLW  2C
0931A:  MOVLB  7
0931C:  MOVWF  x50
0931E:  MOVLB  0
09320:  CALL   5BDE
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5VA);
09324:  MOVLW  04
09326:  MOVLB  7
09328:  MOVWF  x42
0932A:  MOVLW  C1
0932C:  MOVWF  x41
0932E:  MOVLB  0
09330:  CALL   5BA6
09334:  MOVFF  02,03
09338:  MOVF   01,W
0933A:  ADDLW  C1
0933C:  MOVLB  7
0933E:  MOVWF  x40
09340:  MOVLW  04
09342:  ADDWFC 02,W
09344:  MOVWF  x41
09346:  MOVFF  FE8,565
0934A:  MOVFF  740,564
0934E:  MOVLW  89
09350:  MOVWF  FE9
09352:  MOVFF  10A,746
09356:  MOVFF  109,745
0935A:  MOVFF  108,744
0935E:  MOVFF  107,743
09362:  MOVLW  03
09364:  MOVWF  x47
09366:  MOVLB  0
09368:  CALL   5D7C
0936C:  MOVLW  2C
0936E:  MOVLB  7
09370:  MOVWF  x50
09372:  MOVLB  0
09374:  CALL   5BDE
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V6X);
09378:  MOVLW  04
0937A:  MOVLB  7
0937C:  MOVWF  x42
0937E:  MOVLW  C1
09380:  MOVWF  x41
09382:  MOVLB  0
09384:  CALL   5BA6
09388:  MOVFF  02,03
0938C:  MOVF   01,W
0938E:  ADDLW  C1
09390:  MOVLB  7
09392:  MOVWF  x40
09394:  MOVLW  04
09396:  ADDWFC 02,W
09398:  MOVWF  x41
0939A:  MOVFF  FE8,565
0939E:  MOVFF  740,564
093A2:  MOVLW  89
093A4:  MOVWF  FE9
093A6:  MOVFF  10E,746
093AA:  MOVFF  10D,745
093AE:  MOVFF  10C,744
093B2:  MOVFF  10B,743
093B6:  MOVLW  03
093B8:  MOVWF  x47
093BA:  MOVLB  0
093BC:  CALL   5D7C
093C0:  MOVLW  2C
093C2:  MOVLB  7
093C4:  MOVWF  x50
093C6:  MOVLB  0
093C8:  CALL   5BDE
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3A);
093CC:  MOVLW  04
093CE:  MOVLB  7
093D0:  MOVWF  x42
093D2:  MOVLW  C1
093D4:  MOVWF  x41
093D6:  MOVLB  0
093D8:  CALL   5BA6
093DC:  MOVFF  02,03
093E0:  MOVF   01,W
093E2:  ADDLW  C1
093E4:  MOVLB  7
093E6:  MOVWF  x40
093E8:  MOVLW  04
093EA:  ADDWFC 02,W
093EC:  MOVWF  x41
093EE:  MOVFF  FE8,565
093F2:  MOVFF  740,564
093F6:  MOVLW  89
093F8:  MOVWF  FE9
093FA:  MOVFF  112,746
093FE:  MOVFF  111,745
09402:  MOVFF  110,744
09406:  MOVFF  10F,743
0940A:  MOVLW  03
0940C:  MOVWF  x47
0940E:  MOVLB  0
09410:  CALL   5D7C
09414:  MOVLW  2C
09416:  MOVLB  7
09418:  MOVWF  x50
0941A:  MOVLB  0
0941C:  CALL   5BDE
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3D);
09420:  MOVLW  04
09422:  MOVLB  7
09424:  MOVWF  x42
09426:  MOVLW  C1
09428:  MOVWF  x41
0942A:  MOVLB  0
0942C:  CALL   5BA6
09430:  MOVFF  02,03
09434:  MOVF   01,W
09436:  ADDLW  C1
09438:  MOVLB  7
0943A:  MOVWF  x40
0943C:  MOVLW  04
0943E:  ADDWFC 02,W
09440:  MOVWF  x41
09442:  MOVFF  FE8,565
09446:  MOVFF  740,564
0944A:  MOVLW  89
0944C:  MOVWF  FE9
0944E:  MOVFF  116,746
09452:  MOVFF  115,745
09456:  MOVFF  114,744
0945A:  MOVFF  113,743
0945E:  MOVLW  03
09460:  MOVWF  x47
09462:  MOVLB  0
09464:  CALL   5D7C
09468:  MOVLW  2C
0946A:  MOVLB  7
0946C:  MOVWF  x50
0946E:  MOVLB  0
09470:  CALL   5BDE
....................    }
09474:  BRA    947C
....................    else return INV_PARAM;
09476:  MOVLW  02
09478:  MOVWF  01
0947A:  BRA    9480
....................    
....................    return SUCCESS;
0947C:  MOVLW  00
0947E:  MOVWF  01
09480:  RETURN 0
.................... }
.................... 
.................... int8 getPIDdata(unsigned int8 rec){
....................   /*** ARG CHECKS ********************/ 
....................    int8 arg1;
....................    char *arg2;
....................    char *s_PV = "PV";
09482:  MOVLW  50
09484:  MOVLB  7
09486:  MOVWF  x10
09488:  MOVLW  56
0948A:  MOVWF  x11
0948C:  CLRF   x12
0948E:  MOVLW  07
09490:  MOVWF  x0F
09492:  MOVLW  10
09494:  MOVWF  x0E
....................    char *s_CV = "CV";
09496:  MOVLW  43
09498:  MOVWF  x15
0949A:  MOVLW  56
0949C:  MOVWF  x16
0949E:  CLRF   x17
094A0:  MOVLW  07
094A2:  MOVWF  x14
094A4:  MOVLW  15
094A6:  MOVWF  x13
....................    char *s_PVold = "PVold";
094A8:  MOVLW  50
094AA:  MOVWF  x1A
094AC:  MOVLW  56
094AE:  MOVWF  x1B
094B0:  MOVLW  6F
094B2:  MOVWF  x1C
094B4:  MOVLW  6C
094B6:  MOVWF  x1D
094B8:  MOVLW  64
094BA:  MOVWF  x1E
094BC:  CLRF   x1F
094BE:  MOVLW  07
094C0:  MOVWF  x19
094C2:  MOVLW  1A
094C4:  MOVWF  x18
....................    char *s_I = "I";
094C6:  MOVLW  49
094C8:  MOVWF  x22
094CA:  CLRF   x23
094CC:  MOVLW  07
094CE:  MOVWF  x21
094D0:  MOVLW  22
094D2:  MOVWF  x20
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
094D4:  CLRF   x47
094D6:  MOVFF  690,746
094DA:  CLRF   x49
094DC:  MOVLW  B5
094DE:  MOVWF  x48
094E0:  MOVLB  0
094E2:  CALL   0890
094E6:  MOVFF  02,725
094EA:  MOVFF  01,724
094EE:  MOVLW  06
094F0:  MOVLB  7
094F2:  ADDWF  x24,F
094F4:  MOVLW  00
094F6:  ADDWFC x25,F
094F8:  MOVLW  32
094FA:  ADDWF  x24,W
094FC:  MOVWF  01
094FE:  MOVLW  00
09500:  ADDWFC x25,W
09502:  MOVWF  03
09504:  MOVF   01,W
09506:  ADDLW  EB
09508:  MOVWF  01
0950A:  MOVLW  01
0950C:  ADDWFC 03,F
0950E:  MOVFF  01,724
09512:  MOVFF  03,725
09516:  MOVFF  03,734
0951A:  MOVFF  01,733
0951E:  MOVLB  0
09520:  CALL   623C
09524:  MOVF   01,F
09526:  BNZ   9530
09528:  MOVLW  02
0952A:  MOVWF  01
0952C:  BRA    98C6
0952E:  BRA    958E
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
09530:  MOVLB  7
09532:  CLRF   x47
09534:  MOVFF  690,746
09538:  CLRF   x49
0953A:  MOVLW  B5
0953C:  MOVWF  x48
0953E:  MOVLB  0
09540:  CALL   0890
09544:  MOVFF  02,725
09548:  MOVFF  01,724
0954C:  MOVLW  06
0954E:  MOVLB  7
09550:  ADDWF  x24,F
09552:  MOVLW  00
09554:  ADDWFC x25,F
09556:  MOVLW  32
09558:  ADDWF  x24,W
0955A:  MOVWF  01
0955C:  MOVLW  00
0955E:  ADDWFC x25,W
09560:  MOVWF  03
09562:  MOVF   01,W
09564:  ADDLW  EB
09566:  MOVWF  01
09568:  MOVLW  01
0956A:  ADDWFC 03,F
0956C:  MOVFF  01,724
09570:  MOVFF  03,725
09574:  MOVFF  03,734
09578:  MOVFF  01,733
0957C:  CLRF   x36
0957E:  CLRF   x35
09580:  MOVLW  0A
09582:  MOVWF  x37
09584:  MOVLB  0
09586:  CALL   632C
0958A:  MOVFF  01,70B
....................    
....................    arg2 = SERcmd[rec].p[3];
0958E:  MOVLB  7
09590:  CLRF   x47
09592:  MOVFF  690,746
09596:  CLRF   x49
09598:  MOVLW  B5
0959A:  MOVWF  x48
0959C:  MOVLB  0
0959E:  CALL   0890
095A2:  MOVFF  02,725
095A6:  MOVFF  01,724
095AA:  MOVLW  06
095AC:  MOVLB  7
095AE:  ADDWF  x24,F
095B0:  MOVLW  00
095B2:  ADDWFC x25,F
095B4:  MOVLW  4B
095B6:  ADDWF  x24,W
095B8:  MOVWF  01
095BA:  MOVLW  00
095BC:  ADDWFC x25,W
095BE:  MOVWF  03
095C0:  MOVF   01,W
095C2:  ADDLW  EB
095C4:  MOVWF  01
095C6:  MOVLW  01
095C8:  ADDWFC 03,F
095CA:  MOVFF  01,70C
095CE:  MOVFF  03,70D
....................    
....................    /*** GET PV, CV, PVold, I, or A(LL) VALUE **********/
....................    if      (0 == strcmp(s_PV, arg2))     sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].PV);
095D2:  MOVFF  70F,742
095D6:  MOVFF  70E,741
095DA:  MOVFF  70D,744
095DE:  MOVFF  70C,743
095E2:  MOVLB  0
095E4:  CALL   611C
095E8:  MOVF   01,F
095EA:  BNZ   968E
095EC:  MOVLW  04
095EE:  MOVLB  7
095F0:  MOVWF  x42
095F2:  MOVLW  C1
095F4:  MOVWF  x41
095F6:  MOVLB  0
095F8:  CALL   5BA6
095FC:  MOVF   01,W
095FE:  ADDLW  C1
09600:  MOVLB  7
09602:  MOVWF  x24
09604:  MOVLW  04
09606:  ADDWFC 02,W
09608:  MOVWF  x25
0960A:  MOVLW  01
0960C:  SUBWF  x0B,W
0960E:  MULLW  28
09610:  MOVF   FF3,W
09612:  CLRF   x27
09614:  MOVWF  x26
09616:  MOVLW  10
09618:  ADDWF  x26,W
0961A:  MOVWF  01
0961C:  MOVLW  00
0961E:  ADDWFC x27,W
09620:  MOVWF  03
09622:  MOVF   01,W
09624:  ADDLW  20
09626:  MOVWF  FE9
09628:  MOVLW  00
0962A:  ADDWFC 03,W
0962C:  MOVWF  FEA
0962E:  MOVFF  FEF,726
09632:  MOVFF  FEC,727
09636:  MOVFF  FEC,728
0963A:  MOVFF  FEC,729
0963E:  MOVFF  725,565
09642:  MOVFF  724,564
09646:  MOVFF  70B,734
0964A:  MOVLW  18
0964C:  MOVWF  x35
0964E:  MOVLB  0
09650:  CALL   6680
09654:  MOVLW  2C
09656:  MOVLB  7
09658:  MOVWF  x50
0965A:  MOVLB  0
0965C:  CALL   5BDE
09660:  MOVLW  89
09662:  MOVWF  FE9
09664:  MOVFF  729,746
09668:  MOVFF  728,745
0966C:  MOVFF  727,744
09670:  MOVFF  726,743
09674:  MOVLW  02
09676:  MOVLB  7
09678:  MOVWF  x47
0967A:  MOVLB  0
0967C:  CALL   5D7C
09680:  MOVLW  2C
09682:  MOVLB  7
09684:  MOVWF  x50
09686:  MOVLB  0
09688:  CALL   5BDE
0968C:  BRA    98C2
....................    else if (0 == strcmp(s_CV, arg2))     sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].CV);
0968E:  MOVFF  714,742
09692:  MOVFF  713,741
09696:  MOVFF  70D,744
0969A:  MOVFF  70C,743
0969E:  CALL   611C
096A2:  MOVF   01,F
096A4:  BNZ   9748
096A6:  MOVLW  04
096A8:  MOVLB  7
096AA:  MOVWF  x42
096AC:  MOVLW  C1
096AE:  MOVWF  x41
096B0:  MOVLB  0
096B2:  CALL   5BA6
096B6:  MOVF   01,W
096B8:  ADDLW  C1
096BA:  MOVLB  7
096BC:  MOVWF  x24
096BE:  MOVLW  04
096C0:  ADDWFC 02,W
096C2:  MOVWF  x25
096C4:  MOVLW  01
096C6:  SUBWF  x0B,W
096C8:  MULLW  28
096CA:  MOVF   FF3,W
096CC:  CLRF   x27
096CE:  MOVWF  x26
096D0:  MOVLW  18
096D2:  ADDWF  x26,W
096D4:  MOVWF  01
096D6:  MOVLW  00
096D8:  ADDWFC x27,W
096DA:  MOVWF  03
096DC:  MOVF   01,W
096DE:  ADDLW  20
096E0:  MOVWF  FE9
096E2:  MOVLW  00
096E4:  ADDWFC 03,W
096E6:  MOVWF  FEA
096E8:  MOVFF  FEF,726
096EC:  MOVFF  FEC,727
096F0:  MOVFF  FEC,728
096F4:  MOVFF  FEC,729
096F8:  MOVFF  725,565
096FC:  MOVFF  724,564
09700:  MOVFF  70B,734
09704:  MOVLW  18
09706:  MOVWF  x35
09708:  MOVLB  0
0970A:  CALL   6680
0970E:  MOVLW  2C
09710:  MOVLB  7
09712:  MOVWF  x50
09714:  MOVLB  0
09716:  CALL   5BDE
0971A:  MOVLW  89
0971C:  MOVWF  FE9
0971E:  MOVFF  729,746
09722:  MOVFF  728,745
09726:  MOVFF  727,744
0972A:  MOVFF  726,743
0972E:  MOVLW  02
09730:  MOVLB  7
09732:  MOVWF  x47
09734:  MOVLB  0
09736:  CALL   5D7C
0973A:  MOVLW  2C
0973C:  MOVLB  7
0973E:  MOVWF  x50
09740:  MOVLB  0
09742:  CALL   5BDE
09746:  BRA    98C2
....................    else if (0 == strcmp(s_PVold, arg2))  sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].PVold);
09748:  MOVFF  719,742
0974C:  MOVFF  718,741
09750:  MOVFF  70D,744
09754:  MOVFF  70C,743
09758:  CALL   611C
0975C:  MOVF   01,F
0975E:  BNZ   9802
09760:  MOVLW  04
09762:  MOVLB  7
09764:  MOVWF  x42
09766:  MOVLW  C1
09768:  MOVWF  x41
0976A:  MOVLB  0
0976C:  CALL   5BA6
09770:  MOVF   01,W
09772:  ADDLW  C1
09774:  MOVLB  7
09776:  MOVWF  x24
09778:  MOVLW  04
0977A:  ADDWFC 02,W
0977C:  MOVWF  x25
0977E:  MOVLW  01
09780:  SUBWF  x0B,W
09782:  MULLW  28
09784:  MOVF   FF3,W
09786:  CLRF   x27
09788:  MOVWF  x26
0978A:  MOVLW  14
0978C:  ADDWF  x26,W
0978E:  MOVWF  01
09790:  MOVLW  00
09792:  ADDWFC x27,W
09794:  MOVWF  03
09796:  MOVF   01,W
09798:  ADDLW  20
0979A:  MOVWF  FE9
0979C:  MOVLW  00
0979E:  ADDWFC 03,W
097A0:  MOVWF  FEA
097A2:  MOVFF  FEF,726
097A6:  MOVFF  FEC,727
097AA:  MOVFF  FEC,728
097AE:  MOVFF  FEC,729
097B2:  MOVFF  725,565
097B6:  MOVFF  724,564
097BA:  MOVFF  70B,734
097BE:  MOVLW  18
097C0:  MOVWF  x35
097C2:  MOVLB  0
097C4:  CALL   6680
097C8:  MOVLW  2C
097CA:  MOVLB  7
097CC:  MOVWF  x50
097CE:  MOVLB  0
097D0:  CALL   5BDE
097D4:  MOVLW  89
097D6:  MOVWF  FE9
097D8:  MOVFF  729,746
097DC:  MOVFF  728,745
097E0:  MOVFF  727,744
097E4:  MOVFF  726,743
097E8:  MOVLW  02
097EA:  MOVLB  7
097EC:  MOVWF  x47
097EE:  MOVLB  0
097F0:  CALL   5D7C
097F4:  MOVLW  2C
097F6:  MOVLB  7
097F8:  MOVWF  x50
097FA:  MOVLB  0
097FC:  CALL   5BDE
09800:  BRA    98C2
....................    else if (0 == strcmp(s_I, arg2))      sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].I);
09802:  MOVFF  721,742
09806:  MOVFF  720,741
0980A:  MOVFF  70D,744
0980E:  MOVFF  70C,743
09812:  CALL   611C
09816:  MOVF   01,F
09818:  BNZ   98BC
0981A:  MOVLW  04
0981C:  MOVLB  7
0981E:  MOVWF  x42
09820:  MOVLW  C1
09822:  MOVWF  x41
09824:  MOVLB  0
09826:  CALL   5BA6
0982A:  MOVF   01,W
0982C:  ADDLW  C1
0982E:  MOVLB  7
09830:  MOVWF  x24
09832:  MOVLW  04
09834:  ADDWFC 02,W
09836:  MOVWF  x25
09838:  MOVLW  01
0983A:  SUBWF  x0B,W
0983C:  MULLW  28
0983E:  MOVF   FF3,W
09840:  CLRF   x27
09842:  MOVWF  x26
09844:  MOVLW  1C
09846:  ADDWF  x26,W
09848:  MOVWF  01
0984A:  MOVLW  00
0984C:  ADDWFC x27,W
0984E:  MOVWF  03
09850:  MOVF   01,W
09852:  ADDLW  20
09854:  MOVWF  FE9
09856:  MOVLW  00
09858:  ADDWFC 03,W
0985A:  MOVWF  FEA
0985C:  MOVFF  FEF,726
09860:  MOVFF  FEC,727
09864:  MOVFF  FEC,728
09868:  MOVFF  FEC,729
0986C:  MOVFF  725,565
09870:  MOVFF  724,564
09874:  MOVFF  70B,734
09878:  MOVLW  18
0987A:  MOVWF  x35
0987C:  MOVLB  0
0987E:  CALL   6680
09882:  MOVLW  2C
09884:  MOVLB  7
09886:  MOVWF  x50
09888:  MOVLB  0
0988A:  CALL   5BDE
0988E:  MOVLW  89
09890:  MOVWF  FE9
09892:  MOVFF  729,746
09896:  MOVFF  728,745
0989A:  MOVFF  727,744
0989E:  MOVFF  726,743
098A2:  MOVLW  02
098A4:  MOVLB  7
098A6:  MOVWF  x47
098A8:  MOVLB  0
098AA:  CALL   5D7C
098AE:  MOVLW  2C
098B0:  MOVLB  7
098B2:  MOVWF  x50
098B4:  MOVLB  0
098B6:  CALL   5BDE
098BA:  BRA    98C2
....................    else return INV_PARAM;
098BC:  MOVLW  02
098BE:  MOVWF  01
098C0:  BRA    98C6
....................    
....................    return SUCCESS;
098C2:  MOVLW  00
098C4:  MOVWF  01
098C6:  RETURN 0
.................... }
.................... 
.................... int8 getIPdata(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char *arg2;
....................    char *s_raw = "raw";
*
099E6:  MOVLW  72
099E8:  MOVLB  7
099EA:  MOVWF  x10
099EC:  MOVLW  61
099EE:  MOVWF  x11
099F0:  MOVLW  77
099F2:  MOVWF  x12
099F4:  CLRF   x13
099F6:  MOVLW  07
099F8:  MOVWF  x0F
099FA:  MOVLW  10
099FC:  MOVWF  x0E
....................    char *s_calibrated = "calib";
099FE:  MOVLW  63
09A00:  MOVWF  x16
09A02:  MOVLW  61
09A04:  MOVWF  x17
09A06:  MOVLW  6C
09A08:  MOVWF  x18
09A0A:  MOVLW  69
09A0C:  MOVWF  x19
09A0E:  MOVLW  62
09A10:  MOVWF  x1A
09A12:  CLRF   x1B
09A14:  MOVLW  07
09A16:  MOVWF  x15
09A18:  MOVLW  16
09A1A:  MOVWF  x14
....................    char *s_p0 = "p0";
09A1C:  MOVLW  70
09A1E:  MOVWF  x1E
09A20:  MOVLW  30
09A22:  MOVWF  x1F
09A24:  CLRF   x20
09A26:  MOVLW  07
09A28:  MOVWF  x1D
09A2A:  MOVLW  1E
09A2C:  MOVWF  x1C
....................    char *s_poles = "poles";
09A2E:  MOVLW  70
09A30:  MOVWF  x23
09A32:  MOVLW  6F
09A34:  MOVWF  x24
09A36:  MOVLW  6C
09A38:  MOVWF  x25
09A3A:  MOVLW  65
09A3C:  MOVWF  x26
09A3E:  MOVLW  73
09A40:  MOVWF  x27
09A42:  CLRF   x28
09A44:  MOVLW  07
09A46:  MOVWF  x22
09A48:  MOVLW  23
09A4A:  MOVWF  x21
....................    char *s_real = "real";
09A4C:  MOVLW  72
09A4E:  MOVWF  x2B
09A50:  MOVLW  65
09A52:  MOVWF  x2C
09A54:  MOVLW  61
09A56:  MOVWF  x2D
09A58:  MOVLW  6C
09A5A:  MOVWF  x2E
09A5C:  CLRF   x2F
09A5E:  MOVLW  07
09A60:  MOVWF  x2A
09A62:  MOVLW  2B
09A64:  MOVWF  x29
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
09A66:  CLRF   x47
09A68:  MOVFF  690,746
09A6C:  CLRF   x49
09A6E:  MOVLW  B5
09A70:  MOVWF  x48
09A72:  MOVLB  0
09A74:  CALL   0890
09A78:  MOVFF  02,731
09A7C:  MOVFF  01,730
09A80:  MOVLW  06
09A82:  MOVLB  7
09A84:  ADDWF  x30,F
09A86:  MOVLW  00
09A88:  ADDWFC x31,F
09A8A:  MOVLW  32
09A8C:  ADDWF  x30,W
09A8E:  MOVWF  01
09A90:  MOVLW  00
09A92:  ADDWFC x31,W
09A94:  MOVWF  03
09A96:  MOVF   01,W
09A98:  ADDLW  EB
09A9A:  MOVWF  01
09A9C:  MOVLW  01
09A9E:  ADDWFC 03,F
09AA0:  MOVFF  01,730
09AA4:  MOVFF  03,731
09AA8:  MOVFF  03,734
09AAC:  MOVFF  01,733
09AB0:  MOVLB  0
09AB2:  CALL   623C
09AB6:  MOVF   01,F
09AB8:  BNZ   9AC2
09ABA:  MOVLW  02
09ABC:  MOVWF  01
09ABE:  BRA    A106
09AC0:  BRA    9B20
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
09AC2:  MOVLB  7
09AC4:  CLRF   x47
09AC6:  MOVFF  690,746
09ACA:  CLRF   x49
09ACC:  MOVLW  B5
09ACE:  MOVWF  x48
09AD0:  MOVLB  0
09AD2:  CALL   0890
09AD6:  MOVFF  02,731
09ADA:  MOVFF  01,730
09ADE:  MOVLW  06
09AE0:  MOVLB  7
09AE2:  ADDWF  x30,F
09AE4:  MOVLW  00
09AE6:  ADDWFC x31,F
09AE8:  MOVLW  32
09AEA:  ADDWF  x30,W
09AEC:  MOVWF  01
09AEE:  MOVLW  00
09AF0:  ADDWFC x31,W
09AF2:  MOVWF  03
09AF4:  MOVF   01,W
09AF6:  ADDLW  EB
09AF8:  MOVWF  01
09AFA:  MOVLW  01
09AFC:  ADDWFC 03,F
09AFE:  MOVFF  01,730
09B02:  MOVFF  03,731
09B06:  MOVFF  03,734
09B0A:  MOVFF  01,733
09B0E:  CLRF   x36
09B10:  CLRF   x35
09B12:  MOVLW  0A
09B14:  MOVWF  x37
09B16:  MOVLB  0
09B18:  CALL   632C
09B1C:  MOVFF  01,70B
....................    
....................    arg2 = SERcmd[rec].p[3];
09B20:  MOVLB  7
09B22:  CLRF   x47
09B24:  MOVFF  690,746
09B28:  CLRF   x49
09B2A:  MOVLW  B5
09B2C:  MOVWF  x48
09B2E:  MOVLB  0
09B30:  CALL   0890
09B34:  MOVFF  02,731
09B38:  MOVFF  01,730
09B3C:  MOVLW  06
09B3E:  MOVLB  7
09B40:  ADDWF  x30,F
09B42:  MOVLW  00
09B44:  ADDWFC x31,F
09B46:  MOVLW  4B
09B48:  ADDWF  x30,W
09B4A:  MOVWF  01
09B4C:  MOVLW  00
09B4E:  ADDWFC x31,W
09B50:  MOVWF  03
09B52:  MOVF   01,W
09B54:  ADDLW  EB
09B56:  MOVWF  01
09B58:  MOVLW  01
09B5A:  ADDWFC 03,F
09B5C:  MOVFF  01,70C
09B60:  MOVFF  03,70D
....................    
....................    /*** GET INPUT DATA ****************/
....................    if      (0 == strcmp(s_raw, arg2)) {
09B64:  MOVFF  70F,742
09B68:  MOVFF  70E,741
09B6C:  MOVFF  70D,744
09B70:  MOVFF  70C,743
09B74:  MOVLB  0
09B76:  CALL   611C
09B7A:  MOVF   01,F
09B7C:  BTFSS  FD8.2
09B7E:  BRA    9CFA
....................       sprintf(retData+strlen(retData), "%d,", arg1);
09B80:  MOVLW  04
09B82:  MOVLB  7
09B84:  MOVWF  x42
09B86:  MOVLW  C1
09B88:  MOVWF  x41
09B8A:  MOVLB  0
09B8C:  CALL   5BA6
09B90:  MOVFF  02,03
09B94:  MOVF   01,W
09B96:  ADDLW  C1
09B98:  MOVLB  7
09B9A:  MOVWF  x30
09B9C:  MOVLW  04
09B9E:  ADDWFC 02,W
09BA0:  MOVWF  x31
09BA2:  MOVFF  FE8,565
09BA6:  MOVFF  730,564
09BAA:  MOVFF  70B,734
09BAE:  MOVLW  18
09BB0:  MOVWF  x35
09BB2:  MOVLB  0
09BB4:  CALL   6680
09BB8:  MOVLW  2C
09BBA:  MOVLB  7
09BBC:  MOVWF  x50
09BBE:  MOVLB  0
09BC0:  CALL   5BDE
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].sinRaw);
09BC4:  MOVLW  04
09BC6:  MOVLB  7
09BC8:  MOVWF  x42
09BCA:  MOVLW  C1
09BCC:  MOVWF  x41
09BCE:  MOVLB  0
09BD0:  CALL   5BA6
09BD4:  MOVFF  02,03
09BD8:  MOVF   01,W
09BDA:  ADDLW  C1
09BDC:  MOVLB  7
09BDE:  MOVWF  x30
09BE0:  MOVLW  04
09BE2:  ADDWFC 02,W
09BE4:  MOVWF  x31
09BE6:  MOVLW  01
09BE8:  SUBWF  x0B,W
09BEA:  MULLW  26
09BEC:  MOVF   FF3,W
09BEE:  CLRF   x33
09BF0:  MOVWF  x32
09BF2:  MOVLW  17
09BF4:  ADDWF  x32,W
09BF6:  MOVWF  FE9
09BF8:  MOVLW  01
09BFA:  ADDWFC x33,W
09BFC:  MOVWF  FEA
09BFE:  MOVFF  FEF,750
09C02:  MOVFF  FEC,01
09C06:  MOVFF  FEC,02
09C0A:  MOVFF  FEC,03
09C0E:  MOVFF  03,753
09C12:  MOVFF  02,752
09C16:  MOVFF  01,751
09C1A:  MOVLB  0
09C1C:  CALL   5CA6
09C20:  MOVFF  03,737
09C24:  MOVFF  02,736
09C28:  MOVFF  01,735
09C2C:  MOVFF  00,734
09C30:  MOVFF  731,565
09C34:  MOVFF  730,564
09C38:  MOVLW  41
09C3A:  MOVWF  FE9
09C3C:  MOVFF  03,73C
09C40:  MOVFF  02,73B
09C44:  MOVFF  01,73A
09C48:  MOVFF  00,739
09C4C:  RCALL  98C8
09C4E:  MOVLW  2C
09C50:  MOVLB  7
09C52:  MOVWF  x50
09C54:  MOVLB  0
09C56:  CALL   5BDE
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].cosRaw);
09C5A:  MOVLW  04
09C5C:  MOVLB  7
09C5E:  MOVWF  x42
09C60:  MOVLW  C1
09C62:  MOVWF  x41
09C64:  MOVLB  0
09C66:  CALL   5BA6
09C6A:  MOVF   01,W
09C6C:  ADDLW  C1
09C6E:  MOVLB  7
09C70:  MOVWF  x30
09C72:  MOVLW  04
09C74:  ADDWFC 02,W
09C76:  MOVWF  x31
09C78:  MOVLW  01
09C7A:  SUBWF  x0B,W
09C7C:  MULLW  26
09C7E:  MOVF   FF3,W
09C80:  CLRF   x33
09C82:  MOVWF  x32
09C84:  MOVLW  04
09C86:  ADDWF  x32,W
09C88:  MOVWF  01
09C8A:  MOVLW  00
09C8C:  ADDWFC x33,W
09C8E:  MOVWF  03
09C90:  MOVF   01,W
09C92:  ADDLW  17
09C94:  MOVWF  FE9
09C96:  MOVLW  01
09C98:  ADDWFC 03,W
09C9A:  MOVWF  FEA
09C9C:  MOVFF  FEF,750
09CA0:  MOVFF  FEC,01
09CA4:  MOVFF  FEC,02
09CA8:  MOVFF  FEC,03
09CAC:  MOVFF  03,753
09CB0:  MOVFF  02,752
09CB4:  MOVFF  01,751
09CB8:  MOVLB  0
09CBA:  CALL   5CA6
09CBE:  MOVFF  03,735
09CC2:  MOVFF  02,734
09CC6:  MOVFF  01,733
09CCA:  MOVFF  00,732
09CCE:  MOVFF  731,565
09CD2:  MOVFF  730,564
09CD6:  MOVLW  41
09CD8:  MOVWF  FE9
09CDA:  MOVFF  03,73C
09CDE:  MOVFF  02,73B
09CE2:  MOVFF  01,73A
09CE6:  MOVFF  00,739
09CEA:  RCALL  98C8
09CEC:  MOVLW  2C
09CEE:  MOVLB  7
09CF0:  MOVWF  x50
09CF2:  MOVLB  0
09CF4:  CALL   5BDE
....................    }
09CF8:  BRA    A102
....................    else if (0 == strcmp(s_calibrated, arg2)) {
09CFA:  MOVFF  715,742
09CFE:  MOVFF  714,741
09D02:  MOVFF  70D,744
09D06:  MOVFF  70C,743
09D0A:  CALL   611C
09D0E:  MOVF   01,F
09D10:  BTFSS  FD8.2
09D12:  BRA    9E96
....................       sprintf(retData+strlen(retData), "%d,", arg1);
09D14:  MOVLW  04
09D16:  MOVLB  7
09D18:  MOVWF  x42
09D1A:  MOVLW  C1
09D1C:  MOVWF  x41
09D1E:  MOVLB  0
09D20:  CALL   5BA6
09D24:  MOVFF  02,03
09D28:  MOVF   01,W
09D2A:  ADDLW  C1
09D2C:  MOVLB  7
09D2E:  MOVWF  x30
09D30:  MOVLW  04
09D32:  ADDWFC 02,W
09D34:  MOVWF  x31
09D36:  MOVFF  FE8,565
09D3A:  MOVFF  730,564
09D3E:  MOVFF  70B,734
09D42:  MOVLW  18
09D44:  MOVWF  x35
09D46:  MOVLB  0
09D48:  CALL   6680
09D4C:  MOVLW  2C
09D4E:  MOVLB  7
09D50:  MOVWF  x50
09D52:  MOVLB  0
09D54:  CALL   5BDE
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].sinCounts);
09D58:  MOVLW  04
09D5A:  MOVLB  7
09D5C:  MOVWF  x42
09D5E:  MOVLW  C1
09D60:  MOVWF  x41
09D62:  MOVLB  0
09D64:  CALL   5BA6
09D68:  MOVF   01,W
09D6A:  ADDLW  C1
09D6C:  MOVLB  7
09D6E:  MOVWF  x30
09D70:  MOVLW  04
09D72:  ADDWFC 02,W
09D74:  MOVWF  x31
09D76:  MOVLW  01
09D78:  SUBWF  x0B,W
09D7A:  MULLW  26
09D7C:  MOVF   FF3,W
09D7E:  CLRF   x33
09D80:  MOVWF  x32
09D82:  MOVLW  08
09D84:  ADDWF  x32,W
09D86:  MOVWF  01
09D88:  MOVLW  00
09D8A:  ADDWFC x33,W
09D8C:  MOVWF  03
09D8E:  MOVF   01,W
09D90:  ADDLW  17
09D92:  MOVWF  FE9
09D94:  MOVLW  01
09D96:  ADDWFC 03,W
09D98:  MOVWF  FEA
09D9A:  MOVFF  FEF,750
09D9E:  MOVFF  FEC,01
09DA2:  MOVFF  FEC,02
09DA6:  MOVFF  FEC,03
09DAA:  MOVFF  03,753
09DAE:  MOVFF  02,752
09DB2:  MOVFF  01,751
09DB6:  MOVLB  0
09DB8:  CALL   5CA6
09DBC:  MOVFF  03,735
09DC0:  MOVFF  02,734
09DC4:  MOVFF  01,733
09DC8:  MOVFF  00,732
09DCC:  MOVFF  731,565
09DD0:  MOVFF  730,564
09DD4:  MOVLW  41
09DD6:  MOVWF  FE9
09DD8:  MOVFF  03,73C
09DDC:  MOVFF  02,73B
09DE0:  MOVFF  01,73A
09DE4:  MOVFF  00,739
09DE8:  RCALL  98C8
09DEA:  MOVLW  2C
09DEC:  MOVLB  7
09DEE:  MOVWF  x50
09DF0:  MOVLB  0
09DF2:  CALL   5BDE
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].cosCounts);
09DF6:  MOVLW  04
09DF8:  MOVLB  7
09DFA:  MOVWF  x42
09DFC:  MOVLW  C1
09DFE:  MOVWF  x41
09E00:  MOVLB  0
09E02:  CALL   5BA6
09E06:  MOVF   01,W
09E08:  ADDLW  C1
09E0A:  MOVLB  7
09E0C:  MOVWF  x30
09E0E:  MOVLW  04
09E10:  ADDWFC 02,W
09E12:  MOVWF  x31
09E14:  MOVLW  01
09E16:  SUBWF  x0B,W
09E18:  MULLW  26
09E1A:  MOVF   FF3,W
09E1C:  CLRF   x33
09E1E:  MOVWF  x32
09E20:  MOVLW  0C
09E22:  ADDWF  x32,W
09E24:  MOVWF  01
09E26:  MOVLW  00
09E28:  ADDWFC x33,W
09E2A:  MOVWF  03
09E2C:  MOVF   01,W
09E2E:  ADDLW  17
09E30:  MOVWF  FE9
09E32:  MOVLW  01
09E34:  ADDWFC 03,W
09E36:  MOVWF  FEA
09E38:  MOVFF  FEF,750
09E3C:  MOVFF  FEC,01
09E40:  MOVFF  FEC,02
09E44:  MOVFF  FEC,03
09E48:  MOVFF  03,753
09E4C:  MOVFF  02,752
09E50:  MOVFF  01,751
09E54:  MOVLB  0
09E56:  CALL   5CA6
09E5A:  MOVFF  03,735
09E5E:  MOVFF  02,734
09E62:  MOVFF  01,733
09E66:  MOVFF  00,732
09E6A:  MOVFF  731,565
09E6E:  MOVFF  730,564
09E72:  MOVLW  41
09E74:  MOVWF  FE9
09E76:  MOVFF  03,73C
09E7A:  MOVFF  02,73B
09E7E:  MOVFF  01,73A
09E82:  MOVFF  00,739
09E86:  RCALL  98C8
09E88:  MOVLW  2C
09E8A:  MOVLB  7
09E8C:  MOVWF  x50
09E8E:  MOVLB  0
09E90:  CALL   5BDE
....................    }
09E94:  BRA    A102
....................    else if (0 == strcmp(s_p0, arg2)) {
09E96:  MOVFF  71D,742
09E9A:  MOVFF  71C,741
09E9E:  MOVFF  70D,744
09EA2:  MOVFF  70C,743
09EA6:  CALL   611C
09EAA:  MOVF   01,F
09EAC:  BNZ   9F68
....................       sprintf(retData+strlen(retData), "%d,", arg1);
09EAE:  MOVLW  04
09EB0:  MOVLB  7
09EB2:  MOVWF  x42
09EB4:  MOVLW  C1
09EB6:  MOVWF  x41
09EB8:  MOVLB  0
09EBA:  CALL   5BA6
09EBE:  MOVFF  02,03
09EC2:  MOVF   01,W
09EC4:  ADDLW  C1
09EC6:  MOVLB  7
09EC8:  MOVWF  x30
09ECA:  MOVLW  04
09ECC:  ADDWFC 02,W
09ECE:  MOVWF  x31
09ED0:  MOVFF  FE8,565
09ED4:  MOVFF  730,564
09ED8:  MOVFF  70B,734
09EDC:  MOVLW  18
09EDE:  MOVWF  x35
09EE0:  MOVLB  0
09EE2:  CALL   6680
09EE6:  MOVLW  2C
09EE8:  MOVLB  7
09EEA:  MOVWF  x50
09EEC:  MOVLB  0
09EEE:  CALL   5BDE
....................       sprintf(retData+strlen(retData), "%f,", adcVals[arg1-1].p0);
09EF2:  MOVLW  04
09EF4:  MOVLB  7
09EF6:  MOVWF  x42
09EF8:  MOVLW  C1
09EFA:  MOVWF  x41
09EFC:  MOVLB  0
09EFE:  CALL   5BA6
09F02:  MOVF   01,W
09F04:  ADDLW  C1
09F06:  MOVLB  7
09F08:  MOVWF  x30
09F0A:  MOVLW  04
09F0C:  ADDWFC 02,W
09F0E:  MOVWF  x31
09F10:  MOVLW  01
09F12:  SUBWF  x0B,W
09F14:  MULLW  26
09F16:  MOVF   FF3,W
09F18:  CLRF   x33
09F1A:  MOVWF  x32
09F1C:  MOVLW  18
09F1E:  ADDWF  x32,W
09F20:  MOVWF  01
09F22:  MOVLW  00
09F24:  ADDWFC x33,W
09F26:  MOVWF  03
09F28:  MOVF   01,W
09F2A:  ADDLW  17
09F2C:  MOVWF  FE9
09F2E:  MOVLW  01
09F30:  ADDWFC 03,W
09F32:  MOVWF  FEA
09F34:  MOVFF  FEF,743
09F38:  MOVFF  FEC,744
09F3C:  MOVFF  FEC,745
09F40:  MOVFF  FEC,746
09F44:  MOVFF  731,565
09F48:  MOVFF  730,564
09F4C:  MOVLW  89
09F4E:  MOVWF  FE9
09F50:  MOVLW  02
09F52:  MOVWF  x47
09F54:  MOVLB  0
09F56:  CALL   5D7C
09F5A:  MOVLW  2C
09F5C:  MOVLB  7
09F5E:  MOVWF  x50
09F60:  MOVLB  0
09F62:  CALL   5BDE
....................    }
09F66:  BRA    A102
....................    else if (0 == strcmp(s_poles, arg2)) {
09F68:  MOVFF  722,742
09F6C:  MOVFF  721,741
09F70:  MOVFF  70D,744
09F74:  MOVFF  70C,743
09F78:  CALL   611C
09F7C:  MOVF   01,F
09F7E:  BNZ   A02A
....................       sprintf(retData+strlen(retData), "%d,", arg1);
09F80:  MOVLW  04
09F82:  MOVLB  7
09F84:  MOVWF  x42
09F86:  MOVLW  C1
09F88:  MOVWF  x41
09F8A:  MOVLB  0
09F8C:  CALL   5BA6
09F90:  MOVFF  02,03
09F94:  MOVF   01,W
09F96:  ADDLW  C1
09F98:  MOVLB  7
09F9A:  MOVWF  x30
09F9C:  MOVLW  04
09F9E:  ADDWFC 02,W
09FA0:  MOVWF  x31
09FA2:  MOVFF  FE8,565
09FA6:  MOVFF  730,564
09FAA:  MOVFF  70B,734
09FAE:  MOVLW  18
09FB0:  MOVWF  x35
09FB2:  MOVLB  0
09FB4:  CALL   6680
09FB8:  MOVLW  2C
09FBA:  MOVLB  7
09FBC:  MOVWF  x50
09FBE:  MOVLB  0
09FC0:  CALL   5BDE
....................       sprintf(retData+strlen(retData), "%d,", adcVals[arg1-1].npoles);
09FC4:  MOVLW  04
09FC6:  MOVLB  7
09FC8:  MOVWF  x42
09FCA:  MOVLW  C1
09FCC:  MOVWF  x41
09FCE:  MOVLB  0
09FD0:  CALL   5BA6
09FD4:  MOVF   01,W
09FD6:  ADDLW  C1
09FD8:  MOVLB  7
09FDA:  MOVWF  x30
09FDC:  MOVLW  04
09FDE:  ADDWFC 02,W
09FE0:  MOVWF  x31
09FE2:  MOVLW  01
09FE4:  SUBWF  x0B,W
09FE6:  MULLW  26
09FE8:  MOVF   FF3,W
09FEA:  CLRF   x33
09FEC:  MOVWF  x32
09FEE:  MOVLW  1C
09FF0:  ADDWF  x32,W
09FF2:  MOVWF  01
09FF4:  MOVLW  00
09FF6:  ADDWFC x33,W
09FF8:  MOVWF  03
09FFA:  MOVF   01,W
09FFC:  ADDLW  17
09FFE:  MOVWF  FE9
0A000:  MOVLW  01
0A002:  ADDWFC 03,W
0A004:  MOVWF  FEA
0A006:  MOVFF  FEF,734
0A00A:  MOVFF  731,565
0A00E:  MOVFF  730,564
0A012:  MOVLW  18
0A014:  MOVWF  x35
0A016:  MOVLB  0
0A018:  CALL   6680
0A01C:  MOVLW  2C
0A01E:  MOVLB  7
0A020:  MOVWF  x50
0A022:  MOVLB  0
0A024:  CALL   5BDE
....................    }
0A028:  BRA    A102
....................    else if (0 == strcmp(s_real, arg2)) {
0A02A:  MOVFF  72A,742
0A02E:  MOVFF  729,741
0A032:  MOVFF  70D,744
0A036:  MOVFF  70C,743
0A03A:  CALL   611C
0A03E:  MOVF   01,F
0A040:  BNZ   A0FC
....................       sprintf(retData+strlen(retData), "%d,", arg1);
0A042:  MOVLW  04
0A044:  MOVLB  7
0A046:  MOVWF  x42
0A048:  MOVLW  C1
0A04A:  MOVWF  x41
0A04C:  MOVLB  0
0A04E:  CALL   5BA6
0A052:  MOVFF  02,03
0A056:  MOVF   01,W
0A058:  ADDLW  C1
0A05A:  MOVLB  7
0A05C:  MOVWF  x30
0A05E:  MOVLW  04
0A060:  ADDWFC 02,W
0A062:  MOVWF  x31
0A064:  MOVFF  FE8,565
0A068:  MOVFF  730,564
0A06C:  MOVFF  70B,734
0A070:  MOVLW  18
0A072:  MOVWF  x35
0A074:  MOVLB  0
0A076:  CALL   6680
0A07A:  MOVLW  2C
0A07C:  MOVLB  7
0A07E:  MOVWF  x50
0A080:  MOVLB  0
0A082:  CALL   5BDE
....................       sprintf(retData+strlen(retData), "%f,", adcVals[arg1-1].pReal);
0A086:  MOVLW  04
0A088:  MOVLB  7
0A08A:  MOVWF  x42
0A08C:  MOVLW  C1
0A08E:  MOVWF  x41
0A090:  MOVLB  0
0A092:  CALL   5BA6
0A096:  MOVF   01,W
0A098:  ADDLW  C1
0A09A:  MOVLB  7
0A09C:  MOVWF  x30
0A09E:  MOVLW  04
0A0A0:  ADDWFC 02,W
0A0A2:  MOVWF  x31
0A0A4:  MOVLW  01
0A0A6:  SUBWF  x0B,W
0A0A8:  MULLW  26
0A0AA:  MOVF   FF3,W
0A0AC:  CLRF   x33
0A0AE:  MOVWF  x32
0A0B0:  MOVLW  1D
0A0B2:  ADDWF  x32,W
0A0B4:  MOVWF  01
0A0B6:  MOVLW  00
0A0B8:  ADDWFC x33,W
0A0BA:  MOVWF  03
0A0BC:  MOVF   01,W
0A0BE:  ADDLW  17
0A0C0:  MOVWF  FE9
0A0C2:  MOVLW  01
0A0C4:  ADDWFC 03,W
0A0C6:  MOVWF  FEA
0A0C8:  MOVFF  FEF,743
0A0CC:  MOVFF  FEC,744
0A0D0:  MOVFF  FEC,745
0A0D4:  MOVFF  FEC,746
0A0D8:  MOVFF  731,565
0A0DC:  MOVFF  730,564
0A0E0:  MOVLW  89
0A0E2:  MOVWF  FE9
0A0E4:  MOVLW  02
0A0E6:  MOVWF  x47
0A0E8:  MOVLB  0
0A0EA:  CALL   5D7C
0A0EE:  MOVLW  2C
0A0F0:  MOVLB  7
0A0F2:  MOVWF  x50
0A0F4:  MOVLB  0
0A0F6:  CALL   5BDE
....................    }
0A0FA:  BRA    A102
....................    else return INV_PARAM;
0A0FC:  MOVLW  02
0A0FE:  MOVWF  01
0A100:  BRA    A106
....................    
....................    return SUCCESS;
0A102:  MOVLW  00
0A104:  MOVWF  01
0A106:  RETURN 0
.................... }
.................... 
.................... int8 getManOPvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0A108:  MOVLB  7
0A10A:  CLRF   x47
0A10C:  MOVFF  690,746
0A110:  CLRF   x49
0A112:  MOVLW  B5
0A114:  MOVWF  x48
0A116:  MOVLB  0
0A118:  CALL   0890
0A11C:  MOVFF  02,70D
0A120:  MOVFF  01,70C
0A124:  MOVLW  06
0A126:  MOVLB  7
0A128:  ADDWF  x0C,F
0A12A:  MOVLW  00
0A12C:  ADDWFC x0D,F
0A12E:  MOVLW  32
0A130:  ADDWF  x0C,W
0A132:  MOVWF  01
0A134:  MOVLW  00
0A136:  ADDWFC x0D,W
0A138:  MOVWF  03
0A13A:  MOVF   01,W
0A13C:  ADDLW  EB
0A13E:  MOVWF  01
0A140:  MOVLW  01
0A142:  ADDWFC 03,F
0A144:  MOVFF  01,70C
0A148:  MOVFF  03,70D
0A14C:  MOVFF  03,734
0A150:  MOVFF  01,733
0A154:  MOVLB  0
0A156:  CALL   623C
0A15A:  MOVF   01,F
0A15C:  BNZ   A166
0A15E:  MOVLW  02
0A160:  MOVWF  01
0A162:  BRA    A268
0A164:  BRA    A1C4
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
0A166:  MOVLB  7
0A168:  CLRF   x47
0A16A:  MOVFF  690,746
0A16E:  CLRF   x49
0A170:  MOVLW  B5
0A172:  MOVWF  x48
0A174:  MOVLB  0
0A176:  CALL   0890
0A17A:  MOVFF  02,70D
0A17E:  MOVFF  01,70C
0A182:  MOVLW  06
0A184:  MOVLB  7
0A186:  ADDWF  x0C,F
0A188:  MOVLW  00
0A18A:  ADDWFC x0D,F
0A18C:  MOVLW  32
0A18E:  ADDWF  x0C,W
0A190:  MOVWF  01
0A192:  MOVLW  00
0A194:  ADDWFC x0D,W
0A196:  MOVWF  03
0A198:  MOVF   01,W
0A19A:  ADDLW  EB
0A19C:  MOVWF  01
0A19E:  MOVLW  01
0A1A0:  ADDWFC 03,F
0A1A2:  MOVFF  01,70C
0A1A6:  MOVFF  03,70D
0A1AA:  MOVFF  03,734
0A1AE:  MOVFF  01,733
0A1B2:  CLRF   x36
0A1B4:  CLRF   x35
0A1B6:  MOVLW  0A
0A1B8:  MOVWF  x37
0A1BA:  MOVLB  0
0A1BC:  CALL   632C
0A1C0:  MOVFF  01,70B
....................    
....................    /*** GET MANUAL OUTPUT VALUE ***************/ 
....................    sprintf(retData+strlen(retData), "%d,%f,", arg1, dacVals[arg1-1].opPcnt);
0A1C4:  MOVLW  04
0A1C6:  MOVLB  7
0A1C8:  MOVWF  x42
0A1CA:  MOVLW  C1
0A1CC:  MOVWF  x41
0A1CE:  MOVLB  0
0A1D0:  CALL   5BA6
0A1D4:  MOVF   01,W
0A1D6:  ADDLW  C1
0A1D8:  MOVLB  7
0A1DA:  MOVWF  x0C
0A1DC:  MOVLW  04
0A1DE:  ADDWFC 02,W
0A1E0:  MOVWF  x0D
0A1E2:  MOVLW  01
0A1E4:  SUBWF  x0B,W
0A1E6:  MULLW  07
0A1E8:  MOVF   FF3,W
0A1EA:  CLRF   x0F
0A1EC:  MOVWF  x0E
0A1EE:  MOVLW  03
0A1F0:  ADDWF  x0E,W
0A1F2:  MOVWF  01
0A1F4:  MOVLW  00
0A1F6:  ADDWFC x0F,W
0A1F8:  MOVWF  03
0A1FA:  MOVF   01,W
0A1FC:  ADDLW  64
0A1FE:  MOVWF  FE9
0A200:  MOVLW  01
0A202:  ADDWFC 03,W
0A204:  MOVWF  FEA
0A206:  MOVFF  FEF,70E
0A20A:  MOVFF  FEC,70F
0A20E:  MOVFF  FEC,710
0A212:  MOVFF  FEC,711
0A216:  MOVFF  70D,565
0A21A:  MOVFF  70C,564
0A21E:  MOVFF  70B,734
0A222:  MOVLW  18
0A224:  MOVWF  x35
0A226:  MOVLB  0
0A228:  CALL   6680
0A22C:  MOVLW  2C
0A22E:  MOVLB  7
0A230:  MOVWF  x50
0A232:  MOVLB  0
0A234:  CALL   5BDE
0A238:  MOVLW  89
0A23A:  MOVWF  FE9
0A23C:  MOVFF  711,746
0A240:  MOVFF  710,745
0A244:  MOVFF  70F,744
0A248:  MOVFF  70E,743
0A24C:  MOVLW  02
0A24E:  MOVLB  7
0A250:  MOVWF  x47
0A252:  MOVLB  0
0A254:  CALL   5D7C
0A258:  MOVLW  2C
0A25A:  MOVLB  7
0A25C:  MOVWF  x50
0A25E:  MOVLB  0
0A260:  CALL   5BDE
....................    
....................    return SUCCESS;
0A264:  MOVLW  00
0A266:  MOVWF  01
0A268:  RETURN 0
.................... }
.................... 
.................... int8 setManOPvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    float arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0A26A:  MOVLB  7
0A26C:  CLRF   x47
0A26E:  MOVFF  690,746
0A272:  CLRF   x49
0A274:  MOVLW  B5
0A276:  MOVWF  x48
0A278:  MOVLB  0
0A27A:  CALL   0890
0A27E:  MOVFF  02,711
0A282:  MOVFF  01,710
0A286:  MOVLW  06
0A288:  MOVLB  7
0A28A:  ADDWF  x10,F
0A28C:  MOVLW  00
0A28E:  ADDWFC x11,F
0A290:  MOVLW  32
0A292:  ADDWF  x10,W
0A294:  MOVWF  01
0A296:  MOVLW  00
0A298:  ADDWFC x11,W
0A29A:  MOVWF  03
0A29C:  MOVF   01,W
0A29E:  ADDLW  EB
0A2A0:  MOVWF  01
0A2A2:  MOVLW  01
0A2A4:  ADDWFC 03,F
0A2A6:  MOVFF  01,710
0A2AA:  MOVFF  03,711
0A2AE:  MOVFF  03,734
0A2B2:  MOVFF  01,733
0A2B6:  MOVLB  0
0A2B8:  CALL   623C
0A2BC:  MOVF   01,F
0A2BE:  BNZ   A2C8
0A2C0:  MOVLW  02
0A2C2:  MOVWF  01
0A2C4:  BRA    A4DA
0A2C6:  BRA    A326
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
0A2C8:  MOVLB  7
0A2CA:  CLRF   x47
0A2CC:  MOVFF  690,746
0A2D0:  CLRF   x49
0A2D2:  MOVLW  B5
0A2D4:  MOVWF  x48
0A2D6:  MOVLB  0
0A2D8:  CALL   0890
0A2DC:  MOVFF  02,711
0A2E0:  MOVFF  01,710
0A2E4:  MOVLW  06
0A2E6:  MOVLB  7
0A2E8:  ADDWF  x10,F
0A2EA:  MOVLW  00
0A2EC:  ADDWFC x11,F
0A2EE:  MOVLW  32
0A2F0:  ADDWF  x10,W
0A2F2:  MOVWF  01
0A2F4:  MOVLW  00
0A2F6:  ADDWFC x11,W
0A2F8:  MOVWF  03
0A2FA:  MOVF   01,W
0A2FC:  ADDLW  EB
0A2FE:  MOVWF  01
0A300:  MOVLW  01
0A302:  ADDWFC 03,F
0A304:  MOVFF  01,710
0A308:  MOVFF  03,711
0A30C:  MOVFF  03,734
0A310:  MOVFF  01,733
0A314:  CLRF   x36
0A316:  CLRF   x35
0A318:  MOVLW  0A
0A31A:  MOVWF  x37
0A31C:  MOVLB  0
0A31E:  CALL   632C
0A322:  MOVFF  01,70B
....................    
....................    if (!arg_is_float(SERcmd[rec].p[3])) return INV_PARAM;
0A326:  MOVLB  7
0A328:  CLRF   x47
0A32A:  MOVFF  690,746
0A32E:  CLRF   x49
0A330:  MOVLW  B5
0A332:  MOVWF  x48
0A334:  MOVLB  0
0A336:  CALL   0890
0A33A:  MOVFF  02,711
0A33E:  MOVFF  01,710
0A342:  MOVLW  06
0A344:  MOVLB  7
0A346:  ADDWF  x10,F
0A348:  MOVLW  00
0A34A:  ADDWFC x11,F
0A34C:  MOVLW  4B
0A34E:  ADDWF  x10,W
0A350:  MOVWF  01
0A352:  MOVLW  00
0A354:  ADDWFC x11,W
0A356:  MOVWF  03
0A358:  MOVF   01,W
0A35A:  ADDLW  EB
0A35C:  MOVWF  01
0A35E:  MOVLW  01
0A360:  ADDWFC 03,F
0A362:  MOVFF  01,710
0A366:  MOVFF  03,711
0A36A:  MOVFF  03,715
0A36E:  MOVFF  01,714
0A372:  MOVLB  0
0A374:  CALL   7316
0A378:  MOVF   01,F
0A37A:  BNZ   A384
0A37C:  MOVLW  02
0A37E:  MOVWF  01
0A380:  BRA    A4DA
0A382:  BRA    A3EA
....................    else arg2 = strtod(SERcmd[rec].p[3], '\0');
0A384:  MOVLB  7
0A386:  CLRF   x47
0A388:  MOVFF  690,746
0A38C:  CLRF   x49
0A38E:  MOVLW  B5
0A390:  MOVWF  x48
0A392:  MOVLB  0
0A394:  CALL   0890
0A398:  MOVFF  02,711
0A39C:  MOVFF  01,710
0A3A0:  MOVLW  06
0A3A2:  MOVLB  7
0A3A4:  ADDWF  x10,F
0A3A6:  MOVLW  00
0A3A8:  ADDWFC x11,F
0A3AA:  MOVLW  4B
0A3AC:  ADDWF  x10,W
0A3AE:  MOVWF  01
0A3B0:  MOVLW  00
0A3B2:  ADDWFC x11,W
0A3B4:  MOVWF  03
0A3B6:  MOVF   01,W
0A3B8:  ADDLW  EB
0A3BA:  MOVWF  01
0A3BC:  MOVLW  01
0A3BE:  ADDWFC 03,F
0A3C0:  MOVFF  01,710
0A3C4:  MOVFF  03,711
0A3C8:  MOVFF  03,715
0A3CC:  MOVFF  01,714
0A3D0:  CLRF   x17
0A3D2:  CLRF   x16
0A3D4:  MOVLB  0
0A3D6:  CALL   73D8
0A3DA:  MOVFF  03,70F
0A3DE:  MOVFF  02,70E
0A3E2:  MOVFF  01,70D
0A3E6:  MOVFF  00,70C
....................    
....................    /*** SET MANUAL OUTPUT VALUE ***************/
....................    if (arg2 > op_upper_bound) dacVals[arg1-1].opPcnt = op_upper_bound;
0A3EA:  MOVLB  7
0A3EC:  CLRF   x59
0A3EE:  CLRF   x58
0A3F0:  MOVLW  7C
0A3F2:  MOVWF  x57
0A3F4:  MOVLW  84
0A3F6:  MOVWF  x56
0A3F8:  MOVFF  70F,75D
0A3FC:  MOVFF  70E,75C
0A400:  MOVFF  70D,75B
0A404:  MOVFF  70C,75A
0A408:  MOVLB  0
0A40A:  CALL   0D84
0A40E:  BNC   A444
0A410:  MOVLW  01
0A412:  MOVLB  7
0A414:  SUBWF  x0B,W
0A416:  MULLW  07
0A418:  MOVF   FF3,W
0A41A:  CLRF   x11
0A41C:  MOVWF  x10
0A41E:  MOVLW  03
0A420:  ADDWF  x10,W
0A422:  MOVWF  01
0A424:  MOVLW  00
0A426:  ADDWFC x11,W
0A428:  MOVWF  03
0A42A:  MOVF   01,W
0A42C:  ADDLW  64
0A42E:  MOVWF  FE9
0A430:  MOVLW  01
0A432:  ADDWFC 03,W
0A434:  MOVWF  FEA
0A436:  MOVLW  84
0A438:  MOVWF  FEF
0A43A:  MOVLW  7C
0A43C:  MOVWF  FEC
0A43E:  CLRF   FEC
0A440:  CLRF   FEC
0A442:  BRA    A4D4
....................    else if (arg2 < op_lower_bound) dacVals[arg1-1].opPcnt = op_lower_bound;  
0A444:  MOVFF  70F,759
0A448:  MOVFF  70E,758
0A44C:  MOVFF  70D,757
0A450:  MOVFF  70C,756
0A454:  MOVLB  7
0A456:  CLRF   x5D
0A458:  CLRF   x5C
0A45A:  MOVLW  C0
0A45C:  MOVWF  x5B
0A45E:  MOVLW  82
0A460:  MOVWF  x5A
0A462:  MOVLB  0
0A464:  CALL   0D84
0A468:  BNC   A49E
0A46A:  MOVLW  01
0A46C:  MOVLB  7
0A46E:  SUBWF  x0B,W
0A470:  MULLW  07
0A472:  MOVF   FF3,W
0A474:  CLRF   x11
0A476:  MOVWF  x10
0A478:  MOVLW  03
0A47A:  ADDWF  x10,W
0A47C:  MOVWF  01
0A47E:  MOVLW  00
0A480:  ADDWFC x11,W
0A482:  MOVWF  03
0A484:  MOVF   01,W
0A486:  ADDLW  64
0A488:  MOVWF  FE9
0A48A:  MOVLW  01
0A48C:  ADDWFC 03,W
0A48E:  MOVWF  FEA
0A490:  MOVLW  82
0A492:  MOVWF  FEF
0A494:  MOVLW  C0
0A496:  MOVWF  FEC
0A498:  CLRF   FEC
0A49A:  CLRF   FEC
0A49C:  BRA    A4D4
....................    else dacVals[arg1-1].opPcnt = arg2;
0A49E:  MOVLW  01
0A4A0:  MOVLB  7
0A4A2:  SUBWF  x0B,W
0A4A4:  MULLW  07
0A4A6:  MOVF   FF3,W
0A4A8:  CLRF   x11
0A4AA:  MOVWF  x10
0A4AC:  MOVLW  03
0A4AE:  ADDWF  x10,W
0A4B0:  MOVWF  01
0A4B2:  MOVLW  00
0A4B4:  ADDWFC x11,W
0A4B6:  MOVWF  03
0A4B8:  MOVF   01,W
0A4BA:  ADDLW  64
0A4BC:  MOVWF  FE9
0A4BE:  MOVLW  01
0A4C0:  ADDWFC 03,W
0A4C2:  MOVWF  FEA
0A4C4:  MOVFF  70C,FEF
0A4C8:  MOVFF  70D,FEC
0A4CC:  MOVFF  70E,FEC
0A4D0:  MOVFF  70F,FEC
....................    
....................    return SUCCESS;
0A4D4:  MOVLW  00
0A4D6:  MOVWF  01
0A4D8:  MOVLB  0
0A4DA:  RETURN 0
.................... }
.................... 
.................... int8 setFilterOn(unsigned int8 rec){
....................    adcFilter = TRUE;
0A4DC:  MOVLB  1
0A4DE:  BSF    x63.0
....................    return SUCCESS;
0A4E0:  MOVLW  00
0A4E2:  MOVWF  01
0A4E4:  MOVLB  0
0A4E6:  RETURN 0
.................... }
.................... 
.................... int8 setFilterOff(unsigned int8 rec){
....................    adcFilter = FALSE;
0A4E8:  MOVLB  1
0A4EA:  BCF    x63.0
....................    return SUCCESS;
0A4EC:  MOVLW  00
0A4EE:  MOVWF  01
0A4F0:  MOVLB  0
0A4F2:  RETURN 0
.................... }
.................... 
.................... int8 setHomeAxis(unsigned int8 rec){
....................     /*** ARG CHECKS ********************/
....................     int8 arg1;
....................     
....................     if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0A4F4:  MOVLB  7
0A4F6:  CLRF   x47
0A4F8:  MOVFF  690,746
0A4FC:  CLRF   x49
0A4FE:  MOVLW  B5
0A500:  MOVWF  x48
0A502:  MOVLB  0
0A504:  CALL   0890
0A508:  MOVFF  02,70D
0A50C:  MOVFF  01,70C
0A510:  MOVLW  06
0A512:  MOVLB  7
0A514:  ADDWF  x0C,F
0A516:  MOVLW  00
0A518:  ADDWFC x0D,F
0A51A:  MOVLW  32
0A51C:  ADDWF  x0C,W
0A51E:  MOVWF  01
0A520:  MOVLW  00
0A522:  ADDWFC x0D,W
0A524:  MOVWF  03
0A526:  MOVF   01,W
0A528:  ADDLW  EB
0A52A:  MOVWF  01
0A52C:  MOVLW  01
0A52E:  ADDWFC 03,F
0A530:  MOVFF  01,70C
0A534:  MOVFF  03,70D
0A538:  MOVFF  03,734
0A53C:  MOVFF  01,733
0A540:  MOVLB  0
0A542:  CALL   623C
0A546:  MOVF   01,F
0A548:  BNZ   A552
0A54A:  MOVLW  02
0A54C:  MOVWF  01
0A54E:  BRA    A5DE
0A550:  BRA    A5B0
....................     else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
0A552:  MOVLB  7
0A554:  CLRF   x47
0A556:  MOVFF  690,746
0A55A:  CLRF   x49
0A55C:  MOVLW  B5
0A55E:  MOVWF  x48
0A560:  MOVLB  0
0A562:  CALL   0890
0A566:  MOVFF  02,70D
0A56A:  MOVFF  01,70C
0A56E:  MOVLW  06
0A570:  MOVLB  7
0A572:  ADDWF  x0C,F
0A574:  MOVLW  00
0A576:  ADDWFC x0D,F
0A578:  MOVLW  32
0A57A:  ADDWF  x0C,W
0A57C:  MOVWF  01
0A57E:  MOVLW  00
0A580:  ADDWFC x0D,W
0A582:  MOVWF  03
0A584:  MOVF   01,W
0A586:  ADDLW  EB
0A588:  MOVWF  01
0A58A:  MOVLW  01
0A58C:  ADDWFC 03,F
0A58E:  MOVFF  01,70C
0A592:  MOVFF  03,70D
0A596:  MOVFF  03,734
0A59A:  MOVFF  01,733
0A59E:  CLRF   x36
0A5A0:  CLRF   x35
0A5A2:  MOVLW  0A
0A5A4:  MOVWF  x37
0A5A6:  MOVLB  0
0A5A8:  CALL   632C
0A5AC:  MOVFF  01,70B
....................     
....................     adcVals[arg1-1].homeFlag = TRUE;
0A5B0:  MOVLW  01
0A5B2:  MOVLB  7
0A5B4:  SUBWF  x0B,W
0A5B6:  MULLW  26
0A5B8:  MOVF   FF3,W
0A5BA:  CLRF   x0D
0A5BC:  MOVWF  x0C
0A5BE:  MOVLW  25
0A5C0:  ADDWF  x0C,W
0A5C2:  MOVWF  01
0A5C4:  MOVLW  00
0A5C6:  ADDWFC x0D,W
0A5C8:  MOVWF  03
0A5CA:  MOVF   01,W
0A5CC:  ADDLW  17
0A5CE:  MOVWF  FE9
0A5D0:  MOVLW  01
0A5D2:  ADDWFC 03,W
0A5D4:  MOVWF  FEA
0A5D6:  BSF    FEF.0
....................     
....................     return SUCCESS;
0A5D8:  MOVLW  00
0A5DA:  MOVWF  01
0A5DC:  MOVLB  0
0A5DE:  RETURN 0
.................... }
.................... 
.................... int8 invalidCmd(unsigned int8 rec){
....................    return INV_CMD;
0A5E0:  MOVLW  01
0A5E2:  MOVWF  01
0A5E4:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* ARG VALIDATION HELPER FUNCS                                               */
.................... /*****************************************************************************/
.................... BOOLEAN arg_is_float(char *arg){
*
07316:  MOVLB  7
07318:  BCF    x16.0
....................    BOOLEAN decimal = FALSE;
....................    for (int i=0; i<strlen(arg); i++){
0731A:  CLRF   x17
0731C:  MOVFF  715,742
07320:  MOVFF  714,741
07324:  MOVLB  0
07326:  CALL   5BA6
0732A:  MOVFF  02,03
0732E:  MOVF   01,W
07330:  MOVF   03,F
07332:  BNZ   733E
07334:  MOVF   01,W
07336:  MOVLB  7
07338:  SUBWF  x17,W
0733A:  BC    73D0
0733C:  MOVLB  0
....................       if (!isdigit(arg[i])){
0733E:  MOVLB  7
07340:  MOVF   x17,W
07342:  ADDWF  x14,W
07344:  MOVWF  FE9
07346:  MOVLW  00
07348:  ADDWFC x15,W
0734A:  MOVWF  FEA
0734C:  MOVFF  FEF,718
07350:  MOVF   x18,W
07352:  SUBLW  2F
07354:  BC    735C
07356:  MOVF   x18,W
07358:  SUBLW  39
0735A:  BC    73C8
....................          // Check for negative sign
....................          if ('-' != arg[i]){
0735C:  MOVF   x17,W
0735E:  ADDWF  x14,W
07360:  MOVWF  FE9
07362:  MOVLW  00
07364:  ADDWFC x15,W
07366:  MOVWF  FEA
07368:  MOVF   FEF,W
0736A:  SUBLW  2D
0736C:  BZ    7398
....................             // Check for decimal
....................             if ('.' != arg[i]) return FALSE;
0736E:  MOVF   x17,W
07370:  ADDWF  x14,W
07372:  MOVWF  FE9
07374:  MOVLW  00
07376:  ADDWFC x15,W
07378:  MOVWF  FEA
0737A:  MOVF   FEF,W
0737C:  SUBLW  2E
0737E:  BZ    7388
07380:  MOVLW  00
07382:  MOVWF  01
07384:  BRA    73D4
07386:  BRA    7396
....................             else if  (decimal) return FALSE;
07388:  BTFSS  x16.0
0738A:  BRA    7394
0738C:  MOVLW  00
0738E:  MOVWF  01
07390:  BRA    73D4
07392:  BRA    7396
....................             else decimal = TRUE;
07394:  BSF    x16.0
....................          }
07396:  BRA    73C8
....................          else if (0 != i) return FALSE;
07398:  MOVF   x17,F
0739A:  BZ    73A4
0739C:  MOVLW  00
0739E:  MOVWF  01
073A0:  BRA    73D4
073A2:  BRA    73C8
....................          else if (1 == strlen(arg)) return FALSE;
073A4:  MOVFF  715,742
073A8:  MOVFF  714,741
073AC:  MOVLB  0
073AE:  CALL   5BA6
073B2:  MOVFF  02,03
073B6:  MOVF   01,W
073B8:  SUBLW  01
073BA:  BNZ   73CA
073BC:  MOVF   03,F
073BE:  BNZ   73CA
073C0:  MOVLW  00
073C2:  MOVWF  01
073C4:  MOVLB  7
073C6:  BRA    73D4
073C8:  MOVLB  0
....................       }
073CA:  MOVLB  7
073CC:  INCF   x17,F
073CE:  BRA    731C
....................    }
....................    return TRUE;
073D0:  MOVLW  01
073D2:  MOVWF  01
073D4:  MOVLB  0
073D6:  RETURN 0
.................... }
.................... 
.................... BOOLEAN is_valid_channel(char *arg){
....................     if (1 != strlen(arg)) return FALSE;
*
0623C:  MOVFF  734,742
06240:  MOVFF  733,741
06244:  RCALL  5BA6
06246:  MOVFF  02,03
0624A:  MOVF   01,W
0624C:  SUBLW  01
0624E:  BNZ   6254
06250:  MOVF   03,F
06252:  BZ    625C
06254:  MOVLW  00
06256:  MOVWF  01
06258:  BRA    628A
0625A:  BRA    6282
....................     else if ('1' != arg[0] && '2' != arg[0]) return FALSE;
0625C:  MOVLB  7
0625E:  MOVFF  733,FE9
06262:  MOVFF  734,FEA
06266:  MOVF   FEF,W
06268:  SUBLW  31
0626A:  BZ    6284
0626C:  MOVFF  733,FE9
06270:  MOVFF  734,FEA
06274:  MOVF   FEF,W
06276:  SUBLW  32
06278:  BZ    6284
0627A:  MOVLW  00
0627C:  MOVWF  01
0627E:  MOVLB  0
06280:  BRA    628A
06282:  MOVLB  7
....................     return TRUE;
06284:  MOVLW  01
06286:  MOVWF  01
06288:  MOVLB  0
0628A:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* ASCII HEX CHARACTER TO INT                                                */
.................... /*****************************************************************************/
.................... int8 hex_to_int(char ascii){
....................    if (ascii >= '0' && ascii <= '9') return ascii-'0';
*
060E2:  MOVLB  7
060E4:  MOVF   x0A,W
060E6:  SUBLW  2F
060E8:  BC    60FA
060EA:  MOVF   x0A,W
060EC:  SUBLW  39
060EE:  BNC   60FA
060F0:  MOVLW  30
060F2:  SUBWF  x0A,W
060F4:  MOVWF  01
060F6:  BRA    6116
060F8:  BRA    6116
....................    else if (ascii >= 'A' && ascii <= 'F') return ascii-'A'+10;
060FA:  MOVF   x0A,W
060FC:  SUBLW  40
060FE:  BC    6112
06100:  MOVF   x0A,W
06102:  SUBLW  46
06104:  BNC   6112
06106:  MOVLW  41
06108:  SUBWF  x0A,W
0610A:  ADDLW  0A
0610C:  MOVWF  01
0610E:  BRA    6116
06110:  BRA    6116
....................    else return 0xFF;
06112:  MOVLW  FF
06114:  MOVWF  01
06116:  MOVLB  0
06118:  GOTO   A68A (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* COMMAND HANDLER/PARSER FUNCS                                              */
.................... /*****************************************************************************/
.................... void echo_cmd(unsigned int8 rec){
....................    fprintf(SERIAL, "%c", SERcmd[rec].t);
....................    while (SERcmd[rec].recReadIndex <= SERcmd[rec].recWriteIndex)
....................    {
....................       if (SERcmd[rec].recReadIndex != 0) fprintf(SERIAL, "%c", delimiter);
....................       fprintf(SERIAL, "%s", SERcmd[rec].p[SERcmd[rec].recReadIndex]);
....................       SERcmd[rec].recReadIndex++;
....................    }
....................    SERcmd[rec].recReadIndex=0;
.................... }
.................... 
.................... int8 command_parser(unsigned int8 rec){
*
0A5E6:  MOVLB  7
0A5E8:  CLRF   x47
0A5EA:  MOVFF  701,746
0A5EE:  CLRF   x49
0A5F0:  MOVLW  B5
0A5F2:  MOVWF  x48
0A5F4:  MOVLB  0
0A5F6:  CALL   0890
0A5FA:  MOVFF  02,70A
0A5FE:  MOVFF  01,709
0A602:  MOVLW  06
0A604:  MOVLB  7
0A606:  ADDWF  x09,F
0A608:  MOVLW  00
0A60A:  ADDWFC x0A,F
0A60C:  MOVLW  EB
0A60E:  ADDWF  x09,W
0A610:  MOVWF  01
0A612:  MOVLW  01
0A614:  ADDWFC x0A,W
0A616:  MOVWF  03
0A618:  MOVFF  01,702
0A61C:  MOVWF  x03
0A61E:  CLRF   x47
0A620:  MOVFF  701,746
0A624:  CLRF   x49
0A626:  MOVLW  B5
0A628:  MOVWF  x48
0A62A:  MOVLB  0
0A62C:  CALL   0890
0A630:  MOVFF  02,70C
0A634:  MOVFF  01,70B
0A638:  MOVLW  06
0A63A:  MOVLB  7
0A63C:  ADDWF  x0B,F
0A63E:  MOVLW  00
0A640:  ADDWFC x0C,F
0A642:  MOVLW  19
0A644:  ADDWF  x0B,W
0A646:  MOVWF  01
0A648:  MOVLW  00
0A64A:  ADDWFC x0C,W
0A64C:  MOVWF  03
0A64E:  MOVF   01,W
0A650:  ADDLW  EB
0A652:  MOVWF  01
0A654:  MOVLW  01
0A656:  ADDWFC 03,F
0A658:  MOVFF  01,704
0A65C:  MOVFF  03,705
0A660:  CLRF   x06
0A662:  CLRF   x07
....................    char *cmd_adr = SERcmd[rec].p[0];
....................    char *cmd_str = SERcmd[rec].p[1];
.................... //!   int8 devID = input_a();
....................    int8 devID = 0;
....................    int8 i = 0;
....................    
....................    if (hwID == cmd_adr[0]){
0A664:  MOVFF  702,FE9
0A668:  MOVFF  703,FEA
0A66C:  MOVF   FEF,W
0A66E:  SUBLW  44
0A670:  BTFSS  FD8.2
0A672:  BRA    A762
....................       if (hex_to_int(cmd_adr[1]) == (devID & 0x0F)){
0A674:  MOVLW  01
0A676:  ADDWF  x02,W
0A678:  MOVWF  FE9
0A67A:  MOVLW  00
0A67C:  ADDWFC x03,W
0A67E:  MOVWF  FEA
0A680:  MOVFF  FEF,70A
0A684:  MOVLB  0
0A686:  GOTO   60E2
0A68A:  MOVFF  01,709
0A68E:  MOVLB  7
0A690:  MOVF   x06,W
0A692:  ANDLW  0F
0A694:  SUBWF  01,W
0A696:  BNZ   A75A
....................          while (0 != strlen(cmd_list[i].cmd_name)){
0A698:  MOVF   x07,W
0A69A:  MULLW  04
0A69C:  MOVF   FF3,W
0A69E:  CLRF   x0A
0A6A0:  MOVWF  x09
0A6A2:  MOVLW  6A
0A6A4:  ADDWF  x09,W
0A6A6:  MOVWF  FE9
0A6A8:  MOVLW  05
0A6AA:  ADDWFC x0A,W
0A6AC:  MOVWF  FEA
0A6AE:  MOVFF  FEC,742
0A6B2:  MOVF   FED,F
0A6B4:  MOVFF  FEF,741
0A6B8:  MOVLB  0
0A6BA:  CALL   5BA6
0A6BE:  MOVFF  02,03
0A6C2:  MOVF   01,W
0A6C4:  BNZ   A6CA
0A6C6:  MOVF   03,F
0A6C8:  BZ    A750
....................             if (0 == strcmp(cmd_str, cmd_list[i].cmd_name))
0A6CA:  MOVLB  7
0A6CC:  MOVF   x07,W
0A6CE:  MULLW  04
0A6D0:  MOVF   FF3,W
0A6D2:  CLRF   x0A
0A6D4:  MOVWF  x09
0A6D6:  MOVLW  6A
0A6D8:  ADDWF  x09,W
0A6DA:  MOVWF  FE9
0A6DC:  MOVLW  05
0A6DE:  ADDWFC x0A,W
0A6E0:  MOVWF  FEA
0A6E2:  MOVFF  FEC,744
0A6E6:  MOVF   FED,F
0A6E8:  MOVFF  FEF,743
0A6EC:  MOVFF  705,742
0A6F0:  MOVFF  704,741
0A6F4:  MOVLB  0
0A6F6:  CALL   611C
0A6FA:  MOVF   01,F
0A6FC:  BNZ   A748
....................             {
....................                int8 return_code = cmd_list[i].cmd_func(rec);
0A6FE:  MOVLB  7
0A700:  MOVF   x07,W
0A702:  MULLW  04
0A704:  MOVF   FF3,W
0A706:  CLRF   x0A
0A708:  MOVWF  x09
0A70A:  MOVLW  02
0A70C:  ADDWF  x09,W
0A70E:  MOVWF  01
0A710:  MOVLW  00
0A712:  ADDWFC x0A,W
0A714:  MOVWF  03
0A716:  MOVF   01,W
0A718:  ADDLW  6A
0A71A:  MOVWF  01
0A71C:  MOVLW  05
0A71E:  ADDWFC 03,F
0A720:  MOVFF  01,709
0A724:  MOVFF  03,70A
0A728:  MOVFF  03,FEA
0A72C:  MOVFF  01,FE9
0A730:  MOVFF  701,690
0A734:  MOVLB  0
0A736:  CALL   00BC
0A73A:  MOVFF  01,708
....................                return return_code;
0A73E:  MOVLB  7
0A740:  MOVFF  708,01
0A744:  BRA    A766
0A746:  MOVLB  0
....................             }
....................             i++;
0A748:  MOVLB  7
0A74A:  INCF   x07,F
0A74C:  BRA    A698
0A74E:  MOVLB  0
....................          }
....................          return INV_CMD; // INVALID_CMD
0A750:  MOVLW  01
0A752:  MOVWF  01
0A754:  MOVLB  7
0A756:  BRA    A766
....................       } else return 254; // NOT THIS ADDRESS
0A758:  BRA    A760
0A75A:  MOVLW  FE
0A75C:  MOVWF  01
0A75E:  BRA    A766
....................    } else return 255; // NOT THIS DEVICE TYPE
0A760:  BRA    A766
0A762:  MOVLW  FF
0A764:  MOVWF  01
0A766:  MOVLB  0
0A768:  GOTO   A854 (RETURN)
.................... }
.................... 
.................... void command_handler_task(){
....................    while (getNextSERReadIndex())
*
0A7B8:  GOTO   6064
0A7BC:  MOVF   01,F
0A7BE:  BTFSC  FD8.2
0A7C0:  BRA    A8DE
....................    {
....................       int8 return_code;
....................       //echo_cmd(SRI);
....................       sprintf(retData + strlen(retData), "$%s,", SERcmd[SRI].p[0]);
0A7C2:  MOVLW  04
0A7C4:  MOVLB  7
0A7C6:  MOVWF  x42
0A7C8:  MOVLW  C1
0A7CA:  MOVWF  x41
0A7CC:  MOVLB  0
0A7CE:  CALL   5BA6
0A7D2:  MOVFF  02,03
0A7D6:  MOVF   01,W
0A7D8:  ADDLW  C1
0A7DA:  MOVLB  7
0A7DC:  MOVWF  x00
0A7DE:  MOVLW  04
0A7E0:  ADDWFC 02,W
0A7E2:  MOVWF  x01
0A7E4:  CLRF   x47
0A7E6:  MOVFF  4BF,746
0A7EA:  CLRF   x49
0A7EC:  MOVLW  B5
0A7EE:  MOVWF  x48
0A7F0:  MOVLB  0
0A7F2:  CALL   0890
0A7F6:  MOVFF  02,703
0A7FA:  MOVFF  01,702
0A7FE:  MOVLW  06
0A800:  MOVLB  7
0A802:  ADDWF  x02,F
0A804:  MOVLW  00
0A806:  ADDWFC x03,F
0A808:  MOVLW  EB
0A80A:  ADDWF  x02,W
0A80C:  MOVWF  01
0A80E:  MOVLW  01
0A810:  ADDWFC x03,W
0A812:  MOVWF  03
0A814:  MOVFF  01,704
0A818:  MOVWF  x05
0A81A:  MOVFF  701,565
0A81E:  MOVFF  700,564
0A822:  MOVLW  24
0A824:  MOVWF  x50
0A826:  MOVLB  0
0A828:  CALL   5BDE
0A82C:  MOVFF  565,FEA
0A830:  MOVFF  564,FE9
0A834:  CLRF   FEF
0A836:  MOVFF  705,FEA
0A83A:  MOVFF  704,FE9
0A83E:  CALL   60BE
0A842:  MOVLW  2C
0A844:  MOVLB  7
0A846:  MOVWF  x50
0A848:  MOVLB  0
0A84A:  CALL   5BDE
....................       
....................       return_code = command_parser(SRI);
0A84E:  MOVFF  4BF,701
0A852:  BRA    A5E6
0A854:  MOVFF  01,6FB
....................       
....................       sprintf(retData + strlen(retData), "%s", resp_list[return_code].msg);
0A858:  MOVLW  04
0A85A:  MOVLB  7
0A85C:  MOVWF  x42
0A85E:  MOVLW  C1
0A860:  MOVWF  x41
0A862:  MOVLB  0
0A864:  CALL   5BA6
0A868:  MOVF   01,W
0A86A:  ADDLW  C1
0A86C:  MOVLB  7
0A86E:  MOVWF  x00
0A870:  MOVLW  04
0A872:  ADDWFC 02,W
0A874:  MOVWF  x01
0A876:  MOVLB  6
0A878:  MOVF   xFB,W
0A87A:  MULLW  03
0A87C:  MOVF   FF3,W
0A87E:  MOVLB  7
0A880:  CLRF   x03
0A882:  MOVWF  x02
0A884:  MOVLW  01
0A886:  ADDWF  x02,W
0A888:  MOVWF  01
0A88A:  MOVLW  00
0A88C:  ADDWFC x03,W
0A88E:  MOVWF  03
0A890:  MOVF   01,W
0A892:  ADDLW  5C
0A894:  MOVWF  FE9
0A896:  MOVLW  06
0A898:  ADDWFC 03,W
0A89A:  MOVWF  FEA
0A89C:  MOVFF  FEC,703
0A8A0:  MOVF   FED,F
0A8A2:  MOVFF  FEF,702
0A8A6:  MOVFF  701,565
0A8AA:  MOVFF  700,564
0A8AE:  MOVFF  565,FEA
0A8B2:  MOVFF  564,FE9
0A8B6:  CLRF   FEF
0A8B8:  MOVFF  703,FEA
0A8BC:  MOVFF  702,FE9
0A8C0:  MOVLB  0
0A8C2:  CALL   60BE
....................       serial_out(retData);
0A8C6:  MOVLW  04
0A8C8:  MOVLB  7
0A8CA:  MOVWF  x02
0A8CC:  MOVLW  C1
0A8CE:  MOVWF  x01
0A8D0:  MOVLB  0
0A8D2:  BRA    A76C
....................       resetSERcmd(SRI);
0A8D4:  MOVFF  4BF,701
0A8D8:  CALL   0B72
0A8DC:  BRA    A7B8
....................    }
0A8DE:  GOTO   B0CA (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... #define DEBUG_1
.................... 
.................... #ifdef DEBUG_1
.................... #use rs232(ICD, stream=ICD_STREAM)
*
05FEA:  MOVFF  FF2,03
05FEE:  BCF    FF2.7
05FF0:  MOVLW  C4
05FF2:  MOVWF  F88
05FF4:  BCF    F83.7
05FF6:  MOVLW  08
05FF8:  MOVWF  01
05FFA:  BRA    5FFC
05FFC:  NOP   
05FFE:  BSF    01.7
06000:  BRA    6022
06002:  BCF    01.7
06004:  MOVLB  6
06006:  RRCF   xFD,F
06008:  MOVLB  0
0600A:  BTFSC  FD8.0
0600C:  BSF    F83.7
0600E:  BTFSS  FD8.0
06010:  BCF    F83.7
06012:  BSF    01.6
06014:  BRA    6022
06016:  BCF    01.6
06018:  DECFSZ 01,F
0601A:  BRA    6004
0601C:  BRA    601E
0601E:  NOP   
06020:  BSF    F83.7
06022:  MOVLW  84
06024:  MOVWF  FE9
06026:  DECFSZ FE9,F
06028:  BRA    6026
0602A:  BRA    602C
0602C:  NOP   
0602E:  BTFSC  01.7
06030:  BRA    6002
06032:  BTFSC  01.6
06034:  BRA    6016
06036:  BTFSC  03.7
06038:  BSF    FF2.7
0603A:  GOTO   6050 (RETURN)
.................... #endif
.................... 
.................... void main()
*
0A8E2:  CLRF   FF8
0A8E4:  BCF    FF2.5
0A8E6:  BSF    07.7
0A8E8:  MOVLB  E
0A8EA:  MOVLW  55
0A8EC:  MOVWF  x9B
0A8EE:  MOVLW  AA
0A8F0:  MOVWF  x9B
0A8F2:  BCF    x9B.0
0A8F4:  MOVLW  17
0A8F6:  MOVWF  xB0
0A8F8:  MOVLW  13
0A8FA:  MOVWF  xB2
0A8FC:  MOVLW  09
0A8FE:  MOVWF  x8A
0A900:  MOVLW  0A
0A902:  MOVWF  x8B
0A904:  MOVLW  11
0A906:  MOVWF  xEB
0A908:  MOVLW  12
0A90A:  MOVWF  xED
0A90C:  MOVLW  10
0A90E:  MOVWF  xF4
0A910:  MOVLW  0F
0A912:  MOVWF  xF5
0A914:  MOVLW  09
0A916:  MOVWF  xF8
0A918:  MOVLW  55
0A91A:  MOVWF  x9B
0A91C:  MOVLW  AA
0A91E:  MOVWF  x9B
0A920:  BSF    x9B.0
0A922:  CLRF   xD8
0A924:  CLRF   xD5
0A926:  CLRF   xD7
0A928:  MOVLW  08
0A92A:  MOVWF  xD9
0A92C:  MOVLW  60
0A92E:  MOVWF  xD3
0A930:  MOVLW  AA
0A932:  MOVLB  0
0A934:  MOVWF  xFA
0A936:  MOVLB  1
0A938:  BCF    x63.0
0A93A:  CLRF   x75
0A93C:  CLRF   x74
0A93E:  CLRF   x73
0A940:  CLRF   x72
0A942:  CLRF   x79
0A944:  CLRF   x78
0A946:  CLRF   x77
0A948:  CLRF   x76
0A94A:  CLRF   x7D
0A94C:  CLRF   x7C
0A94E:  CLRF   x7B
0A950:  CLRF   x7A
0A952:  CLRF   x7F
0A954:  CLRF   x7E
0A956:  MOVLB  E
0A958:  BCF    x91.5
0A95A:  MOVLW  00
0A95C:  MOVWF  x90
0A95E:  MOVLW  03
0A960:  MOVWF  x8E
0A962:  MOVLW  2A
0A964:  MOVWF  x91
0A966:  MOVLW  C4
0A968:  MOVWF  F88
0A96A:  MOVWF  F88
0A96C:  MOVWF  F88
0A96E:  MOVLB  1
0A970:  CLRF   xD0
0A972:  CLRF   xD1
0A974:  CLRF   xD2
0A976:  CLRF   xD3
0A978:  BCF    F95.5
0A97A:  MOVLW  40
0A97C:  MOVWF  F94
0A97E:  MOVLW  9F
0A980:  MOVWF  F92
0A982:  MOVLW  3A
0A984:  MOVWF  F95
0A986:  MOVLW  93
0A988:  MOVWF  F89
0A98A:  MOVWF  F89
0A98C:  MOVLB  4
0A98E:  CLRF   xBF
0A990:  CLRF   xC0
0A992:  MOVLB  5
0A994:  CLRF   x61
0A996:  CLRF   x62
0A998:  MOVLB  1
0A99A:  BCF    x63.1
0A99C:  MOVLB  5
0A99E:  CLRF   x63
0A9A0:  BSF    F9E.3
0A9A2:  MOVLW  7C
0A9A4:  MOVWF  F9A
0A9A6:  MOVLW  00
0A9A8:  MOVWF  F9B
0A9AA:  MOVLW  A6
0A9AC:  MOVWF  F9D
0A9AE:  MOVLW  90
0A9B0:  MOVWF  F9C
0A9B2:  CLRF   x65
0A9B4:  CLRF   x64
0A9B6:  CLRF   x69
0A9B8:  CLRF   x68
0A9BA:  CLRF   x67
0A9BC:  CLRF   x66
0A9BE:  MOVLW  C4
0A9C0:  MOVWF  F88
0A9C2:  BSF    F83.7
0A9C4:  MOVLW  12
0A9C6:  MOVWF  03
0A9C8:  MOVLW  FA
0A9CA:  MOVLB  7
0A9CC:  MOVWF  x0F
0A9CE:  MOVLB  0
0A9D0:  CALL   03A4
0A9D4:  DECFSZ 03,F
0A9D6:  BRA    A9DA
0A9D8:  BRA    A9DE
0A9DA:  MOVLB  5
0A9DC:  BRA    A9C8
0A9DE:  MOVLB  F
0A9E0:  CLRF   x0C
0A9E2:  CLRF   x14
0A9E4:  CLRF   x1C
0A9E6:  CLRF   x21
0A9E8:  CLRF   x29
0A9EA:  CLRF   x35
0A9EC:  CLRF   x36
0A9EE:  CLRF   x37
0A9F0:  CLRF   x34
0A9F2:  CLRF   x31
0A9F4:  CLRF   x32
0A9F6:  CLRF   x33
0A9F8:  CLRF   x30
0A9FA:  MOVLW  61
0A9FC:  MOVLB  5
0A9FE:  MOVWF  x6D
0AA00:  MOVLW  B4
0AA02:  MOVWF  x6C
0AA04:  MOVLW  61
0AA06:  MOVWF  x71
0AA08:  MOVLW  F8
0AA0A:  MOVWF  x70
0AA0C:  MOVLW  67
0AA0E:  MOVWF  x75
0AA10:  MOVLW  48
0AA12:  MOVWF  x74
0AA14:  MOVLW  68
0AA16:  MOVWF  x79
0AA18:  MOVLW  F4
0AA1A:  MOVWF  x78
0AA1C:  MOVLW  6A
0AA1E:  MOVWF  x7D
0AA20:  MOVLW  A6
0AA22:  MOVWF  x7C
0AA24:  MOVLW  6C
0AA26:  MOVWF  x81
0AA28:  MOVLW  36
0AA2A:  MOVWF  x80
0AA2C:  MOVLW  6E
0AA2E:  MOVWF  x85
0AA30:  MOVLW  54
0AA32:  MOVWF  x84
0AA34:  MOVLW  76
0AA36:  MOVWF  x89
0AA38:  MOVLW  32
0AA3A:  MOVWF  x88
0AA3C:  MOVLW  79
0AA3E:  MOVWF  x8D
0AA40:  MOVLW  12
0AA42:  MOVWF  x8C
0AA44:  MOVLW  7A
0AA46:  MOVWF  x91
0AA48:  MOVLW  74
0AA4A:  MOVWF  x90
0AA4C:  MOVLW  7C
0AA4E:  MOVWF  x95
0AA50:  MOVLW  32
0AA52:  MOVWF  x94
0AA54:  MOVLW  7F
0AA56:  MOVWF  x99
0AA58:  MOVLW  E8
0AA5A:  MOVWF  x98
0AA5C:  MOVLW  85
0AA5E:  MOVWF  x9D
0AA60:  MOVLW  44
0AA62:  MOVWF  x9C
0AA64:  MOVLW  88
0AA66:  MOVWF  xA1
0AA68:  MOVLW  DC
0AA6A:  MOVWF  xA0
0AA6C:  MOVLW  8E
0AA6E:  MOVWF  xA5
0AA70:  MOVLW  08
0AA72:  MOVWF  xA4
0AA74:  MOVLW  8E
0AA76:  MOVWF  xA9
0AA78:  MOVLW  0E
0AA7A:  MOVWF  xA8
0AA7C:  MOVLW  94
0AA7E:  MOVWF  xAD
0AA80:  MOVLW  82
0AA82:  MOVWF  xAC
0AA84:  MOVLW  99
0AA86:  MOVWF  xB1
0AA88:  MOVLW  E6
0AA8A:  MOVWF  xB0
0AA8C:  MOVLW  A1
0AA8E:  MOVWF  xB5
0AA90:  MOVLW  08
0AA92:  MOVWF  xB4
0AA94:  MOVLW  A2
0AA96:  MOVWF  xB9
0AA98:  MOVLW  6A
0AA9A:  MOVWF  xB8
0AA9C:  MOVLW  A4
0AA9E:  MOVWF  xBD
0AAA0:  MOVLW  DC
0AAA2:  MOVWF  xBC
0AAA4:  MOVLW  A4
0AAA6:  MOVWF  xC1
0AAA8:  MOVLW  E8
0AAAA:  MOVWF  xC0
0AAAC:  MOVLW  A4
0AAAE:  MOVWF  xC5
0AAB0:  MOVLW  F4
0AAB2:  MOVWF  xC4
0AAB4:  MOVLW  A5
0AAB6:  MOVWF  xC9
0AAB8:  MOVLW  E0
0AABA:  MOVWF  xC8
0AABC:  BRA    AC9C
0AABE:  DATA 02,00
0AAC0:  DATA 1A,00
0AAC2:  DATA 00,0C
0AAC4:  DATA 00,20
0AAC6:  DATA 78,23
0AAC8:  DATA D7,0A
0AACA:  DATA 7D,19
0AACC:  DATA 99,9A
0AACE:  DATA 7B,4C
0AAD0:  DATA CC,CD
0AAD2:  DATA 1C,C0
0AAD4:  DATA 00,0C
0AAD6:  DATA 80,78
0AAD8:  DATA 23,D7
0AADA:  DATA 0A,7D
0AADC:  DATA 19,99
0AADE:  DATA 9A,7B
0AAE0:  DATA 4C,CC
0AAE2:  DATA CD,1C
0AAE4:  DATA C0,00
0AAE6:  DATA 01,80
0AAE8:  DATA 02,09
0AAEA:  DATA C0,00
0AAEC:  DATA 05,80
0AAEE:  DATA 7F,00
0AAF0:  DATA 00,00
0AAF2:  DATA 7F,0B
0AAF4:  DATA C0,00
0AAF6:  DATA 05,80
0AAF8:  DATA 7F,00
0AAFA:  DATA 00,00
0AAFC:  DATA 7F,07
0AAFE:  DATA C0,00
0AB00:  DATA 01,80
0AB02:  DATA 7F,17
0AB04:  DATA C0,00
0AB06:  DATA 01,80
0AB08:  DATA 7F,17
0AB0A:  DATA C0,00
0AB0C:  DATA 04,80
0AB0E:  DATA 79,B7
0AB10:  DATA F3,BD
0AB12:  DATA 04,C0
0AB14:  DATA 00,04
0AB16:  DATA 80,7C
0AB18:  DATA 59,DF
0AB1A:  DATA 4E,04
0AB1C:  DATA C0,00
0AB1E:  DATA 04,80
0AB20:  DATA 78,0A
0AB22:  DATA 28,88
0AB24:  DATA 04,C0
0AB26:  DATA 00,04
0AB28:  DATA 80,78
0AB2A:  DATA 05,EA
0AB2C:  DATA 16,04
0AB2E:  DATA C0,00
0AB30:  DATA 04,80
0AB32:  DATA 78,1E
0AB34:  DATA 33,D7
0AB36:  DATA 04,C0
0AB38:  DATA 00,04
0AB3A:  DATA 80,77
0AB3C:  DATA 68,7B
0AB3E:  DATA BB,04
0AB40:  DATA C0,00
0AB42:  DATA 04,80
0AB44:  DATA 77,68
0AB46:  DATA 0D,C6
0AB48:  DATA 68,40
0AB4A:  DATA FB,00
0AB4C:  DATA 0E,41
0AB4E:  DATA 64,00
0AB50:  DATA 17,41
0AB52:  DATA D4,00
0AB54:  DATA 3C,45
0AB56:  DATA 25,00
0AB58:  DATA 02,05
0AB5A:  DATA 6A,CA
0AB5C:  DATA 05,02
0AB5E:  DATA 05,6E
0AB60:  DATA CD,05
0AB62:  DATA 02,05
0AB64:  DATA 72,D0
0AB66:  DATA 05,02
0AB68:  DATA 05,76
0AB6A:  DATA D7,05
0AB6C:  DATA 02,05
0AB6E:  DATA 7A,DE
0AB70:  DATA 05,02
0AB72:  DATA 05,7E
0AB74:  DATA E6,05
0AB76:  DATA 02,05
0AB78:  DATA 82,EE
0AB7A:  DATA 05,02
0AB7C:  DATA 05,86
0AB7E:  DATA F3,05
0AB80:  DATA 02,05
0AB82:  DATA 8A,F8
0AB84:  DATA 05,02
0AB86:  DATA 05,8E
0AB88:  DATA FC,05
0AB8A:  DATA 02,05
0AB8C:  DATA 92,00
0AB8E:  DATA 06,02
0AB90:  DATA 05,96
0AB92:  DATA 07,06
0AB94:  DATA 02,05
0AB96:  DATA 9A,0D
0AB98:  DATA 06,02
0AB9A:  DATA 05,9E
0AB9C:  DATA 13,06
0AB9E:  DATA 02,05
0ABA0:  DATA A2,19
0ABA2:  DATA 06,02
0ABA4:  DATA 05,A6
0ABA6:  DATA 1F,06
0ABA8:  DATA 02,05
0ABAA:  DATA AA,24
0ABAC:  DATA 06,02
0ABAE:  DATA 05,AE
0ABB0:  DATA 2D,06
0ABB2:  DATA 02,05
0ABB4:  DATA B2,35
0ABB6:  DATA 06,02
0ABB8:  DATA 05,B6
0ABBA:  DATA 3C,06
0ABBC:  DATA 02,05
0ABBE:  DATA BA,43
0ABC0:  DATA 06,02
0ABC2:  DATA 05,BE
0ABC4:  DATA 4B,06
0ABC6:  DATA 02,05
0ABC8:  DATA C2,54
0ABCA:  DATA 06,02
0ABCC:  DATA 05,C6
0ABCE:  DATA 5A,06
0ABD0:  DATA 8F,05
0ABD2:  DATA CA,67
0ABD4:  DATA 72,00
0ABD6:  DATA 67,73
0ABD8:  DATA 00,67
0ABDA:  DATA 43,68
0ABDC:  DATA 4D,61
0ABDE:  DATA 70,00
0ABE0:  DATA 73,43
0ABE2:  DATA 68,4D
0ABE4:  DATA 61,70
0ABE6:  DATA 00,67
0ABE8:  DATA 43,68
0ABEA:  DATA 4D,6F
0ABEC:  DATA 64,65
0ABEE:  DATA 00,73
0ABF0:  DATA 43,68
0ABF2:  DATA 4D,6F
0ABF4:  DATA 64,65
0ABF6:  DATA 00,67
0ABF8:  DATA 50,49
0ABFA:  DATA 44,00
0ABFC:  DATA 73,50
0ABFE:  DATA 49,44
0AC00:  DATA 00,67
0AC02:  DATA 53,50
0AC04:  DATA 00,73
0AC06:  DATA 53,50
0AC08:  DATA 00,67
0AC0A:  DATA 53,43
0AC0C:  DATA 61,6C
0AC0E:  DATA 73,00
0AC10:  DATA 67,53
0AC12:  DATA 43,61
0AC14:  DATA 6C,00
0AC16:  DATA 73,53
0AC18:  DATA 43,61
0AC1A:  DATA 6C,00
0AC1C:  DATA 67,4D
0AC1E:  DATA 43,61
0AC20:  DATA 6C,00
0AC22:  DATA 73,4D
0AC24:  DATA 43,61
0AC26:  DATA 6C,00
0AC28:  DATA 67,4D
0AC2A:  DATA 6F,6E
0AC2C:  DATA 00,67
0AC2E:  DATA 50,49
0AC30:  DATA 44,64
0AC32:  DATA 61,74
0AC34:  DATA 61,00
0AC36:  DATA 67,49
0AC38:  DATA 50,64
0AC3A:  DATA 61,74
0AC3C:  DATA 61,00
0AC3E:  DATA 67,4D
0AC40:  DATA 61,6E
0AC42:  DATA 4F,50
0AC44:  DATA 00,73
0AC46:  DATA 4D,61
0AC48:  DATA 6E,4F
0AC4A:  DATA 50,00
0AC4C:  DATA 73,46
0AC4E:  DATA 69,6C
0AC50:  DATA 74,4F
0AC52:  DATA 6E,00
0AC54:  DATA 73,46
0AC56:  DATA 69,6C
0AC58:  DATA 74,4F
0AC5A:  DATA 66,66
0AC5C:  DATA 00,73
0AC5E:  DATA 48,6F
0AC60:  DATA 6D,65
0AC62:  DATA 04,C0
0AC64:  DATA 00,33
0AC66:  DATA 80,65
0AC68:  DATA 06,01
0AC6A:  DATA 6D,06
0AC6C:  DATA 02,7D
0AC6E:  DATA 06,53
0AC70:  DATA 55,43
0AC72:  DATA 43,45
0AC74:  DATA 53,53
0AC76:  DATA 00,49
0AC78:  DATA 4E,56
0AC7A:  DATA 41,4C
0AC7C:  DATA 49,44
0AC7E:  DATA 20,43
0AC80:  DATA 4F,4D
0AC82:  DATA 4D,41
0AC84:  DATA 4E,44
0AC86:  DATA 00,49
0AC88:  DATA 4E,56
0AC8A:  DATA 41,4C
0AC8C:  DATA 49,44
0AC8E:  DATA 20,50
0AC90:  DATA 41,52
0AC92:  DATA 41,4D
0AC94:  DATA 45,54
0AC96:  DATA 45,52
0AC98:  DATA 00,00
0AC9A:  DATA 00,00
0AC9C:  MOVLW  00
0AC9E:  MOVWF  FF8
0ACA0:  MOVLW  AA
0ACA2:  MOVWF  FF7
0ACA4:  MOVLW  BE
0ACA6:  MOVWF  FF6
0ACA8:  TBLRD*+
0ACAA:  MOVF   FF5,W
0ACAC:  MOVWF  00
0ACAE:  XORLW  00
0ACB0:  BZ    ACD8
0ACB2:  TBLRD*+
0ACB4:  MOVF   FF5,W
0ACB6:  MOVWF  01
0ACB8:  BTFSC  FE8.7
0ACBA:  BRA    ACC6
0ACBC:  ANDLW  3F
0ACBE:  MOVWF  FEA
0ACC0:  TBLRD*+
0ACC2:  MOVFF  FF5,FE9
0ACC6:  BTFSC  01.6
0ACC8:  TBLRD*+
0ACCA:  BTFSS  01.6
0ACCC:  TBLRD*+
0ACCE:  MOVFF  FF5,FEE
0ACD2:  DCFSNZ 00,F
0ACD4:  BRA    ACA8
0ACD6:  BRA    ACCA
0ACD8:  CLRF   FF8
0ACDA:  MOVLB  6
0ACDC:  CLRF   x92
0ACDE:  MOVLW  64
0ACE0:  MOVWF  x91
0ACE2:  CLRF   x94
0ACE4:  CLRF   x93
0ACE6:  CLRF   x96
0ACE8:  CLRF   x95
.................... {
....................     int16 loopDelay = 100;
....................     int16 controlCounter = 0;
....................     int16 debugCounter = 0;
....................    
....................     char pBuff[100];
....................    
....................     IO_init();                    // set up IO 
0ACEA:  MOVLB  0
0ACEC:  GOTO   03CE
....................     params_init();                // load parameters
0ACF0:  GOTO   066A
....................     monitor_init();               // initialize internal ADC for voltage and current telemetry
0ACF4:  GOTO   0AB6
....................     control_init();               // initialize the output control DACs
0ACF8:  GOTO   0B4E
....................     serial_init();                // setup the serial port
0ACFC:  GOTO   0CEC
....................     event_timer_init();
0AD00:  GOTO   0D0E
.................... //!    setup_wdt(WDT_512MS);
....................     enable_interrupts(GLOBAL);
0AD04:  MOVLW  C0
0AD06:  IORWF  FF2,F
....................    
....................     while(TRUE)
....................     {
....................         //!      restart_wdt();
....................         pBuff[0] = '\0';
0AD08:  MOVLB  6
0AD0A:  CLRF   x97
.................... 
....................         if (adcVals[chX].homeFlag) home_axis(chX);
0AD0C:  MOVLB  1
0AD0E:  BTFSS  x3C.0
0AD10:  BRA    AD1E
0AD12:  MOVLB  6
0AD14:  CLRF   xFB
0AD16:  MOVLB  0
0AD18:  CALL   4CC0
0AD1C:  MOVLB  1
....................         if (adcVals[chY].homeFlag) home_axis(chY);
0AD1E:  BTFSS  x62.0
0AD20:  BRA    AD30
0AD22:  MOVLW  01
0AD24:  MOVLB  6
0AD26:  MOVWF  xFB
0AD28:  MOVLB  0
0AD2A:  CALL   4CC0
0AD2E:  MOVLB  1
....................                 
....................         internal_monitor_task();   //Update monitored voltage and currents etc
0AD30:  MOVLB  0
0AD32:  GOTO   503C
....................         sensor_monitor_task();     //get magnetoresistive sensor data
0AD36:  CALL   4B10
....................       
....................         if (controlCounter >= 2){
0AD3A:  MOVLB  6
0AD3C:  MOVF   x94,F
0AD3E:  BNZ   AD46
0AD40:  MOVF   x93,W
0AD42:  SUBLW  01
0AD44:  BC    AD54
....................             control_task();
0AD46:  MOVLB  0
0AD48:  GOTO   55E0
....................             controlCounter = 0;
0AD4C:  MOVLB  6
0AD4E:  CLRF   x94
0AD50:  CLRF   x93
....................         }else controlCounter++;
0AD52:  BRA    AD5A
0AD54:  INCF   x93,F
0AD56:  BTFSC  FD8.2
0AD58:  INCF   x94,F
....................       
....................         serial_task();             
0AD5A:  MOVLB  0
0AD5C:  GOTO   568E
....................       
....................         #ifdef DEBUG_1
....................         if (debugCounter >= 0){
....................             static int8 ch = 0;
....................             sprintf(pBuff+strlen(pBuff), "#D0,CNT,%u,%.0f,%.0f\n", ch+1, adcVals[ch].sinCounts, adcVals[ch].cosCounts);
0AD60:  MOVLW  06
0AD62:  MOVLB  7
0AD64:  MOVWF  x42
0AD66:  MOVLW  97
0AD68:  MOVWF  x41
0AD6A:  MOVLB  0
0AD6C:  CALL   5BA6
0AD70:  MOVF   01,W
0AD72:  ADDLW  97
0AD74:  MOVLB  6
0AD76:  MOVWF  xFB
0AD78:  MOVLW  06
0AD7A:  ADDWFC 02,W
0AD7C:  MOVWF  xFC
0AD7E:  MOVLW  01
0AD80:  ADDWF  x8F,W
0AD82:  MOVWF  xFD
0AD84:  MOVF   x8F,W
0AD86:  MULLW  26
0AD88:  MOVF   FF3,W
0AD8A:  CLRF   xFF
0AD8C:  MOVWF  xFE
0AD8E:  MOVLW  08
0AD90:  ADDWF  xFE,W
0AD92:  MOVWF  01
0AD94:  MOVLW  00
0AD96:  ADDWFC xFF,W
0AD98:  MOVWF  03
0AD9A:  MOVF   01,W
0AD9C:  ADDLW  17
0AD9E:  MOVWF  FE9
0ADA0:  MOVLW  01
0ADA2:  ADDWFC 03,W
0ADA4:  MOVWF  FEA
0ADA6:  MOVFF  FEF,6FE
0ADAA:  MOVFF  FEC,6FF
0ADAE:  MOVFF  FEC,700
0ADB2:  MOVFF  FEC,701
0ADB6:  MOVF   x8F,W
0ADB8:  MULLW  26
0ADBA:  MOVF   FF3,W
0ADBC:  MOVLB  7
0ADBE:  CLRF   x03
0ADC0:  MOVWF  x02
0ADC2:  MOVLW  0C
0ADC4:  ADDWF  x02,W
0ADC6:  MOVWF  01
0ADC8:  MOVLW  00
0ADCA:  ADDWFC x03,W
0ADCC:  MOVWF  03
0ADCE:  MOVF   01,W
0ADD0:  ADDLW  17
0ADD2:  MOVWF  FE9
0ADD4:  MOVLW  01
0ADD6:  ADDWFC 03,W
0ADD8:  MOVWF  FEA
0ADDA:  MOVFF  FEF,702
0ADDE:  MOVFF  FEC,703
0ADE2:  MOVFF  FEC,704
0ADE6:  MOVFF  FEC,705
0ADEA:  MOVFF  6FC,565
0ADEE:  MOVFF  6FB,564
0ADF2:  MOVLW  58
0ADF4:  MOVWF  FF6
0ADF6:  MOVLW  03
0ADF8:  MOVWF  FF7
0ADFA:  MOVLW  08
0ADFC:  MOVWF  x0F
0ADFE:  MOVLB  0
0AE00:  CALL   5BFE
0AE04:  MOVFF  6FD,706
0AE08:  MOVLW  1B
0AE0A:  MOVLB  7
0AE0C:  MOVWF  x07
0AE0E:  MOVLB  0
0AE10:  CALL   5C26
0AE14:  MOVLW  2C
0AE16:  MOVLB  7
0AE18:  MOVWF  x50
0AE1A:  MOVLB  0
0AE1C:  CALL   5BDE
0AE20:  MOVLW  89
0AE22:  MOVWF  FE9
0AE24:  MOVFF  701,746
0AE28:  MOVFF  700,745
0AE2C:  MOVFF  6FF,744
0AE30:  MOVFF  6FE,743
0AE34:  MOVLB  7
0AE36:  CLRF   x47
0AE38:  MOVLB  0
0AE3A:  CALL   5D7C
0AE3E:  MOVLW  2C
0AE40:  MOVLB  7
0AE42:  MOVWF  x50
0AE44:  MOVLB  0
0AE46:  CALL   5BDE
0AE4A:  MOVLW  89
0AE4C:  MOVWF  FE9
0AE4E:  MOVFF  705,746
0AE52:  MOVFF  704,745
0AE56:  MOVFF  703,744
0AE5A:  MOVFF  702,743
0AE5E:  MOVLB  7
0AE60:  CLRF   x47
0AE62:  MOVLB  0
0AE64:  CALL   5D7C
0AE68:  MOVLW  0A
0AE6A:  MOVLB  7
0AE6C:  MOVWF  x50
0AE6E:  MOVLB  0
0AE70:  CALL   5BDE
....................             sprintf(pBuff+strlen(pBuff), "#D0,POS,%u,%3.3f\n", ch+1, adcVals[ch].pReal);
0AE74:  MOVLW  06
0AE76:  MOVLB  7
0AE78:  MOVWF  x42
0AE7A:  MOVLW  97
0AE7C:  MOVWF  x41
0AE7E:  MOVLB  0
0AE80:  CALL   5BA6
0AE84:  MOVF   01,W
0AE86:  ADDLW  97
0AE88:  MOVLB  6
0AE8A:  MOVWF  xFB
0AE8C:  MOVLW  06
0AE8E:  ADDWFC 02,W
0AE90:  MOVWF  xFC
0AE92:  MOVLW  01
0AE94:  ADDWF  x8F,W
0AE96:  MOVWF  xFD
0AE98:  MOVF   x8F,W
0AE9A:  MULLW  26
0AE9C:  MOVF   FF3,W
0AE9E:  CLRF   xFF
0AEA0:  MOVWF  xFE
0AEA2:  MOVLW  1D
0AEA4:  ADDWF  xFE,W
0AEA6:  MOVWF  01
0AEA8:  MOVLW  00
0AEAA:  ADDWFC xFF,W
0AEAC:  MOVWF  03
0AEAE:  MOVF   01,W
0AEB0:  ADDLW  17
0AEB2:  MOVWF  FE9
0AEB4:  MOVLW  01
0AEB6:  ADDWFC 03,W
0AEB8:  MOVWF  FEA
0AEBA:  MOVFF  FEF,6FE
0AEBE:  MOVFF  FEC,6FF
0AEC2:  MOVFF  FEC,700
0AEC6:  MOVFF  FEC,701
0AECA:  MOVFF  6FC,565
0AECE:  MOVFF  6FB,564
0AED2:  MOVLW  6E
0AED4:  MOVWF  FF6
0AED6:  MOVLW  03
0AED8:  MOVWF  FF7
0AEDA:  MOVLW  08
0AEDC:  MOVLB  7
0AEDE:  MOVWF  x0F
0AEE0:  MOVLB  0
0AEE2:  CALL   5BFE
0AEE6:  MOVFF  6FD,706
0AEEA:  MOVLW  1B
0AEEC:  MOVLB  7
0AEEE:  MOVWF  x07
0AEF0:  MOVLB  0
0AEF2:  CALL   5C26
0AEF6:  MOVLW  2C
0AEF8:  MOVLB  7
0AEFA:  MOVWF  x50
0AEFC:  MOVLB  0
0AEFE:  CALL   5BDE
0AF02:  MOVLW  89
0AF04:  MOVWF  FE9
0AF06:  MOVFF  701,746
0AF0A:  MOVFF  700,745
0AF0E:  MOVFF  6FF,744
0AF12:  MOVFF  6FE,743
0AF16:  MOVLW  03
0AF18:  MOVLB  7
0AF1A:  MOVWF  x47
0AF1C:  MOVLB  0
0AF1E:  CALL   5D7C
0AF22:  MOVLW  0A
0AF24:  MOVLB  7
0AF26:  MOVWF  x50
0AF28:  MOVLB  0
0AF2A:  CALL   5BDE
....................             if ( dacVals[ch].invV ) sprintf(pBuff+strlen(pBuff), "#D0,OUT,%u,-,%Lu\n", ch+1, dacVals[ch].ipVal);
0AF2E:  MOVLB  6
0AF30:  MOVF   x8F,W
0AF32:  MULLW  07
0AF34:  MOVF   FF3,W
0AF36:  CLRF   xFC
0AF38:  MOVWF  xFB
0AF3A:  MOVLW  64
0AF3C:  ADDWF  xFB,W
0AF3E:  MOVWF  FE9
0AF40:  MOVLW  01
0AF42:  ADDWFC xFC,W
0AF44:  MOVWF  FEA
0AF46:  BTFSS  FEF.0
0AF48:  BRA    AFF8
0AF4A:  MOVLW  06
0AF4C:  MOVLB  7
0AF4E:  MOVWF  x42
0AF50:  MOVLW  97
0AF52:  MOVWF  x41
0AF54:  MOVLB  0
0AF56:  CALL   5BA6
0AF5A:  MOVF   01,W
0AF5C:  ADDLW  97
0AF5E:  MOVLB  6
0AF60:  MOVWF  xFB
0AF62:  MOVLW  06
0AF64:  ADDWFC 02,W
0AF66:  MOVWF  xFC
0AF68:  MOVLW  01
0AF6A:  ADDWF  x8F,W
0AF6C:  MOVWF  xFD
0AF6E:  MOVF   x8F,W
0AF70:  MULLW  07
0AF72:  MOVF   FF3,W
0AF74:  CLRF   xFF
0AF76:  MOVWF  xFE
0AF78:  MOVLW  01
0AF7A:  ADDWF  xFE,W
0AF7C:  MOVWF  01
0AF7E:  MOVLW  00
0AF80:  ADDWFC xFF,W
0AF82:  MOVWF  03
0AF84:  MOVF   01,W
0AF86:  ADDLW  64
0AF88:  MOVWF  FE9
0AF8A:  MOVLW  01
0AF8C:  ADDWFC 03,W
0AF8E:  MOVWF  FEA
0AF90:  MOVFF  FEC,6FF
0AF94:  MOVF   FED,F
0AF96:  MOVFF  FEF,6FE
0AF9A:  MOVFF  6FC,565
0AF9E:  MOVFF  6FB,564
0AFA2:  MOVLW  80
0AFA4:  MOVWF  FF6
0AFA6:  MOVLW  03
0AFA8:  MOVWF  FF7
0AFAA:  MOVLW  08
0AFAC:  MOVLB  7
0AFAE:  MOVWF  x0F
0AFB0:  MOVLB  0
0AFB2:  CALL   5BFE
0AFB6:  MOVFF  6FD,706
0AFBA:  MOVLW  1B
0AFBC:  MOVLB  7
0AFBE:  MOVWF  x07
0AFC0:  MOVLB  0
0AFC2:  CALL   5C26
0AFC6:  MOVLW  8A
0AFC8:  MOVWF  FF6
0AFCA:  MOVLW  03
0AFCC:  MOVWF  FF7
0AFCE:  MOVLW  03
0AFD0:  MOVLB  7
0AFD2:  MOVWF  x0F
0AFD4:  MOVLB  0
0AFD6:  CALL   5BFE
0AFDA:  MOVLW  10
0AFDC:  MOVWF  FE9
0AFDE:  MOVFF  6FF,701
0AFE2:  MOVFF  6FE,700
0AFE6:  CALL   5F24
0AFEA:  MOVLW  0A
0AFEC:  MOVLB  7
0AFEE:  MOVWF  x50
0AFF0:  MOVLB  0
0AFF2:  CALL   5BDE
0AFF6:  BRA    B0A4
....................             else                    sprintf(pBuff+strlen(pBuff), "#D0,OUT,%u,+,%Lu\n", ch+1, dacVals[ch].ipVal);
0AFF8:  MOVLW  06
0AFFA:  MOVLB  7
0AFFC:  MOVWF  x42
0AFFE:  MOVLW  97
0B000:  MOVWF  x41
0B002:  MOVLB  0
0B004:  CALL   5BA6
0B008:  MOVF   01,W
0B00A:  ADDLW  97
0B00C:  MOVLB  6
0B00E:  MOVWF  xFB
0B010:  MOVLW  06
0B012:  ADDWFC 02,W
0B014:  MOVWF  xFC
0B016:  MOVLW  01
0B018:  ADDWF  x8F,W
0B01A:  MOVWF  xFD
0B01C:  MOVF   x8F,W
0B01E:  MULLW  07
0B020:  MOVF   FF3,W
0B022:  CLRF   xFF
0B024:  MOVWF  xFE
0B026:  MOVLW  01
0B028:  ADDWF  xFE,W
0B02A:  MOVWF  01
0B02C:  MOVLW  00
0B02E:  ADDWFC xFF,W
0B030:  MOVWF  03
0B032:  MOVF   01,W
0B034:  ADDLW  64
0B036:  MOVWF  FE9
0B038:  MOVLW  01
0B03A:  ADDWFC 03,W
0B03C:  MOVWF  FEA
0B03E:  MOVFF  FEC,6FF
0B042:  MOVF   FED,F
0B044:  MOVFF  FEF,6FE
0B048:  MOVFF  6FC,565
0B04C:  MOVFF  6FB,564
0B050:  MOVLW  92
0B052:  MOVWF  FF6
0B054:  MOVLW  03
0B056:  MOVWF  FF7
0B058:  MOVLW  08
0B05A:  MOVLB  7
0B05C:  MOVWF  x0F
0B05E:  MOVLB  0
0B060:  CALL   5BFE
0B064:  MOVFF  6FD,706
0B068:  MOVLW  1B
0B06A:  MOVLB  7
0B06C:  MOVWF  x07
0B06E:  MOVLB  0
0B070:  CALL   5C26
0B074:  MOVLW  9C
0B076:  MOVWF  FF6
0B078:  MOVLW  03
0B07A:  MOVWF  FF7
0B07C:  MOVLW  03
0B07E:  MOVLB  7
0B080:  MOVWF  x0F
0B082:  MOVLB  0
0B084:  CALL   5BFE
0B088:  MOVLW  10
0B08A:  MOVWF  FE9
0B08C:  MOVFF  6FF,701
0B090:  MOVFF  6FE,700
0B094:  CALL   5F24
0B098:  MOVLW  0A
0B09A:  MOVLB  7
0B09C:  MOVWF  x50
0B09E:  MOVLB  0
0B0A0:  CALL   5BDE
....................             ch = !ch;
0B0A4:  MOVLB  6
0B0A6:  MOVF   x8F,F
0B0A8:  BTFSC  FD8.2
0B0AA:  BRA    B0B0
0B0AC:  MOVLW  00
0B0AE:  BRA    B0B2
0B0B0:  MOVLW  01
0B0B2:  MOVWF  x8F
....................             debugCounter = 0;
0B0B4:  CLRF   x96
0B0B6:  CLRF   x95
....................         }else debugCounter++;
.................... //!        serial_out(pBuff);
....................         fprintf(ICD_STREAM, "%s", pBuff);
0B0B8:  MOVLW  06
0B0BA:  MOVWF  FEA
0B0BC:  MOVLW  97
0B0BE:  MOVWF  FE9
0B0C0:  MOVLB  0
0B0C2:  GOTO   603E
....................         #endif
....................       
....................         command_handler_task();    //execute commands
0B0C6:  GOTO   A7B8
....................       
....................         delay_ms(loopDelay);
0B0CA:  MOVFF  692,6FB
0B0CE:  MOVLB  6
0B0D0:  INCF   xFB,F
0B0D2:  DECF   xFB,F
0B0D4:  BTFSC  FD8.2
0B0D6:  BRA    B0E6
0B0D8:  MOVLB  7
0B0DA:  SETF   x0F
0B0DC:  MOVLB  0
0B0DE:  CALL   03A4
0B0E2:  MOVLB  6
0B0E4:  BRA    B0D2
0B0E6:  MOVFF  691,70F
0B0EA:  MOVLB  0
0B0EC:  CALL   03A4
0B0F0:  BRA    AD08
....................     }
.................... }
0B0F2:  SLEEP 

Configuration Fuses:
   Word  1: FF8C   NOEXTOSC RSTOSC_HFINTRC_64MHZ NOCLKOUT CKS FCMEN
   Word  2: FFFD   MCLR PUT NOLPBOR BROWNOUT BORV19 ZCDDIS PPS1WAY STVREN NODEBUG NOXINST
   Word  3: FF9F   WDTSW NOWDT WDTWIN_SW WDTCLK_SW
   Word  4: DFFF   NOWRT NOWRTC NOWRTB NOWRTD SCANE NOLVP
   Word  5: FFFF   NOPROTECT NOCPD
   Word  6: FFFF   NOEBTR NOEBTRB
