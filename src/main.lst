CCS PCH C Compiler, Version 5.117, 2138               25-Nov-25 21:09

               Filename:   C:\Users\Aidan\Documents\GitHub\DiFCS-Controller\src\main.lst

               ROM used:   45442 bytes (69%)
                           Largest free fragment is 20092
               RAM used:   1645 (46%) at main() level
                           1751 (48%) worst case
               Stack used: 6 locations (4 in main + 2 for interrupts)
               Stack size: 30

*
00000:  NOP   
00002:  GOTO   AC08
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  MOVLB  E
00056:  BTFSS  xC0.5
00058:  GOTO   0062
0005C:  BTFSC  xC8.5
0005E:  GOTO   00E8
00062:  BTFSS  xC1.0
00064:  GOTO   006E
00068:  BTFSC  xC9.0
0006A:  GOTO   025A
0006E:  MOVFF  0E,00
00072:  MOVFF  0F,01
00076:  MOVFF  10,02
0007A:  MOVFF  11,03
0007E:  MOVFF  0C,FE9
00082:  MOVFF  07,FEA
00086:  BSF    07.7
00088:  MOVFF  08,FE1
0008C:  MOVFF  09,FE2
00090:  MOVFF  0A,FD9
00094:  MOVFF  0B,FDA
00098:  MOVFF  12,FF3
0009C:  MOVFF  13,FF4
000A0:  MOVFF  14,FFA
000A4:  MOVFF  15,FF5
000A8:  MOVFF  16,FF6
000AC:  MOVFF  17,FF7
000B0:  MOVF   04,W
000B2:  MOVFF  06,FE0
000B6:  MOVFF  05,FD8
000BA:  RETFIE 0
.................... #include <main.h>
.................... #include <18F46Q10.h>
.................... //////////// Standard Header file for the PIC18F46Q10 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F46Q10
000BC:  MOVFF  FEC,FFA
000C0:  MOVF   FED,F
000C2:  MOVFF  FEF,FE8
000C6:  MOVWF  FF9
000C8:  RETURN 0
*
0032E:  DATA 32,30
00330:  DATA 32,35
00332:  DATA 31,31
00334:  DATA 30,34
00336:  DATA 00,00
00338:  DATA 30,30
0033A:  DATA 30,30
0033C:  DATA 00,00
0033E:  DATA 25,64
00340:  DATA 2C,4D
00342:  DATA 41,4E
00344:  DATA 55,41
00346:  DATA 4C,2C
00348:  DATA 00,00
0034A:  DATA 25,64
0034C:  DATA 2C,4D
0034E:  DATA 41,47
00350:  DATA 53,4E
00352:  DATA 53,2C
00354:  DATA 00,00
00356:  DATA 23,44
00358:  DATA 30,2C
0035A:  DATA 43,4E
0035C:  DATA 54,2C
0035E:  DATA 25,75
00360:  DATA 2C,25
00362:  DATA 2E,30
00364:  DATA 66,2C
00366:  DATA 25,2E
00368:  DATA 30,66
0036A:  DATA 0A,00
0036C:  DATA 23,44
0036E:  DATA 30,2C
00370:  DATA 50,4F
00372:  DATA 53,2C
00374:  DATA 25,75
00376:  DATA 2C,25
00378:  DATA 33,2E
0037A:  DATA 33,66
0037C:  DATA 0A,00
0037E:  DATA 2D,2D
00380:  DATA 2D,2D
00382:  DATA 2D,2D
00384:  DATA 2D,2D
00386:  DATA 2D,2D
00388:  DATA 2D,2D
0038A:  DATA 2D,2D
0038C:  DATA 2D,0A
0038E:  DATA 00,00
*
006B6:  ADDWF  FE8,W
006B8:  CLRF   FF7
006BA:  RLCF   FF7,F
006BC:  ADDLW  D1
006BE:  MOVWF  FF6
006C0:  MOVLW  06
006C2:  ADDWFC FF7,F
006C4:  TBLRD*-
006C6:  MOVF   FF5,W
006C8:  MOVWF  FFA
006CA:  TBLRD*
006CC:  MOVF   FF5,W
006CE:  MOVWF  FF9
006D0:  DATA 80,06
006D2:  DATA 8A,06
006D4:  DATA 94,06
006D6:  DATA 9E,06
*
007F0:  MOVLB  6
007F2:  MOVF   xB0,W
007F4:  MULWF  xB2
007F6:  MOVFF  FF3,01
007FA:  MOVFF  FF4,00
007FE:  MULWF  xB3
00800:  MOVF   FF3,W
00802:  ADDWF  00,F
00804:  MOVF   xB1,W
00806:  MULWF  xB2
00808:  MOVF   FF3,W
0080A:  ADDWFC 00,W
0080C:  MOVWF  02
0080E:  MOVLB  0
00810:  RETURN 0
*
012C2:  MOVLW  8E
012C4:  MOVWF  00
012C6:  MOVFF  6B4,01
012CA:  MOVFF  6B3,02
012CE:  CLRF   03
012D0:  MOVF   01,F
012D2:  BNZ   12E6
012D4:  MOVFF  02,01
012D8:  CLRF   02
012DA:  MOVLW  08
012DC:  SUBWF  00,F
012DE:  MOVF   01,F
012E0:  BNZ   12E6
012E2:  CLRF   00
012E4:  BRA    12F6
012E6:  BCF    FD8.0
012E8:  BTFSC  01.7
012EA:  BRA    12F4
012EC:  RLCF   02,F
012EE:  RLCF   01,F
012F0:  DECF   00,F
012F2:  BRA    12E6
012F4:  BCF    01.7
012F6:  RETURN 0
012F8:  MOVLB  6
012FA:  MOVF   xB4,W
012FC:  BTFSC  FD8.2
012FE:  BRA    13E2
01300:  MOVWF  00
01302:  MOVF   xB8,W
01304:  BTFSC  FD8.2
01306:  BRA    13E2
01308:  ADDWF  00,F
0130A:  BNC   1314
0130C:  MOVLW  81
0130E:  ADDWF  00,F
01310:  BC    13E2
01312:  BRA    131C
01314:  MOVLW  7F
01316:  SUBWF  00,F
01318:  BNC   13E2
0131A:  BZ    13E2
0131C:  MOVFF  6B5,6BC
01320:  MOVF   xB9,W
01322:  XORWF  xBC,F
01324:  BSF    xB5.7
01326:  BSF    xB9.7
01328:  MOVF   xB7,W
0132A:  MULWF  xBB
0132C:  MOVFF  FF4,6BE
01330:  MOVF   xB6,W
01332:  MULWF  xBA
01334:  MOVFF  FF4,03
01338:  MOVFF  FF3,6BD
0133C:  MULWF  xBB
0133E:  MOVF   FF3,W
01340:  ADDWF  xBE,F
01342:  MOVF   FF4,W
01344:  ADDWFC xBD,F
01346:  MOVLW  00
01348:  ADDWFC 03,F
0134A:  MOVF   xB7,W
0134C:  MULWF  xBA
0134E:  MOVF   FF3,W
01350:  ADDWF  xBE,F
01352:  MOVF   FF4,W
01354:  ADDWFC xBD,F
01356:  MOVLW  00
01358:  CLRF   02
0135A:  ADDWFC 03,F
0135C:  ADDWFC 02,F
0135E:  MOVF   xB5,W
01360:  MULWF  xBB
01362:  MOVF   FF3,W
01364:  ADDWF  xBD,F
01366:  MOVF   FF4,W
01368:  ADDWFC 03,F
0136A:  MOVLW  00
0136C:  ADDWFC 02,F
0136E:  MOVF   xB5,W
01370:  MULWF  xBA
01372:  MOVF   FF3,W
01374:  ADDWF  03,F
01376:  MOVF   FF4,W
01378:  ADDWFC 02,F
0137A:  MOVLW  00
0137C:  CLRF   01
0137E:  ADDWFC 01,F
01380:  MOVF   xB7,W
01382:  MULWF  xB9
01384:  MOVF   FF3,W
01386:  ADDWF  xBD,F
01388:  MOVF   FF4,W
0138A:  ADDWFC 03,F
0138C:  MOVLW  00
0138E:  ADDWFC 02,F
01390:  ADDWFC 01,F
01392:  MOVF   xB6,W
01394:  MULWF  xB9
01396:  MOVF   FF3,W
01398:  ADDWF  03,F
0139A:  MOVF   FF4,W
0139C:  ADDWFC 02,F
0139E:  MOVLW  00
013A0:  ADDWFC 01,F
013A2:  MOVF   xB5,W
013A4:  MULWF  xB9
013A6:  MOVF   FF3,W
013A8:  ADDWF  02,F
013AA:  MOVF   FF4,W
013AC:  ADDWFC 01,F
013AE:  INCF   00,F
013B0:  BTFSC  01.7
013B2:  BRA    13BE
013B4:  RLCF   xBD,F
013B6:  RLCF   03,F
013B8:  RLCF   02,F
013BA:  RLCF   01,F
013BC:  DECF   00,F
013BE:  MOVLW  00
013C0:  BTFSS  xBD.7
013C2:  BRA    13D8
013C4:  INCF   03,F
013C6:  ADDWFC 02,F
013C8:  ADDWFC 01,F
013CA:  MOVF   01,W
013CC:  BNZ   13D8
013CE:  MOVF   02,W
013D0:  BNZ   13D8
013D2:  MOVF   03,W
013D4:  BNZ   13D8
013D6:  INCF   00,F
013D8:  BTFSC  xBC.7
013DA:  BSF    01.7
013DC:  BTFSS  xBC.7
013DE:  BCF    01.7
013E0:  BRA    13EA
013E2:  CLRF   00
013E4:  CLRF   01
013E6:  CLRF   02
013E8:  CLRF   03
013EA:  MOVLB  0
013EC:  RETURN 0
013EE:  MOVLW  80
013F0:  BTFSS  FD8.1
013F2:  BRA    13F8
013F4:  MOVLB  6
013F6:  XORWF  xB8,F
013F8:  MOVLB  6
013FA:  CLRF   xBD
013FC:  CLRF   xBE
013FE:  MOVFF  6B4,6BC
01402:  MOVF   xB8,W
01404:  XORWF  xBC,F
01406:  MOVF   xB3,W
01408:  BTFSC  FD8.2
0140A:  BRA    15CA
0140C:  MOVWF  xBB
0140E:  MOVWF  00
01410:  MOVF   xB7,W
01412:  BTFSC  FD8.2
01414:  BRA    15DC
01416:  SUBWF  xBB,F
01418:  BTFSC  FD8.2
0141A:  BRA    1522
0141C:  BNC   149A
0141E:  MOVFF  6B8,6C1
01422:  BSF    xC1.7
01424:  MOVFF  6B9,6C0
01428:  MOVFF  6BA,6BF
0142C:  CLRF   xBE
0142E:  BCF    FD8.0
01430:  RRCF   xC1,F
01432:  RRCF   xC0,F
01434:  RRCF   xBF,F
01436:  RRCF   xBE,F
01438:  DECFSZ xBB,F
0143A:  BRA    142C
0143C:  BTFSS  xBC.7
0143E:  BRA    1446
01440:  BSF    xBD.0
01442:  BRA    1604
01444:  BCF    xBD.0
01446:  BCF    xBB.0
01448:  BSF    xBD.4
0144A:  MOVLW  06
0144C:  MOVWF  FEA
0144E:  MOVLW  B6
01450:  MOVWF  FE9
01452:  BRA    162A
01454:  BCF    xBD.4
01456:  BTFSC  xBC.7
01458:  BRA    146E
0145A:  BTFSS  xBB.0
0145C:  BRA    1484
0145E:  RRCF   xC1,F
01460:  RRCF   xC0,F
01462:  RRCF   xBF,F
01464:  RRCF   xBE,F
01466:  INCF   00,F
01468:  BTFSC  FD8.2
0146A:  BRA    15FA
0146C:  BRA    1484
0146E:  BTFSC  xC1.7
01470:  BRA    148A
01472:  BCF    FD8.0
01474:  RLCF   xBE,F
01476:  RLCF   xBF,F
01478:  RLCF   xC0,F
0147A:  RLCF   xC1,F
0147C:  DECF   00,F
0147E:  BTFSC  FD8.2
01480:  BRA    15FA
01482:  BRA    146E
01484:  BSF    xBD.6
01486:  BRA    1562
01488:  BCF    xBD.6
0148A:  MOVFF  6B4,6BC
0148E:  BTFSS  xB4.7
01490:  BRA    1496
01492:  BSF    xC1.7
01494:  BRA    15EC
01496:  BCF    xC1.7
01498:  BRA    15EC
0149A:  MOVFF  6B7,6BB
0149E:  MOVFF  6B7,00
014A2:  MOVF   xB3,W
014A4:  SUBWF  xBB,F
014A6:  MOVFF  6B4,6C1
014AA:  BSF    xC1.7
014AC:  MOVFF  6B5,6C0
014B0:  MOVFF  6B6,6BF
014B4:  CLRF   xBE
014B6:  BCF    FD8.0
014B8:  RRCF   xC1,F
014BA:  RRCF   xC0,F
014BC:  RRCF   xBF,F
014BE:  RRCF   xBE,F
014C0:  DECFSZ xBB,F
014C2:  BRA    14B4
014C4:  BTFSS  xBC.7
014C6:  BRA    14CE
014C8:  BSF    xBD.1
014CA:  BRA    1604
014CC:  BCF    xBD.1
014CE:  BCF    xBB.0
014D0:  BSF    xBD.5
014D2:  MOVLW  06
014D4:  MOVWF  FEA
014D6:  MOVLW  BA
014D8:  MOVWF  FE9
014DA:  BRA    162A
014DC:  BCF    xBD.5
014DE:  BTFSC  xBC.7
014E0:  BRA    14F6
014E2:  BTFSS  xBB.0
014E4:  BRA    150C
014E6:  RRCF   xC1,F
014E8:  RRCF   xC0,F
014EA:  RRCF   xBF,F
014EC:  RRCF   xBE,F
014EE:  INCF   00,F
014F0:  BTFSC  FD8.2
014F2:  BRA    15FA
014F4:  BRA    150C
014F6:  BTFSC  xC1.7
014F8:  BRA    1512
014FA:  BCF    FD8.0
014FC:  RLCF   xBE,F
014FE:  RLCF   xBF,F
01500:  RLCF   xC0,F
01502:  RLCF   xC1,F
01504:  DECF   00,F
01506:  BTFSC  FD8.2
01508:  BRA    15FA
0150A:  BRA    14F6
0150C:  BSF    xBD.7
0150E:  BRA    1562
01510:  BCF    xBD.7
01512:  MOVFF  6B8,6BC
01516:  BTFSS  xB8.7
01518:  BRA    151E
0151A:  BSF    xC1.7
0151C:  BRA    15EC
0151E:  BCF    xC1.7
01520:  BRA    15EC
01522:  MOVFF  6B8,6C1
01526:  BSF    xC1.7
01528:  MOVFF  6B9,6C0
0152C:  MOVFF  6BA,6BF
01530:  BTFSS  xBC.7
01532:  BRA    153C
01534:  BCF    xC1.7
01536:  BSF    xBD.2
01538:  BRA    1604
0153A:  BCF    xBD.2
0153C:  CLRF   xBE
0153E:  BCF    xBB.0
01540:  MOVLW  06
01542:  MOVWF  FEA
01544:  MOVLW  B6
01546:  MOVWF  FE9
01548:  BRA    162A
0154A:  BTFSC  xBC.7
0154C:  BRA    1586
0154E:  MOVFF  6B4,6BC
01552:  BTFSS  xBB.0
01554:  BRA    1562
01556:  RRCF   xC1,F
01558:  RRCF   xC0,F
0155A:  RRCF   xBF,F
0155C:  RRCF   xBE,F
0155E:  INCF   00,F
01560:  BZ    15FA
01562:  BTFSS  xBE.7
01564:  BRA    157C
01566:  INCF   xBF,F
01568:  BNZ   157C
0156A:  INCF   xC0,F
0156C:  BNZ   157C
0156E:  INCF   xC1,F
01570:  BNZ   157C
01572:  RRCF   xC1,F
01574:  RRCF   xC0,F
01576:  RRCF   xBF,F
01578:  INCF   00,F
0157A:  BZ    15FA
0157C:  BTFSC  xBD.6
0157E:  BRA    1488
01580:  BTFSC  xBD.7
01582:  BRA    1510
01584:  BRA    15BE
01586:  MOVLW  80
01588:  XORWF  xC1,F
0158A:  BTFSS  xC1.7
0158C:  BRA    1596
0158E:  BRA    1604
01590:  MOVFF  6B8,6BC
01594:  BRA    15AA
01596:  MOVFF  6B4,6BC
0159A:  MOVF   xC1,F
0159C:  BNZ   15AA
0159E:  MOVF   xC0,F
015A0:  BNZ   15AA
015A2:  MOVF   xBF,F
015A4:  BNZ   15AA
015A6:  CLRF   00
015A8:  BRA    15EC
015AA:  BTFSC  xC1.7
015AC:  BRA    15BE
015AE:  BCF    FD8.0
015B0:  RLCF   xBE,F
015B2:  RLCF   xBF,F
015B4:  RLCF   xC0,F
015B6:  RLCF   xC1,F
015B8:  DECFSZ 00,F
015BA:  BRA    15AA
015BC:  BRA    15FA
015BE:  BTFSS  xBC.7
015C0:  BRA    15C6
015C2:  BSF    xC1.7
015C4:  BRA    15EC
015C6:  BCF    xC1.7
015C8:  BRA    15EC
015CA:  MOVFF  6B7,00
015CE:  MOVFF  6B8,6C1
015D2:  MOVFF  6B9,6C0
015D6:  MOVFF  6BA,6BF
015DA:  BRA    15EC
015DC:  MOVFF  6B3,00
015E0:  MOVFF  6B4,6C1
015E4:  MOVFF  6B5,6C0
015E8:  MOVFF  6B6,6BF
015EC:  MOVFF  6C1,01
015F0:  MOVFF  6C0,02
015F4:  MOVFF  6BF,03
015F8:  BRA    1662
015FA:  CLRF   00
015FC:  CLRF   01
015FE:  CLRF   02
01600:  CLRF   03
01602:  BRA    1662
01604:  CLRF   xBE
01606:  COMF   xBF,F
01608:  COMF   xC0,F
0160A:  COMF   xC1,F
0160C:  COMF   xBE,F
0160E:  INCF   xBE,F
01610:  BNZ   161C
01612:  INCF   xBF,F
01614:  BNZ   161C
01616:  INCF   xC0,F
01618:  BNZ   161C
0161A:  INCF   xC1,F
0161C:  BTFSC  xBD.0
0161E:  BRA    1444
01620:  BTFSC  xBD.1
01622:  BRA    14CC
01624:  BTFSC  xBD.2
01626:  BRA    153A
01628:  BRA    1590
0162A:  MOVF   FEF,W
0162C:  ADDWF  xBF,F
0162E:  BNC   163A
01630:  INCF   xC0,F
01632:  BNZ   163A
01634:  INCF   xC1,F
01636:  BTFSC  FD8.2
01638:  BSF    xBB.0
0163A:  MOVF   FED,F
0163C:  MOVF   FEF,W
0163E:  ADDWF  xC0,F
01640:  BNC   1648
01642:  INCF   xC1,F
01644:  BTFSC  FD8.2
01646:  BSF    xBB.0
01648:  MOVF   FED,F
0164A:  MOVF   FEF,W
0164C:  BTFSC  FEF.7
0164E:  BRA    1652
01650:  XORLW  80
01652:  ADDWF  xC1,F
01654:  BTFSC  FD8.0
01656:  BSF    xBB.0
01658:  BTFSC  xBD.4
0165A:  BRA    1454
0165C:  BTFSC  xBD.5
0165E:  BRA    14DC
01660:  BRA    154A
01662:  MOVLB  0
01664:  RETURN 0
*
01BBC:  ADDWF  FE8,W
01BBE:  CLRF   FF7
01BC0:  RLCF   FF7,F
01BC2:  ADDLW  D7
01BC4:  MOVWF  FF6
01BC6:  MOVLW  1B
01BC8:  ADDWFC FF7,F
01BCA:  TBLRD*-
01BCC:  MOVF   FF5,W
01BCE:  MOVWF  FFA
01BD0:  TBLRD*
01BD2:  MOVF   FF5,W
01BD4:  MOVWF  FF9
01BD6:  DATA 7E,16
01BD8:  DATA 3E,17
01BDA:  DATA FE,17
01BDC:  DATA BE,18
01BDE:  DATA 7E,19
01BE0:  DATA 3E,1A
01BE2:  DATA FE,1A
*
01D40:  BTFSC  FD8.1
01D42:  BRA    1D4C
01D44:  MOVLW  06
01D46:  MOVWF  FEA
01D48:  MOVLW  B3
01D4A:  MOVWF  FE9
01D4C:  MOVLB  6
01D4E:  MOVF   xAE,W
01D50:  XORWF  xB2,W
01D52:  ANDLW  80
01D54:  MOVWF  xB8
01D56:  BTFSS  xAE.7
01D58:  BRA    1D70
01D5A:  COMF   xAB,F
01D5C:  COMF   xAC,F
01D5E:  COMF   xAD,F
01D60:  COMF   xAE,F
01D62:  INCF   xAB,F
01D64:  BTFSC  FD8.2
01D66:  INCF   xAC,F
01D68:  BTFSC  FD8.2
01D6A:  INCF   xAD,F
01D6C:  BTFSC  FD8.2
01D6E:  INCF   xAE,F
01D70:  BTFSS  xB2.7
01D72:  BRA    1D8A
01D74:  COMF   xAF,F
01D76:  COMF   xB0,F
01D78:  COMF   xB1,F
01D7A:  COMF   xB2,F
01D7C:  INCF   xAF,F
01D7E:  BTFSC  FD8.2
01D80:  INCF   xB0,F
01D82:  BTFSC  FD8.2
01D84:  INCF   xB1,F
01D86:  BTFSC  FD8.2
01D88:  INCF   xB2,F
01D8A:  CLRF   00
01D8C:  CLRF   01
01D8E:  CLRF   02
01D90:  CLRF   03
01D92:  CLRF   xB3
01D94:  CLRF   xB4
01D96:  CLRF   xB5
01D98:  CLRF   xB6
01D9A:  MOVF   xB2,W
01D9C:  IORWF  xB1,W
01D9E:  IORWF  xB0,W
01DA0:  IORWF  xAF,W
01DA2:  BZ    1DFC
01DA4:  MOVLW  20
01DA6:  MOVWF  xB7
01DA8:  BCF    FD8.0
01DAA:  RLCF   xAB,F
01DAC:  RLCF   xAC,F
01DAE:  RLCF   xAD,F
01DB0:  RLCF   xAE,F
01DB2:  RLCF   xB3,F
01DB4:  RLCF   xB4,F
01DB6:  RLCF   xB5,F
01DB8:  RLCF   xB6,F
01DBA:  MOVF   xB2,W
01DBC:  SUBWF  xB6,W
01DBE:  BNZ   1DD0
01DC0:  MOVF   xB1,W
01DC2:  SUBWF  xB5,W
01DC4:  BNZ   1DD0
01DC6:  MOVF   xB0,W
01DC8:  SUBWF  xB4,W
01DCA:  BNZ   1DD0
01DCC:  MOVF   xAF,W
01DCE:  SUBWF  xB3,W
01DD0:  BNC   1DF0
01DD2:  MOVF   xAF,W
01DD4:  SUBWF  xB3,F
01DD6:  MOVF   xB0,W
01DD8:  BTFSS  FD8.0
01DDA:  INCFSZ xB0,W
01DDC:  SUBWF  xB4,F
01DDE:  MOVF   xB1,W
01DE0:  BTFSS  FD8.0
01DE2:  INCFSZ xB1,W
01DE4:  SUBWF  xB5,F
01DE6:  MOVF   xB2,W
01DE8:  BTFSS  FD8.0
01DEA:  INCFSZ xB2,W
01DEC:  SUBWF  xB6,F
01DEE:  BSF    FD8.0
01DF0:  RLCF   00,F
01DF2:  RLCF   01,F
01DF4:  RLCF   02,F
01DF6:  RLCF   03,F
01DF8:  DECFSZ xB7,F
01DFA:  BRA    1DA8
01DFC:  BTFSS  xB8.7
01DFE:  BRA    1E16
01E00:  COMF   00,F
01E02:  COMF   01,F
01E04:  COMF   02,F
01E06:  COMF   03,F
01E08:  INCF   00,F
01E0A:  BTFSC  FD8.2
01E0C:  INCF   01,F
01E0E:  BTFSC  FD8.2
01E10:  INCF   02,F
01E12:  BTFSC  FD8.2
01E14:  INCF   03,F
01E16:  MOVFF  6B3,FEF
01E1A:  MOVFF  6B4,FEC
01E1E:  MOVFF  6B5,FEC
01E22:  MOVFF  6B6,FEC
01E26:  MOVLB  0
01E28:  RETURN 0
*
0276A:  MOVLW  B6
0276C:  MOVWF  00
0276E:  CLRF   03
02770:  CLRF   02
02772:  CLRF   01
02774:  MOVLB  6
02776:  BCF    x7D.0
02778:  BTFSS  x7C.7
0277A:  BRA    2794
0277C:  BSF    x7D.0
0277E:  COMF   x79,F
02780:  COMF   x7A,F
02782:  COMF   x7B,F
02784:  COMF   x7C,F
02786:  INCF   x79,F
02788:  BNZ   2794
0278A:  INCF   x7A,F
0278C:  BNZ   2794
0278E:  INCF   x7B,F
02790:  BTFSC  FD8.2
02792:  INCF   x7C,F
02794:  MOVF   x79,W
02796:  IORWF  x7A,W
02798:  IORWF  x7B,W
0279A:  IORWF  x7C,W
0279C:  BNZ   27A2
0279E:  CLRF   00
027A0:  BRA    27C0
027A2:  BCF    FD8.0
027A4:  BTFSC  01.7
027A6:  BRA    27BA
027A8:  RLCF   x79,F
027AA:  RLCF   x7A,F
027AC:  RLCF   x7B,F
027AE:  RLCF   x7C,F
027B0:  RLCF   03,F
027B2:  RLCF   02,F
027B4:  RLCF   01,F
027B6:  DECFSZ 00,F
027B8:  BRA    27A2
027BA:  BCF    01.7
027BC:  BTFSC  x7D.0
027BE:  BSF    01.7
027C0:  MOVLB  0
027C2:  RETURN 0
027C4:  MOVFF  6B0,6B7
027C8:  MOVLB  6
027CA:  MOVF   xB4,W
027CC:  XORWF  xB7,F
027CE:  BTFSS  xB7.7
027D0:  BRA    27DC
027D2:  BCF    FD8.2
027D4:  BCF    FD8.0
027D6:  BTFSC  xB0.7
027D8:  BSF    FD8.0
027DA:  BRA    283A
027DC:  MOVFF  6B0,6B7
027E0:  MOVFF  6B3,6B8
027E4:  MOVF   xAF,W
027E6:  SUBWF  xB8,F
027E8:  BZ    27F6
027EA:  BTFSS  xB7.7
027EC:  BRA    283A
027EE:  MOVF   FD8,W
027F0:  XORLW  01
027F2:  MOVWF  FD8
027F4:  BRA    283A
027F6:  MOVFF  6B4,6B8
027FA:  MOVF   xB0,W
027FC:  SUBWF  xB8,F
027FE:  BZ    280C
02800:  BTFSS  xB7.7
02802:  BRA    283A
02804:  MOVF   FD8,W
02806:  XORLW  01
02808:  MOVWF  FD8
0280A:  BRA    283A
0280C:  MOVFF  6B5,6B8
02810:  MOVF   xB1,W
02812:  SUBWF  xB8,F
02814:  BZ    2822
02816:  BTFSS  xB7.7
02818:  BRA    283A
0281A:  MOVF   FD8,W
0281C:  XORLW  01
0281E:  MOVWF  FD8
02820:  BRA    283A
02822:  MOVFF  6B6,6B8
02826:  MOVF   xB2,W
02828:  SUBWF  xB8,F
0282A:  BZ    2838
0282C:  BTFSS  xB7.7
0282E:  BRA    283A
02830:  MOVF   FD8,W
02832:  XORLW  01
02834:  MOVWF  FD8
02836:  BRA    283A
02838:  BCF    FD8.0
0283A:  MOVLB  0
0283C:  RETURN 0
0283E:  MOVLB  6
02840:  MOVF   xA8,W
02842:  BTFSC  FD8.2
02844:  BRA    2990
02846:  MOVWF  xB4
02848:  MOVF   xAC,W
0284A:  BTFSC  FD8.2
0284C:  BRA    2990
0284E:  SUBWF  xB4,F
02850:  BNC   285C
02852:  MOVLW  7F
02854:  ADDWF  xB4,F
02856:  BTFSC  FD8.0
02858:  BRA    2990
0285A:  BRA    2868
0285C:  MOVLW  81
0285E:  SUBWF  xB4,F
02860:  BTFSS  FD8.0
02862:  BRA    2990
02864:  BTFSC  FD8.2
02866:  BRA    2990
02868:  MOVFF  6B4,00
0286C:  CLRF   01
0286E:  CLRF   02
02870:  CLRF   03
02872:  CLRF   xB3
02874:  MOVFF  6A9,6B2
02878:  BSF    xB2.7
0287A:  MOVFF  6AA,6B1
0287E:  MOVFF  6AB,6B0
02882:  MOVLW  19
02884:  MOVWF  xB4
02886:  MOVF   xAF,W
02888:  SUBWF  xB0,F
0288A:  BC    28A6
0288C:  MOVLW  01
0288E:  SUBWF  xB1,F
02890:  BC    28A6
02892:  SUBWF  xB2,F
02894:  BC    28A6
02896:  SUBWF  xB3,F
02898:  BC    28A6
0289A:  INCF   xB3,F
0289C:  INCF   xB2,F
0289E:  INCF   xB1,F
028A0:  MOVF   xAF,W
028A2:  ADDWF  xB0,F
028A4:  BRA    28F6
028A6:  MOVF   xAE,W
028A8:  SUBWF  xB1,F
028AA:  BC    28D0
028AC:  MOVLW  01
028AE:  SUBWF  xB2,F
028B0:  BC    28D0
028B2:  SUBWF  xB3,F
028B4:  BC    28D0
028B6:  INCF   xB3,F
028B8:  INCF   xB2,F
028BA:  MOVF   xAE,W
028BC:  ADDWF  xB1,F
028BE:  MOVF   xAF,W
028C0:  ADDWF  xB0,F
028C2:  BNC   28F6
028C4:  INCF   xB1,F
028C6:  BNZ   28F6
028C8:  INCF   xB2,F
028CA:  BNZ   28F6
028CC:  INCF   xB3,F
028CE:  BRA    28F6
028D0:  MOVF   xAD,W
028D2:  IORLW  80
028D4:  SUBWF  xB2,F
028D6:  BC    28F4
028D8:  MOVLW  01
028DA:  SUBWF  xB3,F
028DC:  BC    28F4
028DE:  INCF   xB3,F
028E0:  MOVF   xAD,W
028E2:  IORLW  80
028E4:  ADDWF  xB2,F
028E6:  MOVF   xAE,W
028E8:  ADDWF  xB1,F
028EA:  BNC   28BE
028EC:  INCF   xB2,F
028EE:  BNZ   28BE
028F0:  INCF   xB3,F
028F2:  BRA    28BE
028F4:  BSF    03.0
028F6:  DECFSZ xB4,F
028F8:  BRA    28FC
028FA:  BRA    2912
028FC:  BCF    FD8.0
028FE:  RLCF   xB0,F
02900:  RLCF   xB1,F
02902:  RLCF   xB2,F
02904:  RLCF   xB3,F
02906:  BCF    FD8.0
02908:  RLCF   03,F
0290A:  RLCF   02,F
0290C:  RLCF   01,F
0290E:  RLCF   xB5,F
02910:  BRA    2886
02912:  BTFSS  xB5.0
02914:  BRA    2922
02916:  BCF    FD8.0
02918:  RRCF   01,F
0291A:  RRCF   02,F
0291C:  RRCF   03,F
0291E:  RRCF   xB5,F
02920:  BRA    2926
02922:  DECF   00,F
02924:  BZ    2990
02926:  BTFSC  xB5.7
02928:  BRA    2966
0292A:  BCF    FD8.0
0292C:  RLCF   xB0,F
0292E:  RLCF   xB1,F
02930:  RLCF   xB2,F
02932:  RLCF   xB3,F
02934:  MOVF   xAF,W
02936:  SUBWF  xB0,F
02938:  BC    2948
0293A:  MOVLW  01
0293C:  SUBWF  xB1,F
0293E:  BC    2948
02940:  SUBWF  xB2,F
02942:  BC    2948
02944:  SUBWF  xB3,F
02946:  BNC   297C
02948:  MOVF   xAE,W
0294A:  SUBWF  xB1,F
0294C:  BC    2958
0294E:  MOVLW  01
02950:  SUBWF  xB2,F
02952:  BC    2958
02954:  SUBWF  xB3,F
02956:  BNC   297C
02958:  MOVF   xAD,W
0295A:  IORLW  80
0295C:  SUBWF  xB2,F
0295E:  BC    2966
02960:  MOVLW  01
02962:  SUBWF  xB3,F
02964:  BNC   297C
02966:  INCF   03,F
02968:  BNZ   297C
0296A:  INCF   02,F
0296C:  BNZ   297C
0296E:  INCF   01,F
02970:  BNZ   297C
02972:  INCF   00,F
02974:  BZ    2990
02976:  RRCF   01,F
02978:  RRCF   02,F
0297A:  RRCF   03,F
0297C:  MOVFF  6A9,6B4
02980:  MOVF   xAD,W
02982:  XORWF  xB4,F
02984:  BTFSS  xB4.7
02986:  BRA    298C
02988:  BSF    01.7
0298A:  BRA    2998
0298C:  BCF    01.7
0298E:  BRA    2998
02990:  CLRF   00
02992:  CLRF   01
02994:  CLRF   02
02996:  CLRF   03
02998:  MOVLB  0
0299A:  RETURN 0
*
03146:  ADDWF  FE8,W
03148:  CLRF   FF7
0314A:  RLCF   FF7,F
0314C:  ADDLW  61
0314E:  MOVWF  FF6
03150:  MOVLW  31
03152:  ADDWFC FF7,F
03154:  TBLRD*-
03156:  MOVF   FF5,W
03158:  MOVWF  FFA
0315A:  TBLRD*
0315C:  MOVF   FF5,W
0315E:  MOVWF  FF9
03160:  DATA 4E,30
03162:  DATA 68,30
03164:  DATA BC,30
03166:  DATA 20,31
03168:  MOVLW  8E
0316A:  MOVWF  00
0316C:  MOVFF  6A6,01
03170:  MOVFF  6A5,02
03174:  CLRF   03
03176:  BTFSS  01.7
03178:  BRA    3184
0317A:  COMF   01,F
0317C:  COMF   02,F
0317E:  INCF   02,F
03180:  BNZ   3184
03182:  INCF   01,F
03184:  MOVF   01,F
03186:  BNZ   319A
03188:  MOVFF  02,01
0318C:  CLRF   02
0318E:  MOVLW  08
03190:  SUBWF  00,F
03192:  MOVF   01,F
03194:  BNZ   319A
03196:  CLRF   00
03198:  BRA    31B6
0319A:  BCF    FD8.0
0319C:  BTFSC  01.7
0319E:  BRA    31A8
031A0:  RLCF   02,F
031A2:  RLCF   01,F
031A4:  DECF   00,F
031A6:  BRA    319A
031A8:  MOVLB  6
031AA:  BTFSS  xA6.7
031AC:  BRA    31B2
031AE:  MOVLB  0
031B0:  BRA    31B6
031B2:  BCF    01.7
031B4:  MOVLB  0
031B6:  RETURN 0
031B8:  MOVLW  8E
031BA:  MOVWF  00
031BC:  MOVLB  6
031BE:  MOVF   xAF,W
031C0:  SUBWF  00,F
031C2:  MOVFF  6B0,02
031C6:  MOVFF  6B1,01
031CA:  BSF    02.7
031CC:  MOVF   00,F
031CE:  BZ    31E2
031D0:  BCF    FD8.0
031D2:  MOVF   02,F
031D4:  BNZ   31DA
031D6:  MOVF   01,F
031D8:  BZ    31E2
031DA:  RRCF   02,F
031DC:  RRCF   01,F
031DE:  DECFSZ 00,F
031E0:  BRA    31D0
031E2:  BTFSS  xB0.7
031E4:  BRA    31F0
031E6:  COMF   01,F
031E8:  COMF   02,F
031EA:  INCF   01,F
031EC:  BTFSC  FD8.2
031EE:  INCF   02,F
031F0:  MOVLB  0
031F2:  RETURN 0
*
05030:  MOVLB  6
05032:  MOVF   x71,W
05034:  ANDLW  07
05036:  MOVWF  00
05038:  RRCF   x71,W
0503A:  MOVWF  01
0503C:  RRCF   01,F
0503E:  RRCF   01,F
05040:  MOVLW  1F
05042:  ANDWF  01,F
05044:  MOVF   01,W
05046:  ADDWF  x72,W
05048:  MOVWF  FE9
0504A:  MOVLW  00
0504C:  ADDWFC x73,W
0504E:  MOVWF  FEA
05050:  MOVFF  FEF,01
05054:  INCF   00,F
05056:  BRA    505A
05058:  RRCF   01,F
0505A:  DECFSZ 00,F
0505C:  BRA    5058
0505E:  MOVLW  01
05060:  ANDWF  01,F
05062:  MOVLB  0
05064:  RETURN 0
*
05A66:  MOVF   FEF,F
05A68:  BZ    5A88
05A6A:  MOVFF  FEA,66A
05A6E:  MOVFF  FE9,669
05A72:  MOVFF  FEF,67A
05A76:  RCALL  5A3E
05A78:  MOVFF  66A,FEA
05A7C:  MOVFF  669,FE9
05A80:  INCF   FE9,F
05A82:  BTFSC  FD8.2
05A84:  INCF   FEA,F
05A86:  BRA    5A66
05A88:  RETURN 0
*
05F82:  TBLRD*+
05F84:  MOVFF  FF6,66E
05F88:  MOVFF  FF7,66F
05F8C:  MOVFF  FF5,67A
05F90:  RCALL  5A3E
05F92:  MOVFF  66E,FF6
05F96:  MOVFF  66F,FF7
05F9A:  MOVLB  6
05F9C:  DECFSZ x6D,F
05F9E:  BRA    5FA2
05FA0:  BRA    5FA6
05FA2:  MOVLB  0
05FA4:  BRA    5F82
05FA6:  MOVLB  0
05FA8:  RETURN 0
05FAA:  MOVLB  6
05FAC:  MOVF   x9F,W
05FAE:  CLRF   01
05FB0:  SUBWF  x9E,W
05FB2:  BC    5FBA
05FB4:  MOVFF  69E,00
05FB8:  BRA    5FD2
05FBA:  CLRF   00
05FBC:  MOVLW  08
05FBE:  MOVWF  xA0
05FC0:  RLCF   x9E,F
05FC2:  RLCF   00,F
05FC4:  MOVF   x9F,W
05FC6:  SUBWF  00,W
05FC8:  BTFSC  FD8.0
05FCA:  MOVWF  00
05FCC:  RLCF   01,F
05FCE:  DECFSZ xA0,F
05FD0:  BRA    5FC0
05FD2:  MOVLB  0
05FD4:  RETURN 0
05FD6:  MOVF   01,W
05FD8:  MOVFF  66D,69E
05FDC:  MOVLW  64
05FDE:  MOVLB  6
05FE0:  MOVWF  x9F
05FE2:  MOVLB  0
05FE4:  RCALL  5FAA
05FE6:  MOVFF  00,66D
05FEA:  MOVF   01,W
05FEC:  MOVLW  30
05FEE:  BNZ   6000
05FF0:  MOVLB  6
05FF2:  BTFSS  x6E.1
05FF4:  BRA    6014
05FF6:  BTFSC  x6E.3
05FF8:  BRA    6014
05FFA:  BTFSC  x6E.4
05FFC:  MOVLW  20
05FFE:  BRA    6008
06000:  MOVLB  6
06002:  BCF    x6E.3
06004:  BCF    x6E.4
06006:  BSF    x6E.0
06008:  ADDWF  01,F
0600A:  MOVFF  01,67A
0600E:  MOVLB  0
06010:  RCALL  5A3E
06012:  MOVLB  6
06014:  MOVFF  66D,69E
06018:  MOVLW  0A
0601A:  MOVWF  x9F
0601C:  MOVLB  0
0601E:  RCALL  5FAA
06020:  MOVFF  00,66D
06024:  MOVF   01,W
06026:  MOVLW  30
06028:  BNZ   603A
0602A:  MOVLB  6
0602C:  BTFSC  x6E.3
0602E:  BRA    6044
06030:  BTFSS  x6E.0
06032:  BRA    6044
06034:  BTFSC  x6E.4
06036:  MOVLW  20
06038:  MOVLB  0
0603A:  ADDWF  01,F
0603C:  MOVFF  01,67A
06040:  RCALL  5A3E
06042:  MOVLB  6
06044:  MOVLW  30
06046:  ADDWF  x6D,F
06048:  MOVFF  66D,67A
0604C:  MOVLB  0
0604E:  RCALL  5A3E
06050:  RETURN 0
06052:  MOVLB  6
06054:  MOVF   xB4,W
06056:  SUBLW  B6
06058:  MOVWF  xB4
0605A:  CLRF   03
0605C:  MOVFF  6B5,6B8
06060:  BSF    xB5.7
06062:  BCF    FD8.0
06064:  RRCF   xB5,F
06066:  RRCF   xB6,F
06068:  RRCF   xB7,F
0606A:  RRCF   03,F
0606C:  RRCF   02,F
0606E:  RRCF   01,F
06070:  RRCF   00,F
06072:  DECFSZ xB4,F
06074:  BRA    6062
06076:  BTFSS  xB8.7
06078:  BRA    6090
0607A:  COMF   00,F
0607C:  COMF   01,F
0607E:  COMF   02,F
06080:  COMF   03,F
06082:  INCF   00,F
06084:  BTFSC  FD8.2
06086:  INCF   01,F
06088:  BTFSC  FD8.2
0608A:  INCF   02,F
0608C:  BTFSC  FD8.2
0608E:  INCF   03,F
06090:  MOVLB  0
06092:  RETURN 0
06094:  BTFSC  FD8.1
06096:  BRA    60A0
06098:  MOVLW  06
0609A:  MOVWF  FEA
0609C:  MOVLW  BC
0609E:  MOVWF  FE9
060A0:  CLRF   00
060A2:  CLRF   01
060A4:  CLRF   02
060A6:  CLRF   03
060A8:  MOVLB  6
060AA:  CLRF   xBC
060AC:  CLRF   xBD
060AE:  CLRF   xBE
060B0:  CLRF   xBF
060B2:  MOVF   xBB,W
060B4:  IORWF  xBA,W
060B6:  IORWF  xB9,W
060B8:  IORWF  xB8,W
060BA:  BZ    6114
060BC:  MOVLW  20
060BE:  MOVWF  xC0
060C0:  BCF    FD8.0
060C2:  RLCF   xB4,F
060C4:  RLCF   xB5,F
060C6:  RLCF   xB6,F
060C8:  RLCF   xB7,F
060CA:  RLCF   xBC,F
060CC:  RLCF   xBD,F
060CE:  RLCF   xBE,F
060D0:  RLCF   xBF,F
060D2:  MOVF   xBB,W
060D4:  SUBWF  xBF,W
060D6:  BNZ   60E8
060D8:  MOVF   xBA,W
060DA:  SUBWF  xBE,W
060DC:  BNZ   60E8
060DE:  MOVF   xB9,W
060E0:  SUBWF  xBD,W
060E2:  BNZ   60E8
060E4:  MOVF   xB8,W
060E6:  SUBWF  xBC,W
060E8:  BNC   6108
060EA:  MOVF   xB8,W
060EC:  SUBWF  xBC,F
060EE:  MOVF   xB9,W
060F0:  BTFSS  FD8.0
060F2:  INCFSZ xB9,W
060F4:  SUBWF  xBD,F
060F6:  MOVF   xBA,W
060F8:  BTFSS  FD8.0
060FA:  INCFSZ xBA,W
060FC:  SUBWF  xBE,F
060FE:  MOVF   xBB,W
06100:  BTFSS  FD8.0
06102:  INCFSZ xBB,W
06104:  SUBWF  xBF,F
06106:  BSF    FD8.0
06108:  RLCF   00,F
0610A:  RLCF   01,F
0610C:  RLCF   02,F
0610E:  RLCF   03,F
06110:  DECFSZ xC0,F
06112:  BRA    60C0
06114:  MOVFF  6BC,FEF
06118:  MOVFF  6BD,FEC
0611C:  MOVFF  6BE,FEC
06120:  MOVFF  6BF,FEC
06124:  MOVLB  0
06126:  RETURN 0
06128:  MOVF   FE9,W
0612A:  MOVLB  6
0612C:  MOVWF  x72
0612E:  MOVF   x71,W
06130:  MOVWF  x74
06132:  BZ    616C
06134:  MOVFF  670,6B7
06138:  MOVFF  66F,6B6
0613C:  MOVFF  66E,6B5
06140:  MOVFF  66D,6B4
06144:  CLRF   xBB
06146:  CLRF   xBA
06148:  MOVLW  20
0614A:  MOVWF  xB9
0614C:  MOVLW  82
0614E:  MOVWF  xB8
06150:  MOVLB  0
06152:  CALL   12F8
06156:  MOVFF  03,670
0615A:  MOVFF  02,66F
0615E:  MOVFF  01,66E
06162:  MOVFF  00,66D
06166:  MOVLB  6
06168:  DECFSZ x74,F
0616A:  BRA    6134
0616C:  MOVFF  670,6B7
06170:  MOVFF  66F,6B6
06174:  MOVFF  66E,6B5
06178:  MOVFF  66D,6B4
0617C:  MOVLB  0
0617E:  RCALL  6052
06180:  MOVFF  03,670
06184:  MOVFF  02,66F
06188:  MOVFF  01,66E
0618C:  MOVFF  00,66D
06190:  MOVLB  6
06192:  BTFSS  x70.7
06194:  BRA    61B0
06196:  DECF   x72,F
06198:  BSF    x72.5
0619A:  COMF   x6D,F
0619C:  COMF   x6E,F
0619E:  COMF   x6F,F
061A0:  COMF   x70,F
061A2:  INCF   x6D,F
061A4:  BTFSC  FD8.2
061A6:  INCF   x6E,F
061A8:  BTFSC  FD8.2
061AA:  INCF   x6F,F
061AC:  BTFSC  FD8.2
061AE:  INCF   x70,F
061B0:  MOVLW  3B
061B2:  MOVWF  x79
061B4:  MOVLW  9A
061B6:  MOVWF  x78
061B8:  MOVLW  CA
061BA:  MOVWF  x77
061BC:  CLRF   x76
061BE:  MOVLW  0A
061C0:  MOVWF  x74
061C2:  MOVF   x71,W
061C4:  BTFSC  FD8.2
061C6:  INCF   x72,F
061C8:  BSF    FD8.1
061CA:  MOVLW  06
061CC:  MOVWF  FEA
061CE:  MOVLW  6D
061D0:  MOVWF  FE9
061D2:  MOVFF  670,6B7
061D6:  MOVFF  66F,6B6
061DA:  MOVFF  66E,6B5
061DE:  MOVFF  66D,6B4
061E2:  MOVFF  679,6BB
061E6:  MOVFF  678,6BA
061EA:  MOVFF  677,6B9
061EE:  MOVFF  676,6B8
061F2:  MOVLB  0
061F4:  RCALL  6094
061F6:  MOVF   01,W
061F8:  MOVF   00,F
061FA:  BNZ   6222
061FC:  MOVLB  6
061FE:  INCF   x71,W
06200:  SUBWF  x74,W
06202:  BTFSS  FD8.2
06204:  BRA    620A
06206:  MOVLB  0
06208:  BRA    6222
0620A:  MOVF   x72,W
0620C:  BZ    6228
0620E:  ANDLW  0F
06210:  SUBWF  x74,W
06212:  BZ    6216
06214:  BC    629E
06216:  BTFSC  x72.7
06218:  BRA    629E
0621A:  BTFSC  x72.6
0621C:  BRA    6228
0621E:  MOVLW  20
06220:  BRA    6290
06222:  MOVLW  20
06224:  MOVLB  6
06226:  ANDWF  x72,F
06228:  BTFSS  x72.5
0622A:  BRA    624A
0622C:  BCF    x72.5
0622E:  MOVF   x71,W
06230:  BTFSS  FD8.2
06232:  DECF   x72,F
06234:  MOVF   00,W
06236:  MOVWF  x72
06238:  MOVLW  2D
0623A:  MOVWF  x7A
0623C:  MOVLB  0
0623E:  CALL   5A3E
06242:  MOVLB  6
06244:  MOVF   x72,W
06246:  MOVWF  00
06248:  CLRF   x72
0624A:  MOVF   x71,W
0624C:  SUBWF  x74,W
0624E:  BNZ   626A
06250:  MOVF   00,W
06252:  MOVWF  x72
06254:  MOVLW  2E
06256:  MOVWF  x7A
06258:  MOVLB  0
0625A:  CALL   5A3E
0625E:  MOVLB  6
06260:  MOVF   x72,W
06262:  MOVWF  00
06264:  MOVLW  20
06266:  ANDWF  x72,F
06268:  MOVLW  00
0626A:  MOVLW  30
0626C:  BTFSS  x72.5
0626E:  BRA    6290
06270:  BCF    x72.5
06272:  MOVF   x71,W
06274:  BTFSS  FD8.2
06276:  DECF   x72,F
06278:  MOVF   00,W
0627A:  MOVWF  x72
0627C:  MOVLW  2D
0627E:  MOVWF  x7A
06280:  MOVLB  0
06282:  CALL   5A3E
06286:  MOVLB  6
06288:  MOVF   x72,W
0628A:  MOVWF  00
0628C:  CLRF   x72
0628E:  MOVLW  30
06290:  ADDWF  00,F
06292:  MOVFF  00,67A
06296:  MOVLB  0
06298:  CALL   5A3E
0629C:  MOVLB  6
0629E:  BCF    FD8.1
062A0:  MOVFF  679,6B7
062A4:  MOVFF  678,6B6
062A8:  MOVFF  677,6B5
062AC:  MOVFF  676,6B4
062B0:  CLRF   xBB
062B2:  CLRF   xBA
062B4:  CLRF   xB9
062B6:  MOVLW  0A
062B8:  MOVWF  xB8
062BA:  MOVLB  0
062BC:  RCALL  6094
062BE:  MOVFF  03,679
062C2:  MOVFF  02,678
062C6:  MOVFF  01,677
062CA:  MOVFF  00,676
062CE:  MOVLB  6
062D0:  DECFSZ x74,F
062D2:  BRA    61C8
062D4:  MOVLB  0
062D6:  RETURN 0
062D8:  TBLRD*+
062DA:  MOVF   FF5,F
062DC:  BZ    62F8
062DE:  MOVFF  FF6,664
062E2:  MOVFF  FF7,665
062E6:  MOVFF  FF5,67A
062EA:  CALL   5A3E
062EE:  MOVFF  664,FF6
062F2:  MOVFF  665,FF7
062F6:  BRA    62D8
062F8:  GOTO   B172 (RETURN)
*
06440:  MOVFF  557,FEA
06444:  MOVFF  556,FE9
06448:  MOVFF  6B4,FEF
0644C:  INCF   FE9,F
0644E:  BTFSC  FD8.2
06450:  INCF   FEA,F
06452:  CLRF   FEF
06454:  MOVLB  5
06456:  INCF   x56,F
06458:  BTFSC  FD8.2
0645A:  INCF   x57,F
0645C:  MOVLB  0
0645E:  RETURN 0
06460:  TBLRD*+
06462:  MOVF   FF5,F
06464:  BZ    647E
06466:  MOVFF  FF6,672
0646A:  MOVFF  FF7,673
0646E:  MOVFF  FF5,6B4
06472:  RCALL  6440
06474:  MOVFF  672,FF6
06478:  MOVFF  673,FF7
0647C:  BRA    6460
0647E:  RETURN 0
*
065A2:  MOVLB  6
065A4:  MOVF   xCC,W
065A6:  XORWF  xCE,W
065A8:  ANDLW  80
065AA:  MOVWF  xD0
065AC:  BTFSS  xCC.7
065AE:  BRA    65BA
065B0:  COMF   xCB,F
065B2:  COMF   xCC,F
065B4:  INCF   xCB,F
065B6:  BTFSC  FD8.2
065B8:  INCF   xCC,F
065BA:  BTFSS  xCE.7
065BC:  BRA    65C8
065BE:  COMF   xCD,F
065C0:  COMF   xCE,F
065C2:  INCF   xCD,F
065C4:  BTFSC  FD8.2
065C6:  INCF   xCE,F
065C8:  MOVF   xCB,W
065CA:  MULWF  xCD
065CC:  MOVFF  FF3,01
065D0:  MOVFF  FF4,00
065D4:  MULWF  xCE
065D6:  MOVF   FF3,W
065D8:  ADDWF  00,F
065DA:  MOVF   xCC,W
065DC:  MULWF  xCD
065DE:  MOVF   FF3,W
065E0:  ADDWFC 00,W
065E2:  MOVWF  02
065E4:  BTFSS  xD0.7
065E6:  BRA    65F2
065E8:  COMF   01,F
065EA:  COMF   02,F
065EC:  INCF   01,F
065EE:  BTFSC  FD8.2
065F0:  INCF   02,F
065F2:  MOVLB  0
065F4:  GOTO   6888 (RETURN)
*
0694C:  MOVLW  20
0694E:  MOVLB  6
06950:  BTFSS  x99.4
06952:  MOVLW  30
06954:  MOVWF  x9A
06956:  MOVFF  698,00
0695A:  BTFSS  00.7
0695C:  BRA    696E
0695E:  COMF   00,F
06960:  INCF   00,F
06962:  MOVFF  00,698
06966:  MOVLW  2D
06968:  MOVWF  x9A
0696A:  BSF    x99.7
0696C:  BSF    x99.0
0696E:  MOVF   01,W
06970:  MOVFF  698,69E
06974:  MOVLW  64
06976:  MOVWF  x9F
06978:  MOVLB  0
0697A:  CALL   5FAA
0697E:  MOVFF  00,698
06982:  MOVLW  30
06984:  ADDWF  01,W
06986:  MOVLB  6
06988:  MOVWF  x9B
0698A:  MOVFF  698,69E
0698E:  MOVLW  0A
06990:  MOVWF  x9F
06992:  MOVLB  0
06994:  CALL   5FAA
06998:  MOVLW  30
0699A:  ADDWF  00,W
0699C:  MOVLB  6
0699E:  MOVWF  x9D
069A0:  MOVLW  30
069A2:  ADDWF  01,W
069A4:  MOVWF  x9C
069A6:  MOVFF  69A,00
069AA:  MOVLW  30
069AC:  SUBWF  x9B,W
069AE:  BZ    69B8
069B0:  BSF    x99.1
069B2:  BTFSC  x99.7
069B4:  BSF    x99.2
069B6:  BRA    69DC
069B8:  MOVFF  69A,69B
069BC:  MOVLW  20
069BE:  MOVWF  x9A
069C0:  MOVLW  30
069C2:  SUBWF  x9C,W
069C4:  BZ    69CE
069C6:  BSF    x99.0
069C8:  BTFSC  x99.7
069CA:  BSF    x99.1
069CC:  BRA    69DC
069CE:  BTFSS  FD8.2
069D0:  BSF    x99.0
069D2:  BNZ   69DC
069D4:  MOVFF  69B,69C
069D8:  MOVLW  20
069DA:  MOVWF  x9B
069DC:  BTFSC  x99.2
069DE:  BRA    69EA
069E0:  BTFSC  x99.1
069E2:  BRA    69F2
069E4:  BTFSC  x99.0
069E6:  BRA    69FA
069E8:  BRA    6A02
069EA:  MOVFF  69A,6B4
069EE:  MOVLB  0
069F0:  RCALL  6440
069F2:  MOVFF  69B,6B4
069F6:  MOVLB  0
069F8:  RCALL  6440
069FA:  MOVFF  69C,6B4
069FE:  MOVLB  0
06A00:  RCALL  6440
06A02:  MOVFF  69D,6B4
06A06:  MOVLB  0
06A08:  RCALL  6440
06A0A:  RETURN 0
*
06BA8:  MOVLB  6
06BAA:  MOVF   x86,W
06BAC:  ANDLW  07
06BAE:  MOVWF  00
06BB0:  RRCF   x86,W
06BB2:  MOVWF  01
06BB4:  RRCF   01,F
06BB6:  RRCF   01,F
06BB8:  MOVLW  1F
06BBA:  ANDWF  01,F
06BBC:  MOVF   01,W
06BBE:  ADDWF  x88,W
06BC0:  MOVWF  FE9
06BC2:  MOVLW  00
06BC4:  ADDWFC x89,W
06BC6:  MOVWF  FEA
06BC8:  CLRF   01
06BCA:  INCF   01,F
06BCC:  INCF   00,F
06BCE:  BRA    6BD2
06BD0:  RLCF   01,F
06BD2:  DECFSZ 00,F
06BD4:  BRA    6BD0
06BD6:  MOVF   x87,F
06BD8:  BZ    6BE0
06BDA:  MOVF   01,W
06BDC:  IORWF  FEF,F
06BDE:  BRA    6BE6
06BE0:  COMF   01,F
06BE2:  MOVF   01,W
06BE4:  ANDWF  FEF,F
06BE6:  MOVLB  0
06BE8:  RETURN 0
*
06D98:  TBLRD*+
06D9A:  MOVFF  FF6,674
06D9E:  MOVFF  FF7,675
06DA2:  MOVFF  FF5,6B4
06DA6:  CALL   6440
06DAA:  MOVFF  674,FF6
06DAE:  MOVFF  675,FF7
06DB2:  MOVLB  6
06DB4:  DECFSZ x73,F
06DB6:  BRA    6DBA
06DB8:  BRA    6DBE
06DBA:  MOVLB  0
06DBC:  BRA    6D98
06DBE:  MOVLB  0
06DC0:  RETURN 0
*
07168:  MOVF   FE9,W
0716A:  MOVLB  6
0716C:  MOVWF  xAC
0716E:  MOVF   xAB,W
07170:  MOVWF  xAE
07172:  BZ    71AC
07174:  MOVFF  6AA,6B7
07178:  MOVFF  6A9,6B6
0717C:  MOVFF  6A8,6B5
07180:  MOVFF  6A7,6B4
07184:  CLRF   xBB
07186:  CLRF   xBA
07188:  MOVLW  20
0718A:  MOVWF  xB9
0718C:  MOVLW  82
0718E:  MOVWF  xB8
07190:  MOVLB  0
07192:  CALL   12F8
07196:  MOVFF  03,6AA
0719A:  MOVFF  02,6A9
0719E:  MOVFF  01,6A8
071A2:  MOVFF  00,6A7
071A6:  MOVLB  6
071A8:  DECFSZ xAE,F
071AA:  BRA    7174
071AC:  MOVFF  6AA,6B7
071B0:  MOVFF  6A9,6B6
071B4:  MOVFF  6A8,6B5
071B8:  MOVFF  6A7,6B4
071BC:  MOVLB  0
071BE:  CALL   6052
071C2:  MOVFF  03,6AA
071C6:  MOVFF  02,6A9
071CA:  MOVFF  01,6A8
071CE:  MOVFF  00,6A7
071D2:  MOVLB  6
071D4:  BTFSS  xAA.7
071D6:  BRA    71F2
071D8:  DECF   xAC,F
071DA:  BSF    xAC.5
071DC:  COMF   xA7,F
071DE:  COMF   xA8,F
071E0:  COMF   xA9,F
071E2:  COMF   xAA,F
071E4:  INCF   xA7,F
071E6:  BTFSC  FD8.2
071E8:  INCF   xA8,F
071EA:  BTFSC  FD8.2
071EC:  INCF   xA9,F
071EE:  BTFSC  FD8.2
071F0:  INCF   xAA,F
071F2:  MOVLW  3B
071F4:  MOVWF  xB3
071F6:  MOVLW  9A
071F8:  MOVWF  xB2
071FA:  MOVLW  CA
071FC:  MOVWF  xB1
071FE:  CLRF   xB0
07200:  MOVLW  0A
07202:  MOVWF  xAE
07204:  MOVF   xAB,W
07206:  BTFSC  FD8.2
07208:  INCF   xAC,F
0720A:  BSF    FD8.1
0720C:  MOVLW  06
0720E:  MOVWF  FEA
07210:  MOVLW  A7
07212:  MOVWF  FE9
07214:  MOVFF  6AA,6B7
07218:  MOVFF  6A9,6B6
0721C:  MOVFF  6A8,6B5
07220:  MOVFF  6A7,6B4
07224:  MOVFF  6B3,6BB
07228:  MOVFF  6B2,6BA
0722C:  MOVFF  6B1,6B9
07230:  MOVFF  6B0,6B8
07234:  MOVLB  0
07236:  CALL   6094
0723A:  MOVF   01,W
0723C:  MOVF   00,F
0723E:  BNZ   7266
07240:  MOVLB  6
07242:  INCF   xAB,W
07244:  SUBWF  xAE,W
07246:  BTFSS  FD8.2
07248:  BRA    724E
0724A:  MOVLB  0
0724C:  BRA    7266
0724E:  MOVF   xAC,W
07250:  BZ    726C
07252:  ANDLW  0F
07254:  SUBWF  xAE,W
07256:  BZ    725A
07258:  BC    72E2
0725A:  BTFSC  xAC.7
0725C:  BRA    72E2
0725E:  BTFSC  xAC.6
07260:  BRA    726C
07262:  MOVLW  20
07264:  BRA    72D4
07266:  MOVLW  20
07268:  MOVLB  6
0726A:  ANDWF  xAC,F
0726C:  BTFSS  xAC.5
0726E:  BRA    728E
07270:  BCF    xAC.5
07272:  MOVF   xAB,W
07274:  BTFSS  FD8.2
07276:  DECF   xAC,F
07278:  MOVF   00,W
0727A:  MOVWF  xAC
0727C:  MOVLW  2D
0727E:  MOVWF  xB4
07280:  MOVLB  0
07282:  CALL   6440
07286:  MOVLB  6
07288:  MOVF   xAC,W
0728A:  MOVWF  00
0728C:  CLRF   xAC
0728E:  MOVF   xAB,W
07290:  SUBWF  xAE,W
07292:  BNZ   72AE
07294:  MOVF   00,W
07296:  MOVWF  xAC
07298:  MOVLW  2E
0729A:  MOVWF  xB4
0729C:  MOVLB  0
0729E:  CALL   6440
072A2:  MOVLB  6
072A4:  MOVF   xAC,W
072A6:  MOVWF  00
072A8:  MOVLW  20
072AA:  ANDWF  xAC,F
072AC:  MOVLW  00
072AE:  MOVLW  30
072B0:  BTFSS  xAC.5
072B2:  BRA    72D4
072B4:  BCF    xAC.5
072B6:  MOVF   xAB,W
072B8:  BTFSS  FD8.2
072BA:  DECF   xAC,F
072BC:  MOVF   00,W
072BE:  MOVWF  xAC
072C0:  MOVLW  2D
072C2:  MOVWF  xB4
072C4:  MOVLB  0
072C6:  CALL   6440
072CA:  MOVLB  6
072CC:  MOVF   xAC,W
072CE:  MOVWF  00
072D0:  CLRF   xAC
072D2:  MOVLW  30
072D4:  ADDWF  00,F
072D6:  MOVFF  00,6B4
072DA:  MOVLB  0
072DC:  CALL   6440
072E0:  MOVLB  6
072E2:  BCF    FD8.1
072E4:  MOVFF  6B3,6B7
072E8:  MOVFF  6B2,6B6
072EC:  MOVFF  6B1,6B5
072F0:  MOVFF  6B0,6B4
072F4:  CLRF   xBB
072F6:  CLRF   xBA
072F8:  CLRF   xB9
072FA:  MOVLW  0A
072FC:  MOVWF  xB8
072FE:  MOVLB  0
07300:  CALL   6094
07304:  MOVFF  03,6B3
07308:  MOVFF  02,6B2
0730C:  MOVFF  01,6B1
07310:  MOVFF  00,6B0
07314:  MOVLB  6
07316:  DECFSZ xAE,F
07318:  BRA    720A
0731A:  MOVLB  0
0731C:  RETURN 0
*
09D86:  MOVF   FE9,W
09D88:  MOVLB  6
09D8A:  MOVWF  xA1
09D8C:  BTFSS  xA0.7
09D8E:  BRA    9DAA
09D90:  DECF   xA1,F
09D92:  BSF    xA1.5
09D94:  COMF   x9D,F
09D96:  COMF   x9E,F
09D98:  COMF   x9F,F
09D9A:  COMF   xA0,F
09D9C:  INCF   x9D,F
09D9E:  BTFSC  FD8.2
09DA0:  INCF   x9E,F
09DA2:  BTFSC  FD8.2
09DA4:  INCF   x9F,F
09DA6:  BTFSC  FD8.2
09DA8:  INCF   xA0,F
09DAA:  MOVLW  3B
09DAC:  MOVWF  xA8
09DAE:  MOVLW  9A
09DB0:  MOVWF  xA7
09DB2:  MOVLW  CA
09DB4:  MOVWF  xA6
09DB6:  CLRF   xA5
09DB8:  MOVLW  0A
09DBA:  MOVWF  xA3
09DBC:  BSF    FD8.1
09DBE:  MOVLW  06
09DC0:  MOVWF  FEA
09DC2:  MOVLW  9D
09DC4:  MOVWF  FE9
09DC6:  MOVFF  6A0,6B7
09DCA:  MOVFF  69F,6B6
09DCE:  MOVFF  69E,6B5
09DD2:  MOVFF  69D,6B4
09DD6:  MOVFF  6A8,6BB
09DDA:  MOVFF  6A7,6BA
09DDE:  MOVFF  6A6,6B9
09DE2:  MOVFF  6A5,6B8
09DE6:  MOVLB  0
09DE8:  CALL   6094
09DEC:  MOVF   01,W
09DEE:  MOVF   00,F
09DF0:  BNZ   9E18
09DF2:  MOVLB  6
09DF4:  MOVF   xA3,W
09DF6:  XORLW  01
09DF8:  BTFSS  FD8.2
09DFA:  BRA    9E00
09DFC:  MOVLB  0
09DFE:  BRA    9E18
09E00:  MOVF   xA1,W
09E02:  BZ    9E1E
09E04:  ANDLW  0F
09E06:  SUBWF  xA3,W
09E08:  BZ    9E0C
09E0A:  BC    9E68
09E0C:  BTFSC  xA1.7
09E0E:  BRA    9E68
09E10:  BTFSC  xA1.6
09E12:  BRA    9E1E
09E14:  MOVLW  20
09E16:  BRA    9E5A
09E18:  MOVLW  20
09E1A:  MOVLB  6
09E1C:  ANDWF  xA1,F
09E1E:  BTFSS  xA1.5
09E20:  BRA    9E3A
09E22:  BCF    xA1.5
09E24:  MOVFF  00,6A1
09E28:  MOVLW  2D
09E2A:  MOVWF  xB4
09E2C:  MOVLB  0
09E2E:  CALL   6440
09E32:  MOVLB  6
09E34:  MOVFF  6A1,00
09E38:  CLRF   xA1
09E3A:  MOVLW  30
09E3C:  BTFSS  xA1.5
09E3E:  BRA    9E5A
09E40:  BCF    xA1.5
09E42:  MOVFF  00,6A1
09E46:  MOVLW  2D
09E48:  MOVWF  xB4
09E4A:  MOVLB  0
09E4C:  CALL   6440
09E50:  MOVLB  6
09E52:  MOVFF  6A1,00
09E56:  CLRF   xA1
09E58:  MOVLW  30
09E5A:  ADDWF  00,F
09E5C:  MOVFF  00,6B4
09E60:  MOVLB  0
09E62:  CALL   6440
09E66:  MOVLB  6
09E68:  BCF    FD8.1
09E6A:  MOVFF  6A8,6B7
09E6E:  MOVFF  6A7,6B6
09E72:  MOVFF  6A6,6B5
09E76:  MOVFF  6A5,6B4
09E7A:  CLRF   xBB
09E7C:  CLRF   xBA
09E7E:  CLRF   xB9
09E80:  MOVLW  0A
09E82:  MOVWF  xB8
09E84:  MOVLB  0
09E86:  CALL   6094
09E8A:  MOVFF  03,6A8
09E8E:  MOVFF  02,6A7
09E92:  MOVFF  01,6A6
09E96:  MOVFF  00,6A5
09E9A:  MOVLB  6
09E9C:  DECFSZ xA3,F
09E9E:  BRA    9DBC
09EA0:  MOVLB  0
09EA2:  RETURN 0
*
0AAE6:  MOVF   FEF,F
0AAE8:  BZ    AB0A
0AAEA:  MOVFF  FEA,66A
0AAEE:  MOVFF  FE9,669
0AAF2:  MOVFF  FEF,6B4
0AAF6:  CALL   6440
0AAFA:  MOVFF  66A,FEA
0AAFE:  MOVFF  669,FE9
0AB02:  INCF   FE9,F
0AB04:  BTFSC  FD8.2
0AB06:  INCF   FEA,F
0AB08:  BRA    AAE6
0AB0A:  GOTO   AB88 (RETURN)
.................... 
.................... #list
.................... 
.................... 
.................... #device ADC=10
.................... 
.................... //!#FUSES WDT                      //Watch Dog Timer
.................... //!#FUSES WDT4096                  //Watch Dog Timer uses 1:4096 Postscale
.................... 
.................... #use delay(internal=64000000)
*
00426:  MOVLW  06
00428:  MOVWF  FEA
0042A:  MOVLW  6C
0042C:  MOVWF  FE9
0042E:  MOVF   FEF,W
00430:  BZ    044E
00432:  MOVLW  14
00434:  MOVWF  01
00436:  CLRF   00
00438:  DECFSZ 00,F
0043A:  BRA    0438
0043C:  DECFSZ 01,F
0043E:  BRA    0436
00440:  MOVLW  BF
00442:  MOVWF  00
00444:  DECFSZ 00,F
00446:  BRA    0444
00448:  BRA    044A
0044A:  DECFSZ FEF,F
0044C:  BRA    0432
0044E:  RETURN 0
*
006EE:  MOVLW  01
006F0:  MOVLB  6
006F2:  SUBWF  x71,F
006F4:  BNC   070E
006F6:  MOVLW  06
006F8:  MOVWF  FEA
006FA:  MOVLW  71
006FC:  MOVWF  FE9
006FE:  MOVF   FEF,W
00700:  BZ    070E
00702:  MOVLW  04
00704:  MOVWF  00
00706:  DECFSZ 00,F
00708:  BRA    0706
0070A:  DECFSZ FEF,F
0070C:  BRA    0702
0070E:  MOVLB  0
00710:  GOTO   0756 (RETURN)
.................... #define baudRate 128000
.................... #define numChannels 2
.................... 
.................... #define version  "20251104" // SW Version
.................... #define serialID "0000"     // Unique Serial ID
.................... #define magPP 1             // Magnetoresistive Sensor Pole Pitch in mm   
.................... #define gainLvl 16          // 1, 2, 4, 8, 16, 32, 64, 128
.................... 
.................... 
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
*
00390:  MOVLW  CF
00392:  MOVWF  F87
00394:  CLRF   F82
....................    output_b(portB_reset);
00396:  MOVLW  C4
00398:  MOVWF  F88
0039A:  CLRF   F83
....................    output_c(portC_reset);
0039C:  MOVLW  93
0039E:  MOVWF  F89
003A0:  CLRF   F84
....................    output_d(portD_reset);
003A2:  MOVLW  1F
003A4:  MOVWF  F8A
003A6:  CLRF   F85
....................    output_e(portE_reset);
003A8:  BCF    F8B.0
003AA:  BCF    F8B.1
003AC:  BCF    F8B.2
003AE:  BCF    F8B.3
003B0:  CLRF   F86
....................    
....................    port_a_pullups(portA_pullups);
003B2:  MOVLB  F
003B4:  SETF   x0B
....................    port_b_pullups(portB_pullups);
003B6:  CLRF   x13
....................    port_c_pullups(portC_pullups);
003B8:  CLRF   x1B
....................    port_d_pullups(portD_pullups);
003BA:  SETF   x20
....................    port_e_pullups(portE_pullups);
003BC:  CLRF   x28
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
003BE:  MOVLW  40
003C0:  MOVWF  x0C
003C2:  CLRF   x14
003C4:  MOVLW  03
003C6:  MOVWF  x1C
003C8:  MOVLW  0F
003CA:  MOVWF  x21
003CC:  CLRF   x29
003CE:  MOVLB  0
003D0:  GOTO   AFAC (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
*
063C8:  MOVFF  6A6,FEA
063CC:  MOVLB  6
063CE:  MOVFF  6A5,FE9
063D2:  MOVFF  FEF,6A9
063D6:  MOVFF  6A8,FEA
063DA:  MOVFF  6A7,FE9
063DE:  MOVF   FEF,W
063E0:  SUBWF  xA9,W
063E2:  BNZ   6412
....................       if (*s1 == '\0')
063E4:  MOVFF  6A6,03
063E8:  MOVFF  6A5,FE9
063EC:  MOVFF  03,FEA
063F0:  MOVF   FEF,F
063F2:  BNZ   63FA
....................          return(0);
063F4:  MOVLW  00
063F6:  MOVWF  01
063F8:  BRA    643C
063FA:  MOVFF  6A6,03
063FE:  MOVF   xA5,W
06400:  INCF   xA5,F
06402:  BTFSC  FD8.2
06404:  INCF   xA6,F
06406:  INCF   xA7,F
06408:  BTFSC  FD8.2
0640A:  INCF   xA8,F
0640C:  MOVLB  0
0640E:  BRA    63C8
06410:  MOVLB  6
....................    return((*s1 < *s2) ? -1: 1);
06412:  MOVFF  6A6,03
06416:  MOVFF  6A5,FE9
0641A:  MOVFF  03,FEA
0641E:  MOVFF  FEF,6A9
06422:  MOVFF  6A8,03
06426:  MOVFF  6A7,FE9
0642A:  MOVFF  03,FEA
0642E:  MOVF   FEF,W
06430:  SUBWF  xA9,W
06432:  BC    6438
06434:  MOVLW  FF
06436:  BRA    643A
06438:  MOVLW  01
0643A:  MOVWF  01
0643C:  MOVLB  0
0643E:  RETURN 0
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
*
06558:  MOVFF  6CC,6CF
....................    for(su=s;0<n;++su,--n)
0655C:  MOVFF  6CB,6D1
06560:  MOVFF  6CA,6D0
06564:  MOVLB  6
06566:  MOVF   xCE,F
06568:  BNZ   6570
0656A:  MOVF   xCD,W
0656C:  SUBLW  00
0656E:  BC    6598
....................       if(*su==uc)
06570:  MOVFF  6D1,FEA
06574:  MOVFF  6D0,FE9
06578:  MOVF   xCF,W
0657A:  SUBWF  FEF,W
0657C:  BNZ   6588
....................       return su;
0657E:  MOVFF  6D0,01
06582:  MOVFF  6D1,02
06586:  BRA    659E
06588:  INCF   xD0,F
0658A:  BTFSC  FD8.2
0658C:  INCF   xD1,F
0658E:  MOVF   xCD,W
06590:  BTFSC  FD8.2
06592:  DECF   xCE,F
06594:  DECF   xCD,F
06596:  BRA    6566
....................    return NULL;
06598:  MOVLW  00
0659A:  MOVWF  01
0659C:  MOVWF  02
0659E:  MOVLB  0
065A0:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
*
06390:  MOVFF  6A6,6A8
06394:  MOVFF  6A5,6A7
06398:  MOVFF  6A8,FEA
0639C:  MOVLB  6
0639E:  MOVFF  6A7,FE9
063A2:  MOVF   FEF,F
063A4:  BZ    63B2
063A6:  INCF   xA7,F
063A8:  BTFSC  FD8.2
063AA:  INCF   xA8,F
063AC:  MOVLB  0
063AE:  BRA    6398
063B0:  MOVLB  6
....................    return(sc - s);
063B2:  MOVF   xA5,W
063B4:  SUBWF  xA7,W
063B6:  MOVWF  00
063B8:  MOVF   xA6,W
063BA:  SUBWFB xA8,W
063BC:  MOVWF  03
063BE:  MOVFF  00,01
063C2:  MOVWF  02
063C4:  MOVLB  0
063C6:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
*
07896:  MOVLB  6
07898:  CLRF   x7F
0789A:  CLRF   x7E
0789C:  CLRF   x7D
0789E:  MOVLW  7F
078A0:  MOVWF  x7C
078A2:  CLRF   x83
078A4:  CLRF   x82
078A6:  CLRF   x81
078A8:  CLRF   x80
078AA:  BSF    x84.0
078AC:  BCF    x84.1
078AE:  BCF    x84.2
078B0:  CLRF   x86
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
078B2:  MOVF   x78,W
078B4:  IORWF  x79,W
078B6:  BNZ   78C2
....................       return 0;
078B8:  CLRF   00
078BA:  CLRF   01
078BC:  CLRF   02
078BE:  CLRF   03
078C0:  BRA    7AEC
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
078C2:  MOVF   x86,W
078C4:  INCF   x86,F
078C6:  ADDWF  x78,W
078C8:  MOVWF  FE9
078CA:  MOVLW  00
078CC:  ADDWFC x79,W
078CE:  MOVWF  FEA
078D0:  MOVFF  FEF,685
078D4:  MOVF   x85,F
078D6:  BTFSC  FD8.2
078D8:  BRA    7A70
....................    {
....................       if (skip && !isspace(c))
078DA:  BTFSS  x84.0
078DC:  BRA    78FC
078DE:  MOVF   x85,W
078E0:  SUBLW  20
078E2:  BZ    78FC
....................       {
....................          skip = 0;
078E4:  BCF    x84.0
....................          if (c == '+')
078E6:  MOVF   x85,W
078E8:  SUBLW  2B
078EA:  BNZ   78F2
....................          {
....................             sign = 0;
078EC:  BCF    x84.1
....................             continue;
078EE:  BRA    7A58
....................          }            
078F0:  BRA    78FC
....................          else if (c == '-')
078F2:  MOVF   x85,W
078F4:  SUBLW  2D
078F6:  BNZ   78FC
....................          {
....................             sign = 1;
078F8:  BSF    x84.1
....................             continue;
078FA:  BRA    7A58
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
078FC:  BTFSC  x84.0
078FE:  BRA    790E
07900:  MOVF   x85,W
07902:  SUBLW  2E
07904:  BNZ   790E
07906:  BTFSC  x84.2
07908:  BRA    790E
....................          point = 1;
0790A:  BSF    x84.2
0790C:  BRA    7A58
....................       else if (!skip && isdigit(c))
0790E:  BTFSC  x84.0
07910:  BRA    7A52
07912:  MOVF   x85,W
07914:  SUBLW  2F
07916:  BTFSC  FD8.0
07918:  BRA    7A52
0791A:  MOVF   x85,W
0791C:  SUBLW  39
0791E:  BTFSS  FD8.0
07920:  BRA    7A52
....................       {
....................          c -= '0';
07922:  MOVLW  30
07924:  SUBWF  x85,F
....................          if (point)
07926:  BTFSS  x84.2
07928:  BRA    79D8
....................          {
....................             pow10 = pow10 * 10.0;
0792A:  MOVFF  67F,6B7
0792E:  MOVFF  67E,6B6
07932:  MOVFF  67D,6B5
07936:  MOVFF  67C,6B4
0793A:  CLRF   xBB
0793C:  CLRF   xBA
0793E:  MOVLW  20
07940:  MOVWF  xB9
07942:  MOVLW  82
07944:  MOVWF  xB8
07946:  MOVLB  0
07948:  CALL   12F8
0794C:  MOVFF  03,67F
07950:  MOVFF  02,67E
07954:  MOVFF  01,67D
07958:  MOVFF  00,67C
....................             result += (float)c / pow10;   
0795C:  MOVLB  6
0795E:  CLRF   xB4
07960:  MOVFF  685,6B3
07964:  MOVLB  0
07966:  CALL   12C2
0796A:  MOVFF  03,68A
0796E:  MOVFF  02,689
07972:  MOVFF  01,688
07976:  MOVFF  00,687
0797A:  MOVFF  03,6AB
0797E:  MOVFF  02,6AA
07982:  MOVFF  01,6A9
07986:  MOVFF  00,6A8
0798A:  MOVFF  67F,6AF
0798E:  MOVFF  67E,6AE
07992:  MOVFF  67D,6AD
07996:  MOVFF  67C,6AC
0799A:  CALL   283E
0799E:  BCF    FD8.1
079A0:  MOVFF  683,6B6
079A4:  MOVFF  682,6B5
079A8:  MOVFF  681,6B4
079AC:  MOVFF  680,6B3
079B0:  MOVFF  03,6BA
079B4:  MOVFF  02,6B9
079B8:  MOVFF  01,6B8
079BC:  MOVFF  00,6B7
079C0:  CALL   13EE
079C4:  MOVFF  03,683
079C8:  MOVFF  02,682
079CC:  MOVFF  01,681
079D0:  MOVFF  00,680
....................          }
079D4:  BRA    7A4E
079D6:  MOVLB  6
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
079D8:  CLRF   xB7
079DA:  CLRF   xB6
079DC:  MOVLW  20
079DE:  MOVWF  xB5
079E0:  MOVLW  82
079E2:  MOVWF  xB4
079E4:  MOVFF  683,6BB
079E8:  MOVFF  682,6BA
079EC:  MOVFF  681,6B9
079F0:  MOVFF  680,6B8
079F4:  MOVLB  0
079F6:  CALL   12F8
079FA:  MOVFF  03,68A
079FE:  MOVFF  02,689
07A02:  MOVFF  01,688
07A06:  MOVFF  00,687
07A0A:  MOVLB  6
07A0C:  CLRF   xB4
07A0E:  MOVFF  685,6B3
07A12:  MOVLB  0
07A14:  CALL   12C2
07A18:  BCF    FD8.1
07A1A:  MOVFF  68A,6B6
07A1E:  MOVFF  689,6B5
07A22:  MOVFF  688,6B4
07A26:  MOVFF  687,6B3
07A2A:  MOVFF  03,6BA
07A2E:  MOVFF  02,6B9
07A32:  MOVFF  01,6B8
07A36:  MOVFF  00,6B7
07A3A:  CALL   13EE
07A3E:  MOVFF  03,683
07A42:  MOVFF  02,682
07A46:  MOVFF  01,681
07A4A:  MOVFF  00,680
....................          }
....................       }
07A4E:  BRA    7A5A
07A50:  MOVLB  6
....................       else if (!skip)
07A52:  BTFSC  x84.0
07A54:  BRA    7A58
....................          break;
07A56:  BRA    7A70
07A58:  MOVLB  0
07A5A:  MOVLB  6
07A5C:  MOVF   x86,W
07A5E:  INCF   x86,F
07A60:  ADDWF  x78,W
07A62:  MOVWF  FE9
07A64:  MOVLW  00
07A66:  ADDWFC x79,W
07A68:  MOVWF  FEA
07A6A:  MOVFF  FEF,685
07A6E:  BRA    78D4
....................    }
.................... 
....................    if (sign)
07A70:  BTFSS  x84.1
07A72:  BRA    7AA8
....................       result = -1*result;
07A74:  CLRF   xB7
07A76:  CLRF   xB6
07A78:  MOVLW  80
07A7A:  MOVWF  xB5
07A7C:  MOVLW  7F
07A7E:  MOVWF  xB4
07A80:  MOVFF  683,6BB
07A84:  MOVFF  682,6BA
07A88:  MOVFF  681,6B9
07A8C:  MOVFF  680,6B8
07A90:  MOVLB  0
07A92:  CALL   12F8
07A96:  MOVFF  03,683
07A9A:  MOVFF  02,682
07A9E:  MOVFF  01,681
07AA2:  MOVFF  00,680
07AA6:  MOVLB  6
....................       
....................    if(endptr)
07AA8:  MOVF   x7A,W
07AAA:  IORWF  x7B,W
07AAC:  BZ    7ADC
....................    {
....................       if (ptr) {
07AAE:  MOVF   x86,F
07AB0:  BZ    7ACA
....................          ptr--;
07AB2:  DECF   x86,F
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
07AB4:  MOVFF  67B,FEA
07AB8:  MOVFF  67A,FE9
07ABC:  MOVF   x86,W
07ABE:  ADDWF  x78,W
07AC0:  MOVWF  FEF
07AC2:  MOVLW  00
07AC4:  ADDWFC x79,W
07AC6:  MOVWF  FEC
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
07AC8:  BRA    7ADC
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
07ACA:  MOVFF  67B,FEA
07ACE:  MOVFF  67A,FE9
07AD2:  MOVFF  679,FEC
07AD6:  MOVF   FED,F
07AD8:  MOVFF  678,FEF
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
07ADC:  MOVFF  680,00
07AE0:  MOVFF  681,01
07AE4:  MOVFF  682,02
07AE8:  MOVFF  683,03
07AEC:  MOVLB  0
07AEE:  RETURN 0
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
*
065F8:  MOVLB  6
065FA:  CLRF   xA3
065FC:  CLRF   xA2
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
065FE:  MOVLW  30
06600:  MOVWF  xA5
06602:  MOVLW  31
06604:  MOVWF  xA6
06606:  MOVLW  32
06608:  MOVWF  xA7
0660A:  MOVLW  33
0660C:  MOVWF  xA8
0660E:  MOVLW  34
06610:  MOVWF  xA9
06612:  MOVLW  35
06614:  MOVWF  xAA
06616:  MOVLW  36
06618:  MOVWF  xAB
0661A:  MOVLW  37
0661C:  MOVWF  xAC
0661E:  MOVLW  38
06620:  MOVWF  xAD
06622:  MOVLW  39
06624:  MOVWF  xAE
06626:  MOVLW  61
06628:  MOVWF  xAF
0662A:  MOVLW  62
0662C:  MOVWF  xB0
0662E:  MOVLW  63
06630:  MOVWF  xB1
06632:  MOVLW  64
06634:  MOVWF  xB2
06636:  MOVLW  65
06638:  MOVWF  xB3
0663A:  MOVLW  66
0663C:  MOVWF  xB4
0663E:  MOVLW  67
06640:  MOVWF  xB5
06642:  MOVLW  68
06644:  MOVWF  xB6
06646:  MOVLW  69
06648:  MOVWF  xB7
0664A:  MOVLW  6A
0664C:  MOVWF  xB8
0664E:  MOVLW  6B
06650:  MOVWF  xB9
06652:  MOVLW  6C
06654:  MOVWF  xBA
06656:  MOVLW  6D
06658:  MOVWF  xBB
0665A:  MOVLW  6E
0665C:  MOVWF  xBC
0665E:  MOVLW  6F
06660:  MOVWF  xBD
06662:  MOVLW  70
06664:  MOVWF  xBE
06666:  MOVLW  71
06668:  MOVWF  xBF
0666A:  MOVLW  73
0666C:  MOVWF  xC0
0666E:  MOVLW  74
06670:  MOVWF  xC1
06672:  MOVLW  75
06674:  MOVWF  xC2
06676:  MOVLW  76
06678:  MOVWF  xC3
0667A:  MOVLW  77
0667C:  MOVWF  xC4
0667E:  MOVLW  78
06680:  MOVWF  xC5
06682:  MOVLW  79
06684:  MOVWF  xC6
06686:  MOVLW  7A
06688:  MOVWF  xC7
0668A:  CLRF   xC8
....................    for(sc=s;isspace(*sc);++sc);
0668C:  MOVFF  698,69D
06690:  MOVFF  697,69C
06694:  MOVFF  69D,FEA
06698:  MOVFF  69C,FE9
0669C:  MOVF   FEF,W
0669E:  SUBLW  20
066A0:  BNZ   66AA
066A2:  INCF   x9C,F
066A4:  BTFSC  FD8.2
066A6:  INCF   x9D,F
066A8:  BRA    6694
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
066AA:  MOVFF  69D,03
066AE:  MOVFF  69C,FE9
066B2:  MOVFF  03,FEA
066B6:  MOVF   FEF,W
066B8:  SUBLW  2D
066BA:  BZ    66CA
066BC:  MOVFF  69D,FEA
066C0:  MOVFF  69C,FE9
066C4:  MOVF   FEF,W
066C6:  SUBLW  2B
066C8:  BNZ   66DC
066CA:  MOVFF  69D,FEA
066CE:  MOVF   x9C,W
066D0:  INCF   x9C,F
066D2:  BTFSC  FD8.2
066D4:  INCF   x9D,F
066D6:  MOVWF  FE9
066D8:  MOVF   FEF,W
066DA:  BRA    66DE
066DC:  MOVLW  2B
066DE:  MOVWF  xA4
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
066E0:  MOVF   xA4,W
066E2:  SUBLW  2D
066E4:  BZ    66FA
066E6:  BTFSC  x9B.7
066E8:  BRA    66FA
066EA:  DECFSZ x9B,W
066EC:  BRA    66F0
066EE:  BRA    66FA
066F0:  BTFSC  x9B.7
066F2:  BRA    66FE
066F4:  MOVF   x9B,W
066F6:  SUBLW  24
066F8:  BC    66FE
....................    goto StrtoulGO;
066FA:  BRA    6906
066FC:  BRA    67F6
.................... 
....................    else if (base)
066FE:  MOVF   x9B,F
06700:  BZ    678E
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
06702:  MOVF   x9B,W
06704:  SUBLW  10
06706:  BNZ   6742
06708:  MOVFF  69D,FEA
0670C:  MOVFF  69C,FE9
06710:  MOVF   FEF,W
06712:  SUBLW  30
06714:  BNZ   6742
06716:  MOVLW  01
06718:  ADDWF  x9C,W
0671A:  MOVWF  FE9
0671C:  MOVLW  00
0671E:  ADDWFC x9D,W
06720:  MOVWF  FEA
06722:  MOVF   FEF,W
06724:  SUBLW  78
06726:  BZ    673A
06728:  MOVLW  01
0672A:  ADDWF  x9C,W
0672C:  MOVWF  FE9
0672E:  MOVLW  00
06730:  ADDWFC x9D,W
06732:  MOVWF  FEA
06734:  MOVF   FEF,W
06736:  SUBLW  58
06738:  BNZ   6742
....................          sc+=2;
0673A:  MOVLW  02
0673C:  ADDWF  x9C,F
0673E:  MOVLW  00
06740:  ADDWFC x9D,F
....................       if(base==8 && *sc =='0')
06742:  MOVF   x9B,W
06744:  SUBLW  08
06746:  BNZ   675E
06748:  MOVFF  69D,FEA
0674C:  MOVFF  69C,FE9
06750:  MOVF   FEF,W
06752:  SUBLW  30
06754:  BNZ   675E
....................          sc+=1;
06756:  MOVLW  01
06758:  ADDWF  x9C,F
0675A:  MOVLW  00
0675C:  ADDWFC x9D,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
0675E:  MOVF   x9B,W
06760:  SUBLW  02
06762:  BNZ   678C
06764:  MOVFF  69D,FEA
06768:  MOVFF  69C,FE9
0676C:  MOVF   FEF,W
0676E:  SUBLW  30
06770:  BNZ   678C
06772:  MOVLW  01
06774:  ADDWF  x9C,W
06776:  MOVWF  FE9
06778:  MOVLW  00
0677A:  ADDWFC x9D,W
0677C:  MOVWF  FEA
0677E:  MOVF   FEF,W
06780:  SUBLW  62
06782:  BNZ   678C
....................          sc+=2;
06784:  MOVLW  02
06786:  ADDWF  x9C,F
06788:  MOVLW  00
0678A:  ADDWFC x9D,F
.................... 
....................    }
0678C:  BRA    67F6
....................    else if(*sc!='0') // base is 0, find base
0678E:  MOVFF  69D,FEA
06792:  MOVFF  69C,FE9
06796:  MOVF   FEF,W
06798:  SUBLW  30
0679A:  BZ    67A2
....................       base=10;
0679C:  MOVLW  0A
0679E:  MOVWF  x9B
067A0:  BRA    67F6
....................    else if (sc[1]=='x' || sc[1]=='X')
067A2:  MOVLW  01
067A4:  ADDWF  x9C,W
067A6:  MOVWF  FE9
067A8:  MOVLW  00
067AA:  ADDWFC x9D,W
067AC:  MOVWF  FEA
067AE:  MOVF   FEF,W
067B0:  SUBLW  78
067B2:  BZ    67C6
067B4:  MOVLW  01
067B6:  ADDWF  x9C,W
067B8:  MOVWF  FE9
067BA:  MOVLW  00
067BC:  ADDWFC x9D,W
067BE:  MOVWF  FEA
067C0:  MOVF   FEF,W
067C2:  SUBLW  58
067C4:  BNZ   67D4
....................       base =16,sc+=2;
067C6:  MOVLW  10
067C8:  MOVWF  x9B
067CA:  MOVLW  02
067CC:  ADDWF  x9C,F
067CE:  MOVLW  00
067D0:  ADDWFC x9D,F
067D2:  BRA    67F6
....................    else if(sc[1]=='b')
067D4:  MOVLW  01
067D6:  ADDWF  x9C,W
067D8:  MOVWF  FE9
067DA:  MOVLW  00
067DC:  ADDWFC x9D,W
067DE:  MOVWF  FEA
067E0:  MOVF   FEF,W
067E2:  SUBLW  62
067E4:  BNZ   67F2
....................       base=2,sc+=2;
067E6:  MOVLW  02
067E8:  MOVWF  x9B
067EA:  ADDWF  x9C,F
067EC:  MOVLW  00
067EE:  ADDWFC x9D,F
067F0:  BRA    67F6
....................    else
....................       base=8;
067F2:  MOVLW  08
067F4:  MOVWF  x9B
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
067F6:  MOVFF  69D,69F
067FA:  MOVFF  69C,69E
067FE:  MOVFF  69D,FEA
06802:  MOVFF  69C,FE9
06806:  MOVF   FEF,W
06808:  SUBLW  30
0680A:  BNZ   6814
0680C:  INCF   x9C,F
0680E:  BTFSC  FD8.2
06810:  INCF   x9D,F
06812:  BRA    67FE
....................    sd=memchr(digits,tolower(*sc),base);
06814:  MOVFF  69D,03
06818:  MOVFF  69C,FE9
0681C:  MOVFF  03,FEA
06820:  MOVFF  FEF,6C9
06824:  MOVF   xC9,W
06826:  SUBLW  40
06828:  BC    6836
0682A:  MOVF   xC9,W
0682C:  SUBLW  5A
0682E:  BNC   6836
06830:  MOVF   xC9,W
06832:  IORLW  20
06834:  BRA    6838
06836:  MOVF   xC9,W
06838:  MOVWF  xC9
0683A:  MOVLW  06
0683C:  MOVWF  xCB
0683E:  MOVLW  A5
06840:  MOVWF  xCA
06842:  MOVFF  6C9,6CC
06846:  CLRF   xCE
06848:  MOVFF  69B,6CD
0684C:  BTFSC  xCD.7
0684E:  DECF   xCE,F
06850:  MOVLB  0
06852:  RCALL  6558
06854:  MOVFF  02,6A1
06858:  MOVFF  01,6A0
....................    for(; sd!=0; )
0685C:  MOVLB  6
0685E:  MOVF   xA0,F
06860:  BNZ   6866
06862:  MOVF   xA1,F
06864:  BZ    68FA
....................    {
....................       x=x*base+(int16)(sd-digits);
06866:  CLRF   03
06868:  MOVF   x9B,W
0686A:  MOVWF  00
0686C:  BTFSC  FE8.7
0686E:  DECF   03,F
06870:  MOVWF  xC9
06872:  MOVFF  03,6CA
06876:  MOVFF  6A3,6CC
0687A:  MOVFF  6A2,6CB
0687E:  MOVFF  03,6CE
06882:  MOVWF  xCD
06884:  MOVLB  0
06886:  BRA    65A2
06888:  MOVFF  01,6C9
0688C:  MOVLW  A5
0688E:  MOVLB  6
06890:  SUBWF  xA0,W
06892:  MOVWF  00
06894:  MOVLW  06
06896:  SUBWFB xA1,W
06898:  MOVWF  03
0689A:  MOVF   00,W
0689C:  ADDWF  01,W
0689E:  MOVWF  01
068A0:  MOVF   02,W
068A2:  ADDWFC 03,F
068A4:  MOVFF  01,6A2
068A8:  MOVFF  03,6A3
....................       ++sc;
068AC:  INCF   x9C,F
068AE:  BTFSC  FD8.2
068B0:  INCF   x9D,F
....................       sd=memchr(digits,tolower(*sc),base);
068B2:  MOVFF  69D,FEA
068B6:  MOVFF  69C,FE9
068BA:  MOVFF  FEF,6C9
068BE:  MOVF   xC9,W
068C0:  SUBLW  40
068C2:  BC    68D0
068C4:  MOVF   xC9,W
068C6:  SUBLW  5A
068C8:  BNC   68D0
068CA:  MOVF   xC9,W
068CC:  IORLW  20
068CE:  BRA    68D2
068D0:  MOVF   xC9,W
068D2:  MOVWF  xC9
068D4:  MOVLW  06
068D6:  MOVWF  xCB
068D8:  MOVLW  A5
068DA:  MOVWF  xCA
068DC:  MOVFF  6C9,6CC
068E0:  CLRF   xCE
068E2:  MOVFF  69B,6CD
068E6:  BTFSC  xCD.7
068E8:  DECF   xCE,F
068EA:  MOVLB  0
068EC:  RCALL  6558
068EE:  MOVFF  02,6A1
068F2:  MOVFF  01,6A0
068F6:  BRA    685C
068F8:  MOVLB  6
....................    }
....................    if(s1==sc)
068FA:  MOVF   x9C,W
068FC:  SUBWF  x9E,W
068FE:  BNZ   6928
06900:  MOVF   x9D,W
06902:  SUBWF  x9F,W
06904:  BNZ   6928
....................    {
....................    StrtoulGO:
....................       if (endptr)
06906:  MOVLB  6
06908:  MOVF   x99,W
0690A:  IORWF  x9A,W
0690C:  BZ    6920
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
0690E:  MOVFF  69A,FEA
06912:  MOVFF  699,FE9
06916:  MOVFF  698,FEC
0691A:  MOVF   FED,F
0691C:  MOVFF  697,FEF
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
06920:  MOVLW  00
06922:  MOVWF  01
06924:  MOVWF  02
06926:  BRA    6948
....................    }
....................    if (endptr)
06928:  MOVF   x99,W
0692A:  IORWF  x9A,W
0692C:  BZ    6940
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
0692E:  MOVFF  69A,FEA
06932:  MOVFF  699,FE9
06936:  MOVFF  69D,FEC
0693A:  MOVF   FED,F
0693C:  MOVFF  69C,FEF
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
06940:  MOVFF  6A2,01
06944:  MOVFF  6A3,02
06948:  MOVLB  0
0694A:  RETURN 0
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
*
01C18:  BCF    FD8.0
01C1A:  MOVLB  6
01C1C:  RRCF   xAB,W
01C1E:  MOVWF  xAF
....................    while( m > 0 ) {
01C20:  MOVF   xAF,F
01C22:  BTFSC  FD8.2
01C24:  BRA    1D3C
....................      for(j=0; j<(qitems-m); ++j) {
01C26:  CLRF   xB0
01C28:  MOVF   xAF,W
01C2A:  SUBWF  xAB,W
01C2C:  SUBWF  xB0,W
01C2E:  BTFSC  FD8.0
01C30:  BRA    1D36
....................         i = j;
01C32:  MOVFF  6B0,6B1
....................         do
....................         {
....................            done=1;
01C36:  BSF    xB3.0
....................            l = i+m;
01C38:  MOVF   xAF,W
01C3A:  ADDWF  xB1,W
01C3C:  MOVWF  xB2
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
01C3E:  MOVF   xB1,W
01C40:  MULWF  xAC
01C42:  MOVF   FF3,W
01C44:  ADDWF  xA9,W
01C46:  MOVWF  xC4
01C48:  MOVLW  00
01C4A:  ADDWFC xAA,W
01C4C:  MOVWF  xC5
01C4E:  MOVF   xB2,W
01C50:  MULWF  xAC
01C52:  MOVF   FF3,W
01C54:  ADDWF  xA9,W
01C56:  MOVWF  xC6
01C58:  MOVLW  00
01C5A:  ADDWFC xAA,W
01C5C:  MOVWF  xC7
01C5E:  MOVLW  06
01C60:  MOVWF  FEA
01C62:  MOVLW  AD
01C64:  MOVWF  FE9
01C66:  MOVFF  6C5,660
01C6A:  MOVFF  6C4,65F
01C6E:  MOVFF  6C7,662
01C72:  MOVFF  6C6,661
01C76:  MOVLB  0
01C78:  CALL   00BC
01C7C:  BTFSC  01.7
01C7E:  BRA    1D2C
01C80:  MOVF   01,W
01C82:  SUBLW  00
01C84:  BC    1D2C
....................               memcpy(t, qdata+i*qsize, qsize);
01C86:  MOVLB  6
01C88:  MOVF   xB1,W
01C8A:  MULWF  xAC
01C8C:  MOVF   FF3,W
01C8E:  ADDWF  xA9,W
01C90:  MOVWF  xC4
01C92:  MOVLW  00
01C94:  ADDWFC xAA,W
01C96:  MOVWF  xC5
01C98:  MOVLW  06
01C9A:  MOVWF  FEA
01C9C:  MOVLW  B4
01C9E:  MOVWF  FE9
01CA0:  MOVFF  6C5,FE2
01CA4:  MOVFF  6C4,FE1
01CA8:  MOVF   xAC,W
01CAA:  MOVWF  01
01CAC:  BZ    1CB6
01CAE:  MOVFF  FE6,FEE
01CB2:  DECFSZ 01,F
01CB4:  BRA    1CAE
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
01CB6:  MOVF   xB1,W
01CB8:  MULWF  xAC
01CBA:  MOVF   FF3,W
01CBC:  ADDWF  xA9,W
01CBE:  MOVWF  xC4
01CC0:  MOVLW  00
01CC2:  ADDWFC xAA,W
01CC4:  MOVWF  xC5
01CC6:  MOVF   xB2,W
01CC8:  MULWF  xAC
01CCA:  MOVF   FF3,W
01CCC:  ADDWF  xA9,W
01CCE:  MOVWF  xC6
01CD0:  MOVLW  00
01CD2:  ADDWFC xAA,W
01CD4:  MOVWF  xC7
01CD6:  MOVFF  6C5,FEA
01CDA:  MOVFF  6C4,FE9
01CDE:  MOVWF  FE2
01CE0:  MOVFF  6C6,FE1
01CE4:  MOVF   xAC,W
01CE6:  MOVWF  01
01CE8:  BZ    1CF2
01CEA:  MOVFF  FE6,FEE
01CEE:  DECFSZ 01,F
01CF0:  BRA    1CEA
....................               memcpy(qdata+l*qsize, t, qsize);
01CF2:  MOVF   xB2,W
01CF4:  MULWF  xAC
01CF6:  MOVF   FF3,W
01CF8:  ADDWF  xA9,W
01CFA:  MOVWF  xC4
01CFC:  MOVLW  00
01CFE:  ADDWFC xAA,W
01D00:  MOVWF  xC5
01D02:  MOVWF  FEA
01D04:  MOVFF  6C4,FE9
01D08:  MOVLW  06
01D0A:  MOVWF  FE2
01D0C:  MOVLW  B4
01D0E:  MOVWF  FE1
01D10:  MOVF   xAC,W
01D12:  MOVWF  01
01D14:  BZ    1D1E
01D16:  MOVFF  FE6,FEE
01D1A:  DECFSZ 01,F
01D1C:  BRA    1D16
....................               if(m <= i)
01D1E:  MOVF   xAF,W
01D20:  SUBWF  xB1,W
01D22:  BNC   1D28
....................                 i -= m;
01D24:  MOVF   xAF,W
01D26:  SUBWF  xB1,F
....................                 done = 0;
01D28:  BCF    xB3.0
01D2A:  MOVLB  0
....................            }
....................         } while(!done);
01D2C:  MOVLB  6
01D2E:  BTFSS  xB3.0
01D30:  BRA    1C36
01D32:  INCF   xB0,F
01D34:  BRA    1C28
....................      }
....................      m = m/2;
01D36:  BCF    FD8.0
01D38:  RRCF   xAF,F
01D3A:  BRA    1C20
....................    }
01D3C:  MOVLB  0
01D3E:  RETURN 0
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0.3,0.1,0,0,0,0,0},
....................    {0.01,0.3,0.1,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
*
00450:  MOVLB  6
00452:  CLRF   x69
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
00454:  CLRF   x69
00456:  MOVF   x68,W
00458:  SUBWF  x69,W
0045A:  BC    04B2
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
0045C:  MOVF   x69,W
0045E:  ADDWF  x66,W
00460:  MOVWF  x6A
00462:  MOVLW  00
00464:  ADDWFC x67,W
00466:  MOVWF  x6B
00468:  MOVF   x69,W
0046A:  ADDWF  x64,W
0046C:  MOVWF  01
0046E:  MOVLW  00
00470:  ADDWFC x65,W
00472:  MOVWF  03
00474:  MOVF   01,W
00476:  MOVWF  FE9
00478:  MOVFF  03,FEA
0047C:  MOVFF  FEF,66C
00480:  BSF    F7F.7
00482:  MOVF   FF2,W
00484:  MOVWF  00
00486:  BCF    FF2.7
00488:  MOVFF  66B,F7A
0048C:  MOVFF  66A,F79
00490:  MOVLW  31
00492:  MOVWF  F7B
00494:  MOVFF  66C,F7C
00498:  MOVLB  F
0049A:  MOVLW  55
0049C:  MOVWF  F81
0049E:  MOVLW  AA
004A0:  MOVWF  F81
004A2:  BSF    F80.4
004A4:  BTFSC  F80.4
004A6:  BRA    04A4
004A8:  MOVF   00,W
004AA:  IORWF  FF2,F
004AC:  MOVLB  6
004AE:  INCF   x69,F
004B0:  BRA    0456
....................    }
004B2:  MOVLB  0
004B4:  RETURN 0
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
*
003D4:  MOVLB  6
003D6:  CLRF   x69
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
003D8:  CLRF   x69
003DA:  MOVF   x68,W
003DC:  SUBWF  x69,W
003DE:  BC    0422
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
003E0:  MOVF   x69,W
003E2:  ADDWF  x64,W
003E4:  MOVWF  01
003E6:  MOVLW  00
003E8:  ADDWFC x65,W
003EA:  MOVWF  03
003EC:  MOVF   01,W
003EE:  MOVWF  FE9
003F0:  MOVFF  03,FEA
003F4:  MOVF   x69,W
003F6:  ADDWF  x66,W
003F8:  MOVWF  x6C
003FA:  MOVLW  00
003FC:  ADDWFC x67,W
003FE:  MOVWF  x6D
00400:  BSF    F7F.7
00402:  MOVFF  FF2,66E
00406:  BCF    FF2.7
00408:  MOVFF  66D,F7A
0040C:  MOVFF  66C,F79
00410:  MOVLW  31
00412:  MOVWF  F7B
00414:  BSF    F80.0
00416:  MOVF   F7C,W
00418:  BTFSC  x6E.7
0041A:  BSF    FF2.7
0041C:  MOVWF  FEF
0041E:  INCF   x69,F
00420:  BRA    03DA
....................    }
00422:  MOVLB  0
00424:  RETURN 0
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
*
004B6:  MOVLB  6
004B8:  CLRF   x65
004BA:  MOVLW  20
004BC:  MOVWF  x64
004BE:  CLRF   x67
004C0:  CLRF   x66
004C2:  MOVLW  80
004C4:  MOVWF  x68
004C6:  MOVLB  0
004C8:  RCALL  0450
....................    delay_ms(1);
004CA:  MOVLW  01
004CC:  MOVLB  6
004CE:  MOVWF  x6C
004D0:  MOVLB  0
004D2:  RCALL  0426
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
004D4:  MOVLB  6
004D6:  CLRF   x65
004D8:  MOVLW  60
004DA:  MOVWF  x64
004DC:  CLRF   x67
004DE:  MOVLW  80
004E0:  MOVWF  x66
004E2:  MOVLW  02
004E4:  MOVWF  x68
004E6:  MOVLB  0
004E8:  RCALL  0450
....................    delay_ms(1);
004EA:  MOVLW  01
004EC:  MOVLB  6
004EE:  MOVWF  x6C
004F0:  MOVLB  0
004F2:  RCALL  0426
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
004F4:  MOVLB  6
004F6:  CLRF   x65
004F8:  MOVLW  61
004FA:  MOVWF  x64
004FC:  CLRF   x67
004FE:  MOVLW  90
00500:  MOVWF  x66
00502:  MOVLW  02
00504:  MOVWF  x68
00506:  MOVLB  0
00508:  RCALL  0450
....................    delay_ms(1);
0050A:  MOVLW  01
0050C:  MOVLB  6
0050E:  MOVWF  x6C
00510:  MOVLB  0
00512:  RCALL  0426
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
00514:  MOVLB  6
00516:  CLRF   x65
00518:  MOVLW  62
0051A:  MOVWF  x64
0051C:  CLRF   x67
0051E:  MOVLW  A0
00520:  MOVWF  x66
00522:  MOVLW  20
00524:  MOVWF  x68
00526:  MOVLB  0
00528:  RCALL  0450
....................    delay_ms(1);
0052A:  MOVLW  01
0052C:  MOVLB  6
0052E:  MOVWF  x6C
00530:  MOVLB  0
00532:  RCALL  0426
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
00534:  MOVLB  6
00536:  CLRF   x65
00538:  MOVLW  82
0053A:  MOVWF  x64
0053C:  CLRF   x67
0053E:  MOVLW  C0
00540:  MOVWF  x66
00542:  MOVLW  30
00544:  MOVWF  x68
00546:  MOVLB  0
00548:  RCALL  0450
....................    delay_ms(1);
0054A:  MOVLW  01
0054C:  MOVLB  6
0054E:  MOVWF  x6C
00550:  MOVLB  0
00552:  RCALL  0426
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
00554:  MOVLB  6
00556:  CLRF   x65
00558:  MOVLW  B2
0055A:  MOVWF  x64
0055C:  CLRF   x67
0055E:  MOVLW  F0
00560:  MOVWF  x66
00562:  MOVLW  38
00564:  MOVWF  x68
00566:  MOVLB  0
00568:  RCALL  0450
....................    delay_ms(1);
0056A:  MOVLW  01
0056C:  MOVLB  6
0056E:  MOVWF  x6C
00570:  MOVLB  0
00572:  RCALL  0426
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
00574:  MOVLB  6
00576:  CLRF   x65
00578:  MOVLW  F2
0057A:  MOVWF  x64
0057C:  MOVLW  01
0057E:  MOVWF  x67
00580:  MOVLW  40
00582:  MOVWF  x66
00584:  MOVLW  01
00586:  MOVWF  x68
00588:  MOVLB  0
0058A:  RCALL  0450
....................    delay_ms(1);
0058C:  MOVLW  01
0058E:  MOVLB  6
00590:  MOVWF  x6C
00592:  MOVLB  0
00594:  RCALL  0426
00596:  GOTO   0666 (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
0059A:  MOVLB  6
0059C:  CLRF   x65
0059E:  MOVLW  20
005A0:  MOVWF  x64
005A2:  CLRF   x67
005A4:  CLRF   x66
005A6:  MOVLW  80
005A8:  MOVWF  x68
005AA:  MOVLB  0
005AC:  RCALL  03D4
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
005AE:  MOVLB  6
005B0:  CLRF   x65
005B2:  MOVLW  60
005B4:  MOVWF  x64
005B6:  CLRF   x67
005B8:  MOVLW  80
005BA:  MOVWF  x66
005BC:  MOVLW  02
005BE:  MOVWF  x68
005C0:  MOVLB  0
005C2:  RCALL  03D4
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
005C4:  MOVLB  6
005C6:  CLRF   x65
005C8:  MOVLW  61
005CA:  MOVWF  x64
005CC:  CLRF   x67
005CE:  MOVLW  90
005D0:  MOVWF  x66
005D2:  MOVLW  02
005D4:  MOVWF  x68
005D6:  MOVLB  0
005D8:  RCALL  03D4
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
005DA:  MOVLB  6
005DC:  CLRF   x65
005DE:  MOVLW  62
005E0:  MOVWF  x64
005E2:  CLRF   x67
005E4:  MOVLW  A0
005E6:  MOVWF  x66
005E8:  MOVLW  20
005EA:  MOVWF  x68
005EC:  MOVLB  0
005EE:  RCALL  03D4
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
005F0:  MOVLB  6
005F2:  CLRF   x65
005F4:  MOVLW  82
005F6:  MOVWF  x64
005F8:  CLRF   x67
005FA:  MOVLW  C0
005FC:  MOVWF  x66
005FE:  MOVLW  30
00600:  MOVWF  x68
00602:  MOVLB  0
00604:  RCALL  03D4
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
00606:  MOVLB  6
00608:  CLRF   x65
0060A:  MOVLW  B2
0060C:  MOVWF  x64
0060E:  CLRF   x67
00610:  MOVLW  F0
00612:  MOVWF  x66
00614:  MOVLW  38
00616:  MOVWF  x68
00618:  MOVLB  0
0061A:  RCALL  03D4
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
0061C:  MOVLB  6
0061E:  CLRF   x65
00620:  MOVLW  F2
00622:  MOVWF  x64
00624:  MOVLW  01
00626:  MOVWF  x67
00628:  MOVLW  40
0062A:  MOVWF  x66
0062C:  MOVLW  01
0062E:  MOVWF  x68
00630:  MOVLB  0
00632:  RCALL  03D4
00634:  GOTO   066A (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
00638:  MOVLB  6
0063A:  CLRF   x65
0063C:  MOVLW  F2
0063E:  MOVWF  x64
00640:  MOVLW  01
00642:  MOVWF  x67
00644:  MOVLW  40
00646:  MOVWF  x66
00648:  MOVLW  01
0064A:  MOVWF  x68
0064C:  MOVLB  0
0064E:  RCALL  03D4
....................    delay_ms(1);
00650:  MOVLW  01
00652:  MOVLB  6
00654:  MOVWF  x6C
00656:  MOVLB  0
00658:  RCALL  0426
....................    if (paramsValid != isValid)
0065A:  MOVF   xF2,W
0065C:  SUBLW  AA
0065E:  BZ    0668
....................    {
....................       paramsValid = isValid;
00660:  MOVLW  AA
00662:  MOVWF  xF2
....................       params_save_to_ee(); // saves the base parameters on first boot
00664:  BRA    04B6
....................    }
00666:  BRA    066A
....................    else
....................    {
....................       params_load_from_ee();
00668:  BRA    059A
....................    }
0066A:  GOTO   AFB0 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <monitor.h>
.................... #ifndef monitor
.................... #define monitor
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
....................    output_b(portB_reset);
....................    output_c(portC_reset);
....................    output_d(portD_reset);
....................    output_e(portE_reset);
....................    
....................    port_a_pullups(portA_pullups);
....................    port_b_pullups(portB_pullups);
....................    port_c_pullups(portC_pullups);
....................    port_d_pullups(portD_pullups);
....................    port_e_pullups(portE_pullups);
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0.3,0.1,0,0,0,0,0},
....................    {0.01,0.3,0.1,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <ADS1220.h>
.................... #ifndef ADS1220
.................... #define ADS1220
.................... 
.................... /*****************************************************************************/
.................... /* SET UP PORTS FOR USE WITH DRIVER                                          */
.................... /*****************************************************************************/
.................... #define _CS0  PIN_D5 // chip select pins 
.................... #define _CS1  PIN_D6
.................... #define _CS2  PIN_D7
.................... #define _CS3  PIN_B0
.................... 
.................... #pin_select SCK2=PIN_B1
.................... #pin_select SDI2=PIN_B2
.................... #pin_select SDO2=PIN_B3
.................... #use spi(MASTER, SPI2, BAUD=1000000, MODE=1, STREAM=SPI_mon)
.................... //!setup_spi2(SPI_MASTER | SPI_SCK_IDLE_LOW | SPI_XMIT_H_TO_L | SPI_CLK_DIV_64);
.................... 
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* REGISTER DEFINITIONS                                                      */
.................... /*****************************************************************************/
.................... typedef enum {reg0 = 0x00,reg1 = 0x04 ,reg2 = 0x08, reg3 = 0x0C}adsReg;
.................... 
.................... //REGISTER 0 OPTIONS
.................... 
.................... #define IPp0n1 0x00
.................... #define IPp0n2 0x10
.................... #define IPp0n3 0x20
.................... #define IPp1n2 0x30
.................... #define IPp1n3 0x40
.................... #define IPp2n3 0x50
.................... #define IPp1n0 0x60
.................... #define IPp3n2 0x70
.................... #define IPp0nVss 0x80
.................... #define IPp1nVss 0x90
.................... #define IPp2nVss 0xA0
.................... #define IPp3nVss 0xB0
.................... #define IPVrpVrn 0xC0
.................... #define IPVddVss 0xD0
.................... #define IPhalfRail 0xE0
.................... 
.................... #define g1 0x00
.................... #define g2 0x02
.................... #define g4 0x04
.................... #define g8 0x06
.................... #define g16 0x08
.................... #define g32 0x0A
.................... #define g64 0x0C
.................... #define g128 0x0E
.................... 
.................... #define PGAenabled 0x00
.................... #define PGAbypass 0x01
.................... 
.................... //REGISTER 1 OPTIONS
.................... 
.................... #define DRn20 0x00
.................... #define DRn45 0x20
.................... #define DRn90 0x40
.................... #define DRn175 0x60
.................... #define DRn330 0x80
.................... #define DRn600 0xA0
.................... #define DRn1000 0xC0
.................... 
.................... #define MDnormal 0x00
.................... #define MDduty 0x80
.................... #define MDturbo 0x10
.................... 
.................... #define CMsingle 0x00
.................... #define CMcont 0x40
.................... 
.................... #define TSdisable 0x00
.................... #define TSenable 0x20
.................... 
.................... #define BCSoff 0x00
.................... #define BCSon 0x01
.................... 
.................... //REGISTER 2 OPTIONS
.................... 
.................... #define REFinternal 0x00
.................... #define REFp0n0 0x40
.................... #define REFp1n1 0x80
.................... #define REFVddVss 0xC0
.................... 
.................... #define FIRoff 0x00
.................... #define FIR5060 0x10
.................... #define FIR50 0x20
.................... #define FIR60 0x30
.................... 
.................... #define PSWopen 0x00
.................... #define PSWstart 0x08
.................... 
.................... #define Ioff 0x00
.................... #define Iu10 0x01
.................... #define Iu50 0x02
.................... #define Iu100 0x03
.................... #define Iu250 0x04
.................... #define Iu500 0x05
.................... #define Iu1000 0x06
.................... #define Iu1500 0x07  
.................... 
.................... //REGISTER 3 OPTIONS
.................... 
.................... #define I1disabled 0x00
.................... #define I1a0p1 0x20
.................... #define I1a1 0x40
.................... #define I1a2 0x60
.................... #define I1a3n1 0x80
.................... #define I1p0 0xA0
.................... #define I1n0 0xC0
.................... 
.................... #define I2disabled 0x00
.................... #define I2a0p1 0x04
.................... #define I2a1 0x08
.................... #define I2a2 0x0A
.................... #define I2a3n1 0x10
.................... #define I2p0 0x14
.................... #define I2n0 0x18
.................... 
.................... #define drdyPin 0x00
.................... #define doutPin 0x20
.................... 
.................... // REGISTER CONGIGURATIONS FOR THIS APP
.................... #define reg0config IPp1n2|g1|PGAenabled // 0x30//
.................... #define reg1config DRn20|MDturbo|CMsingle|TSDisable|BCSoff //0x10
.................... #define reg2config REFinternal|FIR60|PSWopen|Ioff //0x30
.................... #define reg3config I1disabled|I2disabled|drdyPin //0x00
.................... 
.................... //COMMANDS
.................... #define ADSreset 0x06
.................... #define ADSstart 0x08
.................... #define ADSpowerDn 0x02
.................... #define ADSreadData 0x10
.................... #define ADSreadReg 0x20
.................... #define ADSwriteReg 0x40
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* DESELECT ALL ADCs                                                         */
.................... /*****************************************************************************/
.................... void ads_deselect_all()
.................... {   
....................    output_high(_CS0); // deselect all chip select pins
*
00136:  MOVLW  1F
00138:  MOVWF  F8A
0013A:  BSF    F85.5
....................    output_high(_CS1);
0013C:  MOVWF  F8A
0013E:  BSF    F85.6
....................    output_high(_CS2);
00140:  MOVWF  F8A
00142:  BSF    F85.7
....................    output_high(_CS3); 
00144:  MOVLW  C4
00146:  MOVWF  F88
00148:  BSF    F83.0
....................    delay_us(10);
0014A:  MOVLW  35
0014C:  MOVWF  00
0014E:  DECFSZ 00,F
00150:  BRA    014E
00152:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT DESIRED ADC                                                        */
.................... /*****************************************************************************/
.................... void ads_select_ch(int8 ch)
.................... {
....................    ads_deselect_all();
*
0066E:  RCALL  0136
....................    switch(ch)
00670:  MOVLB  6
00672:  MOVF   x7D,W
00674:  ADDLW  FC
00676:  BC    06AA
00678:  ADDLW  04
0067A:  MOVLB  0
0067C:  GOTO   06B6
....................    {
....................       case 0:
....................          output_low(_CS0);
00680:  MOVLW  1F
00682:  MOVWF  F8A
00684:  BCF    F85.5
....................       break; 
00686:  MOVLB  6
00688:  BRA    06AA
....................       case 1:
....................          output_low(_CS1);
0068A:  MOVLW  1F
0068C:  MOVWF  F8A
0068E:  BCF    F85.6
....................       break;   
00690:  MOVLB  6
00692:  BRA    06AA
....................       case 2:
....................          output_low(_CS2);
00694:  MOVLW  1F
00696:  MOVWF  F8A
00698:  BCF    F85.7
....................       break;
0069A:  MOVLB  6
0069C:  BRA    06AA
....................       case 3:
....................          output_low(_CS3);
0069E:  MOVLW  C4
006A0:  MOVWF  F88
006A2:  BCF    F83.0
....................       break;              
006A4:  MOVLB  6
006A6:  BRA    06AA
006A8:  MOVLB  6
....................    }
....................    delay_us(10);
006AA:  MOVLW  35
006AC:  MOVWF  00
006AE:  DECFSZ 00,F
006B0:  BRA    06AE
006B2:  MOVLB  0
006B4:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT ADC BLOCK (2 ADCs/BLOCK)                                           */
.................... /*****************************************************************************/
.................... void ads_select_block(int8 block)
.................... {
....................    ads_deselect_all();
*
00154:  RCALL  0136
....................    switch(block)
00156:  MOVLB  6
00158:  MOVF   xD6,W
0015A:  XORLW  00
0015C:  MOVLB  0
0015E:  BZ    0166
00160:  XORLW  01
00162:  BZ    0172
00164:  BRA    017E
....................    {
....................       case 0:
....................          output_low(_CS0);
00166:  MOVLW  1F
00168:  MOVWF  F8A
0016A:  BCF    F85.5
....................          output_low(_CS1);
0016C:  MOVWF  F8A
0016E:  BCF    F85.6
....................       break; 
00170:  BRA    017E
....................       case 1:         
....................          output_low(_CS2);
00172:  MOVLW  1F
00174:  MOVWF  F8A
00176:  BCF    F85.7
....................          output_low(_CS3);
00178:  MOVLW  C4
0017A:  MOVWF  F88
0017C:  BCF    F83.0
....................       break;         
....................    }
....................    delay_us(10);
0017E:  MOVLW  35
00180:  MOVWF  00
00182:  DECFSZ 00,F
00184:  BRA    0182
00186:  GOTO   0190 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT ALL ADCs                                                           */
.................... /*****************************************************************************/
.................... void ads_select_all()
.................... {
....................    output_low(_CS0);
*
007A4:  MOVLW  1F
007A6:  MOVWF  F8A
007A8:  BCF    F85.5
....................    output_low(_CS1);
007AA:  MOVWF  F8A
007AC:  BCF    F85.6
....................    output_low(_CS2);
007AE:  MOVWF  F8A
007B0:  BCF    F85.7
....................    output_low(_CS3);
007B2:  MOVLW  C4
007B4:  MOVWF  F88
007B6:  BCF    F83.0
....................    delay_us(10);
007B8:  MOVLW  35
007BA:  MOVWF  00
007BC:  DECFSZ 00,F
007BE:  BRA    07BC
007C0:  GOTO   07C6 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO AN ADC                                          */
.................... /*****************************************************************************/
.................... void ads_write_command(int8 ch, unsigned int8 command)
.................... {
....................    ads_select_ch(ch);
*
006D8:  MOVFF  674,67D
006DC:  RCALL  066E
....................    spi_write2(command);
006DE:  MOVLB  E
006E0:  MOVF   x8D,W
006E2:  MOVFF  675,E8D
006E6:  RRCF   x90,W
006E8:  BNC   06E6
006EA:  MOVLB  0
006EC:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO A BLOCK OF ADCs                                 */
.................... /*****************************************************************************/
.................... void ads_write_command_block(int8 block, unsigned int8 command)
.................... {
....................    ads_select_block(block);
*
0018A:  MOVFF  6D4,6D6
0018E:  BRA    0154
....................    spi_write2(command);
00190:  MOVLB  E
00192:  MOVF   x8D,W
00194:  MOVFF  6D5,E8D
00198:  RRCF   x90,W
0019A:  BNC   0198
0019C:  MOVLB  0
0019E:  GOTO   01B0 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO ALL ADCs                                        */
.................... /*****************************************************************************/
.................... void ads_write_command_all(unsigned int8 command)
.................... {
....................    ads_select_all();
*
007C4:  BRA    07A4
....................    spi_write2(command);
007C6:  MOVLB  E
007C8:  MOVF   x8D,W
007CA:  MOVFF  66B,E8D
007CE:  RRCF   x90,W
007D0:  BNC   07CE
007D2:  MOVLB  0
007D4:  GOTO   07E2 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PREPARE TO READ FROM AN ADC                                               */
.................... /*****************************************************************************/
.................... void ads_read_command(int8 ch, unsigned int8 command)
.................... {
....................    ads_select_ch(ch);
*
00812:  MOVFF  67B,67D
00816:  RCALL  066E
....................    spi_read2(command);
00818:  MOVLB  E
0081A:  MOVF   x8D,W
0081C:  MOVFF  67C,E8D
00820:  RRCF   x90,W
00822:  BNC   0820
00824:  MOVLB  0
00826:  GOTO   0838 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE TO THE CONFIGURATION REGISTERS                                      */
.................... /*****************************************************************************/
.................... void ads_write_reg(int8 ch, adsReg regID, int8 data)
*
00714:  MOVLB  6
00716:  MOVF   x71,W
00718:  IORLW  40
0071A:  MOVWF  x73
.................... {
....................    unsigned int8 command = ADSwriteReg | regID | 0; // 0 is numbytes to write-1
....................    ads_write_command(ch, command);
0071C:  MOVFF  670,674
00720:  MOVFF  673,675
00724:  MOVLB  0
00726:  RCALL  06D8
....................    spi_write2(data);
00728:  MOVLB  E
0072A:  MOVF   x8D,W
0072C:  MOVFF  672,E8D
00730:  RRCF   x90,W
00732:  BNC   0730
....................    ads_deselect_all();
00734:  MOVLB  0
00736:  RCALL  0136
00738:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* READ FROM THE CONFIGURATION REGISTERS                                     */
.................... /*****************************************************************************/
.................... unsigned int8 ads_read_reg(int8 ch, adsReg regID)
.................... {
....................    unsigned int8 command = ADSreadReg | regID | 0;
....................    ads_read_command(ch, command);
....................    unsigned int8 data = spi_read2(0);
....................    ads_deselect_all();
....................    return data;
.................... }
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* START BLOCK CONVERSION                                                    */
.................... /*****************************************************************************/
.................... void ads_start_conv_block(int8 block)
.................... {
....................    ads_write_command_block(block, ADSstart);
*
001A2:  MOVFF  6D3,6D4
001A6:  MOVLW  08
001A8:  MOVLB  6
001AA:  MOVWF  xD5
001AC:  MOVLB  0
001AE:  BRA    018A
....................    delay_us(10);
001B0:  MOVLW  35
001B2:  MOVWF  00
001B4:  DECFSZ 00,F
001B6:  BRA    01B4
....................    ads_deselect_all();
001B8:  RCALL  0136
001BA:  GOTO   0200 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* START ALL CONVERSION                                                      */
.................... /*****************************************************************************/
.................... void ads_start_conv_all()
.................... {
....................    ads_write_command_all(ADSstart);
*
007D8:  MOVLW  08
007DA:  MOVLB  6
007DC:  MOVWF  x6B
007DE:  MOVLB  0
007E0:  BRA    07C4
....................    delay_us(10);
007E2:  MOVLW  35
007E4:  MOVWF  00
007E6:  DECFSZ 00,F
007E8:  BRA    07E6
....................    ads_deselect_all();
007EA:  RCALL  0136
007EC:  GOTO   0982 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* READ THE MOST RECENT CONVERSION                                           */
.................... /*****************************************************************************/
.................... signed int32 ads_read_data(int8 ch)
.................... {
....................    union Data
....................    {
....................       unsigned int8 dBytes[4];
....................       signed int32 dWord;
....................    }data;
....................    
....................    ads_read_command(ch, ADSreadData);
*
0082A:  MOVFF  676,67B
0082E:  MOVLW  10
00830:  MOVLB  6
00832:  MOVWF  x7C
00834:  MOVLB  0
00836:  BRA    0812
....................    data.dBytes[0] = 0;
00838:  MOVLB  6
0083A:  CLRF   x77
....................    data.dBytes[3] = spi_read2(0);
0083C:  MOVLB  E
0083E:  MOVF   x8D,W
00840:  CLRF   x8D
00842:  RRCF   x90,W
00844:  BNC   0842
00846:  MOVFF  E8D,67A
....................    data.dBytes[2] = spi_read2(0);
0084A:  MOVF   x8D,W
0084C:  CLRF   x8D
0084E:  RRCF   x90,W
00850:  BNC   084E
00852:  MOVFF  E8D,679
....................    data.dBytes[1] = spi_read2(0);
00856:  MOVF   x8D,W
00858:  CLRF   x8D
0085A:  RRCF   x90,W
0085C:  BNC   085A
0085E:  MOVFF  E8D,678
....................    
....................    ads_deselect_all();
00862:  MOVLB  0
00864:  RCALL  0136
....................    return data.dWord;
00866:  MOVFF  677,00
0086A:  MOVFF  678,01
0086E:  MOVFF  679,02
00872:  MOVFF  67A,03
00876:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE A CHANNEL                                                      */
.................... /*****************************************************************************/
.................... 
.................... void ADS1220init(int8 ch, rc0=reg0config, rc1=reg1config, rc2=reg2config, rc3=reg3config)
.................... {
....................    ads_write_command(ch, ADSreset);   //reset the device
*
0073A:  MOVFF  66B,674
0073E:  MOVLW  06
00740:  MOVLB  6
00742:  MOVWF  x75
00744:  MOVLB  0
00746:  RCALL  06D8
....................    delay_us(300);                    
00748:  MOVLW  02
0074A:  MOVLB  6
0074C:  MOVWF  x70
0074E:  MOVLW  96
00750:  MOVWF  x71
00752:  MOVLB  0
00754:  BRA    06EE
00756:  MOVLB  6
00758:  DECFSZ x70,F
0075A:  BRA    074E
....................    ads_write_reg(ch, reg0, rc0);   //send default configurations
0075C:  MOVFF  66B,670
00760:  CLRF   x71
00762:  MOVFF  66C,672
00766:  MOVLB  0
00768:  RCALL  0714
....................    ads_write_reg(ch, reg1, rc1);
0076A:  MOVFF  66B,670
0076E:  MOVLW  04
00770:  MOVLB  6
00772:  MOVWF  x71
00774:  MOVFF  66D,672
00778:  MOVLB  0
0077A:  RCALL  0714
....................    ads_write_reg(ch, reg2, rc2);
0077C:  MOVFF  66B,670
00780:  MOVLW  08
00782:  MOVLB  6
00784:  MOVWF  x71
00786:  MOVFF  66E,672
0078A:  MOVLB  0
0078C:  RCALL  0714
....................    ads_write_reg(ch, reg3, rc3);  
0078E:  MOVFF  66B,670
00792:  MOVLW  0C
00794:  MOVLB  6
00796:  MOVWF  x71
00798:  MOVFF  66F,672
0079C:  MOVLB  0
0079E:  RCALL  0714
007A0:  GOTO   08B0 (RETURN)
.................... }
.................... #endif 
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
*
031F4:  MOVLB  6
031F6:  BCF    xAE.0
....................    y = x;
031F8:  MOVFF  6A2,6A7
031FC:  MOVFF  6A1,6A6
03200:  MOVFF  6A0,6A5
03204:  MOVFF  69F,6A4
.................... 
....................    if (x < 0)
03208:  MOVFF  6A2,6B2
0320C:  MOVFF  6A1,6B1
03210:  MOVFF  6A0,6B0
03214:  MOVFF  69F,6AF
03218:  CLRF   xB6
0321A:  CLRF   xB5
0321C:  CLRF   xB4
0321E:  CLRF   xB3
03220:  MOVLB  0
03222:  CALL   27C4
03226:  BNC   3234
....................    {
....................       s = 1;
03228:  MOVLB  6
0322A:  BSF    xAE.0
....................       y = -y;
0322C:  MOVF   xA5,W
0322E:  XORLW  80
03230:  MOVWF  xA5
03232:  MOVLB  0
....................    }
.................... 
....................    if (y <= 32768.0)
03234:  MOVFF  6A7,6B2
03238:  MOVFF  6A6,6B1
0323C:  MOVFF  6A5,6B0
03240:  MOVFF  6A4,6AF
03244:  MOVLB  6
03246:  CLRF   xB6
03248:  CLRF   xB5
0324A:  CLRF   xB4
0324C:  MOVLW  8E
0324E:  MOVWF  xB3
03250:  MOVLB  0
03252:  CALL   27C4
03256:  BC    325A
03258:  BNZ   328A
....................       res = (float32)(unsigned int16)y;
0325A:  MOVFF  6A7,6B2
0325E:  MOVFF  6A6,6B1
03262:  MOVFF  6A5,6B0
03266:  MOVFF  6A4,6AF
0326A:  RCALL  31B8
0326C:  MOVFF  02,6B4
03270:  MOVFF  01,6B3
03274:  CALL   12C2
03278:  MOVFF  03,6AB
0327C:  MOVFF  02,6AA
03280:  MOVFF  01,6A9
03284:  MOVFF  00,6A8
03288:  BRA    342C
.................... 
....................  else if (y < 10000000.0)
0328A:  MOVFF  6A7,6B2
0328E:  MOVFF  6A6,6B1
03292:  MOVFF  6A5,6B0
03296:  MOVFF  6A4,6AF
0329A:  MOVLW  80
0329C:  MOVLB  6
0329E:  MOVWF  xB6
032A0:  MOVLW  96
032A2:  MOVWF  xB5
032A4:  MOVLW  18
032A6:  MOVWF  xB4
032A8:  MOVLW  96
032AA:  MOVWF  xB3
032AC:  MOVLB  0
032AE:  CALL   27C4
032B2:  BTFSS  FD8.0
032B4:  BRA    341C
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
032B6:  MOVFF  6A7,6B7
032BA:  MOVFF  6A6,6B6
032BE:  MOVFF  6A5,6B5
032C2:  MOVFF  6A4,6B4
032C6:  MOVLB  6
032C8:  CLRF   xBB
032CA:  CLRF   xBA
032CC:  CLRF   xB9
032CE:  MOVLW  70
032D0:  MOVWF  xB8
032D2:  MOVLB  0
032D4:  CALL   12F8
032D8:  MOVFF  03,6B2
032DC:  MOVFF  02,6B1
032E0:  MOVFF  01,6B0
032E4:  MOVFF  00,6AF
032E8:  RCALL  31B8
032EA:  MOVFF  02,6AD
032EE:  MOVFF  01,6AC
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
032F2:  MOVFF  6A7,6B7
032F6:  MOVFF  6A6,6B6
032FA:  MOVFF  6A5,6B5
032FE:  MOVFF  6A4,6B4
03302:  MOVLB  6
03304:  CLRF   xBB
03306:  CLRF   xBA
03308:  CLRF   xB9
0330A:  MOVLW  70
0330C:  MOVWF  xB8
0330E:  MOVLB  0
03310:  CALL   12F8
03314:  MOVFF  03,6B2
03318:  MOVFF  02,6B1
0331C:  MOVFF  01,6B0
03320:  MOVFF  00,6AF
03324:  MOVFF  6AD,6B4
03328:  MOVFF  6AC,6B3
0332C:  CALL   12C2
03330:  BSF    FD8.1
03332:  MOVFF  6B2,6B6
03336:  MOVFF  6B1,6B5
0333A:  MOVFF  6B0,6B4
0333E:  MOVFF  6AF,6B3
03342:  MOVFF  03,6BA
03346:  MOVFF  02,6B9
0334A:  MOVFF  01,6B8
0334E:  MOVFF  00,6B7
03352:  CALL   13EE
03356:  MOVLB  6
03358:  CLRF   xB7
0335A:  CLRF   xB6
0335C:  CLRF   xB5
0335E:  MOVLW  8E
03360:  MOVWF  xB4
03362:  MOVFF  03,6BB
03366:  MOVFF  02,6BA
0336A:  MOVFF  01,6B9
0336E:  MOVFF  00,6B8
03372:  MOVLB  0
03374:  CALL   12F8
03378:  MOVFF  03,6A7
0337C:  MOVFF  02,6A6
03380:  MOVFF  01,6A5
03384:  MOVFF  00,6A4
....................       res = 32768.0*(float32)l;
03388:  MOVFF  6AD,6B4
0338C:  MOVFF  6AC,6B3
03390:  CALL   12C2
03394:  MOVLB  6
03396:  CLRF   xB7
03398:  CLRF   xB6
0339A:  CLRF   xB5
0339C:  MOVLW  8E
0339E:  MOVWF  xB4
033A0:  MOVFF  03,6BB
033A4:  MOVFF  02,6BA
033A8:  MOVFF  01,6B9
033AC:  MOVFF  00,6B8
033B0:  MOVLB  0
033B2:  CALL   12F8
033B6:  MOVFF  03,6AB
033BA:  MOVFF  02,6AA
033BE:  MOVFF  01,6A9
033C2:  MOVFF  00,6A8
....................       res += (float32)(unsigned int16)y;
033C6:  MOVFF  6A7,6B2
033CA:  MOVFF  6A6,6B1
033CE:  MOVFF  6A5,6B0
033D2:  MOVFF  6A4,6AF
033D6:  RCALL  31B8
033D8:  MOVFF  02,6B4
033DC:  MOVFF  01,6B3
033E0:  CALL   12C2
033E4:  BCF    FD8.1
033E6:  MOVFF  6AB,6B6
033EA:  MOVFF  6AA,6B5
033EE:  MOVFF  6A9,6B4
033F2:  MOVFF  6A8,6B3
033F6:  MOVFF  03,6BA
033FA:  MOVFF  02,6B9
033FE:  MOVFF  01,6B8
03402:  MOVFF  00,6B7
03406:  CALL   13EE
0340A:  MOVFF  03,6AB
0340E:  MOVFF  02,6AA
03412:  MOVFF  01,6A9
03416:  MOVFF  00,6A8
....................    }
0341A:  BRA    342C
.................... 
....................  else
....................   res = y;
0341C:  MOVFF  6A7,6AB
03420:  MOVFF  6A6,6AA
03424:  MOVFF  6A5,6A9
03428:  MOVFF  6A4,6A8
.................... 
....................  y = y - (float32)(unsigned int16)y;
0342C:  MOVFF  6A7,6B2
03430:  MOVFF  6A6,6B1
03434:  MOVFF  6A5,6B0
03438:  MOVFF  6A4,6AF
0343C:  RCALL  31B8
0343E:  MOVFF  02,6B4
03442:  MOVFF  01,6B3
03446:  CALL   12C2
0344A:  BSF    FD8.1
0344C:  MOVFF  6A7,6B6
03450:  MOVFF  6A6,6B5
03454:  MOVFF  6A5,6B4
03458:  MOVFF  6A4,6B3
0345C:  MOVFF  03,6BA
03460:  MOVFF  02,6B9
03464:  MOVFF  01,6B8
03468:  MOVFF  00,6B7
0346C:  CALL   13EE
03470:  MOVFF  03,6A7
03474:  MOVFF  02,6A6
03478:  MOVFF  01,6A5
0347C:  MOVFF  00,6A4
.................... 
....................  if (s)
03480:  MOVLB  6
03482:  BTFSS  xAE.0
03484:  BRA    348C
....................   res = -res;
03486:  MOVF   xA9,W
03488:  XORLW  80
0348A:  MOVWF  xA9
.................... 
....................  if (y != 0)
0348C:  MOVFF  6A7,6B2
03490:  MOVFF  6A6,6B1
03494:  MOVFF  6A5,6B0
03498:  MOVFF  6A4,6AF
0349C:  CLRF   xB6
0349E:  CLRF   xB5
034A0:  CLRF   xB4
034A2:  CLRF   xB3
034A4:  MOVLB  0
034A6:  CALL   27C4
034AA:  BZ    3524
....................  {
....................   if (s == 1 && n == 0)
034AC:  MOVLB  6
034AE:  BTFSS  xAE.0
034B0:  BRA    34EA
034B2:  MOVF   xA3,F
034B4:  BNZ   34EA
....................    res -= 1.0;
034B6:  BSF    FD8.1
034B8:  MOVFF  6AB,6B6
034BC:  MOVFF  6AA,6B5
034C0:  MOVFF  6A9,6B4
034C4:  MOVFF  6A8,6B3
034C8:  CLRF   xBA
034CA:  CLRF   xB9
034CC:  CLRF   xB8
034CE:  MOVLW  7F
034D0:  MOVWF  xB7
034D2:  MOVLB  0
034D4:  CALL   13EE
034D8:  MOVFF  03,6AB
034DC:  MOVFF  02,6AA
034E0:  MOVFF  01,6A9
034E4:  MOVFF  00,6A8
034E8:  MOVLB  6
.................... 
....................   if (s == 0 && n == 1)
034EA:  BTFSC  xAE.0
034EC:  BRA    3526
034EE:  DECFSZ xA3,W
034F0:  BRA    3526
....................    res += 1.0;
034F2:  BCF    FD8.1
034F4:  MOVFF  6AB,6B6
034F8:  MOVFF  6AA,6B5
034FC:  MOVFF  6A9,6B4
03500:  MOVFF  6A8,6B3
03504:  CLRF   xBA
03506:  CLRF   xB9
03508:  CLRF   xB8
0350A:  MOVLW  7F
0350C:  MOVWF  xB7
0350E:  MOVLB  0
03510:  CALL   13EE
03514:  MOVFF  03,6AB
03518:  MOVFF  02,6AA
0351C:  MOVFF  01,6A9
03520:  MOVFF  00,6A8
03524:  MOVLB  6
....................  }
....................  if (x == 0)
03526:  MOVFF  6A2,6B2
0352A:  MOVFF  6A1,6B1
0352E:  MOVFF  6A0,6B0
03532:  MOVFF  69F,6AF
03536:  CLRF   xB6
03538:  CLRF   xB5
0353A:  CLRF   xB4
0353C:  CLRF   xB3
0353E:  MOVLB  0
03540:  CALL   27C4
03544:  BNZ   3552
....................     res = 0;
03546:  MOVLB  6
03548:  CLRF   xAB
0354A:  CLRF   xAA
0354C:  CLRF   xA9
0354E:  CLRF   xA8
03550:  MOVLB  0
.................... 
....................  return (res);
03552:  MOVFF  6A8,00
03556:  MOVFF  6A9,01
0355A:  MOVFF  6AA,02
0355E:  MOVFF  6AB,03
03562:  RETURN 0
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
*
03582:  MOVFF  69E,6A2
03586:  MOVFF  69D,6A1
0358A:  MOVFF  69C,6A0
0358E:  MOVFF  69B,69F
03592:  MOVLB  6
03594:  CLRF   xA3
03596:  MOVLB  0
03598:  RCALL  31F4
0359A:  GOTO   36A6 (RETURN)
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
*
03564:  MOVFF  69E,6A2
03568:  MOVFF  69D,6A1
0356C:  MOVFF  69C,6A0
03570:  MOVFF  69B,69F
03574:  MOVLW  01
03576:  MOVLB  6
03578:  MOVWF  xA3
0357A:  MOVLB  0
0357C:  RCALL  31F4
0357E:  GOTO   365E (RETURN)
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
*
0359E:  MOVFF  692,6B2
035A2:  MOVFF  691,6B1
035A6:  MOVFF  690,6B0
035AA:  MOVFF  68F,6AF
035AE:  MOVLB  6
035B0:  CLRF   xB6
035B2:  CLRF   xB5
035B4:  CLRF   xB4
035B6:  CLRF   xB3
035B8:  MOVLB  0
035BA:  CALL   27C4
035BE:  BTFSC  FD8.2
035C0:  BRA    3702
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
035C2:  MOVFF  68E,6AB
035C6:  MOVFF  68D,6AA
035CA:  MOVFF  68C,6A9
035CE:  MOVFF  68B,6A8
035D2:  MOVFF  692,6AF
035D6:  MOVFF  691,6AE
035DA:  MOVFF  690,6AD
035DE:  MOVFF  68F,6AC
035E2:  CALL   283E
035E6:  MOVFF  03,69A
035EA:  MOVFF  02,699
035EE:  MOVFF  01,698
035F2:  MOVFF  00,697
035F6:  MOVFF  03,6B2
035FA:  MOVFF  02,6B1
035FE:  MOVFF  01,6B0
03602:  MOVFF  00,6AF
03606:  MOVLB  6
03608:  CLRF   xB6
0360A:  CLRF   xB5
0360C:  CLRF   xB4
0360E:  CLRF   xB3
03610:  MOVLB  0
03612:  CALL   27C4
03616:  BNC   3660
03618:  MOVFF  68E,6AB
0361C:  MOVFF  68D,6AA
03620:  MOVFF  68C,6A9
03624:  MOVFF  68B,6A8
03628:  MOVFF  692,6AF
0362C:  MOVFF  691,6AE
03630:  MOVFF  690,6AD
03634:  MOVFF  68F,6AC
03638:  CALL   283E
0363C:  MOVFF  03,69A
03640:  MOVFF  02,699
03644:  MOVFF  01,698
03648:  MOVFF  00,697
0364C:  MOVFF  03,69E
03650:  MOVFF  02,69D
03654:  MOVFF  01,69C
03658:  MOVFF  00,69B
0365C:  BRA    3564
0365E:  BRA    36A6
03660:  MOVFF  68E,6AB
03664:  MOVFF  68D,6AA
03668:  MOVFF  68C,6A9
0366C:  MOVFF  68B,6A8
03670:  MOVFF  692,6AF
03674:  MOVFF  691,6AE
03678:  MOVFF  690,6AD
0367C:  MOVFF  68F,6AC
03680:  CALL   283E
03684:  MOVFF  03,69A
03688:  MOVFF  02,699
0368C:  MOVFF  01,698
03690:  MOVFF  00,697
03694:  MOVFF  03,69E
03698:  MOVFF  02,69D
0369C:  MOVFF  01,69C
036A0:  MOVFF  00,69B
036A4:  BRA    3582
036A6:  MOVFF  03,696
036AA:  MOVFF  02,695
036AE:  MOVFF  01,694
036B2:  MOVFF  00,693
....................       return(x-(i*y));
036B6:  MOVFF  696,6B7
036BA:  MOVFF  695,6B6
036BE:  MOVFF  694,6B5
036C2:  MOVFF  693,6B4
036C6:  MOVFF  692,6BB
036CA:  MOVFF  691,6BA
036CE:  MOVFF  690,6B9
036D2:  MOVFF  68F,6B8
036D6:  CALL   12F8
036DA:  BSF    FD8.1
036DC:  MOVFF  68E,6B6
036E0:  MOVFF  68D,6B5
036E4:  MOVFF  68C,6B4
036E8:  MOVFF  68B,6B3
036EC:  MOVFF  03,6BA
036F0:  MOVFF  02,6B9
036F4:  MOVFF  01,6B8
036F8:  MOVFF  00,6B7
036FC:  CALL   13EE
03700:  BRA    3702
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
03702:  RETURN 0
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
*
03A98:  MOVFF  692,6B7
03A9C:  MOVFF  691,6B6
03AA0:  MOVFF  690,6B5
03AA4:  MOVFF  68F,6B4
03AA8:  MOVLW  3B
03AAA:  MOVLB  6
03AAC:  MOVWF  xBB
03AAE:  MOVLW  AA
03AB0:  MOVWF  xBA
03AB2:  MOVLW  38
03AB4:  MOVWF  xB9
03AB6:  MOVLW  7F
03AB8:  MOVWF  xB8
03ABA:  MOVLB  0
03ABC:  CALL   12F8
03AC0:  MOVFF  03,6B2
03AC4:  MOVFF  02,6B1
03AC8:  MOVFF  01,6B0
03ACC:  MOVFF  00,6AF
03AD0:  CALL   31B8
03AD4:  MOVFF  01,69F
....................    s = 0;
03AD8:  MOVLB  6
03ADA:  BCF    xA0.0
....................    y = x;
03ADC:  MOVFF  692,696
03AE0:  MOVFF  691,695
03AE4:  MOVFF  690,694
03AE8:  MOVFF  68F,693
.................... 
....................    if (x < 0)
03AEC:  MOVFF  692,6B2
03AF0:  MOVFF  691,6B1
03AF4:  MOVFF  690,6B0
03AF8:  MOVFF  68F,6AF
03AFC:  CLRF   xB6
03AFE:  CLRF   xB5
03B00:  CLRF   xB4
03B02:  CLRF   xB3
03B04:  MOVLB  0
03B06:  CALL   27C4
03B0A:  BNC   3B1A
....................    {
....................       s = 1;
03B0C:  MOVLB  6
03B0E:  BSF    xA0.0
....................       n = -n;
03B10:  NEGF   x9F
....................       y = -y;
03B12:  MOVF   x94,W
03B14:  XORLW  80
03B16:  MOVWF  x94
03B18:  MOVLB  0
....................    }
.................... 
....................    res = 0.0;
03B1A:  MOVLB  6
03B1C:  CLRF   x9A
03B1E:  CLRF   x99
03B20:  CLRF   x98
03B22:  CLRF   x97
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
03B24:  MOVLW  06
03B26:  MOVWF  xA2
03B28:  MOVLW  97
03B2A:  MOVFF  6A2,FEA
03B2E:  MOVWF  FE9
03B30:  MOVLW  7F
03B32:  ADDWF  x9F,W
03B34:  MOVWF  FEF
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
03B36:  MOVFF  696,6B7
03B3A:  MOVFF  695,6B6
03B3E:  MOVFF  694,6B5
03B42:  MOVFF  693,6B4
03B46:  MOVLW  3B
03B48:  MOVWF  xBB
03B4A:  MOVLW  AA
03B4C:  MOVWF  xBA
03B4E:  MOVLW  38
03B50:  MOVWF  xB9
03B52:  MOVLW  7F
03B54:  MOVWF  xB8
03B56:  MOVLB  0
03B58:  CALL   12F8
03B5C:  MOVFF  03,6A4
03B60:  MOVFF  02,6A3
03B64:  MOVFF  01,6A2
03B68:  MOVFF  00,6A1
03B6C:  MOVLB  6
03B6E:  CLRF   xA6
03B70:  MOVFF  69F,6A5
03B74:  BTFSC  xA5.7
03B76:  DECF   xA6,F
03B78:  MOVLB  0
03B7A:  CALL   3168
03B7E:  BSF    FD8.1
03B80:  MOVFF  6A4,6B6
03B84:  MOVFF  6A3,6B5
03B88:  MOVFF  6A2,6B4
03B8C:  MOVFF  6A1,6B3
03B90:  MOVFF  03,6BA
03B94:  MOVFF  02,6B9
03B98:  MOVFF  01,6B8
03B9C:  MOVFF  00,6B7
03BA0:  CALL   13EE
03BA4:  MOVFF  03,696
03BA8:  MOVFF  02,695
03BAC:  MOVFF  01,694
03BB0:  MOVFF  00,693
.................... 
....................    r = pe[0]*y + pe[1];
03BB4:  MOVLW  7C
03BB6:  MOVLB  6
03BB8:  MOVWF  xB7
03BBA:  MOVLW  88
03BBC:  MOVWF  xB6
03BBE:  MOVLW  59
03BC0:  MOVWF  xB5
03BC2:  MOVLW  72
03BC4:  MOVWF  xB4
03BC6:  MOVFF  696,6BB
03BCA:  MOVFF  695,6BA
03BCE:  MOVFF  694,6B9
03BD2:  MOVFF  693,6B8
03BD6:  MOVLB  0
03BD8:  CALL   12F8
03BDC:  MOVFF  03,6A4
03BE0:  MOVFF  02,6A3
03BE4:  MOVFF  01,6A2
03BE8:  MOVFF  00,6A1
03BEC:  BCF    FD8.1
03BEE:  MOVFF  03,6B6
03BF2:  MOVFF  02,6B5
03BF6:  MOVFF  01,6B4
03BFA:  MOVFF  00,6B3
03BFE:  MOVLW  E0
03C00:  MOVLB  6
03C02:  MOVWF  xBA
03C04:  MOVLW  97
03C06:  MOVWF  xB9
03C08:  MOVLW  26
03C0A:  MOVWF  xB8
03C0C:  MOVLW  75
03C0E:  MOVWF  xB7
03C10:  MOVLB  0
03C12:  CALL   13EE
03C16:  MOVFF  03,69E
03C1A:  MOVFF  02,69D
03C1E:  MOVFF  01,69C
03C22:  MOVFF  00,69B
....................    r = r*y + pe[2];
03C26:  MOVFF  69E,6B7
03C2A:  MOVFF  69D,6B6
03C2E:  MOVFF  69C,6B5
03C32:  MOVFF  69B,6B4
03C36:  MOVFF  696,6BB
03C3A:  MOVFF  695,6BA
03C3E:  MOVFF  694,6B9
03C42:  MOVFF  693,6B8
03C46:  CALL   12F8
03C4A:  MOVFF  03,6A4
03C4E:  MOVFF  02,6A3
03C52:  MOVFF  01,6A2
03C56:  MOVFF  00,6A1
03C5A:  BCF    FD8.1
03C5C:  MOVFF  03,6B6
03C60:  MOVFF  02,6B5
03C64:  MOVFF  01,6B4
03C68:  MOVFF  00,6B3
03C6C:  MOVLW  C4
03C6E:  MOVLB  6
03C70:  MOVWF  xBA
03C72:  MOVLW  1D
03C74:  MOVWF  xB9
03C76:  MOVLW  1E
03C78:  MOVWF  xB8
03C7A:  MOVLW  78
03C7C:  MOVWF  xB7
03C7E:  MOVLB  0
03C80:  CALL   13EE
03C84:  MOVFF  03,69E
03C88:  MOVFF  02,69D
03C8C:  MOVFF  01,69C
03C90:  MOVFF  00,69B
....................    r = r*y + pe[3];
03C94:  MOVFF  69E,6B7
03C98:  MOVFF  69D,6B6
03C9C:  MOVFF  69C,6B5
03CA0:  MOVFF  69B,6B4
03CA4:  MOVFF  696,6BB
03CA8:  MOVFF  695,6BA
03CAC:  MOVFF  694,6B9
03CB0:  MOVFF  693,6B8
03CB4:  CALL   12F8
03CB8:  MOVFF  03,6A4
03CBC:  MOVFF  02,6A3
03CC0:  MOVFF  01,6A2
03CC4:  MOVFF  00,6A1
03CC8:  BCF    FD8.1
03CCA:  MOVFF  03,6B6
03CCE:  MOVFF  02,6B5
03CD2:  MOVFF  01,6B4
03CD6:  MOVFF  00,6B3
03CDA:  MOVLW  5E
03CDC:  MOVLB  6
03CDE:  MOVWF  xBA
03CE0:  MOVLW  50
03CE2:  MOVWF  xB9
03CE4:  MOVLW  63
03CE6:  MOVWF  xB8
03CE8:  MOVLW  7A
03CEA:  MOVWF  xB7
03CEC:  MOVLB  0
03CEE:  CALL   13EE
03CF2:  MOVFF  03,69E
03CF6:  MOVFF  02,69D
03CFA:  MOVFF  01,69C
03CFE:  MOVFF  00,69B
....................    r = r*y + pe[4];
03D02:  MOVFF  69E,6B7
03D06:  MOVFF  69D,6B6
03D0A:  MOVFF  69C,6B5
03D0E:  MOVFF  69B,6B4
03D12:  MOVFF  696,6BB
03D16:  MOVFF  695,6BA
03D1A:  MOVFF  694,6B9
03D1E:  MOVFF  693,6B8
03D22:  CALL   12F8
03D26:  MOVFF  03,6A4
03D2A:  MOVFF  02,6A3
03D2E:  MOVFF  01,6A2
03D32:  MOVFF  00,6A1
03D36:  BCF    FD8.1
03D38:  MOVFF  03,6B6
03D3C:  MOVFF  02,6B5
03D40:  MOVFF  01,6B4
03D44:  MOVFF  00,6B3
03D48:  MOVLW  1A
03D4A:  MOVLB  6
03D4C:  MOVWF  xBA
03D4E:  MOVLW  FE
03D50:  MOVWF  xB9
03D52:  MOVLW  75
03D54:  MOVWF  xB8
03D56:  MOVLW  7C
03D58:  MOVWF  xB7
03D5A:  MOVLB  0
03D5C:  CALL   13EE
03D60:  MOVFF  03,69E
03D64:  MOVFF  02,69D
03D68:  MOVFF  01,69C
03D6C:  MOVFF  00,69B
....................    r = r*y + pe[5];
03D70:  MOVFF  69E,6B7
03D74:  MOVFF  69D,6B6
03D78:  MOVFF  69C,6B5
03D7C:  MOVFF  69B,6B4
03D80:  MOVFF  696,6BB
03D84:  MOVFF  695,6BA
03D88:  MOVFF  694,6B9
03D8C:  MOVFF  693,6B8
03D90:  CALL   12F8
03D94:  MOVFF  03,6A4
03D98:  MOVFF  02,6A3
03D9C:  MOVFF  01,6A2
03DA0:  MOVFF  00,6A1
03DA4:  BCF    FD8.1
03DA6:  MOVFF  03,6B6
03DAA:  MOVFF  02,6B5
03DAE:  MOVFF  01,6B4
03DB2:  MOVFF  00,6B3
03DB6:  MOVLW  18
03DB8:  MOVLB  6
03DBA:  MOVWF  xBA
03DBC:  MOVLW  72
03DBE:  MOVWF  xB9
03DC0:  MOVLW  31
03DC2:  MOVWF  xB8
03DC4:  MOVLW  7E
03DC6:  MOVWF  xB7
03DC8:  MOVLB  0
03DCA:  CALL   13EE
03DCE:  MOVFF  03,69E
03DD2:  MOVFF  02,69D
03DD6:  MOVFF  01,69C
03DDA:  MOVFF  00,69B
.................... 
....................    res = res*(1.0 + y*r);
03DDE:  MOVFF  696,6B7
03DE2:  MOVFF  695,6B6
03DE6:  MOVFF  694,6B5
03DEA:  MOVFF  693,6B4
03DEE:  MOVFF  69E,6BB
03DF2:  MOVFF  69D,6BA
03DF6:  MOVFF  69C,6B9
03DFA:  MOVFF  69B,6B8
03DFE:  CALL   12F8
03E02:  BCF    FD8.1
03E04:  MOVLB  6
03E06:  CLRF   xB6
03E08:  CLRF   xB5
03E0A:  CLRF   xB4
03E0C:  MOVLW  7F
03E0E:  MOVWF  xB3
03E10:  MOVFF  03,6BA
03E14:  MOVFF  02,6B9
03E18:  MOVFF  01,6B8
03E1C:  MOVFF  00,6B7
03E20:  MOVLB  0
03E22:  CALL   13EE
03E26:  MOVFF  69A,6B7
03E2A:  MOVFF  699,6B6
03E2E:  MOVFF  698,6B5
03E32:  MOVFF  697,6B4
03E36:  MOVFF  03,6BB
03E3A:  MOVFF  02,6BA
03E3E:  MOVFF  01,6B9
03E42:  MOVFF  00,6B8
03E46:  CALL   12F8
03E4A:  MOVFF  03,69A
03E4E:  MOVFF  02,699
03E52:  MOVFF  01,698
03E56:  MOVFF  00,697
.................... 
....................    if (s)
03E5A:  MOVLB  6
03E5C:  BTFSS  xA0.0
03E5E:  BRA    3E92
....................       res = 1.0/res;
03E60:  CLRF   xAB
03E62:  CLRF   xAA
03E64:  CLRF   xA9
03E66:  MOVLW  7F
03E68:  MOVWF  xA8
03E6A:  MOVFF  69A,6AF
03E6E:  MOVFF  699,6AE
03E72:  MOVFF  698,6AD
03E76:  MOVFF  697,6AC
03E7A:  MOVLB  0
03E7C:  CALL   283E
03E80:  MOVFF  03,69A
03E84:  MOVFF  02,699
03E88:  MOVFF  01,698
03E8C:  MOVFF  00,697
03E90:  MOVLB  6
....................    return(res);
03E92:  MOVFF  697,00
03E96:  MOVFF  698,01
03E9A:  MOVFF  699,02
03E9E:  MOVFF  69A,03
03EA2:  MOVLB  0
03EA4:  RETURN 0
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
*
03704:  MOVFF  692,696
03708:  MOVFF  691,695
0370C:  MOVFF  690,694
03710:  MOVFF  68F,693
.................... 
....................    if (y != 1.0)
03714:  MOVFF  696,6B2
03718:  MOVFF  695,6B1
0371C:  MOVFF  694,6B0
03720:  MOVFF  693,6AF
03724:  MOVLB  6
03726:  CLRF   xB6
03728:  CLRF   xB5
0372A:  CLRF   xB4
0372C:  MOVLW  7F
0372E:  MOVWF  xB3
03730:  MOVLB  0
03732:  CALL   27C4
03736:  BTFSC  FD8.2
03738:  BRA    3A7A
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
0373A:  MOVLW  06
0373C:  MOVLB  6
0373E:  MOVWF  xA5
03740:  MOVLW  93
03742:  MOVFF  6A5,FEA
03746:  MOVWF  FE9
03748:  MOVLW  7E
0374A:  MOVWF  FEF
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
0374C:  BSF    FD8.1
0374E:  MOVFF  696,6B6
03752:  MOVFF  695,6B5
03756:  MOVFF  694,6B4
0375A:  MOVFF  693,6B3
0375E:  CLRF   xBA
03760:  CLRF   xB9
03762:  CLRF   xB8
03764:  MOVLW  7F
03766:  MOVWF  xB7
03768:  MOVLB  0
0376A:  CALL   13EE
0376E:  MOVFF  03,6A7
03772:  MOVFF  02,6A6
03776:  MOVFF  01,6A5
0377A:  MOVFF  00,6A4
0377E:  BCF    FD8.1
03780:  MOVFF  696,6B6
03784:  MOVFF  695,6B5
03788:  MOVFF  694,6B4
0378C:  MOVFF  693,6B3
03790:  MOVLB  6
03792:  CLRF   xBA
03794:  CLRF   xB9
03796:  CLRF   xB8
03798:  MOVLW  7F
0379A:  MOVWF  xB7
0379C:  MOVLB  0
0379E:  CALL   13EE
037A2:  MOVFF  6A7,6AB
037A6:  MOVFF  6A6,6AA
037AA:  MOVFF  6A5,6A9
037AE:  MOVFF  6A4,6A8
037B2:  MOVFF  03,6AF
037B6:  MOVFF  02,6AE
037BA:  MOVFF  01,6AD
037BE:  MOVFF  00,6AC
037C2:  CALL   283E
037C6:  MOVFF  03,696
037CA:  MOVFF  02,695
037CE:  MOVFF  01,694
037D2:  MOVFF  00,693
.................... 
....................       y2=y*y;
037D6:  MOVFF  696,6B7
037DA:  MOVFF  695,6B6
037DE:  MOVFF  694,6B5
037E2:  MOVFF  693,6B4
037E6:  MOVFF  696,6BB
037EA:  MOVFF  695,6BA
037EE:  MOVFF  694,6B9
037F2:  MOVFF  693,6B8
037F6:  CALL   12F8
037FA:  MOVFF  03,6A2
037FE:  MOVFF  02,6A1
03802:  MOVFF  01,6A0
03806:  MOVFF  00,69F
.................... 
....................       res = pl[0]*y2 + pl[1];
0380A:  MOVLW  99
0380C:  MOVLB  6
0380E:  MOVWF  xB7
03810:  MOVLW  47
03812:  MOVWF  xB6
03814:  MOVLW  8A
03816:  MOVWF  xB5
03818:  MOVLW  7F
0381A:  MOVWF  xB4
0381C:  MOVFF  6A2,6BB
03820:  MOVFF  6A1,6BA
03824:  MOVFF  6A0,6B9
03828:  MOVFF  69F,6B8
0382C:  MOVLB  0
0382E:  CALL   12F8
03832:  MOVFF  03,6A7
03836:  MOVFF  02,6A6
0383A:  MOVFF  01,6A5
0383E:  MOVFF  00,6A4
03842:  BCF    FD8.1
03844:  MOVFF  03,6B6
03848:  MOVFF  02,6B5
0384C:  MOVFF  01,6B4
03850:  MOVFF  00,6B3
03854:  MOVLB  6
03856:  CLRF   xBA
03858:  CLRF   xB9
0385A:  CLRF   xB8
0385C:  MOVLW  80
0385E:  MOVWF  xB7
03860:  MOVLB  0
03862:  CALL   13EE
03866:  MOVFF  03,69A
0386A:  MOVFF  02,699
0386E:  MOVFF  01,698
03872:  MOVFF  00,697
.................... 
....................       r = ql[0]*y2 + ql[1];
03876:  MOVLW  4C
03878:  MOVLB  6
0387A:  MOVWF  xB7
0387C:  MOVLW  F3
0387E:  MOVWF  xB6
03880:  MOVLW  3A
03882:  MOVWF  xB5
03884:  MOVLW  7B
03886:  MOVWF  xB4
03888:  MOVFF  6A2,6BB
0388C:  MOVFF  6A1,6BA
03890:  MOVFF  6A0,6B9
03894:  MOVFF  69F,6B8
03898:  MOVLB  0
0389A:  CALL   12F8
0389E:  MOVFF  03,6A7
038A2:  MOVFF  02,6A6
038A6:  MOVFF  01,6A5
038AA:  MOVFF  00,6A4
038AE:  BCF    FD8.1
038B0:  MOVFF  03,6B6
038B4:  MOVFF  02,6B5
038B8:  MOVFF  01,6B4
038BC:  MOVFF  00,6B3
038C0:  MOVLW  2B
038C2:  MOVLB  6
038C4:  MOVWF  xBA
038C6:  MOVLW  9D
038C8:  MOVWF  xB9
038CA:  MOVLW  DF
038CC:  MOVWF  xB8
038CE:  MOVLW  7E
038D0:  MOVWF  xB7
038D2:  MOVLB  0
038D4:  CALL   13EE
038D8:  MOVFF  03,69E
038DC:  MOVFF  02,69D
038E0:  MOVFF  01,69C
038E4:  MOVFF  00,69B
....................       r = r*y2 + 1.0;
038E8:  MOVFF  69E,6B7
038EC:  MOVFF  69D,6B6
038F0:  MOVFF  69C,6B5
038F4:  MOVFF  69B,6B4
038F8:  MOVFF  6A2,6BB
038FC:  MOVFF  6A1,6BA
03900:  MOVFF  6A0,6B9
03904:  MOVFF  69F,6B8
03908:  CALL   12F8
0390C:  MOVFF  03,6A7
03910:  MOVFF  02,6A6
03914:  MOVFF  01,6A5
03918:  MOVFF  00,6A4
0391C:  BCF    FD8.1
0391E:  MOVFF  03,6B6
03922:  MOVFF  02,6B5
03926:  MOVFF  01,6B4
0392A:  MOVFF  00,6B3
0392E:  MOVLB  6
03930:  CLRF   xBA
03932:  CLRF   xB9
03934:  CLRF   xB8
03936:  MOVLW  7F
03938:  MOVWF  xB7
0393A:  MOVLB  0
0393C:  CALL   13EE
03940:  MOVFF  03,69E
03944:  MOVFF  02,69D
03948:  MOVFF  01,69C
0394C:  MOVFF  00,69B
.................... 
....................       res = y*res/r;
03950:  MOVFF  696,6B7
03954:  MOVFF  695,6B6
03958:  MOVFF  694,6B5
0395C:  MOVFF  693,6B4
03960:  MOVFF  69A,6BB
03964:  MOVFF  699,6BA
03968:  MOVFF  698,6B9
0396C:  MOVFF  697,6B8
03970:  CALL   12F8
03974:  MOVFF  03,6A7
03978:  MOVFF  02,6A6
0397C:  MOVFF  01,6A5
03980:  MOVFF  00,6A4
03984:  MOVFF  03,6AB
03988:  MOVFF  02,6AA
0398C:  MOVFF  01,6A9
03990:  MOVFF  00,6A8
03994:  MOVFF  69E,6AF
03998:  MOVFF  69D,6AE
0399C:  MOVFF  69C,6AD
039A0:  MOVFF  69B,6AC
039A4:  CALL   283E
039A8:  MOVFF  03,69A
039AC:  MOVFF  02,699
039B0:  MOVFF  01,698
039B4:  MOVFF  00,697
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
039B8:  MOVLW  06
039BA:  MOVLB  6
039BC:  MOVWF  xA5
039BE:  MOVLW  8F
039C0:  MOVFF  6A5,FEA
039C4:  MOVWF  FE9
039C6:  MOVLW  7E
039C8:  SUBWF  FEF,W
039CA:  MOVWF  xA3
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
039CC:  BTFSS  xA3.7
039CE:  BRA    39FA
....................          r = -(float32)-n;
039D0:  MOVLW  00
039D2:  BSF    FD8.0
039D4:  SUBFWB xA3,W
039D6:  CLRF   xA6
039D8:  MOVWF  xA5
039DA:  BTFSC  xA5.7
039DC:  DECF   xA6,F
039DE:  MOVLB  0
039E0:  CALL   3168
039E4:  MOVFF  00,69B
039E8:  MOVF   01,W
039EA:  XORLW  80
039EC:  MOVLB  6
039EE:  MOVWF  x9C
039F0:  MOVFF  02,69D
039F4:  MOVFF  03,69E
039F8:  BRA    3A1C
....................       else
....................          r = (float32)n;
039FA:  CLRF   xA6
039FC:  MOVFF  6A3,6A5
03A00:  BTFSC  xA5.7
03A02:  DECF   xA6,F
03A04:  MOVLB  0
03A06:  CALL   3168
03A0A:  MOVFF  03,69E
03A0E:  MOVFF  02,69D
03A12:  MOVFF  01,69C
03A16:  MOVFF  00,69B
03A1A:  MOVLB  6
.................... 
....................       res += r*LN2;
03A1C:  MOVFF  69E,6B7
03A20:  MOVFF  69D,6B6
03A24:  MOVFF  69C,6B5
03A28:  MOVFF  69B,6B4
03A2C:  MOVLW  18
03A2E:  MOVWF  xBB
03A30:  MOVLW  72
03A32:  MOVWF  xBA
03A34:  MOVLW  31
03A36:  MOVWF  xB9
03A38:  MOVLW  7E
03A3A:  MOVWF  xB8
03A3C:  MOVLB  0
03A3E:  CALL   12F8
03A42:  BCF    FD8.1
03A44:  MOVFF  69A,6B6
03A48:  MOVFF  699,6B5
03A4C:  MOVFF  698,6B4
03A50:  MOVFF  697,6B3
03A54:  MOVFF  03,6BA
03A58:  MOVFF  02,6B9
03A5C:  MOVFF  01,6B8
03A60:  MOVFF  00,6B7
03A64:  CALL   13EE
03A68:  MOVFF  03,69A
03A6C:  MOVFF  02,699
03A70:  MOVFF  01,698
03A74:  MOVFF  00,697
....................    }
03A78:  BRA    3A86
.................... 
....................    else
....................       res = 0.0;
03A7A:  MOVLB  6
03A7C:  CLRF   x9A
03A7E:  CLRF   x99
03A80:  CLRF   x98
03A82:  CLRF   x97
03A84:  MOVLB  0
.................... 
....................    return(res);
03A86:  MOVFF  697,00
03A8A:  MOVFF  698,01
03A8E:  MOVFF  699,02
03A92:  MOVFF  69A,03
03A96:  RETURN 0
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
*
03EA6:  MOVFF  686,6B2
03EAA:  MOVFF  685,6B1
03EAE:  MOVFF  684,6B0
03EB2:  MOVFF  683,6AF
03EB6:  MOVLB  6
03EB8:  CLRF   xB6
03EBA:  CLRF   xB5
03EBC:  CLRF   xB4
03EBE:  CLRF   xB3
03EC0:  MOVLB  0
03EC2:  CALL   27C4
03EC6:  BTFSS  FD8.0
03EC8:  BRA    4064
03ECA:  MOVFF  68A,68E
03ECE:  MOVFF  689,68D
03ED2:  MOVFF  688,68C
03ED6:  MOVFF  687,68B
03EDA:  MOVLB  6
03EDC:  CLRF   x92
03EDE:  CLRF   x91
03EE0:  CLRF   x90
03EE2:  MOVLW  7F
03EE4:  MOVWF  x8F
03EE6:  MOVLB  0
03EE8:  CALL   359E
03EEC:  MOVFF  03,68E
03EF0:  MOVFF  02,68D
03EF4:  MOVFF  01,68C
03EF8:  MOVFF  00,68B
03EFC:  MOVFF  03,6B2
03F00:  MOVFF  02,6B1
03F04:  MOVFF  01,6B0
03F08:  MOVFF  00,6AF
03F0C:  MOVLB  6
03F0E:  CLRF   xB6
03F10:  CLRF   xB5
03F12:  CLRF   xB4
03F14:  CLRF   xB3
03F16:  MOVLB  0
03F18:  CALL   27C4
03F1C:  BTFSS  FD8.2
03F1E:  BRA    4064
....................       if(fmod(y, 2) == 0) {
03F20:  MOVFF  68A,68E
03F24:  MOVFF  689,68D
03F28:  MOVFF  688,68C
03F2C:  MOVFF  687,68B
03F30:  MOVLB  6
03F32:  CLRF   x92
03F34:  CLRF   x91
03F36:  CLRF   x90
03F38:  MOVLW  80
03F3A:  MOVWF  x8F
03F3C:  MOVLB  0
03F3E:  CALL   359E
03F42:  MOVFF  03,68E
03F46:  MOVFF  02,68D
03F4A:  MOVFF  01,68C
03F4E:  MOVFF  00,68B
03F52:  MOVFF  03,6B2
03F56:  MOVFF  02,6B1
03F5A:  MOVFF  01,6B0
03F5E:  MOVFF  00,6AF
03F62:  MOVLB  6
03F64:  CLRF   xB6
03F66:  CLRF   xB5
03F68:  CLRF   xB4
03F6A:  CLRF   xB3
03F6C:  MOVLB  0
03F6E:  CALL   27C4
03F72:  BNZ   3FEA
....................          return (exp(log(-x) * y));
03F74:  MOVLB  6
03F76:  MOVF   x84,W
03F78:  XORLW  80
03F7A:  MOVWF  x8C
03F7C:  MOVFF  686,692
03F80:  MOVFF  685,691
03F84:  MOVWF  x90
03F86:  MOVFF  683,68F
03F8A:  MOVLB  0
03F8C:  CALL   3704
03F90:  MOVFF  03,68E
03F94:  MOVFF  02,68D
03F98:  MOVFF  01,68C
03F9C:  MOVFF  00,68B
03FA0:  MOVFF  03,6B7
03FA4:  MOVFF  02,6B6
03FA8:  MOVFF  01,6B5
03FAC:  MOVFF  00,6B4
03FB0:  MOVFF  68A,6BB
03FB4:  MOVFF  689,6BA
03FB8:  MOVFF  688,6B9
03FBC:  MOVFF  687,6B8
03FC0:  CALL   12F8
03FC4:  MOVFF  03,68E
03FC8:  MOVFF  02,68D
03FCC:  MOVFF  01,68C
03FD0:  MOVFF  00,68B
03FD4:  MOVFF  03,692
03FD8:  MOVFF  02,691
03FDC:  MOVFF  01,690
03FE0:  MOVFF  00,68F
03FE4:  RCALL  3A98
03FE6:  BRA    41A2
....................       } else {
03FE8:  BRA    4062
....................          return (-exp(log(-x) * y));
03FEA:  MOVLB  6
03FEC:  MOVF   x84,W
03FEE:  XORLW  80
03FF0:  MOVWF  x8C
03FF2:  MOVFF  686,692
03FF6:  MOVFF  685,691
03FFA:  MOVWF  x90
03FFC:  MOVFF  683,68F
04000:  MOVLB  0
04002:  CALL   3704
04006:  MOVFF  03,68E
0400A:  MOVFF  02,68D
0400E:  MOVFF  01,68C
04012:  MOVFF  00,68B
04016:  MOVFF  03,6B7
0401A:  MOVFF  02,6B6
0401E:  MOVFF  01,6B5
04022:  MOVFF  00,6B4
04026:  MOVFF  68A,6BB
0402A:  MOVFF  689,6BA
0402E:  MOVFF  688,6B9
04032:  MOVFF  687,6B8
04036:  CALL   12F8
0403A:  MOVFF  03,68E
0403E:  MOVFF  02,68D
04042:  MOVFF  01,68C
04046:  MOVFF  00,68B
0404A:  MOVFF  03,692
0404E:  MOVFF  02,691
04052:  MOVFF  01,690
04056:  MOVFF  00,68F
0405A:  RCALL  3A98
0405C:  MOVLW  80
0405E:  XORWF  01,F
04060:  BRA    41A2
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
04062:  BRA    41A2
04064:  MOVFF  686,6B2
04068:  MOVFF  685,6B1
0406C:  MOVFF  684,6B0
04070:  MOVFF  683,6AF
04074:  MOVLB  6
04076:  CLRF   xB6
04078:  CLRF   xB5
0407A:  CLRF   xB4
0407C:  CLRF   xB3
0407E:  MOVLB  0
04080:  CALL   27C4
04084:  BNC   40E6
04086:  MOVFF  68A,68E
0408A:  MOVFF  689,68D
0408E:  MOVFF  688,68C
04092:  MOVFF  687,68B
04096:  MOVLB  6
04098:  CLRF   x92
0409A:  CLRF   x91
0409C:  CLRF   x90
0409E:  MOVLW  7F
040A0:  MOVWF  x8F
040A2:  MOVLB  0
040A4:  CALL   359E
040A8:  MOVFF  03,68E
040AC:  MOVFF  02,68D
040B0:  MOVFF  01,68C
040B4:  MOVFF  00,68B
040B8:  MOVFF  03,6B2
040BC:  MOVFF  02,6B1
040C0:  MOVFF  01,6B0
040C4:  MOVFF  00,6AF
040C8:  MOVLB  6
040CA:  CLRF   xB6
040CC:  CLRF   xB5
040CE:  CLRF   xB4
040D0:  CLRF   xB3
040D2:  MOVLB  0
040D4:  CALL   27C4
040D8:  BZ    40E6
....................       return 0;
040DA:  CLRF   00
040DC:  CLRF   01
040DE:  CLRF   02
040E0:  CLRF   03
040E2:  BRA    41A2
....................    } else {
040E4:  BRA    41A2
....................       if(x != 0 || 0 >= y) {
040E6:  MOVFF  686,6B2
040EA:  MOVFF  685,6B1
040EE:  MOVFF  684,6B0
040F2:  MOVFF  683,6AF
040F6:  MOVLB  6
040F8:  CLRF   xB6
040FA:  CLRF   xB5
040FC:  CLRF   xB4
040FE:  CLRF   xB3
04100:  MOVLB  0
04102:  CALL   27C4
04106:  BNZ   412C
04108:  MOVFF  68A,6B2
0410C:  MOVFF  689,6B1
04110:  MOVFF  688,6B0
04114:  MOVFF  687,6AF
04118:  MOVLB  6
0411A:  CLRF   xB6
0411C:  CLRF   xB5
0411E:  CLRF   xB4
04120:  CLRF   xB3
04122:  MOVLB  0
04124:  CALL   27C4
04128:  BC    412C
0412A:  BNZ   419A
....................          return (exp(log(x) * y));
0412C:  MOVFF  686,692
04130:  MOVFF  685,691
04134:  MOVFF  684,690
04138:  MOVFF  683,68F
0413C:  CALL   3704
04140:  MOVFF  03,68E
04144:  MOVFF  02,68D
04148:  MOVFF  01,68C
0414C:  MOVFF  00,68B
04150:  MOVFF  03,6B7
04154:  MOVFF  02,6B6
04158:  MOVFF  01,6B5
0415C:  MOVFF  00,6B4
04160:  MOVFF  68A,6BB
04164:  MOVFF  689,6BA
04168:  MOVFF  688,6B9
0416C:  MOVFF  687,6B8
04170:  CALL   12F8
04174:  MOVFF  03,68E
04178:  MOVFF  02,68D
0417C:  MOVFF  01,68C
04180:  MOVFF  00,68B
04184:  MOVFF  03,692
04188:  MOVFF  02,691
0418C:  MOVFF  01,690
04190:  MOVFF  00,68F
04194:  RCALL  3A98
04196:  BRA    41A2
....................       } else return 0;
04198:  BRA    41A2
0419A:  CLRF   00
0419C:  CLRF   01
0419E:  CLRF   02
041A0:  CLRF   03
....................    }
041A2:  RETURN 0
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
*
0299C:  MOVLB  6
0299E:  BCF    xA1.0
....................    flag = 0;
029A0:  BCF    xA1.1
....................    y = x;
029A2:  MOVFF  694,698
029A6:  MOVFF  693,697
029AA:  MOVFF  692,696
029AE:  MOVFF  691,695
.................... 
....................    if (x < 0)
029B2:  MOVFF  694,6B2
029B6:  MOVFF  693,6B1
029BA:  MOVFF  692,6B0
029BE:  MOVFF  691,6AF
029C2:  CLRF   xB6
029C4:  CLRF   xB5
029C6:  CLRF   xB4
029C8:  CLRF   xB3
029CA:  MOVLB  0
029CC:  RCALL  27C4
029CE:  BNC   29DC
....................    {
....................       s = 1;
029D0:  MOVLB  6
029D2:  BSF    xA1.0
....................       y = -y;
029D4:  MOVF   x96,W
029D6:  XORLW  80
029D8:  MOVWF  x96
029DA:  MOVLB  0
....................    }
.................... 
....................    if (y > 1.0)
029DC:  MOVLB  6
029DE:  CLRF   xB2
029E0:  CLRF   xB1
029E2:  CLRF   xB0
029E4:  MOVLW  7F
029E6:  MOVWF  xAF
029E8:  MOVFF  698,6B6
029EC:  MOVFF  697,6B5
029F0:  MOVFF  696,6B4
029F4:  MOVFF  695,6B3
029F8:  MOVLB  0
029FA:  RCALL  27C4
029FC:  BNC   2A34
....................    {
....................       y = 1.0/y;
029FE:  MOVLB  6
02A00:  CLRF   xAB
02A02:  CLRF   xAA
02A04:  CLRF   xA9
02A06:  MOVLW  7F
02A08:  MOVWF  xA8
02A0A:  MOVFF  698,6AF
02A0E:  MOVFF  697,6AE
02A12:  MOVFF  696,6AD
02A16:  MOVFF  695,6AC
02A1A:  MOVLB  0
02A1C:  RCALL  283E
02A1E:  MOVFF  03,698
02A22:  MOVFF  02,697
02A26:  MOVFF  01,696
02A2A:  MOVFF  00,695
....................       flag = 1;
02A2E:  MOVLB  6
02A30:  BSF    xA1.1
02A32:  MOVLB  0
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
02A34:  MOVLW  0A
02A36:  MOVLB  6
02A38:  MOVWF  xB7
02A3A:  MOVLW  89
02A3C:  MOVWF  xB6
02A3E:  MOVLW  34
02A40:  MOVWF  xB5
02A42:  MOVLW  7C
02A44:  MOVWF  xB4
02A46:  MOVFF  698,6BB
02A4A:  MOVFF  697,6BA
02A4E:  MOVFF  696,6B9
02A52:  MOVFF  695,6B8
02A56:  MOVLB  0
02A58:  CALL   12F8
02A5C:  MOVFF  03,6A5
02A60:  MOVFF  02,6A4
02A64:  MOVFF  01,6A3
02A68:  MOVFF  00,6A2
02A6C:  MOVFF  03,6B7
02A70:  MOVFF  02,6B6
02A74:  MOVFF  01,6B5
02A78:  MOVFF  00,6B4
02A7C:  MOVFF  698,6BB
02A80:  MOVFF  697,6BA
02A84:  MOVFF  696,6B9
02A88:  MOVFF  695,6B8
02A8C:  CALL   12F8
02A90:  MOVFF  03,6A5
02A94:  MOVFF  02,6A4
02A98:  MOVFF  01,6A3
02A9C:  MOVFF  00,6A2
02AA0:  BCF    FD8.1
02AA2:  MOVFF  03,6B6
02AA6:  MOVFF  02,6B5
02AAA:  MOVFF  01,6B4
02AAE:  MOVFF  00,6B3
02AB2:  MOVLW  7C
02AB4:  MOVLB  6
02AB6:  MOVWF  xBA
02AB8:  MOVLW  79
02ABA:  MOVWF  xB9
02ABC:  MOVLW  35
02ABE:  MOVWF  xB8
02AC0:  MOVLW  81
02AC2:  MOVWF  xB7
02AC4:  MOVLB  0
02AC6:  CALL   13EE
02ACA:  MOVFF  03,69C
02ACE:  MOVFF  02,69B
02AD2:  MOVFF  01,69A
02AD6:  MOVFF  00,699
....................    res = res*y*y + pat[2];
02ADA:  MOVFF  69C,6B7
02ADE:  MOVFF  69B,6B6
02AE2:  MOVFF  69A,6B5
02AE6:  MOVFF  699,6B4
02AEA:  MOVFF  698,6BB
02AEE:  MOVFF  697,6BA
02AF2:  MOVFF  696,6B9
02AF6:  MOVFF  695,6B8
02AFA:  CALL   12F8
02AFE:  MOVFF  03,6A5
02B02:  MOVFF  02,6A4
02B06:  MOVFF  01,6A3
02B0A:  MOVFF  00,6A2
02B0E:  MOVFF  03,6B7
02B12:  MOVFF  02,6B6
02B16:  MOVFF  01,6B5
02B1A:  MOVFF  00,6B4
02B1E:  MOVFF  698,6BB
02B22:  MOVFF  697,6BA
02B26:  MOVFF  696,6B9
02B2A:  MOVFF  695,6B8
02B2E:  CALL   12F8
02B32:  MOVFF  03,6A5
02B36:  MOVFF  02,6A4
02B3A:  MOVFF  01,6A3
02B3E:  MOVFF  00,6A2
02B42:  BCF    FD8.1
02B44:  MOVFF  03,6B6
02B48:  MOVFF  02,6B5
02B4C:  MOVFF  01,6B4
02B50:  MOVFF  00,6B3
02B54:  MOVLW  3F
02B56:  MOVLB  6
02B58:  MOVWF  xBA
02B5A:  MOVLW  02
02B5C:  MOVWF  xB9
02B5E:  MOVLW  33
02B60:  MOVWF  xB8
02B62:  MOVLW  83
02B64:  MOVWF  xB7
02B66:  MOVLB  0
02B68:  CALL   13EE
02B6C:  MOVFF  03,69C
02B70:  MOVFF  02,69B
02B74:  MOVFF  01,69A
02B78:  MOVFF  00,699
....................    res = res*y*y + pat[3];
02B7C:  MOVFF  69C,6B7
02B80:  MOVFF  69B,6B6
02B84:  MOVFF  69A,6B5
02B88:  MOVFF  699,6B4
02B8C:  MOVFF  698,6BB
02B90:  MOVFF  697,6BA
02B94:  MOVFF  696,6B9
02B98:  MOVFF  695,6B8
02B9C:  CALL   12F8
02BA0:  MOVFF  03,6A5
02BA4:  MOVFF  02,6A4
02BA8:  MOVFF  01,6A3
02BAC:  MOVFF  00,6A2
02BB0:  MOVFF  03,6B7
02BB4:  MOVFF  02,6B6
02BB8:  MOVFF  01,6B5
02BBC:  MOVFF  00,6B4
02BC0:  MOVFF  698,6BB
02BC4:  MOVFF  697,6BA
02BC8:  MOVFF  696,6B9
02BCC:  MOVFF  695,6B8
02BD0:  CALL   12F8
02BD4:  MOVFF  03,6A5
02BD8:  MOVFF  02,6A4
02BDC:  MOVFF  01,6A3
02BE0:  MOVFF  00,6A2
02BE4:  BCF    FD8.1
02BE6:  MOVFF  03,6B6
02BEA:  MOVFF  02,6B5
02BEE:  MOVFF  01,6B4
02BF2:  MOVFF  00,6B3
02BF6:  MOVLW  33
02BF8:  MOVLB  6
02BFA:  MOVWF  xBA
02BFC:  MOVLW  8C
02BFE:  MOVWF  xB9
02C00:  MOVLW  1E
02C02:  MOVWF  xB8
02C04:  MOVLW  83
02C06:  MOVWF  xB7
02C08:  MOVLB  0
02C0A:  CALL   13EE
02C0E:  MOVFF  03,69C
02C12:  MOVFF  02,69B
02C16:  MOVFF  01,69A
02C1A:  MOVFF  00,699
.................... 
....................    r = qat[0]*y*y + qat[1];
02C1E:  MOVLB  6
02C20:  CLRF   xB7
02C22:  CLRF   xB6
02C24:  CLRF   xB5
02C26:  MOVLW  7F
02C28:  MOVWF  xB4
02C2A:  MOVFF  698,6BB
02C2E:  MOVFF  697,6BA
02C32:  MOVFF  696,6B9
02C36:  MOVFF  695,6B8
02C3A:  MOVLB  0
02C3C:  CALL   12F8
02C40:  MOVFF  03,6A5
02C44:  MOVFF  02,6A4
02C48:  MOVFF  01,6A3
02C4C:  MOVFF  00,6A2
02C50:  MOVFF  03,6B7
02C54:  MOVFF  02,6B6
02C58:  MOVFF  01,6B5
02C5C:  MOVFF  00,6B4
02C60:  MOVFF  698,6BB
02C64:  MOVFF  697,6BA
02C68:  MOVFF  696,6B9
02C6C:  MOVFF  695,6B8
02C70:  CALL   12F8
02C74:  MOVFF  03,6A5
02C78:  MOVFF  02,6A4
02C7C:  MOVFF  01,6A3
02C80:  MOVFF  00,6A2
02C84:  BCF    FD8.1
02C86:  MOVFF  03,6B6
02C8A:  MOVFF  02,6B5
02C8E:  MOVFF  01,6B4
02C92:  MOVFF  00,6B3
02C96:  MOVLW  1B
02C98:  MOVLB  6
02C9A:  MOVWF  xBA
02C9C:  MOVLW  E4
02C9E:  MOVWF  xB9
02CA0:  MOVLW  35
02CA2:  MOVWF  xB8
02CA4:  MOVLW  82
02CA6:  MOVWF  xB7
02CA8:  MOVLB  0
02CAA:  CALL   13EE
02CAE:  MOVFF  03,6A0
02CB2:  MOVFF  02,69F
02CB6:  MOVFF  01,69E
02CBA:  MOVFF  00,69D
....................    r = r*y*y + qat[2];
02CBE:  MOVFF  6A0,6B7
02CC2:  MOVFF  69F,6B6
02CC6:  MOVFF  69E,6B5
02CCA:  MOVFF  69D,6B4
02CCE:  MOVFF  698,6BB
02CD2:  MOVFF  697,6BA
02CD6:  MOVFF  696,6B9
02CDA:  MOVFF  695,6B8
02CDE:  CALL   12F8
02CE2:  MOVFF  03,6A5
02CE6:  MOVFF  02,6A4
02CEA:  MOVFF  01,6A3
02CEE:  MOVFF  00,6A2
02CF2:  MOVFF  03,6B7
02CF6:  MOVFF  02,6B6
02CFA:  MOVFF  01,6B5
02CFE:  MOVFF  00,6B4
02D02:  MOVFF  698,6BB
02D06:  MOVFF  697,6BA
02D0A:  MOVFF  696,6B9
02D0E:  MOVFF  695,6B8
02D12:  CALL   12F8
02D16:  MOVFF  03,6A5
02D1A:  MOVFF  02,6A4
02D1E:  MOVFF  01,6A3
02D22:  MOVFF  00,6A2
02D26:  BCF    FD8.1
02D28:  MOVFF  03,6B6
02D2C:  MOVFF  02,6B5
02D30:  MOVFF  01,6B4
02D34:  MOVFF  00,6B3
02D38:  MOVLW  A4
02D3A:  MOVLB  6
02D3C:  MOVWF  xBA
02D3E:  MOVLW  DB
02D40:  MOVWF  xB9
02D42:  MOVLW  67
02D44:  MOVWF  xB8
02D46:  MOVLW  83
02D48:  MOVWF  xB7
02D4A:  MOVLB  0
02D4C:  CALL   13EE
02D50:  MOVFF  03,6A0
02D54:  MOVFF  02,69F
02D58:  MOVFF  01,69E
02D5C:  MOVFF  00,69D
....................    r = r*y*y + qat[3];
02D60:  MOVFF  6A0,6B7
02D64:  MOVFF  69F,6B6
02D68:  MOVFF  69E,6B5
02D6C:  MOVFF  69D,6B4
02D70:  MOVFF  698,6BB
02D74:  MOVFF  697,6BA
02D78:  MOVFF  696,6B9
02D7C:  MOVFF  695,6B8
02D80:  CALL   12F8
02D84:  MOVFF  03,6A5
02D88:  MOVFF  02,6A4
02D8C:  MOVFF  01,6A3
02D90:  MOVFF  00,6A2
02D94:  MOVFF  03,6B7
02D98:  MOVFF  02,6B6
02D9C:  MOVFF  01,6B5
02DA0:  MOVFF  00,6B4
02DA4:  MOVFF  698,6BB
02DA8:  MOVFF  697,6BA
02DAC:  MOVFF  696,6B9
02DB0:  MOVFF  695,6B8
02DB4:  CALL   12F8
02DB8:  MOVFF  03,6A5
02DBC:  MOVFF  02,6A4
02DC0:  MOVFF  01,6A3
02DC4:  MOVFF  00,6A2
02DC8:  BCF    FD8.1
02DCA:  MOVFF  03,6B6
02DCE:  MOVFF  02,6B5
02DD2:  MOVFF  01,6B4
02DD6:  MOVFF  00,6B3
02DDA:  MOVLW  33
02DDC:  MOVLB  6
02DDE:  MOVWF  xBA
02DE0:  MOVLW  8C
02DE2:  MOVWF  xB9
02DE4:  MOVLW  1E
02DE6:  MOVWF  xB8
02DE8:  MOVLW  83
02DEA:  MOVWF  xB7
02DEC:  MOVLB  0
02DEE:  CALL   13EE
02DF2:  MOVFF  03,6A0
02DF6:  MOVFF  02,69F
02DFA:  MOVFF  01,69E
02DFE:  MOVFF  00,69D
.................... 
....................    res = y*res/r;
02E02:  MOVFF  698,6B7
02E06:  MOVFF  697,6B6
02E0A:  MOVFF  696,6B5
02E0E:  MOVFF  695,6B4
02E12:  MOVFF  69C,6BB
02E16:  MOVFF  69B,6BA
02E1A:  MOVFF  69A,6B9
02E1E:  MOVFF  699,6B8
02E22:  CALL   12F8
02E26:  MOVFF  03,6A5
02E2A:  MOVFF  02,6A4
02E2E:  MOVFF  01,6A3
02E32:  MOVFF  00,6A2
02E36:  MOVFF  03,6AB
02E3A:  MOVFF  02,6AA
02E3E:  MOVFF  01,6A9
02E42:  MOVFF  00,6A8
02E46:  MOVFF  6A0,6AF
02E4A:  MOVFF  69F,6AE
02E4E:  MOVFF  69E,6AD
02E52:  MOVFF  69D,6AC
02E56:  RCALL  283E
02E58:  MOVFF  03,69C
02E5C:  MOVFF  02,69B
02E60:  MOVFF  01,69A
02E64:  MOVFF  00,699
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
02E68:  MOVLB  6
02E6A:  BTFSS  xA1.1
02E6C:  BRA    2EA8
....................       res = PI_DIV_BY_TWO - res;
02E6E:  BSF    FD8.1
02E70:  MOVLW  DB
02E72:  MOVWF  xB6
02E74:  MOVLW  0F
02E76:  MOVWF  xB5
02E78:  MOVLW  49
02E7A:  MOVWF  xB4
02E7C:  MOVLW  7F
02E7E:  MOVWF  xB3
02E80:  MOVFF  69C,6BA
02E84:  MOVFF  69B,6B9
02E88:  MOVFF  69A,6B8
02E8C:  MOVFF  699,6B7
02E90:  MOVLB  0
02E92:  CALL   13EE
02E96:  MOVFF  03,69C
02E9A:  MOVFF  02,69B
02E9E:  MOVFF  01,69A
02EA2:  MOVFF  00,699
02EA6:  MOVLB  6
....................    if (s)
02EA8:  BTFSS  xA1.0
02EAA:  BRA    2EB2
....................       res = -res;
02EAC:  MOVF   x9A,W
02EAE:  XORLW  80
02EB0:  MOVWF  x9A
.................... 
....................    return(res);
02EB2:  MOVFF  699,00
02EB6:  MOVFF  69A,01
02EBA:  MOVFF  69B,02
02EBE:  MOVFF  69C,03
02EC2:  MOVLB  0
02EC4:  RETURN 0
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
02EC6:  MOVLB  6
02EC8:  BCF    x8F.0
....................    quad=0; //quadrant
02ECA:  CLRF   x90
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
02ECC:  MOVFF  686,6B2
02ED0:  MOVFF  685,6B1
02ED4:  MOVFF  684,6B0
02ED8:  MOVFF  683,6AF
02EDC:  CLRF   xB6
02EDE:  CLRF   xB5
02EE0:  CLRF   xB4
02EE2:  CLRF   xB3
02EE4:  MOVLB  0
02EE6:  RCALL  27C4
02EE8:  BC    2EEC
02EEA:  BNZ   2F16
02EEC:  MOVFF  68A,6B2
02EF0:  MOVFF  689,6B1
02EF4:  MOVFF  688,6B0
02EF8:  MOVFF  687,6AF
02EFC:  MOVLB  6
02EFE:  CLRF   xB6
02F00:  CLRF   xB5
02F02:  CLRF   xB4
02F04:  CLRF   xB3
02F06:  MOVLB  0
02F08:  RCALL  27C4
02F0A:  BC    2F0E
02F0C:  BNZ   2F12
02F0E:  MOVLW  03
02F10:  BRA    2F14
02F12:  MOVLW  04
02F14:  BRA    2F3C
02F16:  MOVFF  68A,6B2
02F1A:  MOVFF  689,6B1
02F1E:  MOVFF  688,6B0
02F22:  MOVFF  687,6AF
02F26:  MOVLB  6
02F28:  CLRF   xB6
02F2A:  CLRF   xB5
02F2C:  CLRF   xB4
02F2E:  CLRF   xB3
02F30:  MOVLB  0
02F32:  RCALL  27C4
02F34:  BNC   2F3A
02F36:  MOVLW  02
02F38:  BRA    2F3C
02F3A:  MOVLW  01
02F3C:  MOVLB  6
02F3E:  MOVWF  x90
....................    if(y<0.0)
02F40:  MOVFF  686,6B2
02F44:  MOVFF  685,6B1
02F48:  MOVFF  684,6B0
02F4C:  MOVFF  683,6AF
02F50:  CLRF   xB6
02F52:  CLRF   xB5
02F54:  CLRF   xB4
02F56:  CLRF   xB3
02F58:  MOVLB  0
02F5A:  RCALL  27C4
02F5C:  BNC   2F6A
....................    {
....................       sign=1;
02F5E:  MOVLB  6
02F60:  BSF    x8F.0
....................       y=-y;
02F62:  MOVF   x84,W
02F64:  XORLW  80
02F66:  MOVWF  x84
02F68:  MOVLB  0
....................    }
....................    if(x<0.0)
02F6A:  MOVFF  68A,6B2
02F6E:  MOVFF  689,6B1
02F72:  MOVFF  688,6B0
02F76:  MOVFF  687,6AF
02F7A:  MOVLB  6
02F7C:  CLRF   xB6
02F7E:  CLRF   xB5
02F80:  CLRF   xB4
02F82:  CLRF   xB3
02F84:  MOVLB  0
02F86:  RCALL  27C4
02F88:  BNC   2F94
....................    {
....................       x=-x;
02F8A:  MOVLB  6
02F8C:  MOVF   x88,W
02F8E:  XORLW  80
02F90:  MOVWF  x88
02F92:  MOVLB  0
....................    }
....................    if (x==0.0)
02F94:  MOVFF  68A,6B2
02F98:  MOVFF  689,6B1
02F9C:  MOVFF  688,6B0
02FA0:  MOVFF  687,6AF
02FA4:  MOVLB  6
02FA6:  CLRF   xB6
02FA8:  CLRF   xB5
02FAA:  CLRF   xB4
02FAC:  CLRF   xB3
02FAE:  MOVLB  0
02FB0:  RCALL  27C4
02FB2:  BNZ   3008
....................    {
....................       if(y==0.0)
02FB4:  MOVFF  686,6B2
02FB8:  MOVFF  685,6B1
02FBC:  MOVFF  684,6B0
02FC0:  MOVFF  683,6AF
02FC4:  MOVLB  6
02FC6:  CLRF   xB6
02FC8:  CLRF   xB5
02FCA:  CLRF   xB4
02FCC:  CLRF   xB3
02FCE:  MOVLB  0
02FD0:  CALL   27C4
02FD4:  BNZ   2FD8
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
02FD6:  BRA    3006
....................       else
....................       {
....................          if(sign)
02FD8:  MOVLB  6
02FDA:  BTFSS  x8F.0
02FDC:  BRA    2FF2
....................          {
....................          return (-(PI_DIV_BY_TWO));
02FDE:  MOVLW  7F
02FE0:  MOVWF  00
02FE2:  MOVLW  C9
02FE4:  MOVWF  01
02FE6:  MOVLW  0F
02FE8:  MOVWF  02
02FEA:  MOVLW  DB
02FEC:  MOVWF  03
02FEE:  BRA    3140
....................          }
02FF0:  BRA    3004
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
02FF2:  MOVLW  7F
02FF4:  MOVWF  00
02FF6:  MOVLW  49
02FF8:  MOVWF  01
02FFA:  MOVLW  0F
02FFC:  MOVWF  02
02FFE:  MOVLW  DB
03000:  MOVWF  03
03002:  BRA    3140
03004:  MOVLB  0
....................          }
....................       }
....................    }
03006:  BRA    313E
....................    else
....................    {
....................       z=y/x;
03008:  MOVFF  686,6AB
0300C:  MOVFF  685,6AA
03010:  MOVFF  684,6A9
03014:  MOVFF  683,6A8
03018:  MOVFF  68A,6AF
0301C:  MOVFF  689,6AE
03020:  MOVFF  688,6AD
03024:  MOVFF  687,6AC
03028:  RCALL  283E
0302A:  MOVFF  03,68E
0302E:  MOVFF  02,68D
03032:  MOVFF  01,68C
03036:  MOVFF  00,68B
....................       switch(quad)
0303A:  MOVLW  01
0303C:  MOVLB  6
0303E:  SUBWF  x90,W
03040:  ADDLW  FC
03042:  BTFSC  FD8.0
03044:  BRA    3140
03046:  ADDLW  04
03048:  MOVLB  0
0304A:  GOTO   3146
....................       {
....................          case 1:
....................          {
....................             return atan(z);
0304E:  MOVFF  68E,694
03052:  MOVFF  68D,693
03056:  MOVFF  68C,692
0305A:  MOVFF  68B,691
0305E:  RCALL  299C
03060:  MOVLB  6
03062:  BRA    3140
....................             break;
03064:  BRA    3140
03066:  MOVLB  0
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
03068:  MOVFF  68E,694
0306C:  MOVFF  68D,693
03070:  MOVFF  68C,692
03074:  MOVFF  68B,691
03078:  RCALL  299C
0307A:  MOVFF  FEA,692
0307E:  MOVFF  FE9,691
03082:  BSF    FD8.1
03084:  MOVLW  DB
03086:  MOVLB  6
03088:  MOVWF  xB6
0308A:  MOVLW  0F
0308C:  MOVWF  xB5
0308E:  MOVLW  49
03090:  MOVWF  xB4
03092:  MOVLW  80
03094:  MOVWF  xB3
03096:  MOVFF  03,6BA
0309A:  MOVFF  02,6B9
0309E:  MOVFF  01,6B8
030A2:  MOVFF  00,6B7
030A6:  MOVLB  0
030A8:  CALL   13EE
030AC:  MOVFF  692,FEA
030B0:  MOVFF  691,FE9
030B4:  MOVLB  6
030B6:  BRA    3140
....................             break;
030B8:  BRA    3140
030BA:  MOVLB  0
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
030BC:  MOVFF  68E,694
030C0:  MOVFF  68D,693
030C4:  MOVFF  68C,692
030C8:  MOVFF  68B,691
030CC:  RCALL  299C
030CE:  MOVFF  03,694
030D2:  MOVFF  02,693
030D6:  MOVFF  01,692
030DA:  MOVFF  00,691
030DE:  MOVFF  FEA,696
030E2:  MOVFF  FE9,695
030E6:  BSF    FD8.1
030E8:  MOVFF  03,6B6
030EC:  MOVFF  02,6B5
030F0:  MOVFF  01,6B4
030F4:  MOVFF  00,6B3
030F8:  MOVLW  DB
030FA:  MOVLB  6
030FC:  MOVWF  xBA
030FE:  MOVLW  0F
03100:  MOVWF  xB9
03102:  MOVLW  49
03104:  MOVWF  xB8
03106:  MOVLW  80
03108:  MOVWF  xB7
0310A:  MOVLB  0
0310C:  CALL   13EE
03110:  MOVFF  696,FEA
03114:  MOVFF  695,FE9
03118:  MOVLB  6
0311A:  BRA    3140
....................             break;
0311C:  BRA    3140
0311E:  MOVLB  0
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
03120:  MOVFF  68E,694
03124:  MOVFF  68D,693
03128:  MOVFF  68C,692
0312C:  MOVFF  68B,691
03130:  RCALL  299C
03132:  MOVLW  80
03134:  XORWF  01,F
03136:  MOVLB  6
03138:  BRA    3140
....................             break;
0313A:  BRA    3140
0313C:  MOVLB  0
0313E:  MOVLB  6
....................          }
....................       }
....................    }
03140:  MOVLB  0
03142:  GOTO   484C (RETURN)
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... #define sensorSampleRate 50 // 50mS delay between each sensor sample = 200ms cadence 
.................... 
.................... #define maxCount 16777216.0   // ADC max count
.................... #define vRef 2.048            // ADC vRef
.................... 
.................... #define sc sensorCal
.................... 
.................... #define vMonN15   6
.................... #define vMon200   16
.................... #define vMon5V6   24
.................... #define vMon5VA   25
.................... #define vMon3V6X  17
.................... #define vMon3V3A  27
.................... #define vMon3V3D  26
.................... 
.................... #define BUFFER_SIZE 5
.................... typedef struct {
....................    int8 in;
....................    int8 out;
....................    signed int32 buff[BUFFER_SIZE];
.................... } buffer;
.................... 
.................... buffer sinQ_x;
.................... buffer cosQ_x;
.................... buffer sinQ_y;
.................... buffer cosQ_y;
.................... 
.................... #define incin(buff) ((buff->in==(BUFFER_SIZE-1))?0:buff->in+1)
.................... #define incout(buff) ((buff->out==(BUFFER_SIZE-1))?0:buff->out+1)
.................... #define isempty(buff) (buff->in==buff->out)
.................... #define hasdata(buff) (buff->in!=buff->out)
.................... #define isfull(buff) (incin(buff)==buff->out)
.................... 
.................... #define tobuff(bname,c) { bname->buff[bname->in]=c;\
....................    bname->in=incin(bname);\
....................    if (bname->in==bname->out) bname->out=incout(bname);\
....................    }
.................... #define frombuff(bname) (btemp##bname=bname->buff[bname->out],\
....................    bname->out=incout(bname), \
....................    btemp##bname)
.................... #define clrbuff(buff) buff->in=buff->out=0
.................... 
.................... #define COMPARE(a,b) (((a) > (b)) - ((a) < (b)))
.................... 
.................... struct sensorMonitorData
.................... {
....................    boolean dataReady;
....................    boolean adcBusy;
....................    buffer* sinQ;
....................    buffer* cosQ;
....................    signed int32 avgSin;
....................    signed int32 avgCos;
.................... } smData[2] = 
.................... {
....................    {false, false, &sinQ_x, &cosQ_x, 0, 0},
....................    {false, false, &sinQ_y, &cosQ_y, 0, 0}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* INTERNAL MONITOR task - gets voltages                                     */
.................... /* gets one value each time the task is run                                  */
.................... /*****************************************************************************/
.................... void internal_monitor_task()
.................... {
....................    static int8 state = 0;
....................    if (adc_done())
*
01666:  MOVLB  F
01668:  BTFSC  x5B.0
0166A:  BRA    1BB6
....................    {
....................       switch (state)
0166C:  MOVLB  1
0166E:  MOVF   xD7,W
01670:  ADDLW  F9
01672:  BTFSC  FD8.0
01674:  BRA    1BB4
01676:  ADDLW  07
01678:  MOVLB  0
0167A:  GOTO   1BBC
....................       {
....................          case 0:     // vMonN15
....................             monitorVals.vN15 = read_adc(ADC_READ_ONLY) * monCal.vN15[1] + monCal.vN15[0];
0167E:  MOVLB  F
01680:  BTFSC  x5B.0
01682:  BRA    1680
01684:  MOVFF  F5F,02
01688:  MOVFF  F5E,01
0168C:  MOVFF  02,665
01690:  MOVFF  01,664
01694:  MOVFF  02,6B4
01698:  MOVFF  01,6B3
0169C:  MOVLB  0
0169E:  RCALL  12C2
016A0:  MOVFF  03,6B7
016A4:  MOVFF  02,6B6
016A8:  MOVFF  01,6B5
016AC:  MOVFF  00,6B4
016B0:  MOVFF  B9,6BB
016B4:  MOVFF  B8,6BA
016B8:  MOVFF  B7,6B9
016BC:  MOVFF  B6,6B8
016C0:  RCALL  12F8
016C2:  MOVFF  03,667
016C6:  MOVFF  02,666
016CA:  MOVFF  01,665
016CE:  MOVFF  00,664
016D2:  BCF    FD8.1
016D4:  MOVFF  03,6B6
016D8:  MOVFF  02,6B5
016DC:  MOVFF  01,6B4
016E0:  MOVFF  00,6B3
016E4:  MOVFF  B5,6BA
016E8:  MOVFF  B4,6B9
016EC:  MOVFF  B3,6B8
016F0:  MOVFF  B2,6B7
016F4:  RCALL  13EE
016F6:  MOVFF  03,F6
016FA:  MOVFF  02,F5
016FE:  MOVFF  01,F4
01702:  MOVFF  00,F3
....................             set_adc_channel(vMon200);
01706:  MOVLB  F
01708:  MOVF   x5A,W
0170A:  ANDLW  3F
0170C:  MOVWF  01
0170E:  MOVLW  10
01710:  MOVWF  x5A
01712:  BTFSS  x5B.7
01714:  BRA    1724
01716:  MOVF   01,W
01718:  SUBLW  10
0171A:  BZ    1724
0171C:  BSF    x5B.0
0171E:  NOP   
01720:  BTFSC  x5B.0
01722:  BRA    1720
....................             delay_ms(10);
01724:  MOVLW  0A
01726:  MOVLB  6
01728:  MOVWF  x6C
0172A:  MOVLB  0
0172C:  CALL   0426
....................             read_adc(ADC_START_ONLY);
01730:  MOVLB  F
01732:  BSF    x5B.0
01734:  NOP   
....................             state = 1;
01736:  MOVLW  01
01738:  MOVLB  1
0173A:  MOVWF  xD7
....................          break;
0173C:  BRA    1BB4
....................          
....................          case 1:     // vMon200
....................             monitorVals.v200 = read_adc(ADC_READ_ONLY) * monCal.v200[1] + monCal.v200[0];
0173E:  MOVLB  F
01740:  BTFSC  x5B.0
01742:  BRA    1740
01744:  MOVFF  F5F,02
01748:  MOVFF  F5E,01
0174C:  MOVFF  02,665
01750:  MOVFF  01,664
01754:  MOVFF  02,6B4
01758:  MOVFF  01,6B3
0175C:  MOVLB  0
0175E:  RCALL  12C2
01760:  MOVFF  03,6B7
01764:  MOVFF  02,6B6
01768:  MOVFF  01,6B5
0176C:  MOVFF  00,6B4
01770:  MOVFF  C1,6BB
01774:  MOVFF  C0,6BA
01778:  MOVFF  BF,6B9
0177C:  MOVFF  BE,6B8
01780:  RCALL  12F8
01782:  MOVFF  03,667
01786:  MOVFF  02,666
0178A:  MOVFF  01,665
0178E:  MOVFF  00,664
01792:  BCF    FD8.1
01794:  MOVFF  03,6B6
01798:  MOVFF  02,6B5
0179C:  MOVFF  01,6B4
017A0:  MOVFF  00,6B3
017A4:  MOVFF  BD,6BA
017A8:  MOVFF  BC,6B9
017AC:  MOVFF  BB,6B8
017B0:  MOVFF  BA,6B7
017B4:  RCALL  13EE
017B6:  MOVFF  03,FA
017BA:  MOVFF  02,F9
017BE:  MOVFF  01,F8
017C2:  MOVFF  00,F7
....................             set_adc_channel(vMon5V6);
017C6:  MOVLB  F
017C8:  MOVF   x5A,W
017CA:  ANDLW  3F
017CC:  MOVWF  01
017CE:  MOVLW  18
017D0:  MOVWF  x5A
017D2:  BTFSS  x5B.7
017D4:  BRA    17E4
017D6:  MOVF   01,W
017D8:  SUBLW  18
017DA:  BZ    17E4
017DC:  BSF    x5B.0
017DE:  NOP   
017E0:  BTFSC  x5B.0
017E2:  BRA    17E0
....................             delay_ms(10);
017E4:  MOVLW  0A
017E6:  MOVLB  6
017E8:  MOVWF  x6C
017EA:  MOVLB  0
017EC:  CALL   0426
....................             read_adc(ADC_START_ONLY);
017F0:  MOVLB  F
017F2:  BSF    x5B.0
017F4:  NOP   
....................             state = 2;
017F6:  MOVLW  02
017F8:  MOVLB  1
017FA:  MOVWF  xD7
....................          break;
017FC:  BRA    1BB4
....................          
....................          case 2:     // vMon5V6
....................             monitorVals.v5V6 = read_adc(ADC_READ_ONLY) * monCal.v5V6[1] + monCal.v5V6[0];
017FE:  MOVLB  F
01800:  BTFSC  x5B.0
01802:  BRA    1800
01804:  MOVFF  F5F,02
01808:  MOVFF  F5E,01
0180C:  MOVFF  02,665
01810:  MOVFF  01,664
01814:  MOVFF  02,6B4
01818:  MOVFF  01,6B3
0181C:  MOVLB  0
0181E:  RCALL  12C2
01820:  MOVFF  03,6B7
01824:  MOVFF  02,6B6
01828:  MOVFF  01,6B5
0182C:  MOVFF  00,6B4
01830:  MOVFF  C9,6BB
01834:  MOVFF  C8,6BA
01838:  MOVFF  C7,6B9
0183C:  MOVFF  C6,6B8
01840:  RCALL  12F8
01842:  MOVFF  03,667
01846:  MOVFF  02,666
0184A:  MOVFF  01,665
0184E:  MOVFF  00,664
01852:  BCF    FD8.1
01854:  MOVFF  03,6B6
01858:  MOVFF  02,6B5
0185C:  MOVFF  01,6B4
01860:  MOVFF  00,6B3
01864:  MOVFF  C5,6BA
01868:  MOVFF  C4,6B9
0186C:  MOVFF  C3,6B8
01870:  MOVFF  C2,6B7
01874:  RCALL  13EE
01876:  MOVFF  03,FE
0187A:  MOVFF  02,FD
0187E:  MOVFF  01,FC
01882:  MOVFF  00,FB
....................             set_adc_channel(vMon5VA);
01886:  MOVLB  F
01888:  MOVF   x5A,W
0188A:  ANDLW  3F
0188C:  MOVWF  01
0188E:  MOVLW  19
01890:  MOVWF  x5A
01892:  BTFSS  x5B.7
01894:  BRA    18A4
01896:  MOVF   01,W
01898:  SUBLW  19
0189A:  BZ    18A4
0189C:  BSF    x5B.0
0189E:  NOP   
018A0:  BTFSC  x5B.0
018A2:  BRA    18A0
....................             delay_ms(10);
018A4:  MOVLW  0A
018A6:  MOVLB  6
018A8:  MOVWF  x6C
018AA:  MOVLB  0
018AC:  CALL   0426
....................             read_adc(ADC_START_ONLY);
018B0:  MOVLB  F
018B2:  BSF    x5B.0
018B4:  NOP   
....................             state = 3;
018B6:  MOVLW  03
018B8:  MOVLB  1
018BA:  MOVWF  xD7
....................          break;
018BC:  BRA    1BB4
....................          
....................          case 3:     // vMon5VA
....................             monitorVals.v5VA = read_adc(ADC_READ_ONLY) * monCal.v5VA[1] + monCal.v5VA[0];
018BE:  MOVLB  F
018C0:  BTFSC  x5B.0
018C2:  BRA    18C0
018C4:  MOVFF  F5F,02
018C8:  MOVFF  F5E,01
018CC:  MOVFF  02,665
018D0:  MOVFF  01,664
018D4:  MOVFF  02,6B4
018D8:  MOVFF  01,6B3
018DC:  MOVLB  0
018DE:  RCALL  12C2
018E0:  MOVFF  03,6B7
018E4:  MOVFF  02,6B6
018E8:  MOVFF  01,6B5
018EC:  MOVFF  00,6B4
018F0:  MOVFF  D1,6BB
018F4:  MOVFF  D0,6BA
018F8:  MOVFF  CF,6B9
018FC:  MOVFF  CE,6B8
01900:  RCALL  12F8
01902:  MOVFF  03,667
01906:  MOVFF  02,666
0190A:  MOVFF  01,665
0190E:  MOVFF  00,664
01912:  BCF    FD8.1
01914:  MOVFF  03,6B6
01918:  MOVFF  02,6B5
0191C:  MOVFF  01,6B4
01920:  MOVFF  00,6B3
01924:  MOVFF  CD,6BA
01928:  MOVFF  CC,6B9
0192C:  MOVFF  CB,6B8
01930:  MOVFF  CA,6B7
01934:  RCALL  13EE
01936:  MOVFF  03,102
0193A:  MOVFF  02,101
0193E:  MOVFF  01,100
01942:  MOVFF  00,FF
....................             set_adc_channel(vMon3V6X);
01946:  MOVLB  F
01948:  MOVF   x5A,W
0194A:  ANDLW  3F
0194C:  MOVWF  01
0194E:  MOVLW  11
01950:  MOVWF  x5A
01952:  BTFSS  x5B.7
01954:  BRA    1964
01956:  MOVF   01,W
01958:  SUBLW  11
0195A:  BZ    1964
0195C:  BSF    x5B.0
0195E:  NOP   
01960:  BTFSC  x5B.0
01962:  BRA    1960
....................             delay_ms(10);
01964:  MOVLW  0A
01966:  MOVLB  6
01968:  MOVWF  x6C
0196A:  MOVLB  0
0196C:  CALL   0426
....................             read_adc(ADC_START_ONLY);
01970:  MOVLB  F
01972:  BSF    x5B.0
01974:  NOP   
....................             state = 4;
01976:  MOVLW  04
01978:  MOVLB  1
0197A:  MOVWF  xD7
....................          break;
0197C:  BRA    1BB4
....................          
....................          case 4:     // vMon3V6X
....................             monitorVals.v3V6X = read_adc(ADC_READ_ONLY) * monCal.v3V6X[1] + monCal.v3V6X[0];
0197E:  MOVLB  F
01980:  BTFSC  x5B.0
01982:  BRA    1980
01984:  MOVFF  F5F,02
01988:  MOVFF  F5E,01
0198C:  MOVFF  02,665
01990:  MOVFF  01,664
01994:  MOVFF  02,6B4
01998:  MOVFF  01,6B3
0199C:  MOVLB  0
0199E:  RCALL  12C2
019A0:  MOVFF  03,6B7
019A4:  MOVFF  02,6B6
019A8:  MOVFF  01,6B5
019AC:  MOVFF  00,6B4
019B0:  MOVFF  D9,6BB
019B4:  MOVFF  D8,6BA
019B8:  MOVFF  D7,6B9
019BC:  MOVFF  D6,6B8
019C0:  RCALL  12F8
019C2:  MOVFF  03,667
019C6:  MOVFF  02,666
019CA:  MOVFF  01,665
019CE:  MOVFF  00,664
019D2:  BCF    FD8.1
019D4:  MOVFF  03,6B6
019D8:  MOVFF  02,6B5
019DC:  MOVFF  01,6B4
019E0:  MOVFF  00,6B3
019E4:  MOVFF  D5,6BA
019E8:  MOVFF  D4,6B9
019EC:  MOVFF  D3,6B8
019F0:  MOVFF  D2,6B7
019F4:  RCALL  13EE
019F6:  MOVFF  03,106
019FA:  MOVFF  02,105
019FE:  MOVFF  01,104
01A02:  MOVFF  00,103
....................             set_adc_channel(vMon3V3A);
01A06:  MOVLB  F
01A08:  MOVF   x5A,W
01A0A:  ANDLW  3F
01A0C:  MOVWF  01
01A0E:  MOVLW  1B
01A10:  MOVWF  x5A
01A12:  BTFSS  x5B.7
01A14:  BRA    1A24
01A16:  MOVF   01,W
01A18:  SUBLW  1B
01A1A:  BZ    1A24
01A1C:  BSF    x5B.0
01A1E:  NOP   
01A20:  BTFSC  x5B.0
01A22:  BRA    1A20
....................             delay_ms(10);
01A24:  MOVLW  0A
01A26:  MOVLB  6
01A28:  MOVWF  x6C
01A2A:  MOVLB  0
01A2C:  CALL   0426
....................             read_adc(ADC_START_ONLY);
01A30:  MOVLB  F
01A32:  BSF    x5B.0
01A34:  NOP   
....................             state = 5;
01A36:  MOVLW  05
01A38:  MOVLB  1
01A3A:  MOVWF  xD7
....................          break;
01A3C:  BRA    1BB4
....................          
....................          case 5:     // vMon3V3A
....................             monitorVals.v3V3A = read_adc(ADC_READ_ONLY) * monCal.v3V3A[1] + monCal.v3V3A[0];
01A3E:  MOVLB  F
01A40:  BTFSC  x5B.0
01A42:  BRA    1A40
01A44:  MOVFF  F5F,02
01A48:  MOVFF  F5E,01
01A4C:  MOVFF  02,665
01A50:  MOVFF  01,664
01A54:  MOVFF  02,6B4
01A58:  MOVFF  01,6B3
01A5C:  MOVLB  0
01A5E:  RCALL  12C2
01A60:  MOVFF  03,6B7
01A64:  MOVFF  02,6B6
01A68:  MOVFF  01,6B5
01A6C:  MOVFF  00,6B4
01A70:  MOVFF  E1,6BB
01A74:  MOVFF  E0,6BA
01A78:  MOVFF  DF,6B9
01A7C:  MOVFF  DE,6B8
01A80:  RCALL  12F8
01A82:  MOVFF  03,667
01A86:  MOVFF  02,666
01A8A:  MOVFF  01,665
01A8E:  MOVFF  00,664
01A92:  BCF    FD8.1
01A94:  MOVFF  03,6B6
01A98:  MOVFF  02,6B5
01A9C:  MOVFF  01,6B4
01AA0:  MOVFF  00,6B3
01AA4:  MOVFF  DD,6BA
01AA8:  MOVFF  DC,6B9
01AAC:  MOVFF  DB,6B8
01AB0:  MOVFF  DA,6B7
01AB4:  RCALL  13EE
01AB6:  MOVFF  03,10A
01ABA:  MOVFF  02,109
01ABE:  MOVFF  01,108
01AC2:  MOVFF  00,107
....................             set_adc_channel(vMon3V3D);
01AC6:  MOVLB  F
01AC8:  MOVF   x5A,W
01ACA:  ANDLW  3F
01ACC:  MOVWF  01
01ACE:  MOVLW  1A
01AD0:  MOVWF  x5A
01AD2:  BTFSS  x5B.7
01AD4:  BRA    1AE4
01AD6:  MOVF   01,W
01AD8:  SUBLW  1A
01ADA:  BZ    1AE4
01ADC:  BSF    x5B.0
01ADE:  NOP   
01AE0:  BTFSC  x5B.0
01AE2:  BRA    1AE0
....................             delay_ms(10);
01AE4:  MOVLW  0A
01AE6:  MOVLB  6
01AE8:  MOVWF  x6C
01AEA:  MOVLB  0
01AEC:  CALL   0426
....................             read_adc(ADC_START_ONLY);
01AF0:  MOVLB  F
01AF2:  BSF    x5B.0
01AF4:  NOP   
....................             state = 6;
01AF6:  MOVLW  06
01AF8:  MOVLB  1
01AFA:  MOVWF  xD7
....................          break;
01AFC:  BRA    1BB4
....................          
....................          case 6:    // vMon3V3D
....................             monitorVals.v3V3D = read_adc(ADC_READ_ONLY) * monCal.v3V3D[1] + monCal.v3V3D[0];
01AFE:  MOVLB  F
01B00:  BTFSC  x5B.0
01B02:  BRA    1B00
01B04:  MOVFF  F5F,02
01B08:  MOVFF  F5E,01
01B0C:  MOVFF  02,665
01B10:  MOVFF  01,664
01B14:  MOVFF  02,6B4
01B18:  MOVFF  01,6B3
01B1C:  MOVLB  0
01B1E:  CALL   12C2
01B22:  MOVFF  03,6B7
01B26:  MOVFF  02,6B6
01B2A:  MOVFF  01,6B5
01B2E:  MOVFF  00,6B4
01B32:  MOVFF  E9,6BB
01B36:  MOVFF  E8,6BA
01B3A:  MOVFF  E7,6B9
01B3E:  MOVFF  E6,6B8
01B42:  CALL   12F8
01B46:  MOVFF  03,667
01B4A:  MOVFF  02,666
01B4E:  MOVFF  01,665
01B52:  MOVFF  00,664
01B56:  BCF    FD8.1
01B58:  MOVFF  03,6B6
01B5C:  MOVFF  02,6B5
01B60:  MOVFF  01,6B4
01B64:  MOVFF  00,6B3
01B68:  MOVFF  E5,6BA
01B6C:  MOVFF  E4,6B9
01B70:  MOVFF  E3,6B8
01B74:  MOVFF  E2,6B7
01B78:  RCALL  13EE
01B7A:  MOVFF  03,10E
01B7E:  MOVFF  02,10D
01B82:  MOVFF  01,10C
01B86:  MOVFF  00,10B
....................             set_adc_channel(vMonN15);
01B8A:  MOVLB  F
01B8C:  MOVF   x5A,W
01B8E:  ANDLW  3F
01B90:  MOVWF  01
01B92:  MOVLW  06
01B94:  MOVWF  x5A
01B96:  BTFSS  x5B.7
01B98:  BRA    1BA8
01B9A:  MOVF   01,W
01B9C:  SUBLW  06
01B9E:  BZ    1BA8
01BA0:  BSF    x5B.0
01BA2:  NOP   
01BA4:  BTFSC  x5B.0
01BA6:  BRA    1BA4
....................             read_adc(ADC_START_ONLY);
01BA8:  BSF    x5B.0
01BAA:  NOP   
....................             state = 0;
01BAC:  MOVLB  1
01BAE:  CLRF   xD7
....................          break;   
01BB0:  BRA    1BB4
01BB2:  MOVLB  1
01BB4:  MOVLB  F
....................       }
....................    }
01BB6:  MOVLB  0
01BB8:  GOTO   AFC8 (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* PROCESS ADC SENSOR DATA                                                   */
.................... /*****************************************************************************/
.................... void sensor_process_data(int8 ch)//, signed int32 sinRawCounts, signed int32 cosRawCounts)
.................... {
....................    adcVals[ch].sinLast = adcVals[ch].sinCounts;
*
041A4:  MOVLB  6
041A6:  MOVF   x6C,W
041A8:  MULLW  21
041AA:  MOVF   FF3,W
041AC:  CLRF   x76
041AE:  MOVWF  x75
041B0:  MOVLW  10
041B2:  ADDWF  x75,W
041B4:  MOVWF  01
041B6:  MOVLW  00
041B8:  ADDWFC x76,W
041BA:  MOVWF  03
041BC:  MOVF   01,W
041BE:  ADDLW  0F
041C0:  MOVWF  01
041C2:  MOVLW  01
041C4:  ADDWFC 03,F
041C6:  MOVFF  01,675
041CA:  MOVFF  03,676
041CE:  MOVF   x6C,W
041D0:  MULLW  21
041D2:  MOVF   FF3,W
041D4:  CLRF   x78
041D6:  MOVWF  x77
041D8:  MOVLW  08
041DA:  ADDWF  x77,W
041DC:  MOVWF  01
041DE:  MOVLW  00
041E0:  ADDWFC x78,W
041E2:  MOVWF  03
041E4:  MOVF   01,W
041E6:  ADDLW  0F
041E8:  MOVWF  FE9
041EA:  MOVLW  01
041EC:  ADDWFC 03,W
041EE:  MOVWF  FEA
041F0:  MOVFF  FEF,00
041F4:  MOVFF  FEC,01
041F8:  MOVFF  FEC,02
041FC:  MOVFF  FEC,03
04200:  MOVFF  676,FEA
04204:  MOVFF  675,FE9
04208:  MOVFF  00,FEF
0420C:  MOVFF  01,FEC
04210:  MOVFF  02,FEC
04214:  MOVFF  03,FEC
....................    adcVals[ch].cosLast = adcVals[ch].cosCounts;
04218:  MOVF   x6C,W
0421A:  MULLW  21
0421C:  MOVF   FF3,W
0421E:  CLRF   x76
04220:  MOVWF  x75
04222:  MOVLW  14
04224:  ADDWF  x75,W
04226:  MOVWF  01
04228:  MOVLW  00
0422A:  ADDWFC x76,W
0422C:  MOVWF  03
0422E:  MOVF   01,W
04230:  ADDLW  0F
04232:  MOVWF  01
04234:  MOVLW  01
04236:  ADDWFC 03,F
04238:  MOVFF  01,675
0423C:  MOVFF  03,676
04240:  MOVF   x6C,W
04242:  MULLW  21
04244:  MOVF   FF3,W
04246:  CLRF   x78
04248:  MOVWF  x77
0424A:  MOVLW  0C
0424C:  ADDWF  x77,W
0424E:  MOVWF  01
04250:  MOVLW  00
04252:  ADDWFC x78,W
04254:  MOVWF  03
04256:  MOVF   01,W
04258:  ADDLW  0F
0425A:  MOVWF  FE9
0425C:  MOVLW  01
0425E:  ADDWFC 03,W
04260:  MOVWF  FEA
04262:  MOVFF  FEF,00
04266:  MOVFF  FEC,01
0426A:  MOVFF  FEC,02
0426E:  MOVFF  FEC,03
04272:  MOVFF  676,FEA
04276:  MOVFF  675,FE9
0427A:  MOVFF  00,FEF
0427E:  MOVFF  01,FEC
04282:  MOVFF  02,FEC
04286:  MOVFF  03,FEC
....................    
....................    adcVals[ch].sinRaw = (float)smData[ch].avgSin;
0428A:  MOVF   x6C,W
0428C:  MULLW  21
0428E:  MOVF   FF3,W
04290:  CLRF   x76
04292:  MOVWF  x75
04294:  MOVLW  0F
04296:  ADDWF  x75,W
04298:  MOVWF  01
0429A:  MOVLW  01
0429C:  ADDWFC x76,W
0429E:  MOVWF  03
042A0:  MOVFF  01,677
042A4:  MOVWF  x78
042A6:  MOVF   x6C,W
042A8:  MULLW  0D
042AA:  MOVF   FF3,W
042AC:  CLRF   x7A
042AE:  MOVWF  x79
042B0:  MOVLW  05
042B2:  ADDWF  x79,W
042B4:  MOVWF  01
042B6:  MOVLW  00
042B8:  ADDWFC x7A,W
042BA:  MOVWF  03
042BC:  MOVF   01,W
042BE:  ADDLW  BD
042C0:  MOVWF  FE9
042C2:  MOVLW  01
042C4:  ADDWFC 03,W
042C6:  MOVWF  FEA
042C8:  MOVFF  FEF,679
042CC:  MOVFF  FEC,01
042D0:  MOVFF  FEC,02
042D4:  MOVFF  FEC,03
042D8:  MOVFF  03,67C
042DC:  MOVFF  02,67B
042E0:  MOVFF  01,67A
042E4:  MOVLB  0
042E6:  CALL   276A
042EA:  MOVFF  678,FEA
042EE:  MOVFF  677,FE9
042F2:  MOVFF  00,FEF
042F6:  MOVFF  01,FEC
042FA:  MOVFF  02,FEC
042FE:  MOVFF  03,FEC
....................    adcVals[ch].cosRaw = (float)smData[ch].avgCos;
04302:  MOVLB  6
04304:  MOVF   x6C,W
04306:  MULLW  21
04308:  MOVF   FF3,W
0430A:  CLRF   x76
0430C:  MOVWF  x75
0430E:  MOVLW  04
04310:  ADDWF  x75,W
04312:  MOVWF  01
04314:  MOVLW  00
04316:  ADDWFC x76,W
04318:  MOVWF  03
0431A:  MOVF   01,W
0431C:  ADDLW  0F
0431E:  MOVWF  01
04320:  MOVLW  01
04322:  ADDWFC 03,F
04324:  MOVFF  01,675
04328:  MOVFF  03,676
0432C:  MOVF   x6C,W
0432E:  MULLW  0D
04330:  MOVF   FF3,W
04332:  CLRF   x78
04334:  MOVWF  x77
04336:  MOVLW  09
04338:  ADDWF  x77,W
0433A:  MOVWF  01
0433C:  MOVLW  00
0433E:  ADDWFC x78,W
04340:  MOVWF  03
04342:  MOVF   01,W
04344:  ADDLW  BD
04346:  MOVWF  FE9
04348:  MOVLW  01
0434A:  ADDWFC 03,W
0434C:  MOVWF  FEA
0434E:  MOVFF  FEF,679
04352:  MOVFF  FEC,01
04356:  MOVFF  FEC,02
0435A:  MOVFF  FEC,03
0435E:  MOVFF  03,67C
04362:  MOVFF  02,67B
04366:  MOVFF  01,67A
0436A:  MOVLB  0
0436C:  CALL   276A
04370:  MOVFF  676,FEA
04374:  MOVFF  675,FE9
04378:  MOVFF  00,FEF
0437C:  MOVFF  01,FEC
04380:  MOVFF  02,FEC
04384:  MOVFF  03,FEC
....................    
....................    adcVals[ch].sinCounts = adcVals[ch].sinRaw * adcCal[ch].sinGain + adcCal[ch].sinOS;
04388:  MOVLB  6
0438A:  MOVF   x6C,W
0438C:  MULLW  21
0438E:  MOVF   FF3,W
04390:  CLRF   x76
04392:  MOVWF  x75
04394:  MOVLW  08
04396:  ADDWF  x75,W
04398:  MOVWF  01
0439A:  MOVLW  00
0439C:  ADDWFC x76,W
0439E:  MOVWF  03
043A0:  MOVF   01,W
043A2:  ADDLW  0F
043A4:  MOVWF  01
043A6:  MOVLW  01
043A8:  ADDWFC 03,F
043AA:  MOVFF  01,675
043AE:  MOVFF  03,676
043B2:  MOVF   x6C,W
043B4:  MULLW  21
043B6:  MOVF   FF3,W
043B8:  CLRF   x78
043BA:  MOVWF  x77
043BC:  MOVLW  0F
043BE:  ADDWF  x77,W
043C0:  MOVWF  FE9
043C2:  MOVLW  01
043C4:  ADDWFC x78,W
043C6:  MOVWF  FEA
043C8:  MOVFF  FEF,6B4
043CC:  MOVFF  FEC,6B5
043D0:  MOVFF  FEC,6B6
043D4:  MOVFF  FEC,6B7
043D8:  MOVF   x6C,W
043DA:  MULLW  10
043DC:  MOVF   FF3,W
043DE:  CLRF   x7E
043E0:  MOVWF  x7D
043E2:  MOVLW  08
043E4:  ADDWF  x7D,W
043E6:  MOVWF  01
043E8:  MOVLW  00
043EA:  ADDWFC x7E,W
043EC:  MOVWF  03
043EE:  MOVF   01,W
043F0:  ADDLW  62
043F2:  MOVWF  FE9
043F4:  MOVLW  00
043F6:  ADDWFC 03,W
043F8:  MOVWF  FEA
043FA:  MOVFF  FEF,6B8
043FE:  MOVFF  FEC,01
04402:  MOVFF  FEC,02
04406:  MOVFF  FEC,03
0440A:  MOVFF  03,6BB
0440E:  MOVFF  02,6BA
04412:  MOVFF  01,6B9
04416:  MOVLB  0
04418:  CALL   12F8
0441C:  MOVFF  03,6B6
04420:  MOVFF  02,6B5
04424:  MOVFF  01,6B4
04428:  MOVFF  00,6B3
0442C:  MOVLB  6
0442E:  MOVF   x6C,W
04430:  MULLW  10
04432:  MOVF   FF3,W
04434:  CLRF   x7E
04436:  MOVWF  x7D
04438:  MOVLW  62
0443A:  ADDWF  x7D,W
0443C:  MOVWF  FE9
0443E:  MOVLW  00
04440:  ADDWFC x7E,W
04442:  MOVWF  FEA
04444:  MOVFF  FEF,6B7
04448:  MOVFF  FEC,01
0444C:  MOVFF  FEC,02
04450:  MOVFF  FEC,03
04454:  BCF    FD8.1
04456:  MOVFF  03,6BA
0445A:  MOVFF  02,6B9
0445E:  MOVFF  01,6B8
04462:  MOVLB  0
04464:  CALL   13EE
04468:  MOVFF  676,FEA
0446C:  MOVFF  675,FE9
04470:  MOVFF  00,FEF
04474:  MOVFF  01,FEC
04478:  MOVFF  02,FEC
0447C:  MOVFF  03,FEC
....................    adcVals[ch].cosCounts = adcVals[ch].cosRaw * adcCal[ch].cosGain + adcCal[ch].cosOS;
04480:  MOVLB  6
04482:  MOVF   x6C,W
04484:  MULLW  21
04486:  MOVF   FF3,W
04488:  CLRF   x76
0448A:  MOVWF  x75
0448C:  MOVLW  0C
0448E:  ADDWF  x75,W
04490:  MOVWF  01
04492:  MOVLW  00
04494:  ADDWFC x76,W
04496:  MOVWF  03
04498:  MOVF   01,W
0449A:  ADDLW  0F
0449C:  MOVWF  01
0449E:  MOVLW  01
044A0:  ADDWFC 03,F
044A2:  MOVFF  01,675
044A6:  MOVFF  03,676
044AA:  MOVF   x6C,W
044AC:  MULLW  21
044AE:  MOVF   FF3,W
044B0:  CLRF   x78
044B2:  MOVWF  x77
044B4:  MOVLW  04
044B6:  ADDWF  x77,W
044B8:  MOVWF  01
044BA:  MOVLW  00
044BC:  ADDWFC x78,W
044BE:  MOVWF  03
044C0:  MOVF   01,W
044C2:  ADDLW  0F
044C4:  MOVWF  FE9
044C6:  MOVLW  01
044C8:  ADDWFC 03,W
044CA:  MOVWF  FEA
044CC:  MOVFF  FEF,6B4
044D0:  MOVFF  FEC,6B5
044D4:  MOVFF  FEC,6B6
044D8:  MOVFF  FEC,6B7
044DC:  MOVF   x6C,W
044DE:  MULLW  10
044E0:  MOVF   FF3,W
044E2:  CLRF   x7C
044E4:  MOVWF  x7B
044E6:  MOVLW  0C
044E8:  ADDWF  x7B,W
044EA:  MOVWF  01
044EC:  MOVLW  00
044EE:  ADDWFC x7C,W
044F0:  MOVWF  03
044F2:  MOVF   01,W
044F4:  ADDLW  62
044F6:  MOVWF  FE9
044F8:  MOVLW  00
044FA:  ADDWFC 03,W
044FC:  MOVWF  FEA
044FE:  MOVFF  FEF,6B8
04502:  MOVFF  FEC,01
04506:  MOVFF  FEC,02
0450A:  MOVFF  FEC,03
0450E:  MOVFF  03,6BB
04512:  MOVFF  02,6BA
04516:  MOVFF  01,6B9
0451A:  MOVLB  0
0451C:  CALL   12F8
04520:  MOVFF  03,6B6
04524:  MOVFF  02,6B5
04528:  MOVFF  01,6B4
0452C:  MOVFF  00,6B3
04530:  MOVLB  6
04532:  MOVF   x6C,W
04534:  MULLW  10
04536:  MOVF   FF3,W
04538:  CLRF   x7C
0453A:  MOVWF  x7B
0453C:  MOVLW  04
0453E:  ADDWF  x7B,W
04540:  MOVWF  01
04542:  MOVLW  00
04544:  ADDWFC x7C,W
04546:  MOVWF  03
04548:  MOVF   01,W
0454A:  ADDLW  62
0454C:  MOVWF  FE9
0454E:  MOVLW  00
04550:  ADDWFC 03,W
04552:  MOVWF  FEA
04554:  MOVFF  FEF,6B7
04558:  MOVFF  FEC,01
0455C:  MOVFF  FEC,02
04560:  MOVFF  FEC,03
04564:  BCF    FD8.1
04566:  MOVFF  03,6BA
0456A:  MOVFF  02,6B9
0456E:  MOVFF  01,6B8
04572:  MOVLB  0
04574:  CALL   13EE
04578:  MOVFF  676,FEA
0457C:  MOVFF  675,FE9
04580:  MOVFF  00,FEF
04584:  MOVFF  01,FEC
04588:  MOVFF  02,FEC
0458C:  MOVFF  03,FEC
....................    float pTmp = 0;
....................    float polePitch = magPP;
04590:  MOVLB  6
04592:  CLRF   x70
04594:  CLRF   x6F
04596:  CLRF   x6E
04598:  CLRF   x6D
0459A:  CLRF   x74
0459C:  CLRF   x73
0459E:  CLRF   x72
045A0:  MOVLW  7F
045A2:  MOVWF  x71
....................    
....................    if (adcVals[ch].cosCounts < 0){
045A4:  MOVF   x6C,W
045A6:  MULLW  21
045A8:  MOVF   FF3,W
045AA:  CLRF   x76
045AC:  MOVWF  x75
045AE:  MOVLW  0C
045B0:  ADDWF  x75,W
045B2:  MOVWF  01
045B4:  MOVLW  00
045B6:  ADDWFC x76,W
045B8:  MOVWF  03
045BA:  MOVF   01,W
045BC:  ADDLW  0F
045BE:  MOVWF  FE9
045C0:  MOVLW  01
045C2:  ADDWFC 03,W
045C4:  MOVWF  FEA
045C6:  MOVFF  FEF,6AF
045CA:  MOVFF  FEC,6B0
045CE:  MOVFF  FEC,6B1
045D2:  MOVFF  FEC,6B2
045D6:  CLRF   xB6
045D8:  CLRF   xB5
045DA:  CLRF   xB4
045DC:  CLRF   xB3
045DE:  MOVLB  0
045E0:  CALL   27C4
045E4:  BTFSS  FD8.0
045E6:  BRA    4750
....................       if ((adcVals[ch].sinCounts > 0) && (adcVals[ch].sinLast < 0)){
045E8:  MOVLB  6
045EA:  MOVF   x6C,W
045EC:  MULLW  21
045EE:  MOVF   FF3,W
045F0:  CLRF   x76
045F2:  MOVWF  x75
045F4:  MOVLW  08
045F6:  ADDWF  x75,W
045F8:  MOVWF  01
045FA:  MOVLW  00
045FC:  ADDWFC x76,W
045FE:  MOVWF  03
04600:  MOVF   01,W
04602:  ADDLW  0F
04604:  MOVWF  FE9
04606:  MOVLW  01
04608:  ADDWFC 03,W
0460A:  MOVWF  FEA
0460C:  MOVFF  FEF,6B3
04610:  MOVFF  FEC,676
04614:  MOVFF  FEC,6B5
04618:  MOVFF  FEC,6B6
0461C:  CLRF   xB2
0461E:  CLRF   xB1
04620:  CLRF   xB0
04622:  CLRF   xAF
04624:  MOVFF  676,6B4
04628:  MOVLB  0
0462A:  CALL   27C4
0462E:  BNC   469C
04630:  MOVLB  6
04632:  MOVF   x6C,W
04634:  MULLW  21
04636:  MOVF   FF3,W
04638:  CLRF   x76
0463A:  MOVWF  x75
0463C:  MOVLW  10
0463E:  ADDWF  x75,W
04640:  MOVWF  01
04642:  MOVLW  00
04644:  ADDWFC x76,W
04646:  MOVWF  03
04648:  MOVF   01,W
0464A:  ADDLW  0F
0464C:  MOVWF  FE9
0464E:  MOVLW  01
04650:  ADDWFC 03,W
04652:  MOVWF  FEA
04654:  MOVFF  FEF,6AF
04658:  MOVFF  FEC,6B0
0465C:  MOVFF  FEC,6B1
04660:  MOVFF  FEC,6B2
04664:  CLRF   xB6
04666:  CLRF   xB5
04668:  CLRF   xB4
0466A:  CLRF   xB3
0466C:  MOVLB  0
0466E:  CALL   27C4
04672:  BNC   469C
....................          adcVals[ch].npoles--;
04674:  MOVLB  6
04676:  MOVF   x6C,W
04678:  MULLW  21
0467A:  MOVF   FF3,W
0467C:  CLRF   x76
0467E:  MOVWF  x75
04680:  MOVLW  1C
04682:  ADDWF  x75,W
04684:  MOVWF  01
04686:  MOVLW  00
04688:  ADDWFC x76,W
0468A:  MOVWF  03
0468C:  MOVF   01,W
0468E:  ADDLW  0F
04690:  MOVWF  FE9
04692:  MOVLW  01
04694:  ADDWFC 03,W
04696:  MOVWF  FEA
04698:  DECF   FEF,F
....................       }
0469A:  BRA    474E
....................       else if ((adcVals[ch].sinCounts < 0) && (adcVals[ch].sinLast > 0)){
0469C:  MOVLB  6
0469E:  MOVF   x6C,W
046A0:  MULLW  21
046A2:  MOVF   FF3,W
046A4:  CLRF   x76
046A6:  MOVWF  x75
046A8:  MOVLW  08
046AA:  ADDWF  x75,W
046AC:  MOVWF  01
046AE:  MOVLW  00
046B0:  ADDWFC x76,W
046B2:  MOVWF  03
046B4:  MOVF   01,W
046B6:  ADDLW  0F
046B8:  MOVWF  FE9
046BA:  MOVLW  01
046BC:  ADDWFC 03,W
046BE:  MOVWF  FEA
046C0:  MOVFF  FEF,6AF
046C4:  MOVFF  FEC,676
046C8:  MOVFF  FEC,6B1
046CC:  MOVFF  FEC,6B2
046D0:  MOVFF  676,6B0
046D4:  CLRF   xB6
046D6:  CLRF   xB5
046D8:  CLRF   xB4
046DA:  CLRF   xB3
046DC:  MOVLB  0
046DE:  CALL   27C4
046E2:  BNC   4750
046E4:  MOVLB  6
046E6:  MOVF   x6C,W
046E8:  MULLW  21
046EA:  MOVF   FF3,W
046EC:  CLRF   x76
046EE:  MOVWF  x75
046F0:  MOVLW  10
046F2:  ADDWF  x75,W
046F4:  MOVWF  01
046F6:  MOVLW  00
046F8:  ADDWFC x76,W
046FA:  MOVWF  03
046FC:  MOVF   01,W
046FE:  ADDLW  0F
04700:  MOVWF  FE9
04702:  MOVLW  01
04704:  ADDWFC 03,W
04706:  MOVWF  FEA
04708:  MOVFF  FEF,6B3
0470C:  MOVFF  FEC,6B4
04710:  MOVFF  FEC,6B5
04714:  MOVFF  FEC,6B6
04718:  CLRF   xB2
0471A:  CLRF   xB1
0471C:  CLRF   xB0
0471E:  CLRF   xAF
04720:  MOVLB  0
04722:  CALL   27C4
04726:  BNC   4750
....................          adcVals[ch].npoles++;
04728:  MOVLB  6
0472A:  MOVF   x6C,W
0472C:  MULLW  21
0472E:  MOVF   FF3,W
04730:  CLRF   x76
04732:  MOVWF  x75
04734:  MOVLW  1C
04736:  ADDWF  x75,W
04738:  MOVWF  01
0473A:  MOVLW  00
0473C:  ADDWFC x76,W
0473E:  MOVWF  03
04740:  MOVF   01,W
04742:  ADDLW  0F
04744:  MOVWF  FE9
04746:  MOVLW  01
04748:  ADDWFC 03,W
0474A:  MOVWF  FEA
0474C:  INCF   FEF,F
0474E:  MOVLB  0
....................       }
....................    }
....................    
....................    adcVals[ch].p0 = polePitch * ( 1000 / (2*PI) ) * atan2( (float)adcVals[ch].sinCounts, (float)adcVals[ch].cosCounts );
04750:  MOVLB  6
04752:  MOVF   x6C,W
04754:  MULLW  21
04756:  MOVF   FF3,W
04758:  CLRF   x76
0475A:  MOVWF  x75
0475C:  MOVLW  18
0475E:  ADDWF  x75,W
04760:  MOVWF  01
04762:  MOVLW  00
04764:  ADDWFC x76,W
04766:  MOVWF  03
04768:  MOVF   01,W
0476A:  ADDLW  0F
0476C:  MOVWF  01
0476E:  MOVLW  01
04770:  ADDWFC 03,F
04772:  MOVFF  01,675
04776:  MOVFF  03,676
0477A:  MOVFF  674,6B7
0477E:  MOVFF  673,6B6
04782:  MOVFF  672,6B5
04786:  MOVFF  671,6B4
0478A:  MOVLW  AA
0478C:  MOVWF  xBB
0478E:  MOVLW  27
04790:  MOVWF  xBA
04792:  MOVLW  1F
04794:  MOVWF  xB9
04796:  MOVLW  86
04798:  MOVWF  xB8
0479A:  MOVLB  0
0479C:  CALL   12F8
047A0:  MOVFF  03,67A
047A4:  MOVFF  02,679
047A8:  MOVFF  01,678
047AC:  MOVFF  00,677
047B0:  MOVLB  6
047B2:  MOVF   x6C,W
047B4:  MULLW  21
047B6:  MOVF   FF3,W
047B8:  CLRF   x7C
047BA:  MOVWF  x7B
047BC:  MOVLW  08
047BE:  ADDWF  x7B,W
047C0:  MOVWF  01
047C2:  MOVLW  00
047C4:  ADDWFC x7C,W
047C6:  MOVWF  03
047C8:  MOVF   01,W
047CA:  ADDLW  0F
047CC:  MOVWF  FE9
047CE:  MOVLW  01
047D0:  ADDWFC 03,W
047D2:  MOVWF  FEA
047D4:  MOVFF  FEF,67B
047D8:  MOVFF  FEC,67C
047DC:  MOVFF  FEC,67D
047E0:  MOVFF  FEC,67E
047E4:  MOVF   x6C,W
047E6:  MULLW  21
047E8:  MOVF   FF3,W
047EA:  CLRF   x80
047EC:  MOVWF  x7F
047EE:  MOVLW  0C
047F0:  ADDWF  x7F,W
047F2:  MOVWF  01
047F4:  MOVLW  00
047F6:  ADDWFC x80,W
047F8:  MOVWF  03
047FA:  MOVF   01,W
047FC:  ADDLW  0F
047FE:  MOVWF  FE9
04800:  MOVLW  01
04802:  ADDWFC 03,W
04804:  MOVWF  FEA
04806:  MOVFF  FEF,00
0480A:  MOVFF  FEC,01
0480E:  MOVFF  FEC,02
04812:  MOVFF  FEC,03
04816:  MOVFF  03,682
0481A:  MOVFF  02,681
0481E:  MOVFF  01,680
04822:  MOVFF  00,67F
04826:  MOVFF  67E,686
0482A:  MOVFF  67D,685
0482E:  MOVFF  67C,684
04832:  MOVFF  67B,683
04836:  MOVFF  03,68A
0483A:  MOVFF  02,689
0483E:  MOVFF  01,688
04842:  MOVFF  00,687
04846:  MOVLB  0
04848:  GOTO   2EC6
0484C:  MOVFF  67A,6B7
04850:  MOVFF  679,6B6
04854:  MOVFF  678,6B5
04858:  MOVFF  677,6B4
0485C:  MOVFF  03,6BB
04860:  MOVFF  02,6BA
04864:  MOVFF  01,6B9
04868:  MOVFF  00,6B8
0486C:  CALL   12F8
04870:  MOVFF  676,FEA
04874:  MOVFF  675,FE9
04878:  MOVFF  00,FEF
0487C:  MOVFF  01,FEC
04880:  MOVFF  02,FEC
04884:  MOVFF  03,FEC
....................    pTmp = adcVals[ch].p0 + ( 1000 * polePitch * (float)adcVals[ch].npoles );
04888:  MOVLB  6
0488A:  MOVF   x6C,W
0488C:  MULLW  21
0488E:  MOVF   FF3,W
04890:  CLRF   x76
04892:  MOVWF  x75
04894:  MOVLW  18
04896:  ADDWF  x75,W
04898:  MOVWF  01
0489A:  MOVLW  00
0489C:  ADDWFC x76,W
0489E:  MOVWF  03
048A0:  MOVF   01,W
048A2:  ADDLW  0F
048A4:  MOVWF  FE9
048A6:  MOVLW  01
048A8:  ADDWFC 03,W
048AA:  MOVWF  FEA
048AC:  MOVFF  FEF,675
048B0:  MOVFF  FEC,676
048B4:  MOVFF  FEC,677
048B8:  MOVFF  FEC,678
048BC:  CLRF   xB7
048BE:  CLRF   xB6
048C0:  MOVLW  7A
048C2:  MOVWF  xB5
048C4:  MOVLW  88
048C6:  MOVWF  xB4
048C8:  MOVFF  674,6BB
048CC:  MOVFF  673,6BA
048D0:  MOVFF  672,6B9
048D4:  MOVFF  671,6B8
048D8:  MOVLB  0
048DA:  CALL   12F8
048DE:  MOVFF  03,67C
048E2:  MOVFF  02,67B
048E6:  MOVFF  01,67A
048EA:  MOVFF  00,679
048EE:  MOVLB  6
048F0:  MOVF   x6C,W
048F2:  MULLW  21
048F4:  MOVF   FF3,W
048F6:  CLRF   x7E
048F8:  MOVWF  x7D
048FA:  MOVLW  1C
048FC:  ADDWF  x7D,W
048FE:  MOVWF  01
04900:  MOVLW  00
04902:  ADDWFC x7E,W
04904:  MOVWF  03
04906:  MOVF   01,W
04908:  ADDLW  0F
0490A:  MOVWF  FE9
0490C:  MOVLW  01
0490E:  ADDWFC 03,W
04910:  MOVWF  FEA
04912:  MOVF   FEF,W
04914:  CLRF   xA6
04916:  MOVWF  xA5
04918:  BTFSC  xA5.7
0491A:  DECF   xA6,F
0491C:  MOVLB  0
0491E:  CALL   3168
04922:  MOVFF  67C,6B7
04926:  MOVFF  67B,6B6
0492A:  MOVFF  67A,6B5
0492E:  MOVFF  679,6B4
04932:  MOVFF  03,6BB
04936:  MOVFF  02,6BA
0493A:  MOVFF  01,6B9
0493E:  MOVFF  00,6B8
04942:  CALL   12F8
04946:  MOVFF  FEA,67A
0494A:  MOVFF  FE9,679
0494E:  BCF    FD8.1
04950:  MOVFF  678,6B6
04954:  MOVFF  677,6B5
04958:  MOVFF  676,6B4
0495C:  MOVFF  675,6B3
04960:  MOVFF  03,6BA
04964:  MOVFF  02,6B9
04968:  MOVFF  01,6B8
0496C:  MOVFF  00,6B7
04970:  CALL   13EE
04974:  MOVFF  67A,FEA
04978:  MOVFF  679,FE9
0497C:  MOVFF  03,670
04980:  MOVFF  02,66F
04984:  MOVFF  01,66E
04988:  MOVFF  00,66D
....................    
....................    adcVals[ch].pReal = (pow(pTmp*sc[ch].c5,5) + pow(pTmp*sc[ch].c4,4) + pow(pTmp*sc[ch].c3,3) + pow(pTmp*sc[ch].c2,2) + pTmp*sc[ch].c1 + sc[ch].c0);
0498C:  MOVLB  6
0498E:  MOVF   x6C,W
04990:  MULLW  21
04992:  MOVF   FF3,W
04994:  CLRF   x76
04996:  MOVWF  x75
04998:  MOVLW  1D
0499A:  ADDWF  x75,W
0499C:  MOVWF  01
0499E:  MOVLW  00
049A0:  ADDWFC x76,W
049A2:  MOVWF  03
049A4:  MOVF   01,W
049A6:  ADDLW  0F
049A8:  MOVWF  01
049AA:  MOVLW  01
049AC:  ADDWFC 03,F
049AE:  MOVFF  01,675
049B2:  MOVFF  03,676
049B6:  MOVF   x6C,W
049B8:  MULLW  18
049BA:  MOVF   FF3,W
049BC:  CLRF   x78
049BE:  MOVWF  x77
049C0:  MOVLW  14
049C2:  ADDWF  x77,W
049C4:  MOVWF  01
049C6:  MOVLW  00
049C8:  ADDWFC x78,W
049CA:  MOVWF  03
049CC:  MOVF   01,W
049CE:  ADDLW  82
049D0:  MOVWF  FE9
049D2:  MOVLW  00
049D4:  ADDWFC 03,W
049D6:  MOVWF  FEA
049D8:  MOVFF  FEF,6B8
049DC:  MOVFF  FEC,01
049E0:  MOVFF  FEC,02
049E4:  MOVFF  FEC,03
049E8:  MOVFF  670,6B7
049EC:  MOVFF  66F,6B6
049F0:  MOVFF  66E,6B5
049F4:  MOVFF  66D,6B4
049F8:  MOVFF  03,6BB
049FC:  MOVFF  02,6BA
04A00:  MOVFF  01,6B9
04A04:  MOVLB  0
04A06:  CALL   12F8
04A0A:  MOVFF  03,67A
04A0E:  MOVFF  02,679
04A12:  MOVFF  01,678
04A16:  MOVFF  00,677
04A1A:  MOVFF  03,686
04A1E:  MOVFF  02,685
04A22:  MOVFF  01,684
04A26:  MOVFF  00,683
04A2A:  MOVLB  6
04A2C:  CLRF   x8A
04A2E:  CLRF   x89
04A30:  MOVLW  20
04A32:  MOVWF  x88
04A34:  MOVLW  81
04A36:  MOVWF  x87
04A38:  MOVLB  0
04A3A:  CALL   3EA6
04A3E:  MOVFF  03,67A
04A42:  MOVFF  02,679
04A46:  MOVFF  01,678
04A4A:  MOVFF  00,677
04A4E:  MOVLB  6
04A50:  MOVF   x6C,W
04A52:  MULLW  18
04A54:  MOVF   FF3,W
04A56:  CLRF   x7C
04A58:  MOVWF  x7B
04A5A:  MOVLW  10
04A5C:  ADDWF  x7B,W
04A5E:  MOVWF  01
04A60:  MOVLW  00
04A62:  ADDWFC x7C,W
04A64:  MOVWF  03
04A66:  MOVF   01,W
04A68:  ADDLW  82
04A6A:  MOVWF  FE9
04A6C:  MOVLW  00
04A6E:  ADDWFC 03,W
04A70:  MOVWF  FEA
04A72:  MOVFF  FEF,6B8
04A76:  MOVFF  FEC,01
04A7A:  MOVFF  FEC,02
04A7E:  MOVFF  FEC,03
04A82:  MOVFF  670,6B7
04A86:  MOVFF  66F,6B6
04A8A:  MOVFF  66E,6B5
04A8E:  MOVFF  66D,6B4
04A92:  MOVFF  03,6BB
04A96:  MOVFF  02,6BA
04A9A:  MOVFF  01,6B9
04A9E:  MOVLB  0
04AA0:  CALL   12F8
04AA4:  MOVFF  03,67E
04AA8:  MOVFF  02,67D
04AAC:  MOVFF  01,67C
04AB0:  MOVFF  00,67B
04AB4:  MOVFF  03,686
04AB8:  MOVFF  02,685
04ABC:  MOVFF  01,684
04AC0:  MOVFF  00,683
04AC4:  MOVLB  6
04AC6:  CLRF   x8A
04AC8:  CLRF   x89
04ACA:  CLRF   x88
04ACC:  MOVLW  81
04ACE:  MOVWF  x87
04AD0:  MOVLB  0
04AD2:  CALL   3EA6
04AD6:  MOVFF  FEA,67C
04ADA:  MOVFF  FE9,67B
04ADE:  BCF    FD8.1
04AE0:  MOVFF  67A,6B6
04AE4:  MOVFF  679,6B5
04AE8:  MOVFF  678,6B4
04AEC:  MOVFF  677,6B3
04AF0:  MOVFF  03,6BA
04AF4:  MOVFF  02,6B9
04AF8:  MOVFF  01,6B8
04AFC:  MOVFF  00,6B7
04B00:  CALL   13EE
04B04:  MOVFF  67C,FEA
04B08:  MOVFF  67B,FE9
04B0C:  MOVFF  03,67A
04B10:  MOVFF  02,679
04B14:  MOVFF  01,678
04B18:  MOVFF  00,677
04B1C:  MOVLB  6
04B1E:  MOVF   x6C,W
04B20:  MULLW  18
04B22:  MOVF   FF3,W
04B24:  CLRF   x7E
04B26:  MOVWF  x7D
04B28:  MOVLW  0C
04B2A:  ADDWF  x7D,W
04B2C:  MOVWF  01
04B2E:  MOVLW  00
04B30:  ADDWFC x7E,W
04B32:  MOVWF  03
04B34:  MOVF   01,W
04B36:  ADDLW  82
04B38:  MOVWF  FE9
04B3A:  MOVLW  00
04B3C:  ADDWFC 03,W
04B3E:  MOVWF  FEA
04B40:  MOVFF  FEF,6B8
04B44:  MOVFF  FEC,01
04B48:  MOVFF  FEC,02
04B4C:  MOVFF  FEC,03
04B50:  MOVFF  670,6B7
04B54:  MOVFF  66F,6B6
04B58:  MOVFF  66E,6B5
04B5C:  MOVFF  66D,6B4
04B60:  MOVFF  03,6BB
04B64:  MOVFF  02,6BA
04B68:  MOVFF  01,6B9
04B6C:  MOVLB  0
04B6E:  CALL   12F8
04B72:  MOVFF  03,680
04B76:  MOVFF  02,67F
04B7A:  MOVFF  01,67E
04B7E:  MOVFF  00,67D
04B82:  MOVFF  03,686
04B86:  MOVFF  02,685
04B8A:  MOVFF  01,684
04B8E:  MOVFF  00,683
04B92:  MOVLB  6
04B94:  CLRF   x8A
04B96:  CLRF   x89
04B98:  MOVLW  40
04B9A:  MOVWF  x88
04B9C:  MOVLW  80
04B9E:  MOVWF  x87
04BA0:  MOVLB  0
04BA2:  CALL   3EA6
04BA6:  MOVFF  FEA,67E
04BAA:  MOVFF  FE9,67D
04BAE:  BCF    FD8.1
04BB0:  MOVFF  67A,6B6
04BB4:  MOVFF  679,6B5
04BB8:  MOVFF  678,6B4
04BBC:  MOVFF  677,6B3
04BC0:  MOVFF  03,6BA
04BC4:  MOVFF  02,6B9
04BC8:  MOVFF  01,6B8
04BCC:  MOVFF  00,6B7
04BD0:  CALL   13EE
04BD4:  MOVFF  67E,FEA
04BD8:  MOVFF  67D,FE9
04BDC:  MOVFF  03,67A
04BE0:  MOVFF  02,679
04BE4:  MOVFF  01,678
04BE8:  MOVFF  00,677
04BEC:  MOVLB  6
04BEE:  MOVF   x6C,W
04BF0:  MULLW  18
04BF2:  MOVF   FF3,W
04BF4:  CLRF   x80
04BF6:  MOVWF  x7F
04BF8:  MOVLW  08
04BFA:  ADDWF  x7F,W
04BFC:  MOVWF  01
04BFE:  MOVLW  00
04C00:  ADDWFC x80,W
04C02:  MOVWF  03
04C04:  MOVF   01,W
04C06:  ADDLW  82
04C08:  MOVWF  FE9
04C0A:  MOVLW  00
04C0C:  ADDWFC 03,W
04C0E:  MOVWF  FEA
04C10:  MOVFF  FEF,6B8
04C14:  MOVFF  FEC,01
04C18:  MOVFF  FEC,02
04C1C:  MOVFF  FEC,03
04C20:  MOVFF  670,6B7
04C24:  MOVFF  66F,6B6
04C28:  MOVFF  66E,6B5
04C2C:  MOVFF  66D,6B4
04C30:  MOVFF  03,6BB
04C34:  MOVFF  02,6BA
04C38:  MOVFF  01,6B9
04C3C:  MOVLB  0
04C3E:  CALL   12F8
04C42:  MOVFF  03,682
04C46:  MOVFF  02,681
04C4A:  MOVFF  01,680
04C4E:  MOVFF  00,67F
04C52:  MOVFF  03,686
04C56:  MOVFF  02,685
04C5A:  MOVFF  01,684
04C5E:  MOVFF  00,683
04C62:  MOVLB  6
04C64:  CLRF   x8A
04C66:  CLRF   x89
04C68:  CLRF   x88
04C6A:  MOVLW  80
04C6C:  MOVWF  x87
04C6E:  MOVLB  0
04C70:  CALL   3EA6
04C74:  MOVFF  FEA,680
04C78:  MOVFF  FE9,67F
04C7C:  BCF    FD8.1
04C7E:  MOVFF  67A,6B6
04C82:  MOVFF  679,6B5
04C86:  MOVFF  678,6B4
04C8A:  MOVFF  677,6B3
04C8E:  MOVFF  03,6BA
04C92:  MOVFF  02,6B9
04C96:  MOVFF  01,6B8
04C9A:  MOVFF  00,6B7
04C9E:  CALL   13EE
04CA2:  MOVFF  680,FEA
04CA6:  MOVFF  67F,FE9
04CAA:  MOVFF  03,67A
04CAE:  MOVFF  02,679
04CB2:  MOVFF  01,678
04CB6:  MOVFF  00,677
04CBA:  MOVLB  6
04CBC:  MOVF   x6C,W
04CBE:  MULLW  18
04CC0:  MOVF   FF3,W
04CC2:  CLRF   x82
04CC4:  MOVWF  x81
04CC6:  MOVLW  04
04CC8:  ADDWF  x81,W
04CCA:  MOVWF  01
04CCC:  MOVLW  00
04CCE:  ADDWFC x82,W
04CD0:  MOVWF  03
04CD2:  MOVF   01,W
04CD4:  ADDLW  82
04CD6:  MOVWF  FE9
04CD8:  MOVLW  00
04CDA:  ADDWFC 03,W
04CDC:  MOVWF  FEA
04CDE:  MOVFF  FEF,6B8
04CE2:  MOVFF  FEC,01
04CE6:  MOVFF  FEC,02
04CEA:  MOVFF  FEC,03
04CEE:  MOVFF  670,6B7
04CF2:  MOVFF  66F,6B6
04CF6:  MOVFF  66E,6B5
04CFA:  MOVFF  66D,6B4
04CFE:  MOVFF  03,6BB
04D02:  MOVFF  02,6BA
04D06:  MOVFF  01,6B9
04D0A:  MOVLB  0
04D0C:  CALL   12F8
04D10:  MOVFF  FEA,682
04D14:  MOVFF  FE9,681
04D18:  BCF    FD8.1
04D1A:  MOVFF  67A,6B6
04D1E:  MOVFF  679,6B5
04D22:  MOVFF  678,6B4
04D26:  MOVFF  677,6B3
04D2A:  MOVFF  03,6BA
04D2E:  MOVFF  02,6B9
04D32:  MOVFF  01,6B8
04D36:  MOVFF  00,6B7
04D3A:  CALL   13EE
04D3E:  MOVFF  682,FEA
04D42:  MOVFF  681,FE9
04D46:  MOVFF  03,6B6
04D4A:  MOVFF  02,6B5
04D4E:  MOVFF  01,6B4
04D52:  MOVFF  00,6B3
04D56:  MOVLB  6
04D58:  MOVF   x6C,W
04D5A:  MULLW  18
04D5C:  MOVF   FF3,W
04D5E:  CLRF   x84
04D60:  MOVWF  x83
04D62:  MOVLW  82
04D64:  ADDWF  x83,W
04D66:  MOVWF  FE9
04D68:  MOVLW  00
04D6A:  ADDWFC x84,W
04D6C:  MOVWF  FEA
04D6E:  MOVFF  FEF,6B7
04D72:  MOVFF  FEC,01
04D76:  MOVFF  FEC,02
04D7A:  MOVFF  FEC,03
04D7E:  BCF    FD8.1
04D80:  MOVFF  03,6BA
04D84:  MOVFF  02,6B9
04D88:  MOVFF  01,6B8
04D8C:  MOVLB  0
04D8E:  CALL   13EE
04D92:  MOVFF  676,FEA
04D96:  MOVFF  675,FE9
04D9A:  MOVFF  00,FEF
04D9E:  MOVFF  01,FEC
04DA2:  MOVFF  02,FEC
04DA6:  MOVFF  03,FEC
....................    if (ch == chX) adcVals[ch].pReal *= -1;
04DAA:  MOVLB  6
04DAC:  MOVF   x6C,F
04DAE:  BNZ   4E0C
04DB0:  MOVF   x6C,W
04DB2:  MULLW  21
04DB4:  MOVF   FF3,W
04DB6:  CLRF   x76
04DB8:  MOVWF  x75
04DBA:  MOVLW  1D
04DBC:  ADDWF  x75,W
04DBE:  MOVWF  01
04DC0:  MOVLW  00
04DC2:  ADDWFC x76,W
04DC4:  MOVWF  03
04DC6:  MOVF   01,W
04DC8:  ADDLW  0F
04DCA:  MOVWF  FE9
04DCC:  MOVLW  01
04DCE:  ADDWFC 03,W
04DD0:  MOVWF  FEA
04DD2:  MOVFF  FEF,6B4
04DD6:  MOVFF  FEC,6B5
04DDA:  MOVFF  FEC,6B6
04DDE:  MOVFF  FEC,6B7
04DE2:  MOVF   FED,F
04DE4:  MOVF   FED,F
04DE6:  MOVF   FED,F
04DE8:  CLRF   xBB
04DEA:  CLRF   xBA
04DEC:  MOVLW  80
04DEE:  MOVWF  xB9
04DF0:  MOVLW  7F
04DF2:  MOVWF  xB8
04DF4:  MOVLB  0
04DF6:  CALL   12F8
04DFA:  MOVFF  00,FEF
04DFE:  MOVFF  01,FEC
04E02:  MOVFF  02,FEC
04E06:  MOVFF  03,FEC
04E0A:  MOVLB  6
....................    PID[ch].PVold = PID[ch].PV;
04E0C:  MOVF   x6C,W
04E0E:  MULLW  20
04E10:  MOVF   FF3,W
04E12:  CLRF   x76
04E14:  MOVWF  x75
04E16:  MOVLW  14
04E18:  ADDWF  x75,W
04E1A:  MOVWF  01
04E1C:  MOVLW  00
04E1E:  ADDWFC x76,W
04E20:  MOVWF  03
04E22:  MOVF   01,W
04E24:  ADDLW  20
04E26:  MOVWF  01
04E28:  MOVLW  00
04E2A:  ADDWFC 03,F
04E2C:  MOVFF  01,675
04E30:  MOVFF  03,676
04E34:  MOVF   x6C,W
04E36:  MULLW  20
04E38:  MOVF   FF3,W
04E3A:  CLRF   x78
04E3C:  MOVWF  x77
04E3E:  MOVLW  10
04E40:  ADDWF  x77,W
04E42:  MOVWF  01
04E44:  MOVLW  00
04E46:  ADDWFC x78,W
04E48:  MOVWF  03
04E4A:  MOVF   01,W
04E4C:  ADDLW  20
04E4E:  MOVWF  FE9
04E50:  MOVLW  00
04E52:  ADDWFC 03,W
04E54:  MOVWF  FEA
04E56:  MOVFF  FEF,00
04E5A:  MOVFF  FEC,01
04E5E:  MOVFF  FEC,02
04E62:  MOVFF  FEC,03
04E66:  MOVFF  676,FEA
04E6A:  MOVFF  675,FE9
04E6E:  MOVFF  00,FEF
04E72:  MOVFF  01,FEC
04E76:  MOVFF  02,FEC
04E7A:  MOVFF  03,FEC
....................    PID[ch].PV = adcVals[ch].pReal;
04E7E:  MOVF   x6C,W
04E80:  MULLW  20
04E82:  MOVF   FF3,W
04E84:  CLRF   x76
04E86:  MOVWF  x75
04E88:  MOVLW  10
04E8A:  ADDWF  x75,W
04E8C:  MOVWF  01
04E8E:  MOVLW  00
04E90:  ADDWFC x76,W
04E92:  MOVWF  03
04E94:  MOVF   01,W
04E96:  ADDLW  20
04E98:  MOVWF  01
04E9A:  MOVLW  00
04E9C:  ADDWFC 03,F
04E9E:  MOVFF  01,675
04EA2:  MOVFF  03,676
04EA6:  MOVF   x6C,W
04EA8:  MULLW  21
04EAA:  MOVF   FF3,W
04EAC:  CLRF   x78
04EAE:  MOVWF  x77
04EB0:  MOVLW  1D
04EB2:  ADDWF  x77,W
04EB4:  MOVWF  01
04EB6:  MOVLW  00
04EB8:  ADDWFC x78,W
04EBA:  MOVWF  03
04EBC:  MOVF   01,W
04EBE:  ADDLW  0F
04EC0:  MOVWF  FE9
04EC2:  MOVLW  01
04EC4:  ADDWFC 03,W
04EC6:  MOVWF  FEA
04EC8:  MOVFF  FEF,00
04ECC:  MOVFF  FEC,01
04ED0:  MOVFF  FEC,02
04ED4:  MOVFF  FEC,03
04ED8:  MOVFF  676,FEA
04EDC:  MOVFF  675,FE9
04EE0:  MOVFF  00,FEF
04EE4:  MOVFF  01,FEC
04EE8:  MOVFF  02,FEC
04EEC:  MOVFF  03,FEC
04EF0:  MOVLB  0
04EF2:  GOTO   4FD6 (RETURN)
.................... }  
.................... 
.................... /*****************************************************************************/
.................... /* SENSOR MONITOR INTERRUPT TASK                                             */
.................... /* starts conversion of the other two ADCs                                   */
.................... /*****************************************************************************/
.................... void sensor_monitor_interrupt_task()
.................... {
....................    static int8 ch = 0;
....................    
....................    if (!smData[ch].adcBusy)
*
001BE:  MOVLB  1
001C0:  MOVF   xD8,W
001C2:  MULLW  0D
001C4:  MOVF   FF3,W
001C6:  MOVLB  6
001C8:  CLRF   xD4
001CA:  MOVWF  xD3
001CC:  MOVLW  BD
001CE:  ADDWF  xD3,W
001D0:  MOVWF  FE9
001D2:  MOVLW  01
001D4:  ADDWFC xD4,W
001D6:  MOVWF  FEA
001D8:  BTFSC  FEF.1
001DA:  BRA    0254
....................    {
....................       smData[ch].adcBusy = true;
001DC:  MOVLB  1
001DE:  MOVF   xD8,W
001E0:  MULLW  0D
001E2:  MOVF   FF3,W
001E4:  MOVLB  6
001E6:  CLRF   xD4
001E8:  MOVWF  xD3
001EA:  MOVLW  BD
001EC:  ADDWF  xD3,W
001EE:  MOVWF  FE9
001F0:  MOVLW  01
001F2:  ADDWFC xD4,W
001F4:  MOVWF  FEA
001F6:  BSF    FEF.1
....................       
....................       ads_start_conv_block(ch);
001F8:  MOVFF  1D8,6D3
001FC:  MOVLB  0
001FE:  BRA    01A2
....................       ch = !ch;
00200:  MOVLB  1
00202:  MOVF   xD8,F
00204:  BZ    020A
00206:  MOVLW  00
00208:  BRA    020C
0020A:  MOVLW  01
0020C:  MOVWF  xD8
....................       
....................       smData[!ch].dataReady = true;
0020E:  MOVF   xD8,F
00210:  BZ    0216
00212:  MOVLW  00
00214:  BRA    0218
00216:  MOVLW  01
00218:  MULLW  0D
0021A:  MOVF   FF3,W
0021C:  MOVLB  6
0021E:  CLRF   xD4
00220:  MOVWF  xD3
00222:  MOVLW  BD
00224:  ADDWF  xD3,W
00226:  MOVWF  FE9
00228:  MOVLW  01
0022A:  ADDWFC xD4,W
0022C:  MOVWF  FEA
0022E:  BSF    FEF.0
....................       smData[!ch].adcBusy = false;
00230:  MOVLB  1
00232:  MOVF   xD8,F
00234:  BZ    023A
00236:  MOVLW  00
00238:  BRA    023C
0023A:  MOVLW  01
0023C:  MULLW  0D
0023E:  MOVF   FF3,W
00240:  MOVLB  6
00242:  CLRF   xD4
00244:  MOVWF  xD3
00246:  MOVLW  BD
00248:  ADDWF  xD3,W
0024A:  MOVWF  FE9
0024C:  MOVLW  01
0024E:  ADDWFC xD4,W
00250:  MOVWF  FEA
00252:  BCF    FEF.1
....................    }
00254:  MOVLB  0
00256:  GOTO   0318 (RETURN)
.................... }
.................... 
.................... signed int compar(void *a, void *b) {
....................    return COMPARE(a,b);
*
01BE4:  MOVLB  6
01BE6:  MOVF   x62,W
01BE8:  SUBWF  x60,W
01BEA:  BNC   1BF4
01BEC:  BNZ   1BF8
01BEE:  MOVF   x5F,W
01BF0:  SUBWF  x61,W
01BF2:  BNC   1BF8
01BF4:  MOVLW  00
01BF6:  BRA    1BFA
01BF8:  MOVLW  01
01BFA:  MOVWF  xC8
01BFC:  MOVF   x60,W
01BFE:  SUBWF  x62,W
01C00:  BNC   1C0A
01C02:  BNZ   1C0E
01C04:  MOVF   x61,W
01C06:  SUBWF  x5F,W
01C08:  BNC   1C0E
01C0A:  MOVLW  00
01C0C:  BRA    1C10
01C0E:  MOVLW  01
01C10:  SUBWF  xC8,W
01C12:  MOVWF  01
01C14:  MOVLB  0
01C16:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Interquartile Mean Ring Buffer                                            */
.................... /* Filters the ADC data to remove spurious readings                          */
.................... /*****************************************************************************/
.................... void iqm_ring_buffer(int8 ch, signed int32 sinCnts, signed int32 cosCnts)
*
01E2A:  MOVLB  6
01E2C:  CLRF   xA0
01E2E:  CLRF   x9F
01E30:  CLRF   x9E
01E32:  CLRF   x9D
01E34:  CLRF   xA4
01E36:  CLRF   xA3
01E38:  CLRF   xA2
01E3A:  CLRF   xA1
.................... {
....................    signed int32 iqmBufSin[BUFFER_SIZE];
....................    signed int32 iqmBufCos[BUFFER_SIZE];
....................    signed int32 sumSin=0;
....................    signed int32 sumCos=0;
....................    
....................    tobuff(smData[ch].sinQ, sinCnts); // push new data into queues
01E3C:  MOVF   x6C,W
01E3E:  MULLW  0D
01E40:  MOVF   FF3,W
01E42:  CLRF   xA8
01E44:  MOVWF  xA7
01E46:  MOVLW  01
01E48:  ADDWF  xA7,W
01E4A:  MOVWF  01
01E4C:  MOVLW  00
01E4E:  ADDWFC xA8,W
01E50:  MOVWF  03
01E52:  MOVF   01,W
01E54:  ADDLW  BD
01E56:  MOVWF  01
01E58:  MOVLW  01
01E5A:  ADDWFC 03,F
01E5C:  MOVFF  01,6A7
01E60:  MOVFF  03,6A8
01E64:  MOVFF  03,FEA
01E68:  MOVFF  01,FE9
01E6C:  MOVFF  FEC,6AA
01E70:  MOVF   FED,F
01E72:  MOVFF  FEF,6A9
01E76:  MOVF   x6C,W
01E78:  MULLW  0D
01E7A:  MOVF   FF3,W
01E7C:  CLRF   xAC
01E7E:  MOVWF  xAB
01E80:  MOVLW  01
01E82:  ADDWF  xAB,W
01E84:  MOVWF  01
01E86:  MOVLW  00
01E88:  ADDWFC xAC,W
01E8A:  MOVWF  03
01E8C:  MOVF   01,W
01E8E:  ADDLW  BD
01E90:  MOVWF  01
01E92:  MOVLW  01
01E94:  ADDWFC 03,F
01E96:  MOVFF  01,6AB
01E9A:  MOVFF  03,6AC
01E9E:  MOVFF  03,FEA
01EA2:  MOVFF  01,FE9
01EA6:  MOVFF  FEC,6AE
01EAA:  MOVF   FED,F
01EAC:  MOVFF  FEF,6AD
01EB0:  MOVFF  6AD,FE9
01EB4:  MOVFF  6AE,FEA
01EB8:  CLRF   xB1
01EBA:  MOVFF  FEF,6B0
01EBE:  CLRF   xB3
01EC0:  MOVLW  04
01EC2:  MOVWF  xB2
01EC4:  MOVLB  0
01EC6:  CALL   07F0
01ECA:  MOVFF  02,03
01ECE:  MOVF   01,W
01ED0:  ADDLW  02
01ED2:  MOVWF  01
01ED4:  MOVLW  00
01ED6:  ADDWFC 03,F
01ED8:  MOVF   01,W
01EDA:  MOVLB  6
01EDC:  ADDWF  xA9,W
01EDE:  MOVWF  FE9
01EE0:  MOVF   xAA,W
01EE2:  ADDWFC 03,W
01EE4:  MOVWF  FEA
01EE6:  MOVFF  66D,FEF
01EEA:  MOVFF  66E,FEC
01EEE:  MOVFF  66F,FEC
01EF2:  MOVFF  670,FEC
01EF6:  MOVF   x6C,W
01EF8:  MULLW  0D
01EFA:  MOVF   FF3,W
01EFC:  CLRF   xA8
01EFE:  MOVWF  xA7
01F00:  MOVLW  01
01F02:  ADDWF  xA7,W
01F04:  MOVWF  01
01F06:  MOVLW  00
01F08:  ADDWFC xA8,W
01F0A:  MOVWF  03
01F0C:  MOVF   01,W
01F0E:  ADDLW  BD
01F10:  MOVWF  01
01F12:  MOVLW  01
01F14:  ADDWFC 03,F
01F16:  MOVFF  01,6A7
01F1A:  MOVFF  03,6A8
01F1E:  MOVFF  03,FEA
01F22:  MOVFF  01,FE9
01F26:  MOVFF  FEC,03
01F2A:  MOVF   FED,F
01F2C:  MOVFF  FEF,01
01F30:  MOVFF  01,6AB
01F34:  MOVFF  03,6AC
01F38:  MOVF   x6C,W
01F3A:  MULLW  0D
01F3C:  MOVF   FF3,W
01F3E:  CLRF   xAE
01F40:  MOVWF  xAD
01F42:  MOVLW  01
01F44:  ADDWF  xAD,W
01F46:  MOVWF  01
01F48:  MOVLW  00
01F4A:  ADDWFC xAE,W
01F4C:  MOVWF  03
01F4E:  MOVF   01,W
01F50:  ADDLW  BD
01F52:  MOVWF  01
01F54:  MOVLW  01
01F56:  ADDWFC 03,F
01F58:  MOVFF  01,6AD
01F5C:  MOVFF  03,6AE
01F60:  MOVFF  03,FEA
01F64:  MOVFF  01,FE9
01F68:  MOVFF  FEC,6B0
01F6C:  MOVF   FED,F
01F6E:  MOVFF  FEF,6AF
01F72:  MOVFF  6AF,FE9
01F76:  MOVFF  6B0,FEA
01F7A:  MOVF   FEF,W
01F7C:  SUBLW  04
01F7E:  BNZ   1F84
01F80:  MOVLW  00
01F82:  BRA    1FCA
01F84:  MOVF   x6C,W
01F86:  MULLW  0D
01F88:  MOVF   FF3,W
01F8A:  CLRF   xB2
01F8C:  MOVWF  xB1
01F8E:  MOVLW  01
01F90:  ADDWF  xB1,W
01F92:  MOVWF  01
01F94:  MOVLW  00
01F96:  ADDWFC xB2,W
01F98:  MOVWF  03
01F9A:  MOVF   01,W
01F9C:  ADDLW  BD
01F9E:  MOVWF  01
01FA0:  MOVLW  01
01FA2:  ADDWFC 03,F
01FA4:  MOVFF  01,6B1
01FA8:  MOVFF  03,6B2
01FAC:  MOVFF  03,FEA
01FB0:  MOVFF  01,FE9
01FB4:  MOVFF  FEC,6B4
01FB8:  MOVF   FED,F
01FBA:  MOVFF  FEF,6B3
01FBE:  MOVFF  6B3,FE9
01FC2:  MOVFF  6B4,FEA
01FC6:  MOVLW  01
01FC8:  ADDWF  FEF,W
01FCA:  MOVWF  xB5
01FCC:  MOVFF  6AC,FEA
01FD0:  MOVFF  6AB,FE9
01FD4:  MOVWF  FEF
01FD6:  MOVF   x6C,W
01FD8:  MULLW  0D
01FDA:  MOVF   FF3,W
01FDC:  CLRF   xA8
01FDE:  MOVWF  xA7
01FE0:  MOVLW  01
01FE2:  ADDWF  xA7,W
01FE4:  MOVWF  01
01FE6:  MOVLW  00
01FE8:  ADDWFC xA8,W
01FEA:  MOVWF  03
01FEC:  MOVF   01,W
01FEE:  ADDLW  BD
01FF0:  MOVWF  01
01FF2:  MOVLW  01
01FF4:  ADDWFC 03,F
01FF6:  MOVFF  01,6A7
01FFA:  MOVFF  03,6A8
01FFE:  MOVFF  03,FEA
02002:  MOVFF  01,FE9
02006:  MOVFF  FEC,6AA
0200A:  MOVF   FED,F
0200C:  MOVFF  FEF,6A9
02010:  MOVFF  6A9,FE9
02014:  MOVFF  6AA,FEA
02018:  MOVFF  FEF,6AB
0201C:  MOVF   x6C,W
0201E:  MULLW  0D
02020:  MOVF   FF3,W
02022:  CLRF   xAD
02024:  MOVWF  xAC
02026:  MOVLW  01
02028:  ADDWF  xAC,W
0202A:  MOVWF  01
0202C:  MOVLW  00
0202E:  ADDWFC xAD,W
02030:  MOVWF  03
02032:  MOVF   01,W
02034:  ADDLW  BD
02036:  MOVWF  01
02038:  MOVLW  01
0203A:  ADDWFC 03,F
0203C:  MOVFF  01,6AC
02040:  MOVFF  03,6AD
02044:  MOVFF  03,FEA
02048:  MOVFF  01,FE9
0204C:  MOVFF  FEC,6AF
02050:  MOVF   FED,F
02052:  MOVFF  FEF,6AE
02056:  MOVLW  01
02058:  ADDWF  xAE,W
0205A:  MOVWF  FE9
0205C:  MOVLW  00
0205E:  ADDWFC xAF,W
02060:  MOVWF  FEA
02062:  MOVF   FEF,W
02064:  SUBWF  xAB,W
02066:  BNZ   2158
02068:  MOVF   x6C,W
0206A:  MULLW  0D
0206C:  MOVF   FF3,W
0206E:  CLRF   xA8
02070:  MOVWF  xA7
02072:  MOVLW  01
02074:  ADDWF  xA7,W
02076:  MOVWF  01
02078:  MOVLW  00
0207A:  ADDWFC xA8,W
0207C:  MOVWF  03
0207E:  MOVF   01,W
02080:  ADDLW  BD
02082:  MOVWF  01
02084:  MOVLW  01
02086:  ADDWFC 03,F
02088:  MOVFF  01,6A7
0208C:  MOVFF  03,6A8
02090:  MOVFF  03,FEA
02094:  MOVFF  01,FE9
02098:  MOVFF  FEC,6AA
0209C:  MOVF   FED,F
0209E:  MOVFF  FEF,6A9
020A2:  MOVLW  01
020A4:  ADDWF  xA9,W
020A6:  MOVWF  01
020A8:  MOVLW  00
020AA:  ADDWFC xAA,W
020AC:  MOVWF  03
020AE:  MOVFF  01,6AB
020B2:  MOVWF  xAC
020B4:  MOVF   x6C,W
020B6:  MULLW  0D
020B8:  MOVF   FF3,W
020BA:  CLRF   xAE
020BC:  MOVWF  xAD
020BE:  MOVLW  01
020C0:  ADDWF  xAD,W
020C2:  MOVWF  01
020C4:  MOVLW  00
020C6:  ADDWFC xAE,W
020C8:  MOVWF  03
020CA:  MOVF   01,W
020CC:  ADDLW  BD
020CE:  MOVWF  01
020D0:  MOVLW  01
020D2:  ADDWFC 03,F
020D4:  MOVFF  01,6AD
020D8:  MOVFF  03,6AE
020DC:  MOVFF  03,FEA
020E0:  MOVFF  01,FE9
020E4:  MOVFF  FEC,6B0
020E8:  MOVF   FED,F
020EA:  MOVFF  FEF,6AF
020EE:  MOVLW  01
020F0:  ADDWF  xAF,W
020F2:  MOVWF  FE9
020F4:  MOVLW  00
020F6:  ADDWFC xB0,W
020F8:  MOVWF  FEA
020FA:  MOVF   FEF,W
020FC:  SUBLW  04
020FE:  BNZ   2104
02100:  MOVLW  00
02102:  BRA    214E
02104:  MOVF   x6C,W
02106:  MULLW  0D
02108:  MOVF   FF3,W
0210A:  CLRF   xB2
0210C:  MOVWF  xB1
0210E:  MOVLW  01
02110:  ADDWF  xB1,W
02112:  MOVWF  01
02114:  MOVLW  00
02116:  ADDWFC xB2,W
02118:  MOVWF  03
0211A:  MOVF   01,W
0211C:  ADDLW  BD
0211E:  MOVWF  01
02120:  MOVLW  01
02122:  ADDWFC 03,F
02124:  MOVFF  01,6B1
02128:  MOVFF  03,6B2
0212C:  MOVFF  03,FEA
02130:  MOVFF  01,FE9
02134:  MOVFF  FEC,6B4
02138:  MOVF   FED,F
0213A:  MOVFF  FEF,6B3
0213E:  MOVLW  01
02140:  ADDWF  xB3,W
02142:  MOVWF  FE9
02144:  MOVLW  00
02146:  ADDWFC xB4,W
02148:  MOVWF  FEA
0214A:  MOVLW  01
0214C:  ADDWF  FEF,W
0214E:  MOVFF  6AC,FEA
02152:  MOVFF  6AB,FE9
02156:  MOVWF  FEF
....................    tobuff(smData[ch].cosQ, cosCnts);
02158:  MOVF   x6C,W
0215A:  MULLW  0D
0215C:  MOVF   FF3,W
0215E:  CLRF   xA8
02160:  MOVWF  xA7
02162:  MOVLW  03
02164:  ADDWF  xA7,W
02166:  MOVWF  01
02168:  MOVLW  00
0216A:  ADDWFC xA8,W
0216C:  MOVWF  03
0216E:  MOVF   01,W
02170:  ADDLW  BD
02172:  MOVWF  01
02174:  MOVLW  01
02176:  ADDWFC 03,F
02178:  MOVFF  01,6A7
0217C:  MOVFF  03,6A8
02180:  MOVFF  03,FEA
02184:  MOVFF  01,FE9
02188:  MOVFF  FEC,6AA
0218C:  MOVF   FED,F
0218E:  MOVFF  FEF,6A9
02192:  MOVF   x6C,W
02194:  MULLW  0D
02196:  MOVF   FF3,W
02198:  CLRF   xAC
0219A:  MOVWF  xAB
0219C:  MOVLW  03
0219E:  ADDWF  xAB,W
021A0:  MOVWF  01
021A2:  MOVLW  00
021A4:  ADDWFC xAC,W
021A6:  MOVWF  03
021A8:  MOVF   01,W
021AA:  ADDLW  BD
021AC:  MOVWF  01
021AE:  MOVLW  01
021B0:  ADDWFC 03,F
021B2:  MOVFF  01,6AB
021B6:  MOVFF  03,6AC
021BA:  MOVFF  03,FEA
021BE:  MOVFF  01,FE9
021C2:  MOVFF  FEC,6AE
021C6:  MOVF   FED,F
021C8:  MOVFF  FEF,6AD
021CC:  MOVFF  6AD,FE9
021D0:  MOVFF  6AE,FEA
021D4:  CLRF   xB1
021D6:  MOVFF  FEF,6B0
021DA:  CLRF   xB3
021DC:  MOVLW  04
021DE:  MOVWF  xB2
021E0:  MOVLB  0
021E2:  CALL   07F0
021E6:  MOVFF  02,03
021EA:  MOVF   01,W
021EC:  ADDLW  02
021EE:  MOVWF  01
021F0:  MOVLW  00
021F2:  ADDWFC 03,F
021F4:  MOVF   01,W
021F6:  MOVLB  6
021F8:  ADDWF  xA9,W
021FA:  MOVWF  FE9
021FC:  MOVF   xAA,W
021FE:  ADDWFC 03,W
02200:  MOVWF  FEA
02202:  MOVFF  671,FEF
02206:  MOVFF  672,FEC
0220A:  MOVFF  673,FEC
0220E:  MOVFF  674,FEC
02212:  MOVF   x6C,W
02214:  MULLW  0D
02216:  MOVF   FF3,W
02218:  CLRF   xA8
0221A:  MOVWF  xA7
0221C:  MOVLW  03
0221E:  ADDWF  xA7,W
02220:  MOVWF  01
02222:  MOVLW  00
02224:  ADDWFC xA8,W
02226:  MOVWF  03
02228:  MOVF   01,W
0222A:  ADDLW  BD
0222C:  MOVWF  01
0222E:  MOVLW  01
02230:  ADDWFC 03,F
02232:  MOVFF  01,6A7
02236:  MOVFF  03,6A8
0223A:  MOVFF  03,FEA
0223E:  MOVFF  01,FE9
02242:  MOVFF  FEC,03
02246:  MOVF   FED,F
02248:  MOVFF  FEF,01
0224C:  MOVFF  01,6AB
02250:  MOVFF  03,6AC
02254:  MOVF   x6C,W
02256:  MULLW  0D
02258:  MOVF   FF3,W
0225A:  CLRF   xAE
0225C:  MOVWF  xAD
0225E:  MOVLW  03
02260:  ADDWF  xAD,W
02262:  MOVWF  01
02264:  MOVLW  00
02266:  ADDWFC xAE,W
02268:  MOVWF  03
0226A:  MOVF   01,W
0226C:  ADDLW  BD
0226E:  MOVWF  01
02270:  MOVLW  01
02272:  ADDWFC 03,F
02274:  MOVFF  01,6AD
02278:  MOVFF  03,6AE
0227C:  MOVFF  03,FEA
02280:  MOVFF  01,FE9
02284:  MOVFF  FEC,6B0
02288:  MOVF   FED,F
0228A:  MOVFF  FEF,6AF
0228E:  MOVFF  6AF,FE9
02292:  MOVFF  6B0,FEA
02296:  MOVF   FEF,W
02298:  SUBLW  04
0229A:  BNZ   22A0
0229C:  MOVLW  00
0229E:  BRA    22E6
022A0:  MOVF   x6C,W
022A2:  MULLW  0D
022A4:  MOVF   FF3,W
022A6:  CLRF   xB2
022A8:  MOVWF  xB1
022AA:  MOVLW  03
022AC:  ADDWF  xB1,W
022AE:  MOVWF  01
022B0:  MOVLW  00
022B2:  ADDWFC xB2,W
022B4:  MOVWF  03
022B6:  MOVF   01,W
022B8:  ADDLW  BD
022BA:  MOVWF  01
022BC:  MOVLW  01
022BE:  ADDWFC 03,F
022C0:  MOVFF  01,6B1
022C4:  MOVFF  03,6B2
022C8:  MOVFF  03,FEA
022CC:  MOVFF  01,FE9
022D0:  MOVFF  FEC,6B4
022D4:  MOVF   FED,F
022D6:  MOVFF  FEF,6B3
022DA:  MOVFF  6B3,FE9
022DE:  MOVFF  6B4,FEA
022E2:  MOVLW  01
022E4:  ADDWF  FEF,W
022E6:  MOVWF  xB5
022E8:  MOVFF  6AC,FEA
022EC:  MOVFF  6AB,FE9
022F0:  MOVWF  FEF
022F2:  MOVF   x6C,W
022F4:  MULLW  0D
022F6:  MOVF   FF3,W
022F8:  CLRF   xA8
022FA:  MOVWF  xA7
022FC:  MOVLW  03
022FE:  ADDWF  xA7,W
02300:  MOVWF  01
02302:  MOVLW  00
02304:  ADDWFC xA8,W
02306:  MOVWF  03
02308:  MOVF   01,W
0230A:  ADDLW  BD
0230C:  MOVWF  01
0230E:  MOVLW  01
02310:  ADDWFC 03,F
02312:  MOVFF  01,6A7
02316:  MOVFF  03,6A8
0231A:  MOVFF  03,FEA
0231E:  MOVFF  01,FE9
02322:  MOVFF  FEC,6AA
02326:  MOVF   FED,F
02328:  MOVFF  FEF,6A9
0232C:  MOVFF  6A9,FE9
02330:  MOVFF  6AA,FEA
02334:  MOVFF  FEF,6AB
02338:  MOVF   x6C,W
0233A:  MULLW  0D
0233C:  MOVF   FF3,W
0233E:  CLRF   xAD
02340:  MOVWF  xAC
02342:  MOVLW  03
02344:  ADDWF  xAC,W
02346:  MOVWF  01
02348:  MOVLW  00
0234A:  ADDWFC xAD,W
0234C:  MOVWF  03
0234E:  MOVF   01,W
02350:  ADDLW  BD
02352:  MOVWF  01
02354:  MOVLW  01
02356:  ADDWFC 03,F
02358:  MOVFF  01,6AC
0235C:  MOVFF  03,6AD
02360:  MOVFF  03,FEA
02364:  MOVFF  01,FE9
02368:  MOVFF  FEC,6AF
0236C:  MOVF   FED,F
0236E:  MOVFF  FEF,6AE
02372:  MOVLW  01
02374:  ADDWF  xAE,W
02376:  MOVWF  FE9
02378:  MOVLW  00
0237A:  ADDWFC xAF,W
0237C:  MOVWF  FEA
0237E:  MOVF   FEF,W
02380:  SUBWF  xAB,W
02382:  BNZ   2474
02384:  MOVF   x6C,W
02386:  MULLW  0D
02388:  MOVF   FF3,W
0238A:  CLRF   xA8
0238C:  MOVWF  xA7
0238E:  MOVLW  03
02390:  ADDWF  xA7,W
02392:  MOVWF  01
02394:  MOVLW  00
02396:  ADDWFC xA8,W
02398:  MOVWF  03
0239A:  MOVF   01,W
0239C:  ADDLW  BD
0239E:  MOVWF  01
023A0:  MOVLW  01
023A2:  ADDWFC 03,F
023A4:  MOVFF  01,6A7
023A8:  MOVFF  03,6A8
023AC:  MOVFF  03,FEA
023B0:  MOVFF  01,FE9
023B4:  MOVFF  FEC,6AA
023B8:  MOVF   FED,F
023BA:  MOVFF  FEF,6A9
023BE:  MOVLW  01
023C0:  ADDWF  xA9,W
023C2:  MOVWF  01
023C4:  MOVLW  00
023C6:  ADDWFC xAA,W
023C8:  MOVWF  03
023CA:  MOVFF  01,6AB
023CE:  MOVWF  xAC
023D0:  MOVF   x6C,W
023D2:  MULLW  0D
023D4:  MOVF   FF3,W
023D6:  CLRF   xAE
023D8:  MOVWF  xAD
023DA:  MOVLW  03
023DC:  ADDWF  xAD,W
023DE:  MOVWF  01
023E0:  MOVLW  00
023E2:  ADDWFC xAE,W
023E4:  MOVWF  03
023E6:  MOVF   01,W
023E8:  ADDLW  BD
023EA:  MOVWF  01
023EC:  MOVLW  01
023EE:  ADDWFC 03,F
023F0:  MOVFF  01,6AD
023F4:  MOVFF  03,6AE
023F8:  MOVFF  03,FEA
023FC:  MOVFF  01,FE9
02400:  MOVFF  FEC,6B0
02404:  MOVF   FED,F
02406:  MOVFF  FEF,6AF
0240A:  MOVLW  01
0240C:  ADDWF  xAF,W
0240E:  MOVWF  FE9
02410:  MOVLW  00
02412:  ADDWFC xB0,W
02414:  MOVWF  FEA
02416:  MOVF   FEF,W
02418:  SUBLW  04
0241A:  BNZ   2420
0241C:  MOVLW  00
0241E:  BRA    246A
02420:  MOVF   x6C,W
02422:  MULLW  0D
02424:  MOVF   FF3,W
02426:  CLRF   xB2
02428:  MOVWF  xB1
0242A:  MOVLW  03
0242C:  ADDWF  xB1,W
0242E:  MOVWF  01
02430:  MOVLW  00
02432:  ADDWFC xB2,W
02434:  MOVWF  03
02436:  MOVF   01,W
02438:  ADDLW  BD
0243A:  MOVWF  01
0243C:  MOVLW  01
0243E:  ADDWFC 03,F
02440:  MOVFF  01,6B1
02444:  MOVFF  03,6B2
02448:  MOVFF  03,FEA
0244C:  MOVFF  01,FE9
02450:  MOVFF  FEC,6B4
02454:  MOVF   FED,F
02456:  MOVFF  FEF,6B3
0245A:  MOVLW  01
0245C:  ADDWF  xB3,W
0245E:  MOVWF  FE9
02460:  MOVLW  00
02462:  ADDWFC xB4,W
02464:  MOVWF  FEA
02466:  MOVLW  01
02468:  ADDWF  FEF,W
0246A:  MOVFF  6AC,FEA
0246E:  MOVFF  6AB,FE9
02472:  MOVWF  FEF
....................    
....................    // copy queue contents out to buffer for qsorting
....................    for (int j=0; j<BUFFER_SIZE; j++){
02474:  CLRF   xA5
02476:  MOVF   xA5,W
02478:  SUBLW  04
0247A:  BTFSS  FD8.0
0247C:  BRA    25D2
....................       iqmBufSin[j] = smData[ch].sinQ->buff[j];
0247E:  MOVF   xA5,W
02480:  MULLW  04
02482:  MOVF   FF3,W
02484:  CLRF   03
02486:  ADDLW  75
02488:  MOVWF  01
0248A:  MOVLW  06
0248C:  ADDWFC 03,F
0248E:  MOVFF  01,6A7
02492:  MOVFF  03,6A8
02496:  MOVF   x6C,W
02498:  MULLW  0D
0249A:  MOVF   FF3,W
0249C:  CLRF   xAA
0249E:  MOVWF  xA9
024A0:  MOVLW  01
024A2:  ADDWF  xA9,W
024A4:  MOVWF  01
024A6:  MOVLW  00
024A8:  ADDWFC xAA,W
024AA:  MOVWF  03
024AC:  MOVF   01,W
024AE:  ADDLW  BD
024B0:  MOVWF  01
024B2:  MOVLW  01
024B4:  ADDWFC 03,F
024B6:  MOVFF  01,6A9
024BA:  MOVFF  03,6AA
024BE:  MOVFF  03,FEA
024C2:  MOVFF  01,FE9
024C6:  MOVFF  FEC,6AC
024CA:  MOVF   FED,F
024CC:  MOVFF  FEF,6AB
024D0:  CLRF   xB1
024D2:  MOVFF  6A5,6B0
024D6:  CLRF   xB3
024D8:  MOVLW  04
024DA:  MOVWF  xB2
024DC:  MOVLB  0
024DE:  CALL   07F0
024E2:  MOVFF  02,03
024E6:  MOVF   01,W
024E8:  ADDLW  02
024EA:  MOVWF  01
024EC:  MOVLW  00
024EE:  ADDWFC 03,F
024F0:  MOVF   01,W
024F2:  MOVLB  6
024F4:  ADDWF  xAB,W
024F6:  MOVWF  FE9
024F8:  MOVF   xAC,W
024FA:  ADDWFC 03,W
024FC:  MOVWF  FEA
024FE:  MOVFF  FEF,00
02502:  MOVFF  FEC,01
02506:  MOVFF  FEC,02
0250A:  MOVFF  FEC,03
0250E:  MOVFF  6A8,FEA
02512:  MOVFF  6A7,FE9
02516:  MOVFF  00,FEF
0251A:  MOVFF  01,FEC
0251E:  MOVFF  02,FEC
02522:  MOVFF  03,FEC
....................       iqmBufCos[j] = smData[ch].cosQ->buff[j];
02526:  MOVF   xA5,W
02528:  MULLW  04
0252A:  MOVF   FF3,W
0252C:  CLRF   03
0252E:  ADDLW  89
02530:  MOVWF  01
02532:  MOVLW  06
02534:  ADDWFC 03,F
02536:  MOVFF  01,6A7
0253A:  MOVFF  03,6A8
0253E:  MOVF   x6C,W
02540:  MULLW  0D
02542:  MOVF   FF3,W
02544:  CLRF   xAA
02546:  MOVWF  xA9
02548:  MOVLW  03
0254A:  ADDWF  xA9,W
0254C:  MOVWF  01
0254E:  MOVLW  00
02550:  ADDWFC xAA,W
02552:  MOVWF  03
02554:  MOVF   01,W
02556:  ADDLW  BD
02558:  MOVWF  01
0255A:  MOVLW  01
0255C:  ADDWFC 03,F
0255E:  MOVFF  01,6A9
02562:  MOVFF  03,6AA
02566:  MOVFF  03,FEA
0256A:  MOVFF  01,FE9
0256E:  MOVFF  FEC,6AC
02572:  MOVF   FED,F
02574:  MOVFF  FEF,6AB
02578:  CLRF   xB1
0257A:  MOVFF  6A5,6B0
0257E:  CLRF   xB3
02580:  MOVLW  04
02582:  MOVWF  xB2
02584:  MOVLB  0
02586:  CALL   07F0
0258A:  MOVFF  02,03
0258E:  MOVF   01,W
02590:  ADDLW  02
02592:  MOVWF  01
02594:  MOVLW  00
02596:  ADDWFC 03,F
02598:  MOVF   01,W
0259A:  MOVLB  6
0259C:  ADDWF  xAB,W
0259E:  MOVWF  FE9
025A0:  MOVF   xAC,W
025A2:  ADDWFC 03,W
025A4:  MOVWF  FEA
025A6:  MOVFF  FEF,00
025AA:  MOVFF  FEC,01
025AE:  MOVFF  FEC,02
025B2:  MOVFF  FEC,03
025B6:  MOVFF  6A8,FEA
025BA:  MOVFF  6A7,FE9
025BE:  MOVFF  00,FEF
025C2:  MOVFF  01,FEC
025C6:  MOVFF  02,FEC
025CA:  MOVFF  03,FEC
025CE:  INCF   xA5,F
025D0:  BRA    2476
....................    }
....................    
....................    qsort(iqmBufSin, BUFFER_SIZE, sizeof(*iqmBufSin), compar);
025D2:  MOVLW  1B
025D4:  MOVWF  03
025D6:  MOVLW  E4
025D8:  MOVWF  xA7
025DA:  MOVFF  03,6A8
025DE:  MOVLW  06
025E0:  MOVWF  xAA
025E2:  MOVLW  75
025E4:  MOVWF  xA9
025E6:  MOVLW  05
025E8:  MOVWF  xAB
025EA:  MOVLW  01
025EC:  MOVWF  xAC
025EE:  MOVFF  03,6AE
025F2:  MOVFF  6A7,6AD
025F6:  MOVLB  0
025F8:  CALL   1C18
....................    qsort(iqmBufCos, BUFFER_SIZE, sizeof(*iqmBufCos), compar);
025FC:  MOVLW  1B
025FE:  MOVWF  03
02600:  MOVLW  E4
02602:  MOVLB  6
02604:  MOVWF  xA7
02606:  MOVFF  03,6A8
0260A:  MOVLW  06
0260C:  MOVWF  xAA
0260E:  MOVLW  89
02610:  MOVWF  xA9
02612:  MOVLW  05
02614:  MOVWF  xAB
02616:  MOVLW  01
02618:  MOVWF  xAC
0261A:  MOVFF  03,6AE
0261E:  MOVFF  6A7,6AD
02622:  MOVLB  0
02624:  CALL   1C18
....................    
....................    for (int k=1; k<(BUFFER_SIZE-1); k++){
02628:  MOVLW  01
0262A:  MOVLB  6
0262C:  MOVWF  xA6
0262E:  MOVF   xA6,W
02630:  SUBLW  03
02632:  BNC   269C
....................       sumSin+=iqmBufSin[k];
02634:  MOVF   xA6,W
02636:  MULLW  04
02638:  MOVF   FF3,W
0263A:  CLRF   03
0263C:  ADDLW  75
0263E:  MOVWF  FE9
02640:  MOVLW  06
02642:  ADDWFC 03,W
02644:  MOVWF  FEA
02646:  MOVFF  FEF,00
0264A:  MOVFF  FEC,01
0264E:  MOVFF  FEC,02
02652:  MOVFF  FEC,03
02656:  MOVF   00,W
02658:  ADDWF  x9D,F
0265A:  MOVF   01,W
0265C:  ADDWFC x9E,F
0265E:  MOVF   02,W
02660:  ADDWFC x9F,F
02662:  MOVF   03,W
02664:  ADDWFC xA0,F
....................       sumCos+=iqmBufCos[k];
02666:  MOVF   xA6,W
02668:  MULLW  04
0266A:  MOVF   FF3,W
0266C:  CLRF   03
0266E:  ADDLW  89
02670:  MOVWF  FE9
02672:  MOVLW  06
02674:  ADDWFC 03,W
02676:  MOVWF  FEA
02678:  MOVFF  FEF,00
0267C:  MOVFF  FEC,01
02680:  MOVFF  FEC,02
02684:  MOVFF  FEC,03
02688:  MOVF   00,W
0268A:  ADDWF  xA1,F
0268C:  MOVF   01,W
0268E:  ADDWFC xA2,F
02690:  MOVF   02,W
02692:  ADDWFC xA3,F
02694:  MOVF   03,W
02696:  ADDWFC xA4,F
02698:  INCF   xA6,F
0269A:  BRA    262E
....................    }
....................    smData[ch].avgSin = sumSin / (BUFFER_SIZE-2);
0269C:  MOVF   x6C,W
0269E:  MULLW  0D
026A0:  MOVF   FF3,W
026A2:  CLRF   xA8
026A4:  MOVWF  xA7
026A6:  MOVLW  05
026A8:  ADDWF  xA7,W
026AA:  MOVWF  01
026AC:  MOVLW  00
026AE:  ADDWFC xA8,W
026B0:  MOVWF  03
026B2:  MOVF   01,W
026B4:  ADDLW  BD
026B6:  MOVWF  FE9
026B8:  MOVLW  01
026BA:  ADDWFC 03,W
026BC:  MOVWF  FEA
026BE:  MOVFF  FEA,6AA
026C2:  MOVFF  FE9,6A9
026C6:  BCF    FD8.1
026C8:  MOVFF  6A0,6AE
026CC:  MOVFF  69F,6AD
026D0:  MOVFF  69E,6AC
026D4:  MOVFF  69D,6AB
026D8:  CLRF   xB2
026DA:  CLRF   xB1
026DC:  CLRF   xB0
026DE:  MOVLW  03
026E0:  MOVWF  xAF
026E2:  MOVLB  0
026E4:  CALL   1D40
026E8:  MOVFF  6AA,FEA
026EC:  MOVFF  6A9,FE9
026F0:  MOVFF  00,FEF
026F4:  MOVFF  01,FEC
026F8:  MOVFF  02,FEC
026FC:  MOVFF  03,FEC
....................    smData[ch].avgCos = sumCos / (BUFFER_SIZE-2);
02700:  MOVLB  6
02702:  MOVF   x6C,W
02704:  MULLW  0D
02706:  MOVF   FF3,W
02708:  CLRF   xA8
0270A:  MOVWF  xA7
0270C:  MOVLW  09
0270E:  ADDWF  xA7,W
02710:  MOVWF  01
02712:  MOVLW  00
02714:  ADDWFC xA8,W
02716:  MOVWF  03
02718:  MOVF   01,W
0271A:  ADDLW  BD
0271C:  MOVWF  FE9
0271E:  MOVLW  01
02720:  ADDWFC 03,W
02722:  MOVWF  FEA
02724:  MOVFF  FEA,6AA
02728:  MOVFF  FE9,6A9
0272C:  BCF    FD8.1
0272E:  MOVFF  6A4,6AE
02732:  MOVFF  6A3,6AD
02736:  MOVFF  6A2,6AC
0273A:  MOVFF  6A1,6AB
0273E:  CLRF   xB2
02740:  CLRF   xB1
02742:  CLRF   xB0
02744:  MOVLW  03
02746:  MOVWF  xAF
02748:  MOVLB  0
0274A:  CALL   1D40
0274E:  MOVFF  6AA,FEA
02752:  MOVFF  6A9,FE9
02756:  MOVFF  00,FEF
0275A:  MOVFF  01,FEC
0275E:  MOVFF  02,FEC
02762:  MOVFF  03,FEC
02766:  GOTO   4FCE (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SENSOR MONITOR task - gets magnetoresistive sensor counts                 */
.................... /* gets two values each time the task is run                                 */
.................... /*****************************************************************************/
.................... void sensor_monitor_task()
*
04EF6:  MOVLB  6
04EF8:  CLRF   x67
04EFA:  CLRF   x66
04EFC:  CLRF   x65
04EFE:  CLRF   x64
04F00:  CLRF   x6B
04F02:  CLRF   x6A
04F04:  CLRF   x69
04F06:  CLRF   x68
.................... {
....................    static int8 ch = 0;
....................    signed int32 sinNew = 0;
....................    signed int32 cosNew = 0;
....................    
....................    if ( (!smData[ch].adcBusy) && smData[ch].dataReady ){
04F08:  MOVLB  1
04F0A:  MOVF   xD9,W
04F0C:  MULLW  0D
04F0E:  MOVF   FF3,W
04F10:  MOVLB  6
04F12:  CLRF   x6D
04F14:  MOVWF  x6C
04F16:  MOVLW  BD
04F18:  ADDWF  x6C,W
04F1A:  MOVWF  FE9
04F1C:  MOVLW  01
04F1E:  ADDWFC x6D,W
04F20:  MOVWF  FEA
04F22:  BTFSC  FEF.1
04F24:  BRA    502A
04F26:  MOVLB  1
04F28:  MOVF   xD9,W
04F2A:  MULLW  0D
04F2C:  MOVF   FF3,W
04F2E:  MOVLB  6
04F30:  CLRF   x6F
04F32:  MOVWF  x6E
04F34:  MOVLW  BD
04F36:  ADDWF  x6E,W
04F38:  MOVWF  FE9
04F3A:  MOVLW  01
04F3C:  ADDWFC x6F,W
04F3E:  MOVWF  FEA
04F40:  BTFSS  FEF.0
04F42:  BRA    502A
....................       smData[ch].adcBusy = true;
04F44:  MOVLB  1
04F46:  MOVF   xD9,W
04F48:  MULLW  0D
04F4A:  MOVF   FF3,W
04F4C:  MOVLB  6
04F4E:  CLRF   x6D
04F50:  MOVWF  x6C
04F52:  MOVLW  BD
04F54:  ADDWF  x6C,W
04F56:  MOVWF  FE9
04F58:  MOVLW  01
04F5A:  ADDWFC x6D,W
04F5C:  MOVWF  FEA
04F5E:  BSF    FEF.1
....................       
....................       sinNew = ads_read_data(ch*2);
04F60:  BCF    FD8.0
04F62:  MOVLB  1
04F64:  RLCF   xD9,W
04F66:  MOVLB  6
04F68:  MOVWF  x6C
04F6A:  MOVWF  x76
04F6C:  MOVLB  0
04F6E:  CALL   082A
04F72:  MOVFF  03,667
04F76:  MOVFF  02,666
04F7A:  MOVFF  01,665
04F7E:  MOVFF  00,664
....................       cosNew = ads_read_data(ch*2+1);      
04F82:  BCF    FD8.0
04F84:  MOVLB  1
04F86:  RLCF   xD9,W
04F88:  ADDLW  01
04F8A:  MOVLB  6
04F8C:  MOVWF  x6C
04F8E:  MOVWF  x76
04F90:  MOVLB  0
04F92:  CALL   082A
04F96:  MOVFF  03,66B
04F9A:  MOVFF  02,66A
04F9E:  MOVFF  01,669
04FA2:  MOVFF  00,668
....................       
....................       iqm_ring_buffer(ch, sinNew, cosNew);
04FA6:  MOVFF  1D9,66C
04FAA:  MOVFF  667,670
04FAE:  MOVFF  666,66F
04FB2:  MOVFF  665,66E
04FB6:  MOVFF  664,66D
04FBA:  MOVFF  66B,674
04FBE:  MOVFF  66A,673
04FC2:  MOVFF  669,672
04FC6:  MOVFF  668,671
04FCA:  GOTO   1E2A
....................       
....................       sensor_process_data(ch);
04FCE:  MOVFF  1D9,66C
04FD2:  GOTO   41A4
....................       ch = !ch;
04FD6:  MOVLB  1
04FD8:  MOVF   xD9,F
04FDA:  BZ    4FE0
04FDC:  MOVLW  00
04FDE:  BRA    4FE2
04FE0:  MOVLW  01
04FE2:  MOVWF  xD9
....................       
....................       smData[!ch].dataReady = false;
04FE4:  MOVF   xD9,F
04FE6:  BZ    4FEC
04FE8:  MOVLW  00
04FEA:  BRA    4FEE
04FEC:  MOVLW  01
04FEE:  MULLW  0D
04FF0:  MOVF   FF3,W
04FF2:  MOVLB  6
04FF4:  CLRF   x6D
04FF6:  MOVWF  x6C
04FF8:  MOVLW  BD
04FFA:  ADDWF  x6C,W
04FFC:  MOVWF  FE9
04FFE:  MOVLW  01
05000:  ADDWFC x6D,W
05002:  MOVWF  FEA
05004:  BCF    FEF.0
....................       smData[!ch].adcBusy = false;
05006:  MOVLB  1
05008:  MOVF   xD9,F
0500A:  BZ    5010
0500C:  MOVLW  00
0500E:  BRA    5012
05010:  MOVLW  01
05012:  MULLW  0D
05014:  MOVF   FF3,W
05016:  MOVLB  6
05018:  CLRF   x6D
0501A:  MOVWF  x6C
0501C:  MOVLW  BD
0501E:  ADDWF  x6C,W
05020:  MOVWF  FE9
05022:  MOVLW  01
05024:  ADDWFC x6D,W
05026:  MOVWF  FEA
05028:  BCF    FEF.1
....................    }
0502A:  MOVLB  0
0502C:  GOTO   AFCC (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* INITIALIZE ADC's                                                          */
.................... /*****************************************************************************/
.................... void setup_external_ADCs()
*
00878:  MOVLB  6
0087A:  CLRF   x64
0087C:  CLRF   x65
0087E:  CLRF   x66
00880:  CLRF   x67
.................... {
....................    unsigned int8 rc0=0;
....................    unsigned int8 rc1=0;
....................    unsigned int8 rc2=0;
....................    unsigned int8 rc3=0;
....................    
....................    for (int ch = 0; ch < 4; ch++)
00882:  CLRF   x68
00884:  MOVF   x68,W
00886:  SUBLW  03
00888:  BNC   08C0
....................    {
....................       rc0=reg0config;
0088A:  MOVLW  30
0088C:  MOVWF  x64
....................       rc1=reg1config;
0088E:  MOVLW  10
00890:  MOVWF  x65
....................       rc2=reg2config;
00892:  MOVLW  30
00894:  MOVWF  x66
....................       rc3=reg3config;
00896:  CLRF   x67
....................       
....................       ADS1220init(ch, rc0, rc1, rc2, rc3);
00898:  MOVFF  668,66B
0089C:  MOVFF  664,66C
008A0:  MOVFF  665,66D
008A4:  MOVFF  666,66E
008A8:  MOVFF  667,66F
008AC:  MOVLB  0
008AE:  BRA    073A
....................       delay_ms(100);
008B0:  MOVLW  64
008B2:  MOVLB  6
008B4:  MOVWF  x6C
008B6:  MOVLB  0
008B8:  RCALL  0426
008BA:  MOVLB  6
008BC:  INCF   x68,F
008BE:  BRA    0884
....................    }
....................    
.................... 
....................    clrbuff(smData[0].sinQ);
008C0:  MOVFF  1BE,01
008C4:  MOVFF  1BF,03
008C8:  MOVLW  01
008CA:  MOVLB  1
008CC:  ADDWF  xBE,W
008CE:  MOVWF  FE9
008D0:  MOVLW  00
008D2:  ADDWFC xBF,W
008D4:  MOVWF  FEA
008D6:  CLRF   FEF
008D8:  MOVLW  00
008DA:  MOVLB  6
008DC:  MOVFF  03,FEA
008E0:  MOVFF  01,FE9
008E4:  MOVWF  FEF
....................    clrbuff(smData[0].cosQ);
008E6:  MOVFF  1C0,01
008EA:  MOVFF  1C1,03
008EE:  MOVLW  01
008F0:  MOVLB  1
008F2:  ADDWF  xC0,W
008F4:  MOVWF  FE9
008F6:  MOVLW  00
008F8:  ADDWFC xC1,W
008FA:  MOVWF  FEA
008FC:  CLRF   FEF
008FE:  MOVLW  00
00900:  MOVLB  6
00902:  MOVFF  03,FEA
00906:  MOVFF  01,FE9
0090A:  MOVWF  FEF
....................    clrbuff(smData[1].sinQ);
0090C:  MOVFF  1CB,01
00910:  MOVFF  1CC,03
00914:  MOVLW  01
00916:  MOVLB  1
00918:  ADDWF  xCB,W
0091A:  MOVWF  FE9
0091C:  MOVLW  00
0091E:  ADDWFC xCC,W
00920:  MOVWF  FEA
00922:  CLRF   FEF
00924:  MOVLW  00
00926:  MOVLB  6
00928:  MOVFF  03,FEA
0092C:  MOVFF  01,FE9
00930:  MOVWF  FEF
....................    clrbuff(smData[1].cosQ);
00932:  MOVFF  1CD,01
00936:  MOVFF  1CE,03
0093A:  MOVLW  01
0093C:  MOVLB  1
0093E:  ADDWF  xCD,W
00940:  MOVWF  FE9
00942:  MOVLW  00
00944:  ADDWFC xCE,W
00946:  MOVWF  FEA
00948:  CLRF   FEF
0094A:  MOVLW  00
0094C:  MOVLB  6
0094E:  MOVFF  03,FEA
00952:  MOVFF  01,FE9
00956:  MOVWF  FEF
....................    smData[0].sinQ->in = 0;
00958:  MOVLB  1
0095A:  MOVFF  1BE,FE9
0095E:  MOVFF  1BF,FEA
00962:  CLRF   FEF
....................    smData[0].sinQ->out = 0;
00964:  MOVLW  01
00966:  ADDWF  xBE,W
00968:  MOVWF  FE9
0096A:  MOVLW  00
0096C:  ADDWFC xBF,W
0096E:  MOVWF  FEA
00970:  CLRF   FEF
....................    for (int i = 0; i < BUFFER_SIZE; i++){
00972:  MOVLB  6
00974:  CLRF   x69
00976:  MOVF   x69,W
00978:  SUBLW  04
0097A:  BTFSS  FD8.0
0097C:  BRA    1016
....................       ads_start_conv_all();
0097E:  MOVLB  0
00980:  BRA    07D8
....................       delay_ms(600);
00982:  MOVLW  03
00984:  MOVLB  6
00986:  MOVWF  x6B
00988:  MOVLW  C8
0098A:  MOVWF  x6C
0098C:  MOVLB  0
0098E:  RCALL  0426
00990:  MOVLB  6
00992:  DECFSZ x6B,F
00994:  BRA    0988
....................       for (int b = 0; b < 2; b++){
00996:  CLRF   x6A
00998:  MOVF   x6A,W
0099A:  SUBLW  01
0099C:  BTFSS  FD8.0
0099E:  BRA    1012
....................          tobuff(smData[b].sinQ, ads_read_data(b*2));
009A0:  MOVF   x6A,W
009A2:  MULLW  0D
009A4:  MOVF   FF3,W
009A6:  CLRF   x6C
009A8:  MOVWF  x6B
009AA:  MOVLW  01
009AC:  ADDWF  x6B,W
009AE:  MOVWF  01
009B0:  MOVLW  00
009B2:  ADDWFC x6C,W
009B4:  MOVWF  03
009B6:  MOVF   01,W
009B8:  ADDLW  BD
009BA:  MOVWF  01
009BC:  MOVLW  01
009BE:  ADDWFC 03,F
009C0:  MOVFF  01,66B
009C4:  MOVFF  03,66C
009C8:  MOVFF  03,FEA
009CC:  MOVFF  01,FE9
009D0:  MOVFF  FEC,66E
009D4:  MOVF   FED,F
009D6:  MOVFF  FEF,66D
009DA:  MOVF   x6A,W
009DC:  MULLW  0D
009DE:  MOVF   FF3,W
009E0:  CLRF   x70
009E2:  MOVWF  x6F
009E4:  MOVLW  01
009E6:  ADDWF  x6F,W
009E8:  MOVWF  01
009EA:  MOVLW  00
009EC:  ADDWFC x70,W
009EE:  MOVWF  03
009F0:  MOVF   01,W
009F2:  ADDLW  BD
009F4:  MOVWF  01
009F6:  MOVLW  01
009F8:  ADDWFC 03,F
009FA:  MOVFF  01,66F
009FE:  MOVFF  03,670
00A02:  MOVFF  03,FEA
00A06:  MOVFF  01,FE9
00A0A:  MOVFF  FEC,672
00A0E:  MOVF   FED,F
00A10:  MOVFF  FEF,671
00A14:  MOVFF  671,FE9
00A18:  MOVFF  672,FEA
00A1C:  CLRF   xB1
00A1E:  MOVFF  FEF,6B0
00A22:  CLRF   xB3
00A24:  MOVLW  04
00A26:  MOVWF  xB2
00A28:  MOVLB  0
00A2A:  RCALL  07F0
00A2C:  MOVFF  02,03
00A30:  MOVF   01,W
00A32:  ADDLW  02
00A34:  MOVWF  01
00A36:  MOVLW  00
00A38:  ADDWFC 03,F
00A3A:  MOVF   01,W
00A3C:  MOVLB  6
00A3E:  ADDWF  x6D,W
00A40:  MOVWF  01
00A42:  MOVF   x6E,W
00A44:  ADDWFC 03,F
00A46:  MOVFF  01,673
00A4A:  MOVFF  03,674
00A4E:  BCF    FD8.0
00A50:  RLCF   x6A,W
00A52:  MOVWF  x75
00A54:  MOVWF  x76
00A56:  MOVLB  0
00A58:  RCALL  082A
00A5A:  MOVFF  674,FEA
00A5E:  MOVFF  673,FE9
00A62:  MOVFF  00,FEF
00A66:  MOVFF  01,FEC
00A6A:  MOVFF  02,FEC
00A6E:  MOVFF  03,FEC
00A72:  MOVLB  6
00A74:  MOVF   x6A,W
00A76:  MULLW  0D
00A78:  MOVF   FF3,W
00A7A:  CLRF   x6C
00A7C:  MOVWF  x6B
00A7E:  MOVLW  01
00A80:  ADDWF  x6B,W
00A82:  MOVWF  01
00A84:  MOVLW  00
00A86:  ADDWFC x6C,W
00A88:  MOVWF  03
00A8A:  MOVF   01,W
00A8C:  ADDLW  BD
00A8E:  MOVWF  01
00A90:  MOVLW  01
00A92:  ADDWFC 03,F
00A94:  MOVFF  01,66B
00A98:  MOVFF  03,66C
00A9C:  MOVFF  03,FEA
00AA0:  MOVFF  01,FE9
00AA4:  MOVFF  FEC,03
00AA8:  MOVF   FED,F
00AAA:  MOVFF  FEF,01
00AAE:  MOVFF  01,66F
00AB2:  MOVFF  03,670
00AB6:  MOVF   x6A,W
00AB8:  MULLW  0D
00ABA:  MOVF   FF3,W
00ABC:  CLRF   x72
00ABE:  MOVWF  x71
00AC0:  MOVLW  01
00AC2:  ADDWF  x71,W
00AC4:  MOVWF  01
00AC6:  MOVLW  00
00AC8:  ADDWFC x72,W
00ACA:  MOVWF  03
00ACC:  MOVF   01,W
00ACE:  ADDLW  BD
00AD0:  MOVWF  01
00AD2:  MOVLW  01
00AD4:  ADDWFC 03,F
00AD6:  MOVFF  01,671
00ADA:  MOVFF  03,672
00ADE:  MOVFF  03,FEA
00AE2:  MOVFF  01,FE9
00AE6:  MOVFF  FEC,674
00AEA:  MOVF   FED,F
00AEC:  MOVFF  FEF,673
00AF0:  MOVFF  673,FE9
00AF4:  MOVFF  674,FEA
00AF8:  MOVF   FEF,W
00AFA:  SUBLW  04
00AFC:  BNZ   0B02
00AFE:  MOVLW  00
00B00:  BRA    0B48
00B02:  MOVF   x6A,W
00B04:  MULLW  0D
00B06:  MOVF   FF3,W
00B08:  CLRF   x76
00B0A:  MOVWF  x75
00B0C:  MOVLW  01
00B0E:  ADDWF  x75,W
00B10:  MOVWF  01
00B12:  MOVLW  00
00B14:  ADDWFC x76,W
00B16:  MOVWF  03
00B18:  MOVF   01,W
00B1A:  ADDLW  BD
00B1C:  MOVWF  01
00B1E:  MOVLW  01
00B20:  ADDWFC 03,F
00B22:  MOVFF  01,675
00B26:  MOVFF  03,676
00B2A:  MOVFF  03,FEA
00B2E:  MOVFF  01,FE9
00B32:  MOVFF  FEC,678
00B36:  MOVF   FED,F
00B38:  MOVFF  FEF,677
00B3C:  MOVFF  677,FE9
00B40:  MOVFF  678,FEA
00B44:  MOVLW  01
00B46:  ADDWF  FEF,W
00B48:  MOVWF  x79
00B4A:  MOVFF  670,FEA
00B4E:  MOVFF  66F,FE9
00B52:  MOVWF  FEF
00B54:  MOVF   x6A,W
00B56:  MULLW  0D
00B58:  MOVF   FF3,W
00B5A:  CLRF   x6C
00B5C:  MOVWF  x6B
00B5E:  MOVLW  01
00B60:  ADDWF  x6B,W
00B62:  MOVWF  01
00B64:  MOVLW  00
00B66:  ADDWFC x6C,W
00B68:  MOVWF  03
00B6A:  MOVF   01,W
00B6C:  ADDLW  BD
00B6E:  MOVWF  01
00B70:  MOVLW  01
00B72:  ADDWFC 03,F
00B74:  MOVFF  01,66B
00B78:  MOVFF  03,66C
00B7C:  MOVFF  03,FEA
00B80:  MOVFF  01,FE9
00B84:  MOVFF  FEC,66E
00B88:  MOVF   FED,F
00B8A:  MOVFF  FEF,66D
00B8E:  MOVFF  66D,FE9
00B92:  MOVFF  66E,FEA
00B96:  MOVFF  FEF,66F
00B9A:  MOVF   x6A,W
00B9C:  MULLW  0D
00B9E:  MOVF   FF3,W
00BA0:  CLRF   x71
00BA2:  MOVWF  x70
00BA4:  MOVLW  01
00BA6:  ADDWF  x70,W
00BA8:  MOVWF  01
00BAA:  MOVLW  00
00BAC:  ADDWFC x71,W
00BAE:  MOVWF  03
00BB0:  MOVF   01,W
00BB2:  ADDLW  BD
00BB4:  MOVWF  01
00BB6:  MOVLW  01
00BB8:  ADDWFC 03,F
00BBA:  MOVFF  01,670
00BBE:  MOVFF  03,671
00BC2:  MOVFF  03,FEA
00BC6:  MOVFF  01,FE9
00BCA:  MOVFF  FEC,673
00BCE:  MOVF   FED,F
00BD0:  MOVFF  FEF,672
00BD4:  MOVLW  01
00BD6:  ADDWF  x72,W
00BD8:  MOVWF  FE9
00BDA:  MOVLW  00
00BDC:  ADDWFC x73,W
00BDE:  MOVWF  FEA
00BE0:  MOVF   FEF,W
00BE2:  SUBWF  x6F,W
00BE4:  BNZ   0CD6
00BE6:  MOVF   x6A,W
00BE8:  MULLW  0D
00BEA:  MOVF   FF3,W
00BEC:  CLRF   x6C
00BEE:  MOVWF  x6B
00BF0:  MOVLW  01
00BF2:  ADDWF  x6B,W
00BF4:  MOVWF  01
00BF6:  MOVLW  00
00BF8:  ADDWFC x6C,W
00BFA:  MOVWF  03
00BFC:  MOVF   01,W
00BFE:  ADDLW  BD
00C00:  MOVWF  01
00C02:  MOVLW  01
00C04:  ADDWFC 03,F
00C06:  MOVFF  01,66B
00C0A:  MOVFF  03,66C
00C0E:  MOVFF  03,FEA
00C12:  MOVFF  01,FE9
00C16:  MOVFF  FEC,66E
00C1A:  MOVF   FED,F
00C1C:  MOVFF  FEF,66D
00C20:  MOVLW  01
00C22:  ADDWF  x6D,W
00C24:  MOVWF  01
00C26:  MOVLW  00
00C28:  ADDWFC x6E,W
00C2A:  MOVWF  03
00C2C:  MOVFF  01,66F
00C30:  MOVWF  x70
00C32:  MOVF   x6A,W
00C34:  MULLW  0D
00C36:  MOVF   FF3,W
00C38:  CLRF   x72
00C3A:  MOVWF  x71
00C3C:  MOVLW  01
00C3E:  ADDWF  x71,W
00C40:  MOVWF  01
00C42:  MOVLW  00
00C44:  ADDWFC x72,W
00C46:  MOVWF  03
00C48:  MOVF   01,W
00C4A:  ADDLW  BD
00C4C:  MOVWF  01
00C4E:  MOVLW  01
00C50:  ADDWFC 03,F
00C52:  MOVFF  01,671
00C56:  MOVFF  03,672
00C5A:  MOVFF  03,FEA
00C5E:  MOVFF  01,FE9
00C62:  MOVFF  FEC,674
00C66:  MOVF   FED,F
00C68:  MOVFF  FEF,673
00C6C:  MOVLW  01
00C6E:  ADDWF  x73,W
00C70:  MOVWF  FE9
00C72:  MOVLW  00
00C74:  ADDWFC x74,W
00C76:  MOVWF  FEA
00C78:  MOVF   FEF,W
00C7A:  SUBLW  04
00C7C:  BNZ   0C82
00C7E:  MOVLW  00
00C80:  BRA    0CCC
00C82:  MOVF   x6A,W
00C84:  MULLW  0D
00C86:  MOVF   FF3,W
00C88:  CLRF   x76
00C8A:  MOVWF  x75
00C8C:  MOVLW  01
00C8E:  ADDWF  x75,W
00C90:  MOVWF  01
00C92:  MOVLW  00
00C94:  ADDWFC x76,W
00C96:  MOVWF  03
00C98:  MOVF   01,W
00C9A:  ADDLW  BD
00C9C:  MOVWF  01
00C9E:  MOVLW  01
00CA0:  ADDWFC 03,F
00CA2:  MOVFF  01,675
00CA6:  MOVFF  03,676
00CAA:  MOVFF  03,FEA
00CAE:  MOVFF  01,FE9
00CB2:  MOVFF  FEC,678
00CB6:  MOVF   FED,F
00CB8:  MOVFF  FEF,677
00CBC:  MOVLW  01
00CBE:  ADDWF  x77,W
00CC0:  MOVWF  FE9
00CC2:  MOVLW  00
00CC4:  ADDWFC x78,W
00CC6:  MOVWF  FEA
00CC8:  MOVLW  01
00CCA:  ADDWF  FEF,W
00CCC:  MOVFF  670,FEA
00CD0:  MOVFF  66F,FE9
00CD4:  MOVWF  FEF
....................          tobuff(smData[b].cosQ, ads_read_data(b*2+1));      
00CD6:  MOVF   x6A,W
00CD8:  MULLW  0D
00CDA:  MOVF   FF3,W
00CDC:  CLRF   x6C
00CDE:  MOVWF  x6B
00CE0:  MOVLW  03
00CE2:  ADDWF  x6B,W
00CE4:  MOVWF  01
00CE6:  MOVLW  00
00CE8:  ADDWFC x6C,W
00CEA:  MOVWF  03
00CEC:  MOVF   01,W
00CEE:  ADDLW  BD
00CF0:  MOVWF  01
00CF2:  MOVLW  01
00CF4:  ADDWFC 03,F
00CF6:  MOVFF  01,66B
00CFA:  MOVFF  03,66C
00CFE:  MOVFF  03,FEA
00D02:  MOVFF  01,FE9
00D06:  MOVFF  FEC,66E
00D0A:  MOVF   FED,F
00D0C:  MOVFF  FEF,66D
00D10:  MOVF   x6A,W
00D12:  MULLW  0D
00D14:  MOVF   FF3,W
00D16:  CLRF   x70
00D18:  MOVWF  x6F
00D1A:  MOVLW  03
00D1C:  ADDWF  x6F,W
00D1E:  MOVWF  01
00D20:  MOVLW  00
00D22:  ADDWFC x70,W
00D24:  MOVWF  03
00D26:  MOVF   01,W
00D28:  ADDLW  BD
00D2A:  MOVWF  01
00D2C:  MOVLW  01
00D2E:  ADDWFC 03,F
00D30:  MOVFF  01,66F
00D34:  MOVFF  03,670
00D38:  MOVFF  03,FEA
00D3C:  MOVFF  01,FE9
00D40:  MOVFF  FEC,672
00D44:  MOVF   FED,F
00D46:  MOVFF  FEF,671
00D4A:  MOVFF  671,FE9
00D4E:  MOVFF  672,FEA
00D52:  CLRF   xB1
00D54:  MOVFF  FEF,6B0
00D58:  CLRF   xB3
00D5A:  MOVLW  04
00D5C:  MOVWF  xB2
00D5E:  MOVLB  0
00D60:  RCALL  07F0
00D62:  MOVFF  02,03
00D66:  MOVF   01,W
00D68:  ADDLW  02
00D6A:  MOVWF  01
00D6C:  MOVLW  00
00D6E:  ADDWFC 03,F
00D70:  MOVF   01,W
00D72:  MOVLB  6
00D74:  ADDWF  x6D,W
00D76:  MOVWF  01
00D78:  MOVF   x6E,W
00D7A:  ADDWFC 03,F
00D7C:  MOVFF  01,673
00D80:  MOVFF  03,674
00D84:  BCF    FD8.0
00D86:  RLCF   x6A,W
00D88:  ADDLW  01
00D8A:  MOVWF  x75
00D8C:  MOVWF  x76
00D8E:  MOVLB  0
00D90:  RCALL  082A
00D92:  MOVFF  674,FEA
00D96:  MOVFF  673,FE9
00D9A:  MOVFF  00,FEF
00D9E:  MOVFF  01,FEC
00DA2:  MOVFF  02,FEC
00DA6:  MOVFF  03,FEC
00DAA:  MOVLB  6
00DAC:  MOVF   x6A,W
00DAE:  MULLW  0D
00DB0:  MOVF   FF3,W
00DB2:  CLRF   x6C
00DB4:  MOVWF  x6B
00DB6:  MOVLW  03
00DB8:  ADDWF  x6B,W
00DBA:  MOVWF  01
00DBC:  MOVLW  00
00DBE:  ADDWFC x6C,W
00DC0:  MOVWF  03
00DC2:  MOVF   01,W
00DC4:  ADDLW  BD
00DC6:  MOVWF  01
00DC8:  MOVLW  01
00DCA:  ADDWFC 03,F
00DCC:  MOVFF  01,66B
00DD0:  MOVFF  03,66C
00DD4:  MOVFF  03,FEA
00DD8:  MOVFF  01,FE9
00DDC:  MOVFF  FEC,03
00DE0:  MOVF   FED,F
00DE2:  MOVFF  FEF,01
00DE6:  MOVFF  01,66F
00DEA:  MOVFF  03,670
00DEE:  MOVF   x6A,W
00DF0:  MULLW  0D
00DF2:  MOVF   FF3,W
00DF4:  CLRF   x72
00DF6:  MOVWF  x71
00DF8:  MOVLW  03
00DFA:  ADDWF  x71,W
00DFC:  MOVWF  01
00DFE:  MOVLW  00
00E00:  ADDWFC x72,W
00E02:  MOVWF  03
00E04:  MOVF   01,W
00E06:  ADDLW  BD
00E08:  MOVWF  01
00E0A:  MOVLW  01
00E0C:  ADDWFC 03,F
00E0E:  MOVFF  01,671
00E12:  MOVFF  03,672
00E16:  MOVFF  03,FEA
00E1A:  MOVFF  01,FE9
00E1E:  MOVFF  FEC,674
00E22:  MOVF   FED,F
00E24:  MOVFF  FEF,673
00E28:  MOVFF  673,FE9
00E2C:  MOVFF  674,FEA
00E30:  MOVF   FEF,W
00E32:  SUBLW  04
00E34:  BNZ   0E3A
00E36:  MOVLW  00
00E38:  BRA    0E80
00E3A:  MOVF   x6A,W
00E3C:  MULLW  0D
00E3E:  MOVF   FF3,W
00E40:  CLRF   x76
00E42:  MOVWF  x75
00E44:  MOVLW  03
00E46:  ADDWF  x75,W
00E48:  MOVWF  01
00E4A:  MOVLW  00
00E4C:  ADDWFC x76,W
00E4E:  MOVWF  03
00E50:  MOVF   01,W
00E52:  ADDLW  BD
00E54:  MOVWF  01
00E56:  MOVLW  01
00E58:  ADDWFC 03,F
00E5A:  MOVFF  01,675
00E5E:  MOVFF  03,676
00E62:  MOVFF  03,FEA
00E66:  MOVFF  01,FE9
00E6A:  MOVFF  FEC,678
00E6E:  MOVF   FED,F
00E70:  MOVFF  FEF,677
00E74:  MOVFF  677,FE9
00E78:  MOVFF  678,FEA
00E7C:  MOVLW  01
00E7E:  ADDWF  FEF,W
00E80:  MOVWF  x79
00E82:  MOVFF  670,FEA
00E86:  MOVFF  66F,FE9
00E8A:  MOVWF  FEF
00E8C:  MOVF   x6A,W
00E8E:  MULLW  0D
00E90:  MOVF   FF3,W
00E92:  CLRF   x6C
00E94:  MOVWF  x6B
00E96:  MOVLW  03
00E98:  ADDWF  x6B,W
00E9A:  MOVWF  01
00E9C:  MOVLW  00
00E9E:  ADDWFC x6C,W
00EA0:  MOVWF  03
00EA2:  MOVF   01,W
00EA4:  ADDLW  BD
00EA6:  MOVWF  01
00EA8:  MOVLW  01
00EAA:  ADDWFC 03,F
00EAC:  MOVFF  01,66B
00EB0:  MOVFF  03,66C
00EB4:  MOVFF  03,FEA
00EB8:  MOVFF  01,FE9
00EBC:  MOVFF  FEC,66E
00EC0:  MOVF   FED,F
00EC2:  MOVFF  FEF,66D
00EC6:  MOVFF  66D,FE9
00ECA:  MOVFF  66E,FEA
00ECE:  MOVFF  FEF,66F
00ED2:  MOVF   x6A,W
00ED4:  MULLW  0D
00ED6:  MOVF   FF3,W
00ED8:  CLRF   x71
00EDA:  MOVWF  x70
00EDC:  MOVLW  03
00EDE:  ADDWF  x70,W
00EE0:  MOVWF  01
00EE2:  MOVLW  00
00EE4:  ADDWFC x71,W
00EE6:  MOVWF  03
00EE8:  MOVF   01,W
00EEA:  ADDLW  BD
00EEC:  MOVWF  01
00EEE:  MOVLW  01
00EF0:  ADDWFC 03,F
00EF2:  MOVFF  01,670
00EF6:  MOVFF  03,671
00EFA:  MOVFF  03,FEA
00EFE:  MOVFF  01,FE9
00F02:  MOVFF  FEC,673
00F06:  MOVF   FED,F
00F08:  MOVFF  FEF,672
00F0C:  MOVLW  01
00F0E:  ADDWF  x72,W
00F10:  MOVWF  FE9
00F12:  MOVLW  00
00F14:  ADDWFC x73,W
00F16:  MOVWF  FEA
00F18:  MOVF   FEF,W
00F1A:  SUBWF  x6F,W
00F1C:  BNZ   100E
00F1E:  MOVF   x6A,W
00F20:  MULLW  0D
00F22:  MOVF   FF3,W
00F24:  CLRF   x6C
00F26:  MOVWF  x6B
00F28:  MOVLW  03
00F2A:  ADDWF  x6B,W
00F2C:  MOVWF  01
00F2E:  MOVLW  00
00F30:  ADDWFC x6C,W
00F32:  MOVWF  03
00F34:  MOVF   01,W
00F36:  ADDLW  BD
00F38:  MOVWF  01
00F3A:  MOVLW  01
00F3C:  ADDWFC 03,F
00F3E:  MOVFF  01,66B
00F42:  MOVFF  03,66C
00F46:  MOVFF  03,FEA
00F4A:  MOVFF  01,FE9
00F4E:  MOVFF  FEC,66E
00F52:  MOVF   FED,F
00F54:  MOVFF  FEF,66D
00F58:  MOVLW  01
00F5A:  ADDWF  x6D,W
00F5C:  MOVWF  01
00F5E:  MOVLW  00
00F60:  ADDWFC x6E,W
00F62:  MOVWF  03
00F64:  MOVFF  01,66F
00F68:  MOVWF  x70
00F6A:  MOVF   x6A,W
00F6C:  MULLW  0D
00F6E:  MOVF   FF3,W
00F70:  CLRF   x72
00F72:  MOVWF  x71
00F74:  MOVLW  03
00F76:  ADDWF  x71,W
00F78:  MOVWF  01
00F7A:  MOVLW  00
00F7C:  ADDWFC x72,W
00F7E:  MOVWF  03
00F80:  MOVF   01,W
00F82:  ADDLW  BD
00F84:  MOVWF  01
00F86:  MOVLW  01
00F88:  ADDWFC 03,F
00F8A:  MOVFF  01,671
00F8E:  MOVFF  03,672
00F92:  MOVFF  03,FEA
00F96:  MOVFF  01,FE9
00F9A:  MOVFF  FEC,674
00F9E:  MOVF   FED,F
00FA0:  MOVFF  FEF,673
00FA4:  MOVLW  01
00FA6:  ADDWF  x73,W
00FA8:  MOVWF  FE9
00FAA:  MOVLW  00
00FAC:  ADDWFC x74,W
00FAE:  MOVWF  FEA
00FB0:  MOVF   FEF,W
00FB2:  SUBLW  04
00FB4:  BNZ   0FBA
00FB6:  MOVLW  00
00FB8:  BRA    1004
00FBA:  MOVF   x6A,W
00FBC:  MULLW  0D
00FBE:  MOVF   FF3,W
00FC0:  CLRF   x76
00FC2:  MOVWF  x75
00FC4:  MOVLW  03
00FC6:  ADDWF  x75,W
00FC8:  MOVWF  01
00FCA:  MOVLW  00
00FCC:  ADDWFC x76,W
00FCE:  MOVWF  03
00FD0:  MOVF   01,W
00FD2:  ADDLW  BD
00FD4:  MOVWF  01
00FD6:  MOVLW  01
00FD8:  ADDWFC 03,F
00FDA:  MOVFF  01,675
00FDE:  MOVFF  03,676
00FE2:  MOVFF  03,FEA
00FE6:  MOVFF  01,FE9
00FEA:  MOVFF  FEC,678
00FEE:  MOVF   FED,F
00FF0:  MOVFF  FEF,677
00FF4:  MOVLW  01
00FF6:  ADDWF  x77,W
00FF8:  MOVWF  FE9
00FFA:  MOVLW  00
00FFC:  ADDWFC x78,W
00FFE:  MOVWF  FEA
01000:  MOVLW  01
01002:  ADDWF  FEF,W
01004:  MOVFF  670,FEA
01008:  MOVFF  66F,FE9
0100C:  MOVWF  FEF
0100E:  INCF   x6A,F
01010:  BRA    0998
....................       }
01012:  INCF   x69,F
01014:  BRA    0976
....................    }
01016:  MOVLB  0
01018:  GOTO   1080 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE MONITOR -- sets up ADC channels                                */
.................... /*****************************************************************************/
.................... void monitor_init()
.................... {
....................    setup_adc_ports(sAN6 | sAN16 | sAN17 | sAN24 | sAN25 | sAN26 | sAN27, NO_ANALOGS_P2, VSS_VDD);
0101C:  MOVLW  00
0101E:  MOVLB  F
01020:  MOVWF  x53
01022:  MOVLW  40
01024:  MOVWF  x0C
01026:  MOVLW  00
01028:  MOVWF  x14
0102A:  MOVLW  03
0102C:  MOVWF  x1C
0102E:  MOVLW  0F
01030:  MOVWF  x21
01032:  MOVLW  00
01034:  MOVWF  x29
....................    setup_adc(ADC_CLOCK_INTERNAL | ADC_TAD_MUL_255 | ADC_LEGACY_MODE | ADC_THRESHOLD_INT_DISABLED);
01036:  MOVLW  08
01038:  MOVWF  x55
0103A:  CLRF   x56
0103C:  CLRF   x52
0103E:  SETF   x57
01040:  CLRF   F61
01042:  MOVLW  94
01044:  MOVWF  x5B
....................    output_high(EN_EXC);
01046:  MOVLW  E8
01048:  MOVWF  F8B
0104A:  BSF    F86.0
....................    set_adc_channel(vMonN15); // internal MUX
0104C:  MOVF   x5A,W
0104E:  ANDLW  3F
01050:  MOVWF  01
01052:  MOVLW  06
01054:  MOVWF  x5A
01056:  BTFSS  x5B.7
01058:  BRA    1068
0105A:  MOVF   01,W
0105C:  SUBLW  06
0105E:  BZ    1068
01060:  BSF    x5B.0
01062:  NOP   
01064:  BTFSC  x5B.0
01066:  BRA    1064
....................    delay_ms(10);
01068:  MOVLW  0A
0106A:  MOVLB  6
0106C:  MOVWF  x6C
0106E:  MOVLB  0
01070:  CALL   0426
....................    read_adc(ADC_START_ONLY);
01074:  MOVLB  F
01076:  BSF    x5B.0
01078:  NOP   
....................    setup_external_ADCs();
0107A:  MOVLB  0
0107C:  GOTO   0878
....................    intTimeoutReg = sensorSampleRate;
01080:  MOVLB  1
01082:  CLRF   x64
01084:  MOVLW  32
01086:  MOVWF  x63
01088:  MOVLB  0
0108A:  GOTO   AFB4 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <control.h>
.................... #ifndef control
.................... #define control
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0.3,0.1,0,0,0,0,0},
....................    {0.01,0.3,0.1,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <pid.h>
.................... #ifndef pidcontroller
.................... #define pidcontroller
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0.3,0.1,0,0,0,0,0},
....................    {0.01,0.3,0.1,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float32)(unsigned int16)y;
.................... 
....................  else if (y < 10000000.0)
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
....................       res = 32768.0*(float32)l;
....................       res += (float32)(unsigned int16)y;
....................    }
.................... 
....................  else
....................   res = y;
.................... 
....................  y = y - (float32)(unsigned int16)y;
.................... 
....................  if (s)
....................   res = -res;
.................... 
....................  if (y != 0)
....................  {
....................   if (s == 1 && n == 0)
....................    res -= 1.0;
.................... 
....................   if (s == 0 && n == 1)
....................    res += 1.0;
....................  }
....................  if (x == 0)
....................     res = 0;
.................... 
....................  return (res);
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl[0]*y2 + pl[1];
.................... 
....................       r = ql[0]*y2 + ql[1];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
....................          r = -(float32)-n;
....................       else
....................          r = (float32)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* UPDATE the Control Variable (CV)                                          */
.................... /*****************************************************************************/
.................... void pid_update (channelMap ch){
*
0510A:  MOVLB  6
0510C:  MOVF   x68,W
0510E:  MULLW  20
05110:  MOVF   FF3,W
05112:  CLRF   x76
05114:  MOVWF  x75
05116:  MOVLW  0C
05118:  ADDWF  x75,W
0511A:  MOVWF  01
0511C:  MOVLW  00
0511E:  ADDWFC x76,W
05120:  MOVWF  03
05122:  MOVF   01,W
05124:  ADDLW  20
05126:  MOVWF  FE9
05128:  MOVLW  00
0512A:  ADDWFC 03,W
0512C:  MOVWF  FEA
0512E:  MOVFF  FEF,6B3
05132:  MOVFF  FEC,6B4
05136:  MOVFF  FEC,6B5
0513A:  MOVFF  FEC,6B6
0513E:  MOVF   x68,W
05140:  MULLW  20
05142:  MOVF   FF3,W
05144:  CLRF   x7A
05146:  MOVWF  x79
05148:  MOVLW  10
0514A:  ADDWF  x79,W
0514C:  MOVWF  01
0514E:  MOVLW  00
05150:  ADDWFC x7A,W
05152:  MOVWF  03
05154:  MOVF   01,W
05156:  ADDLW  20
05158:  MOVWF  FE9
0515A:  MOVLW  00
0515C:  ADDWFC 03,W
0515E:  MOVWF  FEA
05160:  MOVFF  FEF,6B7
05164:  MOVFF  FEC,01
05168:  MOVFF  FEC,02
0516C:  MOVFF  FEC,03
05170:  MOVFF  FEA,67A
05174:  MOVFF  FE9,679
05178:  BSF    FD8.1
0517A:  MOVFF  03,6BA
0517E:  MOVFF  02,6B9
05182:  MOVFF  01,6B8
05186:  MOVLB  0
05188:  CALL   13EE
0518C:  MOVFF  67A,FEA
05190:  MOVFF  679,FE9
05194:  MOVFF  03,66C
05198:  MOVFF  02,66B
0519C:  MOVFF  01,66A
051A0:  MOVFF  00,669
....................    float err = PID[ch].SP - PID[ch].PV;  // error = set value - measured
....................    
....................    PID[ch].I += err*PID[ch].kI;
051A4:  MOVLB  6
051A6:  MOVF   x68,W
051A8:  MULLW  20
051AA:  MOVF   FF3,W
051AC:  CLRF   x76
051AE:  MOVWF  x75
051B0:  MOVLW  1C
051B2:  ADDWF  x75,W
051B4:  MOVWF  01
051B6:  MOVLW  00
051B8:  ADDWFC x76,W
051BA:  MOVWF  03
051BC:  MOVF   01,W
051BE:  ADDLW  20
051C0:  MOVWF  01
051C2:  MOVLW  00
051C4:  ADDWFC 03,F
051C6:  MOVFF  01,675
051CA:  MOVFF  03,676
051CE:  MOVFF  03,FEA
051D2:  MOVFF  01,FE9
051D6:  MOVFF  FEF,677
051DA:  MOVFF  FEC,678
051DE:  MOVFF  FEC,679
051E2:  MOVFF  FEC,67A
051E6:  MOVF   x68,W
051E8:  MULLW  20
051EA:  MOVF   FF3,W
051EC:  CLRF   x7C
051EE:  MOVWF  x7B
051F0:  MOVLW  04
051F2:  ADDWF  x7B,W
051F4:  MOVWF  01
051F6:  MOVLW  00
051F8:  ADDWFC x7C,W
051FA:  MOVWF  03
051FC:  MOVF   01,W
051FE:  ADDLW  20
05200:  MOVWF  FE9
05202:  MOVLW  00
05204:  ADDWFC 03,W
05206:  MOVWF  FEA
05208:  MOVFF  FEF,6B8
0520C:  MOVFF  FEC,01
05210:  MOVFF  FEC,02
05214:  MOVFF  FEC,03
05218:  MOVFF  66C,6B7
0521C:  MOVFF  66B,6B6
05220:  MOVFF  66A,6B5
05224:  MOVFF  669,6B4
05228:  MOVFF  03,6BB
0522C:  MOVFF  02,6BA
05230:  MOVFF  01,6B9
05234:  MOVLB  0
05236:  CALL   12F8
0523A:  BCF    FD8.1
0523C:  MOVFF  67A,6B6
05240:  MOVFF  679,6B5
05244:  MOVFF  678,6B4
05248:  MOVFF  677,6B3
0524C:  MOVFF  03,6BA
05250:  MOVFF  02,6B9
05254:  MOVFF  01,6B8
05258:  MOVFF  00,6B7
0525C:  CALL   13EE
05260:  MOVFF  676,FEA
05264:  MOVFF  675,FE9
05268:  MOVFF  00,FEF
0526C:  MOVFF  01,FEC
05270:  MOVFF  02,FEC
05274:  MOVFF  03,FEC
....................    if (PID[ch].I > op_upper_bound) PID[ch].I = op_upper_bound; // anti-windup
05278:  MOVLB  6
0527A:  MOVF   x68,W
0527C:  MULLW  20
0527E:  MOVF   FF3,W
05280:  CLRF   x76
05282:  MOVWF  x75
05284:  MOVLW  1C
05286:  ADDWF  x75,W
05288:  MOVWF  01
0528A:  MOVLW  00
0528C:  ADDWFC x76,W
0528E:  MOVWF  03
05290:  MOVF   01,W
05292:  ADDLW  20
05294:  MOVWF  FE9
05296:  MOVLW  00
05298:  ADDWFC 03,W
0529A:  MOVWF  FEA
0529C:  MOVFF  FEF,6B3
052A0:  MOVFF  FEC,676
052A4:  MOVFF  FEC,6B5
052A8:  MOVFF  FEC,6B6
052AC:  CLRF   xB2
052AE:  CLRF   xB1
052B0:  MOVLW  7C
052B2:  MOVWF  xB0
052B4:  MOVLW  84
052B6:  MOVWF  xAF
052B8:  MOVFF  676,6B4
052BC:  MOVLB  0
052BE:  CALL   27C4
052C2:  BNC   52F6
052C4:  MOVLB  6
052C6:  MOVF   x68,W
052C8:  MULLW  20
052CA:  MOVF   FF3,W
052CC:  CLRF   x76
052CE:  MOVWF  x75
052D0:  MOVLW  1C
052D2:  ADDWF  x75,W
052D4:  MOVWF  01
052D6:  MOVLW  00
052D8:  ADDWFC x76,W
052DA:  MOVWF  03
052DC:  MOVF   01,W
052DE:  ADDLW  20
052E0:  MOVWF  FE9
052E2:  MOVLW  00
052E4:  ADDWFC 03,W
052E6:  MOVWF  FEA
052E8:  MOVLW  84
052EA:  MOVWF  FEF
052EC:  MOVLW  7C
052EE:  MOVWF  FEC
052F0:  CLRF   FEC
052F2:  CLRF   FEC
052F4:  BRA    5372
....................    else if (PID[ch].I < op_lower_bound) PID[ch].I = op_lower_bound;
052F6:  MOVLB  6
052F8:  MOVF   x68,W
052FA:  MULLW  20
052FC:  MOVF   FF3,W
052FE:  CLRF   x76
05300:  MOVWF  x75
05302:  MOVLW  1C
05304:  ADDWF  x75,W
05306:  MOVWF  01
05308:  MOVLW  00
0530A:  ADDWFC x76,W
0530C:  MOVWF  03
0530E:  MOVF   01,W
05310:  ADDLW  20
05312:  MOVWF  FE9
05314:  MOVLW  00
05316:  ADDWFC 03,W
05318:  MOVWF  FEA
0531A:  MOVFF  FEF,6AF
0531E:  MOVFF  FEC,676
05322:  MOVFF  FEC,6B1
05326:  MOVFF  FEC,6B2
0532A:  MOVFF  676,6B0
0532E:  CLRF   xB6
05330:  CLRF   xB5
05332:  MOVLW  FC
05334:  MOVWF  xB4
05336:  MOVLW  84
05338:  MOVWF  xB3
0533A:  MOVLB  0
0533C:  CALL   27C4
05340:  BNC   5374
05342:  MOVLB  6
05344:  MOVF   x68,W
05346:  MULLW  20
05348:  MOVF   FF3,W
0534A:  CLRF   x76
0534C:  MOVWF  x75
0534E:  MOVLW  1C
05350:  ADDWF  x75,W
05352:  MOVWF  01
05354:  MOVLW  00
05356:  ADDWFC x76,W
05358:  MOVWF  03
0535A:  MOVF   01,W
0535C:  ADDLW  20
0535E:  MOVWF  FE9
05360:  MOVLW  00
05362:  ADDWFC 03,W
05364:  MOVWF  FEA
05366:  MOVLW  84
05368:  MOVWF  FEF
0536A:  MOVLW  FC
0536C:  MOVWF  FEC
0536E:  CLRF   FEC
05370:  CLRF   FEC
05372:  MOVLB  0
....................    
....................    float P = err * PID[ch].kP;  // proportional value
....................    
....................    float D = PID[ch].kD * (PID[ch].PV - PID[ch].PVold);  // derivative value
05374:  MOVLB  6
05376:  MOVF   x68,W
05378:  MULLW  20
0537A:  MOVF   FF3,W
0537C:  CLRF   x76
0537E:  MOVWF  x75
05380:  MOVLW  20
05382:  ADDWF  x75,W
05384:  MOVWF  FE9
05386:  MOVLW  00
05388:  ADDWFC x76,W
0538A:  MOVWF  FEA
0538C:  MOVFF  FEF,6B8
05390:  MOVFF  FEC,01
05394:  MOVFF  FEC,02
05398:  MOVFF  FEC,03
0539C:  MOVFF  66C,6B7
053A0:  MOVFF  66B,6B6
053A4:  MOVFF  66A,6B5
053A8:  MOVFF  669,6B4
053AC:  MOVFF  03,6BB
053B0:  MOVFF  02,6BA
053B4:  MOVFF  01,6B9
053B8:  MOVLB  0
053BA:  CALL   12F8
053BE:  MOVFF  03,670
053C2:  MOVFF  02,66F
053C6:  MOVFF  01,66E
053CA:  MOVFF  00,66D
053CE:  MOVLB  6
053D0:  MOVF   x68,W
053D2:  MULLW  20
053D4:  MOVF   FF3,W
053D6:  CLRF   x78
053D8:  MOVWF  x77
053DA:  MOVLW  08
053DC:  ADDWF  x77,W
053DE:  MOVWF  01
053E0:  MOVLW  00
053E2:  ADDWFC x78,W
053E4:  MOVWF  03
053E6:  MOVF   01,W
053E8:  ADDLW  20
053EA:  MOVWF  FE9
053EC:  MOVLW  00
053EE:  ADDWFC 03,W
053F0:  MOVWF  FEA
053F2:  MOVFF  FEF,677
053F6:  MOVFF  FEC,678
053FA:  MOVFF  FEC,679
053FE:  MOVFF  FEC,67A
05402:  MOVF   x68,W
05404:  MULLW  20
05406:  MOVF   FF3,W
05408:  CLRF   x7C
0540A:  MOVWF  x7B
0540C:  MOVLW  10
0540E:  ADDWF  x7B,W
05410:  MOVWF  01
05412:  MOVLW  00
05414:  ADDWFC x7C,W
05416:  MOVWF  03
05418:  MOVF   01,W
0541A:  ADDLW  20
0541C:  MOVWF  FE9
0541E:  MOVLW  00
05420:  ADDWFC 03,W
05422:  MOVWF  FEA
05424:  MOVFF  FEF,6B3
05428:  MOVFF  FEC,6B4
0542C:  MOVFF  FEC,6B5
05430:  MOVFF  FEC,6B6
05434:  MOVF   x68,W
05436:  MULLW  20
05438:  MOVF   FF3,W
0543A:  CLRF   x80
0543C:  MOVWF  x7F
0543E:  MOVLW  14
05440:  ADDWF  x7F,W
05442:  MOVWF  01
05444:  MOVLW  00
05446:  ADDWFC x80,W
05448:  MOVWF  03
0544A:  MOVF   01,W
0544C:  ADDLW  20
0544E:  MOVWF  FE9
05450:  MOVLW  00
05452:  ADDWFC 03,W
05454:  MOVWF  FEA
05456:  MOVFF  FEF,6B7
0545A:  MOVFF  FEC,01
0545E:  MOVFF  FEC,02
05462:  MOVFF  FEC,03
05466:  MOVFF  FEA,680
0546A:  MOVFF  FE9,67F
0546E:  BSF    FD8.1
05470:  MOVFF  03,6BA
05474:  MOVFF  02,6B9
05478:  MOVFF  01,6B8
0547C:  MOVLB  0
0547E:  CALL   13EE
05482:  MOVFF  680,FEA
05486:  MOVFF  67F,FE9
0548A:  MOVFF  67A,6B7
0548E:  MOVFF  679,6B6
05492:  MOVFF  678,6B5
05496:  MOVFF  677,6B4
0549A:  MOVFF  03,6BB
0549E:  MOVFF  02,6BA
054A2:  MOVFF  01,6B9
054A6:  MOVFF  00,6B8
054AA:  CALL   12F8
054AE:  MOVFF  03,674
054B2:  MOVFF  02,673
054B6:  MOVFF  01,672
054BA:  MOVFF  00,671
....................    
....................    PID[ch].CV = P + PID[ch].I + D;  // new control variable
054BE:  MOVLB  6
054C0:  MOVF   x68,W
054C2:  MULLW  20
054C4:  MOVF   FF3,W
054C6:  CLRF   x76
054C8:  MOVWF  x75
054CA:  MOVLW  18
054CC:  ADDWF  x75,W
054CE:  MOVWF  01
054D0:  MOVLW  00
054D2:  ADDWFC x76,W
054D4:  MOVWF  03
054D6:  MOVF   01,W
054D8:  ADDLW  20
054DA:  MOVWF  01
054DC:  MOVLW  00
054DE:  ADDWFC 03,F
054E0:  MOVFF  01,675
054E4:  MOVFF  03,676
054E8:  MOVF   x68,W
054EA:  MULLW  20
054EC:  MOVF   FF3,W
054EE:  CLRF   x78
054F0:  MOVWF  x77
054F2:  MOVLW  1C
054F4:  ADDWF  x77,W
054F6:  MOVWF  01
054F8:  MOVLW  00
054FA:  ADDWFC x78,W
054FC:  MOVWF  03
054FE:  MOVF   01,W
05500:  ADDLW  20
05502:  MOVWF  FE9
05504:  MOVLW  00
05506:  ADDWFC 03,W
05508:  MOVWF  FEA
0550A:  MOVFF  FEF,6B7
0550E:  MOVFF  FEC,01
05512:  MOVFF  FEC,02
05516:  MOVFF  FEC,03
0551A:  MOVFF  FEA,678
0551E:  MOVFF  FE9,677
05522:  BCF    FD8.1
05524:  MOVFF  670,6B6
05528:  MOVFF  66F,6B5
0552C:  MOVFF  66E,6B4
05530:  MOVFF  66D,6B3
05534:  MOVFF  03,6BA
05538:  MOVFF  02,6B9
0553C:  MOVFF  01,6B8
05540:  MOVLB  0
05542:  CALL   13EE
05546:  MOVFF  678,FEA
0554A:  MOVFF  677,FE9
0554E:  MOVFF  03,67C
05552:  MOVFF  02,67B
05556:  MOVFF  01,67A
0555A:  MOVFF  00,679
0555E:  BCF    FD8.1
05560:  MOVFF  03,6B6
05564:  MOVFF  02,6B5
05568:  MOVFF  01,6B4
0556C:  MOVFF  00,6B3
05570:  MOVFF  674,6BA
05574:  MOVFF  673,6B9
05578:  MOVFF  672,6B8
0557C:  MOVFF  671,6B7
05580:  CALL   13EE
05584:  MOVFF  676,FEA
05588:  MOVFF  675,FE9
0558C:  MOVFF  00,FEF
05590:  MOVFF  01,FEC
05594:  MOVFF  02,FEC
05598:  MOVFF  03,FEC
....................    if (PID[ch].CV > op_upper_bound) PID[ch].CV = op_upper_bound; // limit positive output
0559C:  MOVLB  6
0559E:  MOVF   x68,W
055A0:  MULLW  20
055A2:  MOVF   FF3,W
055A4:  CLRF   x76
055A6:  MOVWF  x75
055A8:  MOVLW  18
055AA:  ADDWF  x75,W
055AC:  MOVWF  01
055AE:  MOVLW  00
055B0:  ADDWFC x76,W
055B2:  MOVWF  03
055B4:  MOVF   01,W
055B6:  ADDLW  20
055B8:  MOVWF  FE9
055BA:  MOVLW  00
055BC:  ADDWFC 03,W
055BE:  MOVWF  FEA
055C0:  MOVFF  FEF,6B3
055C4:  MOVFF  FEC,676
055C8:  MOVFF  FEC,6B5
055CC:  MOVFF  FEC,6B6
055D0:  CLRF   xB2
055D2:  CLRF   xB1
055D4:  MOVLW  7C
055D6:  MOVWF  xB0
055D8:  MOVLW  84
055DA:  MOVWF  xAF
055DC:  MOVFF  676,6B4
055E0:  MOVLB  0
055E2:  CALL   27C4
055E6:  BNC   561A
055E8:  MOVLB  6
055EA:  MOVF   x68,W
055EC:  MULLW  20
055EE:  MOVF   FF3,W
055F0:  CLRF   x76
055F2:  MOVWF  x75
055F4:  MOVLW  18
055F6:  ADDWF  x75,W
055F8:  MOVWF  01
055FA:  MOVLW  00
055FC:  ADDWFC x76,W
055FE:  MOVWF  03
05600:  MOVF   01,W
05602:  ADDLW  20
05604:  MOVWF  FE9
05606:  MOVLW  00
05608:  ADDWFC 03,W
0560A:  MOVWF  FEA
0560C:  MOVLW  84
0560E:  MOVWF  FEF
05610:  MOVLW  7C
05612:  MOVWF  FEC
05614:  CLRF   FEC
05616:  CLRF   FEC
05618:  BRA    5696
....................    else if (PID[ch].CV < op_lower_bound) PID[ch].CV = op_lower_bound; // limit negative output
0561A:  MOVLB  6
0561C:  MOVF   x68,W
0561E:  MULLW  20
05620:  MOVF   FF3,W
05622:  CLRF   x76
05624:  MOVWF  x75
05626:  MOVLW  18
05628:  ADDWF  x75,W
0562A:  MOVWF  01
0562C:  MOVLW  00
0562E:  ADDWFC x76,W
05630:  MOVWF  03
05632:  MOVF   01,W
05634:  ADDLW  20
05636:  MOVWF  FE9
05638:  MOVLW  00
0563A:  ADDWFC 03,W
0563C:  MOVWF  FEA
0563E:  MOVFF  FEF,6AF
05642:  MOVFF  FEC,676
05646:  MOVFF  FEC,6B1
0564A:  MOVFF  FEC,6B2
0564E:  MOVFF  676,6B0
05652:  CLRF   xB6
05654:  CLRF   xB5
05656:  MOVLW  FC
05658:  MOVWF  xB4
0565A:  MOVLW  84
0565C:  MOVWF  xB3
0565E:  MOVLB  0
05660:  CALL   27C4
05664:  BNC   5696
05666:  MOVLB  6
05668:  MOVF   x68,W
0566A:  MULLW  20
0566C:  MOVF   FF3,W
0566E:  CLRF   x76
05670:  MOVWF  x75
05672:  MOVLW  18
05674:  ADDWF  x75,W
05676:  MOVWF  01
05678:  MOVLW  00
0567A:  ADDWFC x76,W
0567C:  MOVWF  03
0567E:  MOVF   01,W
05680:  ADDLW  20
05682:  MOVWF  FE9
05684:  MOVLW  00
05686:  ADDWFC 03,W
05688:  MOVWF  FEA
0568A:  MOVLW  84
0568C:  MOVWF  FEF
0568E:  MOVLW  FC
05690:  MOVWF  FEC
05692:  CLRF   FEC
05694:  CLRF   FEC
05696:  MOVLB  0
05698:  GOTO   5710 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PID Task - looks for change to PV and updates CV                          */
.................... /*****************************************************************************/
.................... void pid_task(channelMap ch){
....................    static int index = 0;
....................    if (PID[ch].SP != PID[ch].PV) pid_update(ch);
0569C:  MOVLB  6
0569E:  MOVF   x67,W
056A0:  MULLW  20
056A2:  MOVF   FF3,W
056A4:  CLRF   x69
056A6:  MOVWF  x68
056A8:  MOVLW  0C
056AA:  ADDWF  x68,W
056AC:  MOVWF  01
056AE:  MOVLW  00
056B0:  ADDWFC x69,W
056B2:  MOVWF  03
056B4:  MOVF   01,W
056B6:  ADDLW  20
056B8:  MOVWF  FE9
056BA:  MOVLW  00
056BC:  ADDWFC 03,W
056BE:  MOVWF  FEA
056C0:  MOVFF  FEF,6AF
056C4:  MOVFF  FEC,6B0
056C8:  MOVFF  FEC,6B1
056CC:  MOVFF  FEC,6B2
056D0:  MOVF   x67,W
056D2:  MULLW  20
056D4:  MOVF   FF3,W
056D6:  CLRF   x6D
056D8:  MOVWF  x6C
056DA:  MOVLW  10
056DC:  ADDWF  x6C,W
056DE:  MOVWF  01
056E0:  MOVLW  00
056E2:  ADDWFC x6D,W
056E4:  MOVWF  03
056E6:  MOVF   01,W
056E8:  ADDLW  20
056EA:  MOVWF  FE9
056EC:  MOVLW  00
056EE:  ADDWFC 03,W
056F0:  MOVWF  FEA
056F2:  MOVFF  FEF,6B3
056F6:  MOVFF  FEC,6B4
056FA:  MOVFF  FEC,6B5
056FE:  MOVFF  FEC,6B6
05702:  MOVLB  0
05704:  CALL   27C4
05708:  BZ    5710
0570A:  MOVFF  667,668
0570E:  BRA    510A
....................    if ((index++) >= numChannels) index = 0;
05710:  MOVLB  1
05712:  MOVF   xDA,W
05714:  INCF   xDA,F
05716:  SUBLW  01
05718:  BC    571C
0571A:  CLRF   xDA
0571C:  MOVLB  0
0571E:  GOTO   580A (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... #pin_select SCK1=PIN_C3
.................... #pin_select SDO1=PIN_C2
.................... #use spi (MASTER, SPI1, BAUD=100000, MODE=2, STREAM=SPI_ctrl)
*
0108E:  CLRF   03
01090:  MOVF   F91,W
01092:  MOVFF  669,F91
01096:  RRCF   F94,W
01098:  BNC   1096
0109A:  MOVF   F91,W
0109C:  MOVWF  02
0109E:  MOVFF  668,F91
010A2:  RRCF   F94,W
010A4:  BNC   10A2
010A6:  MOVF   F91,W
010A8:  MOVWF  01
010AA:  MOVFF  667,F91
010AE:  RRCF   F94,W
010B0:  BNC   10AE
010B2:  MOVFF  F91,00
010B6:  RETURN 0
.................... 
.................... #define DACfullScale 655.35 // full scale/100 because CV = %
.................... 
.................... /*****************************************************************************/
.................... /*  Inverts the output voltage ( -180V - 0V )                                */ 
.................... /*****************************************************************************/
.................... void invert_voltage(channelMap ch, BOOLEAN inv_v){
....................    if ( inv_v ) {
*
05066:  MOVLB  6
05068:  MOVF   x68,F
0506A:  BZ    50BA
....................       if (chMap[0] == ch) output_low(INV_HVX);
0506C:  MOVLW  00
0506E:  MOVLB  0
05070:  BTFSC  x60.0
05072:  MOVLW  01
05074:  MOVLB  6
05076:  SUBWF  x67,W
05078:  BNZ   5080
0507A:  MOVLW  C4
0507C:  MOVWF  F88
0507E:  BCF    F83.4
....................       if (chMap[1] == ch) output_low(INV_HVY);
05080:  MOVLW  00
05082:  MOVLB  0
05084:  BTFSC  x60.1
05086:  MOVLW  01
05088:  MOVLB  6
0508A:  SUBWF  x67,W
0508C:  BNZ   5094
0508E:  MOVLW  C4
05090:  MOVWF  F88
05092:  BCF    F83.5
....................       dacVals[ch].invV = TRUE;
05094:  MOVF   x67,W
05096:  MULLW  03
05098:  MOVF   FF3,W
0509A:  CLRF   x6A
0509C:  MOVWF  x69
0509E:  MOVLW  02
050A0:  ADDWF  x69,W
050A2:  MOVWF  01
050A4:  MOVLW  00
050A6:  ADDWFC x6A,W
050A8:  MOVWF  03
050AA:  MOVF   01,W
050AC:  ADDLW  51
050AE:  MOVWF  FE9
050B0:  MOVLW  01
050B2:  ADDWFC 03,W
050B4:  MOVWF  FEA
050B6:  BSF    FEF.0
....................    }
050B8:  BRA    5106
....................    else {
....................       if (chMap[0] == ch) output_high(INV_HVX);
050BA:  MOVLW  00
050BC:  MOVLB  0
050BE:  BTFSC  x60.0
050C0:  MOVLW  01
050C2:  MOVLB  6
050C4:  SUBWF  x67,W
050C6:  BNZ   50CE
050C8:  MOVLW  C4
050CA:  MOVWF  F88
050CC:  BSF    F83.4
....................       if (chMap[1] == ch) output_high(INV_HVY);
050CE:  MOVLW  00
050D0:  MOVLB  0
050D2:  BTFSC  x60.1
050D4:  MOVLW  01
050D6:  MOVLB  6
050D8:  SUBWF  x67,W
050DA:  BNZ   50E2
050DC:  MOVLW  C4
050DE:  MOVWF  F88
050E0:  BSF    F83.5
....................       dacVals[ch].invV = FALSE;
050E2:  MOVF   x67,W
050E4:  MULLW  03
050E6:  MOVF   FF3,W
050E8:  CLRF   x6A
050EA:  MOVWF  x69
050EC:  MOVLW  02
050EE:  ADDWF  x69,W
050F0:  MOVWF  01
050F2:  MOVLW  00
050F4:  ADDWFC x6A,W
050F6:  MOVWF  03
050F8:  MOVF   01,W
050FA:  ADDLW  51
050FC:  MOVWF  FE9
050FE:  MOVLW  01
05100:  ADDWFC 03,W
05102:  MOVWF  FEA
05104:  BCF    FEF.0
....................    }
05106:  MOVLB  0
05108:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  Nano DAC's have a 16bit serial shift register. Data is sync'ed to output */ 
.................... /*****************************************************************************/
.................... void set_nanoDAC_outputs(channelMap ch){
*
05722:  MOVLB  6
05724:  CLRF   x66
05726:  CLRF   x65
....................    unsigned int16 txData = 0;
....................    
....................    // use manualOutputValues if channel is manual mode
....................    // else, use PID control variable
....................    if (chMode[ch] == MANUAL){
05728:  MOVFF  664,671
0572C:  CLRF   x73
0572E:  MOVLW  61
05730:  MOVWF  x72
05732:  MOVLB  0
05734:  RCALL  5030
05736:  MOVF   01,F
05738:  BNZ   5804
....................       if ( manualOutputValues[ch] < 0) invert_voltage(ch, TRUE); 
0573A:  MOVLB  6
0573C:  MOVF   x64,W
0573E:  MULLW  04
05740:  MOVF   FF3,W
05742:  CLRF   03
05744:  ADDLW  EA
05746:  MOVWF  FE9
05748:  MOVLW  00
0574A:  ADDWFC 03,W
0574C:  MOVWF  FEA
0574E:  MOVFF  FEF,6AF
05752:  MOVFF  FEC,6B0
05756:  MOVFF  FEC,6B1
0575A:  MOVFF  FEC,6B2
0575E:  CLRF   xB6
05760:  CLRF   xB5
05762:  CLRF   xB4
05764:  CLRF   xB3
05766:  MOVLB  0
05768:  CALL   27C4
0576C:  BNC   577E
0576E:  MOVFF  664,667
05772:  MOVLW  01
05774:  MOVLB  6
05776:  MOVWF  x68
05778:  MOVLB  0
0577A:  RCALL  5066
0577C:  BRA    578A
....................       else                             invert_voltage(ch, FALSE);
0577E:  MOVFF  664,667
05782:  MOVLB  6
05784:  CLRF   x68
05786:  MOVLB  0
05788:  RCALL  5066
....................       
....................       txData = (unsigned int16)(abs(manualOutputValues[ch]) * DACfullScale);
0578A:  MOVLB  6
0578C:  MOVF   x64,W
0578E:  MULLW  04
05790:  MOVF   FF3,W
05792:  CLRF   03
05794:  ADDLW  EA
05796:  MOVWF  FE9
05798:  MOVLW  00
0579A:  ADDWFC 03,W
0579C:  MOVWF  FEA
0579E:  MOVFF  FEF,00
057A2:  MOVFF  FEC,01
057A6:  MOVFF  FEC,02
057AA:  MOVFF  FEC,03
057AE:  BCF    01.7
057B0:  MOVFF  03,66A
057B4:  MOVFF  02,669
057B8:  MOVFF  01,668
057BC:  MOVFF  00,667
057C0:  MOVFF  03,6B7
057C4:  MOVFF  02,6B6
057C8:  MOVFF  01,6B5
057CC:  MOVFF  00,6B4
057D0:  MOVLW  66
057D2:  MOVWF  xBB
057D4:  MOVLW  D6
057D6:  MOVWF  xBA
057D8:  MOVLW  23
057DA:  MOVWF  xB9
057DC:  MOVLW  88
057DE:  MOVWF  xB8
057E0:  MOVLB  0
057E2:  CALL   12F8
057E6:  MOVFF  03,6B2
057EA:  MOVFF  02,6B1
057EE:  MOVFF  01,6B0
057F2:  MOVFF  00,6AF
057F6:  CALL   31B8
057FA:  MOVFF  02,666
057FE:  MOVFF  01,665
....................    }
05802:  BRA    58F4
....................    else {
....................       pid_task(ch);
05804:  MOVFF  664,667
05808:  BRA    569C
....................       if ( PID[(int)ch].CV < 0 ) invert_voltage(ch, TRUE); 
0580A:  MOVLB  6
0580C:  MOVF   x64,W
0580E:  MULLW  20
05810:  MOVF   FF3,W
05812:  CLRF   x68
05814:  MOVWF  x67
05816:  MOVLW  18
05818:  ADDWF  x67,W
0581A:  MOVWF  01
0581C:  MOVLW  00
0581E:  ADDWFC x68,W
05820:  MOVWF  03
05822:  MOVF   01,W
05824:  ADDLW  20
05826:  MOVWF  FE9
05828:  MOVLW  00
0582A:  ADDWFC 03,W
0582C:  MOVWF  FEA
0582E:  MOVFF  FEF,6AF
05832:  MOVFF  FEC,6B0
05836:  MOVFF  FEC,6B1
0583A:  MOVFF  FEC,6B2
0583E:  CLRF   xB6
05840:  CLRF   xB5
05842:  CLRF   xB4
05844:  CLRF   xB3
05846:  MOVLB  0
05848:  CALL   27C4
0584C:  BNC   585E
0584E:  MOVFF  664,667
05852:  MOVLW  01
05854:  MOVLB  6
05856:  MOVWF  x68
05858:  MOVLB  0
0585A:  RCALL  5066
0585C:  BRA    586C
....................       else                       invert_voltage(ch, FALSE);
0585E:  MOVFF  664,667
05862:  MOVLB  6
05864:  CLRF   x68
05866:  MOVLB  0
05868:  CALL   5066
....................       
....................       txData = (unsigned int16)(abs(PID[(int)ch].CV) * DACfullScale);
0586C:  MOVLB  6
0586E:  MOVF   x64,W
05870:  MULLW  20
05872:  MOVF   FF3,W
05874:  CLRF   x68
05876:  MOVWF  x67
05878:  MOVLW  18
0587A:  ADDWF  x67,W
0587C:  MOVWF  01
0587E:  MOVLW  00
05880:  ADDWFC x68,W
05882:  MOVWF  03
05884:  MOVF   01,W
05886:  ADDLW  20
05888:  MOVWF  FE9
0588A:  MOVLW  00
0588C:  ADDWFC 03,W
0588E:  MOVWF  FEA
05890:  MOVFF  FEF,00
05894:  MOVFF  FEC,01
05898:  MOVFF  FEC,02
0589C:  MOVFF  FEC,03
058A0:  BCF    01.7
058A2:  MOVFF  03,66A
058A6:  MOVFF  02,669
058AA:  MOVFF  01,668
058AE:  MOVFF  00,667
058B2:  MOVFF  03,6B7
058B6:  MOVFF  02,6B6
058BA:  MOVFF  01,6B5
058BE:  MOVFF  00,6B4
058C2:  MOVLW  66
058C4:  MOVWF  xBB
058C6:  MOVLW  D6
058C8:  MOVWF  xBA
058CA:  MOVLW  23
058CC:  MOVWF  xB9
058CE:  MOVLW  88
058D0:  MOVWF  xB8
058D2:  MOVLB  0
058D4:  CALL   12F8
058D8:  MOVFF  03,6B2
058DC:  MOVFF  02,6B1
058E0:  MOVFF  01,6B0
058E4:  MOVFF  00,6AF
058E8:  CALL   31B8
058EC:  MOVFF  02,666
058F0:  MOVFF  01,665
....................    }
....................    
....................    dacVals[ch].val = txData;
058F4:  MOVLB  6
058F6:  MOVF   x64,W
058F8:  MULLW  03
058FA:  MOVF   FF3,W
058FC:  CLRF   x68
058FE:  MOVWF  x67
05900:  MOVLW  51
05902:  ADDWF  x67,W
05904:  MOVWF  FE9
05906:  MOVLW  01
05908:  ADDWFC x68,W
0590A:  MOVWF  FEA
0590C:  MOVFF  666,FEC
05910:  MOVF   FED,F
05912:  MOVFF  665,FEF
....................    
....................    // use channel map to decide which outputs channels to update
....................    // strobe _sync low to push data to the outputs
....................    if (chMap[0] == ch) output_high(_SYNC_X);
05916:  MOVLW  00
05918:  MOVLB  0
0591A:  BTFSC  x60.0
0591C:  MOVLW  01
0591E:  MOVLB  6
05920:  SUBWF  x64,W
05922:  BNZ   592A
05924:  MOVLW  E8
05926:  MOVWF  F8B
05928:  BSF    F86.2
....................    if (chMap[1] == ch) output_high(_SYNC_Y);
0592A:  MOVLW  00
0592C:  MOVLB  0
0592E:  BTFSC  x60.1
05930:  MOVLW  01
05932:  MOVLB  6
05934:  SUBWF  x64,W
05936:  BNZ   593E
05938:  MOVLW  E8
0593A:  MOVWF  F8B
0593C:  BSF    F86.1
....................    
....................    delay_ms(1);
0593E:  MOVLW  01
05940:  MOVWF  x6C
05942:  MOVLB  0
05944:  CALL   0426
....................    
....................    if (chMap[0] == ch) output_low(_SYNC_X);
05948:  MOVLW  00
0594A:  BTFSC  x60.0
0594C:  MOVLW  01
0594E:  MOVLB  6
05950:  SUBWF  x64,W
05952:  BNZ   595A
05954:  MOVLW  E8
05956:  MOVWF  F8B
05958:  BCF    F86.2
....................    if (chMap[1] == ch) output_low(_SYNC_Y);
0595A:  MOVLW  00
0595C:  MOVLB  0
0595E:  BTFSC  x60.1
05960:  MOVLW  01
05962:  MOVLB  6
05964:  SUBWF  x64,W
05966:  BNZ   596E
05968:  MOVLW  E8
0596A:  MOVWF  F8B
0596C:  BCF    F86.1
....................    delay_ms(1);
0596E:  MOVLW  01
05970:  MOVWF  x6C
05972:  MOVLB  0
05974:  CALL   0426
....................    
....................    // shift 16 bits of data
....................    spi_xfer(SPI_ctrl, txData, 24);
05978:  MOVLB  6
0597A:  CLRF   x6A
0597C:  CLRF   x69
0597E:  MOVFF  666,668
05982:  MOVFF  665,667
05986:  MOVLB  0
05988:  CALL   108E
....................    delay_ms(1);
0598C:  MOVLW  01
0598E:  MOVLB  6
05990:  MOVWF  x6C
05992:  MOVLB  0
05994:  CALL   0426
....................    
....................    if (chMap[0] == ch) output_high(_SYNC_X);
05998:  MOVLW  00
0599A:  BTFSC  x60.0
0599C:  MOVLW  01
0599E:  MOVLB  6
059A0:  SUBWF  x64,W
059A2:  BNZ   59AA
059A4:  MOVLW  E8
059A6:  MOVWF  F8B
059A8:  BSF    F86.2
....................    if (chMap[1] == ch) output_high(_SYNC_Y);
059AA:  MOVLW  00
059AC:  MOVLB  0
059AE:  BTFSC  x60.1
059B0:  MOVLW  01
059B2:  MOVLB  6
059B4:  SUBWF  x64,W
059B6:  BNZ   59BE
059B8:  MOVLW  E8
059BA:  MOVWF  F8B
059BC:  BSF    F86.1
059BE:  MOVLB  0
059C0:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  control task sets up the outputs channels                                */ 
.................... /*****************************************************************************/
.................... void control_task(){
....................    static int state = 0;
....................    
....................    switch (state)
059C2:  MOVLB  1
059C4:  MOVF   xDB,W
059C6:  XORLW  00
059C8:  MOVLB  0
059CA:  BZ    59D2
059CC:  XORLW  01
059CE:  BZ    59E4
059D0:  BRA    59F4
....................    {
....................       case 0:
....................          set_nanoDAC_outputs(chX);
059D2:  MOVLB  6
059D4:  CLRF   x64
059D6:  MOVLB  0
059D8:  RCALL  5722
....................          state = 1;
059DA:  MOVLW  01
059DC:  MOVLB  1
059DE:  MOVWF  xDB
....................       break;
059E0:  MOVLB  0
059E2:  BRA    59F4
....................       case 1:
....................          set_nanoDAC_outputs(chY);
059E4:  MOVLW  01
059E6:  MOVLB  6
059E8:  MOVWF  x64
059EA:  MOVLB  0
059EC:  RCALL  5722
....................          state = 0;
059EE:  MOVLB  1
059F0:  CLRF   xDB
....................       break;
059F2:  MOVLB  0
....................    }
059F4:  GOTO   AFD0 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  control task sets up the outputs channels                                */ 
.................... /*****************************************************************************/
.................... void control_init(){
....................    spi_xfer(SPI_ctrl, 0, 24);
*
010B8:  MOVLB  6
010BA:  CLRF   x6A
010BC:  CLRF   x69
010BE:  CLRF   x68
010C0:  CLRF   x67
010C2:  MOVLB  0
010C4:  RCALL  108E
....................    output_low(_SYNC_X);
010C6:  MOVLW  E8
010C8:  MOVWF  F8B
010CA:  BCF    F86.2
....................    output_low(_SYNC_Y);
010CC:  MOVWF  F8B
010CE:  BCF    F86.1
....................    output_high(_SYNC_X);
010D0:  MOVWF  F8B
010D2:  BSF    F86.2
....................    output_high(_SYNC_Y);
010D4:  MOVWF  F8B
010D6:  BSF    F86.1
010D8:  GOTO   AFB8 (RETURN)
.................... }
.................... #endif
.................... 
.................... #include <serialport.h>
.................... #ifndef serialPort
.................... #define serialPort
.................... #include <cmdBuffer.h>
.................... #ifndef cmd_buffer
.................... #define cmd_buffer
.................... 
.................... /*****************************************************************************/
.................... /* DIFCS COMMAND BUFFER                                                      */
.................... /* The beginning of a message is signified by an address record. The address */
.................... /* is 4 characters. The first 2 are the hardware identifier (TC - temperature*/
.................... /* controller, DC - difics controller, etc..) The second 2 characters dev-   */
.................... /* ice ID... Valid values are 00 thru 0F. A device ID of FF writes to all    */
.................... /* boards. This might be used to feed angles data to all listeners.          */
.................... /*****************************************************************************/
.................... 
.................... // t,p0,p1,p2,p3,p4,p5,p6
.................... // t is the start character, p0 is the address, p1 is command, p2-6 are params
.................... // these characters used for storing messages
.................... 
.................... #define startChr '~' // start character. Also diagnostic command type
.................... #define diagCmdType startChr
.................... #define endChr '\n'
.................... #define delimiter ','
.................... #define ignoreChr1 '\r'
.................... #define ignoreChr2 ' '
.................... #define noRecordFound (char)0xFF
.................... 
.................... #define numRecords 4
.................... #define numParam 7
.................... #define lenParam 25
.................... 
.................... #define useSerial
.................... //#define useTCPIP
.................... 
.................... typedef enum cmdMode {tcp, ser};
.................... 
.................... // this structure holds a command. This is used by the serial routine as well
.................... // as the TCP routine to store an incoming command + parameters
.................... // in the case of TCP socket id is also passed in this structure
.................... typedef struct cmd 
.................... {
....................    BOOLEAN full;        // if full, command is ready to execute
....................    unsigned int8 chrIndex;
....................    unsigned int8 paramIndex;
....................    unsigned int8 recReadIndex;
....................    unsigned int8 recWriteIndex;
....................    #ifdef useTCPIP
....................    TCP_SOCKET s;              // socket ID for TCP commands 
....................    #endif
....................    char t;
....................    char p[numParam][lenParam];   // only used with ~ type command
.................... };
.................... 
.................... #ifdef useSerial
.................... struct cmd SERcmd[numRecords]; // holds serial command 
.................... unsigned int8 SRI = 0; //usb readindex
.................... unsigned int8 SWI = 0; //usb write index
.................... #endif
.................... 
.................... #ifdef useTCPIP
.................... struct cmd TCPcmd[numRecords]; // holds TCP command
.................... unsigned int8 TRI = 0; //usb readindex
.................... unsigned int8 TWI = 0; //usb write index
.................... #endif
.................... 
.................... char retData[100]; // this is used to hold return data 
.................... 
.................... #ifdef useSerial
.................... /*****************************************************************************/
.................... /* RESET SER COMMAND -- ready for a new command                              */
.................... /*****************************************************************************/
.................... void resetSERcmd(unsigned int8 recNum)
.................... {
....................    if (recNum < numRecords)
010DC:  MOVLB  6
010DE:  MOVF   x65,W
010E0:  SUBLW  03
010E2:  BTFSS  FD8.0
010E4:  BRA    1262
....................    {
....................       for (int i = 0; i <numParam; i ++)
010E6:  CLRF   x66
010E8:  MOVF   x66,W
010EA:  SUBLW  06
010EC:  BNC   1140
....................       {
....................          SERcmd[recNum].p[i][0] = '\0';
010EE:  CLRF   xB1
010F0:  MOVFF  665,6B0
010F4:  CLRF   xB3
010F6:  MOVLW  B5
010F8:  MOVWF  xB2
010FA:  MOVLB  0
010FC:  CALL   07F0
01100:  MOVFF  02,668
01104:  MOVFF  01,667
01108:  MOVLW  06
0110A:  MOVLB  6
0110C:  ADDWF  x67,F
0110E:  MOVLW  00
01110:  ADDWFC x68,F
01112:  CLRF   xB1
01114:  MOVFF  666,6B0
01118:  CLRF   xB3
0111A:  MOVLW  19
0111C:  MOVWF  xB2
0111E:  MOVLB  0
01120:  CALL   07F0
01124:  MOVF   01,W
01126:  MOVLB  6
01128:  ADDWF  x67,F
0112A:  MOVF   02,W
0112C:  ADDWFC x68,F
0112E:  MOVLW  DC
01130:  ADDWF  x67,W
01132:  MOVWF  FE9
01134:  MOVLW  01
01136:  ADDWFC x68,W
01138:  MOVWF  FEA
0113A:  CLRF   FEF
0113C:  INCF   x66,F
0113E:  BRA    10E8
....................       }
....................       SERcmd[recNum].t = 0;
01140:  CLRF   xB1
01142:  MOVFF  665,6B0
01146:  CLRF   xB3
01148:  MOVLW  B5
0114A:  MOVWF  xB2
0114C:  MOVLB  0
0114E:  CALL   07F0
01152:  MOVFF  01,667
01156:  MOVLW  05
01158:  MOVLB  6
0115A:  ADDWF  01,W
0115C:  MOVWF  01
0115E:  MOVLW  00
01160:  ADDWFC 02,W
01162:  MOVWF  03
01164:  MOVF   01,W
01166:  ADDLW  DC
01168:  MOVWF  FE9
0116A:  MOVLW  01
0116C:  ADDWFC 03,W
0116E:  MOVWF  FEA
01170:  CLRF   FEF
....................       SERcmd[recNum].chrIndex = 0;
01172:  CLRF   xB1
01174:  MOVFF  665,6B0
01178:  CLRF   xB3
0117A:  MOVLW  B5
0117C:  MOVWF  xB2
0117E:  MOVLB  0
01180:  CALL   07F0
01184:  MOVFF  01,667
01188:  MOVLW  01
0118A:  MOVLB  6
0118C:  ADDWF  01,W
0118E:  MOVWF  01
01190:  MOVLW  00
01192:  ADDWFC 02,W
01194:  MOVWF  03
01196:  MOVF   01,W
01198:  ADDLW  DC
0119A:  MOVWF  FE9
0119C:  MOVLW  01
0119E:  ADDWFC 03,W
011A0:  MOVWF  FEA
011A2:  CLRF   FEF
....................       SERcmd[recNum].paramIndex = 0;
011A4:  CLRF   xB1
011A6:  MOVFF  665,6B0
011AA:  CLRF   xB3
011AC:  MOVLW  B5
011AE:  MOVWF  xB2
011B0:  MOVLB  0
011B2:  CALL   07F0
011B6:  MOVFF  01,667
011BA:  MOVLW  02
011BC:  MOVLB  6
011BE:  ADDWF  01,W
011C0:  MOVWF  01
011C2:  MOVLW  00
011C4:  ADDWFC 02,W
011C6:  MOVWF  03
011C8:  MOVF   01,W
011CA:  ADDLW  DC
011CC:  MOVWF  FE9
011CE:  MOVLW  01
011D0:  ADDWFC 03,W
011D2:  MOVWF  FEA
011D4:  CLRF   FEF
....................       SERcmd[recNum].recReadIndex = 0;
011D6:  CLRF   xB1
011D8:  MOVFF  665,6B0
011DC:  CLRF   xB3
011DE:  MOVLW  B5
011E0:  MOVWF  xB2
011E2:  MOVLB  0
011E4:  CALL   07F0
011E8:  MOVFF  01,667
011EC:  MOVLW  03
011EE:  MOVLB  6
011F0:  ADDWF  01,W
011F2:  MOVWF  01
011F4:  MOVLW  00
011F6:  ADDWFC 02,W
011F8:  MOVWF  03
011FA:  MOVF   01,W
011FC:  ADDLW  DC
011FE:  MOVWF  FE9
01200:  MOVLW  01
01202:  ADDWFC 03,W
01204:  MOVWF  FEA
01206:  CLRF   FEF
....................       SERcmd[recNum].recWriteIndex = 0;
01208:  CLRF   xB1
0120A:  MOVFF  665,6B0
0120E:  CLRF   xB3
01210:  MOVLW  B5
01212:  MOVWF  xB2
01214:  MOVLB  0
01216:  CALL   07F0
0121A:  MOVFF  01,667
0121E:  MOVLW  04
01220:  MOVLB  6
01222:  ADDWF  01,W
01224:  MOVWF  01
01226:  MOVLW  00
01228:  ADDWFC 02,W
0122A:  MOVWF  03
0122C:  MOVF   01,W
0122E:  ADDLW  DC
01230:  MOVWF  FE9
01232:  MOVLW  01
01234:  ADDWFC 03,W
01236:  MOVWF  FEA
01238:  CLRF   FEF
....................       SERcmd[recNum].full = FALSE;
0123A:  CLRF   xB1
0123C:  MOVFF  665,6B0
01240:  CLRF   xB3
01242:  MOVLW  B5
01244:  MOVWF  xB2
01246:  MOVLB  0
01248:  CALL   07F0
0124C:  MOVLW  DC
0124E:  MOVLB  6
01250:  ADDWF  01,W
01252:  MOVWF  FE9
01254:  MOVLW  01
01256:  ADDWFC 02,W
01258:  MOVWF  FEA
0125A:  BCF    FEF.0
....................       retData[0] = '\0';
0125C:  MOVLB  4
0125E:  CLRF   xB2
01260:  MOVLB  6
....................    }
01262:  MOVLB  0
01264:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next serial read index (SRI)                                          */
.................... /*****************************************************************************/
.................... BOOLEAN getNextSERReadIndex()
.................... {
....................    while (!SERcmd[SRI].full)
*
062FC:  MOVLB  6
062FE:  CLRF   xB1
06300:  MOVFF  4B0,6B0
06304:  CLRF   xB3
06306:  MOVLW  B5
06308:  MOVWF  xB2
0630A:  MOVLB  0
0630C:  CALL   07F0
06310:  MOVFF  02,666
06314:  MOVFF  01,665
06318:  MOVLW  DC
0631A:  MOVLB  6
0631C:  ADDWF  01,W
0631E:  MOVWF  FE9
06320:  MOVLW  01
06322:  ADDWFC 02,W
06324:  MOVWF  FEA
06326:  BTFSC  FEF.0
06328:  BRA    634A
....................    {
....................       if (SRI == SWI) return FALSE;
0632A:  MOVLB  4
0632C:  MOVF   xB1,W
0632E:  SUBWF  xB0,W
06330:  BNZ   6338
06332:  MOVLW  00
06334:  MOVWF  01
06336:  BRA    6350
....................       SRI +=1;
06338:  MOVLW  01
0633A:  ADDWF  xB0,F
....................       if (SRI >= numRecords) SRI=0;
0633C:  MOVF   xB0,W
0633E:  SUBLW  03
06340:  BC    6344
06342:  CLRF   xB0
06344:  MOVLB  0
06346:  BRA    62FC
06348:  MOVLB  6
....................    }
....................    return TRUE;
0634A:  MOVLW  01
0634C:  MOVWF  01
0634E:  MOVLB  4
06350:  MOVLB  0
06352:  GOTO   AB12 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next serial write index (SWI)                                         */
.................... /*****************************************************************************/
.................... void setNextSERWriteIndex()
.................... {
....................    SWI +=1;
*
05A2C:  MOVLW  01
05A2E:  MOVLB  4
05A30:  ADDWF  xB1,F
....................    if (SWI >= numRecords) SWI=0;
05A32:  MOVF   xB1,W
05A34:  SUBLW  03
05A36:  BC    5A3A
05A38:  CLRF   xB1
05A3A:  MOVLB  0
05A3C:  RETURN 0
.................... }
.................... #endif
.................... 
.................... #ifdef useTCPIP
.................... /*****************************************************************************/
.................... /* RESET TCP COMMAND -- ready for a new command                              */
.................... /*****************************************************************************/
.................... void resetTCPcmd(unsigned int8 recNum)
.................... {
....................    if(recNum < numRecords)
....................    {
....................       for (int i = 0; i <numParam; i ++)
....................       {
....................          TCPcmd[recNum].p[i][0] = '\0';
....................       }
....................       TCPcmd[recNum].t = 0;
....................       TCPcmd[recNum].chrIndex = 0;
....................       TCPcmd[recNum].paramIndex = 0;
....................       TCPcmd[recNum].full = FALSE;
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next TCP read index (TRI)                                             */
.................... /*****************************************************************************/
.................... BOOLEAN getNextTCPReadIndex()
.................... {
....................    while (!TCPcmd[TRI].full)
....................    {
....................       if (TRI == TWI) return FALSE;
....................       TRI +=1;
....................       if (TRI >= numRecords) TRI=0;
....................    }
....................    return TRUE;
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next TCP write index (TWI)                                            */
.................... /*****************************************************************************/
.................... void setNextTCPWriteIndex()
.................... {
....................    TWI +=1;
....................    if (TWI >= numRecords) TWI=0;
.................... }
.................... #endif
.................... #endif
.................... 
.................... 
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
....................    output_b(portB_reset);
....................    output_c(portC_reset);
....................    output_d(portD_reset);
....................    output_e(portE_reset);
....................    
....................    port_a_pullups(portA_pullups);
....................    port_b_pullups(portB_pullups);
....................    port_c_pullups(portC_pullups);
....................    port_d_pullups(portD_pullups);
....................    port_e_pullups(portE_pullups);
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... #define use_RS485 // adds RX enable pin//
.................... 
.................... #define oneByteCmdTestValue 128
.................... #define UART_BUFFER_SIZE 60
.................... #define UART_EOT_CHAR1 0x0D //Carriage Return
.................... #define UART_EOT_CHAR2 0x0A //Line Feed
.................... #define UART_SOT_CHAR  '~' // START CHARACTER
.................... #define line_turnaround_char 0xFF
.................... 
.................... #bit UART_TXBuffer_Empty = 0x0FAC.1
.................... 
.................... char UART_BUFFER[UART_BUFFER_SIZE] = {0};
.................... unsigned int8 UART_WR_PTR = 0;
.................... unsigned int8 UART_RD_PTR = 0;
.................... boolean BYTES_AVAILABLE= FALSE;
.................... 
.................... #ifdef use_RS485
.................... #use rs232(baud=baudRate, xmit=TX_PIN, rcv=RX_PIN, enable=TX_ENABLE, stream=SERIAL, ERRORS)
*
000CA:  MOVLB  E
000CC:  BTFSS  xC8.5
000CE:  BRA    00CC
000D0:  MOVFF  F9C,555
000D4:  MOVLB  5
000D6:  MOVFF  F98,01
000DA:  BTFSS  x55.1
000DC:  BRA    00E2
000DE:  BCF    F9C.4
000E0:  BSF    F9C.4
000E2:  MOVLB  0
000E4:  GOTO   010C (RETURN)
*
05A3E:  MOVLW  93
05A40:  MOVWF  F89
05A42:  BSF    F84.5
05A44:  MOVLB  E
05A46:  BTFSS  xC8.4
05A48:  BRA    5A46
05A4A:  MOVLW  93
05A4C:  MOVWF  F89
05A4E:  BSF    F84.5
05A50:  MOVLB  6
05A52:  MOVFF  67A,F99
05A56:  NOP   
05A58:  BTFSS  F9D.1
05A5A:  BRA    5A58
05A5C:  MOVLW  93
05A5E:  MOVWF  F89
05A60:  BCF    F84.5
05A62:  MOVLB  0
05A64:  RETURN 0
.................... #else
.................... #use rs232(baud=baudRate, xmit=TX_PIN, rcv=RX_PIN, stream=SERIAL)
.................... #endif
.................... 
.................... // Message format: [SOT]addr ,cmd, arg1, arg2, arg3[EOT]} 
.................... // arguments are optional
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* SERIAL PORT ISR                                                           */
.................... /*****************************************************************************/
.................... #INT_RDA
.................... void RX_isr()
*
000E8:  MOVLB  0
.................... {
....................    while (kbhit())
000EA:  MOVLB  E
000EC:  BTFSS  xC8.5
000EE:  BRA    012E
....................    {
....................       UART_BUFFER[UART_WR_PTR]=getch();
000F0:  CLRF   03
000F2:  MOVLB  5
000F4:  MOVF   x52,W
000F6:  ADDLW  16
000F8:  MOVWF  FE9
000FA:  MOVLW  05
000FC:  ADDWFC 03,W
000FE:  MOVWF  FEA
00100:  MOVFF  FEA,6D6
00104:  MOVFF  FE9,6D5
00108:  MOVLB  0
0010A:  BRA    00CA
0010C:  MOVFF  6D6,FEA
00110:  MOVFF  6D5,FE9
00114:  MOVFF  01,FEF
....................       UART_WR_PTR +=1;
00118:  MOVLW  01
0011A:  MOVLB  5
0011C:  ADDWF  x52,F
....................       if (UART_WR_PTR>=UART_BUFFER_SIZE) UART_WR_PTR=0;
0011E:  MOVF   x52,W
00120:  SUBLW  3B
00122:  BC    0126
00124:  CLRF   x52
....................       BYTES_AVAILABLE=TRUE;
00126:  BSF    x54.0
00128:  MOVLB  0
0012A:  BRA    00EA
0012C:  MOVLB  E
....................    }
0012E:  BCF    xC8.5
00130:  MOVLB  0
00132:  GOTO   006E
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get character from buffer                                                 */
.................... /*****************************************************************************/
.................... char getchFromBuffer()
*
059F8:  CLRF   03
059FA:  MOVLB  5
059FC:  MOVF   x53,W
059FE:  ADDLW  16
05A00:  MOVWF  FE9
05A02:  MOVLW  05
05A04:  ADDWFC 03,W
05A06:  MOVWF  FEA
05A08:  MOVFF  FEF,665
.................... {
....................    char data = UART_BUFFER[UART_RD_PTR];
....................    UART_RD_PTR +=1;
05A0C:  MOVLW  01
05A0E:  ADDWF  x53,F
....................    if (UART_RD_PTR>=UART_BUFFER_SIZE) UART_RD_PTR=0;
05A10:  MOVF   x53,W
05A12:  SUBLW  3B
05A14:  BC    5A18
05A16:  CLRF   x53
....................    if (UART_RD_PTR == UART_WR_PTR) BYTES_AVAILABLE=FALSE;
05A18:  MOVF   x52,W
05A1A:  SUBWF  x53,W
05A1C:  BNZ   5A20
05A1E:  BCF    x54.0
....................    return data;
05A20:  MOVLB  6
05A22:  MOVFF  665,01
05A26:  MOVLB  0
05A28:  GOTO   5ACC (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Serial Task transfers bytes to command buffer                             */
.................... /*****************************************************************************/
.................... void serial_task()
.................... {
....................    while(BYTES_AVAILABLE && SERcmd[SWI].full==FALSE)
*
05A8A:  MOVLB  5
05A8C:  BTFSS  x54.0
05A8E:  BRA    5F7C
05A90:  MOVLB  6
05A92:  CLRF   xB1
05A94:  MOVFF  4B1,6B0
05A98:  CLRF   xB3
05A9A:  MOVLW  B5
05A9C:  MOVWF  xB2
05A9E:  MOVLB  0
05AA0:  CALL   07F0
05AA4:  MOVFF  02,666
05AA8:  MOVFF  01,665
05AAC:  MOVLW  DC
05AAE:  MOVLB  6
05AB0:  ADDWF  01,W
05AB2:  MOVWF  01
05AB4:  MOVLW  01
05AB6:  ADDWFC 02,W
05AB8:  MOVWF  03
05ABA:  MOVFF  01,FE9
05ABE:  MOVWF  FEA
05AC0:  BTFSS  FEF.0
05AC2:  BRA    5AC8
05AC4:  MOVLB  5
05AC6:  BRA    5F7C
....................    {  
....................       unsigned int8 rxChar = getchFromBuffer();
05AC8:  MOVLB  0
05ACA:  BRA    59F8
05ACC:  MOVFF  01,664
....................       if (rxChar == ignoreChr1 || rxChar == ignoreChr2)
05AD0:  MOVLB  6
05AD2:  MOVF   x64,W
05AD4:  SUBLW  0D
05AD6:  BZ    5ADE
05AD8:  MOVF   x64,W
05ADA:  SUBLW  20
05ADC:  BNZ   5AE0
....................       {
....................       }
05ADE:  BRA    5F76
....................       else if (rxChar == UART_SOT_CHAR)
05AE0:  MOVF   x64,W
05AE2:  SUBLW  7E
05AE4:  BNZ   5B28
....................       {
....................          resetSERcmd(SWI);
05AE6:  MOVFF  4B1,665
05AEA:  MOVLB  0
05AEC:  CALL   10DC
....................          SERcmd[SWI].t = rxChar;
05AF0:  MOVLB  6
05AF2:  CLRF   xB1
05AF4:  MOVFF  4B1,6B0
05AF8:  CLRF   xB3
05AFA:  MOVLW  B5
05AFC:  MOVWF  xB2
05AFE:  MOVLB  0
05B00:  CALL   07F0
05B04:  MOVFF  01,665
05B08:  MOVLW  05
05B0A:  MOVLB  6
05B0C:  ADDWF  01,W
05B0E:  MOVWF  01
05B10:  MOVLW  00
05B12:  ADDWFC 02,W
05B14:  MOVWF  03
05B16:  MOVF   01,W
05B18:  ADDLW  DC
05B1A:  MOVWF  FE9
05B1C:  MOVLW  01
05B1E:  ADDWFC 03,W
05B20:  MOVWF  FEA
05B22:  MOVFF  664,FEF
....................       }
05B26:  BRA    5F76
....................       else if (rxChar >= oneByteCmdTestValue)
05B28:  MOVF   x64,W
05B2A:  SUBLW  7F
05B2C:  BC    5B98
....................       {
....................          resetSERcmd(SWI);
05B2E:  MOVFF  4B1,665
05B32:  MOVLB  0
05B34:  CALL   10DC
....................          SERcmd[SWI].t = rxChar;
05B38:  MOVLB  6
05B3A:  CLRF   xB1
05B3C:  MOVFF  4B1,6B0
05B40:  CLRF   xB3
05B42:  MOVLW  B5
05B44:  MOVWF  xB2
05B46:  MOVLB  0
05B48:  CALL   07F0
05B4C:  MOVFF  01,665
05B50:  MOVLW  05
05B52:  MOVLB  6
05B54:  ADDWF  01,W
05B56:  MOVWF  01
05B58:  MOVLW  00
05B5A:  ADDWFC 02,W
05B5C:  MOVWF  03
05B5E:  MOVF   01,W
05B60:  ADDLW  DC
05B62:  MOVWF  FE9
05B64:  MOVLW  01
05B66:  ADDWFC 03,W
05B68:  MOVWF  FEA
05B6A:  MOVFF  664,FEF
....................          SERcmd[SWI].full = TRUE;
05B6E:  CLRF   xB1
05B70:  MOVFF  4B1,6B0
05B74:  CLRF   xB3
05B76:  MOVLW  B5
05B78:  MOVWF  xB2
05B7A:  MOVLB  0
05B7C:  CALL   07F0
05B80:  MOVLW  DC
05B82:  MOVLB  6
05B84:  ADDWF  01,W
05B86:  MOVWF  FE9
05B88:  MOVLW  01
05B8A:  ADDWFC 02,W
05B8C:  MOVWF  FEA
05B8E:  BSF    FEF.0
....................          setNextSERWriteIndex();
05B90:  MOVLB  0
05B92:  RCALL  5A2C
....................       }
05B94:  BRA    5F74
05B96:  MOVLB  6
....................       else if (rxChar == UART_EOT_CHAR2)
05B98:  MOVF   x64,W
05B9A:  SUBLW  0A
05B9C:  BTFSS  FD8.2
05B9E:  BRA    5CA4
....................       {
....................          SERcmd[SWI].full = TRUE;
05BA0:  CLRF   xB1
05BA2:  MOVFF  4B1,6B0
05BA6:  CLRF   xB3
05BA8:  MOVLW  B5
05BAA:  MOVWF  xB2
05BAC:  MOVLB  0
05BAE:  CALL   07F0
05BB2:  MOVLW  DC
05BB4:  MOVLB  6
05BB6:  ADDWF  01,W
05BB8:  MOVWF  FE9
05BBA:  MOVLW  01
05BBC:  ADDWFC 02,W
05BBE:  MOVWF  FEA
05BC0:  BSF    FEF.0
....................          SERcmd[SWI].recWriteIndex = SERcmd[SWI].paramIndex;
05BC2:  CLRF   xB1
05BC4:  MOVFF  4B1,6B0
05BC8:  CLRF   xB3
05BCA:  MOVLW  B5
05BCC:  MOVWF  xB2
05BCE:  MOVLB  0
05BD0:  CALL   07F0
05BD4:  MOVFF  01,665
05BD8:  MOVLW  04
05BDA:  MOVLB  6
05BDC:  ADDWF  01,W
05BDE:  MOVWF  01
05BE0:  MOVLW  00
05BE2:  ADDWFC 02,W
05BE4:  MOVWF  03
05BE6:  MOVF   01,W
05BE8:  ADDLW  DC
05BEA:  MOVWF  01
05BEC:  MOVLW  01
05BEE:  ADDWFC 03,F
05BF0:  MOVFF  01,665
05BF4:  MOVFF  03,666
05BF8:  CLRF   xB1
05BFA:  MOVFF  4B1,6B0
05BFE:  CLRF   xB3
05C00:  MOVLW  B5
05C02:  MOVWF  xB2
05C04:  MOVLB  0
05C06:  CALL   07F0
05C0A:  MOVFF  01,667
05C0E:  MOVLW  02
05C10:  MOVLB  6
05C12:  ADDWF  01,W
05C14:  MOVWF  01
05C16:  MOVLW  00
05C18:  ADDWFC 02,W
05C1A:  MOVWF  03
05C1C:  MOVF   01,W
05C1E:  ADDLW  DC
05C20:  MOVWF  FE9
05C22:  MOVLW  01
05C24:  ADDWFC 03,W
05C26:  MOVWF  FEA
05C28:  MOVFF  FEF,667
05C2C:  MOVFF  666,FEA
05C30:  MOVFF  665,FE9
05C34:  MOVFF  667,FEF
....................          SERcmd[SWI].chrIndex = 0;
05C38:  CLRF   xB1
05C3A:  MOVFF  4B1,6B0
05C3E:  CLRF   xB3
05C40:  MOVLW  B5
05C42:  MOVWF  xB2
05C44:  MOVLB  0
05C46:  CALL   07F0
05C4A:  MOVFF  01,665
05C4E:  MOVLW  01
05C50:  MOVLB  6
05C52:  ADDWF  01,W
05C54:  MOVWF  01
05C56:  MOVLW  00
05C58:  ADDWFC 02,W
05C5A:  MOVWF  03
05C5C:  MOVF   01,W
05C5E:  ADDLW  DC
05C60:  MOVWF  FE9
05C62:  MOVLW  01
05C64:  ADDWFC 03,W
05C66:  MOVWF  FEA
05C68:  CLRF   FEF
....................          SERcmd[SWI].paramIndex = 0;
05C6A:  CLRF   xB1
05C6C:  MOVFF  4B1,6B0
05C70:  CLRF   xB3
05C72:  MOVLW  B5
05C74:  MOVWF  xB2
05C76:  MOVLB  0
05C78:  CALL   07F0
05C7C:  MOVFF  01,665
05C80:  MOVLW  02
05C82:  MOVLB  6
05C84:  ADDWF  01,W
05C86:  MOVWF  01
05C88:  MOVLW  00
05C8A:  ADDWFC 02,W
05C8C:  MOVWF  03
05C8E:  MOVF   01,W
05C90:  ADDLW  DC
05C92:  MOVWF  FE9
05C94:  MOVLW  01
05C96:  ADDWFC 03,W
05C98:  MOVWF  FEA
05C9A:  CLRF   FEF
....................          setNextSERWriteIndex();
05C9C:  MOVLB  0
05C9E:  RCALL  5A2C
....................       }
05CA0:  BRA    5F74
05CA2:  MOVLB  6
....................       else if (rxChar == delimiter)
05CA4:  MOVF   x64,W
05CA6:  SUBLW  2C
05CA8:  BNZ   5D66
....................       {
....................          if (SERcmd[SWI].paramIndex < numParam-1)
05CAA:  CLRF   xB1
05CAC:  MOVFF  4B1,6B0
05CB0:  CLRF   xB3
05CB2:  MOVLW  B5
05CB4:  MOVWF  xB2
05CB6:  MOVLB  0
05CB8:  CALL   07F0
05CBC:  MOVFF  02,666
05CC0:  MOVFF  01,665
05CC4:  MOVLW  02
05CC6:  MOVLB  6
05CC8:  ADDWF  01,W
05CCA:  MOVWF  01
05CCC:  MOVLW  00
05CCE:  ADDWFC 02,W
05CD0:  MOVWF  03
05CD2:  MOVF   01,W
05CD4:  ADDLW  DC
05CD6:  MOVWF  FE9
05CD8:  MOVLW  01
05CDA:  ADDWFC 03,W
05CDC:  MOVWF  FEA
05CDE:  MOVF   FEF,W
05CE0:  SUBLW  05
05CE2:  BNC   5D4E
....................          {
....................             SERcmd[SWI].paramIndex +=1;
05CE4:  CLRF   xB1
05CE6:  MOVFF  4B1,6B0
05CEA:  CLRF   xB3
05CEC:  MOVLW  B5
05CEE:  MOVWF  xB2
05CF0:  MOVLB  0
05CF2:  CALL   07F0
05CF6:  MOVFF  01,665
05CFA:  MOVLW  02
05CFC:  MOVLB  6
05CFE:  ADDWF  01,W
05D00:  MOVWF  01
05D02:  MOVLW  00
05D04:  ADDWFC 02,W
05D06:  MOVWF  03
05D08:  MOVF   01,W
05D0A:  ADDLW  DC
05D0C:  MOVWF  FE9
05D0E:  MOVLW  01
05D10:  ADDWFC 03,W
05D12:  MOVWF  FEA
05D14:  MOVLW  01
05D16:  ADDWF  FEF,W
05D18:  MOVWF  FEF
....................             SERcmd[SWI].chrIndex = 0;
05D1A:  CLRF   xB1
05D1C:  MOVFF  4B1,6B0
05D20:  CLRF   xB3
05D22:  MOVLW  B5
05D24:  MOVWF  xB2
05D26:  MOVLB  0
05D28:  CALL   07F0
05D2C:  MOVFF  01,665
05D30:  MOVLW  01
05D32:  MOVLB  6
05D34:  ADDWF  01,W
05D36:  MOVWF  01
05D38:  MOVLW  00
05D3A:  ADDWFC 02,W
05D3C:  MOVWF  03
05D3E:  MOVF   01,W
05D40:  ADDLW  DC
05D42:  MOVWF  FE9
05D44:  MOVLW  01
05D46:  ADDWFC 03,W
05D48:  MOVWF  FEA
05D4A:  CLRF   FEF
....................          }
05D4C:  BRA    5D64
....................          else
....................          {
....................             resetSERcmd(SWI); // exceed number of params... reset capture
05D4E:  MOVFF  4B1,665
05D52:  MOVLB  0
05D54:  CALL   10DC
....................             fprintf(SERIAL, retData);
05D58:  MOVLW  04
05D5A:  MOVWF  FEA
05D5C:  MOVLW  B2
05D5E:  MOVWF  FE9
05D60:  RCALL  5A66
05D62:  MOVLB  6
....................          }
....................       }
05D64:  BRA    5F76
....................       
....................       else
....................       {
....................          if (SERcmd[SWI].chrIndex < lenParam)
05D66:  CLRF   xB1
05D68:  MOVFF  4B1,6B0
05D6C:  CLRF   xB3
05D6E:  MOVLW  B5
05D70:  MOVWF  xB2
05D72:  MOVLB  0
05D74:  CALL   07F0
05D78:  MOVFF  02,666
05D7C:  MOVFF  01,665
05D80:  MOVLW  01
05D82:  MOVLB  6
05D84:  ADDWF  01,W
05D86:  MOVWF  01
05D88:  MOVLW  00
05D8A:  ADDWFC 02,W
05D8C:  MOVWF  03
05D8E:  MOVF   01,W
05D90:  ADDLW  DC
05D92:  MOVWF  FE9
05D94:  MOVLW  01
05D96:  ADDWFC 03,W
05D98:  MOVWF  FEA
05D9A:  MOVF   FEF,W
05D9C:  SUBLW  18
05D9E:  BTFSS  FD8.0
05DA0:  BRA    5F60
....................          {
....................             SERcmd[SWI].p[SERcmd[SWI].paramIndex][SERcmd[SWI].chrIndex] = rxChar;
05DA2:  CLRF   xB1
05DA4:  MOVFF  4B1,6B0
05DA8:  CLRF   xB3
05DAA:  MOVLW  B5
05DAC:  MOVWF  xB2
05DAE:  MOVLB  0
05DB0:  CALL   07F0
05DB4:  MOVFF  02,666
05DB8:  MOVFF  01,665
05DBC:  MOVLW  06
05DBE:  MOVLB  6
05DC0:  ADDWF  x65,F
05DC2:  MOVLW  00
05DC4:  ADDWFC x66,F
05DC6:  CLRF   xB1
05DC8:  MOVFF  4B1,6B0
05DCC:  CLRF   xB3
05DCE:  MOVLW  B5
05DD0:  MOVWF  xB2
05DD2:  MOVLB  0
05DD4:  CALL   07F0
05DD8:  MOVFF  02,668
05DDC:  MOVFF  01,667
05DE0:  MOVLW  02
05DE2:  MOVLB  6
05DE4:  ADDWF  01,W
05DE6:  MOVWF  01
05DE8:  MOVLW  00
05DEA:  ADDWFC 02,W
05DEC:  MOVWF  03
05DEE:  MOVF   01,W
05DF0:  ADDLW  DC
05DF2:  MOVWF  FE9
05DF4:  MOVLW  01
05DF6:  ADDWFC 03,W
05DF8:  MOVWF  FEA
05DFA:  CLRF   xB1
05DFC:  MOVFF  FEF,6B0
05E00:  CLRF   xB3
05E02:  MOVLW  19
05E04:  MOVWF  xB2
05E06:  MOVLB  0
05E08:  CALL   07F0
05E0C:  MOVFF  02,03
05E10:  MOVF   01,W
05E12:  MOVLB  6
05E14:  ADDWF  x65,F
05E16:  MOVF   02,W
05E18:  ADDWFC x66,F
05E1A:  CLRF   xB1
05E1C:  MOVFF  4B1,6B0
05E20:  CLRF   xB3
05E22:  MOVLW  B5
05E24:  MOVWF  xB2
05E26:  MOVLB  0
05E28:  CALL   07F0
05E2C:  MOVFF  01,667
05E30:  MOVLW  01
05E32:  MOVLB  6
05E34:  ADDWF  01,W
05E36:  MOVWF  01
05E38:  MOVLW  00
05E3A:  ADDWFC 02,W
05E3C:  MOVWF  03
05E3E:  MOVF   01,W
05E40:  ADDLW  DC
05E42:  MOVWF  FE9
05E44:  MOVLW  01
05E46:  ADDWFC 03,W
05E48:  MOVWF  FEA
05E4A:  MOVF   FEF,W
05E4C:  ADDWF  x65,W
05E4E:  MOVWF  01
05E50:  MOVLW  00
05E52:  ADDWFC x66,W
05E54:  MOVWF  03
05E56:  MOVF   01,W
05E58:  ADDLW  DC
05E5A:  MOVWF  FE9
05E5C:  MOVLW  01
05E5E:  ADDWFC 03,W
05E60:  MOVWF  FEA
05E62:  MOVFF  664,FEF
....................             SERcmd[SWI].chrIndex += 1;
05E66:  CLRF   xB1
05E68:  MOVFF  4B1,6B0
05E6C:  CLRF   xB3
05E6E:  MOVLW  B5
05E70:  MOVWF  xB2
05E72:  MOVLB  0
05E74:  CALL   07F0
05E78:  MOVFF  01,665
05E7C:  MOVLW  01
05E7E:  MOVLB  6
05E80:  ADDWF  01,W
05E82:  MOVWF  01
05E84:  MOVLW  00
05E86:  ADDWFC 02,W
05E88:  MOVWF  03
05E8A:  MOVF   01,W
05E8C:  ADDLW  DC
05E8E:  MOVWF  FE9
05E90:  MOVLW  01
05E92:  ADDWFC 03,W
05E94:  MOVWF  FEA
05E96:  MOVLW  01
05E98:  ADDWF  FEF,W
05E9A:  MOVWF  FEF
....................             SERcmd[SWI].p[SERcmd[SWI].paramIndex][SERcmd[SWI].chrIndex] = '\0';
05E9C:  CLRF   xB1
05E9E:  MOVFF  4B1,6B0
05EA2:  CLRF   xB3
05EA4:  MOVLW  B5
05EA6:  MOVWF  xB2
05EA8:  MOVLB  0
05EAA:  CALL   07F0
05EAE:  MOVFF  02,666
05EB2:  MOVFF  01,665
05EB6:  MOVLW  06
05EB8:  MOVLB  6
05EBA:  ADDWF  x65,F
05EBC:  MOVLW  00
05EBE:  ADDWFC x66,F
05EC0:  CLRF   xB1
05EC2:  MOVFF  4B1,6B0
05EC6:  CLRF   xB3
05EC8:  MOVLW  B5
05ECA:  MOVWF  xB2
05ECC:  MOVLB  0
05ECE:  CALL   07F0
05ED2:  MOVFF  02,668
05ED6:  MOVFF  01,667
05EDA:  MOVLW  02
05EDC:  MOVLB  6
05EDE:  ADDWF  01,W
05EE0:  MOVWF  01
05EE2:  MOVLW  00
05EE4:  ADDWFC 02,W
05EE6:  MOVWF  03
05EE8:  MOVF   01,W
05EEA:  ADDLW  DC
05EEC:  MOVWF  FE9
05EEE:  MOVLW  01
05EF0:  ADDWFC 03,W
05EF2:  MOVWF  FEA
05EF4:  CLRF   xB1
05EF6:  MOVFF  FEF,6B0
05EFA:  CLRF   xB3
05EFC:  MOVLW  19
05EFE:  MOVWF  xB2
05F00:  MOVLB  0
05F02:  CALL   07F0
05F06:  MOVFF  02,03
05F0A:  MOVF   01,W
05F0C:  MOVLB  6
05F0E:  ADDWF  x65,F
05F10:  MOVF   02,W
05F12:  ADDWFC x66,F
05F14:  CLRF   xB1
05F16:  MOVFF  4B1,6B0
05F1A:  CLRF   xB3
05F1C:  MOVLW  B5
05F1E:  MOVWF  xB2
05F20:  MOVLB  0
05F22:  CALL   07F0
05F26:  MOVFF  01,667
05F2A:  MOVLW  01
05F2C:  MOVLB  6
05F2E:  ADDWF  01,W
05F30:  MOVWF  01
05F32:  MOVLW  00
05F34:  ADDWFC 02,W
05F36:  MOVWF  03
05F38:  MOVF   01,W
05F3A:  ADDLW  DC
05F3C:  MOVWF  FE9
05F3E:  MOVLW  01
05F40:  ADDWFC 03,W
05F42:  MOVWF  FEA
05F44:  MOVF   FEF,W
05F46:  ADDWF  x65,W
05F48:  MOVWF  01
05F4A:  MOVLW  00
05F4C:  ADDWFC x66,W
05F4E:  MOVWF  03
05F50:  MOVF   01,W
05F52:  ADDLW  DC
05F54:  MOVWF  FE9
05F56:  MOVLW  01
05F58:  ADDWFC 03,W
05F5A:  MOVWF  FEA
05F5C:  CLRF   FEF
....................          }
05F5E:  BRA    5F76
....................          else
....................          {
....................             resetSERcmd(SWI); // exceed number of characters... reset capture
05F60:  MOVFF  4B1,665
05F64:  MOVLB  0
05F66:  CALL   10DC
....................             fprintf(SERIAL, retData);
05F6A:  MOVLW  04
05F6C:  MOVWF  FEA
05F6E:  MOVLW  B2
05F70:  MOVWF  FE9
05F72:  RCALL  5A66
05F74:  MOVLB  6
....................          }
....................       }
05F76:  MOVLB  0
05F78:  BRA    5A8A
05F7A:  MOVLB  5
....................    }          
05F7C:  MOVLB  0
05F7E:  GOTO   AFD4 (RETURN)
.................... }
....................            
.................... /*****************************************************************************/
.................... /* serialInit ROUTINE  - Sets up serial port                                 */
.................... /*****************************************************************************/ 
.................... void serial_init()
.................... {
....................    for (int i = 0; i < numRecords; i++) 
*
01266:  MOVLB  6
01268:  CLRF   x64
0126A:  MOVF   x64,W
0126C:  SUBLW  03
0126E:  BNC   127E
....................    {
....................       resetSERcmd(i);
01270:  MOVFF  664,665
01274:  MOVLB  0
01276:  RCALL  10DC
01278:  MOVLB  6
0127A:  INCF   x64,F
0127C:  BRA    126A
....................    }
....................    enable_interrupts(INT_RDA);
0127E:  MOVLB  E
01280:  BSF    xC0.5
01282:  MOVLB  0
01284:  GOTO   AFBC (RETURN)
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #include <pid.h>
.................... #ifndef pidcontroller
.................... #define pidcontroller
.................... #include <parameters.h>
.................... #include <math.h>
.................... 
.................... /*****************************************************************************/
.................... /* UPDATE the Control Variable (CV)                                          */
.................... /*****************************************************************************/
.................... void pid_update (channelMap ch){
....................    float err = PID[ch].SP - PID[ch].PV;  // error = set value - measured
....................    
....................    PID[ch].I += err*PID[ch].kI;
....................    if (PID[ch].I > op_upper_bound) PID[ch].I = op_upper_bound; // anti-windup
....................    else if (PID[ch].I < op_lower_bound) PID[ch].I = op_lower_bound;
....................    
....................    float P = err * PID[ch].kP;  // proportional value
....................    
....................    float D = PID[ch].kD * (PID[ch].PV - PID[ch].PVold);  // derivative value
....................    
....................    PID[ch].CV = P + PID[ch].I + D;  // new control variable
....................    if (PID[ch].CV > op_upper_bound) PID[ch].CV = op_upper_bound; // limit positive output
....................    else if (PID[ch].CV < op_lower_bound) PID[ch].CV = op_lower_bound; // limit negative output
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PID Task - looks for change to PV and updates CV                          */
.................... /*****************************************************************************/
.................... void pid_task(channelMap ch){
....................    static int index = 0;
....................    if (PID[ch].SP != PID[ch].PV) pid_update(ch);
....................    if ((index++) >= numChannels) index = 0;
.................... }
.................... 
.................... #endif
.................... 
.................... #include <eventTimer.h>
.................... #ifndef timeout
.................... #define timeout
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0.3,0.1,0,0,0,0,0},
....................    {0.01,0.3,0.1,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/           
.................... /* Global timers used by all routnes                                         */
.................... /* timeoutReg0-2 are used for timeouts. Other routines monitor the value of  */
.................... /* intTimeoutReg. On boot, they will be loaded from EEProm. Any              */
.................... /* configuration changes will be changed in EEprom, hence will be restored on*/
.................... /* subsequent boot.                                                          */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* Register definitions                                                      */
.................... /*****************************************************************************/
.................... //!unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... //!unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... //!unsigned int32 timeoutReg2 = 0;
.................... //!unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... unsigned int32 timeCounter = 0;
.................... 
.................... /*****************************************************************************/
.................... /* TIMEOUT_INIT initializes the timer                                        */
.................... /*****************************************************************************/
.................... void event_timer_init()
.................... {        
....................    disable_interrupts(INT_TIMER1);
01288:  MOVLB  E
0128A:  BCF    xC1.0
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_1);
0128C:  MOVLW  01
0128E:  MOVWF  FD1
01290:  MOVLW  07
01292:  MOVWF  FCE
01294:  CLRF   FCF
01296:  CLRF   FD0
....................    timeoutReg0 = 0;  // clear all the timers
01298:  MOVLB  1
0129A:  CLRF   x5A
0129C:  CLRF   x59
0129E:  CLRF   x58
012A0:  CLRF   x57
....................    timeoutReg1 = 0;
012A2:  CLRF   x5E
012A4:  CLRF   x5D
012A6:  CLRF   x5C
012A8:  CLRF   x5B
....................    timeoutReg2 = 0;
012AA:  CLRF   x62
012AC:  CLRF   x61
012AE:  CLRF   x60
012B0:  CLRF   x5F
....................    intTimeoutReg = 50;
012B2:  CLRF   x64
012B4:  MOVLW  32
012B6:  MOVWF  x63
....................    enable_interrupts(INT_TIMER1);
012B8:  MOVLB  E
012BA:  BSF    xC1.0
012BC:  MOVLB  0
012BE:  GOTO   AFC0 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* TIMEOUT INTERRUPT decrements the timeout registers every second           */
.................... /*****************************************************************************/
.................... #INT_TIMER1
.................... void TIMER1_isr(void) 
*
0025A:  MOVLB  0
.................... {
....................    set_timer1(0x0BDB); // load timer register to allow 10 millisecond interupts
0025C:  MOVLW  0B
0025E:  MOVWF  FCD
00260:  MOVLW  DB
00262:  MOVWF  FCC
00264:  NOP   
....................    if (timeoutReg0 > 10) timeoutReg0 -= 10; else timeoutReg0 = 0;
00266:  MOVLB  1
00268:  MOVF   x5A,F
0026A:  BNZ   027A
0026C:  MOVF   x59,F
0026E:  BNZ   027A
00270:  MOVF   x58,F
00272:  BNZ   027A
00274:  MOVF   x57,W
00276:  SUBLW  0A
00278:  BC    0288
0027A:  MOVLW  0A
0027C:  SUBWF  x57,F
0027E:  MOVLW  00
00280:  SUBWFB x58,F
00282:  SUBWFB x59,F
00284:  SUBWFB x5A,F
00286:  BRA    0290
00288:  CLRF   x5A
0028A:  CLRF   x59
0028C:  CLRF   x58
0028E:  CLRF   x57
....................    if (timeoutReg1 > 10) timeoutReg1 -= 10; else timeoutReg1 = 0;
00290:  MOVF   x5E,F
00292:  BNZ   02A2
00294:  MOVF   x5D,F
00296:  BNZ   02A2
00298:  MOVF   x5C,F
0029A:  BNZ   02A2
0029C:  MOVF   x5B,W
0029E:  SUBLW  0A
002A0:  BC    02B0
002A2:  MOVLW  0A
002A4:  SUBWF  x5B,F
002A6:  MOVLW  00
002A8:  SUBWFB x5C,F
002AA:  SUBWFB x5D,F
002AC:  SUBWFB x5E,F
002AE:  BRA    02B8
002B0:  CLRF   x5E
002B2:  CLRF   x5D
002B4:  CLRF   x5C
002B6:  CLRF   x5B
....................    if (timeoutReg2 > 10) timeoutReg2 -= 10; else timeoutReg2 = 0;
002B8:  MOVF   x62,F
002BA:  BNZ   02CA
002BC:  MOVF   x61,F
002BE:  BNZ   02CA
002C0:  MOVF   x60,F
002C2:  BNZ   02CA
002C4:  MOVF   x5F,W
002C6:  SUBLW  0A
002C8:  BC    02D8
002CA:  MOVLW  0A
002CC:  SUBWF  x5F,F
002CE:  MOVLW  00
002D0:  SUBWFB x60,F
002D2:  SUBWFB x61,F
002D4:  SUBWFB x62,F
002D6:  BRA    02E0
002D8:  CLRF   x62
002DA:  CLRF   x61
002DC:  CLRF   x60
002DE:  CLRF   x5F
....................    if (intTimeoutReg != 0) // INTERRUPTING TIMER
002E0:  MOVF   x63,F
002E2:  BNZ   02E8
002E4:  MOVF   x64,F
002E6:  BZ    0324
....................    {
....................       timeCounter+=10;
002E8:  MOVLW  0A
002EA:  MOVLB  5
002EC:  ADDWF  x58,F
002EE:  MOVLW  00
002F0:  ADDWFC x59,F
002F2:  ADDWFC x5A,F
002F4:  ADDWFC x5B,F
....................       if (timeCounter >= intTimeoutReg)
002F6:  MOVF   x5B,F
002F8:  BNZ   0314
002FA:  MOVF   x5A,F
002FC:  BNZ   0314
002FE:  MOVLB  1
00300:  MOVF   x64,W
00302:  MOVLB  5
00304:  SUBWF  x59,W
00306:  BNC   0322
00308:  BNZ   0314
0030A:  MOVLB  1
0030C:  MOVF   x63,W
0030E:  MOVLB  5
00310:  SUBWF  x58,W
00312:  BNC   0322
....................       {
....................          sensor_monitor_interrupt_task();
00314:  MOVLB  0
00316:  BRA    01BE
....................          timeCounter = 0;
00318:  MOVLB  5
0031A:  CLRF   x5B
0031C:  CLRF   x5A
0031E:  CLRF   x59
00320:  CLRF   x58
00322:  MOVLB  1
....................       }
....................    }
.................... }
.................... 
.................... #endif
.................... 
.................... #include <commandHandler.c>
.................... #ifndef cmdHandlerC
.................... #define cmdHandlerC
.................... #include <commandHandler.h>
.................... #ifndef cmdHandler
.................... #define cmdHandler
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0.3,0.1,0,0,0,0,0},
....................    {0.01,0.3,0.1,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... 
00324:  MOVLB  E
00326:  BCF    xC9.0
00328:  MOVLB  0
0032A:  GOTO   006E
.................... #define hwID 'D'   // DiFCS
.................... 
.................... /*****************************************************************************/
.................... /* RESPONSE MESSAGES                                                         */
.................... /*****************************************************************************/
.................... typedef struct response {
....................    int8 id;
....................    char *msg;
.................... } resp;
.................... 
.................... //!#define INVALID_DATA "error - invalid data"
.................... //!#define invalidTime "error - invalid TO value"
.................... //!#define overrun "error - buffer overrun"
.................... //!#define dcVoltage "VDC:%f1"
.................... //!#define USBVoltage "VUSB:%f"
.................... //!#define USBupstream "VUSBup:%f"
.................... //!#define plus5V "5V Rail:%f"
.................... //!#define plus3V3 "3V3 Rai:%f"
.................... //!#define allVoltages "All Voltages = %f, %f, %f, %f, %f"
.................... //!#define USBdownstream "USB downstream status:\r\nPG:%s\r\nch0:%s\r\nch1:%s"
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC MESSGAGE DUMP                                                  */
.................... /*****************************************************************************/
.................... //!#define voltageMsg "V0:%f\r\nV1:%f\r\nV2:%f\r\nV3:%f\r\nV4:%f"
.................... //!#define TimerMsg "T0:%Lu\r\nT1:%Lu\r\nT2:%Lu\r\Tint:%Lu\r\nTtick:%Lu"
.................... //!#define ioStatusMsg "Inputs:%u\r\nOutputs:%u\r\nStatus:%u"
.................... //!#define diagnosticMsg "V0:%f\r\nV1:%f\r\nV2:%f\r\nV3:%f\r\nV4:%f\r\nT0:%Lu\r\nT1:%Lu\r\nT2:%Lu\r\nTint:%Lu\r\nTtick:%Lu\r\nInputs:%u\r\nOutputs:%u\r\nStatus:%u"
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC COMMAND PROTOTYPES                                             */
.................... /*****************************************************************************/
.................... int8 getRev(unsigned int8);                // gr 
.................... int8 getSN(unsigned int8);                 // gs
.................... 
.................... int8 getOPchMap(unsigned int8);            // gChMap,   {1|2}
.................... int8 setOPchMap(unsigned int8);            // sChMap,   {1|2}, {X|Y}
.................... 
.................... int8 getIPchMode(unsigned int8);           // gChMode,  {1|2}
.................... int8 setIPchMode(unsigned int8);           // sChMode,  {1|2}, {MANUAL|MAGSNS}
....................    
.................... int8 getPIDvals(unsigned int8);            // gPID,     {1|2}, {P|I|D}
.................... int8 setPIDvals(unsigned int8);            // sPID,     {1|2}, {P|I|D}, <float>
.................... 
.................... int8 enablePID(unsigned int8);             // enaPID,   {1|2}
.................... int8 disablePID(unsigned int8);            // disPID,   {1|2}
.................... 
.................... int8 getSetPoint(unsigned int8);           // gSP,      {1|2}
.................... int8 setSetPoint(unsigned int8);           // sSP,      {1|2}, <float>
.................... 
.................... int8 getAllSensorCalParams(unsigned int8); // gSCals,   {1|2}
.................... int8 getSensorCalParam(unsigned int8);     // gSCal,    {1|2}, {0|1|2|3|4|5}
.................... int8 setSensorCalParam(unsigned int8);     // sSCal,    {1|2}, {0|1|2|3|4|5}, <float>
.................... 
.................... int8 getMonitorCalParam(unsigned int8);    // gMCal,    {N15|200|5V6|5VA|3V6X|3V3A|3V3D}
.................... int8 setMonitorCalParam(unsigned int8);    // sMCal,    {N15|200|5V6|5VA|3V6X|3V3A|3V3D}, <float>, <float>
.................... int8 getMonitorValue(unsigned int8);       // gMon,     {N15|200|5V6|5VA|3V6X|3V3A|3V3D|all}
.................... 
.................... int8 getPIDdata(unsigned int8);            // gPIDdata, {1|2}, {PV|CV|PVold|I}
.................... 
.................... int8 getIPdata(unsigned int8);             // gIPdata,  {1|2}, {raw|calib|p0|poles|real}
....................    
.................... int8 getManOPvals(unsigned int8);          // gManOP,   {1|2}  
.................... int8 setManOPvals(unsigned int8);          // sManOP,   {1|2}, <float>  
.................... 
.................... int8 invalidCmd(unsigned int8);
.................... 
.................... struct command {
....................    char *cmd_name;
....................    int8 (*cmd_func)(unsigned int8);
.................... };
.................... 
.................... BOOLEAN arg_is_float(char *);
.................... BOOLEAN is_valid_channel(char *);
.................... int8 hex_to_int(char);
.................... void echo_cmd(unsigned int8 rec);
.................... int8 command_parser(unsigned int8 rec);
.................... void command_handler_task();
.................... 
.................... #endif
.................... 
.................... 
.................... /* LIST OF DIAGNOSTIC COMMAND KEYWORDS AND THEIR FUNCTIONS */
.................... struct command cmd_list[] = {
....................    {"gr",       &getRev},
....................    {"gs",       &getSN},
....................    {"gChMap",   &getOPchMap},
....................    {"sChMap",   &setOPchMap},
....................    {"gChMode",  &getIPchMode},
....................    {"sChMode",  &setIPchMode},
....................    {"gPID",     &getPIDvals},
....................    {"sPID",     &setPIDvals},
.................... //!   {"enaPID",   &enablePID},
.................... //!   {"disPID",   &disablePID},
....................    {"gSP",      &getSetPoint},
....................    {"sSP",      &setSetPoint},
....................    {"gSCals",   &getAllSensorCalParams},
....................    {"gSCal",    &getSensorCalParam},
....................    {"sSCal",    &setSensorCalParam},
....................    {"gMCal",    &getMonitorCalParam},
....................    {"sMCal",    &setMonitorCalParam},
....................    {"gMon",     &getMonitorValue},
....................    {"gPIDdata", &getPIDdata},
....................    {"gIPdata",  &getIPdata},
....................    {"gManOP",   &getManOPvals},
....................    {"sManOP",   &setManOPvals},
....................    {"\0", &invalidCmd}
.................... };
.................... 
.................... /* LIST OF RESPONSE MESSAGES */
.................... enum resp_e { 
....................    SUCCESS,
....................    INV_CMD,
....................    INV_PARAM 
.................... };
.................... 
.................... resp resp_list[] = {
....................    {SUCCESS, "SUCCESS"},
....................    {INV_CMD, "INVALID COMMAND"},
....................    {INV_PARAM, "INVALID PARAMETER"}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC COMMAND DEFINITIONS                                            */
.................... /*****************************************************************************/
....................                           
.................... int8 getRev(unsigned int8 rec){
....................    sprintf(retData+strlen(retData), "%s,", version);
*
06480:  MOVLW  04
06482:  MOVLB  6
06484:  MOVWF  xA6
06486:  MOVLW  B2
06488:  MOVWF  xA5
0648A:  MOVLB  0
0648C:  RCALL  6390
0648E:  MOVFF  02,03
06492:  MOVF   01,W
06494:  ADDLW  B2
06496:  MOVLB  6
06498:  MOVWF  x6F
0649A:  MOVLW  04
0649C:  ADDWFC 02,W
0649E:  MOVWF  x70
064A0:  MOVFF  FE8,557
064A4:  MOVFF  66F,556
064A8:  MOVLW  2E
064AA:  MOVWF  FF6
064AC:  MOVLW  03
064AE:  MOVWF  FF7
064B0:  MOVLB  0
064B2:  RCALL  6460
064B4:  MOVLW  2C
064B6:  MOVLB  6
064B8:  MOVWF  xB4
064BA:  MOVLB  0
064BC:  RCALL  6440
....................    return SUCCESS;
064BE:  MOVLW  00
064C0:  MOVWF  01
064C2:  RETURN 0
.................... }
.................... 
.................... int8 getSN(unsigned int8 rec){
....................    sprintf(retData+strlen(retData), "%s,", serialID);
064C4:  MOVLW  04
064C6:  MOVLB  6
064C8:  MOVWF  xA6
064CA:  MOVLW  B2
064CC:  MOVWF  xA5
064CE:  MOVLB  0
064D0:  RCALL  6390
064D2:  MOVFF  02,03
064D6:  MOVF   01,W
064D8:  ADDLW  B2
064DA:  MOVLB  6
064DC:  MOVWF  x6F
064DE:  MOVLW  04
064E0:  ADDWFC 02,W
064E2:  MOVWF  x70
064E4:  MOVFF  FE8,557
064E8:  MOVFF  66F,556
064EC:  MOVLW  38
064EE:  MOVWF  FF6
064F0:  MOVLW  03
064F2:  MOVWF  FF7
064F4:  MOVLB  0
064F6:  RCALL  6460
064F8:  MOVLW  2C
064FA:  MOVLB  6
064FC:  MOVWF  xB4
064FE:  MOVLB  0
06500:  RCALL  6440
....................    return SUCCESS;
06502:  MOVLW  00
06504:  MOVWF  01
06506:  RETURN 0
.................... }
.................... 
.................... int8 getOPchMap(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
06A0C:  MOVLB  6
06A0E:  CLRF   xB1
06A10:  MOVFF  663,6B0
06A14:  CLRF   xB3
06A16:  MOVLW  B5
06A18:  MOVWF  xB2
06A1A:  MOVLB  0
06A1C:  CALL   07F0
06A20:  MOVFF  02,671
06A24:  MOVFF  01,670
06A28:  MOVLW  06
06A2A:  MOVLB  6
06A2C:  ADDWF  x70,F
06A2E:  MOVLW  00
06A30:  ADDWFC x71,F
06A32:  MOVLW  32
06A34:  ADDWF  x70,W
06A36:  MOVWF  01
06A38:  MOVLW  00
06A3A:  ADDWFC x71,W
06A3C:  MOVWF  03
06A3E:  MOVF   01,W
06A40:  ADDLW  DC
06A42:  MOVWF  01
06A44:  MOVLW  01
06A46:  ADDWFC 03,F
06A48:  MOVFF  01,670
06A4C:  MOVFF  03,671
06A50:  MOVFF  03,698
06A54:  MOVFF  01,697
06A58:  MOVLB  0
06A5A:  RCALL  6508
06A5C:  MOVF   01,F
06A5E:  BNZ   6A68
06A60:  MOVLW  02
06A62:  MOVWF  01
06A64:  BRA    6BA6
06A66:  BRA    6AC4
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06A68:  MOVLB  6
06A6A:  CLRF   xB1
06A6C:  MOVFF  663,6B0
06A70:  CLRF   xB3
06A72:  MOVLW  B5
06A74:  MOVWF  xB2
06A76:  MOVLB  0
06A78:  CALL   07F0
06A7C:  MOVFF  02,671
06A80:  MOVFF  01,670
06A84:  MOVLW  06
06A86:  MOVLB  6
06A88:  ADDWF  x70,F
06A8A:  MOVLW  00
06A8C:  ADDWFC x71,F
06A8E:  MOVLW  32
06A90:  ADDWF  x70,W
06A92:  MOVWF  01
06A94:  MOVLW  00
06A96:  ADDWFC x71,W
06A98:  MOVWF  03
06A9A:  MOVF   01,W
06A9C:  ADDLW  DC
06A9E:  MOVWF  01
06AA0:  MOVLW  01
06AA2:  ADDWFC 03,F
06AA4:  MOVFF  01,670
06AA8:  MOVFF  03,671
06AAC:  MOVFF  03,698
06AB0:  MOVFF  01,697
06AB4:  CLRF   x9A
06AB6:  CLRF   x99
06AB8:  MOVLW  0A
06ABA:  MOVWF  x9B
06ABC:  MOVLB  0
06ABE:  RCALL  65F8
06AC0:  MOVFF  01,66F
....................    
....................    /*** GET CHANNEL MAP ***************/ 
....................    if      (0 == chMap[arg1-1]) sprintf(retData+strlen(retData), "%d,%c,", arg1, 'X');
06AC4:  MOVLW  01
06AC6:  MOVLB  6
06AC8:  SUBWF  x6F,W
06ACA:  MOVWF  x71
06ACC:  CLRF   x73
06ACE:  MOVLW  60
06AD0:  MOVWF  x72
06AD2:  MOVLB  0
06AD4:  CALL   5030
06AD8:  BTFSC  01.0
06ADA:  BRA    6B30
06ADC:  MOVLW  04
06ADE:  MOVLB  6
06AE0:  MOVWF  xA6
06AE2:  MOVLW  B2
06AE4:  MOVWF  xA5
06AE6:  MOVLB  0
06AE8:  RCALL  6390
06AEA:  MOVFF  02,03
06AEE:  MOVF   01,W
06AF0:  ADDLW  B2
06AF2:  MOVLB  6
06AF4:  MOVWF  x70
06AF6:  MOVLW  04
06AF8:  ADDWFC 02,W
06AFA:  MOVWF  x71
06AFC:  MOVFF  FE8,557
06B00:  MOVFF  670,556
06B04:  MOVFF  66F,698
06B08:  MOVLW  18
06B0A:  MOVWF  x99
06B0C:  MOVLB  0
06B0E:  RCALL  694C
06B10:  MOVLW  2C
06B12:  MOVLB  6
06B14:  MOVWF  xB4
06B16:  MOVLB  0
06B18:  RCALL  6440
06B1A:  MOVLW  58
06B1C:  MOVLB  6
06B1E:  MOVWF  xB4
06B20:  MOVLB  0
06B22:  RCALL  6440
06B24:  MOVLW  2C
06B26:  MOVLB  6
06B28:  MOVWF  xB4
06B2A:  MOVLB  0
06B2C:  RCALL  6440
06B2E:  BRA    6BA2
....................    else if (1 == chMap[arg1-1]) sprintf(retData+strlen(retData), "%d,%c,", arg1, 'Y');
06B30:  MOVLW  01
06B32:  MOVLB  6
06B34:  SUBWF  x6F,W
06B36:  MOVWF  x71
06B38:  CLRF   x73
06B3A:  MOVLW  60
06B3C:  MOVWF  x72
06B3E:  MOVLB  0
06B40:  CALL   5030
06B44:  BTFSS  01.0
06B46:  BRA    6B9C
06B48:  MOVLW  04
06B4A:  MOVLB  6
06B4C:  MOVWF  xA6
06B4E:  MOVLW  B2
06B50:  MOVWF  xA5
06B52:  MOVLB  0
06B54:  RCALL  6390
06B56:  MOVFF  02,03
06B5A:  MOVF   01,W
06B5C:  ADDLW  B2
06B5E:  MOVLB  6
06B60:  MOVWF  x70
06B62:  MOVLW  04
06B64:  ADDWFC 02,W
06B66:  MOVWF  x71
06B68:  MOVFF  FE8,557
06B6C:  MOVFF  670,556
06B70:  MOVFF  66F,698
06B74:  MOVLW  18
06B76:  MOVWF  x99
06B78:  MOVLB  0
06B7A:  RCALL  694C
06B7C:  MOVLW  2C
06B7E:  MOVLB  6
06B80:  MOVWF  xB4
06B82:  MOVLB  0
06B84:  RCALL  6440
06B86:  MOVLW  59
06B88:  MOVLB  6
06B8A:  MOVWF  xB4
06B8C:  MOVLB  0
06B8E:  RCALL  6440
06B90:  MOVLW  2C
06B92:  MOVLB  6
06B94:  MOVWF  xB4
06B96:  MOVLB  0
06B98:  RCALL  6440
06B9A:  BRA    6BA2
....................    else return INV_PARAM;
06B9C:  MOVLW  02
06B9E:  MOVWF  01
06BA0:  BRA    6BA6
....................    
....................    return SUCCESS;
06BA2:  MOVLW  00
06BA4:  MOVWF  01
06BA6:  RETURN 0
.................... }
.................... 
.................... int8 setOPchMap(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
06BEA:  MOVLB  6
06BEC:  CLRF   xB1
06BEE:  MOVFF  663,6B0
06BF2:  CLRF   xB3
06BF4:  MOVLW  B5
06BF6:  MOVWF  xB2
06BF8:  MOVLB  0
06BFA:  CALL   07F0
06BFE:  MOVFF  02,672
06C02:  MOVFF  01,671
06C06:  MOVLW  06
06C08:  MOVLB  6
06C0A:  ADDWF  x71,F
06C0C:  MOVLW  00
06C0E:  ADDWFC x72,F
06C10:  MOVLW  32
06C12:  ADDWF  x71,W
06C14:  MOVWF  01
06C16:  MOVLW  00
06C18:  ADDWFC x72,W
06C1A:  MOVWF  03
06C1C:  MOVF   01,W
06C1E:  ADDLW  DC
06C20:  MOVWF  01
06C22:  MOVLW  01
06C24:  ADDWFC 03,F
06C26:  MOVFF  01,671
06C2A:  MOVFF  03,672
06C2E:  MOVFF  03,698
06C32:  MOVFF  01,697
06C36:  MOVLB  0
06C38:  RCALL  6508
06C3A:  MOVF   01,F
06C3C:  BNZ   6C46
06C3E:  MOVLW  02
06C40:  MOVWF  01
06C42:  BRA    6D96
06C44:  BRA    6CA2
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06C46:  MOVLB  6
06C48:  CLRF   xB1
06C4A:  MOVFF  663,6B0
06C4E:  CLRF   xB3
06C50:  MOVLW  B5
06C52:  MOVWF  xB2
06C54:  MOVLB  0
06C56:  CALL   07F0
06C5A:  MOVFF  02,672
06C5E:  MOVFF  01,671
06C62:  MOVLW  06
06C64:  MOVLB  6
06C66:  ADDWF  x71,F
06C68:  MOVLW  00
06C6A:  ADDWFC x72,F
06C6C:  MOVLW  32
06C6E:  ADDWF  x71,W
06C70:  MOVWF  01
06C72:  MOVLW  00
06C74:  ADDWFC x72,W
06C76:  MOVWF  03
06C78:  MOVF   01,W
06C7A:  ADDLW  DC
06C7C:  MOVWF  01
06C7E:  MOVLW  01
06C80:  ADDWFC 03,F
06C82:  MOVFF  01,671
06C86:  MOVFF  03,672
06C8A:  MOVFF  03,698
06C8E:  MOVFF  01,697
06C92:  CLRF   x9A
06C94:  CLRF   x99
06C96:  MOVLW  0A
06C98:  MOVWF  x9B
06C9A:  MOVLB  0
06C9C:  RCALL  65F8
06C9E:  MOVFF  01,66F
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
06CA2:  MOVLB  6
06CA4:  CLRF   xB1
06CA6:  MOVFF  663,6B0
06CAA:  CLRF   xB3
06CAC:  MOVLW  B5
06CAE:  MOVWF  xB2
06CB0:  MOVLB  0
06CB2:  CALL   07F0
06CB6:  MOVFF  02,672
06CBA:  MOVFF  01,671
06CBE:  MOVLW  06
06CC0:  MOVLB  6
06CC2:  ADDWF  x71,F
06CC4:  MOVLW  00
06CC6:  ADDWFC x72,F
06CC8:  MOVLW  4B
06CCA:  ADDWF  x71,W
06CCC:  MOVWF  01
06CCE:  MOVLW  00
06CD0:  ADDWFC x72,W
06CD2:  MOVWF  03
06CD4:  MOVF   01,W
06CD6:  ADDLW  DC
06CD8:  MOVWF  01
06CDA:  MOVLW  01
06CDC:  ADDWFC 03,F
06CDE:  MOVFF  01,671
06CE2:  MOVFF  03,672
06CE6:  MOVFF  03,6A6
06CEA:  MOVFF  01,6A5
06CEE:  MOVLB  0
06CF0:  CALL   6390
06CF4:  MOVFF  02,03
06CF8:  MOVF   01,W
06CFA:  SUBLW  01
06CFC:  BNZ   6D02
06CFE:  MOVF   03,F
06D00:  BZ    6D0A
06D02:  MOVLW  02
06D04:  MOVWF  01
06D06:  BRA    6D96
06D08:  BRA    6D4A
....................    else arg2 = SERcmd[rec].p[3][0];
06D0A:  MOVLB  6
06D0C:  CLRF   xB1
06D0E:  MOVFF  663,6B0
06D12:  CLRF   xB3
06D14:  MOVLW  B5
06D16:  MOVWF  xB2
06D18:  MOVLB  0
06D1A:  CALL   07F0
06D1E:  MOVFF  02,672
06D22:  MOVFF  01,671
06D26:  MOVLW  06
06D28:  MOVLB  6
06D2A:  ADDWF  x71,F
06D2C:  MOVLW  00
06D2E:  ADDWFC x72,F
06D30:  MOVLW  4B
06D32:  ADDWF  x71,F
06D34:  MOVLW  00
06D36:  ADDWFC x72,F
06D38:  MOVLW  DC
06D3A:  ADDWF  x71,W
06D3C:  MOVWF  FE9
06D3E:  MOVLW  01
06D40:  ADDWFC x72,W
06D42:  MOVWF  FEA
06D44:  MOVFF  FEF,670
06D48:  MOVLB  0
....................    
....................    /*** SET CHANNEL MAP ***************/
....................    if      ('X' == arg2) chMap[arg1-1] = chX;
06D4A:  MOVLB  6
06D4C:  MOVF   x70,W
06D4E:  SUBLW  58
06D50:  BNZ   6D6A
06D52:  MOVLW  01
06D54:  SUBWF  x6F,W
06D56:  MOVWF  x71
06D58:  MOVWF  x86
06D5A:  CLRF   x87
06D5C:  CLRF   x89
06D5E:  MOVLW  60
06D60:  MOVWF  x88
06D62:  MOVLB  0
06D64:  RCALL  6BA8
06D66:  BRA    6D92
06D68:  MOVLB  6
....................    else if ('Y' == arg2) chMap[arg1-1] = chY;
06D6A:  MOVF   x70,W
06D6C:  SUBLW  59
06D6E:  BNZ   6D8A
06D70:  MOVLW  01
06D72:  SUBWF  x6F,W
06D74:  MOVWF  x71
06D76:  MOVWF  x86
06D78:  MOVLW  01
06D7A:  MOVWF  x87
06D7C:  CLRF   x89
06D7E:  MOVLW  60
06D80:  MOVWF  x88
06D82:  MOVLB  0
06D84:  RCALL  6BA8
06D86:  BRA    6D92
06D88:  MOVLB  6
....................    else return INV_PARAM;
06D8A:  MOVLW  02
06D8C:  MOVWF  01
06D8E:  MOVLB  0
06D90:  BRA    6D96
....................    
....................    return SUCCESS;
06D92:  MOVLW  00
06D94:  MOVWF  01
06D96:  RETURN 0
.................... }
.................... 
.................... int8 getIPchMode(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
06DC2:  MOVLB  6
06DC4:  CLRF   xB1
06DC6:  MOVFF  663,6B0
06DCA:  CLRF   xB3
06DCC:  MOVLW  B5
06DCE:  MOVWF  xB2
06DD0:  MOVLB  0
06DD2:  CALL   07F0
06DD6:  MOVFF  02,671
06DDA:  MOVFF  01,670
06DDE:  MOVLW  06
06DE0:  MOVLB  6
06DE2:  ADDWF  x70,F
06DE4:  MOVLW  00
06DE6:  ADDWFC x71,F
06DE8:  MOVLW  32
06DEA:  ADDWF  x70,W
06DEC:  MOVWF  01
06DEE:  MOVLW  00
06DF0:  ADDWFC x71,W
06DF2:  MOVWF  03
06DF4:  MOVF   01,W
06DF6:  ADDLW  DC
06DF8:  MOVWF  01
06DFA:  MOVLW  01
06DFC:  ADDWFC 03,F
06DFE:  MOVFF  01,670
06E02:  MOVFF  03,671
06E06:  MOVFF  03,698
06E0A:  MOVFF  01,697
06E0E:  MOVLB  0
06E10:  CALL   6508
06E14:  MOVF   01,F
06E16:  BNZ   6E20
06E18:  MOVLW  02
06E1A:  MOVWF  01
06E1C:  BRA    6F4C
06E1E:  BRA    6E7E
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06E20:  MOVLB  6
06E22:  CLRF   xB1
06E24:  MOVFF  663,6B0
06E28:  CLRF   xB3
06E2A:  MOVLW  B5
06E2C:  MOVWF  xB2
06E2E:  MOVLB  0
06E30:  CALL   07F0
06E34:  MOVFF  02,671
06E38:  MOVFF  01,670
06E3C:  MOVLW  06
06E3E:  MOVLB  6
06E40:  ADDWF  x70,F
06E42:  MOVLW  00
06E44:  ADDWFC x71,F
06E46:  MOVLW  32
06E48:  ADDWF  x70,W
06E4A:  MOVWF  01
06E4C:  MOVLW  00
06E4E:  ADDWFC x71,W
06E50:  MOVWF  03
06E52:  MOVF   01,W
06E54:  ADDLW  DC
06E56:  MOVWF  01
06E58:  MOVLW  01
06E5A:  ADDWFC 03,F
06E5C:  MOVFF  01,670
06E60:  MOVFF  03,671
06E64:  MOVFF  03,698
06E68:  MOVFF  01,697
06E6C:  CLRF   x9A
06E6E:  CLRF   x99
06E70:  MOVLW  0A
06E72:  MOVWF  x9B
06E74:  MOVLB  0
06E76:  CALL   65F8
06E7A:  MOVFF  01,66F
....................    
....................    /*** GET INPUT MAP *****************/
....................    if      (0 == chMode[arg1-1]) sprintf(retData+strlen(retData), "%d,MANUAL,", arg1);
06E7E:  MOVLW  01
06E80:  MOVLB  6
06E82:  SUBWF  x6F,W
06E84:  MOVWF  x71
06E86:  CLRF   x73
06E88:  MOVLW  61
06E8A:  MOVWF  x72
06E8C:  MOVLB  0
06E8E:  CALL   5030
06E92:  BTFSC  01.0
06E94:  BRA    6EE0
06E96:  MOVLW  04
06E98:  MOVLB  6
06E9A:  MOVWF  xA6
06E9C:  MOVLW  B2
06E9E:  MOVWF  xA5
06EA0:  MOVLB  0
06EA2:  CALL   6390
06EA6:  MOVFF  02,03
06EAA:  MOVF   01,W
06EAC:  ADDLW  B2
06EAE:  MOVLB  6
06EB0:  MOVWF  x70
06EB2:  MOVLW  04
06EB4:  ADDWFC 02,W
06EB6:  MOVWF  x71
06EB8:  MOVFF  FE8,557
06EBC:  MOVFF  670,556
06EC0:  MOVFF  66F,698
06EC4:  MOVLW  18
06EC6:  MOVWF  x99
06EC8:  MOVLB  0
06ECA:  RCALL  694C
06ECC:  MOVLW  40
06ECE:  MOVWF  FF6
06ED0:  MOVLW  03
06ED2:  MOVWF  FF7
06ED4:  MOVLW  08
06ED6:  MOVLB  6
06ED8:  MOVWF  x73
06EDA:  MOVLB  0
06EDC:  RCALL  6D98
06EDE:  BRA    6F48
....................    else if (1 == chMode[arg1-1]) sprintf(retData+strlen(retData), "%d,MAGSNS,", arg1);
06EE0:  MOVLW  01
06EE2:  MOVLB  6
06EE4:  SUBWF  x6F,W
06EE6:  MOVWF  x71
06EE8:  CLRF   x73
06EEA:  MOVLW  61
06EEC:  MOVWF  x72
06EEE:  MOVLB  0
06EF0:  CALL   5030
06EF4:  BTFSS  01.0
06EF6:  BRA    6F42
06EF8:  MOVLW  04
06EFA:  MOVLB  6
06EFC:  MOVWF  xA6
06EFE:  MOVLW  B2
06F00:  MOVWF  xA5
06F02:  MOVLB  0
06F04:  CALL   6390
06F08:  MOVFF  02,03
06F0C:  MOVF   01,W
06F0E:  ADDLW  B2
06F10:  MOVLB  6
06F12:  MOVWF  x70
06F14:  MOVLW  04
06F16:  ADDWFC 02,W
06F18:  MOVWF  x71
06F1A:  MOVFF  FE8,557
06F1E:  MOVFF  670,556
06F22:  MOVFF  66F,698
06F26:  MOVLW  18
06F28:  MOVWF  x99
06F2A:  MOVLB  0
06F2C:  RCALL  694C
06F2E:  MOVLW  4C
06F30:  MOVWF  FF6
06F32:  MOVLW  03
06F34:  MOVWF  FF7
06F36:  MOVLW  08
06F38:  MOVLB  6
06F3A:  MOVWF  x73
06F3C:  MOVLB  0
06F3E:  RCALL  6D98
06F40:  BRA    6F48
....................    else return INV_PARAM;
06F42:  MOVLW  02
06F44:  MOVWF  01
06F46:  BRA    6F4C
....................    
....................    return SUCCESS;
06F48:  MOVLW  00
06F4A:  MOVWF  01
06F4C:  RETURN 0
.................... }
.................... 
.................... int8 setIPchMode(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char *arg2;
....................    char *s_manual = "MANUAL";
06F4E:  MOVLW  4D
06F50:  MOVLB  6
06F52:  MOVWF  x74
06F54:  MOVLW  41
06F56:  MOVWF  x75
06F58:  MOVLW  4E
06F5A:  MOVWF  x76
06F5C:  MOVLW  55
06F5E:  MOVWF  x77
06F60:  MOVLW  41
06F62:  MOVWF  x78
06F64:  MOVLW  4C
06F66:  MOVWF  x79
06F68:  CLRF   x7A
06F6A:  MOVLW  06
06F6C:  MOVWF  x73
06F6E:  MOVLW  74
06F70:  MOVWF  x72
....................    char *s_magsns = "MAGSNS";
06F72:  MOVLW  4D
06F74:  MOVWF  x7D
06F76:  MOVLW  41
06F78:  MOVWF  x7E
06F7A:  MOVLW  47
06F7C:  MOVWF  x7F
06F7E:  MOVLW  53
06F80:  MOVWF  x80
06F82:  MOVLW  4E
06F84:  MOVWF  x81
06F86:  MOVLW  53
06F88:  MOVWF  x82
06F8A:  CLRF   x83
06F8C:  MOVLW  06
06F8E:  MOVWF  x7C
06F90:  MOVLW  7D
06F92:  MOVWF  x7B
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
06F94:  CLRF   xB1
06F96:  MOVFF  663,6B0
06F9A:  CLRF   xB3
06F9C:  MOVLW  B5
06F9E:  MOVWF  xB2
06FA0:  MOVLB  0
06FA2:  CALL   07F0
06FA6:  MOVFF  02,685
06FAA:  MOVFF  01,684
06FAE:  MOVLW  06
06FB0:  MOVLB  6
06FB2:  ADDWF  x84,F
06FB4:  MOVLW  00
06FB6:  ADDWFC x85,F
06FB8:  MOVLW  32
06FBA:  ADDWF  x84,W
06FBC:  MOVWF  01
06FBE:  MOVLW  00
06FC0:  ADDWFC x85,W
06FC2:  MOVWF  03
06FC4:  MOVF   01,W
06FC6:  ADDLW  DC
06FC8:  MOVWF  01
06FCA:  MOVLW  01
06FCC:  ADDWFC 03,F
06FCE:  MOVFF  01,684
06FD2:  MOVFF  03,685
06FD6:  MOVFF  03,698
06FDA:  MOVFF  01,697
06FDE:  MOVLB  0
06FE0:  CALL   6508
06FE4:  MOVF   01,F
06FE6:  BNZ   6FF0
06FE8:  MOVLW  02
06FEA:  MOVWF  01
06FEC:  BRA    7166
06FEE:  BRA    704E
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06FF0:  MOVLB  6
06FF2:  CLRF   xB1
06FF4:  MOVFF  663,6B0
06FF8:  CLRF   xB3
06FFA:  MOVLW  B5
06FFC:  MOVWF  xB2
06FFE:  MOVLB  0
07000:  CALL   07F0
07004:  MOVFF  02,685
07008:  MOVFF  01,684
0700C:  MOVLW  06
0700E:  MOVLB  6
07010:  ADDWF  x84,F
07012:  MOVLW  00
07014:  ADDWFC x85,F
07016:  MOVLW  32
07018:  ADDWF  x84,W
0701A:  MOVWF  01
0701C:  MOVLW  00
0701E:  ADDWFC x85,W
07020:  MOVWF  03
07022:  MOVF   01,W
07024:  ADDLW  DC
07026:  MOVWF  01
07028:  MOVLW  01
0702A:  ADDWFC 03,F
0702C:  MOVFF  01,684
07030:  MOVFF  03,685
07034:  MOVFF  03,698
07038:  MOVFF  01,697
0703C:  CLRF   x9A
0703E:  CLRF   x99
07040:  MOVLW  0A
07042:  MOVWF  x9B
07044:  MOVLB  0
07046:  CALL   65F8
0704A:  MOVFF  01,66F
....................    
....................    if (0 == strlen(SERcmd[rec].p[3])) return INV_PARAM;
0704E:  MOVLB  6
07050:  CLRF   xB1
07052:  MOVFF  663,6B0
07056:  CLRF   xB3
07058:  MOVLW  B5
0705A:  MOVWF  xB2
0705C:  MOVLB  0
0705E:  CALL   07F0
07062:  MOVFF  02,685
07066:  MOVFF  01,684
0706A:  MOVLW  06
0706C:  MOVLB  6
0706E:  ADDWF  x84,F
07070:  MOVLW  00
07072:  ADDWFC x85,F
07074:  MOVLW  4B
07076:  ADDWF  x84,W
07078:  MOVWF  01
0707A:  MOVLW  00
0707C:  ADDWFC x85,W
0707E:  MOVWF  03
07080:  MOVF   01,W
07082:  ADDLW  DC
07084:  MOVWF  01
07086:  MOVLW  01
07088:  ADDWFC 03,F
0708A:  MOVFF  01,684
0708E:  MOVFF  03,685
07092:  MOVFF  03,6A6
07096:  MOVFF  01,6A5
0709A:  MOVLB  0
0709C:  CALL   6390
070A0:  MOVFF  02,03
070A4:  MOVF   01,W
070A6:  BNZ   70B4
070A8:  MOVF   03,F
070AA:  BNZ   70B4
070AC:  MOVLW  02
070AE:  MOVWF  01
070B0:  BRA    7166
070B2:  BRA    70FA
....................    else arg2 = SERcmd[rec].p[3];
070B4:  MOVLB  6
070B6:  CLRF   xB1
070B8:  MOVFF  663,6B0
070BC:  CLRF   xB3
070BE:  MOVLW  B5
070C0:  MOVWF  xB2
070C2:  MOVLB  0
070C4:  CALL   07F0
070C8:  MOVFF  02,685
070CC:  MOVFF  01,684
070D0:  MOVLW  06
070D2:  MOVLB  6
070D4:  ADDWF  x84,F
070D6:  MOVLW  00
070D8:  ADDWFC x85,F
070DA:  MOVLW  4B
070DC:  ADDWF  x84,W
070DE:  MOVWF  01
070E0:  MOVLW  00
070E2:  ADDWFC x85,W
070E4:  MOVWF  03
070E6:  MOVF   01,W
070E8:  ADDLW  DC
070EA:  MOVWF  01
070EC:  MOVLW  01
070EE:  ADDWFC 03,F
070F0:  MOVFF  01,670
070F4:  MOVFF  03,671
070F8:  MOVLB  0
....................    
....................    /*** SET INPUT MAP *****************/
....................    if      (0 == strcmp(s_manual, arg2)) chMode[arg1-1] = MANUAL;
070FA:  MOVFF  673,6A6
070FE:  MOVFF  672,6A5
07102:  MOVFF  671,6A8
07106:  MOVFF  670,6A7
0710A:  CALL   63C8
0710E:  MOVF   01,F
07110:  BNZ   712A
07112:  MOVLW  01
07114:  MOVLB  6
07116:  SUBWF  x6F,W
07118:  MOVWF  x84
0711A:  MOVWF  x86
0711C:  CLRF   x87
0711E:  CLRF   x89
07120:  MOVLW  61
07122:  MOVWF  x88
07124:  MOVLB  0
07126:  RCALL  6BA8
07128:  BRA    7162
....................    else if (0 == strcmp(s_magsns, arg2)) chMode[arg1-1] = MAGSNS;
0712A:  MOVFF  67C,6A6
0712E:  MOVFF  67B,6A5
07132:  MOVFF  671,6A8
07136:  MOVFF  670,6A7
0713A:  CALL   63C8
0713E:  MOVF   01,F
07140:  BNZ   715C
07142:  MOVLW  01
07144:  MOVLB  6
07146:  SUBWF  x6F,W
07148:  MOVWF  x84
0714A:  MOVWF  x86
0714C:  MOVLW  01
0714E:  MOVWF  x87
07150:  CLRF   x89
07152:  MOVLW  61
07154:  MOVWF  x88
07156:  MOVLB  0
07158:  RCALL  6BA8
0715A:  BRA    7162
....................    else return INV_PARAM;
0715C:  MOVLW  02
0715E:  MOVWF  01
07160:  BRA    7166
....................    
....................    return SUCCESS;
07162:  MOVLW  00
07164:  MOVWF  01
07166:  RETURN 0
.................... }
.................... 
.................... int8 getPIDvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/ 
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
0731E:  MOVLB  6
07320:  CLRF   xB1
07322:  MOVFF  663,6B0
07326:  CLRF   xB3
07328:  MOVLW  B5
0732A:  MOVWF  xB2
0732C:  MOVLB  0
0732E:  CALL   07F0
07332:  MOVFF  02,672
07336:  MOVFF  01,671
0733A:  MOVLW  06
0733C:  MOVLB  6
0733E:  ADDWF  x71,F
07340:  MOVLW  00
07342:  ADDWFC x72,F
07344:  MOVLW  32
07346:  ADDWF  x71,W
07348:  MOVWF  01
0734A:  MOVLW  00
0734C:  ADDWFC x72,W
0734E:  MOVWF  03
07350:  MOVF   01,W
07352:  ADDLW  DC
07354:  MOVWF  01
07356:  MOVLW  01
07358:  ADDWFC 03,F
0735A:  MOVFF  01,671
0735E:  MOVFF  03,672
07362:  MOVFF  03,698
07366:  MOVFF  01,697
0736A:  MOVLB  0
0736C:  CALL   6508
07370:  MOVF   01,F
07372:  BNZ   737C
07374:  MOVLW  02
07376:  MOVWF  01
07378:  BRA    77D2
0737A:  BRA    73DA
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
0737C:  MOVLB  6
0737E:  CLRF   xB1
07380:  MOVFF  663,6B0
07384:  CLRF   xB3
07386:  MOVLW  B5
07388:  MOVWF  xB2
0738A:  MOVLB  0
0738C:  CALL   07F0
07390:  MOVFF  02,672
07394:  MOVFF  01,671
07398:  MOVLW  06
0739A:  MOVLB  6
0739C:  ADDWF  x71,F
0739E:  MOVLW  00
073A0:  ADDWFC x72,F
073A2:  MOVLW  32
073A4:  ADDWF  x71,W
073A6:  MOVWF  01
073A8:  MOVLW  00
073AA:  ADDWFC x72,W
073AC:  MOVWF  03
073AE:  MOVF   01,W
073B0:  ADDLW  DC
073B2:  MOVWF  01
073B4:  MOVLW  01
073B6:  ADDWFC 03,F
073B8:  MOVFF  01,671
073BC:  MOVFF  03,672
073C0:  MOVFF  03,698
073C4:  MOVFF  01,697
073C8:  CLRF   x9A
073CA:  CLRF   x99
073CC:  MOVLW  0A
073CE:  MOVWF  x9B
073D0:  MOVLB  0
073D2:  CALL   65F8
073D6:  MOVFF  01,66F
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
073DA:  MOVLB  6
073DC:  CLRF   xB1
073DE:  MOVFF  663,6B0
073E2:  CLRF   xB3
073E4:  MOVLW  B5
073E6:  MOVWF  xB2
073E8:  MOVLB  0
073EA:  CALL   07F0
073EE:  MOVFF  02,672
073F2:  MOVFF  01,671
073F6:  MOVLW  06
073F8:  MOVLB  6
073FA:  ADDWF  x71,F
073FC:  MOVLW  00
073FE:  ADDWFC x72,F
07400:  MOVLW  4B
07402:  ADDWF  x71,W
07404:  MOVWF  01
07406:  MOVLW  00
07408:  ADDWFC x72,W
0740A:  MOVWF  03
0740C:  MOVF   01,W
0740E:  ADDLW  DC
07410:  MOVWF  01
07412:  MOVLW  01
07414:  ADDWFC 03,F
07416:  MOVFF  01,671
0741A:  MOVFF  03,672
0741E:  MOVFF  03,6A6
07422:  MOVFF  01,6A5
07426:  MOVLB  0
07428:  CALL   6390
0742C:  MOVFF  02,03
07430:  MOVF   01,W
07432:  SUBLW  01
07434:  BNZ   743A
07436:  MOVF   03,F
07438:  BZ    7442
0743A:  MOVLW  02
0743C:  MOVWF  01
0743E:  BRA    77D2
07440:  BRA    7482
....................    else arg2 = SERcmd[rec].p[3][0];
07442:  MOVLB  6
07444:  CLRF   xB1
07446:  MOVFF  663,6B0
0744A:  CLRF   xB3
0744C:  MOVLW  B5
0744E:  MOVWF  xB2
07450:  MOVLB  0
07452:  CALL   07F0
07456:  MOVFF  02,672
0745A:  MOVFF  01,671
0745E:  MOVLW  06
07460:  MOVLB  6
07462:  ADDWF  x71,F
07464:  MOVLW  00
07466:  ADDWFC x72,F
07468:  MOVLW  4B
0746A:  ADDWF  x71,F
0746C:  MOVLW  00
0746E:  ADDWFC x72,F
07470:  MOVLW  DC
07472:  ADDWF  x71,W
07474:  MOVWF  FE9
07476:  MOVLW  01
07478:  ADDWFC x72,W
0747A:  MOVWF  FEA
0747C:  MOVFF  FEF,670
07480:  MOVLB  0
....................    
....................    /*** GET P, I, D, or A(LL) VALUE **********/
....................    if      ('P' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kP);
07482:  MOVLB  6
07484:  MOVF   x70,W
07486:  SUBLW  50
07488:  BNZ   7522
0748A:  MOVLW  04
0748C:  MOVWF  xA6
0748E:  MOVLW  B2
07490:  MOVWF  xA5
07492:  MOVLB  0
07494:  CALL   6390
07498:  MOVFF  02,03
0749C:  MOVF   01,W
0749E:  ADDLW  B2
074A0:  MOVLB  6
074A2:  MOVWF  x71
074A4:  MOVLW  04
074A6:  ADDWFC 02,W
074A8:  MOVWF  x72
074AA:  MOVLW  01
074AC:  SUBWF  x6F,W
074AE:  MULLW  20
074B0:  MOVF   FF3,W
074B2:  CLRF   x74
074B4:  MOVWF  x73
074B6:  MOVLW  20
074B8:  ADDWF  x73,W
074BA:  MOVWF  FE9
074BC:  MOVLW  00
074BE:  ADDWFC x74,W
074C0:  MOVWF  FEA
074C2:  MOVFF  FEF,675
074C6:  MOVFF  FEC,676
074CA:  MOVFF  FEC,677
074CE:  MOVFF  FEC,678
074D2:  MOVFF  672,557
074D6:  MOVFF  671,556
074DA:  MOVFF  66F,698
074DE:  MOVLW  18
074E0:  MOVWF  x99
074E2:  MOVLB  0
074E4:  CALL   694C
074E8:  MOVLW  2C
074EA:  MOVLB  6
074EC:  MOVWF  xB4
074EE:  MOVLB  0
074F0:  CALL   6440
074F4:  MOVLW  89
074F6:  MOVWF  FE9
074F8:  MOVFF  678,6AA
074FC:  MOVFF  677,6A9
07500:  MOVFF  676,6A8
07504:  MOVFF  675,6A7
07508:  MOVLW  02
0750A:  MOVLB  6
0750C:  MOVWF  xAB
0750E:  MOVLB  0
07510:  RCALL  7168
07512:  MOVLW  2C
07514:  MOVLB  6
07516:  MOVWF  xB4
07518:  MOVLB  0
0751A:  CALL   6440
0751E:  BRA    77CE
07520:  MOVLB  6
....................    else if ('I' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kI);
07522:  MOVF   x70,W
07524:  SUBLW  49
07526:  BNZ   75C8
07528:  MOVLW  04
0752A:  MOVWF  xA6
0752C:  MOVLW  B2
0752E:  MOVWF  xA5
07530:  MOVLB  0
07532:  CALL   6390
07536:  MOVF   01,W
07538:  ADDLW  B2
0753A:  MOVLB  6
0753C:  MOVWF  x71
0753E:  MOVLW  04
07540:  ADDWFC 02,W
07542:  MOVWF  x72
07544:  MOVLW  01
07546:  SUBWF  x6F,W
07548:  MULLW  20
0754A:  MOVF   FF3,W
0754C:  CLRF   x74
0754E:  MOVWF  x73
07550:  MOVLW  04
07552:  ADDWF  x73,W
07554:  MOVWF  01
07556:  MOVLW  00
07558:  ADDWFC x74,W
0755A:  MOVWF  03
0755C:  MOVF   01,W
0755E:  ADDLW  20
07560:  MOVWF  FE9
07562:  MOVLW  00
07564:  ADDWFC 03,W
07566:  MOVWF  FEA
07568:  MOVFF  FEF,673
0756C:  MOVFF  FEC,674
07570:  MOVFF  FEC,675
07574:  MOVFF  FEC,676
07578:  MOVFF  672,557
0757C:  MOVFF  671,556
07580:  MOVFF  66F,698
07584:  MOVLW  18
07586:  MOVWF  x99
07588:  MOVLB  0
0758A:  CALL   694C
0758E:  MOVLW  2C
07590:  MOVLB  6
07592:  MOVWF  xB4
07594:  MOVLB  0
07596:  CALL   6440
0759A:  MOVLW  89
0759C:  MOVWF  FE9
0759E:  MOVFF  676,6AA
075A2:  MOVFF  675,6A9
075A6:  MOVFF  674,6A8
075AA:  MOVFF  673,6A7
075AE:  MOVLW  02
075B0:  MOVLB  6
075B2:  MOVWF  xAB
075B4:  MOVLB  0
075B6:  RCALL  7168
075B8:  MOVLW  2C
075BA:  MOVLB  6
075BC:  MOVWF  xB4
075BE:  MOVLB  0
075C0:  CALL   6440
075C4:  BRA    77CE
075C6:  MOVLB  6
....................    else if ('D' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kD);
075C8:  MOVF   x70,W
075CA:  SUBLW  44
075CC:  BNZ   766E
075CE:  MOVLW  04
075D0:  MOVWF  xA6
075D2:  MOVLW  B2
075D4:  MOVWF  xA5
075D6:  MOVLB  0
075D8:  CALL   6390
075DC:  MOVF   01,W
075DE:  ADDLW  B2
075E0:  MOVLB  6
075E2:  MOVWF  x71
075E4:  MOVLW  04
075E6:  ADDWFC 02,W
075E8:  MOVWF  x72
075EA:  MOVLW  01
075EC:  SUBWF  x6F,W
075EE:  MULLW  20
075F0:  MOVF   FF3,W
075F2:  CLRF   x74
075F4:  MOVWF  x73
075F6:  MOVLW  08
075F8:  ADDWF  x73,W
075FA:  MOVWF  01
075FC:  MOVLW  00
075FE:  ADDWFC x74,W
07600:  MOVWF  03
07602:  MOVF   01,W
07604:  ADDLW  20
07606:  MOVWF  FE9
07608:  MOVLW  00
0760A:  ADDWFC 03,W
0760C:  MOVWF  FEA
0760E:  MOVFF  FEF,673
07612:  MOVFF  FEC,674
07616:  MOVFF  FEC,675
0761A:  MOVFF  FEC,676
0761E:  MOVFF  672,557
07622:  MOVFF  671,556
07626:  MOVFF  66F,698
0762A:  MOVLW  18
0762C:  MOVWF  x99
0762E:  MOVLB  0
07630:  CALL   694C
07634:  MOVLW  2C
07636:  MOVLB  6
07638:  MOVWF  xB4
0763A:  MOVLB  0
0763C:  CALL   6440
07640:  MOVLW  89
07642:  MOVWF  FE9
07644:  MOVFF  676,6AA
07648:  MOVFF  675,6A9
0764C:  MOVFF  674,6A8
07650:  MOVFF  673,6A7
07654:  MOVLW  02
07656:  MOVLB  6
07658:  MOVWF  xAB
0765A:  MOVLB  0
0765C:  RCALL  7168
0765E:  MOVLW  2C
07660:  MOVLB  6
07662:  MOVWF  xB4
07664:  MOVLB  0
07666:  CALL   6440
0766A:  BRA    77CE
0766C:  MOVLB  6
....................    else if ('A' == arg2) sprintf(retData+strlen(retData), "%d,%f,%f,%f,", arg1, PID[arg1-1].kP, PID[arg1-1].kI, PID[arg1-1].kD);
0766E:  MOVF   x70,W
07670:  SUBLW  41
07672:  BTFSS  FD8.2
07674:  BRA    77C6
07676:  MOVLW  04
07678:  MOVWF  xA6
0767A:  MOVLW  B2
0767C:  MOVWF  xA5
0767E:  MOVLB  0
07680:  CALL   6390
07684:  MOVF   01,W
07686:  ADDLW  B2
07688:  MOVLB  6
0768A:  MOVWF  x71
0768C:  MOVLW  04
0768E:  ADDWFC 02,W
07690:  MOVWF  x72
07692:  MOVLW  01
07694:  SUBWF  x6F,W
07696:  MULLW  20
07698:  MOVF   FF3,W
0769A:  CLRF   x74
0769C:  MOVWF  x73
0769E:  MOVLW  20
076A0:  ADDWF  x73,W
076A2:  MOVWF  FE9
076A4:  MOVLW  00
076A6:  ADDWFC x74,W
076A8:  MOVWF  FEA
076AA:  MOVFF  FEF,675
076AE:  MOVFF  FEC,676
076B2:  MOVFF  FEC,677
076B6:  MOVFF  FEC,678
076BA:  MOVLW  01
076BC:  SUBWF  x6F,W
076BE:  MULLW  20
076C0:  MOVF   FF3,W
076C2:  CLRF   x7A
076C4:  MOVWF  x79
076C6:  MOVLW  04
076C8:  ADDWF  x79,W
076CA:  MOVWF  01
076CC:  MOVLW  00
076CE:  ADDWFC x7A,W
076D0:  MOVWF  03
076D2:  MOVF   01,W
076D4:  ADDLW  20
076D6:  MOVWF  FE9
076D8:  MOVLW  00
076DA:  ADDWFC 03,W
076DC:  MOVWF  FEA
076DE:  MOVFF  FEF,679
076E2:  MOVFF  FEC,67A
076E6:  MOVFF  FEC,67B
076EA:  MOVFF  FEC,67C
076EE:  MOVLW  01
076F0:  SUBWF  x6F,W
076F2:  MULLW  20
076F4:  MOVF   FF3,W
076F6:  CLRF   x7E
076F8:  MOVWF  x7D
076FA:  MOVLW  08
076FC:  ADDWF  x7D,W
076FE:  MOVWF  01
07700:  MOVLW  00
07702:  ADDWFC x7E,W
07704:  MOVWF  03
07706:  MOVF   01,W
07708:  ADDLW  20
0770A:  MOVWF  FE9
0770C:  MOVLW  00
0770E:  ADDWFC 03,W
07710:  MOVWF  FEA
07712:  MOVFF  FEF,67D
07716:  MOVFF  FEC,67E
0771A:  MOVFF  FEC,67F
0771E:  MOVFF  FEC,680
07722:  MOVFF  672,557
07726:  MOVFF  671,556
0772A:  MOVFF  66F,698
0772E:  MOVLW  18
07730:  MOVWF  x99
07732:  MOVLB  0
07734:  CALL   694C
07738:  MOVLW  2C
0773A:  MOVLB  6
0773C:  MOVWF  xB4
0773E:  MOVLB  0
07740:  CALL   6440
07744:  MOVLW  89
07746:  MOVWF  FE9
07748:  MOVFF  678,6AA
0774C:  MOVFF  677,6A9
07750:  MOVFF  676,6A8
07754:  MOVFF  675,6A7
07758:  MOVLW  02
0775A:  MOVLB  6
0775C:  MOVWF  xAB
0775E:  MOVLB  0
07760:  RCALL  7168
07762:  MOVLW  2C
07764:  MOVLB  6
07766:  MOVWF  xB4
07768:  MOVLB  0
0776A:  CALL   6440
0776E:  MOVLW  89
07770:  MOVWF  FE9
07772:  MOVFF  67C,6AA
07776:  MOVFF  67B,6A9
0777A:  MOVFF  67A,6A8
0777E:  MOVFF  679,6A7
07782:  MOVLW  02
07784:  MOVLB  6
07786:  MOVWF  xAB
07788:  MOVLB  0
0778A:  RCALL  7168
0778C:  MOVLW  2C
0778E:  MOVLB  6
07790:  MOVWF  xB4
07792:  MOVLB  0
07794:  CALL   6440
07798:  MOVLW  89
0779A:  MOVWF  FE9
0779C:  MOVFF  680,6AA
077A0:  MOVFF  67F,6A9
077A4:  MOVFF  67E,6A8
077A8:  MOVFF  67D,6A7
077AC:  MOVLW  02
077AE:  MOVLB  6
077B0:  MOVWF  xAB
077B2:  MOVLB  0
077B4:  RCALL  7168
077B6:  MOVLW  2C
077B8:  MOVLB  6
077BA:  MOVWF  xB4
077BC:  MOVLB  0
077BE:  CALL   6440
077C2:  BRA    77CE
077C4:  MOVLB  6
....................    else return INV_PARAM;
077C6:  MOVLW  02
077C8:  MOVWF  01
077CA:  MOVLB  0
077CC:  BRA    77D2
....................    
....................    return SUCCESS;
077CE:  MOVLW  00
077D0:  MOVWF  01
077D2:  RETURN 0
.................... }
.................... 
.................... int8 setPIDvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char  arg2;
....................    float arg3;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
07AF0:  MOVLB  6
07AF2:  CLRF   xB1
07AF4:  MOVFF  663,6B0
07AF8:  CLRF   xB3
07AFA:  MOVLW  B5
07AFC:  MOVWF  xB2
07AFE:  MOVLB  0
07B00:  CALL   07F0
07B04:  MOVFF  02,676
07B08:  MOVFF  01,675
07B0C:  MOVLW  06
07B0E:  MOVLB  6
07B10:  ADDWF  x75,F
07B12:  MOVLW  00
07B14:  ADDWFC x76,F
07B16:  MOVLW  32
07B18:  ADDWF  x75,W
07B1A:  MOVWF  01
07B1C:  MOVLW  00
07B1E:  ADDWFC x76,W
07B20:  MOVWF  03
07B22:  MOVF   01,W
07B24:  ADDLW  DC
07B26:  MOVWF  01
07B28:  MOVLW  01
07B2A:  ADDWFC 03,F
07B2C:  MOVFF  01,675
07B30:  MOVFF  03,676
07B34:  MOVFF  03,698
07B38:  MOVFF  01,697
07B3C:  MOVLB  0
07B3E:  CALL   6508
07B42:  MOVF   01,F
07B44:  BNZ   7B4E
07B46:  MOVLW  02
07B48:  MOVWF  01
07B4A:  BRA    7DCE
07B4C:  BRA    7BAC
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07B4E:  MOVLB  6
07B50:  CLRF   xB1
07B52:  MOVFF  663,6B0
07B56:  CLRF   xB3
07B58:  MOVLW  B5
07B5A:  MOVWF  xB2
07B5C:  MOVLB  0
07B5E:  CALL   07F0
07B62:  MOVFF  02,676
07B66:  MOVFF  01,675
07B6A:  MOVLW  06
07B6C:  MOVLB  6
07B6E:  ADDWF  x75,F
07B70:  MOVLW  00
07B72:  ADDWFC x76,F
07B74:  MOVLW  32
07B76:  ADDWF  x75,W
07B78:  MOVWF  01
07B7A:  MOVLW  00
07B7C:  ADDWFC x76,W
07B7E:  MOVWF  03
07B80:  MOVF   01,W
07B82:  ADDLW  DC
07B84:  MOVWF  01
07B86:  MOVLW  01
07B88:  ADDWFC 03,F
07B8A:  MOVFF  01,675
07B8E:  MOVFF  03,676
07B92:  MOVFF  03,698
07B96:  MOVFF  01,697
07B9A:  CLRF   x9A
07B9C:  CLRF   x99
07B9E:  MOVLW  0A
07BA0:  MOVWF  x9B
07BA2:  MOVLB  0
07BA4:  CALL   65F8
07BA8:  MOVFF  01,66F
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
07BAC:  MOVLB  6
07BAE:  CLRF   xB1
07BB0:  MOVFF  663,6B0
07BB4:  CLRF   xB3
07BB6:  MOVLW  B5
07BB8:  MOVWF  xB2
07BBA:  MOVLB  0
07BBC:  CALL   07F0
07BC0:  MOVFF  02,676
07BC4:  MOVFF  01,675
07BC8:  MOVLW  06
07BCA:  MOVLB  6
07BCC:  ADDWF  x75,F
07BCE:  MOVLW  00
07BD0:  ADDWFC x76,F
07BD2:  MOVLW  4B
07BD4:  ADDWF  x75,W
07BD6:  MOVWF  01
07BD8:  MOVLW  00
07BDA:  ADDWFC x76,W
07BDC:  MOVWF  03
07BDE:  MOVF   01,W
07BE0:  ADDLW  DC
07BE2:  MOVWF  01
07BE4:  MOVLW  01
07BE6:  ADDWFC 03,F
07BE8:  MOVFF  01,675
07BEC:  MOVFF  03,676
07BF0:  MOVFF  03,6A6
07BF4:  MOVFF  01,6A5
07BF8:  MOVLB  0
07BFA:  CALL   6390
07BFE:  MOVFF  02,03
07C02:  MOVF   01,W
07C04:  SUBLW  01
07C06:  BNZ   7C0C
07C08:  MOVF   03,F
07C0A:  BZ    7C14
07C0C:  MOVLW  02
07C0E:  MOVWF  01
07C10:  BRA    7DCE
07C12:  BRA    7C54
....................    else arg2 = SERcmd[rec].p[3][0];
07C14:  MOVLB  6
07C16:  CLRF   xB1
07C18:  MOVFF  663,6B0
07C1C:  CLRF   xB3
07C1E:  MOVLW  B5
07C20:  MOVWF  xB2
07C22:  MOVLB  0
07C24:  CALL   07F0
07C28:  MOVFF  02,676
07C2C:  MOVFF  01,675
07C30:  MOVLW  06
07C32:  MOVLB  6
07C34:  ADDWF  x75,F
07C36:  MOVLW  00
07C38:  ADDWFC x76,F
07C3A:  MOVLW  4B
07C3C:  ADDWF  x75,F
07C3E:  MOVLW  00
07C40:  ADDWFC x76,F
07C42:  MOVLW  DC
07C44:  ADDWF  x75,W
07C46:  MOVWF  FE9
07C48:  MOVLW  01
07C4A:  ADDWFC x76,W
07C4C:  MOVWF  FEA
07C4E:  MOVFF  FEF,670
07C52:  MOVLB  0
....................    
....................    if (!arg_is_float(SERcmd[rec].p[4])) return INV_PARAM;
07C54:  MOVLB  6
07C56:  CLRF   xB1
07C58:  MOVFF  663,6B0
07C5C:  CLRF   xB3
07C5E:  MOVLW  B5
07C60:  MOVWF  xB2
07C62:  MOVLB  0
07C64:  CALL   07F0
07C68:  MOVFF  02,676
07C6C:  MOVFF  01,675
07C70:  MOVLW  06
07C72:  MOVLB  6
07C74:  ADDWF  x75,F
07C76:  MOVLW  00
07C78:  ADDWFC x76,F
07C7A:  MOVLW  64
07C7C:  ADDWF  x75,W
07C7E:  MOVWF  01
07C80:  MOVLW  00
07C82:  ADDWFC x76,W
07C84:  MOVWF  03
07C86:  MOVF   01,W
07C88:  ADDLW  DC
07C8A:  MOVWF  01
07C8C:  MOVLW  01
07C8E:  ADDWFC 03,F
07C90:  MOVFF  01,675
07C94:  MOVFF  03,676
07C98:  MOVFF  03,679
07C9C:  MOVFF  01,678
07CA0:  MOVLB  0
07CA2:  RCALL  77D4
07CA4:  MOVF   01,F
07CA6:  BNZ   7CB0
07CA8:  MOVLW  02
07CAA:  MOVWF  01
07CAC:  BRA    7DCE
07CAE:  BRA    7D14
....................    else arg3 = strtod(SERcmd[rec].p[4], '\0');
07CB0:  MOVLB  6
07CB2:  CLRF   xB1
07CB4:  MOVFF  663,6B0
07CB8:  CLRF   xB3
07CBA:  MOVLW  B5
07CBC:  MOVWF  xB2
07CBE:  MOVLB  0
07CC0:  CALL   07F0
07CC4:  MOVFF  02,676
07CC8:  MOVFF  01,675
07CCC:  MOVLW  06
07CCE:  MOVLB  6
07CD0:  ADDWF  x75,F
07CD2:  MOVLW  00
07CD4:  ADDWFC x76,F
07CD6:  MOVLW  64
07CD8:  ADDWF  x75,W
07CDA:  MOVWF  01
07CDC:  MOVLW  00
07CDE:  ADDWFC x76,W
07CE0:  MOVWF  03
07CE2:  MOVF   01,W
07CE4:  ADDLW  DC
07CE6:  MOVWF  01
07CE8:  MOVLW  01
07CEA:  ADDWFC 03,F
07CEC:  MOVFF  01,675
07CF0:  MOVFF  03,676
07CF4:  MOVFF  03,679
07CF8:  MOVFF  01,678
07CFC:  CLRF   x7B
07CFE:  CLRF   x7A
07D00:  MOVLB  0
07D02:  RCALL  7896
07D04:  MOVFF  03,674
07D08:  MOVFF  02,673
07D0C:  MOVFF  01,672
07D10:  MOVFF  00,671
....................    
....................    /*** SET P, I, or D VALUE **********/
....................    if      ('P' == arg2) PID[arg1-1].kP = arg3;
07D14:  MOVLB  6
07D16:  MOVF   x70,W
07D18:  SUBLW  50
07D1A:  BNZ   7D46
07D1C:  MOVLW  01
07D1E:  SUBWF  x6F,W
07D20:  MULLW  20
07D22:  MOVF   FF3,W
07D24:  CLRF   x76
07D26:  MOVWF  x75
07D28:  MOVLW  20
07D2A:  ADDWF  x75,W
07D2C:  MOVWF  FE9
07D2E:  MOVLW  00
07D30:  ADDWFC x76,W
07D32:  MOVWF  FEA
07D34:  MOVFF  671,FEF
07D38:  MOVFF  672,FEC
07D3C:  MOVFF  673,FEC
07D40:  MOVFF  674,FEC
07D44:  BRA    7DC8
....................    else if ('I' == arg2) PID[arg1-1].kI = arg3;
07D46:  MOVF   x70,W
07D48:  SUBLW  49
07D4A:  BNZ   7D82
07D4C:  MOVLW  01
07D4E:  SUBWF  x6F,W
07D50:  MULLW  20
07D52:  MOVF   FF3,W
07D54:  CLRF   x76
07D56:  MOVWF  x75
07D58:  MOVLW  04
07D5A:  ADDWF  x75,W
07D5C:  MOVWF  01
07D5E:  MOVLW  00
07D60:  ADDWFC x76,W
07D62:  MOVWF  03
07D64:  MOVF   01,W
07D66:  ADDLW  20
07D68:  MOVWF  FE9
07D6A:  MOVLW  00
07D6C:  ADDWFC 03,W
07D6E:  MOVWF  FEA
07D70:  MOVFF  671,FEF
07D74:  MOVFF  672,FEC
07D78:  MOVFF  673,FEC
07D7C:  MOVFF  674,FEC
07D80:  BRA    7DC8
....................    else if ('D' == arg2) PID[arg1-1].kD = arg3;
07D82:  MOVF   x70,W
07D84:  SUBLW  44
07D86:  BNZ   7DBE
07D88:  MOVLW  01
07D8A:  SUBWF  x6F,W
07D8C:  MULLW  20
07D8E:  MOVF   FF3,W
07D90:  CLRF   x76
07D92:  MOVWF  x75
07D94:  MOVLW  08
07D96:  ADDWF  x75,W
07D98:  MOVWF  01
07D9A:  MOVLW  00
07D9C:  ADDWFC x76,W
07D9E:  MOVWF  03
07DA0:  MOVF   01,W
07DA2:  ADDLW  20
07DA4:  MOVWF  FE9
07DA6:  MOVLW  00
07DA8:  ADDWFC 03,W
07DAA:  MOVWF  FEA
07DAC:  MOVFF  671,FEF
07DB0:  MOVFF  672,FEC
07DB4:  MOVFF  673,FEC
07DB8:  MOVFF  674,FEC
07DBC:  BRA    7DC8
....................    else return INV_PARAM;
07DBE:  MOVLW  02
07DC0:  MOVWF  01
07DC2:  MOVLB  0
07DC4:  BRA    7DCE
07DC6:  MOVLB  6
....................    
....................    return SUCCESS;
07DC8:  MOVLW  00
07DCA:  MOVWF  01
07DCC:  MOVLB  0
07DCE:  RETURN 0
.................... }
.................... 
.................... //!int8 enablePID(unsigned int8 rec){
.................... //!   /*** ARG CHECKS ********************/
.................... //!   int8  arg1;
.................... //!   
.................... //!   if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
.................... //!   else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
.................... //!   
.................... //!   PID[arg1-1].enable = TRUE;
.................... //!   
.................... //!   return SUCCESS;
.................... //!}
.................... //!
.................... //!int8 disablePID(unsigned int8 rec){
.................... //!   /*** ARG CHECKS ********************/
.................... //!   int8  arg1;
.................... //!   
.................... //!   if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
.................... //!   else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
.................... //!   
.................... //!   PID[arg1-1].enable = FALSE;
.................... //!   
.................... //!   return SUCCESS;
.................... //!}
.................... 
.................... int8 getSetPoint(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
07DD0:  MOVLB  6
07DD2:  CLRF   xB1
07DD4:  MOVFF  663,6B0
07DD8:  CLRF   xB3
07DDA:  MOVLW  B5
07DDC:  MOVWF  xB2
07DDE:  MOVLB  0
07DE0:  CALL   07F0
07DE4:  MOVFF  02,671
07DE8:  MOVFF  01,670
07DEC:  MOVLW  06
07DEE:  MOVLB  6
07DF0:  ADDWF  x70,F
07DF2:  MOVLW  00
07DF4:  ADDWFC x71,F
07DF6:  MOVLW  32
07DF8:  ADDWF  x70,W
07DFA:  MOVWF  01
07DFC:  MOVLW  00
07DFE:  ADDWFC x71,W
07E00:  MOVWF  03
07E02:  MOVF   01,W
07E04:  ADDLW  DC
07E06:  MOVWF  01
07E08:  MOVLW  01
07E0A:  ADDWFC 03,F
07E0C:  MOVFF  01,670
07E10:  MOVFF  03,671
07E14:  MOVFF  03,698
07E18:  MOVFF  01,697
07E1C:  MOVLB  0
07E1E:  CALL   6508
07E22:  MOVF   01,F
07E24:  BNZ   7E2E
07E26:  MOVLW  02
07E28:  MOVWF  01
07E2A:  BRA    7F30
07E2C:  BRA    7E8C
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07E2E:  MOVLB  6
07E30:  CLRF   xB1
07E32:  MOVFF  663,6B0
07E36:  CLRF   xB3
07E38:  MOVLW  B5
07E3A:  MOVWF  xB2
07E3C:  MOVLB  0
07E3E:  CALL   07F0
07E42:  MOVFF  02,671
07E46:  MOVFF  01,670
07E4A:  MOVLW  06
07E4C:  MOVLB  6
07E4E:  ADDWF  x70,F
07E50:  MOVLW  00
07E52:  ADDWFC x71,F
07E54:  MOVLW  32
07E56:  ADDWF  x70,W
07E58:  MOVWF  01
07E5A:  MOVLW  00
07E5C:  ADDWFC x71,W
07E5E:  MOVWF  03
07E60:  MOVF   01,W
07E62:  ADDLW  DC
07E64:  MOVWF  01
07E66:  MOVLW  01
07E68:  ADDWFC 03,F
07E6A:  MOVFF  01,670
07E6E:  MOVFF  03,671
07E72:  MOVFF  03,698
07E76:  MOVFF  01,697
07E7A:  CLRF   x9A
07E7C:  CLRF   x99
07E7E:  MOVLW  0A
07E80:  MOVWF  x9B
07E82:  MOVLB  0
07E84:  CALL   65F8
07E88:  MOVFF  01,66F
....................    
....................    /*** GET SETPOINT ******************/ 
....................    sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].SP);
07E8C:  MOVLW  04
07E8E:  MOVLB  6
07E90:  MOVWF  xA6
07E92:  MOVLW  B2
07E94:  MOVWF  xA5
07E96:  MOVLB  0
07E98:  CALL   6390
07E9C:  MOVF   01,W
07E9E:  ADDLW  B2
07EA0:  MOVLB  6
07EA2:  MOVWF  x70
07EA4:  MOVLW  04
07EA6:  ADDWFC 02,W
07EA8:  MOVWF  x71
07EAA:  MOVLW  01
07EAC:  SUBWF  x6F,W
07EAE:  MULLW  20
07EB0:  MOVF   FF3,W
07EB2:  CLRF   x73
07EB4:  MOVWF  x72
07EB6:  MOVLW  0C
07EB8:  ADDWF  x72,W
07EBA:  MOVWF  01
07EBC:  MOVLW  00
07EBE:  ADDWFC x73,W
07EC0:  MOVWF  03
07EC2:  MOVF   01,W
07EC4:  ADDLW  20
07EC6:  MOVWF  FE9
07EC8:  MOVLW  00
07ECA:  ADDWFC 03,W
07ECC:  MOVWF  FEA
07ECE:  MOVFF  FEF,672
07ED2:  MOVFF  FEC,673
07ED6:  MOVFF  FEC,674
07EDA:  MOVFF  FEC,675
07EDE:  MOVFF  671,557
07EE2:  MOVFF  670,556
07EE6:  MOVFF  66F,698
07EEA:  MOVLW  18
07EEC:  MOVWF  x99
07EEE:  MOVLB  0
07EF0:  CALL   694C
07EF4:  MOVLW  2C
07EF6:  MOVLB  6
07EF8:  MOVWF  xB4
07EFA:  MOVLB  0
07EFC:  CALL   6440
07F00:  MOVLW  89
07F02:  MOVWF  FE9
07F04:  MOVFF  675,6AA
07F08:  MOVFF  674,6A9
07F0C:  MOVFF  673,6A8
07F10:  MOVFF  672,6A7
07F14:  MOVLW  02
07F16:  MOVLB  6
07F18:  MOVWF  xAB
07F1A:  MOVLB  0
07F1C:  CALL   7168
07F20:  MOVLW  2C
07F22:  MOVLB  6
07F24:  MOVWF  xB4
07F26:  MOVLB  0
07F28:  CALL   6440
....................    return SUCCESS;
07F2C:  MOVLW  00
07F2E:  MOVWF  01
07F30:  RETURN 0
.................... }
.................... 
.................... int8 setSetPoint(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/   
....................    int8  arg1;
....................    float arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
07F32:  MOVLB  6
07F34:  CLRF   xB1
07F36:  MOVFF  663,6B0
07F3A:  CLRF   xB3
07F3C:  MOVLW  B5
07F3E:  MOVWF  xB2
07F40:  MOVLB  0
07F42:  CALL   07F0
07F46:  MOVFF  02,675
07F4A:  MOVFF  01,674
07F4E:  MOVLW  06
07F50:  MOVLB  6
07F52:  ADDWF  x74,F
07F54:  MOVLW  00
07F56:  ADDWFC x75,F
07F58:  MOVLW  32
07F5A:  ADDWF  x74,W
07F5C:  MOVWF  01
07F5E:  MOVLW  00
07F60:  ADDWFC x75,W
07F62:  MOVWF  03
07F64:  MOVF   01,W
07F66:  ADDLW  DC
07F68:  MOVWF  01
07F6A:  MOVLW  01
07F6C:  ADDWFC 03,F
07F6E:  MOVFF  01,674
07F72:  MOVFF  03,675
07F76:  MOVFF  03,698
07F7A:  MOVFF  01,697
07F7E:  MOVLB  0
07F80:  CALL   6508
07F84:  MOVF   01,F
07F86:  BNZ   7F90
07F88:  MOVLW  02
07F8A:  MOVWF  01
07F8C:  BRA    80EE
07F8E:  BRA    7FEE
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07F90:  MOVLB  6
07F92:  CLRF   xB1
07F94:  MOVFF  663,6B0
07F98:  CLRF   xB3
07F9A:  MOVLW  B5
07F9C:  MOVWF  xB2
07F9E:  MOVLB  0
07FA0:  CALL   07F0
07FA4:  MOVFF  02,675
07FA8:  MOVFF  01,674
07FAC:  MOVLW  06
07FAE:  MOVLB  6
07FB0:  ADDWF  x74,F
07FB2:  MOVLW  00
07FB4:  ADDWFC x75,F
07FB6:  MOVLW  32
07FB8:  ADDWF  x74,W
07FBA:  MOVWF  01
07FBC:  MOVLW  00
07FBE:  ADDWFC x75,W
07FC0:  MOVWF  03
07FC2:  MOVF   01,W
07FC4:  ADDLW  DC
07FC6:  MOVWF  01
07FC8:  MOVLW  01
07FCA:  ADDWFC 03,F
07FCC:  MOVFF  01,674
07FD0:  MOVFF  03,675
07FD4:  MOVFF  03,698
07FD8:  MOVFF  01,697
07FDC:  CLRF   x9A
07FDE:  CLRF   x99
07FE0:  MOVLW  0A
07FE2:  MOVWF  x9B
07FE4:  MOVLB  0
07FE6:  CALL   65F8
07FEA:  MOVFF  01,66F
....................    
....................    if (!arg_is_float(SERcmd[rec].p[3])) return INV_PARAM;
07FEE:  MOVLB  6
07FF0:  CLRF   xB1
07FF2:  MOVFF  663,6B0
07FF6:  CLRF   xB3
07FF8:  MOVLW  B5
07FFA:  MOVWF  xB2
07FFC:  MOVLB  0
07FFE:  CALL   07F0
08002:  MOVFF  02,675
08006:  MOVFF  01,674
0800A:  MOVLW  06
0800C:  MOVLB  6
0800E:  ADDWF  x74,F
08010:  MOVLW  00
08012:  ADDWFC x75,F
08014:  MOVLW  4B
08016:  ADDWF  x74,W
08018:  MOVWF  01
0801A:  MOVLW  00
0801C:  ADDWFC x75,W
0801E:  MOVWF  03
08020:  MOVF   01,W
08022:  ADDLW  DC
08024:  MOVWF  01
08026:  MOVLW  01
08028:  ADDWFC 03,F
0802A:  MOVFF  01,674
0802E:  MOVFF  03,675
08032:  MOVFF  03,679
08036:  MOVFF  01,678
0803A:  MOVLB  0
0803C:  CALL   77D4
08040:  MOVF   01,F
08042:  BNZ   804C
08044:  MOVLW  02
08046:  MOVWF  01
08048:  BRA    80EE
0804A:  BRA    80B2
....................    else arg2 = strtod(SERcmd[rec].p[3], '\0');
0804C:  MOVLB  6
0804E:  CLRF   xB1
08050:  MOVFF  663,6B0
08054:  CLRF   xB3
08056:  MOVLW  B5
08058:  MOVWF  xB2
0805A:  MOVLB  0
0805C:  CALL   07F0
08060:  MOVFF  02,675
08064:  MOVFF  01,674
08068:  MOVLW  06
0806A:  MOVLB  6
0806C:  ADDWF  x74,F
0806E:  MOVLW  00
08070:  ADDWFC x75,F
08072:  MOVLW  4B
08074:  ADDWF  x74,W
08076:  MOVWF  01
08078:  MOVLW  00
0807A:  ADDWFC x75,W
0807C:  MOVWF  03
0807E:  MOVF   01,W
08080:  ADDLW  DC
08082:  MOVWF  01
08084:  MOVLW  01
08086:  ADDWFC 03,F
08088:  MOVFF  01,674
0808C:  MOVFF  03,675
08090:  MOVFF  03,679
08094:  MOVFF  01,678
08098:  CLRF   x7B
0809A:  CLRF   x7A
0809C:  MOVLB  0
0809E:  CALL   7896
080A2:  MOVFF  03,673
080A6:  MOVFF  02,672
080AA:  MOVFF  01,671
080AE:  MOVFF  00,670
....................    
....................    /*** SET SETPOINT ******************/ 
....................    PID[arg1-1].SP = arg2;
080B2:  MOVLW  01
080B4:  MOVLB  6
080B6:  SUBWF  x6F,W
080B8:  MULLW  20
080BA:  MOVF   FF3,W
080BC:  CLRF   x75
080BE:  MOVWF  x74
080C0:  MOVLW  0C
080C2:  ADDWF  x74,W
080C4:  MOVWF  01
080C6:  MOVLW  00
080C8:  ADDWFC x75,W
080CA:  MOVWF  03
080CC:  MOVF   01,W
080CE:  ADDLW  20
080D0:  MOVWF  FE9
080D2:  MOVLW  00
080D4:  ADDWFC 03,W
080D6:  MOVWF  FEA
080D8:  MOVFF  670,FEF
080DC:  MOVFF  671,FEC
080E0:  MOVFF  672,FEC
080E4:  MOVFF  673,FEC
....................    
....................    return SUCCESS;
080E8:  MOVLW  00
080EA:  MOVWF  01
080EC:  MOVLB  0
080EE:  RETURN 0
.................... }
.................... 
.................... int8 getAllSensorCalParams(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
080F0:  MOVLB  6
080F2:  CLRF   xB1
080F4:  MOVFF  663,6B0
080F8:  CLRF   xB3
080FA:  MOVLW  B5
080FC:  MOVWF  xB2
080FE:  MOVLB  0
08100:  CALL   07F0
08104:  MOVFF  02,671
08108:  MOVFF  01,670
0810C:  MOVLW  06
0810E:  MOVLB  6
08110:  ADDWF  x70,F
08112:  MOVLW  00
08114:  ADDWFC x71,F
08116:  MOVLW  32
08118:  ADDWF  x70,W
0811A:  MOVWF  01
0811C:  MOVLW  00
0811E:  ADDWFC x71,W
08120:  MOVWF  03
08122:  MOVF   01,W
08124:  ADDLW  DC
08126:  MOVWF  01
08128:  MOVLW  01
0812A:  ADDWFC 03,F
0812C:  MOVFF  01,670
08130:  MOVFF  03,671
08134:  MOVFF  03,698
08138:  MOVFF  01,697
0813C:  MOVLB  0
0813E:  CALL   6508
08142:  MOVF   01,F
08144:  BNZ   814E
08146:  MOVLW  02
08148:  MOVWF  01
0814A:  BRA    84A4
0814C:  BRA    81AC
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
0814E:  MOVLB  6
08150:  CLRF   xB1
08152:  MOVFF  663,6B0
08156:  CLRF   xB3
08158:  MOVLW  B5
0815A:  MOVWF  xB2
0815C:  MOVLB  0
0815E:  CALL   07F0
08162:  MOVFF  02,671
08166:  MOVFF  01,670
0816A:  MOVLW  06
0816C:  MOVLB  6
0816E:  ADDWF  x70,F
08170:  MOVLW  00
08172:  ADDWFC x71,F
08174:  MOVLW  32
08176:  ADDWF  x70,W
08178:  MOVWF  01
0817A:  MOVLW  00
0817C:  ADDWFC x71,W
0817E:  MOVWF  03
08180:  MOVF   01,W
08182:  ADDLW  DC
08184:  MOVWF  01
08186:  MOVLW  01
08188:  ADDWFC 03,F
0818A:  MOVFF  01,670
0818E:  MOVFF  03,671
08192:  MOVFF  03,698
08196:  MOVFF  01,697
0819A:  CLRF   x9A
0819C:  CLRF   x99
0819E:  MOVLW  0A
081A0:  MOVWF  x9B
081A2:  MOVLB  0
081A4:  CALL   65F8
081A8:  MOVFF  01,66F
....................    
....................    /*** GET ALL SENSOR CAL PARAMS *****/
....................    sprintf(retData+strlen(retData), "%d,", arg1);
081AC:  MOVLW  04
081AE:  MOVLB  6
081B0:  MOVWF  xA6
081B2:  MOVLW  B2
081B4:  MOVWF  xA5
081B6:  MOVLB  0
081B8:  CALL   6390
081BC:  MOVFF  02,03
081C0:  MOVF   01,W
081C2:  ADDLW  B2
081C4:  MOVLB  6
081C6:  MOVWF  x70
081C8:  MOVLW  04
081CA:  ADDWFC 02,W
081CC:  MOVWF  x71
081CE:  MOVFF  FE8,557
081D2:  MOVFF  670,556
081D6:  MOVFF  66F,698
081DA:  MOVLW  18
081DC:  MOVWF  x99
081DE:  MOVLB  0
081E0:  CALL   694C
081E4:  MOVLW  2C
081E6:  MOVLB  6
081E8:  MOVWF  xB4
081EA:  MOVLB  0
081EC:  CALL   6440
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c0);
081F0:  MOVLW  04
081F2:  MOVLB  6
081F4:  MOVWF  xA6
081F6:  MOVLW  B2
081F8:  MOVWF  xA5
081FA:  MOVLB  0
081FC:  CALL   6390
08200:  MOVFF  02,03
08204:  MOVF   01,W
08206:  ADDLW  B2
08208:  MOVLB  6
0820A:  MOVWF  x70
0820C:  MOVLW  04
0820E:  ADDWFC 02,W
08210:  MOVWF  x71
08212:  MOVLW  01
08214:  SUBWF  x6F,W
08216:  MULLW  18
08218:  MOVF   FF3,W
0821A:  CLRF   x73
0821C:  MOVWF  x72
0821E:  MOVLW  82
08220:  ADDWF  x72,W
08222:  MOVWF  FE9
08224:  MOVLW  00
08226:  ADDWFC x73,W
08228:  MOVWF  FEA
0822A:  MOVFF  FEF,6A7
0822E:  MOVFF  FEC,6A8
08232:  MOVFF  FEC,6A9
08236:  MOVFF  FEC,6AA
0823A:  MOVFF  671,557
0823E:  MOVFF  670,556
08242:  MOVLW  89
08244:  MOVWF  FE9
08246:  MOVLW  02
08248:  MOVWF  xAB
0824A:  MOVLB  0
0824C:  CALL   7168
08250:  MOVLW  2C
08252:  MOVLB  6
08254:  MOVWF  xB4
08256:  MOVLB  0
08258:  CALL   6440
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c1);
0825C:  MOVLW  04
0825E:  MOVLB  6
08260:  MOVWF  xA6
08262:  MOVLW  B2
08264:  MOVWF  xA5
08266:  MOVLB  0
08268:  CALL   6390
0826C:  MOVF   01,W
0826E:  ADDLW  B2
08270:  MOVLB  6
08272:  MOVWF  x70
08274:  MOVLW  04
08276:  ADDWFC 02,W
08278:  MOVWF  x71
0827A:  MOVLW  01
0827C:  SUBWF  x6F,W
0827E:  MULLW  18
08280:  MOVF   FF3,W
08282:  CLRF   x73
08284:  MOVWF  x72
08286:  MOVLW  04
08288:  ADDWF  x72,W
0828A:  MOVWF  01
0828C:  MOVLW  00
0828E:  ADDWFC x73,W
08290:  MOVWF  03
08292:  MOVF   01,W
08294:  ADDLW  82
08296:  MOVWF  FE9
08298:  MOVLW  00
0829A:  ADDWFC 03,W
0829C:  MOVWF  FEA
0829E:  MOVFF  FEF,6A7
082A2:  MOVFF  FEC,6A8
082A6:  MOVFF  FEC,6A9
082AA:  MOVFF  FEC,6AA
082AE:  MOVFF  671,557
082B2:  MOVFF  670,556
082B6:  MOVLW  89
082B8:  MOVWF  FE9
082BA:  MOVLW  02
082BC:  MOVWF  xAB
082BE:  MOVLB  0
082C0:  CALL   7168
082C4:  MOVLW  2C
082C6:  MOVLB  6
082C8:  MOVWF  xB4
082CA:  MOVLB  0
082CC:  CALL   6440
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c2);
082D0:  MOVLW  04
082D2:  MOVLB  6
082D4:  MOVWF  xA6
082D6:  MOVLW  B2
082D8:  MOVWF  xA5
082DA:  MOVLB  0
082DC:  CALL   6390
082E0:  MOVF   01,W
082E2:  ADDLW  B2
082E4:  MOVLB  6
082E6:  MOVWF  x70
082E8:  MOVLW  04
082EA:  ADDWFC 02,W
082EC:  MOVWF  x71
082EE:  MOVLW  01
082F0:  SUBWF  x6F,W
082F2:  MULLW  18
082F4:  MOVF   FF3,W
082F6:  CLRF   x73
082F8:  MOVWF  x72
082FA:  MOVLW  08
082FC:  ADDWF  x72,W
082FE:  MOVWF  01
08300:  MOVLW  00
08302:  ADDWFC x73,W
08304:  MOVWF  03
08306:  MOVF   01,W
08308:  ADDLW  82
0830A:  MOVWF  FE9
0830C:  MOVLW  00
0830E:  ADDWFC 03,W
08310:  MOVWF  FEA
08312:  MOVFF  FEF,6A7
08316:  MOVFF  FEC,6A8
0831A:  MOVFF  FEC,6A9
0831E:  MOVFF  FEC,6AA
08322:  MOVFF  671,557
08326:  MOVFF  670,556
0832A:  MOVLW  89
0832C:  MOVWF  FE9
0832E:  MOVLW  02
08330:  MOVWF  xAB
08332:  MOVLB  0
08334:  CALL   7168
08338:  MOVLW  2C
0833A:  MOVLB  6
0833C:  MOVWF  xB4
0833E:  MOVLB  0
08340:  CALL   6440
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c3);
08344:  MOVLW  04
08346:  MOVLB  6
08348:  MOVWF  xA6
0834A:  MOVLW  B2
0834C:  MOVWF  xA5
0834E:  MOVLB  0
08350:  CALL   6390
08354:  MOVF   01,W
08356:  ADDLW  B2
08358:  MOVLB  6
0835A:  MOVWF  x70
0835C:  MOVLW  04
0835E:  ADDWFC 02,W
08360:  MOVWF  x71
08362:  MOVLW  01
08364:  SUBWF  x6F,W
08366:  MULLW  18
08368:  MOVF   FF3,W
0836A:  CLRF   x73
0836C:  MOVWF  x72
0836E:  MOVLW  0C
08370:  ADDWF  x72,W
08372:  MOVWF  01
08374:  MOVLW  00
08376:  ADDWFC x73,W
08378:  MOVWF  03
0837A:  MOVF   01,W
0837C:  ADDLW  82
0837E:  MOVWF  FE9
08380:  MOVLW  00
08382:  ADDWFC 03,W
08384:  MOVWF  FEA
08386:  MOVFF  FEF,6A7
0838A:  MOVFF  FEC,6A8
0838E:  MOVFF  FEC,6A9
08392:  MOVFF  FEC,6AA
08396:  MOVFF  671,557
0839A:  MOVFF  670,556
0839E:  MOVLW  89
083A0:  MOVWF  FE9
083A2:  MOVLW  02
083A4:  MOVWF  xAB
083A6:  MOVLB  0
083A8:  CALL   7168
083AC:  MOVLW  2C
083AE:  MOVLB  6
083B0:  MOVWF  xB4
083B2:  MOVLB  0
083B4:  CALL   6440
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c4);
083B8:  MOVLW  04
083BA:  MOVLB  6
083BC:  MOVWF  xA6
083BE:  MOVLW  B2
083C0:  MOVWF  xA5
083C2:  MOVLB  0
083C4:  CALL   6390
083C8:  MOVF   01,W
083CA:  ADDLW  B2
083CC:  MOVLB  6
083CE:  MOVWF  x70
083D0:  MOVLW  04
083D2:  ADDWFC 02,W
083D4:  MOVWF  x71
083D6:  MOVLW  01
083D8:  SUBWF  x6F,W
083DA:  MULLW  18
083DC:  MOVF   FF3,W
083DE:  CLRF   x73
083E0:  MOVWF  x72
083E2:  MOVLW  10
083E4:  ADDWF  x72,W
083E6:  MOVWF  01
083E8:  MOVLW  00
083EA:  ADDWFC x73,W
083EC:  MOVWF  03
083EE:  MOVF   01,W
083F0:  ADDLW  82
083F2:  MOVWF  FE9
083F4:  MOVLW  00
083F6:  ADDWFC 03,W
083F8:  MOVWF  FEA
083FA:  MOVFF  FEF,6A7
083FE:  MOVFF  FEC,6A8
08402:  MOVFF  FEC,6A9
08406:  MOVFF  FEC,6AA
0840A:  MOVFF  671,557
0840E:  MOVFF  670,556
08412:  MOVLW  89
08414:  MOVWF  FE9
08416:  MOVLW  02
08418:  MOVWF  xAB
0841A:  MOVLB  0
0841C:  CALL   7168
08420:  MOVLW  2C
08422:  MOVLB  6
08424:  MOVWF  xB4
08426:  MOVLB  0
08428:  CALL   6440
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c5);
0842C:  MOVLW  04
0842E:  MOVLB  6
08430:  MOVWF  xA6
08432:  MOVLW  B2
08434:  MOVWF  xA5
08436:  MOVLB  0
08438:  CALL   6390
0843C:  MOVF   01,W
0843E:  ADDLW  B2
08440:  MOVLB  6
08442:  MOVWF  x70
08444:  MOVLW  04
08446:  ADDWFC 02,W
08448:  MOVWF  x71
0844A:  MOVLW  01
0844C:  SUBWF  x6F,W
0844E:  MULLW  18
08450:  MOVF   FF3,W
08452:  CLRF   x73
08454:  MOVWF  x72
08456:  MOVLW  14
08458:  ADDWF  x72,W
0845A:  MOVWF  01
0845C:  MOVLW  00
0845E:  ADDWFC x73,W
08460:  MOVWF  03
08462:  MOVF   01,W
08464:  ADDLW  82
08466:  MOVWF  FE9
08468:  MOVLW  00
0846A:  ADDWFC 03,W
0846C:  MOVWF  FEA
0846E:  MOVFF  FEF,6A7
08472:  MOVFF  FEC,6A8
08476:  MOVFF  FEC,6A9
0847A:  MOVFF  FEC,6AA
0847E:  MOVFF  671,557
08482:  MOVFF  670,556
08486:  MOVLW  89
08488:  MOVWF  FE9
0848A:  MOVLW  02
0848C:  MOVWF  xAB
0848E:  MOVLB  0
08490:  CALL   7168
08494:  MOVLW  2C
08496:  MOVLB  6
08498:  MOVWF  xB4
0849A:  MOVLB  0
0849C:  CALL   6440
....................    
....................    return SUCCESS;
084A0:  MOVLW  00
084A2:  MOVWF  01
084A4:  RETURN 0
.................... }
.................... 
.................... int8 getSensorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
084A6:  MOVLB  6
084A8:  CLRF   xB1
084AA:  MOVFF  663,6B0
084AE:  CLRF   xB3
084B0:  MOVLW  B5
084B2:  MOVWF  xB2
084B4:  MOVLB  0
084B6:  CALL   07F0
084BA:  MOVFF  02,672
084BE:  MOVFF  01,671
084C2:  MOVLW  06
084C4:  MOVLB  6
084C6:  ADDWF  x71,F
084C8:  MOVLW  00
084CA:  ADDWFC x72,F
084CC:  MOVLW  32
084CE:  ADDWF  x71,W
084D0:  MOVWF  01
084D2:  MOVLW  00
084D4:  ADDWFC x72,W
084D6:  MOVWF  03
084D8:  MOVF   01,W
084DA:  ADDLW  DC
084DC:  MOVWF  01
084DE:  MOVLW  01
084E0:  ADDWFC 03,F
084E2:  MOVFF  01,671
084E6:  MOVFF  03,672
084EA:  MOVFF  03,698
084EE:  MOVFF  01,697
084F2:  MOVLB  0
084F4:  CALL   6508
084F8:  MOVF   01,F
084FA:  BNZ   8504
084FC:  MOVLW  02
084FE:  MOVWF  01
08500:  BRA    8A00
08502:  BRA    8562
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
08504:  MOVLB  6
08506:  CLRF   xB1
08508:  MOVFF  663,6B0
0850C:  CLRF   xB3
0850E:  MOVLW  B5
08510:  MOVWF  xB2
08512:  MOVLB  0
08514:  CALL   07F0
08518:  MOVFF  02,672
0851C:  MOVFF  01,671
08520:  MOVLW  06
08522:  MOVLB  6
08524:  ADDWF  x71,F
08526:  MOVLW  00
08528:  ADDWFC x72,F
0852A:  MOVLW  32
0852C:  ADDWF  x71,W
0852E:  MOVWF  01
08530:  MOVLW  00
08532:  ADDWFC x72,W
08534:  MOVWF  03
08536:  MOVF   01,W
08538:  ADDLW  DC
0853A:  MOVWF  01
0853C:  MOVLW  01
0853E:  ADDWFC 03,F
08540:  MOVFF  01,671
08544:  MOVFF  03,672
08548:  MOVFF  03,698
0854C:  MOVFF  01,697
08550:  CLRF   x9A
08552:  CLRF   x99
08554:  MOVLW  0A
08556:  MOVWF  x9B
08558:  MOVLB  0
0855A:  CALL   65F8
0855E:  MOVFF  01,66F
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
08562:  MOVLB  6
08564:  CLRF   xB1
08566:  MOVFF  663,6B0
0856A:  CLRF   xB3
0856C:  MOVLW  B5
0856E:  MOVWF  xB2
08570:  MOVLB  0
08572:  CALL   07F0
08576:  MOVFF  02,672
0857A:  MOVFF  01,671
0857E:  MOVLW  06
08580:  MOVLB  6
08582:  ADDWF  x71,F
08584:  MOVLW  00
08586:  ADDWFC x72,F
08588:  MOVLW  4B
0858A:  ADDWF  x71,W
0858C:  MOVWF  01
0858E:  MOVLW  00
08590:  ADDWFC x72,W
08592:  MOVWF  03
08594:  MOVF   01,W
08596:  ADDLW  DC
08598:  MOVWF  01
0859A:  MOVLW  01
0859C:  ADDWFC 03,F
0859E:  MOVFF  01,671
085A2:  MOVFF  03,672
085A6:  MOVFF  03,6A6
085AA:  MOVFF  01,6A5
085AE:  MOVLB  0
085B0:  CALL   6390
085B4:  MOVFF  02,03
085B8:  MOVF   01,W
085BA:  SUBLW  01
085BC:  BNZ   85C2
085BE:  MOVF   03,F
085C0:  BZ    85CA
085C2:  MOVLW  02
085C4:  MOVWF  01
085C6:  BRA    8A00
085C8:  BRA    860A
....................    else arg2 = SERcmd[rec].p[3][0];
085CA:  MOVLB  6
085CC:  CLRF   xB1
085CE:  MOVFF  663,6B0
085D2:  CLRF   xB3
085D4:  MOVLW  B5
085D6:  MOVWF  xB2
085D8:  MOVLB  0
085DA:  CALL   07F0
085DE:  MOVFF  02,672
085E2:  MOVFF  01,671
085E6:  MOVLW  06
085E8:  MOVLB  6
085EA:  ADDWF  x71,F
085EC:  MOVLW  00
085EE:  ADDWFC x72,F
085F0:  MOVLW  4B
085F2:  ADDWF  x71,F
085F4:  MOVLW  00
085F6:  ADDWFC x72,F
085F8:  MOVLW  DC
085FA:  ADDWF  x71,W
085FC:  MOVWF  FE9
085FE:  MOVLW  01
08600:  ADDWFC x72,W
08602:  MOVWF  FEA
08604:  MOVFF  FEF,670
08608:  MOVLB  0
....................    
....................    /*** GET SENSOR CAL PARAM **********/
....................    if      ('0' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c0);
0860A:  MOVLB  6
0860C:  MOVF   x70,W
0860E:  SUBLW  30
08610:  BNZ   86AC
08612:  MOVLW  04
08614:  MOVWF  xA6
08616:  MOVLW  B2
08618:  MOVWF  xA5
0861A:  MOVLB  0
0861C:  CALL   6390
08620:  MOVFF  02,03
08624:  MOVF   01,W
08626:  ADDLW  B2
08628:  MOVLB  6
0862A:  MOVWF  x71
0862C:  MOVLW  04
0862E:  ADDWFC 02,W
08630:  MOVWF  x72
08632:  MOVLW  01
08634:  SUBWF  x6F,W
08636:  MULLW  18
08638:  MOVF   FF3,W
0863A:  CLRF   x74
0863C:  MOVWF  x73
0863E:  MOVLW  82
08640:  ADDWF  x73,W
08642:  MOVWF  FE9
08644:  MOVLW  00
08646:  ADDWFC x74,W
08648:  MOVWF  FEA
0864A:  MOVFF  FEF,675
0864E:  MOVFF  FEC,676
08652:  MOVFF  FEC,677
08656:  MOVFF  FEC,678
0865A:  MOVFF  672,557
0865E:  MOVFF  671,556
08662:  MOVFF  66F,698
08666:  MOVLW  18
08668:  MOVWF  x99
0866A:  MOVLB  0
0866C:  CALL   694C
08670:  MOVLW  2C
08672:  MOVLB  6
08674:  MOVWF  xB4
08676:  MOVLB  0
08678:  CALL   6440
0867C:  MOVLW  89
0867E:  MOVWF  FE9
08680:  MOVFF  678,6AA
08684:  MOVFF  677,6A9
08688:  MOVFF  676,6A8
0868C:  MOVFF  675,6A7
08690:  MOVLW  02
08692:  MOVLB  6
08694:  MOVWF  xAB
08696:  MOVLB  0
08698:  CALL   7168
0869C:  MOVLW  2C
0869E:  MOVLB  6
086A0:  MOVWF  xB4
086A2:  MOVLB  0
086A4:  CALL   6440
086A8:  BRA    89FC
086AA:  MOVLB  6
....................    else if ('1' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c1);
086AC:  MOVF   x70,W
086AE:  SUBLW  31
086B0:  BNZ   8754
086B2:  MOVLW  04
086B4:  MOVWF  xA6
086B6:  MOVLW  B2
086B8:  MOVWF  xA5
086BA:  MOVLB  0
086BC:  CALL   6390
086C0:  MOVF   01,W
086C2:  ADDLW  B2
086C4:  MOVLB  6
086C6:  MOVWF  x71
086C8:  MOVLW  04
086CA:  ADDWFC 02,W
086CC:  MOVWF  x72
086CE:  MOVLW  01
086D0:  SUBWF  x6F,W
086D2:  MULLW  18
086D4:  MOVF   FF3,W
086D6:  CLRF   x74
086D8:  MOVWF  x73
086DA:  MOVLW  04
086DC:  ADDWF  x73,W
086DE:  MOVWF  01
086E0:  MOVLW  00
086E2:  ADDWFC x74,W
086E4:  MOVWF  03
086E6:  MOVF   01,W
086E8:  ADDLW  82
086EA:  MOVWF  FE9
086EC:  MOVLW  00
086EE:  ADDWFC 03,W
086F0:  MOVWF  FEA
086F2:  MOVFF  FEF,673
086F6:  MOVFF  FEC,674
086FA:  MOVFF  FEC,675
086FE:  MOVFF  FEC,676
08702:  MOVFF  672,557
08706:  MOVFF  671,556
0870A:  MOVFF  66F,698
0870E:  MOVLW  18
08710:  MOVWF  x99
08712:  MOVLB  0
08714:  CALL   694C
08718:  MOVLW  2C
0871A:  MOVLB  6
0871C:  MOVWF  xB4
0871E:  MOVLB  0
08720:  CALL   6440
08724:  MOVLW  89
08726:  MOVWF  FE9
08728:  MOVFF  676,6AA
0872C:  MOVFF  675,6A9
08730:  MOVFF  674,6A8
08734:  MOVFF  673,6A7
08738:  MOVLW  02
0873A:  MOVLB  6
0873C:  MOVWF  xAB
0873E:  MOVLB  0
08740:  CALL   7168
08744:  MOVLW  2C
08746:  MOVLB  6
08748:  MOVWF  xB4
0874A:  MOVLB  0
0874C:  CALL   6440
08750:  BRA    89FC
08752:  MOVLB  6
....................    else if ('2' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c2);
08754:  MOVF   x70,W
08756:  SUBLW  32
08758:  BNZ   87FC
0875A:  MOVLW  04
0875C:  MOVWF  xA6
0875E:  MOVLW  B2
08760:  MOVWF  xA5
08762:  MOVLB  0
08764:  CALL   6390
08768:  MOVF   01,W
0876A:  ADDLW  B2
0876C:  MOVLB  6
0876E:  MOVWF  x71
08770:  MOVLW  04
08772:  ADDWFC 02,W
08774:  MOVWF  x72
08776:  MOVLW  01
08778:  SUBWF  x6F,W
0877A:  MULLW  18
0877C:  MOVF   FF3,W
0877E:  CLRF   x74
08780:  MOVWF  x73
08782:  MOVLW  08
08784:  ADDWF  x73,W
08786:  MOVWF  01
08788:  MOVLW  00
0878A:  ADDWFC x74,W
0878C:  MOVWF  03
0878E:  MOVF   01,W
08790:  ADDLW  82
08792:  MOVWF  FE9
08794:  MOVLW  00
08796:  ADDWFC 03,W
08798:  MOVWF  FEA
0879A:  MOVFF  FEF,673
0879E:  MOVFF  FEC,674
087A2:  MOVFF  FEC,675
087A6:  MOVFF  FEC,676
087AA:  MOVFF  672,557
087AE:  MOVFF  671,556
087B2:  MOVFF  66F,698
087B6:  MOVLW  18
087B8:  MOVWF  x99
087BA:  MOVLB  0
087BC:  CALL   694C
087C0:  MOVLW  2C
087C2:  MOVLB  6
087C4:  MOVWF  xB4
087C6:  MOVLB  0
087C8:  CALL   6440
087CC:  MOVLW  89
087CE:  MOVWF  FE9
087D0:  MOVFF  676,6AA
087D4:  MOVFF  675,6A9
087D8:  MOVFF  674,6A8
087DC:  MOVFF  673,6A7
087E0:  MOVLW  02
087E2:  MOVLB  6
087E4:  MOVWF  xAB
087E6:  MOVLB  0
087E8:  CALL   7168
087EC:  MOVLW  2C
087EE:  MOVLB  6
087F0:  MOVWF  xB4
087F2:  MOVLB  0
087F4:  CALL   6440
087F8:  BRA    89FC
087FA:  MOVLB  6
....................    else if ('3' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c3);
087FC:  MOVF   x70,W
087FE:  SUBLW  33
08800:  BNZ   88A4
08802:  MOVLW  04
08804:  MOVWF  xA6
08806:  MOVLW  B2
08808:  MOVWF  xA5
0880A:  MOVLB  0
0880C:  CALL   6390
08810:  MOVF   01,W
08812:  ADDLW  B2
08814:  MOVLB  6
08816:  MOVWF  x71
08818:  MOVLW  04
0881A:  ADDWFC 02,W
0881C:  MOVWF  x72
0881E:  MOVLW  01
08820:  SUBWF  x6F,W
08822:  MULLW  18
08824:  MOVF   FF3,W
08826:  CLRF   x74
08828:  MOVWF  x73
0882A:  MOVLW  0C
0882C:  ADDWF  x73,W
0882E:  MOVWF  01
08830:  MOVLW  00
08832:  ADDWFC x74,W
08834:  MOVWF  03
08836:  MOVF   01,W
08838:  ADDLW  82
0883A:  MOVWF  FE9
0883C:  MOVLW  00
0883E:  ADDWFC 03,W
08840:  MOVWF  FEA
08842:  MOVFF  FEF,673
08846:  MOVFF  FEC,674
0884A:  MOVFF  FEC,675
0884E:  MOVFF  FEC,676
08852:  MOVFF  672,557
08856:  MOVFF  671,556
0885A:  MOVFF  66F,698
0885E:  MOVLW  18
08860:  MOVWF  x99
08862:  MOVLB  0
08864:  CALL   694C
08868:  MOVLW  2C
0886A:  MOVLB  6
0886C:  MOVWF  xB4
0886E:  MOVLB  0
08870:  CALL   6440
08874:  MOVLW  89
08876:  MOVWF  FE9
08878:  MOVFF  676,6AA
0887C:  MOVFF  675,6A9
08880:  MOVFF  674,6A8
08884:  MOVFF  673,6A7
08888:  MOVLW  02
0888A:  MOVLB  6
0888C:  MOVWF  xAB
0888E:  MOVLB  0
08890:  CALL   7168
08894:  MOVLW  2C
08896:  MOVLB  6
08898:  MOVWF  xB4
0889A:  MOVLB  0
0889C:  CALL   6440
088A0:  BRA    89FC
088A2:  MOVLB  6
....................    else if ('4' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c4);
088A4:  MOVF   x70,W
088A6:  SUBLW  34
088A8:  BNZ   894C
088AA:  MOVLW  04
088AC:  MOVWF  xA6
088AE:  MOVLW  B2
088B0:  MOVWF  xA5
088B2:  MOVLB  0
088B4:  CALL   6390
088B8:  MOVF   01,W
088BA:  ADDLW  B2
088BC:  MOVLB  6
088BE:  MOVWF  x71
088C0:  MOVLW  04
088C2:  ADDWFC 02,W
088C4:  MOVWF  x72
088C6:  MOVLW  01
088C8:  SUBWF  x6F,W
088CA:  MULLW  18
088CC:  MOVF   FF3,W
088CE:  CLRF   x74
088D0:  MOVWF  x73
088D2:  MOVLW  10
088D4:  ADDWF  x73,W
088D6:  MOVWF  01
088D8:  MOVLW  00
088DA:  ADDWFC x74,W
088DC:  MOVWF  03
088DE:  MOVF   01,W
088E0:  ADDLW  82
088E2:  MOVWF  FE9
088E4:  MOVLW  00
088E6:  ADDWFC 03,W
088E8:  MOVWF  FEA
088EA:  MOVFF  FEF,673
088EE:  MOVFF  FEC,674
088F2:  MOVFF  FEC,675
088F6:  MOVFF  FEC,676
088FA:  MOVFF  672,557
088FE:  MOVFF  671,556
08902:  MOVFF  66F,698
08906:  MOVLW  18
08908:  MOVWF  x99
0890A:  MOVLB  0
0890C:  CALL   694C
08910:  MOVLW  2C
08912:  MOVLB  6
08914:  MOVWF  xB4
08916:  MOVLB  0
08918:  CALL   6440
0891C:  MOVLW  89
0891E:  MOVWF  FE9
08920:  MOVFF  676,6AA
08924:  MOVFF  675,6A9
08928:  MOVFF  674,6A8
0892C:  MOVFF  673,6A7
08930:  MOVLW  02
08932:  MOVLB  6
08934:  MOVWF  xAB
08936:  MOVLB  0
08938:  CALL   7168
0893C:  MOVLW  2C
0893E:  MOVLB  6
08940:  MOVWF  xB4
08942:  MOVLB  0
08944:  CALL   6440
08948:  BRA    89FC
0894A:  MOVLB  6
....................    else if ('5' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c5);
0894C:  MOVF   x70,W
0894E:  SUBLW  35
08950:  BNZ   89F4
08952:  MOVLW  04
08954:  MOVWF  xA6
08956:  MOVLW  B2
08958:  MOVWF  xA5
0895A:  MOVLB  0
0895C:  CALL   6390
08960:  MOVF   01,W
08962:  ADDLW  B2
08964:  MOVLB  6
08966:  MOVWF  x71
08968:  MOVLW  04
0896A:  ADDWFC 02,W
0896C:  MOVWF  x72
0896E:  MOVLW  01
08970:  SUBWF  x6F,W
08972:  MULLW  18
08974:  MOVF   FF3,W
08976:  CLRF   x74
08978:  MOVWF  x73
0897A:  MOVLW  14
0897C:  ADDWF  x73,W
0897E:  MOVWF  01
08980:  MOVLW  00
08982:  ADDWFC x74,W
08984:  MOVWF  03
08986:  MOVF   01,W
08988:  ADDLW  82
0898A:  MOVWF  FE9
0898C:  MOVLW  00
0898E:  ADDWFC 03,W
08990:  MOVWF  FEA
08992:  MOVFF  FEF,673
08996:  MOVFF  FEC,674
0899A:  MOVFF  FEC,675
0899E:  MOVFF  FEC,676
089A2:  MOVFF  672,557
089A6:  MOVFF  671,556
089AA:  MOVFF  66F,698
089AE:  MOVLW  18
089B0:  MOVWF  x99
089B2:  MOVLB  0
089B4:  CALL   694C
089B8:  MOVLW  2C
089BA:  MOVLB  6
089BC:  MOVWF  xB4
089BE:  MOVLB  0
089C0:  CALL   6440
089C4:  MOVLW  89
089C6:  MOVWF  FE9
089C8:  MOVFF  676,6AA
089CC:  MOVFF  675,6A9
089D0:  MOVFF  674,6A8
089D4:  MOVFF  673,6A7
089D8:  MOVLW  02
089DA:  MOVLB  6
089DC:  MOVWF  xAB
089DE:  MOVLB  0
089E0:  CALL   7168
089E4:  MOVLW  2C
089E6:  MOVLB  6
089E8:  MOVWF  xB4
089EA:  MOVLB  0
089EC:  CALL   6440
089F0:  BRA    89FC
089F2:  MOVLB  6
....................    else return INV_PARAM;
089F4:  MOVLW  02
089F6:  MOVWF  01
089F8:  MOVLB  0
089FA:  BRA    8A00
....................    
....................    return SUCCESS;
089FC:  MOVLW  00
089FE:  MOVWF  01
08A00:  RETURN 0
.................... }
.................... 
.................... int8 setSensorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char  arg2;
....................    float arg3;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
08A02:  MOVLB  6
08A04:  CLRF   xB1
08A06:  MOVFF  663,6B0
08A0A:  CLRF   xB3
08A0C:  MOVLW  B5
08A0E:  MOVWF  xB2
08A10:  MOVLB  0
08A12:  CALL   07F0
08A16:  MOVFF  02,676
08A1A:  MOVFF  01,675
08A1E:  MOVLW  06
08A20:  MOVLB  6
08A22:  ADDWF  x75,F
08A24:  MOVLW  00
08A26:  ADDWFC x76,F
08A28:  MOVLW  32
08A2A:  ADDWF  x75,W
08A2C:  MOVWF  01
08A2E:  MOVLW  00
08A30:  ADDWFC x76,W
08A32:  MOVWF  03
08A34:  MOVF   01,W
08A36:  ADDLW  DC
08A38:  MOVWF  01
08A3A:  MOVLW  01
08A3C:  ADDWFC 03,F
08A3E:  MOVFF  01,675
08A42:  MOVFF  03,676
08A46:  MOVFF  03,698
08A4A:  MOVFF  01,697
08A4E:  MOVLB  0
08A50:  CALL   6508
08A54:  MOVF   01,F
08A56:  BNZ   8A60
08A58:  MOVLW  02
08A5A:  MOVWF  01
08A5C:  BRA    8D98
08A5E:  BRA    8ABE
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
08A60:  MOVLB  6
08A62:  CLRF   xB1
08A64:  MOVFF  663,6B0
08A68:  CLRF   xB3
08A6A:  MOVLW  B5
08A6C:  MOVWF  xB2
08A6E:  MOVLB  0
08A70:  CALL   07F0
08A74:  MOVFF  02,676
08A78:  MOVFF  01,675
08A7C:  MOVLW  06
08A7E:  MOVLB  6
08A80:  ADDWF  x75,F
08A82:  MOVLW  00
08A84:  ADDWFC x76,F
08A86:  MOVLW  32
08A88:  ADDWF  x75,W
08A8A:  MOVWF  01
08A8C:  MOVLW  00
08A8E:  ADDWFC x76,W
08A90:  MOVWF  03
08A92:  MOVF   01,W
08A94:  ADDLW  DC
08A96:  MOVWF  01
08A98:  MOVLW  01
08A9A:  ADDWFC 03,F
08A9C:  MOVFF  01,675
08AA0:  MOVFF  03,676
08AA4:  MOVFF  03,698
08AA8:  MOVFF  01,697
08AAC:  CLRF   x9A
08AAE:  CLRF   x99
08AB0:  MOVLW  0A
08AB2:  MOVWF  x9B
08AB4:  MOVLB  0
08AB6:  CALL   65F8
08ABA:  MOVFF  01,66F
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
08ABE:  MOVLB  6
08AC0:  CLRF   xB1
08AC2:  MOVFF  663,6B0
08AC6:  CLRF   xB3
08AC8:  MOVLW  B5
08ACA:  MOVWF  xB2
08ACC:  MOVLB  0
08ACE:  CALL   07F0
08AD2:  MOVFF  02,676
08AD6:  MOVFF  01,675
08ADA:  MOVLW  06
08ADC:  MOVLB  6
08ADE:  ADDWF  x75,F
08AE0:  MOVLW  00
08AE2:  ADDWFC x76,F
08AE4:  MOVLW  4B
08AE6:  ADDWF  x75,W
08AE8:  MOVWF  01
08AEA:  MOVLW  00
08AEC:  ADDWFC x76,W
08AEE:  MOVWF  03
08AF0:  MOVF   01,W
08AF2:  ADDLW  DC
08AF4:  MOVWF  01
08AF6:  MOVLW  01
08AF8:  ADDWFC 03,F
08AFA:  MOVFF  01,675
08AFE:  MOVFF  03,676
08B02:  MOVFF  03,6A6
08B06:  MOVFF  01,6A5
08B0A:  MOVLB  0
08B0C:  CALL   6390
08B10:  MOVFF  02,03
08B14:  MOVF   01,W
08B16:  SUBLW  01
08B18:  BNZ   8B1E
08B1A:  MOVF   03,F
08B1C:  BZ    8B26
08B1E:  MOVLW  02
08B20:  MOVWF  01
08B22:  BRA    8D98
08B24:  BRA    8B66
....................    else arg2 = SERcmd[rec].p[3][0];
08B26:  MOVLB  6
08B28:  CLRF   xB1
08B2A:  MOVFF  663,6B0
08B2E:  CLRF   xB3
08B30:  MOVLW  B5
08B32:  MOVWF  xB2
08B34:  MOVLB  0
08B36:  CALL   07F0
08B3A:  MOVFF  02,676
08B3E:  MOVFF  01,675
08B42:  MOVLW  06
08B44:  MOVLB  6
08B46:  ADDWF  x75,F
08B48:  MOVLW  00
08B4A:  ADDWFC x76,F
08B4C:  MOVLW  4B
08B4E:  ADDWF  x75,F
08B50:  MOVLW  00
08B52:  ADDWFC x76,F
08B54:  MOVLW  DC
08B56:  ADDWF  x75,W
08B58:  MOVWF  FE9
08B5A:  MOVLW  01
08B5C:  ADDWFC x76,W
08B5E:  MOVWF  FEA
08B60:  MOVFF  FEF,670
08B64:  MOVLB  0
....................    
....................    if (!arg_is_float(SERcmd[rec].p[4])) return INV_PARAM;
08B66:  MOVLB  6
08B68:  CLRF   xB1
08B6A:  MOVFF  663,6B0
08B6E:  CLRF   xB3
08B70:  MOVLW  B5
08B72:  MOVWF  xB2
08B74:  MOVLB  0
08B76:  CALL   07F0
08B7A:  MOVFF  02,676
08B7E:  MOVFF  01,675
08B82:  MOVLW  06
08B84:  MOVLB  6
08B86:  ADDWF  x75,F
08B88:  MOVLW  00
08B8A:  ADDWFC x76,F
08B8C:  MOVLW  64
08B8E:  ADDWF  x75,W
08B90:  MOVWF  01
08B92:  MOVLW  00
08B94:  ADDWFC x76,W
08B96:  MOVWF  03
08B98:  MOVF   01,W
08B9A:  ADDLW  DC
08B9C:  MOVWF  01
08B9E:  MOVLW  01
08BA0:  ADDWFC 03,F
08BA2:  MOVFF  01,675
08BA6:  MOVFF  03,676
08BAA:  MOVFF  03,679
08BAE:  MOVFF  01,678
08BB2:  MOVLB  0
08BB4:  CALL   77D4
08BB8:  MOVF   01,F
08BBA:  BNZ   8BC4
08BBC:  MOVLW  02
08BBE:  MOVWF  01
08BC0:  BRA    8D98
08BC2:  BRA    8C2A
....................    else arg3 = strtod(SERcmd[rec].p[4], '\0');
08BC4:  MOVLB  6
08BC6:  CLRF   xB1
08BC8:  MOVFF  663,6B0
08BCC:  CLRF   xB3
08BCE:  MOVLW  B5
08BD0:  MOVWF  xB2
08BD2:  MOVLB  0
08BD4:  CALL   07F0
08BD8:  MOVFF  02,676
08BDC:  MOVFF  01,675
08BE0:  MOVLW  06
08BE2:  MOVLB  6
08BE4:  ADDWF  x75,F
08BE6:  MOVLW  00
08BE8:  ADDWFC x76,F
08BEA:  MOVLW  64
08BEC:  ADDWF  x75,W
08BEE:  MOVWF  01
08BF0:  MOVLW  00
08BF2:  ADDWFC x76,W
08BF4:  MOVWF  03
08BF6:  MOVF   01,W
08BF8:  ADDLW  DC
08BFA:  MOVWF  01
08BFC:  MOVLW  01
08BFE:  ADDWFC 03,F
08C00:  MOVFF  01,675
08C04:  MOVFF  03,676
08C08:  MOVFF  03,679
08C0C:  MOVFF  01,678
08C10:  CLRF   x7B
08C12:  CLRF   x7A
08C14:  MOVLB  0
08C16:  CALL   7896
08C1A:  MOVFF  03,674
08C1E:  MOVFF  02,673
08C22:  MOVFF  01,672
08C26:  MOVFF  00,671
....................    
....................    /*** SET SENSOR CAL PARAM **********/
....................    if      ('0' == arg2) sensorCal[arg1-1].c0 = arg3;
08C2A:  MOVLB  6
08C2C:  MOVF   x70,W
08C2E:  SUBLW  30
08C30:  BNZ   8C5C
08C32:  MOVLW  01
08C34:  SUBWF  x6F,W
08C36:  MULLW  18
08C38:  MOVF   FF3,W
08C3A:  CLRF   x76
08C3C:  MOVWF  x75
08C3E:  MOVLW  82
08C40:  ADDWF  x75,W
08C42:  MOVWF  FE9
08C44:  MOVLW  00
08C46:  ADDWFC x76,W
08C48:  MOVWF  FEA
08C4A:  MOVFF  671,FEF
08C4E:  MOVFF  672,FEC
08C52:  MOVFF  673,FEC
08C56:  MOVFF  674,FEC
08C5A:  BRA    8D92
....................    else if ('1' == arg2) sensorCal[arg1-1].c1 = arg3;
08C5C:  MOVF   x70,W
08C5E:  SUBLW  31
08C60:  BNZ   8C98
08C62:  MOVLW  01
08C64:  SUBWF  x6F,W
08C66:  MULLW  18
08C68:  MOVF   FF3,W
08C6A:  CLRF   x76
08C6C:  MOVWF  x75
08C6E:  MOVLW  04
08C70:  ADDWF  x75,W
08C72:  MOVWF  01
08C74:  MOVLW  00
08C76:  ADDWFC x76,W
08C78:  MOVWF  03
08C7A:  MOVF   01,W
08C7C:  ADDLW  82
08C7E:  MOVWF  FE9
08C80:  MOVLW  00
08C82:  ADDWFC 03,W
08C84:  MOVWF  FEA
08C86:  MOVFF  671,FEF
08C8A:  MOVFF  672,FEC
08C8E:  MOVFF  673,FEC
08C92:  MOVFF  674,FEC
08C96:  BRA    8D92
....................    else if ('2' == arg2) sensorCal[arg1-1].c2 = arg3;
08C98:  MOVF   x70,W
08C9A:  SUBLW  32
08C9C:  BNZ   8CD4
08C9E:  MOVLW  01
08CA0:  SUBWF  x6F,W
08CA2:  MULLW  18
08CA4:  MOVF   FF3,W
08CA6:  CLRF   x76
08CA8:  MOVWF  x75
08CAA:  MOVLW  08
08CAC:  ADDWF  x75,W
08CAE:  MOVWF  01
08CB0:  MOVLW  00
08CB2:  ADDWFC x76,W
08CB4:  MOVWF  03
08CB6:  MOVF   01,W
08CB8:  ADDLW  82
08CBA:  MOVWF  FE9
08CBC:  MOVLW  00
08CBE:  ADDWFC 03,W
08CC0:  MOVWF  FEA
08CC2:  MOVFF  671,FEF
08CC6:  MOVFF  672,FEC
08CCA:  MOVFF  673,FEC
08CCE:  MOVFF  674,FEC
08CD2:  BRA    8D92
....................    else if ('3' == arg2) sensorCal[arg1-1].c3 = arg3;
08CD4:  MOVF   x70,W
08CD6:  SUBLW  33
08CD8:  BNZ   8D10
08CDA:  MOVLW  01
08CDC:  SUBWF  x6F,W
08CDE:  MULLW  18
08CE0:  MOVF   FF3,W
08CE2:  CLRF   x76
08CE4:  MOVWF  x75
08CE6:  MOVLW  0C
08CE8:  ADDWF  x75,W
08CEA:  MOVWF  01
08CEC:  MOVLW  00
08CEE:  ADDWFC x76,W
08CF0:  MOVWF  03
08CF2:  MOVF   01,W
08CF4:  ADDLW  82
08CF6:  MOVWF  FE9
08CF8:  MOVLW  00
08CFA:  ADDWFC 03,W
08CFC:  MOVWF  FEA
08CFE:  MOVFF  671,FEF
08D02:  MOVFF  672,FEC
08D06:  MOVFF  673,FEC
08D0A:  MOVFF  674,FEC
08D0E:  BRA    8D92
....................    else if ('4' == arg2) sensorCal[arg1-1].c4 = arg3;
08D10:  MOVF   x70,W
08D12:  SUBLW  34
08D14:  BNZ   8D4C
08D16:  MOVLW  01
08D18:  SUBWF  x6F,W
08D1A:  MULLW  18
08D1C:  MOVF   FF3,W
08D1E:  CLRF   x76
08D20:  MOVWF  x75
08D22:  MOVLW  10
08D24:  ADDWF  x75,W
08D26:  MOVWF  01
08D28:  MOVLW  00
08D2A:  ADDWFC x76,W
08D2C:  MOVWF  03
08D2E:  MOVF   01,W
08D30:  ADDLW  82
08D32:  MOVWF  FE9
08D34:  MOVLW  00
08D36:  ADDWFC 03,W
08D38:  MOVWF  FEA
08D3A:  MOVFF  671,FEF
08D3E:  MOVFF  672,FEC
08D42:  MOVFF  673,FEC
08D46:  MOVFF  674,FEC
08D4A:  BRA    8D92
....................    else if ('5' == arg2) sensorCal[arg1-1].c5 = arg3;
08D4C:  MOVF   x70,W
08D4E:  SUBLW  35
08D50:  BNZ   8D88
08D52:  MOVLW  01
08D54:  SUBWF  x6F,W
08D56:  MULLW  18
08D58:  MOVF   FF3,W
08D5A:  CLRF   x76
08D5C:  MOVWF  x75
08D5E:  MOVLW  14
08D60:  ADDWF  x75,W
08D62:  MOVWF  01
08D64:  MOVLW  00
08D66:  ADDWFC x76,W
08D68:  MOVWF  03
08D6A:  MOVF   01,W
08D6C:  ADDLW  82
08D6E:  MOVWF  FE9
08D70:  MOVLW  00
08D72:  ADDWFC 03,W
08D74:  MOVWF  FEA
08D76:  MOVFF  671,FEF
08D7A:  MOVFF  672,FEC
08D7E:  MOVFF  673,FEC
08D82:  MOVFF  674,FEC
08D86:  BRA    8D92
....................    else return INV_PARAM;
08D88:  MOVLW  02
08D8A:  MOVWF  01
08D8C:  MOVLB  0
08D8E:  BRA    8D98
08D90:  MOVLB  6
....................    
....................    return SUCCESS;
08D92:  MOVLW  00
08D94:  MOVWF  01
08D96:  MOVLB  0
08D98:  RETURN 0
.................... }
.................... 
.................... int8 getMonitorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    char *arg1;
....................    char *s_N15 = "N15";
08D9A:  MOVLW  4E
08D9C:  MOVLB  6
08D9E:  MOVWF  x73
08DA0:  MOVLW  31
08DA2:  MOVWF  x74
08DA4:  MOVLW  35
08DA6:  MOVWF  x75
08DA8:  CLRF   x76
08DAA:  MOVLW  06
08DAC:  MOVWF  x72
08DAE:  MOVLW  73
08DB0:  MOVWF  x71
....................    char *s_200 = "200";
08DB2:  MOVLW  32
08DB4:  MOVWF  x79
08DB6:  MOVLW  30
08DB8:  MOVWF  x7A
08DBA:  MOVWF  x7B
08DBC:  CLRF   x7C
08DBE:  MOVLW  06
08DC0:  MOVWF  x78
08DC2:  MOVLW  79
08DC4:  MOVWF  x77
....................    char *s_5V6 = "5V6";
08DC6:  MOVLW  35
08DC8:  MOVWF  x7F
08DCA:  MOVLW  56
08DCC:  MOVWF  x80
08DCE:  MOVLW  36
08DD0:  MOVWF  x81
08DD2:  CLRF   x82
08DD4:  MOVLW  06
08DD6:  MOVWF  x7E
08DD8:  MOVLW  7F
08DDA:  MOVWF  x7D
....................    char *s_5VA = "5VA";
08DDC:  MOVLW  35
08DDE:  MOVWF  x85
08DE0:  MOVLW  56
08DE2:  MOVWF  x86
08DE4:  MOVLW  41
08DE6:  MOVWF  x87
08DE8:  CLRF   x88
08DEA:  MOVLW  06
08DEC:  MOVWF  x84
08DEE:  MOVLW  85
08DF0:  MOVWF  x83
....................    char *s_3V6X = "3V6X";
08DF2:  MOVLW  33
08DF4:  MOVWF  x8B
08DF6:  MOVLW  56
08DF8:  MOVWF  x8C
08DFA:  MOVLW  36
08DFC:  MOVWF  x8D
08DFE:  MOVLW  58
08E00:  MOVWF  x8E
08E02:  CLRF   x8F
08E04:  MOVLW  06
08E06:  MOVWF  x8A
08E08:  MOVLW  8B
08E0A:  MOVWF  x89
....................    char *s_3V3A = "3V3A";
08E0C:  MOVLW  33
08E0E:  MOVWF  x92
08E10:  MOVLW  56
08E12:  MOVWF  x93
08E14:  MOVLW  33
08E16:  MOVWF  x94
08E18:  MOVLW  41
08E1A:  MOVWF  x95
08E1C:  CLRF   x96
08E1E:  MOVLW  06
08E20:  MOVWF  x91
08E22:  MOVLW  92
08E24:  MOVWF  x90
....................    char *s_3V3D = "3V3D";
08E26:  MOVLW  33
08E28:  MOVWF  x99
08E2A:  MOVLW  56
08E2C:  MOVWF  x9A
08E2E:  MOVLW  33
08E30:  MOVWF  x9B
08E32:  MOVLW  44
08E34:  MOVWF  x9C
08E36:  CLRF   x9D
08E38:  MOVLW  06
08E3A:  MOVWF  x98
08E3C:  MOVLW  99
08E3E:  MOVWF  x97
.................... //!   char *s_all = "all";
....................    
....................    arg1 = SERcmd[rec].p[2];
08E40:  CLRF   xB1
08E42:  MOVFF  663,6B0
08E46:  CLRF   xB3
08E48:  MOVLW  B5
08E4A:  MOVWF  xB2
08E4C:  MOVLB  0
08E4E:  CALL   07F0
08E52:  MOVFF  02,69F
08E56:  MOVFF  01,69E
08E5A:  MOVLW  06
08E5C:  MOVLB  6
08E5E:  ADDWF  x9E,F
08E60:  MOVLW  00
08E62:  ADDWFC x9F,F
08E64:  MOVLW  32
08E66:  ADDWF  x9E,W
08E68:  MOVWF  01
08E6A:  MOVLW  00
08E6C:  ADDWFC x9F,W
08E6E:  MOVWF  03
08E70:  MOVF   01,W
08E72:  ADDLW  DC
08E74:  MOVWF  01
08E76:  MOVLW  01
08E78:  ADDWFC 03,F
08E7A:  MOVFF  01,66F
08E7E:  MOVFF  03,670
....................    
....................    /*** GET MONITOR VALUES ************/
....................    if      (0 == strcmp(s_N15, arg1)) {
08E82:  MOVFF  672,6A6
08E86:  MOVFF  671,6A5
08E8A:  MOVFF  670,6A8
08E8E:  MOVFF  66F,6A7
08E92:  MOVLB  0
08E94:  CALL   63C8
08E98:  MOVF   01,F
08E9A:  BNZ   8F1E
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.vN15[0],monCal.vN15[1]);
08E9C:  MOVLW  04
08E9E:  MOVLB  6
08EA0:  MOVWF  xA6
08EA2:  MOVLW  B2
08EA4:  MOVWF  xA5
08EA6:  MOVLB  0
08EA8:  CALL   6390
08EAC:  MOVFF  02,03
08EB0:  MOVF   01,W
08EB2:  ADDLW  B2
08EB4:  MOVLB  6
08EB6:  MOVWF  x9E
08EB8:  MOVLW  04
08EBA:  ADDWFC 02,W
08EBC:  MOVWF  x9F
08EBE:  MOVFF  FE8,557
08EC2:  MOVFF  69E,556
08EC6:  MOVLW  89
08EC8:  MOVWF  FE9
08ECA:  MOVFF  B5,6AA
08ECE:  MOVFF  B4,6A9
08ED2:  MOVFF  B3,6A8
08ED6:  MOVFF  B2,6A7
08EDA:  MOVLW  02
08EDC:  MOVWF  xAB
08EDE:  MOVLB  0
08EE0:  CALL   7168
08EE4:  MOVLW  2C
08EE6:  MOVLB  6
08EE8:  MOVWF  xB4
08EEA:  MOVLB  0
08EEC:  CALL   6440
08EF0:  MOVLW  89
08EF2:  MOVWF  FE9
08EF4:  MOVFF  B9,6AA
08EF8:  MOVFF  B8,6A9
08EFC:  MOVFF  B7,6A8
08F00:  MOVFF  B6,6A7
08F04:  MOVLW  02
08F06:  MOVLB  6
08F08:  MOVWF  xAB
08F0A:  MOVLB  0
08F0C:  CALL   7168
08F10:  MOVLW  2C
08F12:  MOVLB  6
08F14:  MOVWF  xB4
08F16:  MOVLB  0
08F18:  CALL   6440
....................    }
08F1C:  BRA    92C0
....................    else if (0 == strcmp(s_200, arg1)) {
08F1E:  MOVFF  678,6A6
08F22:  MOVFF  677,6A5
08F26:  MOVFF  670,6A8
08F2A:  MOVFF  66F,6A7
08F2E:  CALL   63C8
08F32:  MOVF   01,F
08F34:  BNZ   8FB8
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v200[0],monCal.v200[1]);
08F36:  MOVLW  04
08F38:  MOVLB  6
08F3A:  MOVWF  xA6
08F3C:  MOVLW  B2
08F3E:  MOVWF  xA5
08F40:  MOVLB  0
08F42:  CALL   6390
08F46:  MOVFF  02,03
08F4A:  MOVF   01,W
08F4C:  ADDLW  B2
08F4E:  MOVLB  6
08F50:  MOVWF  x9E
08F52:  MOVLW  04
08F54:  ADDWFC 02,W
08F56:  MOVWF  x9F
08F58:  MOVFF  FE8,557
08F5C:  MOVFF  69E,556
08F60:  MOVLW  89
08F62:  MOVWF  FE9
08F64:  MOVFF  BD,6AA
08F68:  MOVFF  BC,6A9
08F6C:  MOVFF  BB,6A8
08F70:  MOVFF  BA,6A7
08F74:  MOVLW  02
08F76:  MOVWF  xAB
08F78:  MOVLB  0
08F7A:  CALL   7168
08F7E:  MOVLW  2C
08F80:  MOVLB  6
08F82:  MOVWF  xB4
08F84:  MOVLB  0
08F86:  CALL   6440
08F8A:  MOVLW  89
08F8C:  MOVWF  FE9
08F8E:  MOVFF  C1,6AA
08F92:  MOVFF  C0,6A9
08F96:  MOVFF  BF,6A8
08F9A:  MOVFF  BE,6A7
08F9E:  MOVLW  02
08FA0:  MOVLB  6
08FA2:  MOVWF  xAB
08FA4:  MOVLB  0
08FA6:  CALL   7168
08FAA:  MOVLW  2C
08FAC:  MOVLB  6
08FAE:  MOVWF  xB4
08FB0:  MOVLB  0
08FB2:  CALL   6440
....................    }
08FB6:  BRA    92C0
....................    else if (0 == strcmp(s_5V6, arg1)) {
08FB8:  MOVFF  67E,6A6
08FBC:  MOVFF  67D,6A5
08FC0:  MOVFF  670,6A8
08FC4:  MOVFF  66F,6A7
08FC8:  CALL   63C8
08FCC:  MOVF   01,F
08FCE:  BNZ   9052
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v5V6[0],monCal.v5V6[1]);
08FD0:  MOVLW  04
08FD2:  MOVLB  6
08FD4:  MOVWF  xA6
08FD6:  MOVLW  B2
08FD8:  MOVWF  xA5
08FDA:  MOVLB  0
08FDC:  CALL   6390
08FE0:  MOVFF  02,03
08FE4:  MOVF   01,W
08FE6:  ADDLW  B2
08FE8:  MOVLB  6
08FEA:  MOVWF  x9E
08FEC:  MOVLW  04
08FEE:  ADDWFC 02,W
08FF0:  MOVWF  x9F
08FF2:  MOVFF  FE8,557
08FF6:  MOVFF  69E,556
08FFA:  MOVLW  89
08FFC:  MOVWF  FE9
08FFE:  MOVFF  C5,6AA
09002:  MOVFF  C4,6A9
09006:  MOVFF  C3,6A8
0900A:  MOVFF  C2,6A7
0900E:  MOVLW  02
09010:  MOVWF  xAB
09012:  MOVLB  0
09014:  CALL   7168
09018:  MOVLW  2C
0901A:  MOVLB  6
0901C:  MOVWF  xB4
0901E:  MOVLB  0
09020:  CALL   6440
09024:  MOVLW  89
09026:  MOVWF  FE9
09028:  MOVFF  C9,6AA
0902C:  MOVFF  C8,6A9
09030:  MOVFF  C7,6A8
09034:  MOVFF  C6,6A7
09038:  MOVLW  02
0903A:  MOVLB  6
0903C:  MOVWF  xAB
0903E:  MOVLB  0
09040:  CALL   7168
09044:  MOVLW  2C
09046:  MOVLB  6
09048:  MOVWF  xB4
0904A:  MOVLB  0
0904C:  CALL   6440
....................    }
09050:  BRA    92C0
....................    else if (0 == strcmp(s_5VA, arg1)) {
09052:  MOVFF  684,6A6
09056:  MOVFF  683,6A5
0905A:  MOVFF  670,6A8
0905E:  MOVFF  66F,6A7
09062:  CALL   63C8
09066:  MOVF   01,F
09068:  BNZ   90EC
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v5VA[0],monCal.v5VA[1]);
0906A:  MOVLW  04
0906C:  MOVLB  6
0906E:  MOVWF  xA6
09070:  MOVLW  B2
09072:  MOVWF  xA5
09074:  MOVLB  0
09076:  CALL   6390
0907A:  MOVFF  02,03
0907E:  MOVF   01,W
09080:  ADDLW  B2
09082:  MOVLB  6
09084:  MOVWF  x9E
09086:  MOVLW  04
09088:  ADDWFC 02,W
0908A:  MOVWF  x9F
0908C:  MOVFF  FE8,557
09090:  MOVFF  69E,556
09094:  MOVLW  89
09096:  MOVWF  FE9
09098:  MOVFF  CD,6AA
0909C:  MOVFF  CC,6A9
090A0:  MOVFF  CB,6A8
090A4:  MOVFF  CA,6A7
090A8:  MOVLW  02
090AA:  MOVWF  xAB
090AC:  MOVLB  0
090AE:  CALL   7168
090B2:  MOVLW  2C
090B4:  MOVLB  6
090B6:  MOVWF  xB4
090B8:  MOVLB  0
090BA:  CALL   6440
090BE:  MOVLW  89
090C0:  MOVWF  FE9
090C2:  MOVFF  D1,6AA
090C6:  MOVFF  D0,6A9
090CA:  MOVFF  CF,6A8
090CE:  MOVFF  CE,6A7
090D2:  MOVLW  02
090D4:  MOVLB  6
090D6:  MOVWF  xAB
090D8:  MOVLB  0
090DA:  CALL   7168
090DE:  MOVLW  2C
090E0:  MOVLB  6
090E2:  MOVWF  xB4
090E4:  MOVLB  0
090E6:  CALL   6440
....................    }
090EA:  BRA    92C0
....................    else if (0 == strcmp(s_3V6X, arg1)) {
090EC:  MOVFF  68A,6A6
090F0:  MOVFF  689,6A5
090F4:  MOVFF  670,6A8
090F8:  MOVFF  66F,6A7
090FC:  CALL   63C8
09100:  MOVF   01,F
09102:  BNZ   9186
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V6X[0],monCal.v3V6X[1]);
09104:  MOVLW  04
09106:  MOVLB  6
09108:  MOVWF  xA6
0910A:  MOVLW  B2
0910C:  MOVWF  xA5
0910E:  MOVLB  0
09110:  CALL   6390
09114:  MOVFF  02,03
09118:  MOVF   01,W
0911A:  ADDLW  B2
0911C:  MOVLB  6
0911E:  MOVWF  x9E
09120:  MOVLW  04
09122:  ADDWFC 02,W
09124:  MOVWF  x9F
09126:  MOVFF  FE8,557
0912A:  MOVFF  69E,556
0912E:  MOVLW  89
09130:  MOVWF  FE9
09132:  MOVFF  D5,6AA
09136:  MOVFF  D4,6A9
0913A:  MOVFF  D3,6A8
0913E:  MOVFF  D2,6A7
09142:  MOVLW  02
09144:  MOVWF  xAB
09146:  MOVLB  0
09148:  CALL   7168
0914C:  MOVLW  2C
0914E:  MOVLB  6
09150:  MOVWF  xB4
09152:  MOVLB  0
09154:  CALL   6440
09158:  MOVLW  89
0915A:  MOVWF  FE9
0915C:  MOVFF  D9,6AA
09160:  MOVFF  D8,6A9
09164:  MOVFF  D7,6A8
09168:  MOVFF  D6,6A7
0916C:  MOVLW  02
0916E:  MOVLB  6
09170:  MOVWF  xAB
09172:  MOVLB  0
09174:  CALL   7168
09178:  MOVLW  2C
0917A:  MOVLB  6
0917C:  MOVWF  xB4
0917E:  MOVLB  0
09180:  CALL   6440
....................    }
09184:  BRA    92C0
....................    else if (0 == strcmp(s_3V3A, arg1)) {
09186:  MOVFF  691,6A6
0918A:  MOVFF  690,6A5
0918E:  MOVFF  670,6A8
09192:  MOVFF  66F,6A7
09196:  CALL   63C8
0919A:  MOVF   01,F
0919C:  BNZ   9220
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3A[0],monCal.v3V3A[1]);
0919E:  MOVLW  04
091A0:  MOVLB  6
091A2:  MOVWF  xA6
091A4:  MOVLW  B2
091A6:  MOVWF  xA5
091A8:  MOVLB  0
091AA:  CALL   6390
091AE:  MOVFF  02,03
091B2:  MOVF   01,W
091B4:  ADDLW  B2
091B6:  MOVLB  6
091B8:  MOVWF  x9E
091BA:  MOVLW  04
091BC:  ADDWFC 02,W
091BE:  MOVWF  x9F
091C0:  MOVFF  FE8,557
091C4:  MOVFF  69E,556
091C8:  MOVLW  89
091CA:  MOVWF  FE9
091CC:  MOVFF  DD,6AA
091D0:  MOVFF  DC,6A9
091D4:  MOVFF  DB,6A8
091D8:  MOVFF  DA,6A7
091DC:  MOVLW  02
091DE:  MOVWF  xAB
091E0:  MOVLB  0
091E2:  CALL   7168
091E6:  MOVLW  2C
091E8:  MOVLB  6
091EA:  MOVWF  xB4
091EC:  MOVLB  0
091EE:  CALL   6440
091F2:  MOVLW  89
091F4:  MOVWF  FE9
091F6:  MOVFF  E1,6AA
091FA:  MOVFF  E0,6A9
091FE:  MOVFF  DF,6A8
09202:  MOVFF  DE,6A7
09206:  MOVLW  02
09208:  MOVLB  6
0920A:  MOVWF  xAB
0920C:  MOVLB  0
0920E:  CALL   7168
09212:  MOVLW  2C
09214:  MOVLB  6
09216:  MOVWF  xB4
09218:  MOVLB  0
0921A:  CALL   6440
....................    }
0921E:  BRA    92C0
....................    else if (0 == strcmp(s_3V3D, arg1)) {
09220:  MOVFF  698,6A6
09224:  MOVFF  697,6A5
09228:  MOVFF  670,6A8
0922C:  MOVFF  66F,6A7
09230:  CALL   63C8
09234:  MOVF   01,F
09236:  BNZ   92BA
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3D[0],monCal.v3V3D[1]);
09238:  MOVLW  04
0923A:  MOVLB  6
0923C:  MOVWF  xA6
0923E:  MOVLW  B2
09240:  MOVWF  xA5
09242:  MOVLB  0
09244:  CALL   6390
09248:  MOVFF  02,03
0924C:  MOVF   01,W
0924E:  ADDLW  B2
09250:  MOVLB  6
09252:  MOVWF  x9E
09254:  MOVLW  04
09256:  ADDWFC 02,W
09258:  MOVWF  x9F
0925A:  MOVFF  FE8,557
0925E:  MOVFF  69E,556
09262:  MOVLW  89
09264:  MOVWF  FE9
09266:  MOVFF  E5,6AA
0926A:  MOVFF  E4,6A9
0926E:  MOVFF  E3,6A8
09272:  MOVFF  E2,6A7
09276:  MOVLW  02
09278:  MOVWF  xAB
0927A:  MOVLB  0
0927C:  CALL   7168
09280:  MOVLW  2C
09282:  MOVLB  6
09284:  MOVWF  xB4
09286:  MOVLB  0
09288:  CALL   6440
0928C:  MOVLW  89
0928E:  MOVWF  FE9
09290:  MOVFF  E9,6AA
09294:  MOVFF  E8,6A9
09298:  MOVFF  E7,6A8
0929C:  MOVFF  E6,6A7
092A0:  MOVLW  02
092A2:  MOVLB  6
092A4:  MOVWF  xAB
092A6:  MOVLB  0
092A8:  CALL   7168
092AC:  MOVLW  2C
092AE:  MOVLB  6
092B0:  MOVWF  xB4
092B2:  MOVLB  0
092B4:  CALL   6440
....................    }
092B8:  BRA    92C0
.................... //!   else if (0 == strcmp(s_all, arg1)) {
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.vN15[0],monCal.vN15[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v200[0],monCal.v200[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v5V6[0],monCal.v5V6[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v5VA[0],monCal.v5VA[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V6X[0],monCal.v3V6X[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3A[0],monCal.v3V3A[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3D[0],monCal.v3V3D[1]);
.................... //!   }
....................    else return INV_PARAM;
092BA:  MOVLW  02
092BC:  MOVWF  01
092BE:  BRA    92C4
....................    
....................    return SUCCESS;
092C0:  MOVLW  00
092C2:  MOVWF  01
092C4:  RETURN 0
.................... }
.................... 
.................... int8 setMonitorCalParam(unsigned int8 rec){
.................... 
....................    return SUCCESS;
092C6:  MOVLW  00
092C8:  MOVWF  01
092CA:  RETURN 0
.................... }
.................... 
.................... int8 getMonitorValue(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    char *arg1;
....................    char *s_N15 = "N15";
092CC:  MOVLW  4E
092CE:  MOVLB  6
092D0:  MOVWF  x73
092D2:  MOVLW  31
092D4:  MOVWF  x74
092D6:  MOVLW  35
092D8:  MOVWF  x75
092DA:  CLRF   x76
092DC:  MOVLW  06
092DE:  MOVWF  x72
092E0:  MOVLW  73
092E2:  MOVWF  x71
....................    char *s_200 = "200";
092E4:  MOVLW  32
092E6:  MOVWF  x79
092E8:  MOVLW  30
092EA:  MOVWF  x7A
092EC:  MOVWF  x7B
092EE:  CLRF   x7C
092F0:  MOVLW  06
092F2:  MOVWF  x78
092F4:  MOVLW  79
092F6:  MOVWF  x77
....................    char *s_5V6 = "5V6";
092F8:  MOVLW  35
092FA:  MOVWF  x7F
092FC:  MOVLW  56
092FE:  MOVWF  x80
09300:  MOVLW  36
09302:  MOVWF  x81
09304:  CLRF   x82
09306:  MOVLW  06
09308:  MOVWF  x7E
0930A:  MOVLW  7F
0930C:  MOVWF  x7D
....................    char *s_5VA = "5VA";
0930E:  MOVLW  35
09310:  MOVWF  x85
09312:  MOVLW  56
09314:  MOVWF  x86
09316:  MOVLW  41
09318:  MOVWF  x87
0931A:  CLRF   x88
0931C:  MOVLW  06
0931E:  MOVWF  x84
09320:  MOVLW  85
09322:  MOVWF  x83
....................    char *s_3V6X = "3V6X";
09324:  MOVLW  33
09326:  MOVWF  x8B
09328:  MOVLW  56
0932A:  MOVWF  x8C
0932C:  MOVLW  36
0932E:  MOVWF  x8D
09330:  MOVLW  58
09332:  MOVWF  x8E
09334:  CLRF   x8F
09336:  MOVLW  06
09338:  MOVWF  x8A
0933A:  MOVLW  8B
0933C:  MOVWF  x89
....................    char *s_3V3A = "3V3A";
0933E:  MOVLW  33
09340:  MOVWF  x92
09342:  MOVLW  56
09344:  MOVWF  x93
09346:  MOVLW  33
09348:  MOVWF  x94
0934A:  MOVLW  41
0934C:  MOVWF  x95
0934E:  CLRF   x96
09350:  MOVLW  06
09352:  MOVWF  x91
09354:  MOVLW  92
09356:  MOVWF  x90
....................    char *s_3V3D = "3V3D";
09358:  MOVLW  33
0935A:  MOVWF  x99
0935C:  MOVLW  56
0935E:  MOVWF  x9A
09360:  MOVLW  33
09362:  MOVWF  x9B
09364:  MOVLW  44
09366:  MOVWF  x9C
09368:  CLRF   x9D
0936A:  MOVLW  06
0936C:  MOVWF  x98
0936E:  MOVLW  99
09370:  MOVWF  x97
....................    char *s_all = "all";
09372:  MOVLW  61
09374:  MOVWF  xA0
09376:  MOVLW  6C
09378:  MOVWF  xA1
0937A:  MOVWF  xA2
0937C:  CLRF   xA3
0937E:  MOVLW  06
09380:  MOVWF  x9F
09382:  MOVLW  A0
09384:  MOVWF  x9E
....................    
....................    arg1 = SERcmd[rec].p[2];
09386:  CLRF   xB1
09388:  MOVFF  663,6B0
0938C:  CLRF   xB3
0938E:  MOVLW  B5
09390:  MOVWF  xB2
09392:  MOVLB  0
09394:  CALL   07F0
09398:  MOVFF  02,6A5
0939C:  MOVFF  01,6A4
093A0:  MOVLW  06
093A2:  MOVLB  6
093A4:  ADDWF  xA4,F
093A6:  MOVLW  00
093A8:  ADDWFC xA5,F
093AA:  MOVLW  32
093AC:  ADDWF  xA4,W
093AE:  MOVWF  01
093B0:  MOVLW  00
093B2:  ADDWFC xA5,W
093B4:  MOVWF  03
093B6:  MOVF   01,W
093B8:  ADDLW  DC
093BA:  MOVWF  01
093BC:  MOVLW  01
093BE:  ADDWFC 03,F
093C0:  MOVFF  01,66F
093C4:  MOVFF  03,670
....................    
....................    /*** GET MONITOR VALUES ************/
....................    if      (0 == strcmp(s_N15, arg1)) {
093C8:  MOVFF  672,6A6
093CC:  MOVFF  671,6A5
093D0:  MOVFF  670,6A8
093D4:  MOVFF  66F,6A7
093D8:  MOVLB  0
093DA:  CALL   63C8
093DE:  MOVF   01,F
093E0:  BNZ   9438
....................       sprintf(retData+strlen(retData), "%.2f,", monitorVals.vN15);
093E2:  MOVLW  04
093E4:  MOVLB  6
093E6:  MOVWF  xA6
093E8:  MOVLW  B2
093EA:  MOVWF  xA5
093EC:  MOVLB  0
093EE:  CALL   6390
093F2:  MOVFF  02,03
093F6:  MOVF   01,W
093F8:  ADDLW  B2
093FA:  MOVLB  6
093FC:  MOVWF  xA4
093FE:  MOVLW  04
09400:  ADDWFC 02,W
09402:  MOVWF  xA5
09404:  MOVFF  FE8,557
09408:  MOVFF  6A4,556
0940C:  MOVLW  89
0940E:  MOVWF  FE9
09410:  MOVFF  F6,6AA
09414:  MOVFF  F5,6A9
09418:  MOVFF  F4,6A8
0941C:  MOVFF  F3,6A7
09420:  MOVLW  02
09422:  MOVWF  xAB
09424:  MOVLB  0
09426:  CALL   7168
0942A:  MOVLW  2C
0942C:  MOVLB  6
0942E:  MOVWF  xB4
09430:  MOVLB  0
09432:  CALL   6440
....................    }
09436:  BRA    993A
....................    else if (0 == strcmp(s_200, arg1)) {
09438:  MOVFF  678,6A6
0943C:  MOVFF  677,6A5
09440:  MOVFF  670,6A8
09444:  MOVFF  66F,6A7
09448:  CALL   63C8
0944C:  MOVF   01,F
0944E:  BNZ   94A6
....................       sprintf(retData+strlen(retData), "%.1f,", monitorVals.v200);
09450:  MOVLW  04
09452:  MOVLB  6
09454:  MOVWF  xA6
09456:  MOVLW  B2
09458:  MOVWF  xA5
0945A:  MOVLB  0
0945C:  CALL   6390
09460:  MOVFF  02,03
09464:  MOVF   01,W
09466:  ADDLW  B2
09468:  MOVLB  6
0946A:  MOVWF  xA4
0946C:  MOVLW  04
0946E:  ADDWFC 02,W
09470:  MOVWF  xA5
09472:  MOVFF  FE8,557
09476:  MOVFF  6A4,556
0947A:  MOVLW  89
0947C:  MOVWF  FE9
0947E:  MOVFF  FA,6AA
09482:  MOVFF  F9,6A9
09486:  MOVFF  F8,6A8
0948A:  MOVFF  F7,6A7
0948E:  MOVLW  01
09490:  MOVWF  xAB
09492:  MOVLB  0
09494:  CALL   7168
09498:  MOVLW  2C
0949A:  MOVLB  6
0949C:  MOVWF  xB4
0949E:  MOVLB  0
094A0:  CALL   6440
....................    }
094A4:  BRA    993A
....................    else if (0 == strcmp(s_5V6, arg1)) {
094A6:  MOVFF  67E,6A6
094AA:  MOVFF  67D,6A5
094AE:  MOVFF  670,6A8
094B2:  MOVFF  66F,6A7
094B6:  CALL   63C8
094BA:  MOVF   01,F
094BC:  BNZ   9514
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5V6);
094BE:  MOVLW  04
094C0:  MOVLB  6
094C2:  MOVWF  xA6
094C4:  MOVLW  B2
094C6:  MOVWF  xA5
094C8:  MOVLB  0
094CA:  CALL   6390
094CE:  MOVFF  02,03
094D2:  MOVF   01,W
094D4:  ADDLW  B2
094D6:  MOVLB  6
094D8:  MOVWF  xA4
094DA:  MOVLW  04
094DC:  ADDWFC 02,W
094DE:  MOVWF  xA5
094E0:  MOVFF  FE8,557
094E4:  MOVFF  6A4,556
094E8:  MOVLW  89
094EA:  MOVWF  FE9
094EC:  MOVFF  FE,6AA
094F0:  MOVFF  FD,6A9
094F4:  MOVFF  FC,6A8
094F8:  MOVFF  FB,6A7
094FC:  MOVLW  03
094FE:  MOVWF  xAB
09500:  MOVLB  0
09502:  CALL   7168
09506:  MOVLW  2C
09508:  MOVLB  6
0950A:  MOVWF  xB4
0950C:  MOVLB  0
0950E:  CALL   6440
....................    }
09512:  BRA    993A
....................    else if (0 == strcmp(s_5VA, arg1)) {
09514:  MOVFF  684,6A6
09518:  MOVFF  683,6A5
0951C:  MOVFF  670,6A8
09520:  MOVFF  66F,6A7
09524:  CALL   63C8
09528:  MOVF   01,F
0952A:  BNZ   9582
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5VA);
0952C:  MOVLW  04
0952E:  MOVLB  6
09530:  MOVWF  xA6
09532:  MOVLW  B2
09534:  MOVWF  xA5
09536:  MOVLB  0
09538:  CALL   6390
0953C:  MOVFF  02,03
09540:  MOVF   01,W
09542:  ADDLW  B2
09544:  MOVLB  6
09546:  MOVWF  xA4
09548:  MOVLW  04
0954A:  ADDWFC 02,W
0954C:  MOVWF  xA5
0954E:  MOVFF  FE8,557
09552:  MOVFF  6A4,556
09556:  MOVLW  89
09558:  MOVWF  FE9
0955A:  MOVFF  102,6AA
0955E:  MOVFF  101,6A9
09562:  MOVFF  100,6A8
09566:  MOVFF  FF,6A7
0956A:  MOVLW  03
0956C:  MOVWF  xAB
0956E:  MOVLB  0
09570:  CALL   7168
09574:  MOVLW  2C
09576:  MOVLB  6
09578:  MOVWF  xB4
0957A:  MOVLB  0
0957C:  CALL   6440
....................    }
09580:  BRA    993A
....................    else if (0 == strcmp(s_3V6X, arg1)) {
09582:  MOVFF  68A,6A6
09586:  MOVFF  689,6A5
0958A:  MOVFF  670,6A8
0958E:  MOVFF  66F,6A7
09592:  CALL   63C8
09596:  MOVF   01,F
09598:  BNZ   95F0
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V6X);
0959A:  MOVLW  04
0959C:  MOVLB  6
0959E:  MOVWF  xA6
095A0:  MOVLW  B2
095A2:  MOVWF  xA5
095A4:  MOVLB  0
095A6:  CALL   6390
095AA:  MOVFF  02,03
095AE:  MOVF   01,W
095B0:  ADDLW  B2
095B2:  MOVLB  6
095B4:  MOVWF  xA4
095B6:  MOVLW  04
095B8:  ADDWFC 02,W
095BA:  MOVWF  xA5
095BC:  MOVFF  FE8,557
095C0:  MOVFF  6A4,556
095C4:  MOVLW  89
095C6:  MOVWF  FE9
095C8:  MOVFF  106,6AA
095CC:  MOVFF  105,6A9
095D0:  MOVFF  104,6A8
095D4:  MOVFF  103,6A7
095D8:  MOVLW  03
095DA:  MOVWF  xAB
095DC:  MOVLB  0
095DE:  CALL   7168
095E2:  MOVLW  2C
095E4:  MOVLB  6
095E6:  MOVWF  xB4
095E8:  MOVLB  0
095EA:  CALL   6440
....................    }
095EE:  BRA    993A
....................    else if (0 == strcmp(s_3V3A, arg1)) {
095F0:  MOVFF  691,6A6
095F4:  MOVFF  690,6A5
095F8:  MOVFF  670,6A8
095FC:  MOVFF  66F,6A7
09600:  CALL   63C8
09604:  MOVF   01,F
09606:  BNZ   965E
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3A);
09608:  MOVLW  04
0960A:  MOVLB  6
0960C:  MOVWF  xA6
0960E:  MOVLW  B2
09610:  MOVWF  xA5
09612:  MOVLB  0
09614:  CALL   6390
09618:  MOVFF  02,03
0961C:  MOVF   01,W
0961E:  ADDLW  B2
09620:  MOVLB  6
09622:  MOVWF  xA4
09624:  MOVLW  04
09626:  ADDWFC 02,W
09628:  MOVWF  xA5
0962A:  MOVFF  FE8,557
0962E:  MOVFF  6A4,556
09632:  MOVLW  89
09634:  MOVWF  FE9
09636:  MOVFF  10A,6AA
0963A:  MOVFF  109,6A9
0963E:  MOVFF  108,6A8
09642:  MOVFF  107,6A7
09646:  MOVLW  03
09648:  MOVWF  xAB
0964A:  MOVLB  0
0964C:  CALL   7168
09650:  MOVLW  2C
09652:  MOVLB  6
09654:  MOVWF  xB4
09656:  MOVLB  0
09658:  CALL   6440
....................    }
0965C:  BRA    993A
....................    else if (0 == strcmp(s_3V3D, arg1)) {
0965E:  MOVFF  698,6A6
09662:  MOVFF  697,6A5
09666:  MOVFF  670,6A8
0966A:  MOVFF  66F,6A7
0966E:  CALL   63C8
09672:  MOVF   01,F
09674:  BNZ   96CC
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3D);
09676:  MOVLW  04
09678:  MOVLB  6
0967A:  MOVWF  xA6
0967C:  MOVLW  B2
0967E:  MOVWF  xA5
09680:  MOVLB  0
09682:  CALL   6390
09686:  MOVFF  02,03
0968A:  MOVF   01,W
0968C:  ADDLW  B2
0968E:  MOVLB  6
09690:  MOVWF  xA4
09692:  MOVLW  04
09694:  ADDWFC 02,W
09696:  MOVWF  xA5
09698:  MOVFF  FE8,557
0969C:  MOVFF  6A4,556
096A0:  MOVLW  89
096A2:  MOVWF  FE9
096A4:  MOVFF  10E,6AA
096A8:  MOVFF  10D,6A9
096AC:  MOVFF  10C,6A8
096B0:  MOVFF  10B,6A7
096B4:  MOVLW  03
096B6:  MOVWF  xAB
096B8:  MOVLB  0
096BA:  CALL   7168
096BE:  MOVLW  2C
096C0:  MOVLB  6
096C2:  MOVWF  xB4
096C4:  MOVLB  0
096C6:  CALL   6440
....................    }
096CA:  BRA    993A
....................    else if (0 == strcmp(s_all, arg1)) {
096CC:  MOVFF  69F,6A6
096D0:  MOVFF  69E,6A5
096D4:  MOVFF  670,6A8
096D8:  MOVFF  66F,6A7
096DC:  CALL   63C8
096E0:  MOVF   01,F
096E2:  BTFSS  FD8.2
096E4:  BRA    9934
....................       sprintf(retData+strlen(retData), "%.2f,", monitorVals.vN15);
096E6:  MOVLW  04
096E8:  MOVLB  6
096EA:  MOVWF  xA6
096EC:  MOVLW  B2
096EE:  MOVWF  xA5
096F0:  MOVLB  0
096F2:  CALL   6390
096F6:  MOVFF  02,03
096FA:  MOVF   01,W
096FC:  ADDLW  B2
096FE:  MOVLB  6
09700:  MOVWF  xA4
09702:  MOVLW  04
09704:  ADDWFC 02,W
09706:  MOVWF  xA5
09708:  MOVFF  FE8,557
0970C:  MOVFF  6A4,556
09710:  MOVLW  89
09712:  MOVWF  FE9
09714:  MOVFF  F6,6AA
09718:  MOVFF  F5,6A9
0971C:  MOVFF  F4,6A8
09720:  MOVFF  F3,6A7
09724:  MOVLW  02
09726:  MOVWF  xAB
09728:  MOVLB  0
0972A:  CALL   7168
0972E:  MOVLW  2C
09730:  MOVLB  6
09732:  MOVWF  xB4
09734:  MOVLB  0
09736:  CALL   6440
....................       sprintf(retData+strlen(retData), "%.1f,", monitorVals.v200);
0973A:  MOVLW  04
0973C:  MOVLB  6
0973E:  MOVWF  xA6
09740:  MOVLW  B2
09742:  MOVWF  xA5
09744:  MOVLB  0
09746:  CALL   6390
0974A:  MOVFF  02,03
0974E:  MOVF   01,W
09750:  ADDLW  B2
09752:  MOVLB  6
09754:  MOVWF  xA4
09756:  MOVLW  04
09758:  ADDWFC 02,W
0975A:  MOVWF  xA5
0975C:  MOVFF  FE8,557
09760:  MOVFF  6A4,556
09764:  MOVLW  89
09766:  MOVWF  FE9
09768:  MOVFF  FA,6AA
0976C:  MOVFF  F9,6A9
09770:  MOVFF  F8,6A8
09774:  MOVFF  F7,6A7
09778:  MOVLW  01
0977A:  MOVWF  xAB
0977C:  MOVLB  0
0977E:  CALL   7168
09782:  MOVLW  2C
09784:  MOVLB  6
09786:  MOVWF  xB4
09788:  MOVLB  0
0978A:  CALL   6440
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5V6);
0978E:  MOVLW  04
09790:  MOVLB  6
09792:  MOVWF  xA6
09794:  MOVLW  B2
09796:  MOVWF  xA5
09798:  MOVLB  0
0979A:  CALL   6390
0979E:  MOVFF  02,03
097A2:  MOVF   01,W
097A4:  ADDLW  B2
097A6:  MOVLB  6
097A8:  MOVWF  xA4
097AA:  MOVLW  04
097AC:  ADDWFC 02,W
097AE:  MOVWF  xA5
097B0:  MOVFF  FE8,557
097B4:  MOVFF  6A4,556
097B8:  MOVLW  89
097BA:  MOVWF  FE9
097BC:  MOVFF  FE,6AA
097C0:  MOVFF  FD,6A9
097C4:  MOVFF  FC,6A8
097C8:  MOVFF  FB,6A7
097CC:  MOVLW  03
097CE:  MOVWF  xAB
097D0:  MOVLB  0
097D2:  CALL   7168
097D6:  MOVLW  2C
097D8:  MOVLB  6
097DA:  MOVWF  xB4
097DC:  MOVLB  0
097DE:  CALL   6440
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5VA);
097E2:  MOVLW  04
097E4:  MOVLB  6
097E6:  MOVWF  xA6
097E8:  MOVLW  B2
097EA:  MOVWF  xA5
097EC:  MOVLB  0
097EE:  CALL   6390
097F2:  MOVFF  02,03
097F6:  MOVF   01,W
097F8:  ADDLW  B2
097FA:  MOVLB  6
097FC:  MOVWF  xA4
097FE:  MOVLW  04
09800:  ADDWFC 02,W
09802:  MOVWF  xA5
09804:  MOVFF  FE8,557
09808:  MOVFF  6A4,556
0980C:  MOVLW  89
0980E:  MOVWF  FE9
09810:  MOVFF  102,6AA
09814:  MOVFF  101,6A9
09818:  MOVFF  100,6A8
0981C:  MOVFF  FF,6A7
09820:  MOVLW  03
09822:  MOVWF  xAB
09824:  MOVLB  0
09826:  CALL   7168
0982A:  MOVLW  2C
0982C:  MOVLB  6
0982E:  MOVWF  xB4
09830:  MOVLB  0
09832:  CALL   6440
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V6X);
09836:  MOVLW  04
09838:  MOVLB  6
0983A:  MOVWF  xA6
0983C:  MOVLW  B2
0983E:  MOVWF  xA5
09840:  MOVLB  0
09842:  CALL   6390
09846:  MOVFF  02,03
0984A:  MOVF   01,W
0984C:  ADDLW  B2
0984E:  MOVLB  6
09850:  MOVWF  xA4
09852:  MOVLW  04
09854:  ADDWFC 02,W
09856:  MOVWF  xA5
09858:  MOVFF  FE8,557
0985C:  MOVFF  6A4,556
09860:  MOVLW  89
09862:  MOVWF  FE9
09864:  MOVFF  106,6AA
09868:  MOVFF  105,6A9
0986C:  MOVFF  104,6A8
09870:  MOVFF  103,6A7
09874:  MOVLW  03
09876:  MOVWF  xAB
09878:  MOVLB  0
0987A:  CALL   7168
0987E:  MOVLW  2C
09880:  MOVLB  6
09882:  MOVWF  xB4
09884:  MOVLB  0
09886:  CALL   6440
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3A);
0988A:  MOVLW  04
0988C:  MOVLB  6
0988E:  MOVWF  xA6
09890:  MOVLW  B2
09892:  MOVWF  xA5
09894:  MOVLB  0
09896:  CALL   6390
0989A:  MOVFF  02,03
0989E:  MOVF   01,W
098A0:  ADDLW  B2
098A2:  MOVLB  6
098A4:  MOVWF  xA4
098A6:  MOVLW  04
098A8:  ADDWFC 02,W
098AA:  MOVWF  xA5
098AC:  MOVFF  FE8,557
098B0:  MOVFF  6A4,556
098B4:  MOVLW  89
098B6:  MOVWF  FE9
098B8:  MOVFF  10A,6AA
098BC:  MOVFF  109,6A9
098C0:  MOVFF  108,6A8
098C4:  MOVFF  107,6A7
098C8:  MOVLW  03
098CA:  MOVWF  xAB
098CC:  MOVLB  0
098CE:  CALL   7168
098D2:  MOVLW  2C
098D4:  MOVLB  6
098D6:  MOVWF  xB4
098D8:  MOVLB  0
098DA:  CALL   6440
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3D);
098DE:  MOVLW  04
098E0:  MOVLB  6
098E2:  MOVWF  xA6
098E4:  MOVLW  B2
098E6:  MOVWF  xA5
098E8:  MOVLB  0
098EA:  CALL   6390
098EE:  MOVFF  02,03
098F2:  MOVF   01,W
098F4:  ADDLW  B2
098F6:  MOVLB  6
098F8:  MOVWF  xA4
098FA:  MOVLW  04
098FC:  ADDWFC 02,W
098FE:  MOVWF  xA5
09900:  MOVFF  FE8,557
09904:  MOVFF  6A4,556
09908:  MOVLW  89
0990A:  MOVWF  FE9
0990C:  MOVFF  10E,6AA
09910:  MOVFF  10D,6A9
09914:  MOVFF  10C,6A8
09918:  MOVFF  10B,6A7
0991C:  MOVLW  03
0991E:  MOVWF  xAB
09920:  MOVLB  0
09922:  CALL   7168
09926:  MOVLW  2C
09928:  MOVLB  6
0992A:  MOVWF  xB4
0992C:  MOVLB  0
0992E:  CALL   6440
....................    }
09932:  BRA    993A
....................    else return INV_PARAM;
09934:  MOVLW  02
09936:  MOVWF  01
09938:  BRA    993E
....................    
....................    return SUCCESS;
0993A:  MOVLW  00
0993C:  MOVWF  01
0993E:  RETURN 0
.................... }
.................... 
.................... int8 getPIDdata(unsigned int8 rec){
....................   /*** ARG CHECKS ********************/ 
....................    int8 arg1;
....................    char *arg2;
....................    char *s_PV = "PV";
09940:  MOVLW  50
09942:  MOVLB  6
09944:  MOVWF  x74
09946:  MOVLW  56
09948:  MOVWF  x75
0994A:  CLRF   x76
0994C:  MOVLW  06
0994E:  MOVWF  x73
09950:  MOVLW  74
09952:  MOVWF  x72
....................    char *s_CV = "CV";
09954:  MOVLW  43
09956:  MOVWF  x79
09958:  MOVLW  56
0995A:  MOVWF  x7A
0995C:  CLRF   x7B
0995E:  MOVLW  06
09960:  MOVWF  x78
09962:  MOVLW  79
09964:  MOVWF  x77
....................    char *s_PVold = "PVold";
09966:  MOVLW  50
09968:  MOVWF  x7E
0996A:  MOVLW  56
0996C:  MOVWF  x7F
0996E:  MOVLW  6F
09970:  MOVWF  x80
09972:  MOVLW  6C
09974:  MOVWF  x81
09976:  MOVLW  64
09978:  MOVWF  x82
0997A:  CLRF   x83
0997C:  MOVLW  06
0997E:  MOVWF  x7D
09980:  MOVLW  7E
09982:  MOVWF  x7C
....................    char *s_I = "I";
09984:  MOVLW  49
09986:  MOVWF  x86
09988:  CLRF   x87
0998A:  MOVLW  06
0998C:  MOVWF  x85
0998E:  MOVLW  86
09990:  MOVWF  x84
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
09992:  CLRF   xB1
09994:  MOVFF  663,6B0
09998:  CLRF   xB3
0999A:  MOVLW  B5
0999C:  MOVWF  xB2
0999E:  MOVLB  0
099A0:  CALL   07F0
099A4:  MOVFF  02,689
099A8:  MOVFF  01,688
099AC:  MOVLW  06
099AE:  MOVLB  6
099B0:  ADDWF  x88,F
099B2:  MOVLW  00
099B4:  ADDWFC x89,F
099B6:  MOVLW  32
099B8:  ADDWF  x88,W
099BA:  MOVWF  01
099BC:  MOVLW  00
099BE:  ADDWFC x89,W
099C0:  MOVWF  03
099C2:  MOVF   01,W
099C4:  ADDLW  DC
099C6:  MOVWF  01
099C8:  MOVLW  01
099CA:  ADDWFC 03,F
099CC:  MOVFF  01,688
099D0:  MOVFF  03,689
099D4:  MOVFF  03,698
099D8:  MOVFF  01,697
099DC:  MOVLB  0
099DE:  CALL   6508
099E2:  MOVF   01,F
099E4:  BNZ   99EE
099E6:  MOVLW  02
099E8:  MOVWF  01
099EA:  BRA    9D84
099EC:  BRA    9A4C
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
099EE:  MOVLB  6
099F0:  CLRF   xB1
099F2:  MOVFF  663,6B0
099F6:  CLRF   xB3
099F8:  MOVLW  B5
099FA:  MOVWF  xB2
099FC:  MOVLB  0
099FE:  CALL   07F0
09A02:  MOVFF  02,689
09A06:  MOVFF  01,688
09A0A:  MOVLW  06
09A0C:  MOVLB  6
09A0E:  ADDWF  x88,F
09A10:  MOVLW  00
09A12:  ADDWFC x89,F
09A14:  MOVLW  32
09A16:  ADDWF  x88,W
09A18:  MOVWF  01
09A1A:  MOVLW  00
09A1C:  ADDWFC x89,W
09A1E:  MOVWF  03
09A20:  MOVF   01,W
09A22:  ADDLW  DC
09A24:  MOVWF  01
09A26:  MOVLW  01
09A28:  ADDWFC 03,F
09A2A:  MOVFF  01,688
09A2E:  MOVFF  03,689
09A32:  MOVFF  03,698
09A36:  MOVFF  01,697
09A3A:  CLRF   x9A
09A3C:  CLRF   x99
09A3E:  MOVLW  0A
09A40:  MOVWF  x9B
09A42:  MOVLB  0
09A44:  CALL   65F8
09A48:  MOVFF  01,66F
....................    
....................    arg2 = SERcmd[rec].p[3];
09A4C:  MOVLB  6
09A4E:  CLRF   xB1
09A50:  MOVFF  663,6B0
09A54:  CLRF   xB3
09A56:  MOVLW  B5
09A58:  MOVWF  xB2
09A5A:  MOVLB  0
09A5C:  CALL   07F0
09A60:  MOVFF  02,689
09A64:  MOVFF  01,688
09A68:  MOVLW  06
09A6A:  MOVLB  6
09A6C:  ADDWF  x88,F
09A6E:  MOVLW  00
09A70:  ADDWFC x89,F
09A72:  MOVLW  4B
09A74:  ADDWF  x88,W
09A76:  MOVWF  01
09A78:  MOVLW  00
09A7A:  ADDWFC x89,W
09A7C:  MOVWF  03
09A7E:  MOVF   01,W
09A80:  ADDLW  DC
09A82:  MOVWF  01
09A84:  MOVLW  01
09A86:  ADDWFC 03,F
09A88:  MOVFF  01,670
09A8C:  MOVFF  03,671
....................    
....................    /*** GET PV, CV, PVold, I, or A(LL) VALUE **********/
....................    if      (0 == strcmp(s_PV, arg2))     sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].PV);
09A90:  MOVFF  673,6A6
09A94:  MOVFF  672,6A5
09A98:  MOVFF  671,6A8
09A9C:  MOVFF  670,6A7
09AA0:  MOVLB  0
09AA2:  CALL   63C8
09AA6:  MOVF   01,F
09AA8:  BNZ   9B4C
09AAA:  MOVLW  04
09AAC:  MOVLB  6
09AAE:  MOVWF  xA6
09AB0:  MOVLW  B2
09AB2:  MOVWF  xA5
09AB4:  MOVLB  0
09AB6:  CALL   6390
09ABA:  MOVF   01,W
09ABC:  ADDLW  B2
09ABE:  MOVLB  6
09AC0:  MOVWF  x88
09AC2:  MOVLW  04
09AC4:  ADDWFC 02,W
09AC6:  MOVWF  x89
09AC8:  MOVLW  01
09ACA:  SUBWF  x6F,W
09ACC:  MULLW  20
09ACE:  MOVF   FF3,W
09AD0:  CLRF   x8B
09AD2:  MOVWF  x8A
09AD4:  MOVLW  10
09AD6:  ADDWF  x8A,W
09AD8:  MOVWF  01
09ADA:  MOVLW  00
09ADC:  ADDWFC x8B,W
09ADE:  MOVWF  03
09AE0:  MOVF   01,W
09AE2:  ADDLW  20
09AE4:  MOVWF  FE9
09AE6:  MOVLW  00
09AE8:  ADDWFC 03,W
09AEA:  MOVWF  FEA
09AEC:  MOVFF  FEF,68A
09AF0:  MOVFF  FEC,68B
09AF4:  MOVFF  FEC,68C
09AF8:  MOVFF  FEC,68D
09AFC:  MOVFF  689,557
09B00:  MOVFF  688,556
09B04:  MOVFF  66F,698
09B08:  MOVLW  18
09B0A:  MOVWF  x99
09B0C:  MOVLB  0
09B0E:  CALL   694C
09B12:  MOVLW  2C
09B14:  MOVLB  6
09B16:  MOVWF  xB4
09B18:  MOVLB  0
09B1A:  CALL   6440
09B1E:  MOVLW  89
09B20:  MOVWF  FE9
09B22:  MOVFF  68D,6AA
09B26:  MOVFF  68C,6A9
09B2A:  MOVFF  68B,6A8
09B2E:  MOVFF  68A,6A7
09B32:  MOVLW  02
09B34:  MOVLB  6
09B36:  MOVWF  xAB
09B38:  MOVLB  0
09B3A:  CALL   7168
09B3E:  MOVLW  2C
09B40:  MOVLB  6
09B42:  MOVWF  xB4
09B44:  MOVLB  0
09B46:  CALL   6440
09B4A:  BRA    9D80
....................    else if (0 == strcmp(s_CV, arg2))     sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].CV);
09B4C:  MOVFF  678,6A6
09B50:  MOVFF  677,6A5
09B54:  MOVFF  671,6A8
09B58:  MOVFF  670,6A7
09B5C:  CALL   63C8
09B60:  MOVF   01,F
09B62:  BNZ   9C06
09B64:  MOVLW  04
09B66:  MOVLB  6
09B68:  MOVWF  xA6
09B6A:  MOVLW  B2
09B6C:  MOVWF  xA5
09B6E:  MOVLB  0
09B70:  CALL   6390
09B74:  MOVF   01,W
09B76:  ADDLW  B2
09B78:  MOVLB  6
09B7A:  MOVWF  x88
09B7C:  MOVLW  04
09B7E:  ADDWFC 02,W
09B80:  MOVWF  x89
09B82:  MOVLW  01
09B84:  SUBWF  x6F,W
09B86:  MULLW  20
09B88:  MOVF   FF3,W
09B8A:  CLRF   x8B
09B8C:  MOVWF  x8A
09B8E:  MOVLW  18
09B90:  ADDWF  x8A,W
09B92:  MOVWF  01
09B94:  MOVLW  00
09B96:  ADDWFC x8B,W
09B98:  MOVWF  03
09B9A:  MOVF   01,W
09B9C:  ADDLW  20
09B9E:  MOVWF  FE9
09BA0:  MOVLW  00
09BA2:  ADDWFC 03,W
09BA4:  MOVWF  FEA
09BA6:  MOVFF  FEF,68A
09BAA:  MOVFF  FEC,68B
09BAE:  MOVFF  FEC,68C
09BB2:  MOVFF  FEC,68D
09BB6:  MOVFF  689,557
09BBA:  MOVFF  688,556
09BBE:  MOVFF  66F,698
09BC2:  MOVLW  18
09BC4:  MOVWF  x99
09BC6:  MOVLB  0
09BC8:  CALL   694C
09BCC:  MOVLW  2C
09BCE:  MOVLB  6
09BD0:  MOVWF  xB4
09BD2:  MOVLB  0
09BD4:  CALL   6440
09BD8:  MOVLW  89
09BDA:  MOVWF  FE9
09BDC:  MOVFF  68D,6AA
09BE0:  MOVFF  68C,6A9
09BE4:  MOVFF  68B,6A8
09BE8:  MOVFF  68A,6A7
09BEC:  MOVLW  02
09BEE:  MOVLB  6
09BF0:  MOVWF  xAB
09BF2:  MOVLB  0
09BF4:  CALL   7168
09BF8:  MOVLW  2C
09BFA:  MOVLB  6
09BFC:  MOVWF  xB4
09BFE:  MOVLB  0
09C00:  CALL   6440
09C04:  BRA    9D80
....................    else if (0 == strcmp(s_PVold, arg2))  sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].PVold);
09C06:  MOVFF  67D,6A6
09C0A:  MOVFF  67C,6A5
09C0E:  MOVFF  671,6A8
09C12:  MOVFF  670,6A7
09C16:  CALL   63C8
09C1A:  MOVF   01,F
09C1C:  BNZ   9CC0
09C1E:  MOVLW  04
09C20:  MOVLB  6
09C22:  MOVWF  xA6
09C24:  MOVLW  B2
09C26:  MOVWF  xA5
09C28:  MOVLB  0
09C2A:  CALL   6390
09C2E:  MOVF   01,W
09C30:  ADDLW  B2
09C32:  MOVLB  6
09C34:  MOVWF  x88
09C36:  MOVLW  04
09C38:  ADDWFC 02,W
09C3A:  MOVWF  x89
09C3C:  MOVLW  01
09C3E:  SUBWF  x6F,W
09C40:  MULLW  20
09C42:  MOVF   FF3,W
09C44:  CLRF   x8B
09C46:  MOVWF  x8A
09C48:  MOVLW  14
09C4A:  ADDWF  x8A,W
09C4C:  MOVWF  01
09C4E:  MOVLW  00
09C50:  ADDWFC x8B,W
09C52:  MOVWF  03
09C54:  MOVF   01,W
09C56:  ADDLW  20
09C58:  MOVWF  FE9
09C5A:  MOVLW  00
09C5C:  ADDWFC 03,W
09C5E:  MOVWF  FEA
09C60:  MOVFF  FEF,68A
09C64:  MOVFF  FEC,68B
09C68:  MOVFF  FEC,68C
09C6C:  MOVFF  FEC,68D
09C70:  MOVFF  689,557
09C74:  MOVFF  688,556
09C78:  MOVFF  66F,698
09C7C:  MOVLW  18
09C7E:  MOVWF  x99
09C80:  MOVLB  0
09C82:  CALL   694C
09C86:  MOVLW  2C
09C88:  MOVLB  6
09C8A:  MOVWF  xB4
09C8C:  MOVLB  0
09C8E:  CALL   6440
09C92:  MOVLW  89
09C94:  MOVWF  FE9
09C96:  MOVFF  68D,6AA
09C9A:  MOVFF  68C,6A9
09C9E:  MOVFF  68B,6A8
09CA2:  MOVFF  68A,6A7
09CA6:  MOVLW  02
09CA8:  MOVLB  6
09CAA:  MOVWF  xAB
09CAC:  MOVLB  0
09CAE:  CALL   7168
09CB2:  MOVLW  2C
09CB4:  MOVLB  6
09CB6:  MOVWF  xB4
09CB8:  MOVLB  0
09CBA:  CALL   6440
09CBE:  BRA    9D80
....................    else if (0 == strcmp(s_I, arg2))      sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].I);
09CC0:  MOVFF  685,6A6
09CC4:  MOVFF  684,6A5
09CC8:  MOVFF  671,6A8
09CCC:  MOVFF  670,6A7
09CD0:  CALL   63C8
09CD4:  MOVF   01,F
09CD6:  BNZ   9D7A
09CD8:  MOVLW  04
09CDA:  MOVLB  6
09CDC:  MOVWF  xA6
09CDE:  MOVLW  B2
09CE0:  MOVWF  xA5
09CE2:  MOVLB  0
09CE4:  CALL   6390
09CE8:  MOVF   01,W
09CEA:  ADDLW  B2
09CEC:  MOVLB  6
09CEE:  MOVWF  x88
09CF0:  MOVLW  04
09CF2:  ADDWFC 02,W
09CF4:  MOVWF  x89
09CF6:  MOVLW  01
09CF8:  SUBWF  x6F,W
09CFA:  MULLW  20
09CFC:  MOVF   FF3,W
09CFE:  CLRF   x8B
09D00:  MOVWF  x8A
09D02:  MOVLW  1C
09D04:  ADDWF  x8A,W
09D06:  MOVWF  01
09D08:  MOVLW  00
09D0A:  ADDWFC x8B,W
09D0C:  MOVWF  03
09D0E:  MOVF   01,W
09D10:  ADDLW  20
09D12:  MOVWF  FE9
09D14:  MOVLW  00
09D16:  ADDWFC 03,W
09D18:  MOVWF  FEA
09D1A:  MOVFF  FEF,68A
09D1E:  MOVFF  FEC,68B
09D22:  MOVFF  FEC,68C
09D26:  MOVFF  FEC,68D
09D2A:  MOVFF  689,557
09D2E:  MOVFF  688,556
09D32:  MOVFF  66F,698
09D36:  MOVLW  18
09D38:  MOVWF  x99
09D3A:  MOVLB  0
09D3C:  CALL   694C
09D40:  MOVLW  2C
09D42:  MOVLB  6
09D44:  MOVWF  xB4
09D46:  MOVLB  0
09D48:  CALL   6440
09D4C:  MOVLW  89
09D4E:  MOVWF  FE9
09D50:  MOVFF  68D,6AA
09D54:  MOVFF  68C,6A9
09D58:  MOVFF  68B,6A8
09D5C:  MOVFF  68A,6A7
09D60:  MOVLW  02
09D62:  MOVLB  6
09D64:  MOVWF  xAB
09D66:  MOVLB  0
09D68:  CALL   7168
09D6C:  MOVLW  2C
09D6E:  MOVLB  6
09D70:  MOVWF  xB4
09D72:  MOVLB  0
09D74:  CALL   6440
09D78:  BRA    9D80
....................    else return INV_PARAM;
09D7A:  MOVLW  02
09D7C:  MOVWF  01
09D7E:  BRA    9D84
....................    
....................    return SUCCESS;
09D80:  MOVLW  00
09D82:  MOVWF  01
09D84:  RETURN 0
.................... }
.................... 
.................... int8 getIPdata(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char *arg2;
....................    char *s_raw = "raw";
*
09EA4:  MOVLW  72
09EA6:  MOVLB  6
09EA8:  MOVWF  x74
09EAA:  MOVLW  61
09EAC:  MOVWF  x75
09EAE:  MOVLW  77
09EB0:  MOVWF  x76
09EB2:  CLRF   x77
09EB4:  MOVLW  06
09EB6:  MOVWF  x73
09EB8:  MOVLW  74
09EBA:  MOVWF  x72
....................    char *s_calibrated = "calib";
09EBC:  MOVLW  63
09EBE:  MOVWF  x7A
09EC0:  MOVLW  61
09EC2:  MOVWF  x7B
09EC4:  MOVLW  6C
09EC6:  MOVWF  x7C
09EC8:  MOVLW  69
09ECA:  MOVWF  x7D
09ECC:  MOVLW  62
09ECE:  MOVWF  x7E
09ED0:  CLRF   x7F
09ED2:  MOVLW  06
09ED4:  MOVWF  x79
09ED6:  MOVLW  7A
09ED8:  MOVWF  x78
....................    char *s_p0 = "p0";
09EDA:  MOVLW  70
09EDC:  MOVWF  x82
09EDE:  MOVLW  30
09EE0:  MOVWF  x83
09EE2:  CLRF   x84
09EE4:  MOVLW  06
09EE6:  MOVWF  x81
09EE8:  MOVLW  82
09EEA:  MOVWF  x80
....................    char *s_poles = "poles";
09EEC:  MOVLW  70
09EEE:  MOVWF  x87
09EF0:  MOVLW  6F
09EF2:  MOVWF  x88
09EF4:  MOVLW  6C
09EF6:  MOVWF  x89
09EF8:  MOVLW  65
09EFA:  MOVWF  x8A
09EFC:  MOVLW  73
09EFE:  MOVWF  x8B
09F00:  CLRF   x8C
09F02:  MOVLW  06
09F04:  MOVWF  x86
09F06:  MOVLW  87
09F08:  MOVWF  x85
....................    char *s_real = "real";
09F0A:  MOVLW  72
09F0C:  MOVWF  x8F
09F0E:  MOVLW  65
09F10:  MOVWF  x90
09F12:  MOVLW  61
09F14:  MOVWF  x91
09F16:  MOVLW  6C
09F18:  MOVWF  x92
09F1A:  CLRF   x93
09F1C:  MOVLW  06
09F1E:  MOVWF  x8E
09F20:  MOVLW  8F
09F22:  MOVWF  x8D
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
09F24:  CLRF   xB1
09F26:  MOVFF  663,6B0
09F2A:  CLRF   xB3
09F2C:  MOVLW  B5
09F2E:  MOVWF  xB2
09F30:  MOVLB  0
09F32:  CALL   07F0
09F36:  MOVFF  02,695
09F3A:  MOVFF  01,694
09F3E:  MOVLW  06
09F40:  MOVLB  6
09F42:  ADDWF  x94,F
09F44:  MOVLW  00
09F46:  ADDWFC x95,F
09F48:  MOVLW  32
09F4A:  ADDWF  x94,W
09F4C:  MOVWF  01
09F4E:  MOVLW  00
09F50:  ADDWFC x95,W
09F52:  MOVWF  03
09F54:  MOVF   01,W
09F56:  ADDLW  DC
09F58:  MOVWF  01
09F5A:  MOVLW  01
09F5C:  ADDWFC 03,F
09F5E:  MOVFF  01,694
09F62:  MOVFF  03,695
09F66:  MOVFF  03,698
09F6A:  MOVFF  01,697
09F6E:  MOVLB  0
09F70:  CALL   6508
09F74:  MOVF   01,F
09F76:  BNZ   9F80
09F78:  MOVLW  02
09F7A:  MOVWF  01
09F7C:  BRA    A5C4
09F7E:  BRA    9FDE
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
09F80:  MOVLB  6
09F82:  CLRF   xB1
09F84:  MOVFF  663,6B0
09F88:  CLRF   xB3
09F8A:  MOVLW  B5
09F8C:  MOVWF  xB2
09F8E:  MOVLB  0
09F90:  CALL   07F0
09F94:  MOVFF  02,695
09F98:  MOVFF  01,694
09F9C:  MOVLW  06
09F9E:  MOVLB  6
09FA0:  ADDWF  x94,F
09FA2:  MOVLW  00
09FA4:  ADDWFC x95,F
09FA6:  MOVLW  32
09FA8:  ADDWF  x94,W
09FAA:  MOVWF  01
09FAC:  MOVLW  00
09FAE:  ADDWFC x95,W
09FB0:  MOVWF  03
09FB2:  MOVF   01,W
09FB4:  ADDLW  DC
09FB6:  MOVWF  01
09FB8:  MOVLW  01
09FBA:  ADDWFC 03,F
09FBC:  MOVFF  01,694
09FC0:  MOVFF  03,695
09FC4:  MOVFF  03,698
09FC8:  MOVFF  01,697
09FCC:  CLRF   x9A
09FCE:  CLRF   x99
09FD0:  MOVLW  0A
09FD2:  MOVWF  x9B
09FD4:  MOVLB  0
09FD6:  CALL   65F8
09FDA:  MOVFF  01,66F
....................    
....................    arg2 = SERcmd[rec].p[3];
09FDE:  MOVLB  6
09FE0:  CLRF   xB1
09FE2:  MOVFF  663,6B0
09FE6:  CLRF   xB3
09FE8:  MOVLW  B5
09FEA:  MOVWF  xB2
09FEC:  MOVLB  0
09FEE:  CALL   07F0
09FF2:  MOVFF  02,695
09FF6:  MOVFF  01,694
09FFA:  MOVLW  06
09FFC:  MOVLB  6
09FFE:  ADDWF  x94,F
0A000:  MOVLW  00
0A002:  ADDWFC x95,F
0A004:  MOVLW  4B
0A006:  ADDWF  x94,W
0A008:  MOVWF  01
0A00A:  MOVLW  00
0A00C:  ADDWFC x95,W
0A00E:  MOVWF  03
0A010:  MOVF   01,W
0A012:  ADDLW  DC
0A014:  MOVWF  01
0A016:  MOVLW  01
0A018:  ADDWFC 03,F
0A01A:  MOVFF  01,670
0A01E:  MOVFF  03,671
....................    
....................    /*** GET INPUT DATA ****************/
....................    if      (0 == strcmp(s_raw, arg2)) {
0A022:  MOVFF  673,6A6
0A026:  MOVFF  672,6A5
0A02A:  MOVFF  671,6A8
0A02E:  MOVFF  670,6A7
0A032:  MOVLB  0
0A034:  CALL   63C8
0A038:  MOVF   01,F
0A03A:  BTFSS  FD8.2
0A03C:  BRA    A1B8
....................       sprintf(retData+strlen(retData), "%d,", arg1);
0A03E:  MOVLW  04
0A040:  MOVLB  6
0A042:  MOVWF  xA6
0A044:  MOVLW  B2
0A046:  MOVWF  xA5
0A048:  MOVLB  0
0A04A:  CALL   6390
0A04E:  MOVFF  02,03
0A052:  MOVF   01,W
0A054:  ADDLW  B2
0A056:  MOVLB  6
0A058:  MOVWF  x94
0A05A:  MOVLW  04
0A05C:  ADDWFC 02,W
0A05E:  MOVWF  x95
0A060:  MOVFF  FE8,557
0A064:  MOVFF  694,556
0A068:  MOVFF  66F,698
0A06C:  MOVLW  18
0A06E:  MOVWF  x99
0A070:  MOVLB  0
0A072:  CALL   694C
0A076:  MOVLW  2C
0A078:  MOVLB  6
0A07A:  MOVWF  xB4
0A07C:  MOVLB  0
0A07E:  CALL   6440
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].sinRaw);
0A082:  MOVLW  04
0A084:  MOVLB  6
0A086:  MOVWF  xA6
0A088:  MOVLW  B2
0A08A:  MOVWF  xA5
0A08C:  MOVLB  0
0A08E:  CALL   6390
0A092:  MOVFF  02,03
0A096:  MOVF   01,W
0A098:  ADDLW  B2
0A09A:  MOVLB  6
0A09C:  MOVWF  x94
0A09E:  MOVLW  04
0A0A0:  ADDWFC 02,W
0A0A2:  MOVWF  x95
0A0A4:  MOVLW  01
0A0A6:  SUBWF  x6F,W
0A0A8:  MULLW  21
0A0AA:  MOVF   FF3,W
0A0AC:  CLRF   x97
0A0AE:  MOVWF  x96
0A0B0:  MOVLW  0F
0A0B2:  ADDWF  x96,W
0A0B4:  MOVWF  FE9
0A0B6:  MOVLW  01
0A0B8:  ADDWFC x97,W
0A0BA:  MOVWF  FEA
0A0BC:  MOVFF  FEF,6B4
0A0C0:  MOVFF  FEC,01
0A0C4:  MOVFF  FEC,02
0A0C8:  MOVFF  FEC,03
0A0CC:  MOVFF  03,6B7
0A0D0:  MOVFF  02,6B6
0A0D4:  MOVFF  01,6B5
0A0D8:  MOVLB  0
0A0DA:  CALL   6052
0A0DE:  MOVFF  03,69B
0A0E2:  MOVFF  02,69A
0A0E6:  MOVFF  01,699
0A0EA:  MOVFF  00,698
0A0EE:  MOVFF  695,557
0A0F2:  MOVFF  694,556
0A0F6:  MOVLW  41
0A0F8:  MOVWF  FE9
0A0FA:  MOVFF  03,6A0
0A0FE:  MOVFF  02,69F
0A102:  MOVFF  01,69E
0A106:  MOVFF  00,69D
0A10A:  RCALL  9D86
0A10C:  MOVLW  2C
0A10E:  MOVLB  6
0A110:  MOVWF  xB4
0A112:  MOVLB  0
0A114:  CALL   6440
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].cosRaw);
0A118:  MOVLW  04
0A11A:  MOVLB  6
0A11C:  MOVWF  xA6
0A11E:  MOVLW  B2
0A120:  MOVWF  xA5
0A122:  MOVLB  0
0A124:  CALL   6390
0A128:  MOVF   01,W
0A12A:  ADDLW  B2
0A12C:  MOVLB  6
0A12E:  MOVWF  x94
0A130:  MOVLW  04
0A132:  ADDWFC 02,W
0A134:  MOVWF  x95
0A136:  MOVLW  01
0A138:  SUBWF  x6F,W
0A13A:  MULLW  21
0A13C:  MOVF   FF3,W
0A13E:  CLRF   x97
0A140:  MOVWF  x96
0A142:  MOVLW  04
0A144:  ADDWF  x96,W
0A146:  MOVWF  01
0A148:  MOVLW  00
0A14A:  ADDWFC x97,W
0A14C:  MOVWF  03
0A14E:  MOVF   01,W
0A150:  ADDLW  0F
0A152:  MOVWF  FE9
0A154:  MOVLW  01
0A156:  ADDWFC 03,W
0A158:  MOVWF  FEA
0A15A:  MOVFF  FEF,6B4
0A15E:  MOVFF  FEC,01
0A162:  MOVFF  FEC,02
0A166:  MOVFF  FEC,03
0A16A:  MOVFF  03,6B7
0A16E:  MOVFF  02,6B6
0A172:  MOVFF  01,6B5
0A176:  MOVLB  0
0A178:  CALL   6052
0A17C:  MOVFF  03,699
0A180:  MOVFF  02,698
0A184:  MOVFF  01,697
0A188:  MOVFF  00,696
0A18C:  MOVFF  695,557
0A190:  MOVFF  694,556
0A194:  MOVLW  41
0A196:  MOVWF  FE9
0A198:  MOVFF  03,6A0
0A19C:  MOVFF  02,69F
0A1A0:  MOVFF  01,69E
0A1A4:  MOVFF  00,69D
0A1A8:  RCALL  9D86
0A1AA:  MOVLW  2C
0A1AC:  MOVLB  6
0A1AE:  MOVWF  xB4
0A1B0:  MOVLB  0
0A1B2:  CALL   6440
....................    }
0A1B6:  BRA    A5C0
....................    else if (0 == strcmp(s_calibrated, arg2)) {
0A1B8:  MOVFF  679,6A6
0A1BC:  MOVFF  678,6A5
0A1C0:  MOVFF  671,6A8
0A1C4:  MOVFF  670,6A7
0A1C8:  CALL   63C8
0A1CC:  MOVF   01,F
0A1CE:  BTFSS  FD8.2
0A1D0:  BRA    A354
....................       sprintf(retData+strlen(retData), "%d,", arg1);
0A1D2:  MOVLW  04
0A1D4:  MOVLB  6
0A1D6:  MOVWF  xA6
0A1D8:  MOVLW  B2
0A1DA:  MOVWF  xA5
0A1DC:  MOVLB  0
0A1DE:  CALL   6390
0A1E2:  MOVFF  02,03
0A1E6:  MOVF   01,W
0A1E8:  ADDLW  B2
0A1EA:  MOVLB  6
0A1EC:  MOVWF  x94
0A1EE:  MOVLW  04
0A1F0:  ADDWFC 02,W
0A1F2:  MOVWF  x95
0A1F4:  MOVFF  FE8,557
0A1F8:  MOVFF  694,556
0A1FC:  MOVFF  66F,698
0A200:  MOVLW  18
0A202:  MOVWF  x99
0A204:  MOVLB  0
0A206:  CALL   694C
0A20A:  MOVLW  2C
0A20C:  MOVLB  6
0A20E:  MOVWF  xB4
0A210:  MOVLB  0
0A212:  CALL   6440
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].sinCounts);
0A216:  MOVLW  04
0A218:  MOVLB  6
0A21A:  MOVWF  xA6
0A21C:  MOVLW  B2
0A21E:  MOVWF  xA5
0A220:  MOVLB  0
0A222:  CALL   6390
0A226:  MOVF   01,W
0A228:  ADDLW  B2
0A22A:  MOVLB  6
0A22C:  MOVWF  x94
0A22E:  MOVLW  04
0A230:  ADDWFC 02,W
0A232:  MOVWF  x95
0A234:  MOVLW  01
0A236:  SUBWF  x6F,W
0A238:  MULLW  21
0A23A:  MOVF   FF3,W
0A23C:  CLRF   x97
0A23E:  MOVWF  x96
0A240:  MOVLW  08
0A242:  ADDWF  x96,W
0A244:  MOVWF  01
0A246:  MOVLW  00
0A248:  ADDWFC x97,W
0A24A:  MOVWF  03
0A24C:  MOVF   01,W
0A24E:  ADDLW  0F
0A250:  MOVWF  FE9
0A252:  MOVLW  01
0A254:  ADDWFC 03,W
0A256:  MOVWF  FEA
0A258:  MOVFF  FEF,6B4
0A25C:  MOVFF  FEC,01
0A260:  MOVFF  FEC,02
0A264:  MOVFF  FEC,03
0A268:  MOVFF  03,6B7
0A26C:  MOVFF  02,6B6
0A270:  MOVFF  01,6B5
0A274:  MOVLB  0
0A276:  CALL   6052
0A27A:  MOVFF  03,699
0A27E:  MOVFF  02,698
0A282:  MOVFF  01,697
0A286:  MOVFF  00,696
0A28A:  MOVFF  695,557
0A28E:  MOVFF  694,556
0A292:  MOVLW  41
0A294:  MOVWF  FE9
0A296:  MOVFF  03,6A0
0A29A:  MOVFF  02,69F
0A29E:  MOVFF  01,69E
0A2A2:  MOVFF  00,69D
0A2A6:  RCALL  9D86
0A2A8:  MOVLW  2C
0A2AA:  MOVLB  6
0A2AC:  MOVWF  xB4
0A2AE:  MOVLB  0
0A2B0:  CALL   6440
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].cosCounts);
0A2B4:  MOVLW  04
0A2B6:  MOVLB  6
0A2B8:  MOVWF  xA6
0A2BA:  MOVLW  B2
0A2BC:  MOVWF  xA5
0A2BE:  MOVLB  0
0A2C0:  CALL   6390
0A2C4:  MOVF   01,W
0A2C6:  ADDLW  B2
0A2C8:  MOVLB  6
0A2CA:  MOVWF  x94
0A2CC:  MOVLW  04
0A2CE:  ADDWFC 02,W
0A2D0:  MOVWF  x95
0A2D2:  MOVLW  01
0A2D4:  SUBWF  x6F,W
0A2D6:  MULLW  21
0A2D8:  MOVF   FF3,W
0A2DA:  CLRF   x97
0A2DC:  MOVWF  x96
0A2DE:  MOVLW  0C
0A2E0:  ADDWF  x96,W
0A2E2:  MOVWF  01
0A2E4:  MOVLW  00
0A2E6:  ADDWFC x97,W
0A2E8:  MOVWF  03
0A2EA:  MOVF   01,W
0A2EC:  ADDLW  0F
0A2EE:  MOVWF  FE9
0A2F0:  MOVLW  01
0A2F2:  ADDWFC 03,W
0A2F4:  MOVWF  FEA
0A2F6:  MOVFF  FEF,6B4
0A2FA:  MOVFF  FEC,01
0A2FE:  MOVFF  FEC,02
0A302:  MOVFF  FEC,03
0A306:  MOVFF  03,6B7
0A30A:  MOVFF  02,6B6
0A30E:  MOVFF  01,6B5
0A312:  MOVLB  0
0A314:  CALL   6052
0A318:  MOVFF  03,699
0A31C:  MOVFF  02,698
0A320:  MOVFF  01,697
0A324:  MOVFF  00,696
0A328:  MOVFF  695,557
0A32C:  MOVFF  694,556
0A330:  MOVLW  41
0A332:  MOVWF  FE9
0A334:  MOVFF  03,6A0
0A338:  MOVFF  02,69F
0A33C:  MOVFF  01,69E
0A340:  MOVFF  00,69D
0A344:  RCALL  9D86
0A346:  MOVLW  2C
0A348:  MOVLB  6
0A34A:  MOVWF  xB4
0A34C:  MOVLB  0
0A34E:  CALL   6440
....................    }
0A352:  BRA    A5C0
....................    else if (0 == strcmp(s_p0, arg2)) {
0A354:  MOVFF  681,6A6
0A358:  MOVFF  680,6A5
0A35C:  MOVFF  671,6A8
0A360:  MOVFF  670,6A7
0A364:  CALL   63C8
0A368:  MOVF   01,F
0A36A:  BNZ   A426
....................       sprintf(retData+strlen(retData), "%d,", arg1);
0A36C:  MOVLW  04
0A36E:  MOVLB  6
0A370:  MOVWF  xA6
0A372:  MOVLW  B2
0A374:  MOVWF  xA5
0A376:  MOVLB  0
0A378:  CALL   6390
0A37C:  MOVFF  02,03
0A380:  MOVF   01,W
0A382:  ADDLW  B2
0A384:  MOVLB  6
0A386:  MOVWF  x94
0A388:  MOVLW  04
0A38A:  ADDWFC 02,W
0A38C:  MOVWF  x95
0A38E:  MOVFF  FE8,557
0A392:  MOVFF  694,556
0A396:  MOVFF  66F,698
0A39A:  MOVLW  18
0A39C:  MOVWF  x99
0A39E:  MOVLB  0
0A3A0:  CALL   694C
0A3A4:  MOVLW  2C
0A3A6:  MOVLB  6
0A3A8:  MOVWF  xB4
0A3AA:  MOVLB  0
0A3AC:  CALL   6440
....................       sprintf(retData+strlen(retData), "%f,", adcVals[arg1-1].p0);
0A3B0:  MOVLW  04
0A3B2:  MOVLB  6
0A3B4:  MOVWF  xA6
0A3B6:  MOVLW  B2
0A3B8:  MOVWF  xA5
0A3BA:  MOVLB  0
0A3BC:  CALL   6390
0A3C0:  MOVF   01,W
0A3C2:  ADDLW  B2
0A3C4:  MOVLB  6
0A3C6:  MOVWF  x94
0A3C8:  MOVLW  04
0A3CA:  ADDWFC 02,W
0A3CC:  MOVWF  x95
0A3CE:  MOVLW  01
0A3D0:  SUBWF  x6F,W
0A3D2:  MULLW  21
0A3D4:  MOVF   FF3,W
0A3D6:  CLRF   x97
0A3D8:  MOVWF  x96
0A3DA:  MOVLW  18
0A3DC:  ADDWF  x96,W
0A3DE:  MOVWF  01
0A3E0:  MOVLW  00
0A3E2:  ADDWFC x97,W
0A3E4:  MOVWF  03
0A3E6:  MOVF   01,W
0A3E8:  ADDLW  0F
0A3EA:  MOVWF  FE9
0A3EC:  MOVLW  01
0A3EE:  ADDWFC 03,W
0A3F0:  MOVWF  FEA
0A3F2:  MOVFF  FEF,6A7
0A3F6:  MOVFF  FEC,6A8
0A3FA:  MOVFF  FEC,6A9
0A3FE:  MOVFF  FEC,6AA
0A402:  MOVFF  695,557
0A406:  MOVFF  694,556
0A40A:  MOVLW  89
0A40C:  MOVWF  FE9
0A40E:  MOVLW  02
0A410:  MOVWF  xAB
0A412:  MOVLB  0
0A414:  CALL   7168
0A418:  MOVLW  2C
0A41A:  MOVLB  6
0A41C:  MOVWF  xB4
0A41E:  MOVLB  0
0A420:  CALL   6440
....................    }
0A424:  BRA    A5C0
....................    else if (0 == strcmp(s_poles, arg2)) {
0A426:  MOVFF  686,6A6
0A42A:  MOVFF  685,6A5
0A42E:  MOVFF  671,6A8
0A432:  MOVFF  670,6A7
0A436:  CALL   63C8
0A43A:  MOVF   01,F
0A43C:  BNZ   A4E8
....................       sprintf(retData+strlen(retData), "%d,", arg1);
0A43E:  MOVLW  04
0A440:  MOVLB  6
0A442:  MOVWF  xA6
0A444:  MOVLW  B2
0A446:  MOVWF  xA5
0A448:  MOVLB  0
0A44A:  CALL   6390
0A44E:  MOVFF  02,03
0A452:  MOVF   01,W
0A454:  ADDLW  B2
0A456:  MOVLB  6
0A458:  MOVWF  x94
0A45A:  MOVLW  04
0A45C:  ADDWFC 02,W
0A45E:  MOVWF  x95
0A460:  MOVFF  FE8,557
0A464:  MOVFF  694,556
0A468:  MOVFF  66F,698
0A46C:  MOVLW  18
0A46E:  MOVWF  x99
0A470:  MOVLB  0
0A472:  CALL   694C
0A476:  MOVLW  2C
0A478:  MOVLB  6
0A47A:  MOVWF  xB4
0A47C:  MOVLB  0
0A47E:  CALL   6440
....................       sprintf(retData+strlen(retData), "%d,", adcVals[arg1-1].npoles);
0A482:  MOVLW  04
0A484:  MOVLB  6
0A486:  MOVWF  xA6
0A488:  MOVLW  B2
0A48A:  MOVWF  xA5
0A48C:  MOVLB  0
0A48E:  CALL   6390
0A492:  MOVF   01,W
0A494:  ADDLW  B2
0A496:  MOVLB  6
0A498:  MOVWF  x94
0A49A:  MOVLW  04
0A49C:  ADDWFC 02,W
0A49E:  MOVWF  x95
0A4A0:  MOVLW  01
0A4A2:  SUBWF  x6F,W
0A4A4:  MULLW  21
0A4A6:  MOVF   FF3,W
0A4A8:  CLRF   x97
0A4AA:  MOVWF  x96
0A4AC:  MOVLW  1C
0A4AE:  ADDWF  x96,W
0A4B0:  MOVWF  01
0A4B2:  MOVLW  00
0A4B4:  ADDWFC x97,W
0A4B6:  MOVWF  03
0A4B8:  MOVF   01,W
0A4BA:  ADDLW  0F
0A4BC:  MOVWF  FE9
0A4BE:  MOVLW  01
0A4C0:  ADDWFC 03,W
0A4C2:  MOVWF  FEA
0A4C4:  MOVFF  FEF,698
0A4C8:  MOVFF  695,557
0A4CC:  MOVFF  694,556
0A4D0:  MOVLW  18
0A4D2:  MOVWF  x99
0A4D4:  MOVLB  0
0A4D6:  CALL   694C
0A4DA:  MOVLW  2C
0A4DC:  MOVLB  6
0A4DE:  MOVWF  xB4
0A4E0:  MOVLB  0
0A4E2:  CALL   6440
....................    }
0A4E6:  BRA    A5C0
....................    else if (0 == strcmp(s_real, arg2)) {
0A4E8:  MOVFF  68E,6A6
0A4EC:  MOVFF  68D,6A5
0A4F0:  MOVFF  671,6A8
0A4F4:  MOVFF  670,6A7
0A4F8:  CALL   63C8
0A4FC:  MOVF   01,F
0A4FE:  BNZ   A5BA
....................       sprintf(retData+strlen(retData), "%d,", arg1);
0A500:  MOVLW  04
0A502:  MOVLB  6
0A504:  MOVWF  xA6
0A506:  MOVLW  B2
0A508:  MOVWF  xA5
0A50A:  MOVLB  0
0A50C:  CALL   6390
0A510:  MOVFF  02,03
0A514:  MOVF   01,W
0A516:  ADDLW  B2
0A518:  MOVLB  6
0A51A:  MOVWF  x94
0A51C:  MOVLW  04
0A51E:  ADDWFC 02,W
0A520:  MOVWF  x95
0A522:  MOVFF  FE8,557
0A526:  MOVFF  694,556
0A52A:  MOVFF  66F,698
0A52E:  MOVLW  18
0A530:  MOVWF  x99
0A532:  MOVLB  0
0A534:  CALL   694C
0A538:  MOVLW  2C
0A53A:  MOVLB  6
0A53C:  MOVWF  xB4
0A53E:  MOVLB  0
0A540:  CALL   6440
....................       sprintf(retData+strlen(retData), "%f,", adcVals[arg1-1].pReal);
0A544:  MOVLW  04
0A546:  MOVLB  6
0A548:  MOVWF  xA6
0A54A:  MOVLW  B2
0A54C:  MOVWF  xA5
0A54E:  MOVLB  0
0A550:  CALL   6390
0A554:  MOVF   01,W
0A556:  ADDLW  B2
0A558:  MOVLB  6
0A55A:  MOVWF  x94
0A55C:  MOVLW  04
0A55E:  ADDWFC 02,W
0A560:  MOVWF  x95
0A562:  MOVLW  01
0A564:  SUBWF  x6F,W
0A566:  MULLW  21
0A568:  MOVF   FF3,W
0A56A:  CLRF   x97
0A56C:  MOVWF  x96
0A56E:  MOVLW  1D
0A570:  ADDWF  x96,W
0A572:  MOVWF  01
0A574:  MOVLW  00
0A576:  ADDWFC x97,W
0A578:  MOVWF  03
0A57A:  MOVF   01,W
0A57C:  ADDLW  0F
0A57E:  MOVWF  FE9
0A580:  MOVLW  01
0A582:  ADDWFC 03,W
0A584:  MOVWF  FEA
0A586:  MOVFF  FEF,6A7
0A58A:  MOVFF  FEC,6A8
0A58E:  MOVFF  FEC,6A9
0A592:  MOVFF  FEC,6AA
0A596:  MOVFF  695,557
0A59A:  MOVFF  694,556
0A59E:  MOVLW  89
0A5A0:  MOVWF  FE9
0A5A2:  MOVLW  02
0A5A4:  MOVWF  xAB
0A5A6:  MOVLB  0
0A5A8:  CALL   7168
0A5AC:  MOVLW  2C
0A5AE:  MOVLB  6
0A5B0:  MOVWF  xB4
0A5B2:  MOVLB  0
0A5B4:  CALL   6440
....................    }
0A5B8:  BRA    A5C0
....................    else return INV_PARAM;
0A5BA:  MOVLW  02
0A5BC:  MOVWF  01
0A5BE:  BRA    A5C4
....................    
....................    return SUCCESS;
0A5C0:  MOVLW  00
0A5C2:  MOVWF  01
0A5C4:  RETURN 0
.................... }
.................... 
.................... int8 getManOPvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0A5C6:  MOVLB  6
0A5C8:  CLRF   xB1
0A5CA:  MOVFF  663,6B0
0A5CE:  CLRF   xB3
0A5D0:  MOVLW  B5
0A5D2:  MOVWF  xB2
0A5D4:  MOVLB  0
0A5D6:  CALL   07F0
0A5DA:  MOVFF  02,671
0A5DE:  MOVFF  01,670
0A5E2:  MOVLW  06
0A5E4:  MOVLB  6
0A5E6:  ADDWF  x70,F
0A5E8:  MOVLW  00
0A5EA:  ADDWFC x71,F
0A5EC:  MOVLW  32
0A5EE:  ADDWF  x70,W
0A5F0:  MOVWF  01
0A5F2:  MOVLW  00
0A5F4:  ADDWFC x71,W
0A5F6:  MOVWF  03
0A5F8:  MOVF   01,W
0A5FA:  ADDLW  DC
0A5FC:  MOVWF  01
0A5FE:  MOVLW  01
0A600:  ADDWFC 03,F
0A602:  MOVFF  01,670
0A606:  MOVFF  03,671
0A60A:  MOVFF  03,698
0A60E:  MOVFF  01,697
0A612:  MOVLB  0
0A614:  CALL   6508
0A618:  MOVF   01,F
0A61A:  BNZ   A624
0A61C:  MOVLW  02
0A61E:  MOVWF  01
0A620:  BRA    A716
0A622:  BRA    A682
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
0A624:  MOVLB  6
0A626:  CLRF   xB1
0A628:  MOVFF  663,6B0
0A62C:  CLRF   xB3
0A62E:  MOVLW  B5
0A630:  MOVWF  xB2
0A632:  MOVLB  0
0A634:  CALL   07F0
0A638:  MOVFF  02,671
0A63C:  MOVFF  01,670
0A640:  MOVLW  06
0A642:  MOVLB  6
0A644:  ADDWF  x70,F
0A646:  MOVLW  00
0A648:  ADDWFC x71,F
0A64A:  MOVLW  32
0A64C:  ADDWF  x70,W
0A64E:  MOVWF  01
0A650:  MOVLW  00
0A652:  ADDWFC x71,W
0A654:  MOVWF  03
0A656:  MOVF   01,W
0A658:  ADDLW  DC
0A65A:  MOVWF  01
0A65C:  MOVLW  01
0A65E:  ADDWFC 03,F
0A660:  MOVFF  01,670
0A664:  MOVFF  03,671
0A668:  MOVFF  03,698
0A66C:  MOVFF  01,697
0A670:  CLRF   x9A
0A672:  CLRF   x99
0A674:  MOVLW  0A
0A676:  MOVWF  x9B
0A678:  MOVLB  0
0A67A:  CALL   65F8
0A67E:  MOVFF  01,66F
....................    
....................    /*** GET MANUAL OUTPUT VALUE ***************/ 
....................    sprintf(retData+strlen(retData), "%d,%f,", arg1, manualOutputValues[arg1-1]);
0A682:  MOVLW  04
0A684:  MOVLB  6
0A686:  MOVWF  xA6
0A688:  MOVLW  B2
0A68A:  MOVWF  xA5
0A68C:  MOVLB  0
0A68E:  CALL   6390
0A692:  MOVF   01,W
0A694:  ADDLW  B2
0A696:  MOVLB  6
0A698:  MOVWF  x70
0A69A:  MOVLW  04
0A69C:  ADDWFC 02,W
0A69E:  MOVWF  x71
0A6A0:  MOVLW  01
0A6A2:  SUBWF  x6F,W
0A6A4:  MULLW  04
0A6A6:  MOVF   FF3,W
0A6A8:  CLRF   03
0A6AA:  ADDLW  EA
0A6AC:  MOVWF  FE9
0A6AE:  MOVLW  00
0A6B0:  ADDWFC 03,W
0A6B2:  MOVWF  FEA
0A6B4:  MOVFF  FEF,672
0A6B8:  MOVFF  FEC,673
0A6BC:  MOVFF  FEC,674
0A6C0:  MOVFF  FEC,675
0A6C4:  MOVFF  671,557
0A6C8:  MOVFF  670,556
0A6CC:  MOVFF  66F,698
0A6D0:  MOVLW  18
0A6D2:  MOVWF  x99
0A6D4:  MOVLB  0
0A6D6:  CALL   694C
0A6DA:  MOVLW  2C
0A6DC:  MOVLB  6
0A6DE:  MOVWF  xB4
0A6E0:  MOVLB  0
0A6E2:  CALL   6440
0A6E6:  MOVLW  89
0A6E8:  MOVWF  FE9
0A6EA:  MOVFF  675,6AA
0A6EE:  MOVFF  674,6A9
0A6F2:  MOVFF  673,6A8
0A6F6:  MOVFF  672,6A7
0A6FA:  MOVLW  02
0A6FC:  MOVLB  6
0A6FE:  MOVWF  xAB
0A700:  MOVLB  0
0A702:  CALL   7168
0A706:  MOVLW  2C
0A708:  MOVLB  6
0A70A:  MOVWF  xB4
0A70C:  MOVLB  0
0A70E:  CALL   6440
....................    
....................    return SUCCESS;
0A712:  MOVLW  00
0A714:  MOVWF  01
0A716:  RETURN 0
.................... }
.................... 
.................... int8 setManOPvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    float arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0A718:  MOVLB  6
0A71A:  CLRF   xB1
0A71C:  MOVFF  663,6B0
0A720:  CLRF   xB3
0A722:  MOVLW  B5
0A724:  MOVWF  xB2
0A726:  MOVLB  0
0A728:  CALL   07F0
0A72C:  MOVFF  02,675
0A730:  MOVFF  01,674
0A734:  MOVLW  06
0A736:  MOVLB  6
0A738:  ADDWF  x74,F
0A73A:  MOVLW  00
0A73C:  ADDWFC x75,F
0A73E:  MOVLW  32
0A740:  ADDWF  x74,W
0A742:  MOVWF  01
0A744:  MOVLW  00
0A746:  ADDWFC x75,W
0A748:  MOVWF  03
0A74A:  MOVF   01,W
0A74C:  ADDLW  DC
0A74E:  MOVWF  01
0A750:  MOVLW  01
0A752:  ADDWFC 03,F
0A754:  MOVFF  01,674
0A758:  MOVFF  03,675
0A75C:  MOVFF  03,698
0A760:  MOVFF  01,697
0A764:  MOVLB  0
0A766:  CALL   6508
0A76A:  MOVF   01,F
0A76C:  BNZ   A776
0A76E:  MOVLW  02
0A770:  MOVWF  01
0A772:  BRA    A958
0A774:  BRA    A7D4
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
0A776:  MOVLB  6
0A778:  CLRF   xB1
0A77A:  MOVFF  663,6B0
0A77E:  CLRF   xB3
0A780:  MOVLW  B5
0A782:  MOVWF  xB2
0A784:  MOVLB  0
0A786:  CALL   07F0
0A78A:  MOVFF  02,675
0A78E:  MOVFF  01,674
0A792:  MOVLW  06
0A794:  MOVLB  6
0A796:  ADDWF  x74,F
0A798:  MOVLW  00
0A79A:  ADDWFC x75,F
0A79C:  MOVLW  32
0A79E:  ADDWF  x74,W
0A7A0:  MOVWF  01
0A7A2:  MOVLW  00
0A7A4:  ADDWFC x75,W
0A7A6:  MOVWF  03
0A7A8:  MOVF   01,W
0A7AA:  ADDLW  DC
0A7AC:  MOVWF  01
0A7AE:  MOVLW  01
0A7B0:  ADDWFC 03,F
0A7B2:  MOVFF  01,674
0A7B6:  MOVFF  03,675
0A7BA:  MOVFF  03,698
0A7BE:  MOVFF  01,697
0A7C2:  CLRF   x9A
0A7C4:  CLRF   x99
0A7C6:  MOVLW  0A
0A7C8:  MOVWF  x9B
0A7CA:  MOVLB  0
0A7CC:  CALL   65F8
0A7D0:  MOVFF  01,66F
....................    
....................    if (!arg_is_float(SERcmd[rec].p[3])) return INV_PARAM;
0A7D4:  MOVLB  6
0A7D6:  CLRF   xB1
0A7D8:  MOVFF  663,6B0
0A7DC:  CLRF   xB3
0A7DE:  MOVLW  B5
0A7E0:  MOVWF  xB2
0A7E2:  MOVLB  0
0A7E4:  CALL   07F0
0A7E8:  MOVFF  02,675
0A7EC:  MOVFF  01,674
0A7F0:  MOVLW  06
0A7F2:  MOVLB  6
0A7F4:  ADDWF  x74,F
0A7F6:  MOVLW  00
0A7F8:  ADDWFC x75,F
0A7FA:  MOVLW  4B
0A7FC:  ADDWF  x74,W
0A7FE:  MOVWF  01
0A800:  MOVLW  00
0A802:  ADDWFC x75,W
0A804:  MOVWF  03
0A806:  MOVF   01,W
0A808:  ADDLW  DC
0A80A:  MOVWF  01
0A80C:  MOVLW  01
0A80E:  ADDWFC 03,F
0A810:  MOVFF  01,674
0A814:  MOVFF  03,675
0A818:  MOVFF  03,679
0A81C:  MOVFF  01,678
0A820:  MOVLB  0
0A822:  CALL   77D4
0A826:  MOVF   01,F
0A828:  BNZ   A832
0A82A:  MOVLW  02
0A82C:  MOVWF  01
0A82E:  BRA    A958
0A830:  BRA    A898
....................    else arg2 = strtod(SERcmd[rec].p[3], '\0');
0A832:  MOVLB  6
0A834:  CLRF   xB1
0A836:  MOVFF  663,6B0
0A83A:  CLRF   xB3
0A83C:  MOVLW  B5
0A83E:  MOVWF  xB2
0A840:  MOVLB  0
0A842:  CALL   07F0
0A846:  MOVFF  02,675
0A84A:  MOVFF  01,674
0A84E:  MOVLW  06
0A850:  MOVLB  6
0A852:  ADDWF  x74,F
0A854:  MOVLW  00
0A856:  ADDWFC x75,F
0A858:  MOVLW  4B
0A85A:  ADDWF  x74,W
0A85C:  MOVWF  01
0A85E:  MOVLW  00
0A860:  ADDWFC x75,W
0A862:  MOVWF  03
0A864:  MOVF   01,W
0A866:  ADDLW  DC
0A868:  MOVWF  01
0A86A:  MOVLW  01
0A86C:  ADDWFC 03,F
0A86E:  MOVFF  01,674
0A872:  MOVFF  03,675
0A876:  MOVFF  03,679
0A87A:  MOVFF  01,678
0A87E:  CLRF   x7B
0A880:  CLRF   x7A
0A882:  MOVLB  0
0A884:  CALL   7896
0A888:  MOVFF  03,673
0A88C:  MOVFF  02,672
0A890:  MOVFF  01,671
0A894:  MOVFF  00,670
....................    
....................    /*** SET MANUAL OUTPUT VALUE ***************/
....................    if (arg2 > op_upper_bound) manualOutputValues[arg1-1] = op_upper_bound;
0A898:  MOVLB  6
0A89A:  CLRF   xB2
0A89C:  CLRF   xB1
0A89E:  MOVLW  7C
0A8A0:  MOVWF  xB0
0A8A2:  MOVLW  84
0A8A4:  MOVWF  xAF
0A8A6:  MOVFF  673,6B6
0A8AA:  MOVFF  672,6B5
0A8AE:  MOVFF  671,6B4
0A8B2:  MOVFF  670,6B3
0A8B6:  MOVLB  0
0A8B8:  CALL   27C4
0A8BC:  BNC   A8E2
0A8BE:  MOVLW  01
0A8C0:  MOVLB  6
0A8C2:  SUBWF  x6F,W
0A8C4:  MULLW  04
0A8C6:  MOVF   FF3,W
0A8C8:  CLRF   03
0A8CA:  ADDLW  EA
0A8CC:  MOVWF  FE9
0A8CE:  MOVLW  00
0A8D0:  ADDWFC 03,W
0A8D2:  MOVWF  FEA
0A8D4:  MOVLW  84
0A8D6:  MOVWF  FEF
0A8D8:  MOVLW  7C
0A8DA:  MOVWF  FEC
0A8DC:  CLRF   FEC
0A8DE:  CLRF   FEC
0A8E0:  BRA    A952
....................    else if (arg2 < op_lower_bound) manualOutputValues[arg1-1] = op_lower_bound;  
0A8E2:  MOVFF  673,6B2
0A8E6:  MOVFF  672,6B1
0A8EA:  MOVFF  671,6B0
0A8EE:  MOVFF  670,6AF
0A8F2:  MOVLB  6
0A8F4:  CLRF   xB6
0A8F6:  CLRF   xB5
0A8F8:  MOVLW  FC
0A8FA:  MOVWF  xB4
0A8FC:  MOVLW  84
0A8FE:  MOVWF  xB3
0A900:  MOVLB  0
0A902:  CALL   27C4
0A906:  BNC   A92C
0A908:  MOVLW  01
0A90A:  MOVLB  6
0A90C:  SUBWF  x6F,W
0A90E:  MULLW  04
0A910:  MOVF   FF3,W
0A912:  CLRF   03
0A914:  ADDLW  EA
0A916:  MOVWF  FE9
0A918:  MOVLW  00
0A91A:  ADDWFC 03,W
0A91C:  MOVWF  FEA
0A91E:  MOVLW  84
0A920:  MOVWF  FEF
0A922:  MOVLW  FC
0A924:  MOVWF  FEC
0A926:  CLRF   FEC
0A928:  CLRF   FEC
0A92A:  BRA    A952
....................    else manualOutputValues[arg1-1] = arg2;
0A92C:  MOVLW  01
0A92E:  MOVLB  6
0A930:  SUBWF  x6F,W
0A932:  MULLW  04
0A934:  MOVF   FF3,W
0A936:  CLRF   03
0A938:  ADDLW  EA
0A93A:  MOVWF  FE9
0A93C:  MOVLW  00
0A93E:  ADDWFC 03,W
0A940:  MOVWF  FEA
0A942:  MOVFF  670,FEF
0A946:  MOVFF  671,FEC
0A94A:  MOVFF  672,FEC
0A94E:  MOVFF  673,FEC
....................    
....................    return SUCCESS;
0A952:  MOVLW  00
0A954:  MOVWF  01
0A956:  MOVLB  0
0A958:  RETURN 0
.................... }
.................... 
.................... int8 invalidCmd(unsigned int8 rec){
....................    return INV_CMD;
0A95A:  MOVLW  01
0A95C:  MOVWF  01
0A95E:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* ARG VALIDATION HELPER FUNCS                                               */
.................... /*****************************************************************************/
.................... BOOLEAN arg_is_float(char *arg){
*
077D4:  MOVLB  6
077D6:  BCF    x7A.0
....................    BOOLEAN decimal = FALSE;
....................    for (int i=0; i<strlen(arg); i++){
077D8:  CLRF   x7B
077DA:  MOVFF  679,6A6
077DE:  MOVFF  678,6A5
077E2:  MOVLB  0
077E4:  CALL   6390
077E8:  MOVFF  02,03
077EC:  MOVF   01,W
077EE:  MOVF   03,F
077F0:  BNZ   77FC
077F2:  MOVF   01,W
077F4:  MOVLB  6
077F6:  SUBWF  x7B,W
077F8:  BC    788E
077FA:  MOVLB  0
....................       if (!isdigit(arg[i])){
077FC:  MOVLB  6
077FE:  MOVF   x7B,W
07800:  ADDWF  x78,W
07802:  MOVWF  FE9
07804:  MOVLW  00
07806:  ADDWFC x79,W
07808:  MOVWF  FEA
0780A:  MOVFF  FEF,67C
0780E:  MOVF   x7C,W
07810:  SUBLW  2F
07812:  BC    781A
07814:  MOVF   x7C,W
07816:  SUBLW  39
07818:  BC    7886
....................          // Check for negative sign
....................          if ('-' != arg[i]){
0781A:  MOVF   x7B,W
0781C:  ADDWF  x78,W
0781E:  MOVWF  FE9
07820:  MOVLW  00
07822:  ADDWFC x79,W
07824:  MOVWF  FEA
07826:  MOVF   FEF,W
07828:  SUBLW  2D
0782A:  BZ    7856
....................             // Check for decimal
....................             if ('.' != arg[i]) return FALSE;
0782C:  MOVF   x7B,W
0782E:  ADDWF  x78,W
07830:  MOVWF  FE9
07832:  MOVLW  00
07834:  ADDWFC x79,W
07836:  MOVWF  FEA
07838:  MOVF   FEF,W
0783A:  SUBLW  2E
0783C:  BZ    7846
0783E:  MOVLW  00
07840:  MOVWF  01
07842:  BRA    7892
07844:  BRA    7854
....................             else if  (decimal) return FALSE;
07846:  BTFSS  x7A.0
07848:  BRA    7852
0784A:  MOVLW  00
0784C:  MOVWF  01
0784E:  BRA    7892
07850:  BRA    7854
....................             else decimal = TRUE;
07852:  BSF    x7A.0
....................          }
07854:  BRA    7886
....................          else if (0 != i) return FALSE;
07856:  MOVF   x7B,F
07858:  BZ    7862
0785A:  MOVLW  00
0785C:  MOVWF  01
0785E:  BRA    7892
07860:  BRA    7886
....................          else if (1 == strlen(arg)) return FALSE;
07862:  MOVFF  679,6A6
07866:  MOVFF  678,6A5
0786A:  MOVLB  0
0786C:  CALL   6390
07870:  MOVFF  02,03
07874:  MOVF   01,W
07876:  SUBLW  01
07878:  BNZ   7888
0787A:  MOVF   03,F
0787C:  BNZ   7888
0787E:  MOVLW  00
07880:  MOVWF  01
07882:  MOVLB  6
07884:  BRA    7892
07886:  MOVLB  0
....................       }
07888:  MOVLB  6
0788A:  INCF   x7B,F
0788C:  BRA    77DA
....................    }
....................    return TRUE;
0788E:  MOVLW  01
07890:  MOVWF  01
07892:  MOVLB  0
07894:  RETURN 0
.................... }
.................... 
.................... BOOLEAN is_valid_channel(char *arg){
....................     if (1 != strlen(arg)) return FALSE;
*
06508:  MOVFF  698,6A6
0650C:  MOVFF  697,6A5
06510:  RCALL  6390
06512:  MOVFF  02,03
06516:  MOVF   01,W
06518:  SUBLW  01
0651A:  BNZ   6520
0651C:  MOVF   03,F
0651E:  BZ    6528
06520:  MOVLW  00
06522:  MOVWF  01
06524:  BRA    6556
06526:  BRA    654E
....................     else if ('1' != arg[0] && '2' != arg[0]) return FALSE;
06528:  MOVLB  6
0652A:  MOVFF  697,FE9
0652E:  MOVFF  698,FEA
06532:  MOVF   FEF,W
06534:  SUBLW  31
06536:  BZ    6550
06538:  MOVFF  697,FE9
0653C:  MOVFF  698,FEA
06540:  MOVF   FEF,W
06542:  SUBLW  32
06544:  BZ    6550
06546:  MOVLW  00
06548:  MOVWF  01
0654A:  MOVLB  0
0654C:  BRA    6556
0654E:  MOVLB  6
....................     return TRUE;
06550:  MOVLW  01
06552:  MOVWF  01
06554:  MOVLB  0
06556:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* ASCII HEX CHARACTER TO INT                                                */
.................... /*****************************************************************************/
.................... int8 hex_to_int(char ascii){
....................    if (ascii >= '0' && ascii <= '9') return ascii-'0';
*
06356:  MOVLB  6
06358:  MOVF   x6E,W
0635A:  SUBLW  2F
0635C:  BC    636E
0635E:  MOVF   x6E,W
06360:  SUBLW  39
06362:  BNC   636E
06364:  MOVLW  30
06366:  SUBWF  x6E,W
06368:  MOVWF  01
0636A:  BRA    638A
0636C:  BRA    638A
....................    else if (ascii >= 'A' && ascii <= 'F') return ascii-'A'+10;
0636E:  MOVF   x6E,W
06370:  SUBLW  40
06372:  BC    6386
06374:  MOVF   x6E,W
06376:  SUBLW  46
06378:  BNC   6386
0637A:  MOVLW  41
0637C:  SUBWF  x6E,W
0637E:  ADDLW  0A
06380:  MOVWF  01
06382:  BRA    638A
06384:  BRA    638A
....................    else return 0xFF;
06386:  MOVLW  FF
06388:  MOVWF  01
0638A:  MOVLB  0
0638C:  GOTO   AA04 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* COMMAND HANDLER/PARSER FUNCS                                              */
.................... /*****************************************************************************/
.................... void echo_cmd(unsigned int8 rec){
....................    fprintf(SERIAL, "%c", SERcmd[rec].t);
....................    while (SERcmd[rec].recReadIndex <= SERcmd[rec].recWriteIndex)
....................    {
....................       if (SERcmd[rec].recReadIndex != 0) fprintf(SERIAL, "%c", delimiter);
....................       fprintf(SERIAL, "%s", SERcmd[rec].p[SERcmd[rec].recReadIndex]);
....................       SERcmd[rec].recReadIndex++;
....................    }
....................    SERcmd[rec].recReadIndex=0;
.................... }
.................... 
.................... int8 command_parser(unsigned int8 rec){
*
0A960:  MOVLB  6
0A962:  CLRF   xB1
0A964:  MOVFF  665,6B0
0A968:  CLRF   xB3
0A96A:  MOVLW  B5
0A96C:  MOVWF  xB2
0A96E:  MOVLB  0
0A970:  CALL   07F0
0A974:  MOVFF  02,66E
0A978:  MOVFF  01,66D
0A97C:  MOVLW  06
0A97E:  MOVLB  6
0A980:  ADDWF  x6D,F
0A982:  MOVLW  00
0A984:  ADDWFC x6E,F
0A986:  MOVLW  DC
0A988:  ADDWF  x6D,W
0A98A:  MOVWF  01
0A98C:  MOVLW  01
0A98E:  ADDWFC x6E,W
0A990:  MOVWF  03
0A992:  MOVFF  01,666
0A996:  MOVWF  x67
0A998:  CLRF   xB1
0A99A:  MOVFF  665,6B0
0A99E:  CLRF   xB3
0A9A0:  MOVLW  B5
0A9A2:  MOVWF  xB2
0A9A4:  MOVLB  0
0A9A6:  CALL   07F0
0A9AA:  MOVFF  02,670
0A9AE:  MOVFF  01,66F
0A9B2:  MOVLW  06
0A9B4:  MOVLB  6
0A9B6:  ADDWF  x6F,F
0A9B8:  MOVLW  00
0A9BA:  ADDWFC x70,F
0A9BC:  MOVLW  19
0A9BE:  ADDWF  x6F,W
0A9C0:  MOVWF  01
0A9C2:  MOVLW  00
0A9C4:  ADDWFC x70,W
0A9C6:  MOVWF  03
0A9C8:  MOVF   01,W
0A9CA:  ADDLW  DC
0A9CC:  MOVWF  01
0A9CE:  MOVLW  01
0A9D0:  ADDWFC 03,F
0A9D2:  MOVFF  01,668
0A9D6:  MOVFF  03,669
0A9DA:  CLRF   x6A
0A9DC:  CLRF   x6B
....................    char *cmd_adr = SERcmd[rec].p[0];
....................    char *cmd_str = SERcmd[rec].p[1];
.................... //!   int8 devID = input_a();
....................    int8 devID = 0;
....................    int8 i = 0;
....................    
....................    if (hwID == cmd_adr[0]){
0A9DE:  MOVFF  666,FE9
0A9E2:  MOVFF  667,FEA
0A9E6:  MOVF   FEF,W
0A9E8:  SUBLW  44
0A9EA:  BTFSS  FD8.2
0A9EC:  BRA    AADC
....................       if (hex_to_int(cmd_adr[1]) == (devID & 0x0F)){
0A9EE:  MOVLW  01
0A9F0:  ADDWF  x66,W
0A9F2:  MOVWF  FE9
0A9F4:  MOVLW  00
0A9F6:  ADDWFC x67,W
0A9F8:  MOVWF  FEA
0A9FA:  MOVFF  FEF,66E
0A9FE:  MOVLB  0
0AA00:  GOTO   6356
0AA04:  MOVFF  01,66D
0AA08:  MOVLB  6
0AA0A:  MOVF   x6A,W
0AA0C:  ANDLW  0F
0AA0E:  SUBWF  01,W
0AA10:  BNZ   AAD4
....................          while (0 != strlen(cmd_list[i].cmd_name)){
0AA12:  MOVF   x6B,W
0AA14:  MULLW  04
0AA16:  MOVF   FF3,W
0AA18:  CLRF   x6E
0AA1A:  MOVWF  x6D
0AA1C:  MOVLW  5C
0AA1E:  ADDWF  x6D,W
0AA20:  MOVWF  FE9
0AA22:  MOVLW  05
0AA24:  ADDWFC x6E,W
0AA26:  MOVWF  FEA
0AA28:  MOVFF  FEC,6A6
0AA2C:  MOVF   FED,F
0AA2E:  MOVFF  FEF,6A5
0AA32:  MOVLB  0
0AA34:  CALL   6390
0AA38:  MOVFF  02,03
0AA3C:  MOVF   01,W
0AA3E:  BNZ   AA44
0AA40:  MOVF   03,F
0AA42:  BZ    AACA
....................             if (0 == strcmp(cmd_str, cmd_list[i].cmd_name))
0AA44:  MOVLB  6
0AA46:  MOVF   x6B,W
0AA48:  MULLW  04
0AA4A:  MOVF   FF3,W
0AA4C:  CLRF   x6E
0AA4E:  MOVWF  x6D
0AA50:  MOVLW  5C
0AA52:  ADDWF  x6D,W
0AA54:  MOVWF  FE9
0AA56:  MOVLW  05
0AA58:  ADDWFC x6E,W
0AA5A:  MOVWF  FEA
0AA5C:  MOVFF  FEC,6A8
0AA60:  MOVF   FED,F
0AA62:  MOVFF  FEF,6A7
0AA66:  MOVFF  669,6A6
0AA6A:  MOVFF  668,6A5
0AA6E:  MOVLB  0
0AA70:  CALL   63C8
0AA74:  MOVF   01,F
0AA76:  BNZ   AAC2
....................             {
....................                int8 return_code = cmd_list[i].cmd_func(rec);
0AA78:  MOVLB  6
0AA7A:  MOVF   x6B,W
0AA7C:  MULLW  04
0AA7E:  MOVF   FF3,W
0AA80:  CLRF   x6E
0AA82:  MOVWF  x6D
0AA84:  MOVLW  02
0AA86:  ADDWF  x6D,W
0AA88:  MOVWF  01
0AA8A:  MOVLW  00
0AA8C:  ADDWFC x6E,W
0AA8E:  MOVWF  03
0AA90:  MOVF   01,W
0AA92:  ADDLW  5C
0AA94:  MOVWF  01
0AA96:  MOVLW  05
0AA98:  ADDWFC 03,F
0AA9A:  MOVFF  01,66D
0AA9E:  MOVFF  03,66E
0AAA2:  MOVFF  03,FEA
0AAA6:  MOVFF  01,FE9
0AAAA:  MOVFF  665,663
0AAAE:  MOVLB  0
0AAB0:  CALL   00BC
0AAB4:  MOVFF  01,66C
....................                return return_code;
0AAB8:  MOVLB  6
0AABA:  MOVFF  66C,01
0AABE:  BRA    AAE0
0AAC0:  MOVLB  0
....................             }
....................             i++;
0AAC2:  MOVLB  6
0AAC4:  INCF   x6B,F
0AAC6:  BRA    AA12
0AAC8:  MOVLB  0
....................          }
....................          return INV_CMD; // INVALID_CMD
0AACA:  MOVLW  01
0AACC:  MOVWF  01
0AACE:  MOVLB  6
0AAD0:  BRA    AAE0
....................       } else return 254; // NOT THIS ADDRESS
0AAD2:  BRA    AADA
0AAD4:  MOVLW  FE
0AAD6:  MOVWF  01
0AAD8:  BRA    AAE0
....................    } else return 255; // NOT THIS DEVICE TYPE
0AADA:  BRA    AAE0
0AADC:  MOVLW  FF
0AADE:  MOVWF  01
0AAE0:  MOVLB  0
0AAE2:  GOTO   AB1C (RETURN)
.................... }
.................... 
.................... void command_handler_task(){
....................    while (getNextSERReadIndex())
*
0AB0E:  GOTO   62FC
0AB12:  MOVF   01,F
0AB14:  BZ    AC04
....................    {
....................       int8 return_code = command_parser(SRI);
0AB16:  MOVFF  4B0,665
0AB1A:  BRA    A960
0AB1C:  MOVFF  01,664
....................       //echo_cmd(SRI);
....................       sprintf(retData + strlen(retData), "%s", resp_list[return_code].msg);
0AB20:  MOVLW  04
0AB22:  MOVLB  6
0AB24:  MOVWF  xA6
0AB26:  MOVLW  B2
0AB28:  MOVWF  xA5
0AB2A:  MOVLB  0
0AB2C:  CALL   6390
0AB30:  MOVF   01,W
0AB32:  ADDLW  B2
0AB34:  MOVLB  6
0AB36:  MOVWF  x65
0AB38:  MOVLW  04
0AB3A:  ADDWFC 02,W
0AB3C:  MOVWF  x66
0AB3E:  MOVF   x64,W
0AB40:  MULLW  03
0AB42:  MOVF   FF3,W
0AB44:  CLRF   x68
0AB46:  MOVWF  x67
0AB48:  MOVLW  01
0AB4A:  ADDWF  x67,W
0AB4C:  MOVWF  01
0AB4E:  MOVLW  00
0AB50:  ADDWFC x68,W
0AB52:  MOVWF  03
0AB54:  MOVF   01,W
0AB56:  ADDLW  2B
0AB58:  MOVWF  FE9
0AB5A:  MOVLW  06
0AB5C:  ADDWFC 03,W
0AB5E:  MOVWF  FEA
0AB60:  MOVFF  FEC,668
0AB64:  MOVF   FED,F
0AB66:  MOVFF  FEF,667
0AB6A:  MOVFF  666,557
0AB6E:  MOVFF  665,556
0AB72:  MOVFF  557,FEA
0AB76:  MOVFF  556,FE9
0AB7A:  CLRF   FEF
0AB7C:  MOVFF  668,FEA
0AB80:  MOVFF  667,FE9
0AB84:  MOVLB  0
0AB86:  BRA    AAE6
....................       fprintf(SERIAL, "$%s,%s\n", SERcmd[SRI].p[0], retData);
0AB88:  MOVLB  6
0AB8A:  CLRF   xB1
0AB8C:  MOVFF  4B0,6B0
0AB90:  CLRF   xB3
0AB92:  MOVLW  B5
0AB94:  MOVWF  xB2
0AB96:  MOVLB  0
0AB98:  CALL   07F0
0AB9C:  MOVFF  02,666
0ABA0:  MOVFF  01,665
0ABA4:  MOVLW  06
0ABA6:  MOVLB  6
0ABA8:  ADDWF  x65,F
0ABAA:  MOVLW  00
0ABAC:  ADDWFC x66,F
0ABAE:  MOVLW  DC
0ABB0:  ADDWF  x65,W
0ABB2:  MOVWF  01
0ABB4:  MOVLW  01
0ABB6:  ADDWFC x66,W
0ABB8:  MOVWF  03
0ABBA:  MOVFF  01,667
0ABBE:  MOVWF  x68
0ABC0:  MOVLW  24
0ABC2:  MOVWF  x7A
0ABC4:  MOVLB  0
0ABC6:  CALL   5A3E
0ABCA:  MOVFF  668,FEA
0ABCE:  MOVFF  667,FE9
0ABD2:  CALL   5A66
0ABD6:  MOVLW  2C
0ABD8:  MOVLB  6
0ABDA:  MOVWF  x7A
0ABDC:  MOVLB  0
0ABDE:  CALL   5A3E
0ABE2:  MOVLW  04
0ABE4:  MOVWF  FEA
0ABE6:  MOVLW  B2
0ABE8:  MOVWF  FE9
0ABEA:  CALL   5A66
0ABEE:  MOVLW  0A
0ABF0:  MOVLB  6
0ABF2:  MOVWF  x7A
0ABF4:  MOVLB  0
0ABF6:  CALL   5A3E
....................       
....................       resetSERcmd(SRI);
0ABFA:  MOVFF  4B0,665
0ABFE:  CALL   10DC
0AC02:  BRA    AB0E
....................    }
0AC04:  GOTO   B174 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... #define DEBUG_1
.................... 
.................... void main()
0AC08:  CLRF   FF8
0AC0A:  BCF    FF2.5
0AC0C:  BSF    07.7
0AC0E:  MOVLB  E
0AC10:  MOVLW  55
0AC12:  MOVWF  x9B
0AC14:  MOVLW  AA
0AC16:  MOVWF  x9B
0AC18:  BCF    x9B.0
0AC1A:  MOVLW  17
0AC1C:  MOVWF  xB0
0AC1E:  MOVLW  13
0AC20:  MOVWF  xB2
0AC22:  MOVLW  09
0AC24:  MOVWF  x8A
0AC26:  MOVLW  0A
0AC28:  MOVWF  x8B
0AC2A:  MOVLW  11
0AC2C:  MOVWF  xEB
0AC2E:  MOVLW  12
0AC30:  MOVWF  xED
0AC32:  MOVLW  10
0AC34:  MOVWF  xF4
0AC36:  MOVLW  0F
0AC38:  MOVWF  xF5
0AC3A:  MOVLW  09
0AC3C:  MOVWF  xF8
0AC3E:  MOVLW  55
0AC40:  MOVWF  x9B
0AC42:  MOVLW  AA
0AC44:  MOVWF  x9B
0AC46:  BSF    x9B.0
0AC48:  CLRF   xD8
0AC4A:  CLRF   xD5
0AC4C:  CLRF   xD7
0AC4E:  MOVLW  08
0AC50:  MOVWF  xD9
0AC52:  MOVLW  60
0AC54:  MOVWF  xD3
0AC56:  MOVLW  AA
0AC58:  MOVLB  0
0AC5A:  MOVWF  xF2
0AC5C:  MOVLB  1
0AC5E:  CLRF   x5A
0AC60:  CLRF   x59
0AC62:  CLRF   x58
0AC64:  CLRF   x57
0AC66:  CLRF   x5E
0AC68:  CLRF   x5D
0AC6A:  CLRF   x5C
0AC6C:  CLRF   x5B
0AC6E:  CLRF   x62
0AC70:  CLRF   x61
0AC72:  CLRF   x60
0AC74:  CLRF   x5F
0AC76:  CLRF   x64
0AC78:  CLRF   x63
0AC7A:  MOVLB  E
0AC7C:  BCF    x91.5
0AC7E:  MOVLW  00
0AC80:  MOVWF  x90
0AC82:  MOVLW  0F
0AC84:  MOVWF  x8E
0AC86:  MOVLW  2A
0AC88:  MOVWF  x91
0AC8A:  MOVLW  C4
0AC8C:  MOVWF  F88
0AC8E:  MOVWF  F88
0AC90:  MOVWF  F88
0AC92:  BCF    F95.5
0AC94:  MOVLW  40
0AC96:  MOVWF  F94
0AC98:  MOVLW  9F
0AC9A:  MOVWF  F92
0AC9C:  MOVLW  3A
0AC9E:  MOVWF  F95
0ACA0:  MOVLW  93
0ACA2:  MOVWF  F89
0ACA4:  MOVWF  F89
0ACA6:  MOVLB  4
0ACA8:  CLRF   xB0
0ACAA:  CLRF   xB1
0ACAC:  MOVLB  5
0ACAE:  CLRF   x52
0ACB0:  CLRF   x53
0ACB2:  BCF    x54.0
0ACB4:  CLRF   x55
0ACB6:  BSF    F9E.3
0ACB8:  MOVLW  7C
0ACBA:  MOVWF  F9A
0ACBC:  MOVLW  00
0ACBE:  MOVWF  F9B
0ACC0:  MOVLW  A6
0ACC2:  MOVWF  F9D
0ACC4:  MOVLW  90
0ACC6:  MOVWF  F9C
0ACC8:  MOVLW  93
0ACCA:  MOVWF  F89
0ACCC:  BCF    F84.5
0ACCE:  CLRF   x57
0ACD0:  CLRF   x56
0ACD2:  CLRF   x5B
0ACD4:  CLRF   x5A
0ACD6:  CLRF   x59
0ACD8:  CLRF   x58
0ACDA:  MOVLB  F
0ACDC:  CLRF   x0C
0ACDE:  CLRF   x14
0ACE0:  CLRF   x1C
0ACE2:  CLRF   x21
0ACE4:  CLRF   x29
0ACE6:  CLRF   x35
0ACE8:  CLRF   x36
0ACEA:  CLRF   x37
0ACEC:  CLRF   x34
0ACEE:  CLRF   x31
0ACF0:  CLRF   x32
0ACF2:  CLRF   x33
0ACF4:  CLRF   x30
0ACF6:  MOVLW  64
0ACF8:  MOVLB  5
0ACFA:  MOVWF  x5F
0ACFC:  MOVLW  80
0ACFE:  MOVWF  x5E
0AD00:  MOVLW  64
0AD02:  MOVWF  x63
0AD04:  MOVLW  C4
0AD06:  MOVWF  x62
0AD08:  MOVLW  6A
0AD0A:  MOVWF  x67
0AD0C:  MOVLW  0C
0AD0E:  MOVWF  x66
0AD10:  MOVLW  6B
0AD12:  MOVWF  x6B
0AD14:  MOVLW  EA
0AD16:  MOVWF  x6A
0AD18:  MOVLW  6D
0AD1A:  MOVWF  x6F
0AD1C:  MOVLW  C2
0AD1E:  MOVWF  x6E
0AD20:  MOVLW  6F
0AD22:  MOVWF  x73
0AD24:  MOVLW  4E
0AD26:  MOVWF  x72
0AD28:  MOVLW  73
0AD2A:  MOVWF  x77
0AD2C:  MOVLW  1E
0AD2E:  MOVWF  x76
0AD30:  MOVLW  7A
0AD32:  MOVWF  x7B
0AD34:  MOVLW  F0
0AD36:  MOVWF  x7A
0AD38:  MOVLW  7D
0AD3A:  MOVWF  x7F
0AD3C:  MOVLW  D0
0AD3E:  MOVWF  x7E
0AD40:  MOVLW  7F
0AD42:  MOVWF  x83
0AD44:  MOVLW  32
0AD46:  MOVWF  x82
0AD48:  MOVLW  80
0AD4A:  MOVWF  x87
0AD4C:  MOVLW  F0
0AD4E:  MOVWF  x86
0AD50:  MOVLW  84
0AD52:  MOVWF  x8B
0AD54:  MOVLW  A6
0AD56:  MOVWF  x8A
0AD58:  MOVLW  8A
0AD5A:  MOVWF  x8F
0AD5C:  MOVLW  02
0AD5E:  MOVWF  x8E
0AD60:  MOVLW  8D
0AD62:  MOVWF  x93
0AD64:  MOVLW  9A
0AD66:  MOVWF  x92
0AD68:  MOVLW  92
0AD6A:  MOVWF  x97
0AD6C:  MOVLW  C6
0AD6E:  MOVWF  x96
0AD70:  MOVLW  92
0AD72:  MOVWF  x9B
0AD74:  MOVLW  CC
0AD76:  MOVWF  x9A
0AD78:  MOVLW  99
0AD7A:  MOVWF  x9F
0AD7C:  MOVLW  40
0AD7E:  MOVWF  x9E
0AD80:  MOVLW  9E
0AD82:  MOVWF  xA3
0AD84:  MOVLW  A4
0AD86:  MOVWF  xA2
0AD88:  MOVLW  A5
0AD8A:  MOVWF  xA7
0AD8C:  MOVLW  C6
0AD8E:  MOVWF  xA6
0AD90:  MOVLW  A7
0AD92:  MOVWF  xAB
0AD94:  MOVLW  18
0AD96:  MOVWF  xAA
0AD98:  MOVLW  A9
0AD9A:  MOVWF  xAF
0AD9C:  MOVLW  5A
0AD9E:  MOVWF  xAE
0ADA0:  BRA    AF68
0ADA2:  DATA 02,00
0ADA4:  DATA 1A,00
0ADA6:  DATA 00,0C
0ADA8:  DATA 00,20
0ADAA:  DATA 78,23
0ADAC:  DATA D7,0A
0ADAE:  DATA 7D,19
0ADB0:  DATA 99,9A
0ADB2:  DATA 7B,4C
0ADB4:  DATA CC,CD
0ADB6:  DATA 14,C0
0ADB8:  DATA 00,0C
0ADBA:  DATA 80,78
0ADBC:  DATA 23,D7
0ADBE:  DATA 0A,7D
0ADC0:  DATA 19,99
0ADC2:  DATA 9A,7B
0ADC4:  DATA 4C,CC
0ADC6:  DATA CD,14
0ADC8:  DATA C0,00
0ADCA:  DATA 01,80
0ADCC:  DATA 02,09
0ADCE:  DATA C0,00
0ADD0:  DATA 05,80
0ADD2:  DATA 7F,00
0ADD4:  DATA 00,00
0ADD6:  DATA 7F,0B
0ADD8:  DATA C0,00
0ADDA:  DATA 05,80
0ADDC:  DATA 7F,00
0ADDE:  DATA 00,00
0ADE0:  DATA 7F,07
0ADE2:  DATA C0,00
0ADE4:  DATA 01,80
0ADE6:  DATA 7F,17
0ADE8:  DATA C0,00
0ADEA:  DATA 01,80
0ADEC:  DATA 7F,17
0ADEE:  DATA C0,00
0ADF0:  DATA 04,80
0ADF2:  DATA 79,B7
0ADF4:  DATA F3,BD
0ADF6:  DATA 04,C0
0ADF8:  DATA 00,04
0ADFA:  DATA 80,7C
0ADFC:  DATA 59,DF
0ADFE:  DATA 4E,04
0AE00:  DATA C0,00
0AE02:  DATA 04,80
0AE04:  DATA 78,0A
0AE06:  DATA 28,88
0AE08:  DATA 04,C0
0AE0A:  DATA 00,04
0AE0C:  DATA 80,78
0AE0E:  DATA 05,EA
0AE10:  DATA 16,04
0AE12:  DATA C0,00
0AE14:  DATA 04,80
0AE16:  DATA 78,1E
0AE18:  DATA 33,D7
0AE1A:  DATA 04,C0
0AE1C:  DATA 00,04
0AE1E:  DATA 80,77
0AE20:  DATA 68,7B
0AE22:  DATA BB,04
0AE24:  DATA C0,00
0AE26:  DATA 04,80
0AE28:  DATA 77,68
0AE2A:  DATA 0D,C6
0AE2C:  DATA 08,C0
0AE2E:  DATA 00,64
0AE30:  DATA 40,F3
0AE32:  DATA 00,05
0AE34:  DATA 01,BD
0AE36:  DATA 00,65
0AE38:  DATA 01,7B
0AE3A:  DATA 01,09
0AE3C:  DATA C0,00
0AE3E:  DATA 04,80
0AE40:  DATA 91,01
0AE42:  DATA A7,01
0AE44:  DATA 0D,C0
0AE46:  DATA 00,3C
0AE48:  DATA 45,16
0AE4A:  DATA 00,02
0AE4C:  DATA 05,5C
0AE4E:  DATA B0,05
0AE50:  DATA 02,05
0AE52:  DATA 60,B3
0AE54:  DATA 05,02
0AE56:  DATA 05,64
0AE58:  DATA B6,05
0AE5A:  DATA 02,05
0AE5C:  DATA 68,BD
0AE5E:  DATA 05,02
0AE60:  DATA 05,6C
0AE62:  DATA C4,05
0AE64:  DATA 02,05
0AE66:  DATA 70,CC
0AE68:  DATA 05,02
0AE6A:  DATA 05,74
0AE6C:  DATA D4,05
0AE6E:  DATA 02,05
0AE70:  DATA 78,D9
0AE72:  DATA 05,02
0AE74:  DATA 05,7C
0AE76:  DATA DE,05
0AE78:  DATA 02,05
0AE7A:  DATA 80,E2
0AE7C:  DATA 05,02
0AE7E:  DATA 05,84
0AE80:  DATA E6,05
0AE82:  DATA 02,05
0AE84:  DATA 88,ED
0AE86:  DATA 05,02
0AE88:  DATA 05,8C
0AE8A:  DATA F3,05
0AE8C:  DATA 02,05
0AE8E:  DATA 90,F9
0AE90:  DATA 05,02
0AE92:  DATA 05,94
0AE94:  DATA FF,05
0AE96:  DATA 02,05
0AE98:  DATA 98,05
0AE9A:  DATA 06,02
0AE9C:  DATA 05,9C
0AE9E:  DATA 0A,06
0AEA0:  DATA 02,05
0AEA2:  DATA A0,13
0AEA4:  DATA 06,02
0AEA6:  DATA 05,A4
0AEA8:  DATA 1B,06
0AEAA:  DATA 02,05
0AEAC:  DATA A8,22
0AEAE:  DATA 06,02
0AEB0:  DATA 05,AC
0AEB2:  DATA 29,06
0AEB4:  DATA 78,05
0AEB6:  DATA B0,67
0AEB8:  DATA 72,00
0AEBA:  DATA 67,73
0AEBC:  DATA 00,67
0AEBE:  DATA 43,68
0AEC0:  DATA 4D,61
0AEC2:  DATA 70,00
0AEC4:  DATA 73,43
0AEC6:  DATA 68,4D
0AEC8:  DATA 61,70
0AECA:  DATA 00,67
0AECC:  DATA 43,68
0AECE:  DATA 4D,6F
0AED0:  DATA 64,65
0AED2:  DATA 00,73
0AED4:  DATA 43,68
0AED6:  DATA 4D,6F
0AED8:  DATA 64,65
0AEDA:  DATA 00,67
0AEDC:  DATA 50,49
0AEDE:  DATA 44,00
0AEE0:  DATA 73,50
0AEE2:  DATA 49,44
0AEE4:  DATA 00,67
0AEE6:  DATA 53,50
0AEE8:  DATA 00,73
0AEEA:  DATA 53,50
0AEEC:  DATA 00,67
0AEEE:  DATA 53,43
0AEF0:  DATA 61,6C
0AEF2:  DATA 73,00
0AEF4:  DATA 67,53
0AEF6:  DATA 43,61
0AEF8:  DATA 6C,00
0AEFA:  DATA 73,53
0AEFC:  DATA 43,61
0AEFE:  DATA 6C,00
0AF00:  DATA 67,4D
0AF02:  DATA 43,61
0AF04:  DATA 6C,00
0AF06:  DATA 73,4D
0AF08:  DATA 43,61
0AF0A:  DATA 6C,00
0AF0C:  DATA 67,4D
0AF0E:  DATA 6F,6E
0AF10:  DATA 00,67
0AF12:  DATA 50,49
0AF14:  DATA 44,64
0AF16:  DATA 61,74
0AF18:  DATA 61,00
0AF1A:  DATA 67,49
0AF1C:  DATA 50,64
0AF1E:  DATA 61,74
0AF20:  DATA 61,00
0AF22:  DATA 67,4D
0AF24:  DATA 61,6E
0AF26:  DATA 4F,50
0AF28:  DATA 00,73
0AF2A:  DATA 4D,61
0AF2C:  DATA 6E,4F
0AF2E:  DATA 50,04
0AF30:  DATA C0,00
0AF32:  DATA 33,80
0AF34:  DATA 34,06
0AF36:  DATA 01,3C
0AF38:  DATA 06,02
0AF3A:  DATA 4C,06
0AF3C:  DATA 53,55
0AF3E:  DATA 43,43
0AF40:  DATA 45,53
0AF42:  DATA 53,00
0AF44:  DATA 49,4E
0AF46:  DATA 56,41
0AF48:  DATA 4C,49
0AF4A:  DATA 44,20
0AF4C:  DATA 43,4F
0AF4E:  DATA 4D,4D
0AF50:  DATA 41,4E
0AF52:  DATA 44,00
0AF54:  DATA 49,4E
0AF56:  DATA 56,41
0AF58:  DATA 4C,49
0AF5A:  DATA 44,20
0AF5C:  DATA 50,41
0AF5E:  DATA 52,41
0AF60:  DATA 4D,45
0AF62:  DATA 54,45
0AF64:  DATA 52,00
0AF66:  DATA 00,00
0AF68:  MOVLW  00
0AF6A:  MOVWF  FF8
0AF6C:  MOVLW  AD
0AF6E:  MOVWF  FF7
0AF70:  MOVLW  A2
0AF72:  MOVWF  FF6
0AF74:  TBLRD*+
0AF76:  MOVF   FF5,W
0AF78:  MOVWF  00
0AF7A:  XORLW  00
0AF7C:  BZ    AFA4
0AF7E:  TBLRD*+
0AF80:  MOVF   FF5,W
0AF82:  MOVWF  01
0AF84:  BTFSC  FE8.7
0AF86:  BRA    AF92
0AF88:  ANDLW  3F
0AF8A:  MOVWF  FEA
0AF8C:  TBLRD*+
0AF8E:  MOVFF  FF5,FE9
0AF92:  BTFSC  01.6
0AF94:  TBLRD*+
0AF96:  BTFSS  01.6
0AF98:  TBLRD*+
0AF9A:  MOVFF  FF5,FEE
0AF9E:  DCFSNZ 00,F
0AFA0:  BRA    AF74
0AFA2:  BRA    AF96
0AFA4:  CLRF   FF8
.................... {
....................    IO_init();                    // set up IO 
0AFA6:  MOVLB  0
0AFA8:  GOTO   0390
....................    params_init();                // load parameters
0AFAC:  GOTO   0638
....................    monitor_init();               // initialize internal ADC for voltage and current telemetry
0AFB0:  GOTO   101C
....................    control_init();               // initialize the output control DACs
0AFB4:  GOTO   10B8
....................    serial_init();                // setup the serial port
0AFB8:  GOTO   1266
....................    event_timer_init();
0AFBC:  GOTO   1288
.................... //!   setup_wdt(WDT_512MS);
....................    enable_interrupts(GLOBAL);
0AFC0:  MOVLW  C0
0AFC2:  IORWF  FF2,F
....................    
....................    while(TRUE)
....................    {
.................... //!      restart_wdt();
....................       internal_monitor_task();   //Update monitored voltage and currents etc
0AFC4:  GOTO   1666
....................       sensor_monitor_task();     //get magnetoresistive sensor data
0AFC8:  GOTO   4EF6
....................       control_task();            //output control
0AFCC:  GOTO   59C2
....................       serial_task();             //serial port 
0AFD0:  GOTO   5A8A
....................       
....................       #ifdef DEBUG_1
....................       static int8 ch = 0;
....................       fprintf(SERIAL, "#D0,CNT,%u,%.0f,%.0f\n", ch+1, adcVals[ch].sinCounts, adcVals[ch].cosCounts);
0AFD4:  MOVLW  01
0AFD6:  MOVLB  6
0AFD8:  ADDWF  x5E,W
0AFDA:  MOVWF  x64
0AFDC:  MOVF   x5E,W
0AFDE:  MULLW  21
0AFE0:  MOVF   FF3,W
0AFE2:  CLRF   x66
0AFE4:  MOVWF  x65
0AFE6:  MOVLW  08
0AFE8:  ADDWF  x65,W
0AFEA:  MOVWF  01
0AFEC:  MOVLW  00
0AFEE:  ADDWFC x66,W
0AFF0:  MOVWF  03
0AFF2:  MOVF   01,W
0AFF4:  ADDLW  0F
0AFF6:  MOVWF  FE9
0AFF8:  MOVLW  01
0AFFA:  ADDWFC 03,W
0AFFC:  MOVWF  FEA
0AFFE:  MOVFF  FEF,665
0B002:  MOVFF  FEC,666
0B006:  MOVFF  FEC,667
0B00A:  MOVFF  FEC,668
0B00E:  MOVF   x5E,W
0B010:  MULLW  21
0B012:  MOVF   FF3,W
0B014:  CLRF   x6A
0B016:  MOVWF  x69
0B018:  MOVLW  0C
0B01A:  ADDWF  x69,W
0B01C:  MOVWF  01
0B01E:  MOVLW  00
0B020:  ADDWFC x6A,W
0B022:  MOVWF  03
0B024:  MOVF   01,W
0B026:  ADDLW  0F
0B028:  MOVWF  FE9
0B02A:  MOVLW  01
0B02C:  ADDWFC 03,W
0B02E:  MOVWF  FEA
0B030:  MOVFF  FEF,669
0B034:  MOVFF  FEC,66A
0B038:  MOVFF  FEC,66B
0B03C:  MOVFF  FEC,66C
0B040:  MOVLW  56
0B042:  MOVWF  FF6
0B044:  MOVLW  03
0B046:  MOVWF  FF7
0B048:  MOVLW  08
0B04A:  MOVWF  x6D
0B04C:  MOVLB  0
0B04E:  CALL   5F82
0B052:  MOVFF  664,66D
0B056:  MOVLW  1B
0B058:  MOVLB  6
0B05A:  MOVWF  x6E
0B05C:  MOVLB  0
0B05E:  CALL   5FD6
0B062:  MOVLW  2C
0B064:  MOVLB  6
0B066:  MOVWF  x7A
0B068:  MOVLB  0
0B06A:  CALL   5A3E
0B06E:  MOVLW  89
0B070:  MOVWF  FE9
0B072:  MOVFF  668,670
0B076:  MOVFF  667,66F
0B07A:  MOVFF  666,66E
0B07E:  MOVFF  665,66D
0B082:  MOVLB  6
0B084:  CLRF   x71
0B086:  MOVLB  0
0B088:  CALL   6128
0B08C:  MOVLW  2C
0B08E:  MOVLB  6
0B090:  MOVWF  x7A
0B092:  MOVLB  0
0B094:  CALL   5A3E
0B098:  MOVLW  89
0B09A:  MOVWF  FE9
0B09C:  MOVFF  66C,670
0B0A0:  MOVFF  66B,66F
0B0A4:  MOVFF  66A,66E
0B0A8:  MOVFF  669,66D
0B0AC:  MOVLB  6
0B0AE:  CLRF   x71
0B0B0:  MOVLB  0
0B0B2:  CALL   6128
0B0B6:  MOVLW  0A
0B0B8:  MOVLB  6
0B0BA:  MOVWF  x7A
0B0BC:  MOVLB  0
0B0BE:  CALL   5A3E
....................       fprintf(SERIAL, "#D0,POS,%u,%3.3f\n", ch+1, adcVals[ch].pReal);
0B0C2:  MOVLW  01
0B0C4:  MOVLB  6
0B0C6:  ADDWF  x5E,W
0B0C8:  MOVWF  x64
0B0CA:  MOVF   x5E,W
0B0CC:  MULLW  21
0B0CE:  MOVF   FF3,W
0B0D0:  CLRF   x66
0B0D2:  MOVWF  x65
0B0D4:  MOVLW  1D
0B0D6:  ADDWF  x65,W
0B0D8:  MOVWF  01
0B0DA:  MOVLW  00
0B0DC:  ADDWFC x66,W
0B0DE:  MOVWF  03
0B0E0:  MOVF   01,W
0B0E2:  ADDLW  0F
0B0E4:  MOVWF  FE9
0B0E6:  MOVLW  01
0B0E8:  ADDWFC 03,W
0B0EA:  MOVWF  FEA
0B0EC:  MOVFF  FEF,665
0B0F0:  MOVFF  FEC,666
0B0F4:  MOVFF  FEC,667
0B0F8:  MOVFF  FEC,668
0B0FC:  MOVLW  6C
0B0FE:  MOVWF  FF6
0B100:  MOVLW  03
0B102:  MOVWF  FF7
0B104:  MOVLW  08
0B106:  MOVWF  x6D
0B108:  MOVLB  0
0B10A:  CALL   5F82
0B10E:  MOVFF  664,66D
0B112:  MOVLW  1B
0B114:  MOVLB  6
0B116:  MOVWF  x6E
0B118:  MOVLB  0
0B11A:  CALL   5FD6
0B11E:  MOVLW  2C
0B120:  MOVLB  6
0B122:  MOVWF  x7A
0B124:  MOVLB  0
0B126:  CALL   5A3E
0B12A:  MOVLW  89
0B12C:  MOVWF  FE9
0B12E:  MOVFF  668,670
0B132:  MOVFF  667,66F
0B136:  MOVFF  666,66E
0B13A:  MOVFF  665,66D
0B13E:  MOVLW  03
0B140:  MOVLB  6
0B142:  MOVWF  x71
0B144:  MOVLB  0
0B146:  CALL   6128
0B14A:  MOVLW  0A
0B14C:  MOVLB  6
0B14E:  MOVWF  x7A
0B150:  MOVLB  0
0B152:  CALL   5A3E
.................... //!      if ( dacVals[ch].invV ) fprintf(SERIAL, "#D0,OUT,%u,-,%Lu\n", ch+1, dacVals[ch].val);
.................... //!      else                    fprintf(SERIAL, "#D0,OUT,%u,+,%Lu\n", ch+1, dacVals[ch].val);
....................       ch = !ch;
0B156:  MOVLB  6
0B158:  MOVF   x5E,F
0B15A:  BZ    B160
0B15C:  MOVLW  00
0B15E:  BRA    B162
0B160:  MOVLW  01
0B162:  MOVWF  x5E
....................       fprintf(SERIAL, "---------------\n");
0B164:  MOVLW  7E
0B166:  MOVWF  FF6
0B168:  MOVLW  03
0B16A:  MOVWF  FF7
0B16C:  MOVLB  0
0B16E:  GOTO   62D8
....................       #endif
....................       
....................       command_handler_task();    //execute commands
0B172:  BRA    AB0E
....................       
....................       delay_ms(250);
0B174:  MOVLW  FA
0B176:  MOVLB  6
0B178:  MOVWF  x6C
0B17A:  MOVLB  0
0B17C:  CALL   0426
0B180:  BRA    AFC4
....................    }
.................... }
0B182:  BRA    B182

Configuration Fuses:
   Word  1: FF8C   NOEXTOSC RSTOSC_HFINTRC_64MHZ NOCLKOUT CKS FCMEN
   Word  2: CF3F   MCLR NOPUT NOLPBOR NOBROWNOUT BORV19 ZCDDIS PPS1WAY NOSTVREN DEBUG NOXINST
   Word  3: FF9F   WDTSW NOWDT WDTWIN_SW WDTCLK_SW
   Word  4: DFFF   NOWRT NOWRTC NOWRTB NOWRTD SCANE NOLVP
   Word  5: FFFF   NOPROTECT NOCPD
   Word  6: FFFF   NOEBTR NOEBTRB

   Some fuses have been forced to be compatible with the ICD debugger.
