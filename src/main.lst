CCS PCH C Compiler, Version 5.117, 2138               25-Feb-26 17:32

               Filename:   C:\Users\Aidan\Documents\GitHub\DiFCS-Controller\src\main.lst

               ROM used:   45606 bytes (70%)
                           Largest free fragment is 19928
               RAM used:   1815 (50%) at main() level
                           1929 (53%) worst case
               Stack used: 8 locations (6 in main + 2 for interrupts)
               Stack size: 31

*
00000:  NOP   
00002:  GOTO   AD58
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  MOVLB  E
00056:  BTFSS  xC0.5
00058:  GOTO   0062
0005C:  BTFSC  xC8.5
0005E:  GOTO   00E8
00062:  BTFSS  xC1.0
00064:  GOTO   006E
00068:  BTFSC  xC9.0
0006A:  GOTO   025C
0006E:  MOVFF  0E,00
00072:  MOVFF  0F,01
00076:  MOVFF  10,02
0007A:  MOVFF  11,03
0007E:  MOVFF  0C,FE9
00082:  MOVFF  07,FEA
00086:  BSF    07.7
00088:  MOVFF  08,FE1
0008C:  MOVFF  09,FE2
00090:  MOVFF  0A,FD9
00094:  MOVFF  0B,FDA
00098:  MOVFF  12,FF3
0009C:  MOVFF  13,FF4
000A0:  MOVFF  14,FFA
000A4:  MOVFF  15,FF5
000A8:  MOVFF  16,FF6
000AC:  MOVFF  17,FF7
000B0:  MOVF   04,W
000B2:  MOVFF  06,FE0
000B6:  MOVFF  05,FD8
000BA:  RETFIE 0
.................... #include <main.h>
.................... #include <18F46Q10.h>
.................... //////////// Standard Header file for the PIC18F46Q10 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F46Q10
000BC:  MOVFF  FEC,FFA
000C0:  MOVF   FED,F
000C2:  MOVFF  FEF,FE8
000C6:  MOVWF  FF9
000C8:  RETURN 0
*
00330:  DATA 32,30
00332:  DATA 32,36
00334:  DATA 30,32
00336:  DATA 30,39
00338:  DATA 00,00
0033A:  DATA 30,30
0033C:  DATA 30,30
0033E:  DATA 00,00
00340:  DATA 25,64
00342:  DATA 2C,4D
00344:  DATA 41,4E
00346:  DATA 55,41
00348:  DATA 4C,2C
0034A:  DATA 00,00
0034C:  DATA 25,64
0034E:  DATA 2C,4D
00350:  DATA 41,47
00352:  DATA 53,4E
00354:  DATA 53,2C
00356:  DATA 00,00
00358:  DATA 48,4F
0035A:  DATA 4D,45
0035C:  DATA 2C,25
0035E:  DATA 75,2C
00360:  DATA 25,66
00362:  DATA 3B,00
00364:  DATA 43,4E
00366:  DATA 54,2C
00368:  DATA 25,75
0036A:  DATA 2C,25
0036C:  DATA 2E,30
0036E:  DATA 66,2C
00370:  DATA 25,2E
00372:  DATA 30,66
00374:  DATA 3B,00
00376:  DATA 50,4F
00378:  DATA 53,2C
0037A:  DATA 25,75
0037C:  DATA 2C,25
0037E:  DATA 2E,33
00380:  DATA 66,3B
00382:  DATA 00,00
00384:  DATA 4F,55
00386:  DATA 54,2C
00388:  DATA 25,75
0038A:  DATA 2C,2D
0038C:  DATA 2C,25
0038E:  DATA 4C,75
00390:  DATA 3B,00
00392:  DATA 4F,55
00394:  DATA 54,2C
00396:  DATA 25,75
00398:  DATA 2C,2B
0039A:  DATA 2C,25
0039C:  DATA 4C,75
0039E:  DATA 3B,00
*
006C4:  ADDWF  FE8,W
006C6:  CLRF   FF7
006C8:  RLCF   FF7,F
006CA:  ADDLW  DF
006CC:  MOVWF  FF6
006CE:  MOVLW  06
006D0:  ADDWFC FF7,F
006D2:  TBLRD*-
006D4:  MOVF   FF5,W
006D6:  MOVWF  FFA
006D8:  TBLRD*
006DA:  MOVF   FF5,W
006DC:  MOVWF  FF9
006DE:  DATA 8E,06
006E0:  DATA 98,06
006E2:  DATA A2,06
006E4:  DATA AC,06
*
0086E:  MOVLB  7
00870:  MOVF   x5C,W
00872:  MULWF  x5E
00874:  MOVFF  FF3,01
00878:  MOVFF  FF4,00
0087C:  MULWF  x5F
0087E:  MOVF   FF3,W
00880:  ADDWF  00,F
00882:  MOVF   x5D,W
00884:  MULWF  x5E
00886:  MOVF   FF3,W
00888:  ADDWFC 00,W
0088A:  MOVWF  02
0088C:  MOVLB  0
0088E:  RETURN 0
00890:  MOVLB  7
00892:  MOVF   x60,W
00894:  CLRF   01
00896:  SUBWF  x5F,W
00898:  BC    08A0
0089A:  MOVFF  75F,00
0089E:  BRA    08B8
008A0:  CLRF   00
008A2:  MOVLW  08
008A4:  MOVWF  x61
008A6:  RLCF   x5F,F
008A8:  RLCF   00,F
008AA:  MOVF   x60,W
008AC:  SUBWF  00,W
008AE:  BTFSC  FD8.0
008B0:  MOVWF  00
008B2:  RLCF   01,F
008B4:  DECFSZ x61,F
008B6:  BRA    08A6
008B8:  MOVLB  0
008BA:  RETURN 0
*
00D20:  MOVLB  7
00D22:  MOVF   x38,W
00D24:  ANDLW  07
00D26:  MOVWF  00
00D28:  RRCF   x38,W
00D2A:  MOVWF  01
00D2C:  RRCF   01,F
00D2E:  RRCF   01,F
00D30:  MOVLW  1F
00D32:  ANDWF  01,F
00D34:  MOVF   01,W
00D36:  ADDWF  x3A,W
00D38:  MOVWF  FE9
00D3A:  MOVLW  00
00D3C:  ADDWFC x3B,W
00D3E:  MOVWF  FEA
00D40:  CLRF   01
00D42:  INCF   01,F
00D44:  INCF   00,F
00D46:  BRA    0D4A
00D48:  RLCF   01,F
00D4A:  DECFSZ 00,F
00D4C:  BRA    0D48
00D4E:  MOVF   x39,F
00D50:  BZ    0D58
00D52:  MOVF   01,W
00D54:  IORWF  FEF,F
00D56:  BRA    0D5E
00D58:  COMF   01,F
00D5A:  MOVF   01,W
00D5C:  ANDWF  FEF,F
00D5E:  MOVLB  0
00D60:  RETURN 0
00D62:  MOVFF  76D,774
00D66:  MOVLB  7
00D68:  MOVF   x71,W
00D6A:  XORWF  x74,F
00D6C:  BTFSS  x74.7
00D6E:  BRA    0D7A
00D70:  BCF    FD8.2
00D72:  BCF    FD8.0
00D74:  BTFSC  x6D.7
00D76:  BSF    FD8.0
00D78:  BRA    0DD8
00D7A:  MOVFF  76D,774
00D7E:  MOVFF  770,775
00D82:  MOVF   x6C,W
00D84:  SUBWF  x75,F
00D86:  BZ    0D94
00D88:  BTFSS  x74.7
00D8A:  BRA    0DD8
00D8C:  MOVF   FD8,W
00D8E:  XORLW  01
00D90:  MOVWF  FD8
00D92:  BRA    0DD8
00D94:  MOVFF  771,775
00D98:  MOVF   x6D,W
00D9A:  SUBWF  x75,F
00D9C:  BZ    0DAA
00D9E:  BTFSS  x74.7
00DA0:  BRA    0DD8
00DA2:  MOVF   FD8,W
00DA4:  XORLW  01
00DA6:  MOVWF  FD8
00DA8:  BRA    0DD8
00DAA:  MOVFF  772,775
00DAE:  MOVF   x6E,W
00DB0:  SUBWF  x75,F
00DB2:  BZ    0DC0
00DB4:  BTFSS  x74.7
00DB6:  BRA    0DD8
00DB8:  MOVF   FD8,W
00DBA:  XORLW  01
00DBC:  MOVWF  FD8
00DBE:  BRA    0DD8
00DC0:  MOVFF  773,775
00DC4:  MOVF   x6F,W
00DC6:  SUBWF  x75,F
00DC8:  BZ    0DD6
00DCA:  BTFSS  x74.7
00DCC:  BRA    0DD8
00DCE:  MOVF   FD8,W
00DD0:  XORLW  01
00DD2:  MOVWF  FD8
00DD4:  BRA    0DD8
00DD6:  BCF    FD8.0
00DD8:  MOVLB  0
00DDA:  RETURN 0
00DDC:  MOVLW  80
00DDE:  BTFSS  FD8.1
00DE0:  BRA    0DE6
00DE2:  MOVLB  7
00DE4:  XORWF  x75,F
00DE6:  MOVLB  7
00DE8:  CLRF   x7A
00DEA:  CLRF   x7B
00DEC:  MOVFF  771,779
00DF0:  MOVF   x75,W
00DF2:  XORWF  x79,F
00DF4:  MOVF   x70,W
00DF6:  BTFSC  FD8.2
00DF8:  BRA    0FB8
00DFA:  MOVWF  x78
00DFC:  MOVWF  00
00DFE:  MOVF   x74,W
00E00:  BTFSC  FD8.2
00E02:  BRA    0FCA
00E04:  SUBWF  x78,F
00E06:  BTFSC  FD8.2
00E08:  BRA    0F10
00E0A:  BNC   0E88
00E0C:  MOVFF  775,77E
00E10:  BSF    x7E.7
00E12:  MOVFF  776,77D
00E16:  MOVFF  777,77C
00E1A:  CLRF   x7B
00E1C:  BCF    FD8.0
00E1E:  RRCF   x7E,F
00E20:  RRCF   x7D,F
00E22:  RRCF   x7C,F
00E24:  RRCF   x7B,F
00E26:  DECFSZ x78,F
00E28:  BRA    0E1A
00E2A:  BTFSS  x79.7
00E2C:  BRA    0E34
00E2E:  BSF    x7A.0
00E30:  BRA    0FF2
00E32:  BCF    x7A.0
00E34:  BCF    x78.0
00E36:  BSF    x7A.4
00E38:  MOVLW  07
00E3A:  MOVWF  FEA
00E3C:  MOVLW  73
00E3E:  MOVWF  FE9
00E40:  BRA    1018
00E42:  BCF    x7A.4
00E44:  BTFSC  x79.7
00E46:  BRA    0E5C
00E48:  BTFSS  x78.0
00E4A:  BRA    0E72
00E4C:  RRCF   x7E,F
00E4E:  RRCF   x7D,F
00E50:  RRCF   x7C,F
00E52:  RRCF   x7B,F
00E54:  INCF   00,F
00E56:  BTFSC  FD8.2
00E58:  BRA    0FE8
00E5A:  BRA    0E72
00E5C:  BTFSC  x7E.7
00E5E:  BRA    0E78
00E60:  BCF    FD8.0
00E62:  RLCF   x7B,F
00E64:  RLCF   x7C,F
00E66:  RLCF   x7D,F
00E68:  RLCF   x7E,F
00E6A:  DECF   00,F
00E6C:  BTFSC  FD8.2
00E6E:  BRA    0FE8
00E70:  BRA    0E5C
00E72:  BSF    x7A.6
00E74:  BRA    0F50
00E76:  BCF    x7A.6
00E78:  MOVFF  771,779
00E7C:  BTFSS  x71.7
00E7E:  BRA    0E84
00E80:  BSF    x7E.7
00E82:  BRA    0FDA
00E84:  BCF    x7E.7
00E86:  BRA    0FDA
00E88:  MOVFF  774,778
00E8C:  MOVFF  774,00
00E90:  MOVF   x70,W
00E92:  SUBWF  x78,F
00E94:  MOVFF  771,77E
00E98:  BSF    x7E.7
00E9A:  MOVFF  772,77D
00E9E:  MOVFF  773,77C
00EA2:  CLRF   x7B
00EA4:  BCF    FD8.0
00EA6:  RRCF   x7E,F
00EA8:  RRCF   x7D,F
00EAA:  RRCF   x7C,F
00EAC:  RRCF   x7B,F
00EAE:  DECFSZ x78,F
00EB0:  BRA    0EA2
00EB2:  BTFSS  x79.7
00EB4:  BRA    0EBC
00EB6:  BSF    x7A.1
00EB8:  BRA    0FF2
00EBA:  BCF    x7A.1
00EBC:  BCF    x78.0
00EBE:  BSF    x7A.5
00EC0:  MOVLW  07
00EC2:  MOVWF  FEA
00EC4:  MOVLW  77
00EC6:  MOVWF  FE9
00EC8:  BRA    1018
00ECA:  BCF    x7A.5
00ECC:  BTFSC  x79.7
00ECE:  BRA    0EE4
00ED0:  BTFSS  x78.0
00ED2:  BRA    0EFA
00ED4:  RRCF   x7E,F
00ED6:  RRCF   x7D,F
00ED8:  RRCF   x7C,F
00EDA:  RRCF   x7B,F
00EDC:  INCF   00,F
00EDE:  BTFSC  FD8.2
00EE0:  BRA    0FE8
00EE2:  BRA    0EFA
00EE4:  BTFSC  x7E.7
00EE6:  BRA    0F00
00EE8:  BCF    FD8.0
00EEA:  RLCF   x7B,F
00EEC:  RLCF   x7C,F
00EEE:  RLCF   x7D,F
00EF0:  RLCF   x7E,F
00EF2:  DECF   00,F
00EF4:  BTFSC  FD8.2
00EF6:  BRA    0FE8
00EF8:  BRA    0EE4
00EFA:  BSF    x7A.7
00EFC:  BRA    0F50
00EFE:  BCF    x7A.7
00F00:  MOVFF  775,779
00F04:  BTFSS  x75.7
00F06:  BRA    0F0C
00F08:  BSF    x7E.7
00F0A:  BRA    0FDA
00F0C:  BCF    x7E.7
00F0E:  BRA    0FDA
00F10:  MOVFF  775,77E
00F14:  BSF    x7E.7
00F16:  MOVFF  776,77D
00F1A:  MOVFF  777,77C
00F1E:  BTFSS  x79.7
00F20:  BRA    0F2A
00F22:  BCF    x7E.7
00F24:  BSF    x7A.2
00F26:  BRA    0FF2
00F28:  BCF    x7A.2
00F2A:  CLRF   x7B
00F2C:  BCF    x78.0
00F2E:  MOVLW  07
00F30:  MOVWF  FEA
00F32:  MOVLW  73
00F34:  MOVWF  FE9
00F36:  BRA    1018
00F38:  BTFSC  x79.7
00F3A:  BRA    0F74
00F3C:  MOVFF  771,779
00F40:  BTFSS  x78.0
00F42:  BRA    0F50
00F44:  RRCF   x7E,F
00F46:  RRCF   x7D,F
00F48:  RRCF   x7C,F
00F4A:  RRCF   x7B,F
00F4C:  INCF   00,F
00F4E:  BZ    0FE8
00F50:  BTFSS  x7B.7
00F52:  BRA    0F6A
00F54:  INCF   x7C,F
00F56:  BNZ   0F6A
00F58:  INCF   x7D,F
00F5A:  BNZ   0F6A
00F5C:  INCF   x7E,F
00F5E:  BNZ   0F6A
00F60:  RRCF   x7E,F
00F62:  RRCF   x7D,F
00F64:  RRCF   x7C,F
00F66:  INCF   00,F
00F68:  BZ    0FE8
00F6A:  BTFSC  x7A.6
00F6C:  BRA    0E76
00F6E:  BTFSC  x7A.7
00F70:  BRA    0EFE
00F72:  BRA    0FAC
00F74:  MOVLW  80
00F76:  XORWF  x7E,F
00F78:  BTFSS  x7E.7
00F7A:  BRA    0F84
00F7C:  BRA    0FF2
00F7E:  MOVFF  775,779
00F82:  BRA    0F98
00F84:  MOVFF  771,779
00F88:  MOVF   x7E,F
00F8A:  BNZ   0F98
00F8C:  MOVF   x7D,F
00F8E:  BNZ   0F98
00F90:  MOVF   x7C,F
00F92:  BNZ   0F98
00F94:  CLRF   00
00F96:  BRA    0FDA
00F98:  BTFSC  x7E.7
00F9A:  BRA    0FAC
00F9C:  BCF    FD8.0
00F9E:  RLCF   x7B,F
00FA0:  RLCF   x7C,F
00FA2:  RLCF   x7D,F
00FA4:  RLCF   x7E,F
00FA6:  DECFSZ 00,F
00FA8:  BRA    0F98
00FAA:  BRA    0FE8
00FAC:  BTFSS  x79.7
00FAE:  BRA    0FB4
00FB0:  BSF    x7E.7
00FB2:  BRA    0FDA
00FB4:  BCF    x7E.7
00FB6:  BRA    0FDA
00FB8:  MOVFF  774,00
00FBC:  MOVFF  775,77E
00FC0:  MOVFF  776,77D
00FC4:  MOVFF  777,77C
00FC8:  BRA    0FDA
00FCA:  MOVFF  770,00
00FCE:  MOVFF  771,77E
00FD2:  MOVFF  772,77D
00FD6:  MOVFF  773,77C
00FDA:  MOVFF  77E,01
00FDE:  MOVFF  77D,02
00FE2:  MOVFF  77C,03
00FE6:  BRA    1050
00FE8:  CLRF   00
00FEA:  CLRF   01
00FEC:  CLRF   02
00FEE:  CLRF   03
00FF0:  BRA    1050
00FF2:  CLRF   x7B
00FF4:  COMF   x7C,F
00FF6:  COMF   x7D,F
00FF8:  COMF   x7E,F
00FFA:  COMF   x7B,F
00FFC:  INCF   x7B,F
00FFE:  BNZ   100A
01000:  INCF   x7C,F
01002:  BNZ   100A
01004:  INCF   x7D,F
01006:  BNZ   100A
01008:  INCF   x7E,F
0100A:  BTFSC  x7A.0
0100C:  BRA    0E32
0100E:  BTFSC  x7A.1
01010:  BRA    0EBA
01012:  BTFSC  x7A.2
01014:  BRA    0F28
01016:  BRA    0F7E
01018:  MOVF   FEF,W
0101A:  ADDWF  x7C,F
0101C:  BNC   1028
0101E:  INCF   x7D,F
01020:  BNZ   1028
01022:  INCF   x7E,F
01024:  BTFSC  FD8.2
01026:  BSF    x78.0
01028:  MOVF   FED,F
0102A:  MOVF   FEF,W
0102C:  ADDWF  x7D,F
0102E:  BNC   1036
01030:  INCF   x7E,F
01032:  BTFSC  FD8.2
01034:  BSF    x78.0
01036:  MOVF   FED,F
01038:  MOVF   FEF,W
0103A:  BTFSC  FEF.7
0103C:  BRA    1040
0103E:  XORLW  80
01040:  ADDWF  x7E,F
01042:  BTFSC  FD8.0
01044:  BSF    x78.0
01046:  BTFSC  x7A.4
01048:  BRA    0E42
0104A:  BTFSC  x7A.5
0104C:  BRA    0ECA
0104E:  BRA    0F38
01050:  MOVLB  0
01052:  RETURN 0
01054:  MOVLB  7
01056:  MOVF   x25,W
01058:  ANDLW  07
0105A:  MOVWF  00
0105C:  RRCF   x25,W
0105E:  MOVWF  01
01060:  RRCF   01,F
01062:  RRCF   01,F
01064:  MOVLW  1F
01066:  ANDWF  01,F
01068:  MOVF   01,W
0106A:  ADDWF  x26,W
0106C:  MOVWF  FE9
0106E:  MOVLW  00
01070:  ADDWFC x27,W
01072:  MOVWF  FEA
01074:  MOVFF  FEF,01
01078:  INCF   00,F
0107A:  BRA    107E
0107C:  RRCF   01,F
0107E:  DECFSZ 00,F
01080:  BRA    107C
01082:  MOVLW  01
01084:  ANDWF  01,F
01086:  MOVLB  0
01088:  RETURN 0
*
01116:  MOVLB  7
01118:  MOVF   x6C,W
0111A:  BTFSC  FD8.2
0111C:  BRA    1200
0111E:  MOVWF  00
01120:  MOVF   x70,W
01122:  BTFSC  FD8.2
01124:  BRA    1200
01126:  ADDWF  00,F
01128:  BNC   1132
0112A:  MOVLW  81
0112C:  ADDWF  00,F
0112E:  BC    1200
01130:  BRA    113A
01132:  MOVLW  7F
01134:  SUBWF  00,F
01136:  BNC   1200
01138:  BZ    1200
0113A:  MOVFF  76D,774
0113E:  MOVF   x71,W
01140:  XORWF  x74,F
01142:  BSF    x6D.7
01144:  BSF    x71.7
01146:  MOVF   x6F,W
01148:  MULWF  x73
0114A:  MOVFF  FF4,776
0114E:  MOVF   x6E,W
01150:  MULWF  x72
01152:  MOVFF  FF4,03
01156:  MOVFF  FF3,775
0115A:  MULWF  x73
0115C:  MOVF   FF3,W
0115E:  ADDWF  x76,F
01160:  MOVF   FF4,W
01162:  ADDWFC x75,F
01164:  MOVLW  00
01166:  ADDWFC 03,F
01168:  MOVF   x6F,W
0116A:  MULWF  x72
0116C:  MOVF   FF3,W
0116E:  ADDWF  x76,F
01170:  MOVF   FF4,W
01172:  ADDWFC x75,F
01174:  MOVLW  00
01176:  CLRF   02
01178:  ADDWFC 03,F
0117A:  ADDWFC 02,F
0117C:  MOVF   x6D,W
0117E:  MULWF  x73
01180:  MOVF   FF3,W
01182:  ADDWF  x75,F
01184:  MOVF   FF4,W
01186:  ADDWFC 03,F
01188:  MOVLW  00
0118A:  ADDWFC 02,F
0118C:  MOVF   x6D,W
0118E:  MULWF  x72
01190:  MOVF   FF3,W
01192:  ADDWF  03,F
01194:  MOVF   FF4,W
01196:  ADDWFC 02,F
01198:  MOVLW  00
0119A:  CLRF   01
0119C:  ADDWFC 01,F
0119E:  MOVF   x6F,W
011A0:  MULWF  x71
011A2:  MOVF   FF3,W
011A4:  ADDWF  x75,F
011A6:  MOVF   FF4,W
011A8:  ADDWFC 03,F
011AA:  MOVLW  00
011AC:  ADDWFC 02,F
011AE:  ADDWFC 01,F
011B0:  MOVF   x6E,W
011B2:  MULWF  x71
011B4:  MOVF   FF3,W
011B6:  ADDWF  03,F
011B8:  MOVF   FF4,W
011BA:  ADDWFC 02,F
011BC:  MOVLW  00
011BE:  ADDWFC 01,F
011C0:  MOVF   x6D,W
011C2:  MULWF  x71
011C4:  MOVF   FF3,W
011C6:  ADDWF  02,F
011C8:  MOVF   FF4,W
011CA:  ADDWFC 01,F
011CC:  INCF   00,F
011CE:  BTFSC  01.7
011D0:  BRA    11DC
011D2:  RLCF   x75,F
011D4:  RLCF   03,F
011D6:  RLCF   02,F
011D8:  RLCF   01,F
011DA:  DECF   00,F
011DC:  MOVLW  00
011DE:  BTFSS  x75.7
011E0:  BRA    11F6
011E2:  INCF   03,F
011E4:  ADDWFC 02,F
011E6:  ADDWFC 01,F
011E8:  MOVF   01,W
011EA:  BNZ   11F6
011EC:  MOVF   02,W
011EE:  BNZ   11F6
011F0:  MOVF   03,W
011F2:  BNZ   11F6
011F4:  INCF   00,F
011F6:  BTFSC  x74.7
011F8:  BSF    01.7
011FA:  BTFSS  x74.7
011FC:  BCF    01.7
011FE:  BRA    1208
01200:  CLRF   00
01202:  CLRF   01
01204:  CLRF   02
01206:  CLRF   03
01208:  MOVLB  0
0120A:  RETURN 0
0120C:  MOVLW  8E
0120E:  MOVWF  00
01210:  MOVLB  7
01212:  MOVF   x6C,W
01214:  SUBWF  00,F
01216:  MOVFF  76D,02
0121A:  MOVFF  76E,01
0121E:  BSF    02.7
01220:  MOVF   00,F
01222:  BZ    1236
01224:  BCF    FD8.0
01226:  MOVF   02,F
01228:  BNZ   122E
0122A:  MOVF   01,F
0122C:  BZ    1236
0122E:  RRCF   02,F
01230:  RRCF   01,F
01232:  DECFSZ 00,F
01234:  BRA    1224
01236:  BTFSS  x6D.7
01238:  BRA    1244
0123A:  COMF   01,F
0123C:  COMF   02,F
0123E:  INCF   01,F
01240:  BTFSC  FD8.2
01242:  INCF   02,F
01244:  MOVLB  0
01246:  RETURN 0
*
01D8E:  BTFSC  FD8.1
01D90:  BRA    1D9A
01D92:  MOVLW  07
01D94:  MOVWF  FEA
01D96:  MOVLW  5F
01D98:  MOVWF  FE9
01D9A:  MOVLB  7
01D9C:  MOVF   x5A,W
01D9E:  XORWF  x5E,W
01DA0:  ANDLW  80
01DA2:  MOVWF  x64
01DA4:  BTFSS  x5A.7
01DA6:  BRA    1DBE
01DA8:  COMF   x57,F
01DAA:  COMF   x58,F
01DAC:  COMF   x59,F
01DAE:  COMF   x5A,F
01DB0:  INCF   x57,F
01DB2:  BTFSC  FD8.2
01DB4:  INCF   x58,F
01DB6:  BTFSC  FD8.2
01DB8:  INCF   x59,F
01DBA:  BTFSC  FD8.2
01DBC:  INCF   x5A,F
01DBE:  BTFSS  x5E.7
01DC0:  BRA    1DD8
01DC2:  COMF   x5B,F
01DC4:  COMF   x5C,F
01DC6:  COMF   x5D,F
01DC8:  COMF   x5E,F
01DCA:  INCF   x5B,F
01DCC:  BTFSC  FD8.2
01DCE:  INCF   x5C,F
01DD0:  BTFSC  FD8.2
01DD2:  INCF   x5D,F
01DD4:  BTFSC  FD8.2
01DD6:  INCF   x5E,F
01DD8:  CLRF   00
01DDA:  CLRF   01
01DDC:  CLRF   02
01DDE:  CLRF   03
01DE0:  CLRF   x5F
01DE2:  CLRF   x60
01DE4:  CLRF   x61
01DE6:  CLRF   x62
01DE8:  MOVF   x5E,W
01DEA:  IORWF  x5D,W
01DEC:  IORWF  x5C,W
01DEE:  IORWF  x5B,W
01DF0:  BZ    1E4A
01DF2:  MOVLW  20
01DF4:  MOVWF  x63
01DF6:  BCF    FD8.0
01DF8:  RLCF   x57,F
01DFA:  RLCF   x58,F
01DFC:  RLCF   x59,F
01DFE:  RLCF   x5A,F
01E00:  RLCF   x5F,F
01E02:  RLCF   x60,F
01E04:  RLCF   x61,F
01E06:  RLCF   x62,F
01E08:  MOVF   x5E,W
01E0A:  SUBWF  x62,W
01E0C:  BNZ   1E1E
01E0E:  MOVF   x5D,W
01E10:  SUBWF  x61,W
01E12:  BNZ   1E1E
01E14:  MOVF   x5C,W
01E16:  SUBWF  x60,W
01E18:  BNZ   1E1E
01E1A:  MOVF   x5B,W
01E1C:  SUBWF  x5F,W
01E1E:  BNC   1E3E
01E20:  MOVF   x5B,W
01E22:  SUBWF  x5F,F
01E24:  MOVF   x5C,W
01E26:  BTFSS  FD8.0
01E28:  INCFSZ x5C,W
01E2A:  SUBWF  x60,F
01E2C:  MOVF   x5D,W
01E2E:  BTFSS  FD8.0
01E30:  INCFSZ x5D,W
01E32:  SUBWF  x61,F
01E34:  MOVF   x5E,W
01E36:  BTFSS  FD8.0
01E38:  INCFSZ x5E,W
01E3A:  SUBWF  x62,F
01E3C:  BSF    FD8.0
01E3E:  RLCF   00,F
01E40:  RLCF   01,F
01E42:  RLCF   02,F
01E44:  RLCF   03,F
01E46:  DECFSZ x63,F
01E48:  BRA    1DF6
01E4A:  BTFSS  x64.7
01E4C:  BRA    1E64
01E4E:  COMF   00,F
01E50:  COMF   01,F
01E52:  COMF   02,F
01E54:  COMF   03,F
01E56:  INCF   00,F
01E58:  BTFSC  FD8.2
01E5A:  INCF   01,F
01E5C:  BTFSC  FD8.2
01E5E:  INCF   02,F
01E60:  BTFSC  FD8.2
01E62:  INCF   03,F
01E64:  MOVFF  75F,FEF
01E68:  MOVFF  760,FEC
01E6C:  MOVFF  761,FEC
01E70:  MOVFF  762,FEC
01E74:  MOVLB  0
01E76:  RETURN 0
*
023D4:  MOVLW  B6
023D6:  MOVWF  00
023D8:  CLRF   03
023DA:  CLRF   02
023DC:  CLRF   01
023DE:  MOVLB  7
023E0:  BCF    x3A.0
023E2:  BTFSS  x39.7
023E4:  BRA    23FE
023E6:  BSF    x3A.0
023E8:  COMF   x36,F
023EA:  COMF   x37,F
023EC:  COMF   x38,F
023EE:  COMF   x39,F
023F0:  INCF   x36,F
023F2:  BNZ   23FE
023F4:  INCF   x37,F
023F6:  BNZ   23FE
023F8:  INCF   x38,F
023FA:  BTFSC  FD8.2
023FC:  INCF   x39,F
023FE:  MOVF   x36,W
02400:  IORWF  x37,W
02402:  IORWF  x38,W
02404:  IORWF  x39,W
02406:  BNZ   240C
02408:  CLRF   00
0240A:  BRA    242A
0240C:  BCF    FD8.0
0240E:  BTFSC  01.7
02410:  BRA    2424
02412:  RLCF   x36,F
02414:  RLCF   x37,F
02416:  RLCF   x38,F
02418:  RLCF   x39,F
0241A:  RLCF   03,F
0241C:  RLCF   02,F
0241E:  RLCF   01,F
02420:  DECFSZ 00,F
02422:  BRA    240C
02424:  BCF    01.7
02426:  BTFSC  x3A.0
02428:  BSF    01.7
0242A:  MOVLB  0
0242C:  RETURN 0
0242E:  MOVLB  7
02430:  MOVF   x65,W
02432:  BTFSC  FD8.2
02434:  BRA    2580
02436:  MOVWF  x71
02438:  MOVF   x69,W
0243A:  BTFSC  FD8.2
0243C:  BRA    2580
0243E:  SUBWF  x71,F
02440:  BNC   244C
02442:  MOVLW  7F
02444:  ADDWF  x71,F
02446:  BTFSC  FD8.0
02448:  BRA    2580
0244A:  BRA    2458
0244C:  MOVLW  81
0244E:  SUBWF  x71,F
02450:  BTFSS  FD8.0
02452:  BRA    2580
02454:  BTFSC  FD8.2
02456:  BRA    2580
02458:  MOVFF  771,00
0245C:  CLRF   01
0245E:  CLRF   02
02460:  CLRF   03
02462:  CLRF   x70
02464:  MOVFF  766,76F
02468:  BSF    x6F.7
0246A:  MOVFF  767,76E
0246E:  MOVFF  768,76D
02472:  MOVLW  19
02474:  MOVWF  x71
02476:  MOVF   x6C,W
02478:  SUBWF  x6D,F
0247A:  BC    2496
0247C:  MOVLW  01
0247E:  SUBWF  x6E,F
02480:  BC    2496
02482:  SUBWF  x6F,F
02484:  BC    2496
02486:  SUBWF  x70,F
02488:  BC    2496
0248A:  INCF   x70,F
0248C:  INCF   x6F,F
0248E:  INCF   x6E,F
02490:  MOVF   x6C,W
02492:  ADDWF  x6D,F
02494:  BRA    24E6
02496:  MOVF   x6B,W
02498:  SUBWF  x6E,F
0249A:  BC    24C0
0249C:  MOVLW  01
0249E:  SUBWF  x6F,F
024A0:  BC    24C0
024A2:  SUBWF  x70,F
024A4:  BC    24C0
024A6:  INCF   x70,F
024A8:  INCF   x6F,F
024AA:  MOVF   x6B,W
024AC:  ADDWF  x6E,F
024AE:  MOVF   x6C,W
024B0:  ADDWF  x6D,F
024B2:  BNC   24E6
024B4:  INCF   x6E,F
024B6:  BNZ   24E6
024B8:  INCF   x6F,F
024BA:  BNZ   24E6
024BC:  INCF   x70,F
024BE:  BRA    24E6
024C0:  MOVF   x6A,W
024C2:  IORLW  80
024C4:  SUBWF  x6F,F
024C6:  BC    24E4
024C8:  MOVLW  01
024CA:  SUBWF  x70,F
024CC:  BC    24E4
024CE:  INCF   x70,F
024D0:  MOVF   x6A,W
024D2:  IORLW  80
024D4:  ADDWF  x6F,F
024D6:  MOVF   x6B,W
024D8:  ADDWF  x6E,F
024DA:  BNC   24AE
024DC:  INCF   x6F,F
024DE:  BNZ   24AE
024E0:  INCF   x70,F
024E2:  BRA    24AE
024E4:  BSF    03.0
024E6:  DECFSZ x71,F
024E8:  BRA    24EC
024EA:  BRA    2502
024EC:  BCF    FD8.0
024EE:  RLCF   x6D,F
024F0:  RLCF   x6E,F
024F2:  RLCF   x6F,F
024F4:  RLCF   x70,F
024F6:  BCF    FD8.0
024F8:  RLCF   03,F
024FA:  RLCF   02,F
024FC:  RLCF   01,F
024FE:  RLCF   x72,F
02500:  BRA    2476
02502:  BTFSS  x72.0
02504:  BRA    2512
02506:  BCF    FD8.0
02508:  RRCF   01,F
0250A:  RRCF   02,F
0250C:  RRCF   03,F
0250E:  RRCF   x72,F
02510:  BRA    2516
02512:  DECF   00,F
02514:  BZ    2580
02516:  BTFSC  x72.7
02518:  BRA    2556
0251A:  BCF    FD8.0
0251C:  RLCF   x6D,F
0251E:  RLCF   x6E,F
02520:  RLCF   x6F,F
02522:  RLCF   x70,F
02524:  MOVF   x6C,W
02526:  SUBWF  x6D,F
02528:  BC    2538
0252A:  MOVLW  01
0252C:  SUBWF  x6E,F
0252E:  BC    2538
02530:  SUBWF  x6F,F
02532:  BC    2538
02534:  SUBWF  x70,F
02536:  BNC   256C
02538:  MOVF   x6B,W
0253A:  SUBWF  x6E,F
0253C:  BC    2548
0253E:  MOVLW  01
02540:  SUBWF  x6F,F
02542:  BC    2548
02544:  SUBWF  x70,F
02546:  BNC   256C
02548:  MOVF   x6A,W
0254A:  IORLW  80
0254C:  SUBWF  x6F,F
0254E:  BC    2556
02550:  MOVLW  01
02552:  SUBWF  x70,F
02554:  BNC   256C
02556:  INCF   03,F
02558:  BNZ   256C
0255A:  INCF   02,F
0255C:  BNZ   256C
0255E:  INCF   01,F
02560:  BNZ   256C
02562:  INCF   00,F
02564:  BZ    2580
02566:  RRCF   01,F
02568:  RRCF   02,F
0256A:  RRCF   03,F
0256C:  MOVFF  766,771
02570:  MOVF   x6A,W
02572:  XORWF  x71,F
02574:  BTFSS  x71.7
02576:  BRA    257C
02578:  BSF    01.7
0257A:  BRA    2588
0257C:  BCF    01.7
0257E:  BRA    2588
02580:  CLRF   00
02582:  CLRF   01
02584:  CLRF   02
02586:  CLRF   03
02588:  MOVLB  0
0258A:  RETURN 0
*
02D46:  ADDWF  FE8,W
02D48:  CLRF   FF7
02D4A:  RLCF   FF7,F
02D4C:  ADDLW  61
02D4E:  MOVWF  FF6
02D50:  MOVLW  2D
02D52:  ADDWFC FF7,F
02D54:  TBLRD*-
02D56:  MOVF   FF5,W
02D58:  MOVWF  FFA
02D5A:  TBLRD*
02D5C:  MOVF   FF5,W
02D5E:  MOVWF  FF9
02D60:  DATA 4E,2C
02D62:  DATA 68,2C
02D64:  DATA BC,2C
02D66:  DATA 20,2D
02D68:  MOVLW  8E
02D6A:  MOVWF  00
02D6C:  MOVFF  763,01
02D70:  MOVFF  762,02
02D74:  CLRF   03
02D76:  BTFSS  01.7
02D78:  BRA    2D84
02D7A:  COMF   01,F
02D7C:  COMF   02,F
02D7E:  INCF   02,F
02D80:  BNZ   2D84
02D82:  INCF   01,F
02D84:  MOVF   01,F
02D86:  BNZ   2D9A
02D88:  MOVFF  02,01
02D8C:  CLRF   02
02D8E:  MOVLW  08
02D90:  SUBWF  00,F
02D92:  MOVF   01,F
02D94:  BNZ   2D9A
02D96:  CLRF   00
02D98:  BRA    2DB6
02D9A:  BCF    FD8.0
02D9C:  BTFSC  01.7
02D9E:  BRA    2DA8
02DA0:  RLCF   02,F
02DA2:  RLCF   01,F
02DA4:  DECF   00,F
02DA6:  BRA    2D9A
02DA8:  MOVLB  7
02DAA:  BTFSS  x63.7
02DAC:  BRA    2DB2
02DAE:  MOVLB  0
02DB0:  BRA    2DB6
02DB2:  BCF    01.7
02DB4:  MOVLB  0
02DB6:  RETURN 0
02DB8:  MOVLW  8E
02DBA:  MOVWF  00
02DBC:  MOVFF  771,01
02DC0:  MOVFF  770,02
02DC4:  CLRF   03
02DC6:  MOVF   01,F
02DC8:  BNZ   2DDC
02DCA:  MOVFF  02,01
02DCE:  CLRF   02
02DD0:  MOVLW  08
02DD2:  SUBWF  00,F
02DD4:  MOVF   01,F
02DD6:  BNZ   2DDC
02DD8:  CLRF   00
02DDA:  BRA    2DEC
02DDC:  BCF    FD8.0
02DDE:  BTFSC  01.7
02DE0:  BRA    2DEA
02DE2:  RLCF   02,F
02DE4:  RLCF   01,F
02DE6:  DECF   00,F
02DE8:  BRA    2DDC
02DEA:  BCF    01.7
02DEC:  RETURN 0
*
05606:  ADDWF  FE8,W
05608:  CLRF   FF7
0560A:  RLCF   FF7,F
0560C:  ADDLW  21
0560E:  MOVWF  FF6
05610:  MOVLW  56
05612:  ADDWFC FF7,F
05614:  TBLRD*-
05616:  MOVF   FF5,W
05618:  MOVWF  FFA
0561A:  TBLRD*
0561C:  MOVF   FF5,W
0561E:  MOVWF  FF9
05620:  DATA A2,50
05622:  DATA 68,51
05624:  DATA 2E,52
05626:  DATA F4,52
05628:  DATA BA,53
0562A:  DATA 80,54
0562C:  DATA 46,55
*
056B2:  MOVF   FEF,F
056B4:  BZ    56DA
056B6:  MOVFF  FEA,71A
056BA:  MOVFF  FE9,719
056BE:  MOVF   FEF,W
056C0:  MOVLB  E
056C2:  BTFSS  xC8.4
056C4:  BRA    56C2
056C6:  MOVWF  F99
056C8:  MOVFF  71A,FEA
056CC:  MOVFF  719,FE9
056D0:  INCF   FE9,F
056D2:  BTFSC  FD8.2
056D4:  INCF   FEA,F
056D6:  MOVLB  0
056D8:  BRA    56B2
056DA:  GOTO   56FA (RETURN)
*
05CB6:  MOVFF  565,FEA
05CBA:  MOVFF  564,FE9
05CBE:  MOVFF  766,FEF
05CC2:  INCF   FE9,F
05CC4:  BTFSC  FD8.2
05CC6:  INCF   FEA,F
05CC8:  CLRF   FEF
05CCA:  MOVLB  5
05CCC:  INCF   x64,F
05CCE:  BTFSC  FD8.2
05CD0:  INCF   x65,F
05CD2:  MOVLB  0
05CD4:  RETURN 0
05CD6:  MOVF   FEF,F
05CD8:  BZ    5CF8
05CDA:  MOVFF  FEA,71E
05CDE:  MOVFF  FE9,71D
05CE2:  MOVFF  FEF,766
05CE6:  RCALL  5CB6
05CE8:  MOVFF  71E,FEA
05CEC:  MOVFF  71D,FE9
05CF0:  INCF   FE9,F
05CF2:  BTFSC  FD8.2
05CF4:  INCF   FEA,F
05CF6:  BRA    5CD6
05CF8:  RETURN 0
*
05DAC:  TBLRD*+
05DAE:  MOVF   FF5,F
05DB0:  BZ    5DCA
05DB2:  MOVFF  FF6,724
05DB6:  MOVFF  FF7,725
05DBA:  MOVFF  FF5,766
05DBE:  RCALL  5CB6
05DC0:  MOVFF  724,FF6
05DC4:  MOVFF  725,FF7
05DC8:  BRA    5DAC
05DCA:  RETURN 0
*
05EF8:  MOVLB  7
05EFA:  MOVF   x7E,W
05EFC:  XORWF  x80,W
05EFE:  ANDLW  80
05F00:  MOVWF  x82
05F02:  BTFSS  x7E.7
05F04:  BRA    5F10
05F06:  COMF   x7D,F
05F08:  COMF   x7E,F
05F0A:  INCF   x7D,F
05F0C:  BTFSC  FD8.2
05F0E:  INCF   x7E,F
05F10:  BTFSS  x80.7
05F12:  BRA    5F1E
05F14:  COMF   x7F,F
05F16:  COMF   x80,F
05F18:  INCF   x7F,F
05F1A:  BTFSC  FD8.2
05F1C:  INCF   x80,F
05F1E:  MOVF   x7D,W
05F20:  MULWF  x7F
05F22:  MOVFF  FF3,01
05F26:  MOVFF  FF4,00
05F2A:  MULWF  x80
05F2C:  MOVF   FF3,W
05F2E:  ADDWF  00,F
05F30:  MOVF   x7E,W
05F32:  MULWF  x7F
05F34:  MOVF   FF3,W
05F36:  ADDWFC 00,W
05F38:  MOVWF  02
05F3A:  BTFSS  x82.7
05F3C:  BRA    5F48
05F3E:  COMF   01,F
05F40:  COMF   02,F
05F42:  INCF   01,F
05F44:  BTFSC  FD8.2
05F46:  INCF   02,F
05F48:  MOVLB  0
05F4A:  GOTO   61DE (RETURN)
*
062A2:  MOVLW  20
062A4:  MOVLB  7
062A6:  BTFSS  x4B.4
062A8:  MOVLW  30
062AA:  MOVWF  x4C
062AC:  MOVFF  74A,00
062B0:  BTFSS  00.7
062B2:  BRA    62C4
062B4:  COMF   00,F
062B6:  INCF   00,F
062B8:  MOVFF  00,74A
062BC:  MOVLW  2D
062BE:  MOVWF  x4C
062C0:  BSF    x4B.7
062C2:  BSF    x4B.0
062C4:  MOVF   01,W
062C6:  MOVFF  74A,75F
062CA:  MOVLW  64
062CC:  MOVWF  x60
062CE:  MOVLB  0
062D0:  CALL   0890
062D4:  MOVFF  00,74A
062D8:  MOVLW  30
062DA:  ADDWF  01,W
062DC:  MOVLB  7
062DE:  MOVWF  x4D
062E0:  MOVFF  74A,75F
062E4:  MOVLW  0A
062E6:  MOVWF  x60
062E8:  MOVLB  0
062EA:  CALL   0890
062EE:  MOVLW  30
062F0:  ADDWF  00,W
062F2:  MOVLB  7
062F4:  MOVWF  x4F
062F6:  MOVLW  30
062F8:  ADDWF  01,W
062FA:  MOVWF  x4E
062FC:  MOVFF  74C,00
06300:  MOVLW  30
06302:  SUBWF  x4D,W
06304:  BZ    630E
06306:  BSF    x4B.1
06308:  BTFSC  x4B.7
0630A:  BSF    x4B.2
0630C:  BRA    6332
0630E:  MOVFF  74C,74D
06312:  MOVLW  20
06314:  MOVWF  x4C
06316:  MOVLW  30
06318:  SUBWF  x4E,W
0631A:  BZ    6324
0631C:  BSF    x4B.0
0631E:  BTFSC  x4B.7
06320:  BSF    x4B.1
06322:  BRA    6332
06324:  BTFSS  FD8.2
06326:  BSF    x4B.0
06328:  BNZ   6332
0632A:  MOVFF  74D,74E
0632E:  MOVLW  20
06330:  MOVWF  x4D
06332:  BTFSC  x4B.2
06334:  BRA    6340
06336:  BTFSC  x4B.1
06338:  BRA    6348
0633A:  BTFSC  x4B.0
0633C:  BRA    6350
0633E:  BRA    6358
06340:  MOVFF  74C,766
06344:  MOVLB  0
06346:  RCALL  5CB6
06348:  MOVFF  74D,766
0634C:  MOVLB  0
0634E:  RCALL  5CB6
06350:  MOVFF  74E,766
06354:  MOVLB  0
06356:  RCALL  5CB6
06358:  MOVFF  74F,766
0635C:  MOVLB  0
0635E:  RCALL  5CB6
06360:  RETURN 0
*
066B8:  TBLRD*+
066BA:  MOVFF  FF6,72F
066BE:  MOVFF  FF7,730
066C2:  MOVFF  FF5,766
066C6:  CALL   5CB6
066CA:  MOVFF  72F,FF6
066CE:  MOVFF  730,FF7
066D2:  MOVLB  7
066D4:  DECFSZ x2E,F
066D6:  BRA    66DA
066D8:  BRA    66DE
066DA:  MOVLB  0
066DC:  BRA    66B8
066DE:  MOVLB  0
066E0:  RETURN 0
*
06A8C:  MOVLB  7
06A8E:  MOVF   x66,W
06A90:  SUBLW  B6
06A92:  MOVWF  x66
06A94:  CLRF   03
06A96:  MOVFF  767,76A
06A9A:  BSF    x67.7
06A9C:  BCF    FD8.0
06A9E:  RRCF   x67,F
06AA0:  RRCF   x68,F
06AA2:  RRCF   x69,F
06AA4:  RRCF   03,F
06AA6:  RRCF   02,F
06AA8:  RRCF   01,F
06AAA:  RRCF   00,F
06AAC:  DECFSZ x66,F
06AAE:  BRA    6A9C
06AB0:  BTFSS  x6A.7
06AB2:  BRA    6ACA
06AB4:  COMF   00,F
06AB6:  COMF   01,F
06AB8:  COMF   02,F
06ABA:  COMF   03,F
06ABC:  INCF   00,F
06ABE:  BTFSC  FD8.2
06AC0:  INCF   01,F
06AC2:  BTFSC  FD8.2
06AC4:  INCF   02,F
06AC6:  BTFSC  FD8.2
06AC8:  INCF   03,F
06ACA:  MOVLB  0
06ACC:  RETURN 0
06ACE:  BTFSC  FD8.1
06AD0:  BRA    6ADA
06AD2:  MOVLW  07
06AD4:  MOVWF  FEA
06AD6:  MOVLW  6E
06AD8:  MOVWF  FE9
06ADA:  CLRF   00
06ADC:  CLRF   01
06ADE:  CLRF   02
06AE0:  CLRF   03
06AE2:  MOVLB  7
06AE4:  CLRF   x6E
06AE6:  CLRF   x6F
06AE8:  CLRF   x70
06AEA:  CLRF   x71
06AEC:  MOVF   x6D,W
06AEE:  IORWF  x6C,W
06AF0:  IORWF  x6B,W
06AF2:  IORWF  x6A,W
06AF4:  BZ    6B4E
06AF6:  MOVLW  20
06AF8:  MOVWF  x72
06AFA:  BCF    FD8.0
06AFC:  RLCF   x66,F
06AFE:  RLCF   x67,F
06B00:  RLCF   x68,F
06B02:  RLCF   x69,F
06B04:  RLCF   x6E,F
06B06:  RLCF   x6F,F
06B08:  RLCF   x70,F
06B0A:  RLCF   x71,F
06B0C:  MOVF   x6D,W
06B0E:  SUBWF  x71,W
06B10:  BNZ   6B22
06B12:  MOVF   x6C,W
06B14:  SUBWF  x70,W
06B16:  BNZ   6B22
06B18:  MOVF   x6B,W
06B1A:  SUBWF  x6F,W
06B1C:  BNZ   6B22
06B1E:  MOVF   x6A,W
06B20:  SUBWF  x6E,W
06B22:  BNC   6B42
06B24:  MOVF   x6A,W
06B26:  SUBWF  x6E,F
06B28:  MOVF   x6B,W
06B2A:  BTFSS  FD8.0
06B2C:  INCFSZ x6B,W
06B2E:  SUBWF  x6F,F
06B30:  MOVF   x6C,W
06B32:  BTFSS  FD8.0
06B34:  INCFSZ x6C,W
06B36:  SUBWF  x70,F
06B38:  MOVF   x6D,W
06B3A:  BTFSS  FD8.0
06B3C:  INCFSZ x6D,W
06B3E:  SUBWF  x71,F
06B40:  BSF    FD8.0
06B42:  RLCF   00,F
06B44:  RLCF   01,F
06B46:  RLCF   02,F
06B48:  RLCF   03,F
06B4A:  DECFSZ x72,F
06B4C:  BRA    6AFA
06B4E:  MOVFF  76E,FEF
06B52:  MOVFF  76F,FEC
06B56:  MOVFF  770,FEC
06B5A:  MOVFF  771,FEC
06B5E:  MOVLB  0
06B60:  RETURN 0
06B62:  MOVF   FE9,W
06B64:  MOVLB  7
06B66:  MOVWF  x5E
06B68:  MOVF   x5D,W
06B6A:  MOVWF  x60
06B6C:  BZ    6BA6
06B6E:  MOVFF  75C,76F
06B72:  MOVFF  75B,76E
06B76:  MOVFF  75A,76D
06B7A:  MOVFF  759,76C
06B7E:  CLRF   x73
06B80:  CLRF   x72
06B82:  MOVLW  20
06B84:  MOVWF  x71
06B86:  MOVLW  82
06B88:  MOVWF  x70
06B8A:  MOVLB  0
06B8C:  CALL   1116
06B90:  MOVFF  03,75C
06B94:  MOVFF  02,75B
06B98:  MOVFF  01,75A
06B9C:  MOVFF  00,759
06BA0:  MOVLB  7
06BA2:  DECFSZ x60,F
06BA4:  BRA    6B6E
06BA6:  MOVFF  75C,769
06BAA:  MOVFF  75B,768
06BAE:  MOVFF  75A,767
06BB2:  MOVFF  759,766
06BB6:  MOVLB  0
06BB8:  RCALL  6A8C
06BBA:  MOVFF  03,75C
06BBE:  MOVFF  02,75B
06BC2:  MOVFF  01,75A
06BC6:  MOVFF  00,759
06BCA:  MOVLB  7
06BCC:  BTFSS  x5C.7
06BCE:  BRA    6BEA
06BD0:  DECF   x5E,F
06BD2:  BSF    x5E.5
06BD4:  COMF   x59,F
06BD6:  COMF   x5A,F
06BD8:  COMF   x5B,F
06BDA:  COMF   x5C,F
06BDC:  INCF   x59,F
06BDE:  BTFSC  FD8.2
06BE0:  INCF   x5A,F
06BE2:  BTFSC  FD8.2
06BE4:  INCF   x5B,F
06BE6:  BTFSC  FD8.2
06BE8:  INCF   x5C,F
06BEA:  MOVLW  3B
06BEC:  MOVWF  x65
06BEE:  MOVLW  9A
06BF0:  MOVWF  x64
06BF2:  MOVLW  CA
06BF4:  MOVWF  x63
06BF6:  CLRF   x62
06BF8:  MOVLW  0A
06BFA:  MOVWF  x60
06BFC:  MOVF   x5D,W
06BFE:  BTFSC  FD8.2
06C00:  INCF   x5E,F
06C02:  BSF    FD8.1
06C04:  MOVLW  07
06C06:  MOVWF  FEA
06C08:  MOVLW  59
06C0A:  MOVWF  FE9
06C0C:  MOVFF  75C,769
06C10:  MOVFF  75B,768
06C14:  MOVFF  75A,767
06C18:  MOVFF  759,766
06C1C:  MOVFF  765,76D
06C20:  MOVFF  764,76C
06C24:  MOVFF  763,76B
06C28:  MOVFF  762,76A
06C2C:  MOVLB  0
06C2E:  RCALL  6ACE
06C30:  MOVF   01,W
06C32:  MOVF   00,F
06C34:  BNZ   6C5C
06C36:  MOVLB  7
06C38:  INCF   x5D,W
06C3A:  SUBWF  x60,W
06C3C:  BTFSS  FD8.2
06C3E:  BRA    6C44
06C40:  MOVLB  0
06C42:  BRA    6C5C
06C44:  MOVF   x5E,W
06C46:  BZ    6C62
06C48:  ANDLW  0F
06C4A:  SUBWF  x60,W
06C4C:  BZ    6C50
06C4E:  BC    6CD8
06C50:  BTFSC  x5E.7
06C52:  BRA    6CD8
06C54:  BTFSC  x5E.6
06C56:  BRA    6C62
06C58:  MOVLW  20
06C5A:  BRA    6CCA
06C5C:  MOVLW  20
06C5E:  MOVLB  7
06C60:  ANDWF  x5E,F
06C62:  BTFSS  x5E.5
06C64:  BRA    6C84
06C66:  BCF    x5E.5
06C68:  MOVF   x5D,W
06C6A:  BTFSS  FD8.2
06C6C:  DECF   x5E,F
06C6E:  MOVF   00,W
06C70:  MOVWF  x5E
06C72:  MOVLW  2D
06C74:  MOVWF  x66
06C76:  MOVLB  0
06C78:  CALL   5CB6
06C7C:  MOVLB  7
06C7E:  MOVF   x5E,W
06C80:  MOVWF  00
06C82:  CLRF   x5E
06C84:  MOVF   x5D,W
06C86:  SUBWF  x60,W
06C88:  BNZ   6CA4
06C8A:  MOVF   00,W
06C8C:  MOVWF  x5E
06C8E:  MOVLW  2E
06C90:  MOVWF  x66
06C92:  MOVLB  0
06C94:  CALL   5CB6
06C98:  MOVLB  7
06C9A:  MOVF   x5E,W
06C9C:  MOVWF  00
06C9E:  MOVLW  20
06CA0:  ANDWF  x5E,F
06CA2:  MOVLW  00
06CA4:  MOVLW  30
06CA6:  BTFSS  x5E.5
06CA8:  BRA    6CCA
06CAA:  BCF    x5E.5
06CAC:  MOVF   x5D,W
06CAE:  BTFSS  FD8.2
06CB0:  DECF   x5E,F
06CB2:  MOVF   00,W
06CB4:  MOVWF  x5E
06CB6:  MOVLW  2D
06CB8:  MOVWF  x66
06CBA:  MOVLB  0
06CBC:  CALL   5CB6
06CC0:  MOVLB  7
06CC2:  MOVF   x5E,W
06CC4:  MOVWF  00
06CC6:  CLRF   x5E
06CC8:  MOVLW  30
06CCA:  ADDWF  00,F
06CCC:  MOVFF  00,766
06CD0:  MOVLB  0
06CD2:  CALL   5CB6
06CD6:  MOVLB  7
06CD8:  BCF    FD8.1
06CDA:  MOVFF  765,769
06CDE:  MOVFF  764,768
06CE2:  MOVFF  763,767
06CE6:  MOVFF  762,766
06CEA:  CLRF   x6D
06CEC:  CLRF   x6C
06CEE:  CLRF   x6B
06CF0:  MOVLW  0A
06CF2:  MOVWF  x6A
06CF4:  MOVLB  0
06CF6:  RCALL  6ACE
06CF8:  MOVFF  03,765
06CFC:  MOVFF  02,764
06D00:  MOVFF  01,763
06D04:  MOVFF  00,762
06D08:  MOVLB  7
06D0A:  DECFSZ x60,F
06D0C:  BRA    6C02
06D0E:  MOVLB  0
06D10:  RETURN 0
*
0977A:  MOVF   FE9,W
0977C:  MOVLB  7
0977E:  MOVWF  x53
09780:  BTFSS  x52.7
09782:  BRA    979E
09784:  DECF   x53,F
09786:  BSF    x53.5
09788:  COMF   x4F,F
0978A:  COMF   x50,F
0978C:  COMF   x51,F
0978E:  COMF   x52,F
09790:  INCF   x4F,F
09792:  BTFSC  FD8.2
09794:  INCF   x50,F
09796:  BTFSC  FD8.2
09798:  INCF   x51,F
0979A:  BTFSC  FD8.2
0979C:  INCF   x52,F
0979E:  MOVLW  3B
097A0:  MOVWF  x5A
097A2:  MOVLW  9A
097A4:  MOVWF  x59
097A6:  MOVLW  CA
097A8:  MOVWF  x58
097AA:  CLRF   x57
097AC:  MOVLW  0A
097AE:  MOVWF  x55
097B0:  BSF    FD8.1
097B2:  MOVLW  07
097B4:  MOVWF  FEA
097B6:  MOVLW  4F
097B8:  MOVWF  FE9
097BA:  MOVFF  752,769
097BE:  MOVFF  751,768
097C2:  MOVFF  750,767
097C6:  MOVFF  74F,766
097CA:  MOVFF  75A,76D
097CE:  MOVFF  759,76C
097D2:  MOVFF  758,76B
097D6:  MOVFF  757,76A
097DA:  MOVLB  0
097DC:  CALL   6ACE
097E0:  MOVF   01,W
097E2:  MOVF   00,F
097E4:  BNZ   980C
097E6:  MOVLB  7
097E8:  MOVF   x55,W
097EA:  XORLW  01
097EC:  BTFSS  FD8.2
097EE:  BRA    97F4
097F0:  MOVLB  0
097F2:  BRA    980C
097F4:  MOVF   x53,W
097F6:  BZ    9812
097F8:  ANDLW  0F
097FA:  SUBWF  x55,W
097FC:  BZ    9800
097FE:  BC    985C
09800:  BTFSC  x53.7
09802:  BRA    985C
09804:  BTFSC  x53.6
09806:  BRA    9812
09808:  MOVLW  20
0980A:  BRA    984E
0980C:  MOVLW  20
0980E:  MOVLB  7
09810:  ANDWF  x53,F
09812:  BTFSS  x53.5
09814:  BRA    982E
09816:  BCF    x53.5
09818:  MOVFF  00,753
0981C:  MOVLW  2D
0981E:  MOVWF  x66
09820:  MOVLB  0
09822:  CALL   5CB6
09826:  MOVLB  7
09828:  MOVFF  753,00
0982C:  CLRF   x53
0982E:  MOVLW  30
09830:  BTFSS  x53.5
09832:  BRA    984E
09834:  BCF    x53.5
09836:  MOVFF  00,753
0983A:  MOVLW  2D
0983C:  MOVWF  x66
0983E:  MOVLB  0
09840:  CALL   5CB6
09844:  MOVLB  7
09846:  MOVFF  753,00
0984A:  CLRF   x53
0984C:  MOVLW  30
0984E:  ADDWF  00,F
09850:  MOVFF  00,766
09854:  MOVLB  0
09856:  CALL   5CB6
0985A:  MOVLB  7
0985C:  BCF    FD8.1
0985E:  MOVFF  75A,769
09862:  MOVFF  759,768
09866:  MOVFF  758,767
0986A:  MOVFF  757,766
0986E:  CLRF   x6D
09870:  CLRF   x6C
09872:  CLRF   x6B
09874:  MOVLW  0A
09876:  MOVWF  x6A
09878:  MOVLB  0
0987A:  CALL   6ACE
0987E:  MOVFF  03,75A
09882:  MOVFF  02,759
09886:  MOVFF  01,758
0988A:  MOVFF  00,757
0988E:  MOVLB  7
09890:  DECFSZ x55,F
09892:  BRA    97B0
09894:  MOVLB  0
09896:  RETURN 0
*
0A492:  MOVF   01,W
0A494:  MOVFF  72E,75F
0A498:  MOVLW  64
0A49A:  MOVLB  7
0A49C:  MOVWF  x60
0A49E:  MOVLB  0
0A4A0:  CALL   0890
0A4A4:  MOVFF  00,72E
0A4A8:  MOVF   01,W
0A4AA:  MOVLW  30
0A4AC:  BNZ   A4BE
0A4AE:  MOVLB  7
0A4B0:  BTFSS  x2F.1
0A4B2:  BRA    A4D4
0A4B4:  BTFSC  x2F.3
0A4B6:  BRA    A4D4
0A4B8:  BTFSC  x2F.4
0A4BA:  MOVLW  20
0A4BC:  BRA    A4C6
0A4BE:  MOVLB  7
0A4C0:  BCF    x2F.3
0A4C2:  BCF    x2F.4
0A4C4:  BSF    x2F.0
0A4C6:  ADDWF  01,F
0A4C8:  MOVFF  01,766
0A4CC:  MOVLB  0
0A4CE:  CALL   5CB6
0A4D2:  MOVLB  7
0A4D4:  MOVFF  72E,75F
0A4D8:  MOVLW  0A
0A4DA:  MOVWF  x60
0A4DC:  MOVLB  0
0A4DE:  CALL   0890
0A4E2:  MOVFF  00,72E
0A4E6:  MOVF   01,W
0A4E8:  MOVLW  30
0A4EA:  BNZ   A4FC
0A4EC:  MOVLB  7
0A4EE:  BTFSC  x2F.3
0A4F0:  BRA    A508
0A4F2:  BTFSS  x2F.0
0A4F4:  BRA    A508
0A4F6:  BTFSC  x2F.4
0A4F8:  MOVLW  20
0A4FA:  MOVLB  0
0A4FC:  ADDWF  01,F
0A4FE:  MOVFF  01,766
0A502:  CALL   5CB6
0A506:  MOVLB  7
0A508:  MOVLW  30
0A50A:  ADDWF  x2E,F
0A50C:  MOVFF  72E,766
0A510:  MOVLB  0
0A512:  CALL   5CB6
0A516:  RETURN 0
*
0A696:  MOVFF  FEA,730
0A69A:  MOVFF  FE9,72F
0A69E:  MOVLB  7
0A6A0:  SWAPF  x29,W
0A6A2:  IORLW  F0
0A6A4:  MOVWF  x2B
0A6A6:  ADDWF  x2B,F
0A6A8:  ADDLW  E2
0A6AA:  MOVWF  x2C
0A6AC:  ADDLW  32
0A6AE:  MOVWF  x2E
0A6B0:  MOVF   x29,W
0A6B2:  ANDLW  0F
0A6B4:  ADDWF  x2C,F
0A6B6:  ADDWF  x2C,F
0A6B8:  ADDWF  x2E,F
0A6BA:  ADDLW  E9
0A6BC:  MOVWF  x2D
0A6BE:  ADDWF  x2D,F
0A6C0:  ADDWF  x2D,F
0A6C2:  SWAPF  x28,W
0A6C4:  ANDLW  0F
0A6C6:  ADDWF  x2D,F
0A6C8:  ADDWF  x2E,F
0A6CA:  RLCF   x2D,F
0A6CC:  RLCF   x2E,F
0A6CE:  COMF   x2E,F
0A6D0:  RLCF   x2E,F
0A6D2:  MOVF   x28,W
0A6D4:  ANDLW  0F
0A6D6:  ADDWF  x2E,F
0A6D8:  RLCF   x2B,F
0A6DA:  MOVLW  07
0A6DC:  MOVWF  x2A
0A6DE:  MOVLW  0A
0A6E0:  DECF   x2D,F
0A6E2:  ADDWF  x2E,F
0A6E4:  BNC   A6E0
0A6E6:  DECF   x2C,F
0A6E8:  ADDWF  x2D,F
0A6EA:  BNC   A6E6
0A6EC:  DECF   x2B,F
0A6EE:  ADDWF  x2C,F
0A6F0:  BNC   A6EC
0A6F2:  DECF   x2A,F
0A6F4:  ADDWF  x2B,F
0A6F6:  BNC   A6F2
0A6F8:  MOVLW  07
0A6FA:  MOVWF  FEA
0A6FC:  MOVLW  2A
0A6FE:  MOVWF  FE9
0A700:  MOVLW  07
0A702:  ANDWF  x2F,W
0A704:  BCF    x2F.6
0A706:  ADDWF  FE9,F
0A708:  MOVLW  00
0A70A:  ADDWFC FEA,F
0A70C:  MOVF   FE9,W
0A70E:  SUBLW  2E
0A710:  BNZ   A71A
0A712:  MOVF   FEA,W
0A714:  SUBLW  07
0A716:  BNZ   A71A
0A718:  BSF    x2F.6
0A71A:  MOVF   FEF,W
0A71C:  MOVWF  00
0A71E:  BNZ   A730
0A720:  BTFSC  x2F.6
0A722:  BRA    A730
0A724:  BTFSC  x2F.4
0A726:  BRA    A754
0A728:  BTFSC  x2F.3
0A72A:  BRA    A730
0A72C:  MOVLW  20
0A72E:  BRA    A736
0A730:  BSF    x2F.3
0A732:  BCF    x2F.4
0A734:  MOVLW  30
0A736:  ADDWF  00,F
0A738:  MOVFF  FEA,729
0A73C:  MOVFF  FE9,728
0A740:  MOVFF  00,766
0A744:  MOVLB  0
0A746:  CALL   5CB6
0A74A:  MOVFF  729,FEA
0A74E:  MOVFF  728,FE9
0A752:  MOVLB  7
0A754:  MOVF   FEE,W
0A756:  BTFSS  x2F.6
0A758:  BRA    A70C
0A75A:  MOVLB  0
0A75C:  RETURN 0
.................... 
.................... #list
.................... 
.................... 
.................... #device ADC=10
.................... 
.................... //!#FUSES WDT                      //Watch Dog Timer
.................... //!#FUSES WDT4096                  //Watch Dog Timer uses 1:4096 Postscale
.................... 
.................... #use delay(internal=64000000)
*
00436:  MOVLW  07
00438:  MOVWF  FEA
0043A:  MOVLW  25
0043C:  MOVWF  FE9
0043E:  MOVF   FEF,W
00440:  BZ    045E
00442:  MOVLW  14
00444:  MOVWF  01
00446:  CLRF   00
00448:  DECFSZ 00,F
0044A:  BRA    0448
0044C:  DECFSZ 01,F
0044E:  BRA    0446
00450:  MOVLW  BF
00452:  MOVWF  00
00454:  DECFSZ 00,F
00456:  BRA    0454
00458:  BRA    045A
0045A:  DECFSZ FEF,F
0045C:  BRA    0442
0045E:  RETURN 0
*
006FC:  MOVLW  01
006FE:  MOVLB  7
00700:  SUBWF  x22,F
00702:  BNC   071C
00704:  MOVLW  07
00706:  MOVWF  FEA
00708:  MOVLW  22
0070A:  MOVWF  FE9
0070C:  MOVF   FEF,W
0070E:  BZ    071C
00710:  MOVLW  04
00712:  MOVWF  00
00714:  DECFSZ 00,F
00716:  BRA    0714
00718:  DECFSZ FEF,F
0071A:  BRA    0710
0071C:  MOVLB  0
0071E:  RETURN 0
.................... #define baudRate 128000
.................... #define numChannels 2
.................... 
.................... #define version  "20260209" // SW Version
.................... #define serialID "0000"     // Unique Serial ID
.................... #define magPP 1             // Magnetoresistive Sensor Pole Pitch in mm   
.................... #define gainLvl 16          // 1, 2, 4, 8, 16, 32, 64, 128
.................... 
.................... 
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B7,PIN_B6,PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
*
003A0:  MOVLW  CF
003A2:  MOVWF  F87
003A4:  CLRF   F82
....................    output_b(portB_reset);
003A6:  MOVLW  04
003A8:  MOVWF  F88
003AA:  CLRF   F83
....................    output_c(portC_reset);
003AC:  MOVLW  93
003AE:  MOVWF  F89
003B0:  CLRF   F84
....................    output_d(portD_reset);
003B2:  MOVLW  1F
003B4:  MOVWF  F8A
003B6:  CLRF   F85
....................    output_e(portE_reset);
003B8:  BCF    F8B.0
003BA:  BCF    F8B.1
003BC:  BCF    F8B.2
003BE:  BCF    F8B.3
003C0:  CLRF   F86
....................    
....................    port_a_pullups(portA_pullups);
003C2:  MOVLB  F
003C4:  SETF   x0B
....................    port_b_pullups(portB_pullups);
003C6:  CLRF   x13
....................    port_c_pullups(portC_pullups);
003C8:  CLRF   x1B
....................    port_d_pullups(portD_pullups);
003CA:  SETF   x20
....................    port_e_pullups(portE_pullups);
003CC:  CLRF   x28
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
003CE:  MOVLW  40
003D0:  MOVWF  x0C
003D2:  CLRF   x14
003D4:  MOVLW  03
003D6:  MOVWF  x1C
003D8:  MOVLW  0F
003DA:  MOVWF  x21
003DC:  CLRF   x29
003DE:  MOVLB  0
003E0:  GOTO   B18E (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
*
05D34:  MOVFF  758,FEA
05D38:  MOVLB  7
05D3A:  MOVFF  757,FE9
05D3E:  MOVFF  FEF,75B
05D42:  MOVFF  75A,FEA
05D46:  MOVFF  759,FE9
05D4A:  MOVF   FEF,W
05D4C:  SUBWF  x5B,W
05D4E:  BNZ   5D7E
....................       if (*s1 == '\0')
05D50:  MOVFF  758,03
05D54:  MOVFF  757,FE9
05D58:  MOVFF  03,FEA
05D5C:  MOVF   FEF,F
05D5E:  BNZ   5D66
....................          return(0);
05D60:  MOVLW  00
05D62:  MOVWF  01
05D64:  BRA    5DA8
05D66:  MOVFF  758,03
05D6A:  MOVF   x57,W
05D6C:  INCF   x57,F
05D6E:  BTFSC  FD8.2
05D70:  INCF   x58,F
05D72:  INCF   x59,F
05D74:  BTFSC  FD8.2
05D76:  INCF   x5A,F
05D78:  MOVLB  0
05D7A:  BRA    5D34
05D7C:  MOVLB  7
....................    return((*s1 < *s2) ? -1: 1);
05D7E:  MOVFF  758,03
05D82:  MOVFF  757,FE9
05D86:  MOVFF  03,FEA
05D8A:  MOVFF  FEF,75B
05D8E:  MOVFF  75A,03
05D92:  MOVFF  759,FE9
05D96:  MOVFF  03,FEA
05D9A:  MOVF   FEF,W
05D9C:  SUBWF  x5B,W
05D9E:  BC    5DA4
05DA0:  MOVLW  FF
05DA2:  BRA    5DA6
05DA4:  MOVLW  01
05DA6:  MOVWF  01
05DA8:  MOVLB  0
05DAA:  RETURN 0
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
*
05EAE:  MOVFF  77E,781
....................    for(su=s;0<n;++su,--n)
05EB2:  MOVFF  77D,783
05EB6:  MOVFF  77C,782
05EBA:  MOVLB  7
05EBC:  MOVF   x80,F
05EBE:  BNZ   5EC6
05EC0:  MOVF   x7F,W
05EC2:  SUBLW  00
05EC4:  BC    5EEE
....................       if(*su==uc)
05EC6:  MOVFF  783,FEA
05ECA:  MOVFF  782,FE9
05ECE:  MOVF   x81,W
05ED0:  SUBWF  FEF,W
05ED2:  BNZ   5EDE
....................       return su;
05ED4:  MOVFF  782,01
05ED8:  MOVFF  783,02
05EDC:  BRA    5EF4
05EDE:  INCF   x82,F
05EE0:  BTFSC  FD8.2
05EE2:  INCF   x83,F
05EE4:  MOVF   x7F,W
05EE6:  BTFSC  FD8.2
05EE8:  DECF   x80,F
05EEA:  DECF   x7F,F
05EEC:  BRA    5EBC
....................    return NULL;
05EEE:  MOVLW  00
05EF0:  MOVWF  01
05EF2:  MOVWF  02
05EF4:  MOVLB  0
05EF6:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
*
05C7E:  MOVFF  758,75A
05C82:  MOVFF  757,759
05C86:  MOVFF  75A,FEA
05C8A:  MOVLB  7
05C8C:  MOVFF  759,FE9
05C90:  MOVF   FEF,F
05C92:  BZ    5CA0
05C94:  INCF   x59,F
05C96:  BTFSC  FD8.2
05C98:  INCF   x5A,F
05C9A:  MOVLB  0
05C9C:  BRA    5C86
05C9E:  MOVLB  7
....................    return(sc - s);
05CA0:  MOVF   x57,W
05CA2:  SUBWF  x59,W
05CA4:  MOVWF  00
05CA6:  MOVF   x58,W
05CA8:  SUBWFB x5A,W
05CAA:  MOVWF  03
05CAC:  MOVFF  00,01
05CB0:  MOVWF  02
05CB2:  MOVLB  0
05CB4:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
*
0728A:  MOVLB  7
0728C:  CLRF   x31
0728E:  CLRF   x30
07290:  CLRF   x2F
07292:  MOVLW  7F
07294:  MOVWF  x2E
07296:  CLRF   x35
07298:  CLRF   x34
0729A:  CLRF   x33
0729C:  CLRF   x32
0729E:  BSF    x36.0
072A0:  BCF    x36.1
072A2:  BCF    x36.2
072A4:  CLRF   x38
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
072A6:  MOVF   x2A,W
072A8:  IORWF  x2B,W
072AA:  BNZ   72B6
....................       return 0;
072AC:  CLRF   00
072AE:  CLRF   01
072B0:  CLRF   02
072B2:  CLRF   03
072B4:  BRA    74E0
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
072B6:  MOVF   x38,W
072B8:  INCF   x38,F
072BA:  ADDWF  x2A,W
072BC:  MOVWF  FE9
072BE:  MOVLW  00
072C0:  ADDWFC x2B,W
072C2:  MOVWF  FEA
072C4:  MOVFF  FEF,737
072C8:  MOVF   x37,F
072CA:  BTFSC  FD8.2
072CC:  BRA    7464
....................    {
....................       if (skip && !isspace(c))
072CE:  BTFSS  x36.0
072D0:  BRA    72F0
072D2:  MOVF   x37,W
072D4:  SUBLW  20
072D6:  BZ    72F0
....................       {
....................          skip = 0;
072D8:  BCF    x36.0
....................          if (c == '+')
072DA:  MOVF   x37,W
072DC:  SUBLW  2B
072DE:  BNZ   72E6
....................          {
....................             sign = 0;
072E0:  BCF    x36.1
....................             continue;
072E2:  BRA    744C
....................          }            
072E4:  BRA    72F0
....................          else if (c == '-')
072E6:  MOVF   x37,W
072E8:  SUBLW  2D
072EA:  BNZ   72F0
....................          {
....................             sign = 1;
072EC:  BSF    x36.1
....................             continue;
072EE:  BRA    744C
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
072F0:  BTFSC  x36.0
072F2:  BRA    7302
072F4:  MOVF   x37,W
072F6:  SUBLW  2E
072F8:  BNZ   7302
072FA:  BTFSC  x36.2
072FC:  BRA    7302
....................          point = 1;
072FE:  BSF    x36.2
07300:  BRA    744C
....................       else if (!skip && isdigit(c))
07302:  BTFSC  x36.0
07304:  BRA    7446
07306:  MOVF   x37,W
07308:  SUBLW  2F
0730A:  BTFSC  FD8.0
0730C:  BRA    7446
0730E:  MOVF   x37,W
07310:  SUBLW  39
07312:  BTFSS  FD8.0
07314:  BRA    7446
....................       {
....................          c -= '0';
07316:  MOVLW  30
07318:  SUBWF  x37,F
....................          if (point)
0731A:  BTFSS  x36.2
0731C:  BRA    73CC
....................          {
....................             pow10 = pow10 * 10.0;
0731E:  MOVFF  731,76F
07322:  MOVFF  730,76E
07326:  MOVFF  72F,76D
0732A:  MOVFF  72E,76C
0732E:  CLRF   x73
07330:  CLRF   x72
07332:  MOVLW  20
07334:  MOVWF  x71
07336:  MOVLW  82
07338:  MOVWF  x70
0733A:  MOVLB  0
0733C:  CALL   1116
07340:  MOVFF  03,731
07344:  MOVFF  02,730
07348:  MOVFF  01,72F
0734C:  MOVFF  00,72E
....................             result += (float)c / pow10;   
07350:  MOVLB  7
07352:  CLRF   x71
07354:  MOVFF  737,770
07358:  MOVLB  0
0735A:  CALL   2DB8
0735E:  MOVFF  03,73C
07362:  MOVFF  02,73B
07366:  MOVFF  01,73A
0736A:  MOVFF  00,739
0736E:  MOVFF  03,768
07372:  MOVFF  02,767
07376:  MOVFF  01,766
0737A:  MOVFF  00,765
0737E:  MOVFF  731,76C
07382:  MOVFF  730,76B
07386:  MOVFF  72F,76A
0738A:  MOVFF  72E,769
0738E:  CALL   242E
07392:  BCF    FD8.1
07394:  MOVFF  735,773
07398:  MOVFF  734,772
0739C:  MOVFF  733,771
073A0:  MOVFF  732,770
073A4:  MOVFF  03,777
073A8:  MOVFF  02,776
073AC:  MOVFF  01,775
073B0:  MOVFF  00,774
073B4:  CALL   0DDC
073B8:  MOVFF  03,735
073BC:  MOVFF  02,734
073C0:  MOVFF  01,733
073C4:  MOVFF  00,732
....................          }
073C8:  BRA    7442
073CA:  MOVLB  7
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
073CC:  CLRF   x6F
073CE:  CLRF   x6E
073D0:  MOVLW  20
073D2:  MOVWF  x6D
073D4:  MOVLW  82
073D6:  MOVWF  x6C
073D8:  MOVFF  735,773
073DC:  MOVFF  734,772
073E0:  MOVFF  733,771
073E4:  MOVFF  732,770
073E8:  MOVLB  0
073EA:  CALL   1116
073EE:  MOVFF  03,73C
073F2:  MOVFF  02,73B
073F6:  MOVFF  01,73A
073FA:  MOVFF  00,739
073FE:  MOVLB  7
07400:  CLRF   x71
07402:  MOVFF  737,770
07406:  MOVLB  0
07408:  CALL   2DB8
0740C:  BCF    FD8.1
0740E:  MOVFF  73C,773
07412:  MOVFF  73B,772
07416:  MOVFF  73A,771
0741A:  MOVFF  739,770
0741E:  MOVFF  03,777
07422:  MOVFF  02,776
07426:  MOVFF  01,775
0742A:  MOVFF  00,774
0742E:  CALL   0DDC
07432:  MOVFF  03,735
07436:  MOVFF  02,734
0743A:  MOVFF  01,733
0743E:  MOVFF  00,732
....................          }
....................       }
07442:  BRA    744E
07444:  MOVLB  7
....................       else if (!skip)
07446:  BTFSC  x36.0
07448:  BRA    744C
....................          break;
0744A:  BRA    7464
0744C:  MOVLB  0
0744E:  MOVLB  7
07450:  MOVF   x38,W
07452:  INCF   x38,F
07454:  ADDWF  x2A,W
07456:  MOVWF  FE9
07458:  MOVLW  00
0745A:  ADDWFC x2B,W
0745C:  MOVWF  FEA
0745E:  MOVFF  FEF,737
07462:  BRA    72C8
....................    }
.................... 
....................    if (sign)
07464:  BTFSS  x36.1
07466:  BRA    749C
....................       result = -1*result;
07468:  CLRF   x6F
0746A:  CLRF   x6E
0746C:  MOVLW  80
0746E:  MOVWF  x6D
07470:  MOVLW  7F
07472:  MOVWF  x6C
07474:  MOVFF  735,773
07478:  MOVFF  734,772
0747C:  MOVFF  733,771
07480:  MOVFF  732,770
07484:  MOVLB  0
07486:  CALL   1116
0748A:  MOVFF  03,735
0748E:  MOVFF  02,734
07492:  MOVFF  01,733
07496:  MOVFF  00,732
0749A:  MOVLB  7
....................       
....................    if(endptr)
0749C:  MOVF   x2C,W
0749E:  IORWF  x2D,W
074A0:  BZ    74D0
....................    {
....................       if (ptr) {
074A2:  MOVF   x38,F
074A4:  BZ    74BE
....................          ptr--;
074A6:  DECF   x38,F
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
074A8:  MOVFF  72D,FEA
074AC:  MOVFF  72C,FE9
074B0:  MOVF   x38,W
074B2:  ADDWF  x2A,W
074B4:  MOVWF  FEF
074B6:  MOVLW  00
074B8:  ADDWFC x2B,W
074BA:  MOVWF  FEC
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
074BC:  BRA    74D0
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
074BE:  MOVFF  72D,FEA
074C2:  MOVFF  72C,FE9
074C6:  MOVFF  72B,FEC
074CA:  MOVF   FED,F
074CC:  MOVFF  72A,FEF
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
074D0:  MOVFF  732,00
074D4:  MOVFF  733,01
074D8:  MOVFF  734,02
074DC:  MOVFF  735,03
074E0:  MOVLB  0
074E2:  RETURN 0
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
*
05F4E:  MOVLB  7
05F50:  CLRF   x55
05F52:  CLRF   x54
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
05F54:  MOVLW  30
05F56:  MOVWF  x57
05F58:  MOVLW  31
05F5A:  MOVWF  x58
05F5C:  MOVLW  32
05F5E:  MOVWF  x59
05F60:  MOVLW  33
05F62:  MOVWF  x5A
05F64:  MOVLW  34
05F66:  MOVWF  x5B
05F68:  MOVLW  35
05F6A:  MOVWF  x5C
05F6C:  MOVLW  36
05F6E:  MOVWF  x5D
05F70:  MOVLW  37
05F72:  MOVWF  x5E
05F74:  MOVLW  38
05F76:  MOVWF  x5F
05F78:  MOVLW  39
05F7A:  MOVWF  x60
05F7C:  MOVLW  61
05F7E:  MOVWF  x61
05F80:  MOVLW  62
05F82:  MOVWF  x62
05F84:  MOVLW  63
05F86:  MOVWF  x63
05F88:  MOVLW  64
05F8A:  MOVWF  x64
05F8C:  MOVLW  65
05F8E:  MOVWF  x65
05F90:  MOVLW  66
05F92:  MOVWF  x66
05F94:  MOVLW  67
05F96:  MOVWF  x67
05F98:  MOVLW  68
05F9A:  MOVWF  x68
05F9C:  MOVLW  69
05F9E:  MOVWF  x69
05FA0:  MOVLW  6A
05FA2:  MOVWF  x6A
05FA4:  MOVLW  6B
05FA6:  MOVWF  x6B
05FA8:  MOVLW  6C
05FAA:  MOVWF  x6C
05FAC:  MOVLW  6D
05FAE:  MOVWF  x6D
05FB0:  MOVLW  6E
05FB2:  MOVWF  x6E
05FB4:  MOVLW  6F
05FB6:  MOVWF  x6F
05FB8:  MOVLW  70
05FBA:  MOVWF  x70
05FBC:  MOVLW  71
05FBE:  MOVWF  x71
05FC0:  MOVLW  73
05FC2:  MOVWF  x72
05FC4:  MOVLW  74
05FC6:  MOVWF  x73
05FC8:  MOVLW  75
05FCA:  MOVWF  x74
05FCC:  MOVLW  76
05FCE:  MOVWF  x75
05FD0:  MOVLW  77
05FD2:  MOVWF  x76
05FD4:  MOVLW  78
05FD6:  MOVWF  x77
05FD8:  MOVLW  79
05FDA:  MOVWF  x78
05FDC:  MOVLW  7A
05FDE:  MOVWF  x79
05FE0:  CLRF   x7A
....................    for(sc=s;isspace(*sc);++sc);
05FE2:  MOVFF  74A,74F
05FE6:  MOVFF  749,74E
05FEA:  MOVFF  74F,FEA
05FEE:  MOVFF  74E,FE9
05FF2:  MOVF   FEF,W
05FF4:  SUBLW  20
05FF6:  BNZ   6000
05FF8:  INCF   x4E,F
05FFA:  BTFSC  FD8.2
05FFC:  INCF   x4F,F
05FFE:  BRA    5FEA
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
06000:  MOVFF  74F,03
06004:  MOVFF  74E,FE9
06008:  MOVFF  03,FEA
0600C:  MOVF   FEF,W
0600E:  SUBLW  2D
06010:  BZ    6020
06012:  MOVFF  74F,FEA
06016:  MOVFF  74E,FE9
0601A:  MOVF   FEF,W
0601C:  SUBLW  2B
0601E:  BNZ   6032
06020:  MOVFF  74F,FEA
06024:  MOVF   x4E,W
06026:  INCF   x4E,F
06028:  BTFSC  FD8.2
0602A:  INCF   x4F,F
0602C:  MOVWF  FE9
0602E:  MOVF   FEF,W
06030:  BRA    6034
06032:  MOVLW  2B
06034:  MOVWF  x56
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
06036:  MOVF   x56,W
06038:  SUBLW  2D
0603A:  BZ    6050
0603C:  BTFSC  x4D.7
0603E:  BRA    6050
06040:  DECFSZ x4D,W
06042:  BRA    6046
06044:  BRA    6050
06046:  BTFSC  x4D.7
06048:  BRA    6054
0604A:  MOVF   x4D,W
0604C:  SUBLW  24
0604E:  BC    6054
....................    goto StrtoulGO;
06050:  BRA    625C
06052:  BRA    614C
.................... 
....................    else if (base)
06054:  MOVF   x4D,F
06056:  BZ    60E4
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
06058:  MOVF   x4D,W
0605A:  SUBLW  10
0605C:  BNZ   6098
0605E:  MOVFF  74F,FEA
06062:  MOVFF  74E,FE9
06066:  MOVF   FEF,W
06068:  SUBLW  30
0606A:  BNZ   6098
0606C:  MOVLW  01
0606E:  ADDWF  x4E,W
06070:  MOVWF  FE9
06072:  MOVLW  00
06074:  ADDWFC x4F,W
06076:  MOVWF  FEA
06078:  MOVF   FEF,W
0607A:  SUBLW  78
0607C:  BZ    6090
0607E:  MOVLW  01
06080:  ADDWF  x4E,W
06082:  MOVWF  FE9
06084:  MOVLW  00
06086:  ADDWFC x4F,W
06088:  MOVWF  FEA
0608A:  MOVF   FEF,W
0608C:  SUBLW  58
0608E:  BNZ   6098
....................          sc+=2;
06090:  MOVLW  02
06092:  ADDWF  x4E,F
06094:  MOVLW  00
06096:  ADDWFC x4F,F
....................       if(base==8 && *sc =='0')
06098:  MOVF   x4D,W
0609A:  SUBLW  08
0609C:  BNZ   60B4
0609E:  MOVFF  74F,FEA
060A2:  MOVFF  74E,FE9
060A6:  MOVF   FEF,W
060A8:  SUBLW  30
060AA:  BNZ   60B4
....................          sc+=1;
060AC:  MOVLW  01
060AE:  ADDWF  x4E,F
060B0:  MOVLW  00
060B2:  ADDWFC x4F,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
060B4:  MOVF   x4D,W
060B6:  SUBLW  02
060B8:  BNZ   60E2
060BA:  MOVFF  74F,FEA
060BE:  MOVFF  74E,FE9
060C2:  MOVF   FEF,W
060C4:  SUBLW  30
060C6:  BNZ   60E2
060C8:  MOVLW  01
060CA:  ADDWF  x4E,W
060CC:  MOVWF  FE9
060CE:  MOVLW  00
060D0:  ADDWFC x4F,W
060D2:  MOVWF  FEA
060D4:  MOVF   FEF,W
060D6:  SUBLW  62
060D8:  BNZ   60E2
....................          sc+=2;
060DA:  MOVLW  02
060DC:  ADDWF  x4E,F
060DE:  MOVLW  00
060E0:  ADDWFC x4F,F
.................... 
....................    }
060E2:  BRA    614C
....................    else if(*sc!='0') // base is 0, find base
060E4:  MOVFF  74F,FEA
060E8:  MOVFF  74E,FE9
060EC:  MOVF   FEF,W
060EE:  SUBLW  30
060F0:  BZ    60F8
....................       base=10;
060F2:  MOVLW  0A
060F4:  MOVWF  x4D
060F6:  BRA    614C
....................    else if (sc[1]=='x' || sc[1]=='X')
060F8:  MOVLW  01
060FA:  ADDWF  x4E,W
060FC:  MOVWF  FE9
060FE:  MOVLW  00
06100:  ADDWFC x4F,W
06102:  MOVWF  FEA
06104:  MOVF   FEF,W
06106:  SUBLW  78
06108:  BZ    611C
0610A:  MOVLW  01
0610C:  ADDWF  x4E,W
0610E:  MOVWF  FE9
06110:  MOVLW  00
06112:  ADDWFC x4F,W
06114:  MOVWF  FEA
06116:  MOVF   FEF,W
06118:  SUBLW  58
0611A:  BNZ   612A
....................       base =16,sc+=2;
0611C:  MOVLW  10
0611E:  MOVWF  x4D
06120:  MOVLW  02
06122:  ADDWF  x4E,F
06124:  MOVLW  00
06126:  ADDWFC x4F,F
06128:  BRA    614C
....................    else if(sc[1]=='b')
0612A:  MOVLW  01
0612C:  ADDWF  x4E,W
0612E:  MOVWF  FE9
06130:  MOVLW  00
06132:  ADDWFC x4F,W
06134:  MOVWF  FEA
06136:  MOVF   FEF,W
06138:  SUBLW  62
0613A:  BNZ   6148
....................       base=2,sc+=2;
0613C:  MOVLW  02
0613E:  MOVWF  x4D
06140:  ADDWF  x4E,F
06142:  MOVLW  00
06144:  ADDWFC x4F,F
06146:  BRA    614C
....................    else
....................       base=8;
06148:  MOVLW  08
0614A:  MOVWF  x4D
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
0614C:  MOVFF  74F,751
06150:  MOVFF  74E,750
06154:  MOVFF  74F,FEA
06158:  MOVFF  74E,FE9
0615C:  MOVF   FEF,W
0615E:  SUBLW  30
06160:  BNZ   616A
06162:  INCF   x4E,F
06164:  BTFSC  FD8.2
06166:  INCF   x4F,F
06168:  BRA    6154
....................    sd=memchr(digits,tolower(*sc),base);
0616A:  MOVFF  74F,03
0616E:  MOVFF  74E,FE9
06172:  MOVFF  03,FEA
06176:  MOVFF  FEF,77B
0617A:  MOVF   x7B,W
0617C:  SUBLW  40
0617E:  BC    618C
06180:  MOVF   x7B,W
06182:  SUBLW  5A
06184:  BNC   618C
06186:  MOVF   x7B,W
06188:  IORLW  20
0618A:  BRA    618E
0618C:  MOVF   x7B,W
0618E:  MOVWF  x7B
06190:  MOVLW  07
06192:  MOVWF  x7D
06194:  MOVLW  57
06196:  MOVWF  x7C
06198:  MOVFF  77B,77E
0619C:  CLRF   x80
0619E:  MOVFF  74D,77F
061A2:  BTFSC  x7F.7
061A4:  DECF   x80,F
061A6:  MOVLB  0
061A8:  RCALL  5EAE
061AA:  MOVFF  02,753
061AE:  MOVFF  01,752
....................    for(; sd!=0; )
061B2:  MOVLB  7
061B4:  MOVF   x52,F
061B6:  BNZ   61BC
061B8:  MOVF   x53,F
061BA:  BZ    6250
....................    {
....................       x=x*base+(int16)(sd-digits);
061BC:  CLRF   03
061BE:  MOVF   x4D,W
061C0:  MOVWF  00
061C2:  BTFSC  FE8.7
061C4:  DECF   03,F
061C6:  MOVWF  x7B
061C8:  MOVFF  03,77C
061CC:  MOVFF  755,77E
061D0:  MOVFF  754,77D
061D4:  MOVFF  03,780
061D8:  MOVWF  x7F
061DA:  MOVLB  0
061DC:  BRA    5EF8
061DE:  MOVFF  01,77B
061E2:  MOVLW  57
061E4:  MOVLB  7
061E6:  SUBWF  x52,W
061E8:  MOVWF  00
061EA:  MOVLW  07
061EC:  SUBWFB x53,W
061EE:  MOVWF  03
061F0:  MOVF   00,W
061F2:  ADDWF  01,W
061F4:  MOVWF  01
061F6:  MOVF   02,W
061F8:  ADDWFC 03,F
061FA:  MOVFF  01,754
061FE:  MOVFF  03,755
....................       ++sc;
06202:  INCF   x4E,F
06204:  BTFSC  FD8.2
06206:  INCF   x4F,F
....................       sd=memchr(digits,tolower(*sc),base);
06208:  MOVFF  74F,FEA
0620C:  MOVFF  74E,FE9
06210:  MOVFF  FEF,77B
06214:  MOVF   x7B,W
06216:  SUBLW  40
06218:  BC    6226
0621A:  MOVF   x7B,W
0621C:  SUBLW  5A
0621E:  BNC   6226
06220:  MOVF   x7B,W
06222:  IORLW  20
06224:  BRA    6228
06226:  MOVF   x7B,W
06228:  MOVWF  x7B
0622A:  MOVLW  07
0622C:  MOVWF  x7D
0622E:  MOVLW  57
06230:  MOVWF  x7C
06232:  MOVFF  77B,77E
06236:  CLRF   x80
06238:  MOVFF  74D,77F
0623C:  BTFSC  x7F.7
0623E:  DECF   x80,F
06240:  MOVLB  0
06242:  RCALL  5EAE
06244:  MOVFF  02,753
06248:  MOVFF  01,752
0624C:  BRA    61B2
0624E:  MOVLB  7
....................    }
....................    if(s1==sc)
06250:  MOVF   x4E,W
06252:  SUBWF  x50,W
06254:  BNZ   627E
06256:  MOVF   x4F,W
06258:  SUBWF  x51,W
0625A:  BNZ   627E
....................    {
....................    StrtoulGO:
....................       if (endptr)
0625C:  MOVLB  7
0625E:  MOVF   x4B,W
06260:  IORWF  x4C,W
06262:  BZ    6276
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
06264:  MOVFF  74C,FEA
06268:  MOVFF  74B,FE9
0626C:  MOVFF  74A,FEC
06270:  MOVF   FED,F
06272:  MOVFF  749,FEF
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
06276:  MOVLW  00
06278:  MOVWF  01
0627A:  MOVWF  02
0627C:  BRA    629E
....................    }
....................    if (endptr)
0627E:  MOVF   x4B,W
06280:  IORWF  x4C,W
06282:  BZ    6296
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
06284:  MOVFF  74C,FEA
06288:  MOVFF  74B,FE9
0628C:  MOVFF  74F,FEC
06290:  MOVF   FED,F
06292:  MOVFF  74E,FEF
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
06296:  MOVFF  754,01
0629A:  MOVFF  755,02
0629E:  MOVLB  0
062A0:  RETURN 0
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................     float kP;      // proportional gain
....................     float kI;      // integral gain
....................     float kD;      // derivative gain
....................     float SP;      // set point-- desired output
....................     float PV;      // process variable-- measured output
....................     float PVold;   // oldPV value  
....................     float CV;      // control variable-- output -- 0 to 100%
....................     float I;       // integral value
....................     float maxSP;   // Max setpoint in microns
....................     float minSP;   // Min setpoint in microns
.................... }PID[2] = {
....................    //  P     I     D
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}, 
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}
....................     };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... // @FLAG
.................... #define op_upper_bound 63  // CRYO
.................... #define op_lower_bound -63 // CRYO
.................... 
.................... //!#define op_upper_bound 63  // AMBIENT 
.................... //!#define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {-0.2701,-0.97313,0,0,0,0},  // @FLAG: Switched Channels
....................                     {-0.3964,-0.96557,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    BOOLEAN homeFlag;       // Flag to trigger the homing routine
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,-1,0,0,FALSE},  // @FLAG: Y-Axis passes -pole during cooldown
....................    {0,0,0,0,0,0,0, 0,0,0,FALSE}
.................... };
.................... 
.................... BOOLEAN adcFilter = TRUE;
.................... 
.................... struct dacV
.................... {
....................     BOOLEAN invV;
....................     unsigned int16 ipVal;
....................     float opPcnt;
....................    
.................... }dacVals[2] = 
.................... {
....................     {FALSE,0,0},
....................     {FALSE,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
*
00460:  MOVLB  7
00462:  CLRF   x27
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
00464:  CLRF   x27
00466:  MOVF   x26,W
00468:  SUBWF  x27,W
0046A:  BC    04C2
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
0046C:  MOVF   x27,W
0046E:  ADDWF  x24,W
00470:  MOVWF  x28
00472:  MOVLW  00
00474:  ADDWFC x25,W
00476:  MOVWF  x29
00478:  MOVF   x27,W
0047A:  ADDWF  x22,W
0047C:  MOVWF  01
0047E:  MOVLW  00
00480:  ADDWFC x23,W
00482:  MOVWF  03
00484:  MOVF   01,W
00486:  MOVWF  FE9
00488:  MOVFF  03,FEA
0048C:  MOVFF  FEF,72A
00490:  BSF    F7F.7
00492:  MOVF   FF2,W
00494:  MOVWF  00
00496:  BCF    FF2.7
00498:  MOVFF  729,F7A
0049C:  MOVFF  728,F79
004A0:  MOVLW  31
004A2:  MOVWF  F7B
004A4:  MOVFF  72A,F7C
004A8:  MOVLB  F
004AA:  MOVLW  55
004AC:  MOVWF  F81
004AE:  MOVLW  AA
004B0:  MOVWF  F81
004B2:  BSF    F80.4
004B4:  BTFSC  F80.4
004B6:  BRA    04B4
004B8:  MOVF   00,W
004BA:  IORWF  FF2,F
004BC:  MOVLB  7
004BE:  INCF   x27,F
004C0:  BRA    0466
....................    }
004C2:  MOVLB  0
004C4:  RETURN 0
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
*
003E4:  MOVLB  7
003E6:  CLRF   x1B
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
003E8:  CLRF   x1B
003EA:  MOVF   x1A,W
003EC:  SUBWF  x1B,W
003EE:  BC    0432
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
003F0:  MOVF   x1B,W
003F2:  ADDWF  x16,W
003F4:  MOVWF  01
003F6:  MOVLW  00
003F8:  ADDWFC x17,W
003FA:  MOVWF  03
003FC:  MOVF   01,W
003FE:  MOVWF  FE9
00400:  MOVFF  03,FEA
00404:  MOVF   x1B,W
00406:  ADDWF  x18,W
00408:  MOVWF  x1E
0040A:  MOVLW  00
0040C:  ADDWFC x19,W
0040E:  MOVWF  x1F
00410:  BSF    F7F.7
00412:  MOVFF  FF2,720
00416:  BCF    FF2.7
00418:  MOVFF  71F,F7A
0041C:  MOVFF  71E,F79
00420:  MOVLW  31
00422:  MOVWF  F7B
00424:  BSF    F80.0
00426:  MOVF   F7C,W
00428:  BTFSC  x20.7
0042A:  BSF    FF2.7
0042C:  MOVWF  FEF
0042E:  INCF   x1B,F
00430:  BRA    03EA
....................    }
00432:  MOVLB  0
00434:  RETURN 0
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
*
004C6:  MOVLB  7
004C8:  CLRF   x23
004CA:  MOVLW  20
004CC:  MOVWF  x22
004CE:  CLRF   x25
004D0:  CLRF   x24
004D2:  MOVLW  80
004D4:  MOVWF  x26
004D6:  MOVLB  0
004D8:  RCALL  0460
....................    delay_ms(1);
004DA:  MOVLW  01
004DC:  MOVLB  7
004DE:  MOVWF  x25
004E0:  MOVLB  0
004E2:  RCALL  0436
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
004E4:  MOVLB  7
004E6:  CLRF   x23
004E8:  MOVLW  70
004EA:  MOVWF  x22
004EC:  CLRF   x25
004EE:  MOVLW  80
004F0:  MOVWF  x24
004F2:  MOVLW  02
004F4:  MOVWF  x26
004F6:  MOVLB  0
004F8:  RCALL  0460
....................    delay_ms(1);
004FA:  MOVLW  01
004FC:  MOVLB  7
004FE:  MOVWF  x25
00500:  MOVLB  0
00502:  RCALL  0436
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
00504:  MOVLB  7
00506:  CLRF   x23
00508:  MOVLW  71
0050A:  MOVWF  x22
0050C:  CLRF   x25
0050E:  MOVLW  90
00510:  MOVWF  x24
00512:  MOVLW  02
00514:  MOVWF  x26
00516:  MOVLB  0
00518:  RCALL  0460
....................    delay_ms(1);
0051A:  MOVLW  01
0051C:  MOVLB  7
0051E:  MOVWF  x25
00520:  MOVLB  0
00522:  RCALL  0436
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
00524:  MOVLB  7
00526:  CLRF   x23
00528:  MOVLW  72
0052A:  MOVWF  x22
0052C:  CLRF   x25
0052E:  MOVLW  A0
00530:  MOVWF  x24
00532:  MOVLW  20
00534:  MOVWF  x26
00536:  MOVLB  0
00538:  RCALL  0460
....................    delay_ms(1);
0053A:  MOVLW  01
0053C:  MOVLB  7
0053E:  MOVWF  x25
00540:  MOVLB  0
00542:  RCALL  0436
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
00544:  MOVLB  7
00546:  CLRF   x23
00548:  MOVLW  92
0054A:  MOVWF  x22
0054C:  CLRF   x25
0054E:  MOVLW  C0
00550:  MOVWF  x24
00552:  MOVLW  30
00554:  MOVWF  x26
00556:  MOVLB  0
00558:  RCALL  0460
....................    delay_ms(1);
0055A:  MOVLW  01
0055C:  MOVLB  7
0055E:  MOVWF  x25
00560:  MOVLB  0
00562:  RCALL  0436
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
00564:  MOVLB  7
00566:  CLRF   x23
00568:  MOVLW  C2
0056A:  MOVWF  x22
0056C:  CLRF   x25
0056E:  MOVLW  F0
00570:  MOVWF  x24
00572:  MOVLW  38
00574:  MOVWF  x26
00576:  MOVLB  0
00578:  RCALL  0460
....................    delay_ms(1);
0057A:  MOVLW  01
0057C:  MOVLB  7
0057E:  MOVWF  x25
00580:  MOVLB  0
00582:  RCALL  0436
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
00584:  MOVLB  7
00586:  CLRF   x23
00588:  MOVLW  FA
0058A:  MOVWF  x22
0058C:  MOVLW  01
0058E:  MOVWF  x25
00590:  MOVLW  40
00592:  MOVWF  x24
00594:  MOVLW  01
00596:  MOVWF  x26
00598:  MOVLB  0
0059A:  RCALL  0460
....................    delay_ms(1);
0059C:  MOVLW  01
0059E:  MOVLB  7
005A0:  MOVWF  x25
005A2:  MOVLB  0
005A4:  RCALL  0436
005A6:  RETURN 0
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
005A8:  MOVLB  7
005AA:  CLRF   x17
005AC:  MOVLW  20
005AE:  MOVWF  x16
005B0:  CLRF   x19
005B2:  CLRF   x18
005B4:  MOVLW  80
005B6:  MOVWF  x1A
005B8:  MOVLB  0
005BA:  RCALL  03E4
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
005BC:  MOVLB  7
005BE:  CLRF   x17
005C0:  MOVLW  70
005C2:  MOVWF  x16
005C4:  CLRF   x19
005C6:  MOVLW  80
005C8:  MOVWF  x18
005CA:  MOVLW  02
005CC:  MOVWF  x1A
005CE:  MOVLB  0
005D0:  RCALL  03E4
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
005D2:  MOVLB  7
005D4:  CLRF   x17
005D6:  MOVLW  71
005D8:  MOVWF  x16
005DA:  CLRF   x19
005DC:  MOVLW  90
005DE:  MOVWF  x18
005E0:  MOVLW  02
005E2:  MOVWF  x1A
005E4:  MOVLB  0
005E6:  RCALL  03E4
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
005E8:  MOVLB  7
005EA:  CLRF   x17
005EC:  MOVLW  72
005EE:  MOVWF  x16
005F0:  CLRF   x19
005F2:  MOVLW  A0
005F4:  MOVWF  x18
005F6:  MOVLW  20
005F8:  MOVWF  x1A
005FA:  MOVLB  0
005FC:  RCALL  03E4
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
005FE:  MOVLB  7
00600:  CLRF   x17
00602:  MOVLW  92
00604:  MOVWF  x16
00606:  CLRF   x19
00608:  MOVLW  C0
0060A:  MOVWF  x18
0060C:  MOVLW  30
0060E:  MOVWF  x1A
00610:  MOVLB  0
00612:  RCALL  03E4
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
00614:  MOVLB  7
00616:  CLRF   x17
00618:  MOVLW  C2
0061A:  MOVWF  x16
0061C:  CLRF   x19
0061E:  MOVLW  F0
00620:  MOVWF  x18
00622:  MOVLW  38
00624:  MOVWF  x1A
00626:  MOVLB  0
00628:  RCALL  03E4
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
0062A:  MOVLB  7
0062C:  CLRF   x17
0062E:  MOVLW  FA
00630:  MOVWF  x16
00632:  MOVLW  01
00634:  MOVWF  x19
00636:  MOVLW  40
00638:  MOVWF  x18
0063A:  MOVLW  01
0063C:  MOVWF  x1A
0063E:  MOVLB  0
00640:  RCALL  03E4
00642:  GOTO   0678 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
00646:  MOVLB  7
00648:  CLRF   x17
0064A:  MOVLW  FA
0064C:  MOVWF  x16
0064E:  MOVLW  01
00650:  MOVWF  x19
00652:  MOVLW  40
00654:  MOVWF  x18
00656:  MOVLW  01
00658:  MOVWF  x1A
0065A:  MOVLB  0
0065C:  RCALL  03E4
....................    delay_ms(1);
0065E:  MOVLW  01
00660:  MOVLB  7
00662:  MOVWF  x25
00664:  MOVLB  0
00666:  RCALL  0436
....................    if (paramsValid != isValid)
00668:  MOVF   xFA,W
0066A:  SUBLW  AA
0066C:  BZ    0676
....................    {
....................       paramsValid = isValid;
0066E:  MOVLW  AA
00670:  MOVWF  xFA
....................       params_save_to_ee(); // saves the base parameters on first boot
00672:  RCALL  04C6
....................    }
00674:  BRA    0678
....................    else
....................    {
....................       params_load_from_ee();
00676:  BRA    05A8
....................    }
00678:  GOTO   B192 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <monitor.h>
.................... #ifndef monitor
.................... #define monitor
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B7,PIN_B6,PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
....................    output_b(portB_reset);
....................    output_c(portC_reset);
....................    output_d(portD_reset);
....................    output_e(portE_reset);
....................    
....................    port_a_pullups(portA_pullups);
....................    port_b_pullups(portB_pullups);
....................    port_c_pullups(portC_pullups);
....................    port_d_pullups(portD_pullups);
....................    port_e_pullups(portE_pullups);
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................     float kP;      // proportional gain
....................     float kI;      // integral gain
....................     float kD;      // derivative gain
....................     float SP;      // set point-- desired output
....................     float PV;      // process variable-- measured output
....................     float PVold;   // oldPV value  
....................     float CV;      // control variable-- output -- 0 to 100%
....................     float I;       // integral value
....................     float maxSP;   // Max setpoint in microns
....................     float minSP;   // Min setpoint in microns
.................... }PID[2] = {
....................    //  P     I     D
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}, 
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}
....................     };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... // @FLAG
.................... #define op_upper_bound 63  // CRYO
.................... #define op_lower_bound -63 // CRYO
.................... 
.................... //!#define op_upper_bound 63  // AMBIENT 
.................... //!#define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {-0.2701,-0.97313,0,0,0,0},  // @FLAG: Switched Channels
....................                     {-0.3964,-0.96557,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    BOOLEAN homeFlag;       // Flag to trigger the homing routine
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,-1,0,0,FALSE},  // @FLAG: Y-Axis passes -pole during cooldown
....................    {0,0,0,0,0,0,0, 0,0,0,FALSE}
.................... };
.................... 
.................... BOOLEAN adcFilter = TRUE;
.................... 
.................... struct dacV
.................... {
....................     BOOLEAN invV;
....................     unsigned int16 ipVal;
....................     float opPcnt;
....................    
.................... }dacVals[2] = 
.................... {
....................     {FALSE,0,0},
....................     {FALSE,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <ADS1220.h>
.................... #ifndef ADS1220
.................... #define ADS1220
.................... 
.................... /*****************************************************************************/
.................... /* SET UP PORTS FOR USE WITH DRIVER                                          */
.................... /*****************************************************************************/
.................... #define _CS0  PIN_D5 // chip select pins 
.................... #define _CS1  PIN_D6
.................... #define _CS2  PIN_D7
.................... #define _CS3  PIN_B0
.................... 
.................... #pin_select SCK2=PIN_B1
.................... #pin_select SDI2=PIN_B2
.................... #pin_select SDO2=PIN_B3
.................... #use spi(MASTER, SPI2, BAUD=4096000, MODE=1, STREAM=SPI_mon)
.................... //!setup_spi2(SPI_MASTER | SPI_SCK_IDLE_LOW | SPI_XMIT_H_TO_L | SPI_CLK_DIV_64);
.................... 
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* REGISTER DEFINITIONS                                                      */
.................... /*****************************************************************************/
.................... typedef enum {reg0 = 0x00,reg1 = 0x04 ,reg2 = 0x08, reg3 = 0x0C}adsReg;
.................... 
.................... //REGISTER 0 OPTIONS
.................... 
.................... #define IPp0n1 0x00
.................... #define IPp0n2 0x10
.................... #define IPp0n3 0x20
.................... #define IPp1n2 0x30
.................... #define IPp1n3 0x40
.................... #define IPp2n3 0x50
.................... #define IPp1n0 0x60
.................... #define IPp3n2 0x70
.................... #define IPp0nVss 0x80
.................... #define IPp1nVss 0x90
.................... #define IPp2nVss 0xA0
.................... #define IPp3nVss 0xB0
.................... #define IPVrpVrn 0xC0
.................... #define IPVddVss 0xD0
.................... #define IPhalfRail 0xE0
.................... 
.................... #define g1 0x00
.................... #define g2 0x02
.................... #define g4 0x04
.................... #define g8 0x06
.................... #define g16 0x08
.................... #define g32 0x0A
.................... #define g64 0x0C
.................... #define g128 0x0E
.................... 
.................... #define PGAenabled 0x00
.................... #define PGAbypass 0x01
.................... 
.................... //REGISTER 1 OPTIONS
.................... 
.................... #define DRn20 0x00
.................... #define DRn45 0x20
.................... #define DRn90 0x40
.................... #define DRn175 0x60
.................... #define DRn330 0x80
.................... #define DRn600 0xA0
.................... #define DRn1000 0xC0
.................... 
.................... #define MDnormal 0x00
.................... #define MDduty 0x80
.................... #define MDturbo 0x10
.................... 
.................... #define CMsingle 0x00
.................... #define CMcont 0x40
.................... 
.................... #define TSdisable 0x00
.................... #define TSenable 0x20
.................... 
.................... #define BCSoff 0x00
.................... #define BCSon 0x01
.................... 
.................... //REGISTER 2 OPTIONS
.................... 
.................... #define REFinternal 0x00
.................... #define REFp0n0 0x40
.................... #define REFp1n1 0x80
.................... #define REFVddVss 0xC0
.................... 
.................... #define FIRoff 0x00
.................... #define FIR5060 0x10
.................... #define FIR50 0x20
.................... #define FIR60 0x30
.................... 
.................... #define PSWopen 0x00
.................... #define PSWstart 0x08
.................... 
.................... #define Ioff 0x00
.................... #define Iu10 0x01
.................... #define Iu50 0x02
.................... #define Iu100 0x03
.................... #define Iu250 0x04
.................... #define Iu500 0x05
.................... #define Iu1000 0x06
.................... #define Iu1500 0x07  
.................... 
.................... //REGISTER 3 OPTIONS
.................... 
.................... #define I1disabled 0x00
.................... #define I1a0p1 0x20
.................... #define I1a1 0x40
.................... #define I1a2 0x60
.................... #define I1a3n1 0x80
.................... #define I1p0 0xA0
.................... #define I1n0 0xC0
.................... 
.................... #define I2disabled 0x00
.................... #define I2a0p1 0x04
.................... #define I2a1 0x08
.................... #define I2a2 0x0A
.................... #define I2a3n1 0x10
.................... #define I2p0 0x14
.................... #define I2n0 0x18
.................... 
.................... #define drdyPin 0x00
.................... #define doutPin 0x20
.................... 
.................... // REGISTER CONGIGURATIONS FOR THIS APP
.................... #define reg0config IPp1n2|g1|PGAenabled // 0x30//
.................... #define reg1config DRn20|MDturbo|CMsingle|TSDisable|BCSoff //0x10
.................... #define reg2config REFinternal|FIRoff|PSWopen|Ioff //0x30
.................... #define reg3config I1disabled|I2disabled|drdyPin //0x00
.................... 
.................... //COMMANDS
.................... #define ADSreset 0x06
.................... #define ADSstart 0x08
.................... #define ADSpowerDn 0x02
.................... #define ADSreadData 0x10
.................... #define ADSreadReg 0x20
.................... #define ADSwriteReg 0x40
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* DESELECT ALL ADCs                                                         */
.................... /*****************************************************************************/
.................... void ads_deselect_all()
.................... {   
....................    output_high(_CS0); // deselect all chip select pins
*
00138:  MOVLW  1F
0013A:  MOVWF  F8A
0013C:  BSF    F85.5
....................    output_high(_CS1);
0013E:  MOVWF  F8A
00140:  BSF    F85.6
....................    output_high(_CS2);
00142:  MOVWF  F8A
00144:  BSF    F85.7
....................    output_high(_CS3); 
00146:  MOVLW  04
00148:  MOVWF  F88
0014A:  BSF    F83.0
....................    delay_us(10);
0014C:  MOVLW  35
0014E:  MOVWF  00
00150:  DECFSZ 00,F
00152:  BRA    0150
00154:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT DESIRED ADC                                                        */
.................... /*****************************************************************************/
.................... void ads_select_ch(int8 ch)
.................... {
....................    ads_deselect_all();
*
0067C:  RCALL  0138
....................    switch(ch)
0067E:  MOVLB  7
00680:  MOVF   x31,W
00682:  ADDLW  FC
00684:  BC    06B8
00686:  ADDLW  04
00688:  MOVLB  0
0068A:  GOTO   06C4
....................    {
....................       case 0:
....................          output_low(_CS0);
0068E:  MOVLW  1F
00690:  MOVWF  F8A
00692:  BCF    F85.5
....................       break; 
00694:  MOVLB  7
00696:  BRA    06B8
....................       case 1:
....................          output_low(_CS1);
00698:  MOVLW  1F
0069A:  MOVWF  F8A
0069C:  BCF    F85.6
....................       break;   
0069E:  MOVLB  7
006A0:  BRA    06B8
....................       case 2:
....................          output_low(_CS2);
006A2:  MOVLW  1F
006A4:  MOVWF  F8A
006A6:  BCF    F85.7
....................       break;
006A8:  MOVLB  7
006AA:  BRA    06B8
....................       case 3:
....................          output_low(_CS3);
006AC:  MOVLW  04
006AE:  MOVWF  F88
006B0:  BCF    F83.0
....................       break;              
006B2:  MOVLB  7
006B4:  BRA    06B8
006B6:  MOVLB  7
....................    }
....................    delay_us(10);
006B8:  MOVLW  35
006BA:  MOVWF  00
006BC:  DECFSZ 00,F
006BE:  BRA    06BC
006C0:  MOVLB  0
006C2:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT ADC BLOCK (2 ADCs/BLOCK)                                           */
.................... /*****************************************************************************/
.................... void ads_select_block(int8 block)
.................... {
....................    ads_deselect_all();
*
00156:  RCALL  0138
....................    switch(block)
00158:  MOVLB  7
0015A:  MOVF   x88,W
0015C:  XORLW  00
0015E:  MOVLB  0
00160:  BZ    0168
00162:  XORLW  01
00164:  BZ    0174
00166:  BRA    0180
....................    {
....................       case 0:
....................          output_low(_CS0);
00168:  MOVLW  1F
0016A:  MOVWF  F8A
0016C:  BCF    F85.5
....................          output_low(_CS1);
0016E:  MOVWF  F8A
00170:  BCF    F85.6
....................       break; 
00172:  BRA    0180
....................       case 1:         
....................          output_low(_CS2);
00174:  MOVLW  1F
00176:  MOVWF  F8A
00178:  BCF    F85.7
....................          output_low(_CS3);
0017A:  MOVLW  04
0017C:  MOVWF  F88
0017E:  BCF    F83.0
....................       break;         
....................    }
....................    delay_us(10);
00180:  MOVLW  35
00182:  MOVWF  00
00184:  DECFSZ 00,F
00186:  BRA    0184
00188:  GOTO   0192 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT ALL ADCs                                                           */
.................... /*****************************************************************************/
.................... void ads_select_all()
.................... {
....................    output_low(_CS0);
*
007B0:  MOVLW  1F
007B2:  MOVWF  F8A
007B4:  BCF    F85.5
....................    output_low(_CS1);
007B6:  MOVWF  F8A
007B8:  BCF    F85.6
....................    output_low(_CS2);
007BA:  MOVWF  F8A
007BC:  BCF    F85.7
....................    output_low(_CS3);
007BE:  MOVLW  04
007C0:  MOVWF  F88
007C2:  BCF    F83.0
....................    delay_us(10);
007C4:  MOVLW  35
007C6:  MOVWF  00
007C8:  DECFSZ 00,F
007CA:  BRA    07C8
007CC:  GOTO   07D2 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO AN ADC                                          */
.................... /*****************************************************************************/
.................... void ads_write_command(int8 ch, unsigned int8 command)
.................... {
....................    ads_select_ch(ch);
*
006E6:  MOVFF  725,731
006EA:  RCALL  067C
....................    spi_write2(command);
006EC:  MOVLB  E
006EE:  MOVF   x8D,W
006F0:  MOVFF  726,E8D
006F4:  RRCF   x90,W
006F6:  BNC   06F4
006F8:  MOVLB  0
006FA:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO A BLOCK OF ADCs                                 */
.................... /*****************************************************************************/
.................... void ads_write_command_block(int8 block, unsigned int8 command)
.................... {
....................    ads_select_block(block);
*
0018C:  MOVFF  786,788
00190:  BRA    0156
....................    spi_write2(command);
00192:  MOVLB  E
00194:  MOVF   x8D,W
00196:  MOVFF  787,E8D
0019A:  RRCF   x90,W
0019C:  BNC   019A
0019E:  MOVLB  0
001A0:  GOTO   01B2 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO ALL ADCs                                        */
.................... /*****************************************************************************/
.................... void ads_write_command_all(unsigned int8 command)
.................... {
....................    ads_select_all();
*
007D0:  BRA    07B0
....................    spi_write2(command);
007D2:  MOVLB  E
007D4:  MOVF   x8D,W
007D6:  MOVFF  71C,E8D
007DA:  RRCF   x90,W
007DC:  BNC   07DA
007DE:  MOVLB  0
007E0:  GOTO   07EE (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PREPARE TO READ FROM AN ADC                                               */
.................... /*****************************************************************************/
.................... void ads_read_command(int8 ch, unsigned int8 command)
.................... {
....................    ads_select_ch(ch);
*
007FC:  MOVFF  72F,731
00800:  RCALL  067C
....................    spi_read2(command);
00802:  MOVLB  E
00804:  MOVF   x8D,W
00806:  MOVFF  730,E8D
0080A:  RRCF   x90,W
0080C:  BNC   080A
0080E:  MOVLB  0
00810:  GOTO   0822 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE TO THE CONFIGURATION REGISTERS                                      */
.................... /*****************************************************************************/
.................... void ads_write_reg(int8 ch, adsReg regID, int8 data)
*
00720:  MOVLB  7
00722:  MOVF   x22,W
00724:  IORLW  40
00726:  MOVWF  x24
.................... {
....................    unsigned int8 command = ADSwriteReg | regID | 0; // 0 is numbytes to write-1
....................    ads_write_command(ch, command);
00728:  MOVFF  721,725
0072C:  MOVFF  724,726
00730:  MOVLB  0
00732:  RCALL  06E6
....................    spi_write2(data);
00734:  MOVLB  E
00736:  MOVF   x8D,W
00738:  MOVFF  723,E8D
0073C:  RRCF   x90,W
0073E:  BNC   073C
....................    ads_deselect_all();
00740:  MOVLB  0
00742:  RCALL  0138
00744:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* READ FROM THE CONFIGURATION REGISTERS                                     */
.................... /*****************************************************************************/
.................... unsigned int8 ads_read_reg(int8 ch, adsReg regID)
.................... {
....................    unsigned int8 command = ADSreadReg | regID | 0;
....................    ads_read_command(ch, command);
....................    unsigned int8 data = spi_read2(0);
....................    ads_deselect_all();
....................    return data;
.................... }
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* START BLOCK CONVERSION                                                    */
.................... /*****************************************************************************/
.................... void ads_start_conv_block(int8 block)
.................... {
....................    ads_write_command_block(block, ADSstart);
*
001A4:  MOVFF  785,786
001A8:  MOVLW  08
001AA:  MOVLB  7
001AC:  MOVWF  x87
001AE:  MOVLB  0
001B0:  BRA    018C
....................    delay_us(10);
001B2:  MOVLW  35
001B4:  MOVWF  00
001B6:  DECFSZ 00,F
001B8:  BRA    01B6
....................    ads_deselect_all();
001BA:  RCALL  0138
001BC:  GOTO   0202 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* START ALL CONVERSION                                                      */
.................... /*****************************************************************************/
.................... void ads_start_conv_all()
.................... {
....................    ads_write_command_all(ADSstart);
*
007E4:  MOVLW  08
007E6:  MOVLB  7
007E8:  MOVWF  x1C
007EA:  MOVLB  0
007EC:  BRA    07D0
....................    delay_us(10);
007EE:  MOVLW  35
007F0:  MOVWF  00
007F2:  DECFSZ 00,F
007F4:  BRA    07F2
....................    ads_deselect_all();
007F6:  RCALL  0138
007F8:  GOTO   097E (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* READ THE MOST RECENT CONVERSION                                           */
.................... /*****************************************************************************/
.................... signed int32 ads_read_data(int8 ch)
.................... {
....................    union Data
....................    {
....................       unsigned int8 dBytes[4];
....................       signed int32 dWord;
....................    }data;
....................    
....................    ads_read_command(ch, ADSreadData);
*
00814:  MOVFF  72A,72F
00818:  MOVLW  10
0081A:  MOVLB  7
0081C:  MOVWF  x30
0081E:  MOVLB  0
00820:  BRA    07FC
....................    data.dBytes[3] = 0;
00822:  MOVLB  7
00824:  CLRF   x2E
....................    data.dBytes[2] = spi_read2(0);
00826:  MOVLB  E
00828:  MOVF   x8D,W
0082A:  CLRF   x8D
0082C:  RRCF   x90,W
0082E:  BNC   082C
00830:  MOVFF  E8D,72D
....................    data.dBytes[1] = spi_read2(0);
00834:  MOVF   x8D,W
00836:  CLRF   x8D
00838:  RRCF   x90,W
0083A:  BNC   0838
0083C:  MOVFF  E8D,72C
....................    data.dBytes[0] = spi_read2(0);
00840:  MOVF   x8D,W
00842:  CLRF   x8D
00844:  RRCF   x90,W
00846:  BNC   0844
00848:  MOVFF  E8D,72B
....................    
....................    //convert 24-bit 2's complement to 32-bit 2's complement
....................    if (0x80 & data.dBytes[2]) data.dBytes[3] |= 0xFF;
0084C:  MOVLB  7
0084E:  MOVF   x2D,W
00850:  ANDLW  80
00852:  BZ    0858
00854:  MOVLW  FF
00856:  IORWF  x2E,F
....................    
....................    ads_deselect_all();
00858:  MOVLB  0
0085A:  RCALL  0138
....................    return data.dWord;
0085C:  MOVFF  72B,00
00860:  MOVFF  72C,01
00864:  MOVFF  72D,02
00868:  MOVFF  72E,03
0086C:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE A CHANNEL                                                      */
.................... /*****************************************************************************/
.................... 
.................... void ADS1220init(int8 ch, rc0=reg0config, rc1=reg1config, rc2=reg2config, rc3=reg3config)
.................... {
....................    ads_write_command(ch, ADSreset);   //reset the device
*
00746:  MOVFF  71C,725
0074A:  MOVLW  06
0074C:  MOVLB  7
0074E:  MOVWF  x26
00750:  MOVLB  0
00752:  RCALL  06E6
....................    delay_us(300);                    
00754:  MOVLW  02
00756:  MOVLB  7
00758:  MOVWF  x21
0075A:  MOVLW  96
0075C:  MOVWF  x22
0075E:  MOVLB  0
00760:  RCALL  06FC
00762:  MOVLB  7
00764:  DECFSZ x21,F
00766:  BRA    075A
....................    ads_write_reg(ch, reg0, rc0);   //send default configurations
00768:  MOVFF  71C,721
0076C:  CLRF   x22
0076E:  MOVFF  71D,723
00772:  MOVLB  0
00774:  RCALL  0720
....................    ads_write_reg(ch, reg1, rc1);
00776:  MOVFF  71C,721
0077A:  MOVLW  04
0077C:  MOVLB  7
0077E:  MOVWF  x22
00780:  MOVFF  71E,723
00784:  MOVLB  0
00786:  RCALL  0720
....................    ads_write_reg(ch, reg2, rc2);
00788:  MOVFF  71C,721
0078C:  MOVLW  08
0078E:  MOVLB  7
00790:  MOVWF  x22
00792:  MOVFF  71F,723
00796:  MOVLB  0
00798:  RCALL  0720
....................    ads_write_reg(ch, reg3, rc3);  
0079A:  MOVFF  71C,721
0079E:  MOVLW  0C
007A0:  MOVLB  7
007A2:  MOVWF  x22
007A4:  MOVFF  720,723
007A8:  MOVLB  0
007AA:  RCALL  0720
007AC:  GOTO   0958 (RETURN)
.................... }
.................... #endif 
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
*
02DEE:  MOVLB  7
02DF0:  BCF    x6B.0
....................    y = x;
02DF2:  MOVFF  75F,764
02DF6:  MOVFF  75E,763
02DFA:  MOVFF  75D,762
02DFE:  MOVFF  75C,761
.................... 
....................    if (x < 0)
02E02:  MOVFF  75F,76F
02E06:  MOVFF  75E,76E
02E0A:  MOVFF  75D,76D
02E0E:  MOVFF  75C,76C
02E12:  CLRF   x73
02E14:  CLRF   x72
02E16:  CLRF   x71
02E18:  CLRF   x70
02E1A:  MOVLB  0
02E1C:  CALL   0D62
02E20:  BNC   2E2E
....................    {
....................       s = 1;
02E22:  MOVLB  7
02E24:  BSF    x6B.0
....................       y = -y;
02E26:  MOVF   x62,W
02E28:  XORLW  80
02E2A:  MOVWF  x62
02E2C:  MOVLB  0
....................    }
.................... 
....................    if (y <= 32768.0)
02E2E:  MOVFF  764,76F
02E32:  MOVFF  763,76E
02E36:  MOVFF  762,76D
02E3A:  MOVFF  761,76C
02E3E:  MOVLB  7
02E40:  CLRF   x73
02E42:  CLRF   x72
02E44:  CLRF   x71
02E46:  MOVLW  8E
02E48:  MOVWF  x70
02E4A:  MOVLB  0
02E4C:  CALL   0D62
02E50:  BC    2E54
02E52:  BNZ   2E84
....................       res = (float32)(unsigned int16)y;
02E54:  MOVFF  764,76F
02E58:  MOVFF  763,76E
02E5C:  MOVFF  762,76D
02E60:  MOVFF  761,76C
02E64:  CALL   120C
02E68:  MOVFF  02,771
02E6C:  MOVFF  01,770
02E70:  RCALL  2DB8
02E72:  MOVFF  03,768
02E76:  MOVFF  02,767
02E7A:  MOVFF  01,766
02E7E:  MOVFF  00,765
02E82:  BRA    3024
.................... 
....................  else if (y < 10000000.0)
02E84:  MOVFF  764,76F
02E88:  MOVFF  763,76E
02E8C:  MOVFF  762,76D
02E90:  MOVFF  761,76C
02E94:  MOVLW  80
02E96:  MOVLB  7
02E98:  MOVWF  x73
02E9A:  MOVLW  96
02E9C:  MOVWF  x72
02E9E:  MOVLW  18
02EA0:  MOVWF  x71
02EA2:  MOVLW  96
02EA4:  MOVWF  x70
02EA6:  MOVLB  0
02EA8:  CALL   0D62
02EAC:  BTFSS  FD8.0
02EAE:  BRA    3014
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
02EB0:  MOVFF  764,76F
02EB4:  MOVFF  763,76E
02EB8:  MOVFF  762,76D
02EBC:  MOVFF  761,76C
02EC0:  MOVLB  7
02EC2:  CLRF   x73
02EC4:  CLRF   x72
02EC6:  CLRF   x71
02EC8:  MOVLW  70
02ECA:  MOVWF  x70
02ECC:  MOVLB  0
02ECE:  CALL   1116
02ED2:  MOVFF  03,76F
02ED6:  MOVFF  02,76E
02EDA:  MOVFF  01,76D
02EDE:  MOVFF  00,76C
02EE2:  CALL   120C
02EE6:  MOVFF  02,76A
02EEA:  MOVFF  01,769
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
02EEE:  MOVFF  764,76F
02EF2:  MOVFF  763,76E
02EF6:  MOVFF  762,76D
02EFA:  MOVFF  761,76C
02EFE:  MOVLB  7
02F00:  CLRF   x73
02F02:  CLRF   x72
02F04:  CLRF   x71
02F06:  MOVLW  70
02F08:  MOVWF  x70
02F0A:  MOVLB  0
02F0C:  CALL   1116
02F10:  MOVFF  03,76F
02F14:  MOVFF  02,76E
02F18:  MOVFF  01,76D
02F1C:  MOVFF  00,76C
02F20:  MOVFF  76A,771
02F24:  MOVFF  769,770
02F28:  RCALL  2DB8
02F2A:  BSF    FD8.1
02F2C:  MOVFF  76F,773
02F30:  MOVFF  76E,772
02F34:  MOVFF  76D,771
02F38:  MOVFF  76C,770
02F3C:  MOVFF  03,777
02F40:  MOVFF  02,776
02F44:  MOVFF  01,775
02F48:  MOVFF  00,774
02F4C:  CALL   0DDC
02F50:  MOVLB  7
02F52:  CLRF   x6F
02F54:  CLRF   x6E
02F56:  CLRF   x6D
02F58:  MOVLW  8E
02F5A:  MOVWF  x6C
02F5C:  MOVFF  03,773
02F60:  MOVFF  02,772
02F64:  MOVFF  01,771
02F68:  MOVFF  00,770
02F6C:  MOVLB  0
02F6E:  CALL   1116
02F72:  MOVFF  03,764
02F76:  MOVFF  02,763
02F7A:  MOVFF  01,762
02F7E:  MOVFF  00,761
....................       res = 32768.0*(float32)l;
02F82:  MOVFF  76A,771
02F86:  MOVFF  769,770
02F8A:  RCALL  2DB8
02F8C:  MOVLB  7
02F8E:  CLRF   x6F
02F90:  CLRF   x6E
02F92:  CLRF   x6D
02F94:  MOVLW  8E
02F96:  MOVWF  x6C
02F98:  MOVFF  03,773
02F9C:  MOVFF  02,772
02FA0:  MOVFF  01,771
02FA4:  MOVFF  00,770
02FA8:  MOVLB  0
02FAA:  CALL   1116
02FAE:  MOVFF  03,768
02FB2:  MOVFF  02,767
02FB6:  MOVFF  01,766
02FBA:  MOVFF  00,765
....................       res += (float32)(unsigned int16)y;
02FBE:  MOVFF  764,76F
02FC2:  MOVFF  763,76E
02FC6:  MOVFF  762,76D
02FCA:  MOVFF  761,76C
02FCE:  CALL   120C
02FD2:  MOVFF  02,771
02FD6:  MOVFF  01,770
02FDA:  RCALL  2DB8
02FDC:  BCF    FD8.1
02FDE:  MOVFF  768,773
02FE2:  MOVFF  767,772
02FE6:  MOVFF  766,771
02FEA:  MOVFF  765,770
02FEE:  MOVFF  03,777
02FF2:  MOVFF  02,776
02FF6:  MOVFF  01,775
02FFA:  MOVFF  00,774
02FFE:  CALL   0DDC
03002:  MOVFF  03,768
03006:  MOVFF  02,767
0300A:  MOVFF  01,766
0300E:  MOVFF  00,765
....................    }
03012:  BRA    3024
.................... 
....................  else
....................   res = y;
03014:  MOVFF  764,768
03018:  MOVFF  763,767
0301C:  MOVFF  762,766
03020:  MOVFF  761,765
.................... 
....................  y = y - (float32)(unsigned int16)y;
03024:  MOVFF  764,76F
03028:  MOVFF  763,76E
0302C:  MOVFF  762,76D
03030:  MOVFF  761,76C
03034:  CALL   120C
03038:  MOVFF  02,771
0303C:  MOVFF  01,770
03040:  RCALL  2DB8
03042:  BSF    FD8.1
03044:  MOVFF  764,773
03048:  MOVFF  763,772
0304C:  MOVFF  762,771
03050:  MOVFF  761,770
03054:  MOVFF  03,777
03058:  MOVFF  02,776
0305C:  MOVFF  01,775
03060:  MOVFF  00,774
03064:  CALL   0DDC
03068:  MOVFF  03,764
0306C:  MOVFF  02,763
03070:  MOVFF  01,762
03074:  MOVFF  00,761
.................... 
....................  if (s)
03078:  MOVLB  7
0307A:  BTFSS  x6B.0
0307C:  BRA    3084
....................   res = -res;
0307E:  MOVF   x66,W
03080:  XORLW  80
03082:  MOVWF  x66
.................... 
....................  if (y != 0)
03084:  MOVFF  764,76F
03088:  MOVFF  763,76E
0308C:  MOVFF  762,76D
03090:  MOVFF  761,76C
03094:  CLRF   x73
03096:  CLRF   x72
03098:  CLRF   x71
0309A:  CLRF   x70
0309C:  MOVLB  0
0309E:  CALL   0D62
030A2:  BZ    311C
....................  {
....................   if (s == 1 && n == 0)
030A4:  MOVLB  7
030A6:  BTFSS  x6B.0
030A8:  BRA    30E2
030AA:  MOVF   x60,F
030AC:  BNZ   30E2
....................    res -= 1.0;
030AE:  BSF    FD8.1
030B0:  MOVFF  768,773
030B4:  MOVFF  767,772
030B8:  MOVFF  766,771
030BC:  MOVFF  765,770
030C0:  CLRF   x77
030C2:  CLRF   x76
030C4:  CLRF   x75
030C6:  MOVLW  7F
030C8:  MOVWF  x74
030CA:  MOVLB  0
030CC:  CALL   0DDC
030D0:  MOVFF  03,768
030D4:  MOVFF  02,767
030D8:  MOVFF  01,766
030DC:  MOVFF  00,765
030E0:  MOVLB  7
.................... 
....................   if (s == 0 && n == 1)
030E2:  BTFSC  x6B.0
030E4:  BRA    311E
030E6:  DECFSZ x60,W
030E8:  BRA    311E
....................    res += 1.0;
030EA:  BCF    FD8.1
030EC:  MOVFF  768,773
030F0:  MOVFF  767,772
030F4:  MOVFF  766,771
030F8:  MOVFF  765,770
030FC:  CLRF   x77
030FE:  CLRF   x76
03100:  CLRF   x75
03102:  MOVLW  7F
03104:  MOVWF  x74
03106:  MOVLB  0
03108:  CALL   0DDC
0310C:  MOVFF  03,768
03110:  MOVFF  02,767
03114:  MOVFF  01,766
03118:  MOVFF  00,765
0311C:  MOVLB  7
....................  }
....................  if (x == 0)
0311E:  MOVFF  75F,76F
03122:  MOVFF  75E,76E
03126:  MOVFF  75D,76D
0312A:  MOVFF  75C,76C
0312E:  CLRF   x73
03130:  CLRF   x72
03132:  CLRF   x71
03134:  CLRF   x70
03136:  MOVLB  0
03138:  CALL   0D62
0313C:  BNZ   314A
....................     res = 0;
0313E:  MOVLB  7
03140:  CLRF   x68
03142:  CLRF   x67
03144:  CLRF   x66
03146:  CLRF   x65
03148:  MOVLB  0
.................... 
....................  return (res);
0314A:  MOVFF  765,00
0314E:  MOVFF  766,01
03152:  MOVFF  767,02
03156:  MOVFF  768,03
0315A:  RETURN 0
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
*
0317A:  MOVFF  75B,75F
0317E:  MOVFF  75A,75E
03182:  MOVFF  759,75D
03186:  MOVFF  758,75C
0318A:  MOVLB  7
0318C:  CLRF   x60
0318E:  MOVLB  0
03190:  RCALL  2DEE
03192:  GOTO   329E (RETURN)
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
*
0315C:  MOVFF  75B,75F
03160:  MOVFF  75A,75E
03164:  MOVFF  759,75D
03168:  MOVFF  758,75C
0316C:  MOVLW  01
0316E:  MOVLB  7
03170:  MOVWF  x60
03172:  MOVLB  0
03174:  RCALL  2DEE
03176:  GOTO   3256 (RETURN)
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
*
03196:  MOVFF  74F,76F
0319A:  MOVFF  74E,76E
0319E:  MOVFF  74D,76D
031A2:  MOVFF  74C,76C
031A6:  MOVLB  7
031A8:  CLRF   x73
031AA:  CLRF   x72
031AC:  CLRF   x71
031AE:  CLRF   x70
031B0:  MOVLB  0
031B2:  CALL   0D62
031B6:  BTFSC  FD8.2
031B8:  BRA    32FA
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
031BA:  MOVFF  74B,768
031BE:  MOVFF  74A,767
031C2:  MOVFF  749,766
031C6:  MOVFF  748,765
031CA:  MOVFF  74F,76C
031CE:  MOVFF  74E,76B
031D2:  MOVFF  74D,76A
031D6:  MOVFF  74C,769
031DA:  CALL   242E
031DE:  MOVFF  03,757
031E2:  MOVFF  02,756
031E6:  MOVFF  01,755
031EA:  MOVFF  00,754
031EE:  MOVFF  03,76F
031F2:  MOVFF  02,76E
031F6:  MOVFF  01,76D
031FA:  MOVFF  00,76C
031FE:  MOVLB  7
03200:  CLRF   x73
03202:  CLRF   x72
03204:  CLRF   x71
03206:  CLRF   x70
03208:  MOVLB  0
0320A:  CALL   0D62
0320E:  BNC   3258
03210:  MOVFF  74B,768
03214:  MOVFF  74A,767
03218:  MOVFF  749,766
0321C:  MOVFF  748,765
03220:  MOVFF  74F,76C
03224:  MOVFF  74E,76B
03228:  MOVFF  74D,76A
0322C:  MOVFF  74C,769
03230:  CALL   242E
03234:  MOVFF  03,757
03238:  MOVFF  02,756
0323C:  MOVFF  01,755
03240:  MOVFF  00,754
03244:  MOVFF  03,75B
03248:  MOVFF  02,75A
0324C:  MOVFF  01,759
03250:  MOVFF  00,758
03254:  BRA    315C
03256:  BRA    329E
03258:  MOVFF  74B,768
0325C:  MOVFF  74A,767
03260:  MOVFF  749,766
03264:  MOVFF  748,765
03268:  MOVFF  74F,76C
0326C:  MOVFF  74E,76B
03270:  MOVFF  74D,76A
03274:  MOVFF  74C,769
03278:  CALL   242E
0327C:  MOVFF  03,757
03280:  MOVFF  02,756
03284:  MOVFF  01,755
03288:  MOVFF  00,754
0328C:  MOVFF  03,75B
03290:  MOVFF  02,75A
03294:  MOVFF  01,759
03298:  MOVFF  00,758
0329C:  BRA    317A
0329E:  MOVFF  03,753
032A2:  MOVFF  02,752
032A6:  MOVFF  01,751
032AA:  MOVFF  00,750
....................       return(x-(i*y));
032AE:  MOVFF  753,76F
032B2:  MOVFF  752,76E
032B6:  MOVFF  751,76D
032BA:  MOVFF  750,76C
032BE:  MOVFF  74F,773
032C2:  MOVFF  74E,772
032C6:  MOVFF  74D,771
032CA:  MOVFF  74C,770
032CE:  CALL   1116
032D2:  BSF    FD8.1
032D4:  MOVFF  74B,773
032D8:  MOVFF  74A,772
032DC:  MOVFF  749,771
032E0:  MOVFF  748,770
032E4:  MOVFF  03,777
032E8:  MOVFF  02,776
032EC:  MOVFF  01,775
032F0:  MOVFF  00,774
032F4:  CALL   0DDC
032F8:  BRA    32FA
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
032FA:  RETURN 0
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
*
03690:  MOVFF  74F,76F
03694:  MOVFF  74E,76E
03698:  MOVFF  74D,76D
0369C:  MOVFF  74C,76C
036A0:  MOVLW  3B
036A2:  MOVLB  7
036A4:  MOVWF  x73
036A6:  MOVLW  AA
036A8:  MOVWF  x72
036AA:  MOVLW  38
036AC:  MOVWF  x71
036AE:  MOVLW  7F
036B0:  MOVWF  x70
036B2:  MOVLB  0
036B4:  CALL   1116
036B8:  MOVFF  03,76F
036BC:  MOVFF  02,76E
036C0:  MOVFF  01,76D
036C4:  MOVFF  00,76C
036C8:  CALL   120C
036CC:  MOVFF  01,75C
....................    s = 0;
036D0:  MOVLB  7
036D2:  BCF    x5D.0
....................    y = x;
036D4:  MOVFF  74F,753
036D8:  MOVFF  74E,752
036DC:  MOVFF  74D,751
036E0:  MOVFF  74C,750
.................... 
....................    if (x < 0)
036E4:  MOVFF  74F,76F
036E8:  MOVFF  74E,76E
036EC:  MOVFF  74D,76D
036F0:  MOVFF  74C,76C
036F4:  CLRF   x73
036F6:  CLRF   x72
036F8:  CLRF   x71
036FA:  CLRF   x70
036FC:  MOVLB  0
036FE:  CALL   0D62
03702:  BNC   3712
....................    {
....................       s = 1;
03704:  MOVLB  7
03706:  BSF    x5D.0
....................       n = -n;
03708:  NEGF   x5C
....................       y = -y;
0370A:  MOVF   x51,W
0370C:  XORLW  80
0370E:  MOVWF  x51
03710:  MOVLB  0
....................    }
.................... 
....................    res = 0.0;
03712:  MOVLB  7
03714:  CLRF   x57
03716:  CLRF   x56
03718:  CLRF   x55
0371A:  CLRF   x54
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
0371C:  MOVLW  07
0371E:  MOVWF  x5F
03720:  MOVLW  54
03722:  MOVFF  75F,FEA
03726:  MOVWF  FE9
03728:  MOVLW  7F
0372A:  ADDWF  x5C,W
0372C:  MOVWF  FEF
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
0372E:  MOVFF  753,76F
03732:  MOVFF  752,76E
03736:  MOVFF  751,76D
0373A:  MOVFF  750,76C
0373E:  MOVLW  3B
03740:  MOVWF  x73
03742:  MOVLW  AA
03744:  MOVWF  x72
03746:  MOVLW  38
03748:  MOVWF  x71
0374A:  MOVLW  7F
0374C:  MOVWF  x70
0374E:  MOVLB  0
03750:  CALL   1116
03754:  MOVFF  03,761
03758:  MOVFF  02,760
0375C:  MOVFF  01,75F
03760:  MOVFF  00,75E
03764:  MOVLB  7
03766:  CLRF   x63
03768:  MOVFF  75C,762
0376C:  BTFSC  x62.7
0376E:  DECF   x63,F
03770:  MOVLB  0
03772:  CALL   2D68
03776:  BSF    FD8.1
03778:  MOVFF  761,773
0377C:  MOVFF  760,772
03780:  MOVFF  75F,771
03784:  MOVFF  75E,770
03788:  MOVFF  03,777
0378C:  MOVFF  02,776
03790:  MOVFF  01,775
03794:  MOVFF  00,774
03798:  CALL   0DDC
0379C:  MOVFF  03,753
037A0:  MOVFF  02,752
037A4:  MOVFF  01,751
037A8:  MOVFF  00,750
.................... 
....................    r = pe[0]*y + pe[1];
037AC:  MOVLW  7C
037AE:  MOVLB  7
037B0:  MOVWF  x6F
037B2:  MOVLW  88
037B4:  MOVWF  x6E
037B6:  MOVLW  59
037B8:  MOVWF  x6D
037BA:  MOVLW  72
037BC:  MOVWF  x6C
037BE:  MOVFF  753,773
037C2:  MOVFF  752,772
037C6:  MOVFF  751,771
037CA:  MOVFF  750,770
037CE:  MOVLB  0
037D0:  CALL   1116
037D4:  MOVFF  03,761
037D8:  MOVFF  02,760
037DC:  MOVFF  01,75F
037E0:  MOVFF  00,75E
037E4:  BCF    FD8.1
037E6:  MOVFF  03,773
037EA:  MOVFF  02,772
037EE:  MOVFF  01,771
037F2:  MOVFF  00,770
037F6:  MOVLW  E0
037F8:  MOVLB  7
037FA:  MOVWF  x77
037FC:  MOVLW  97
037FE:  MOVWF  x76
03800:  MOVLW  26
03802:  MOVWF  x75
03804:  MOVLW  75
03806:  MOVWF  x74
03808:  MOVLB  0
0380A:  CALL   0DDC
0380E:  MOVFF  03,75B
03812:  MOVFF  02,75A
03816:  MOVFF  01,759
0381A:  MOVFF  00,758
....................    r = r*y + pe[2];
0381E:  MOVFF  75B,76F
03822:  MOVFF  75A,76E
03826:  MOVFF  759,76D
0382A:  MOVFF  758,76C
0382E:  MOVFF  753,773
03832:  MOVFF  752,772
03836:  MOVFF  751,771
0383A:  MOVFF  750,770
0383E:  CALL   1116
03842:  MOVFF  03,761
03846:  MOVFF  02,760
0384A:  MOVFF  01,75F
0384E:  MOVFF  00,75E
03852:  BCF    FD8.1
03854:  MOVFF  03,773
03858:  MOVFF  02,772
0385C:  MOVFF  01,771
03860:  MOVFF  00,770
03864:  MOVLW  C4
03866:  MOVLB  7
03868:  MOVWF  x77
0386A:  MOVLW  1D
0386C:  MOVWF  x76
0386E:  MOVLW  1E
03870:  MOVWF  x75
03872:  MOVLW  78
03874:  MOVWF  x74
03876:  MOVLB  0
03878:  CALL   0DDC
0387C:  MOVFF  03,75B
03880:  MOVFF  02,75A
03884:  MOVFF  01,759
03888:  MOVFF  00,758
....................    r = r*y + pe[3];
0388C:  MOVFF  75B,76F
03890:  MOVFF  75A,76E
03894:  MOVFF  759,76D
03898:  MOVFF  758,76C
0389C:  MOVFF  753,773
038A0:  MOVFF  752,772
038A4:  MOVFF  751,771
038A8:  MOVFF  750,770
038AC:  CALL   1116
038B0:  MOVFF  03,761
038B4:  MOVFF  02,760
038B8:  MOVFF  01,75F
038BC:  MOVFF  00,75E
038C0:  BCF    FD8.1
038C2:  MOVFF  03,773
038C6:  MOVFF  02,772
038CA:  MOVFF  01,771
038CE:  MOVFF  00,770
038D2:  MOVLW  5E
038D4:  MOVLB  7
038D6:  MOVWF  x77
038D8:  MOVLW  50
038DA:  MOVWF  x76
038DC:  MOVLW  63
038DE:  MOVWF  x75
038E0:  MOVLW  7A
038E2:  MOVWF  x74
038E4:  MOVLB  0
038E6:  CALL   0DDC
038EA:  MOVFF  03,75B
038EE:  MOVFF  02,75A
038F2:  MOVFF  01,759
038F6:  MOVFF  00,758
....................    r = r*y + pe[4];
038FA:  MOVFF  75B,76F
038FE:  MOVFF  75A,76E
03902:  MOVFF  759,76D
03906:  MOVFF  758,76C
0390A:  MOVFF  753,773
0390E:  MOVFF  752,772
03912:  MOVFF  751,771
03916:  MOVFF  750,770
0391A:  CALL   1116
0391E:  MOVFF  03,761
03922:  MOVFF  02,760
03926:  MOVFF  01,75F
0392A:  MOVFF  00,75E
0392E:  BCF    FD8.1
03930:  MOVFF  03,773
03934:  MOVFF  02,772
03938:  MOVFF  01,771
0393C:  MOVFF  00,770
03940:  MOVLW  1A
03942:  MOVLB  7
03944:  MOVWF  x77
03946:  MOVLW  FE
03948:  MOVWF  x76
0394A:  MOVLW  75
0394C:  MOVWF  x75
0394E:  MOVLW  7C
03950:  MOVWF  x74
03952:  MOVLB  0
03954:  CALL   0DDC
03958:  MOVFF  03,75B
0395C:  MOVFF  02,75A
03960:  MOVFF  01,759
03964:  MOVFF  00,758
....................    r = r*y + pe[5];
03968:  MOVFF  75B,76F
0396C:  MOVFF  75A,76E
03970:  MOVFF  759,76D
03974:  MOVFF  758,76C
03978:  MOVFF  753,773
0397C:  MOVFF  752,772
03980:  MOVFF  751,771
03984:  MOVFF  750,770
03988:  CALL   1116
0398C:  MOVFF  03,761
03990:  MOVFF  02,760
03994:  MOVFF  01,75F
03998:  MOVFF  00,75E
0399C:  BCF    FD8.1
0399E:  MOVFF  03,773
039A2:  MOVFF  02,772
039A6:  MOVFF  01,771
039AA:  MOVFF  00,770
039AE:  MOVLW  18
039B0:  MOVLB  7
039B2:  MOVWF  x77
039B4:  MOVLW  72
039B6:  MOVWF  x76
039B8:  MOVLW  31
039BA:  MOVWF  x75
039BC:  MOVLW  7E
039BE:  MOVWF  x74
039C0:  MOVLB  0
039C2:  CALL   0DDC
039C6:  MOVFF  03,75B
039CA:  MOVFF  02,75A
039CE:  MOVFF  01,759
039D2:  MOVFF  00,758
.................... 
....................    res = res*(1.0 + y*r);
039D6:  MOVFF  753,76F
039DA:  MOVFF  752,76E
039DE:  MOVFF  751,76D
039E2:  MOVFF  750,76C
039E6:  MOVFF  75B,773
039EA:  MOVFF  75A,772
039EE:  MOVFF  759,771
039F2:  MOVFF  758,770
039F6:  CALL   1116
039FA:  BCF    FD8.1
039FC:  MOVLB  7
039FE:  CLRF   x73
03A00:  CLRF   x72
03A02:  CLRF   x71
03A04:  MOVLW  7F
03A06:  MOVWF  x70
03A08:  MOVFF  03,777
03A0C:  MOVFF  02,776
03A10:  MOVFF  01,775
03A14:  MOVFF  00,774
03A18:  MOVLB  0
03A1A:  CALL   0DDC
03A1E:  MOVFF  757,76F
03A22:  MOVFF  756,76E
03A26:  MOVFF  755,76D
03A2A:  MOVFF  754,76C
03A2E:  MOVFF  03,773
03A32:  MOVFF  02,772
03A36:  MOVFF  01,771
03A3A:  MOVFF  00,770
03A3E:  CALL   1116
03A42:  MOVFF  03,757
03A46:  MOVFF  02,756
03A4A:  MOVFF  01,755
03A4E:  MOVFF  00,754
.................... 
....................    if (s)
03A52:  MOVLB  7
03A54:  BTFSS  x5D.0
03A56:  BRA    3A8A
....................       res = 1.0/res;
03A58:  CLRF   x68
03A5A:  CLRF   x67
03A5C:  CLRF   x66
03A5E:  MOVLW  7F
03A60:  MOVWF  x65
03A62:  MOVFF  757,76C
03A66:  MOVFF  756,76B
03A6A:  MOVFF  755,76A
03A6E:  MOVFF  754,769
03A72:  MOVLB  0
03A74:  CALL   242E
03A78:  MOVFF  03,757
03A7C:  MOVFF  02,756
03A80:  MOVFF  01,755
03A84:  MOVFF  00,754
03A88:  MOVLB  7
....................    return(res);
03A8A:  MOVFF  754,00
03A8E:  MOVFF  755,01
03A92:  MOVFF  756,02
03A96:  MOVFF  757,03
03A9A:  MOVLB  0
03A9C:  RETURN 0
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
*
032FC:  MOVFF  74F,753
03300:  MOVFF  74E,752
03304:  MOVFF  74D,751
03308:  MOVFF  74C,750
.................... 
....................    if (y != 1.0)
0330C:  MOVFF  753,76F
03310:  MOVFF  752,76E
03314:  MOVFF  751,76D
03318:  MOVFF  750,76C
0331C:  MOVLB  7
0331E:  CLRF   x73
03320:  CLRF   x72
03322:  CLRF   x71
03324:  MOVLW  7F
03326:  MOVWF  x70
03328:  MOVLB  0
0332A:  CALL   0D62
0332E:  BTFSC  FD8.2
03330:  BRA    3672
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
03332:  MOVLW  07
03334:  MOVLB  7
03336:  MOVWF  x62
03338:  MOVLW  50
0333A:  MOVFF  762,FEA
0333E:  MOVWF  FE9
03340:  MOVLW  7E
03342:  MOVWF  FEF
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
03344:  BSF    FD8.1
03346:  MOVFF  753,773
0334A:  MOVFF  752,772
0334E:  MOVFF  751,771
03352:  MOVFF  750,770
03356:  CLRF   x77
03358:  CLRF   x76
0335A:  CLRF   x75
0335C:  MOVLW  7F
0335E:  MOVWF  x74
03360:  MOVLB  0
03362:  CALL   0DDC
03366:  MOVFF  03,764
0336A:  MOVFF  02,763
0336E:  MOVFF  01,762
03372:  MOVFF  00,761
03376:  BCF    FD8.1
03378:  MOVFF  753,773
0337C:  MOVFF  752,772
03380:  MOVFF  751,771
03384:  MOVFF  750,770
03388:  MOVLB  7
0338A:  CLRF   x77
0338C:  CLRF   x76
0338E:  CLRF   x75
03390:  MOVLW  7F
03392:  MOVWF  x74
03394:  MOVLB  0
03396:  CALL   0DDC
0339A:  MOVFF  764,768
0339E:  MOVFF  763,767
033A2:  MOVFF  762,766
033A6:  MOVFF  761,765
033AA:  MOVFF  03,76C
033AE:  MOVFF  02,76B
033B2:  MOVFF  01,76A
033B6:  MOVFF  00,769
033BA:  CALL   242E
033BE:  MOVFF  03,753
033C2:  MOVFF  02,752
033C6:  MOVFF  01,751
033CA:  MOVFF  00,750
.................... 
....................       y2=y*y;
033CE:  MOVFF  753,76F
033D2:  MOVFF  752,76E
033D6:  MOVFF  751,76D
033DA:  MOVFF  750,76C
033DE:  MOVFF  753,773
033E2:  MOVFF  752,772
033E6:  MOVFF  751,771
033EA:  MOVFF  750,770
033EE:  CALL   1116
033F2:  MOVFF  03,75F
033F6:  MOVFF  02,75E
033FA:  MOVFF  01,75D
033FE:  MOVFF  00,75C
.................... 
....................       res = pl[0]*y2 + pl[1];
03402:  MOVLW  99
03404:  MOVLB  7
03406:  MOVWF  x6F
03408:  MOVLW  47
0340A:  MOVWF  x6E
0340C:  MOVLW  8A
0340E:  MOVWF  x6D
03410:  MOVLW  7F
03412:  MOVWF  x6C
03414:  MOVFF  75F,773
03418:  MOVFF  75E,772
0341C:  MOVFF  75D,771
03420:  MOVFF  75C,770
03424:  MOVLB  0
03426:  CALL   1116
0342A:  MOVFF  03,764
0342E:  MOVFF  02,763
03432:  MOVFF  01,762
03436:  MOVFF  00,761
0343A:  BCF    FD8.1
0343C:  MOVFF  03,773
03440:  MOVFF  02,772
03444:  MOVFF  01,771
03448:  MOVFF  00,770
0344C:  MOVLB  7
0344E:  CLRF   x77
03450:  CLRF   x76
03452:  CLRF   x75
03454:  MOVLW  80
03456:  MOVWF  x74
03458:  MOVLB  0
0345A:  CALL   0DDC
0345E:  MOVFF  03,757
03462:  MOVFF  02,756
03466:  MOVFF  01,755
0346A:  MOVFF  00,754
.................... 
....................       r = ql[0]*y2 + ql[1];
0346E:  MOVLW  4C
03470:  MOVLB  7
03472:  MOVWF  x6F
03474:  MOVLW  F3
03476:  MOVWF  x6E
03478:  MOVLW  3A
0347A:  MOVWF  x6D
0347C:  MOVLW  7B
0347E:  MOVWF  x6C
03480:  MOVFF  75F,773
03484:  MOVFF  75E,772
03488:  MOVFF  75D,771
0348C:  MOVFF  75C,770
03490:  MOVLB  0
03492:  CALL   1116
03496:  MOVFF  03,764
0349A:  MOVFF  02,763
0349E:  MOVFF  01,762
034A2:  MOVFF  00,761
034A6:  BCF    FD8.1
034A8:  MOVFF  03,773
034AC:  MOVFF  02,772
034B0:  MOVFF  01,771
034B4:  MOVFF  00,770
034B8:  MOVLW  2B
034BA:  MOVLB  7
034BC:  MOVWF  x77
034BE:  MOVLW  9D
034C0:  MOVWF  x76
034C2:  MOVLW  DF
034C4:  MOVWF  x75
034C6:  MOVLW  7E
034C8:  MOVWF  x74
034CA:  MOVLB  0
034CC:  CALL   0DDC
034D0:  MOVFF  03,75B
034D4:  MOVFF  02,75A
034D8:  MOVFF  01,759
034DC:  MOVFF  00,758
....................       r = r*y2 + 1.0;
034E0:  MOVFF  75B,76F
034E4:  MOVFF  75A,76E
034E8:  MOVFF  759,76D
034EC:  MOVFF  758,76C
034F0:  MOVFF  75F,773
034F4:  MOVFF  75E,772
034F8:  MOVFF  75D,771
034FC:  MOVFF  75C,770
03500:  CALL   1116
03504:  MOVFF  03,764
03508:  MOVFF  02,763
0350C:  MOVFF  01,762
03510:  MOVFF  00,761
03514:  BCF    FD8.1
03516:  MOVFF  03,773
0351A:  MOVFF  02,772
0351E:  MOVFF  01,771
03522:  MOVFF  00,770
03526:  MOVLB  7
03528:  CLRF   x77
0352A:  CLRF   x76
0352C:  CLRF   x75
0352E:  MOVLW  7F
03530:  MOVWF  x74
03532:  MOVLB  0
03534:  CALL   0DDC
03538:  MOVFF  03,75B
0353C:  MOVFF  02,75A
03540:  MOVFF  01,759
03544:  MOVFF  00,758
.................... 
....................       res = y*res/r;
03548:  MOVFF  753,76F
0354C:  MOVFF  752,76E
03550:  MOVFF  751,76D
03554:  MOVFF  750,76C
03558:  MOVFF  757,773
0355C:  MOVFF  756,772
03560:  MOVFF  755,771
03564:  MOVFF  754,770
03568:  CALL   1116
0356C:  MOVFF  03,764
03570:  MOVFF  02,763
03574:  MOVFF  01,762
03578:  MOVFF  00,761
0357C:  MOVFF  03,768
03580:  MOVFF  02,767
03584:  MOVFF  01,766
03588:  MOVFF  00,765
0358C:  MOVFF  75B,76C
03590:  MOVFF  75A,76B
03594:  MOVFF  759,76A
03598:  MOVFF  758,769
0359C:  CALL   242E
035A0:  MOVFF  03,757
035A4:  MOVFF  02,756
035A8:  MOVFF  01,755
035AC:  MOVFF  00,754
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
035B0:  MOVLW  07
035B2:  MOVLB  7
035B4:  MOVWF  x62
035B6:  MOVLW  4C
035B8:  MOVFF  762,FEA
035BC:  MOVWF  FE9
035BE:  MOVLW  7E
035C0:  SUBWF  FEF,W
035C2:  MOVWF  x60
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
035C4:  BTFSS  x60.7
035C6:  BRA    35F2
....................          r = -(float32)-n;
035C8:  MOVLW  00
035CA:  BSF    FD8.0
035CC:  SUBFWB x60,W
035CE:  CLRF   x63
035D0:  MOVWF  x62
035D2:  BTFSC  x62.7
035D4:  DECF   x63,F
035D6:  MOVLB  0
035D8:  CALL   2D68
035DC:  MOVFF  00,758
035E0:  MOVF   01,W
035E2:  XORLW  80
035E4:  MOVLB  7
035E6:  MOVWF  x59
035E8:  MOVFF  02,75A
035EC:  MOVFF  03,75B
035F0:  BRA    3614
....................       else
....................          r = (float32)n;
035F2:  CLRF   x63
035F4:  MOVFF  760,762
035F8:  BTFSC  x62.7
035FA:  DECF   x63,F
035FC:  MOVLB  0
035FE:  CALL   2D68
03602:  MOVFF  03,75B
03606:  MOVFF  02,75A
0360A:  MOVFF  01,759
0360E:  MOVFF  00,758
03612:  MOVLB  7
.................... 
....................       res += r*LN2;
03614:  MOVFF  75B,76F
03618:  MOVFF  75A,76E
0361C:  MOVFF  759,76D
03620:  MOVFF  758,76C
03624:  MOVLW  18
03626:  MOVWF  x73
03628:  MOVLW  72
0362A:  MOVWF  x72
0362C:  MOVLW  31
0362E:  MOVWF  x71
03630:  MOVLW  7E
03632:  MOVWF  x70
03634:  MOVLB  0
03636:  CALL   1116
0363A:  BCF    FD8.1
0363C:  MOVFF  757,773
03640:  MOVFF  756,772
03644:  MOVFF  755,771
03648:  MOVFF  754,770
0364C:  MOVFF  03,777
03650:  MOVFF  02,776
03654:  MOVFF  01,775
03658:  MOVFF  00,774
0365C:  CALL   0DDC
03660:  MOVFF  03,757
03664:  MOVFF  02,756
03668:  MOVFF  01,755
0366C:  MOVFF  00,754
....................    }
03670:  BRA    367E
.................... 
....................    else
....................       res = 0.0;
03672:  MOVLB  7
03674:  CLRF   x57
03676:  CLRF   x56
03678:  CLRF   x55
0367A:  CLRF   x54
0367C:  MOVLB  0
.................... 
....................    return(res);
0367E:  MOVFF  754,00
03682:  MOVFF  755,01
03686:  MOVFF  756,02
0368A:  MOVFF  757,03
0368E:  RETURN 0
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
*
03A9E:  MOVFF  743,76F
03AA2:  MOVFF  742,76E
03AA6:  MOVFF  741,76D
03AAA:  MOVFF  740,76C
03AAE:  MOVLB  7
03AB0:  CLRF   x73
03AB2:  CLRF   x72
03AB4:  CLRF   x71
03AB6:  CLRF   x70
03AB8:  MOVLB  0
03ABA:  CALL   0D62
03ABE:  BTFSS  FD8.0
03AC0:  BRA    3C5C
03AC2:  MOVFF  747,74B
03AC6:  MOVFF  746,74A
03ACA:  MOVFF  745,749
03ACE:  MOVFF  744,748
03AD2:  MOVLB  7
03AD4:  CLRF   x4F
03AD6:  CLRF   x4E
03AD8:  CLRF   x4D
03ADA:  MOVLW  7F
03ADC:  MOVWF  x4C
03ADE:  MOVLB  0
03AE0:  CALL   3196
03AE4:  MOVFF  03,74B
03AE8:  MOVFF  02,74A
03AEC:  MOVFF  01,749
03AF0:  MOVFF  00,748
03AF4:  MOVFF  03,76F
03AF8:  MOVFF  02,76E
03AFC:  MOVFF  01,76D
03B00:  MOVFF  00,76C
03B04:  MOVLB  7
03B06:  CLRF   x73
03B08:  CLRF   x72
03B0A:  CLRF   x71
03B0C:  CLRF   x70
03B0E:  MOVLB  0
03B10:  CALL   0D62
03B14:  BTFSS  FD8.2
03B16:  BRA    3C5C
....................       if(fmod(y, 2) == 0) {
03B18:  MOVFF  747,74B
03B1C:  MOVFF  746,74A
03B20:  MOVFF  745,749
03B24:  MOVFF  744,748
03B28:  MOVLB  7
03B2A:  CLRF   x4F
03B2C:  CLRF   x4E
03B2E:  CLRF   x4D
03B30:  MOVLW  80
03B32:  MOVWF  x4C
03B34:  MOVLB  0
03B36:  CALL   3196
03B3A:  MOVFF  03,74B
03B3E:  MOVFF  02,74A
03B42:  MOVFF  01,749
03B46:  MOVFF  00,748
03B4A:  MOVFF  03,76F
03B4E:  MOVFF  02,76E
03B52:  MOVFF  01,76D
03B56:  MOVFF  00,76C
03B5A:  MOVLB  7
03B5C:  CLRF   x73
03B5E:  CLRF   x72
03B60:  CLRF   x71
03B62:  CLRF   x70
03B64:  MOVLB  0
03B66:  CALL   0D62
03B6A:  BNZ   3BE2
....................          return (exp(log(-x) * y));
03B6C:  MOVLB  7
03B6E:  MOVF   x41,W
03B70:  XORLW  80
03B72:  MOVWF  x49
03B74:  MOVFF  743,74F
03B78:  MOVFF  742,74E
03B7C:  MOVWF  x4D
03B7E:  MOVFF  740,74C
03B82:  MOVLB  0
03B84:  CALL   32FC
03B88:  MOVFF  03,74B
03B8C:  MOVFF  02,74A
03B90:  MOVFF  01,749
03B94:  MOVFF  00,748
03B98:  MOVFF  03,76F
03B9C:  MOVFF  02,76E
03BA0:  MOVFF  01,76D
03BA4:  MOVFF  00,76C
03BA8:  MOVFF  747,773
03BAC:  MOVFF  746,772
03BB0:  MOVFF  745,771
03BB4:  MOVFF  744,770
03BB8:  CALL   1116
03BBC:  MOVFF  03,74B
03BC0:  MOVFF  02,74A
03BC4:  MOVFF  01,749
03BC8:  MOVFF  00,748
03BCC:  MOVFF  03,74F
03BD0:  MOVFF  02,74E
03BD4:  MOVFF  01,74D
03BD8:  MOVFF  00,74C
03BDC:  RCALL  3690
03BDE:  BRA    3D9A
....................       } else {
03BE0:  BRA    3C5A
....................          return (-exp(log(-x) * y));
03BE2:  MOVLB  7
03BE4:  MOVF   x41,W
03BE6:  XORLW  80
03BE8:  MOVWF  x49
03BEA:  MOVFF  743,74F
03BEE:  MOVFF  742,74E
03BF2:  MOVWF  x4D
03BF4:  MOVFF  740,74C
03BF8:  MOVLB  0
03BFA:  CALL   32FC
03BFE:  MOVFF  03,74B
03C02:  MOVFF  02,74A
03C06:  MOVFF  01,749
03C0A:  MOVFF  00,748
03C0E:  MOVFF  03,76F
03C12:  MOVFF  02,76E
03C16:  MOVFF  01,76D
03C1A:  MOVFF  00,76C
03C1E:  MOVFF  747,773
03C22:  MOVFF  746,772
03C26:  MOVFF  745,771
03C2A:  MOVFF  744,770
03C2E:  CALL   1116
03C32:  MOVFF  03,74B
03C36:  MOVFF  02,74A
03C3A:  MOVFF  01,749
03C3E:  MOVFF  00,748
03C42:  MOVFF  03,74F
03C46:  MOVFF  02,74E
03C4A:  MOVFF  01,74D
03C4E:  MOVFF  00,74C
03C52:  RCALL  3690
03C54:  MOVLW  80
03C56:  XORWF  01,F
03C58:  BRA    3D9A
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
03C5A:  BRA    3D9A
03C5C:  MOVFF  743,76F
03C60:  MOVFF  742,76E
03C64:  MOVFF  741,76D
03C68:  MOVFF  740,76C
03C6C:  MOVLB  7
03C6E:  CLRF   x73
03C70:  CLRF   x72
03C72:  CLRF   x71
03C74:  CLRF   x70
03C76:  MOVLB  0
03C78:  CALL   0D62
03C7C:  BNC   3CDE
03C7E:  MOVFF  747,74B
03C82:  MOVFF  746,74A
03C86:  MOVFF  745,749
03C8A:  MOVFF  744,748
03C8E:  MOVLB  7
03C90:  CLRF   x4F
03C92:  CLRF   x4E
03C94:  CLRF   x4D
03C96:  MOVLW  7F
03C98:  MOVWF  x4C
03C9A:  MOVLB  0
03C9C:  CALL   3196
03CA0:  MOVFF  03,74B
03CA4:  MOVFF  02,74A
03CA8:  MOVFF  01,749
03CAC:  MOVFF  00,748
03CB0:  MOVFF  03,76F
03CB4:  MOVFF  02,76E
03CB8:  MOVFF  01,76D
03CBC:  MOVFF  00,76C
03CC0:  MOVLB  7
03CC2:  CLRF   x73
03CC4:  CLRF   x72
03CC6:  CLRF   x71
03CC8:  CLRF   x70
03CCA:  MOVLB  0
03CCC:  CALL   0D62
03CD0:  BZ    3CDE
....................       return 0;
03CD2:  CLRF   00
03CD4:  CLRF   01
03CD6:  CLRF   02
03CD8:  CLRF   03
03CDA:  BRA    3D9A
....................    } else {
03CDC:  BRA    3D9A
....................       if(x != 0 || 0 >= y) {
03CDE:  MOVFF  743,76F
03CE2:  MOVFF  742,76E
03CE6:  MOVFF  741,76D
03CEA:  MOVFF  740,76C
03CEE:  MOVLB  7
03CF0:  CLRF   x73
03CF2:  CLRF   x72
03CF4:  CLRF   x71
03CF6:  CLRF   x70
03CF8:  MOVLB  0
03CFA:  CALL   0D62
03CFE:  BNZ   3D24
03D00:  MOVFF  747,76F
03D04:  MOVFF  746,76E
03D08:  MOVFF  745,76D
03D0C:  MOVFF  744,76C
03D10:  MOVLB  7
03D12:  CLRF   x73
03D14:  CLRF   x72
03D16:  CLRF   x71
03D18:  CLRF   x70
03D1A:  MOVLB  0
03D1C:  CALL   0D62
03D20:  BC    3D24
03D22:  BNZ   3D92
....................          return (exp(log(x) * y));
03D24:  MOVFF  743,74F
03D28:  MOVFF  742,74E
03D2C:  MOVFF  741,74D
03D30:  MOVFF  740,74C
03D34:  CALL   32FC
03D38:  MOVFF  03,74B
03D3C:  MOVFF  02,74A
03D40:  MOVFF  01,749
03D44:  MOVFF  00,748
03D48:  MOVFF  03,76F
03D4C:  MOVFF  02,76E
03D50:  MOVFF  01,76D
03D54:  MOVFF  00,76C
03D58:  MOVFF  747,773
03D5C:  MOVFF  746,772
03D60:  MOVFF  745,771
03D64:  MOVFF  744,770
03D68:  CALL   1116
03D6C:  MOVFF  03,74B
03D70:  MOVFF  02,74A
03D74:  MOVFF  01,749
03D78:  MOVFF  00,748
03D7C:  MOVFF  03,74F
03D80:  MOVFF  02,74E
03D84:  MOVFF  01,74D
03D88:  MOVFF  00,74C
03D8C:  RCALL  3690
03D8E:  BRA    3D9A
....................       } else return 0;
03D90:  BRA    3D9A
03D92:  CLRF   00
03D94:  CLRF   01
03D96:  CLRF   02
03D98:  CLRF   03
....................    }
03D9A:  RETURN 0
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
*
0258C:  MOVLB  7
0258E:  BCF    x5E.0
....................    flag = 0;
02590:  BCF    x5E.1
....................    y = x;
02592:  MOVFF  751,755
02596:  MOVFF  750,754
0259A:  MOVFF  74F,753
0259E:  MOVFF  74E,752
.................... 
....................    if (x < 0)
025A2:  MOVFF  751,76F
025A6:  MOVFF  750,76E
025AA:  MOVFF  74F,76D
025AE:  MOVFF  74E,76C
025B2:  CLRF   x73
025B4:  CLRF   x72
025B6:  CLRF   x71
025B8:  CLRF   x70
025BA:  MOVLB  0
025BC:  CALL   0D62
025C0:  BNC   25CE
....................    {
....................       s = 1;
025C2:  MOVLB  7
025C4:  BSF    x5E.0
....................       y = -y;
025C6:  MOVF   x53,W
025C8:  XORLW  80
025CA:  MOVWF  x53
025CC:  MOVLB  0
....................    }
.................... 
....................    if (y > 1.0)
025CE:  MOVLB  7
025D0:  CLRF   x6F
025D2:  CLRF   x6E
025D4:  CLRF   x6D
025D6:  MOVLW  7F
025D8:  MOVWF  x6C
025DA:  MOVFF  755,773
025DE:  MOVFF  754,772
025E2:  MOVFF  753,771
025E6:  MOVFF  752,770
025EA:  MOVLB  0
025EC:  CALL   0D62
025F0:  BNC   2628
....................    {
....................       y = 1.0/y;
025F2:  MOVLB  7
025F4:  CLRF   x68
025F6:  CLRF   x67
025F8:  CLRF   x66
025FA:  MOVLW  7F
025FC:  MOVWF  x65
025FE:  MOVFF  755,76C
02602:  MOVFF  754,76B
02606:  MOVFF  753,76A
0260A:  MOVFF  752,769
0260E:  MOVLB  0
02610:  RCALL  242E
02612:  MOVFF  03,755
02616:  MOVFF  02,754
0261A:  MOVFF  01,753
0261E:  MOVFF  00,752
....................       flag = 1;
02622:  MOVLB  7
02624:  BSF    x5E.1
02626:  MOVLB  0
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
02628:  MOVLW  0A
0262A:  MOVLB  7
0262C:  MOVWF  x6F
0262E:  MOVLW  89
02630:  MOVWF  x6E
02632:  MOVLW  34
02634:  MOVWF  x6D
02636:  MOVLW  7C
02638:  MOVWF  x6C
0263A:  MOVFF  755,773
0263E:  MOVFF  754,772
02642:  MOVFF  753,771
02646:  MOVFF  752,770
0264A:  MOVLB  0
0264C:  CALL   1116
02650:  MOVFF  03,762
02654:  MOVFF  02,761
02658:  MOVFF  01,760
0265C:  MOVFF  00,75F
02660:  MOVFF  03,76F
02664:  MOVFF  02,76E
02668:  MOVFF  01,76D
0266C:  MOVFF  00,76C
02670:  MOVFF  755,773
02674:  MOVFF  754,772
02678:  MOVFF  753,771
0267C:  MOVFF  752,770
02680:  CALL   1116
02684:  MOVFF  03,762
02688:  MOVFF  02,761
0268C:  MOVFF  01,760
02690:  MOVFF  00,75F
02694:  BCF    FD8.1
02696:  MOVFF  03,773
0269A:  MOVFF  02,772
0269E:  MOVFF  01,771
026A2:  MOVFF  00,770
026A6:  MOVLW  7C
026A8:  MOVLB  7
026AA:  MOVWF  x77
026AC:  MOVLW  79
026AE:  MOVWF  x76
026B0:  MOVLW  35
026B2:  MOVWF  x75
026B4:  MOVLW  81
026B6:  MOVWF  x74
026B8:  MOVLB  0
026BA:  CALL   0DDC
026BE:  MOVFF  03,759
026C2:  MOVFF  02,758
026C6:  MOVFF  01,757
026CA:  MOVFF  00,756
....................    res = res*y*y + pat[2];
026CE:  MOVFF  759,76F
026D2:  MOVFF  758,76E
026D6:  MOVFF  757,76D
026DA:  MOVFF  756,76C
026DE:  MOVFF  755,773
026E2:  MOVFF  754,772
026E6:  MOVFF  753,771
026EA:  MOVFF  752,770
026EE:  CALL   1116
026F2:  MOVFF  03,762
026F6:  MOVFF  02,761
026FA:  MOVFF  01,760
026FE:  MOVFF  00,75F
02702:  MOVFF  03,76F
02706:  MOVFF  02,76E
0270A:  MOVFF  01,76D
0270E:  MOVFF  00,76C
02712:  MOVFF  755,773
02716:  MOVFF  754,772
0271A:  MOVFF  753,771
0271E:  MOVFF  752,770
02722:  CALL   1116
02726:  MOVFF  03,762
0272A:  MOVFF  02,761
0272E:  MOVFF  01,760
02732:  MOVFF  00,75F
02736:  BCF    FD8.1
02738:  MOVFF  03,773
0273C:  MOVFF  02,772
02740:  MOVFF  01,771
02744:  MOVFF  00,770
02748:  MOVLW  3F
0274A:  MOVLB  7
0274C:  MOVWF  x77
0274E:  MOVLW  02
02750:  MOVWF  x76
02752:  MOVLW  33
02754:  MOVWF  x75
02756:  MOVLW  83
02758:  MOVWF  x74
0275A:  MOVLB  0
0275C:  CALL   0DDC
02760:  MOVFF  03,759
02764:  MOVFF  02,758
02768:  MOVFF  01,757
0276C:  MOVFF  00,756
....................    res = res*y*y + pat[3];
02770:  MOVFF  759,76F
02774:  MOVFF  758,76E
02778:  MOVFF  757,76D
0277C:  MOVFF  756,76C
02780:  MOVFF  755,773
02784:  MOVFF  754,772
02788:  MOVFF  753,771
0278C:  MOVFF  752,770
02790:  CALL   1116
02794:  MOVFF  03,762
02798:  MOVFF  02,761
0279C:  MOVFF  01,760
027A0:  MOVFF  00,75F
027A4:  MOVFF  03,76F
027A8:  MOVFF  02,76E
027AC:  MOVFF  01,76D
027B0:  MOVFF  00,76C
027B4:  MOVFF  755,773
027B8:  MOVFF  754,772
027BC:  MOVFF  753,771
027C0:  MOVFF  752,770
027C4:  CALL   1116
027C8:  MOVFF  03,762
027CC:  MOVFF  02,761
027D0:  MOVFF  01,760
027D4:  MOVFF  00,75F
027D8:  BCF    FD8.1
027DA:  MOVFF  03,773
027DE:  MOVFF  02,772
027E2:  MOVFF  01,771
027E6:  MOVFF  00,770
027EA:  MOVLW  33
027EC:  MOVLB  7
027EE:  MOVWF  x77
027F0:  MOVLW  8C
027F2:  MOVWF  x76
027F4:  MOVLW  1E
027F6:  MOVWF  x75
027F8:  MOVLW  83
027FA:  MOVWF  x74
027FC:  MOVLB  0
027FE:  CALL   0DDC
02802:  MOVFF  03,759
02806:  MOVFF  02,758
0280A:  MOVFF  01,757
0280E:  MOVFF  00,756
.................... 
....................    r = qat[0]*y*y + qat[1];
02812:  MOVLB  7
02814:  CLRF   x6F
02816:  CLRF   x6E
02818:  CLRF   x6D
0281A:  MOVLW  7F
0281C:  MOVWF  x6C
0281E:  MOVFF  755,773
02822:  MOVFF  754,772
02826:  MOVFF  753,771
0282A:  MOVFF  752,770
0282E:  MOVLB  0
02830:  CALL   1116
02834:  MOVFF  03,762
02838:  MOVFF  02,761
0283C:  MOVFF  01,760
02840:  MOVFF  00,75F
02844:  MOVFF  03,76F
02848:  MOVFF  02,76E
0284C:  MOVFF  01,76D
02850:  MOVFF  00,76C
02854:  MOVFF  755,773
02858:  MOVFF  754,772
0285C:  MOVFF  753,771
02860:  MOVFF  752,770
02864:  CALL   1116
02868:  MOVFF  03,762
0286C:  MOVFF  02,761
02870:  MOVFF  01,760
02874:  MOVFF  00,75F
02878:  BCF    FD8.1
0287A:  MOVFF  03,773
0287E:  MOVFF  02,772
02882:  MOVFF  01,771
02886:  MOVFF  00,770
0288A:  MOVLW  1B
0288C:  MOVLB  7
0288E:  MOVWF  x77
02890:  MOVLW  E4
02892:  MOVWF  x76
02894:  MOVLW  35
02896:  MOVWF  x75
02898:  MOVLW  82
0289A:  MOVWF  x74
0289C:  MOVLB  0
0289E:  CALL   0DDC
028A2:  MOVFF  03,75D
028A6:  MOVFF  02,75C
028AA:  MOVFF  01,75B
028AE:  MOVFF  00,75A
....................    r = r*y*y + qat[2];
028B2:  MOVFF  75D,76F
028B6:  MOVFF  75C,76E
028BA:  MOVFF  75B,76D
028BE:  MOVFF  75A,76C
028C2:  MOVFF  755,773
028C6:  MOVFF  754,772
028CA:  MOVFF  753,771
028CE:  MOVFF  752,770
028D2:  CALL   1116
028D6:  MOVFF  03,762
028DA:  MOVFF  02,761
028DE:  MOVFF  01,760
028E2:  MOVFF  00,75F
028E6:  MOVFF  03,76F
028EA:  MOVFF  02,76E
028EE:  MOVFF  01,76D
028F2:  MOVFF  00,76C
028F6:  MOVFF  755,773
028FA:  MOVFF  754,772
028FE:  MOVFF  753,771
02902:  MOVFF  752,770
02906:  CALL   1116
0290A:  MOVFF  03,762
0290E:  MOVFF  02,761
02912:  MOVFF  01,760
02916:  MOVFF  00,75F
0291A:  BCF    FD8.1
0291C:  MOVFF  03,773
02920:  MOVFF  02,772
02924:  MOVFF  01,771
02928:  MOVFF  00,770
0292C:  MOVLW  A4
0292E:  MOVLB  7
02930:  MOVWF  x77
02932:  MOVLW  DB
02934:  MOVWF  x76
02936:  MOVLW  67
02938:  MOVWF  x75
0293A:  MOVLW  83
0293C:  MOVWF  x74
0293E:  MOVLB  0
02940:  CALL   0DDC
02944:  MOVFF  03,75D
02948:  MOVFF  02,75C
0294C:  MOVFF  01,75B
02950:  MOVFF  00,75A
....................    r = r*y*y + qat[3];
02954:  MOVFF  75D,76F
02958:  MOVFF  75C,76E
0295C:  MOVFF  75B,76D
02960:  MOVFF  75A,76C
02964:  MOVFF  755,773
02968:  MOVFF  754,772
0296C:  MOVFF  753,771
02970:  MOVFF  752,770
02974:  CALL   1116
02978:  MOVFF  03,762
0297C:  MOVFF  02,761
02980:  MOVFF  01,760
02984:  MOVFF  00,75F
02988:  MOVFF  03,76F
0298C:  MOVFF  02,76E
02990:  MOVFF  01,76D
02994:  MOVFF  00,76C
02998:  MOVFF  755,773
0299C:  MOVFF  754,772
029A0:  MOVFF  753,771
029A4:  MOVFF  752,770
029A8:  CALL   1116
029AC:  MOVFF  03,762
029B0:  MOVFF  02,761
029B4:  MOVFF  01,760
029B8:  MOVFF  00,75F
029BC:  BCF    FD8.1
029BE:  MOVFF  03,773
029C2:  MOVFF  02,772
029C6:  MOVFF  01,771
029CA:  MOVFF  00,770
029CE:  MOVLW  33
029D0:  MOVLB  7
029D2:  MOVWF  x77
029D4:  MOVLW  8C
029D6:  MOVWF  x76
029D8:  MOVLW  1E
029DA:  MOVWF  x75
029DC:  MOVLW  83
029DE:  MOVWF  x74
029E0:  MOVLB  0
029E2:  CALL   0DDC
029E6:  MOVFF  03,75D
029EA:  MOVFF  02,75C
029EE:  MOVFF  01,75B
029F2:  MOVFF  00,75A
.................... 
....................    res = y*res/r;
029F6:  MOVFF  755,76F
029FA:  MOVFF  754,76E
029FE:  MOVFF  753,76D
02A02:  MOVFF  752,76C
02A06:  MOVFF  759,773
02A0A:  MOVFF  758,772
02A0E:  MOVFF  757,771
02A12:  MOVFF  756,770
02A16:  CALL   1116
02A1A:  MOVFF  03,762
02A1E:  MOVFF  02,761
02A22:  MOVFF  01,760
02A26:  MOVFF  00,75F
02A2A:  MOVFF  03,768
02A2E:  MOVFF  02,767
02A32:  MOVFF  01,766
02A36:  MOVFF  00,765
02A3A:  MOVFF  75D,76C
02A3E:  MOVFF  75C,76B
02A42:  MOVFF  75B,76A
02A46:  MOVFF  75A,769
02A4A:  RCALL  242E
02A4C:  MOVFF  03,759
02A50:  MOVFF  02,758
02A54:  MOVFF  01,757
02A58:  MOVFF  00,756
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
02A5C:  MOVLB  7
02A5E:  BTFSS  x5E.1
02A60:  BRA    2A9C
....................       res = PI_DIV_BY_TWO - res;
02A62:  BSF    FD8.1
02A64:  MOVLW  DB
02A66:  MOVWF  x73
02A68:  MOVLW  0F
02A6A:  MOVWF  x72
02A6C:  MOVLW  49
02A6E:  MOVWF  x71
02A70:  MOVLW  7F
02A72:  MOVWF  x70
02A74:  MOVFF  759,777
02A78:  MOVFF  758,776
02A7C:  MOVFF  757,775
02A80:  MOVFF  756,774
02A84:  MOVLB  0
02A86:  CALL   0DDC
02A8A:  MOVFF  03,759
02A8E:  MOVFF  02,758
02A92:  MOVFF  01,757
02A96:  MOVFF  00,756
02A9A:  MOVLB  7
....................    if (s)
02A9C:  BTFSS  x5E.0
02A9E:  BRA    2AA6
....................       res = -res;
02AA0:  MOVF   x57,W
02AA2:  XORLW  80
02AA4:  MOVWF  x57
.................... 
....................    return(res);
02AA6:  MOVFF  756,00
02AAA:  MOVFF  757,01
02AAE:  MOVFF  758,02
02AB2:  MOVFF  759,03
02AB6:  MOVLB  0
02AB8:  RETURN 0
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
02ABA:  MOVLB  7
02ABC:  BCF    x4C.0
....................    quad=0; //quadrant
02ABE:  CLRF   x4D
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
02AC0:  MOVFF  743,76F
02AC4:  MOVFF  742,76E
02AC8:  MOVFF  741,76D
02ACC:  MOVFF  740,76C
02AD0:  CLRF   x73
02AD2:  CLRF   x72
02AD4:  CLRF   x71
02AD6:  CLRF   x70
02AD8:  MOVLB  0
02ADA:  CALL   0D62
02ADE:  BC    2AE2
02AE0:  BNZ   2B0E
02AE2:  MOVFF  747,76F
02AE6:  MOVFF  746,76E
02AEA:  MOVFF  745,76D
02AEE:  MOVFF  744,76C
02AF2:  MOVLB  7
02AF4:  CLRF   x73
02AF6:  CLRF   x72
02AF8:  CLRF   x71
02AFA:  CLRF   x70
02AFC:  MOVLB  0
02AFE:  CALL   0D62
02B02:  BC    2B06
02B04:  BNZ   2B0A
02B06:  MOVLW  03
02B08:  BRA    2B0C
02B0A:  MOVLW  04
02B0C:  BRA    2B36
02B0E:  MOVFF  747,76F
02B12:  MOVFF  746,76E
02B16:  MOVFF  745,76D
02B1A:  MOVFF  744,76C
02B1E:  MOVLB  7
02B20:  CLRF   x73
02B22:  CLRF   x72
02B24:  CLRF   x71
02B26:  CLRF   x70
02B28:  MOVLB  0
02B2A:  CALL   0D62
02B2E:  BNC   2B34
02B30:  MOVLW  02
02B32:  BRA    2B36
02B34:  MOVLW  01
02B36:  MOVLB  7
02B38:  MOVWF  x4D
....................    if(y<0.0)
02B3A:  MOVFF  743,76F
02B3E:  MOVFF  742,76E
02B42:  MOVFF  741,76D
02B46:  MOVFF  740,76C
02B4A:  CLRF   x73
02B4C:  CLRF   x72
02B4E:  CLRF   x71
02B50:  CLRF   x70
02B52:  MOVLB  0
02B54:  CALL   0D62
02B58:  BNC   2B66
....................    {
....................       sign=1;
02B5A:  MOVLB  7
02B5C:  BSF    x4C.0
....................       y=-y;
02B5E:  MOVF   x41,W
02B60:  XORLW  80
02B62:  MOVWF  x41
02B64:  MOVLB  0
....................    }
....................    if(x<0.0)
02B66:  MOVFF  747,76F
02B6A:  MOVFF  746,76E
02B6E:  MOVFF  745,76D
02B72:  MOVFF  744,76C
02B76:  MOVLB  7
02B78:  CLRF   x73
02B7A:  CLRF   x72
02B7C:  CLRF   x71
02B7E:  CLRF   x70
02B80:  MOVLB  0
02B82:  CALL   0D62
02B86:  BNC   2B92
....................    {
....................       x=-x;
02B88:  MOVLB  7
02B8A:  MOVF   x45,W
02B8C:  XORLW  80
02B8E:  MOVWF  x45
02B90:  MOVLB  0
....................    }
....................    if (x==0.0)
02B92:  MOVFF  747,76F
02B96:  MOVFF  746,76E
02B9A:  MOVFF  745,76D
02B9E:  MOVFF  744,76C
02BA2:  MOVLB  7
02BA4:  CLRF   x73
02BA6:  CLRF   x72
02BA8:  CLRF   x71
02BAA:  CLRF   x70
02BAC:  MOVLB  0
02BAE:  CALL   0D62
02BB2:  BNZ   2C08
....................    {
....................       if(y==0.0)
02BB4:  MOVFF  743,76F
02BB8:  MOVFF  742,76E
02BBC:  MOVFF  741,76D
02BC0:  MOVFF  740,76C
02BC4:  MOVLB  7
02BC6:  CLRF   x73
02BC8:  CLRF   x72
02BCA:  CLRF   x71
02BCC:  CLRF   x70
02BCE:  MOVLB  0
02BD0:  CALL   0D62
02BD4:  BNZ   2BD8
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
02BD6:  BRA    2C06
....................       else
....................       {
....................          if(sign)
02BD8:  MOVLB  7
02BDA:  BTFSS  x4C.0
02BDC:  BRA    2BF2
....................          {
....................          return (-(PI_DIV_BY_TWO));
02BDE:  MOVLW  7F
02BE0:  MOVWF  00
02BE2:  MOVLW  C9
02BE4:  MOVWF  01
02BE6:  MOVLW  0F
02BE8:  MOVWF  02
02BEA:  MOVLW  DB
02BEC:  MOVWF  03
02BEE:  BRA    2D40
....................          }
02BF0:  BRA    2C04
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
02BF2:  MOVLW  7F
02BF4:  MOVWF  00
02BF6:  MOVLW  49
02BF8:  MOVWF  01
02BFA:  MOVLW  0F
02BFC:  MOVWF  02
02BFE:  MOVLW  DB
02C00:  MOVWF  03
02C02:  BRA    2D40
02C04:  MOVLB  0
....................          }
....................       }
....................    }
02C06:  BRA    2D3E
....................    else
....................    {
....................       z=y/x;
02C08:  MOVFF  743,768
02C0C:  MOVFF  742,767
02C10:  MOVFF  741,766
02C14:  MOVFF  740,765
02C18:  MOVFF  747,76C
02C1C:  MOVFF  746,76B
02C20:  MOVFF  745,76A
02C24:  MOVFF  744,769
02C28:  RCALL  242E
02C2A:  MOVFF  03,74B
02C2E:  MOVFF  02,74A
02C32:  MOVFF  01,749
02C36:  MOVFF  00,748
....................       switch(quad)
02C3A:  MOVLW  01
02C3C:  MOVLB  7
02C3E:  SUBWF  x4D,W
02C40:  ADDLW  FC
02C42:  BTFSC  FD8.0
02C44:  BRA    2D40
02C46:  ADDLW  04
02C48:  MOVLB  0
02C4A:  GOTO   2D46
....................       {
....................          case 1:
....................          {
....................             return atan(z);
02C4E:  MOVFF  74B,751
02C52:  MOVFF  74A,750
02C56:  MOVFF  749,74F
02C5A:  MOVFF  748,74E
02C5E:  RCALL  258C
02C60:  MOVLB  7
02C62:  BRA    2D40
....................             break;
02C64:  BRA    2D40
02C66:  MOVLB  0
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
02C68:  MOVFF  74B,751
02C6C:  MOVFF  74A,750
02C70:  MOVFF  749,74F
02C74:  MOVFF  748,74E
02C78:  RCALL  258C
02C7A:  MOVFF  FEA,74F
02C7E:  MOVFF  FE9,74E
02C82:  BSF    FD8.1
02C84:  MOVLW  DB
02C86:  MOVLB  7
02C88:  MOVWF  x73
02C8A:  MOVLW  0F
02C8C:  MOVWF  x72
02C8E:  MOVLW  49
02C90:  MOVWF  x71
02C92:  MOVLW  80
02C94:  MOVWF  x70
02C96:  MOVFF  03,777
02C9A:  MOVFF  02,776
02C9E:  MOVFF  01,775
02CA2:  MOVFF  00,774
02CA6:  MOVLB  0
02CA8:  CALL   0DDC
02CAC:  MOVFF  74F,FEA
02CB0:  MOVFF  74E,FE9
02CB4:  MOVLB  7
02CB6:  BRA    2D40
....................             break;
02CB8:  BRA    2D40
02CBA:  MOVLB  0
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
02CBC:  MOVFF  74B,751
02CC0:  MOVFF  74A,750
02CC4:  MOVFF  749,74F
02CC8:  MOVFF  748,74E
02CCC:  RCALL  258C
02CCE:  MOVFF  03,751
02CD2:  MOVFF  02,750
02CD6:  MOVFF  01,74F
02CDA:  MOVFF  00,74E
02CDE:  MOVFF  FEA,753
02CE2:  MOVFF  FE9,752
02CE6:  BSF    FD8.1
02CE8:  MOVFF  03,773
02CEC:  MOVFF  02,772
02CF0:  MOVFF  01,771
02CF4:  MOVFF  00,770
02CF8:  MOVLW  DB
02CFA:  MOVLB  7
02CFC:  MOVWF  x77
02CFE:  MOVLW  0F
02D00:  MOVWF  x76
02D02:  MOVLW  49
02D04:  MOVWF  x75
02D06:  MOVLW  80
02D08:  MOVWF  x74
02D0A:  MOVLB  0
02D0C:  CALL   0DDC
02D10:  MOVFF  753,FEA
02D14:  MOVFF  752,FE9
02D18:  MOVLB  7
02D1A:  BRA    2D40
....................             break;
02D1C:  BRA    2D40
02D1E:  MOVLB  0
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
02D20:  MOVFF  74B,751
02D24:  MOVFF  74A,750
02D28:  MOVFF  749,74F
02D2C:  MOVFF  748,74E
02D30:  RCALL  258C
02D32:  MOVLW  80
02D34:  XORWF  01,F
02D36:  MOVLB  7
02D38:  BRA    2D40
....................             break;
02D3A:  BRA    2D40
02D3C:  MOVLB  0
02D3E:  MOVLB  7
....................          }
....................       }
....................    }
02D40:  MOVLB  0
02D42:  GOTO   4444 (RETURN)
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... #define sensorSampleRate 50 // 50mS delay between each sensor sample = 100ms cadence 
.................... 
.................... #define maxCount 16777216.0   // ADC max count
.................... #define vRef 2.048            // ADC vRef
.................... 
.................... #define sc sensorCal
.................... 
.................... #define vMonN15   6
.................... #define vMon200   16
.................... #define vMon5V6   24
.................... #define vMon5VA   25
.................... #define vMon3V6X  17
.................... #define vMon3V3A  27
.................... #define vMon3V3D  26
.................... 
.................... #define BUFFER_SIZE 5
.................... 
.................... signed int32 sQ_x[BUFFER_SIZE];
.................... signed int32 cQ_x[BUFFER_SIZE];
.................... signed int32 sQ_y[BUFFER_SIZE];
.................... signed int32 cQ_y[BUFFER_SIZE];
.................... int sIn_x=0;
.................... int cIn_x=0;
.................... int sIn_y=0;
.................... int cIn_y=0;
.................... 
.................... struct sensorMonitorData
.................... {
....................    boolean dataReady;
....................    boolean adcBusy;
....................    signed int32 avgSin;
....................    signed int32 avgCos;
.................... } smData[2] = 
.................... {
....................    {false, false, 0, 0},
....................    {false, false, 0, 0}
.................... };
.................... 
.................... void push(signed int32* buff, int* idx, signed int32 newData) {
....................    buff[*idx]=newData;
*
008BC:  MOVFF  756,FEA
008C0:  MOVLB  7
008C2:  MOVFF  755,FE9
008C6:  CLRF   x5D
008C8:  MOVFF  FEF,75C
008CC:  CLRF   x5F
008CE:  MOVLW  04
008D0:  MOVWF  x5E
008D2:  MOVLB  0
008D4:  RCALL  086E
008D6:  MOVF   01,W
008D8:  MOVLB  7
008DA:  ADDWF  x53,W
008DC:  MOVWF  FE9
008DE:  MOVF   x54,W
008E0:  ADDWFC 02,W
008E2:  MOVWF  FEA
008E4:  MOVFF  757,FEF
008E8:  MOVFF  758,FEC
008EC:  MOVFF  759,FEC
008F0:  MOVFF  75A,FEC
....................    *idx=(*idx+1) % BUFFER_SIZE;
008F4:  MOVFF  756,75C
008F8:  MOVFF  756,FEA
008FC:  MOVFF  755,FE9
00900:  MOVLW  01
00902:  ADDWF  FEF,W
00904:  MOVWF  x5E
00906:  MOVWF  x5F
00908:  MOVLW  05
0090A:  MOVWF  x60
0090C:  MOVLB  0
0090E:  RCALL  0890
00910:  MOVLB  7
00912:  MOVFF  75C,FEA
00916:  MOVFF  755,FE9
0091A:  MOVFF  00,FEF
0091E:  MOVLB  0
00920:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INTERNAL MONITOR task - gets voltages                                     */
.................... /* gets one value each time the task is run                                  */
.................... /*****************************************************************************/
.................... void internal_monitor_task(){
....................    static int8 state = 0;
....................    if (adc_done()){
*
0508A:  MOVLB  F
0508C:  BTFSC  x5B.0
0508E:  BRA    5600
....................       switch (state)
05090:  MOVLB  1
05092:  MOVF   xE6,W
05094:  ADDLW  F9
05096:  BTFSC  FD8.0
05098:  BRA    55FE
0509A:  ADDLW  07
0509C:  MOVLB  0
0509E:  GOTO   5606
....................       {
....................          case 0:     // vMonN15
....................             monitorVals.vN15 = read_adc(ADC_READ_ONLY) * monCal.vN15[1] + monCal.vN15[0];
050A2:  MOVLB  F
050A4:  BTFSC  x5B.0
050A6:  BRA    50A4
050A8:  MOVFF  F5F,02
050AC:  MOVFF  F5E,01
050B0:  MOVFF  02,717
050B4:  MOVFF  01,716
050B8:  MOVFF  02,771
050BC:  MOVFF  01,770
050C0:  MOVLB  0
050C2:  CALL   2DB8
050C6:  MOVFF  03,76F
050CA:  MOVFF  02,76E
050CE:  MOVFF  01,76D
050D2:  MOVFF  00,76C
050D6:  MOVFF  C9,773
050DA:  MOVFF  C8,772
050DE:  MOVFF  C7,771
050E2:  MOVFF  C6,770
050E6:  CALL   1116
050EA:  MOVFF  03,719
050EE:  MOVFF  02,718
050F2:  MOVFF  01,717
050F6:  MOVFF  00,716
050FA:  BCF    FD8.1
050FC:  MOVFF  03,773
05100:  MOVFF  02,772
05104:  MOVFF  01,771
05108:  MOVFF  00,770
0510C:  MOVFF  C5,777
05110:  MOVFF  C4,776
05114:  MOVFF  C3,775
05118:  MOVFF  C2,774
0511C:  CALL   0DDC
05120:  MOVFF  03,FE
05124:  MOVFF  02,FD
05128:  MOVFF  01,FC
0512C:  MOVFF  00,FB
....................             set_adc_channel(vMon200);
05130:  MOVLB  F
05132:  MOVF   x5A,W
05134:  ANDLW  3F
05136:  MOVWF  01
05138:  MOVLW  10
0513A:  MOVWF  x5A
0513C:  BTFSS  x5B.7
0513E:  BRA    514E
05140:  MOVF   01,W
05142:  SUBLW  10
05144:  BZ    514E
05146:  BSF    x5B.0
05148:  NOP   
0514A:  BTFSC  x5B.0
0514C:  BRA    514A
....................             delay_ms(10);
0514E:  MOVLW  0A
05150:  MOVLB  7
05152:  MOVWF  x25
05154:  MOVLB  0
05156:  CALL   0436
....................             read_adc(ADC_START_ONLY);
0515A:  MOVLB  F
0515C:  BSF    x5B.0
0515E:  NOP   
....................             state = 1;
05160:  MOVLW  01
05162:  MOVLB  1
05164:  MOVWF  xE6
....................          break;
05166:  BRA    55FE
....................          
....................          case 1:     // vMon200
....................             monitorVals.v200 = read_adc(ADC_READ_ONLY) * monCal.v200[1] + monCal.v200[0];
05168:  MOVLB  F
0516A:  BTFSC  x5B.0
0516C:  BRA    516A
0516E:  MOVFF  F5F,02
05172:  MOVFF  F5E,01
05176:  MOVFF  02,717
0517A:  MOVFF  01,716
0517E:  MOVFF  02,771
05182:  MOVFF  01,770
05186:  MOVLB  0
05188:  CALL   2DB8
0518C:  MOVFF  03,76F
05190:  MOVFF  02,76E
05194:  MOVFF  01,76D
05198:  MOVFF  00,76C
0519C:  MOVFF  D1,773
051A0:  MOVFF  D0,772
051A4:  MOVFF  CF,771
051A8:  MOVFF  CE,770
051AC:  CALL   1116
051B0:  MOVFF  03,719
051B4:  MOVFF  02,718
051B8:  MOVFF  01,717
051BC:  MOVFF  00,716
051C0:  BCF    FD8.1
051C2:  MOVFF  03,773
051C6:  MOVFF  02,772
051CA:  MOVFF  01,771
051CE:  MOVFF  00,770
051D2:  MOVFF  CD,777
051D6:  MOVFF  CC,776
051DA:  MOVFF  CB,775
051DE:  MOVFF  CA,774
051E2:  CALL   0DDC
051E6:  MOVFF  03,102
051EA:  MOVFF  02,101
051EE:  MOVFF  01,100
051F2:  MOVFF  00,FF
....................             set_adc_channel(vMon5V6);
051F6:  MOVLB  F
051F8:  MOVF   x5A,W
051FA:  ANDLW  3F
051FC:  MOVWF  01
051FE:  MOVLW  18
05200:  MOVWF  x5A
05202:  BTFSS  x5B.7
05204:  BRA    5214
05206:  MOVF   01,W
05208:  SUBLW  18
0520A:  BZ    5214
0520C:  BSF    x5B.0
0520E:  NOP   
05210:  BTFSC  x5B.0
05212:  BRA    5210
....................             delay_ms(10);
05214:  MOVLW  0A
05216:  MOVLB  7
05218:  MOVWF  x25
0521A:  MOVLB  0
0521C:  CALL   0436
....................             read_adc(ADC_START_ONLY);
05220:  MOVLB  F
05222:  BSF    x5B.0
05224:  NOP   
....................             state = 2;
05226:  MOVLW  02
05228:  MOVLB  1
0522A:  MOVWF  xE6
....................          break;
0522C:  BRA    55FE
....................          
....................          case 2:     // vMon5V6
....................             monitorVals.v5V6 = read_adc(ADC_READ_ONLY) * monCal.v5V6[1] + monCal.v5V6[0];
0522E:  MOVLB  F
05230:  BTFSC  x5B.0
05232:  BRA    5230
05234:  MOVFF  F5F,02
05238:  MOVFF  F5E,01
0523C:  MOVFF  02,717
05240:  MOVFF  01,716
05244:  MOVFF  02,771
05248:  MOVFF  01,770
0524C:  MOVLB  0
0524E:  CALL   2DB8
05252:  MOVFF  03,76F
05256:  MOVFF  02,76E
0525A:  MOVFF  01,76D
0525E:  MOVFF  00,76C
05262:  MOVFF  D9,773
05266:  MOVFF  D8,772
0526A:  MOVFF  D7,771
0526E:  MOVFF  D6,770
05272:  CALL   1116
05276:  MOVFF  03,719
0527A:  MOVFF  02,718
0527E:  MOVFF  01,717
05282:  MOVFF  00,716
05286:  BCF    FD8.1
05288:  MOVFF  03,773
0528C:  MOVFF  02,772
05290:  MOVFF  01,771
05294:  MOVFF  00,770
05298:  MOVFF  D5,777
0529C:  MOVFF  D4,776
052A0:  MOVFF  D3,775
052A4:  MOVFF  D2,774
052A8:  CALL   0DDC
052AC:  MOVFF  03,106
052B0:  MOVFF  02,105
052B4:  MOVFF  01,104
052B8:  MOVFF  00,103
....................             set_adc_channel(vMon5VA);
052BC:  MOVLB  F
052BE:  MOVF   x5A,W
052C0:  ANDLW  3F
052C2:  MOVWF  01
052C4:  MOVLW  19
052C6:  MOVWF  x5A
052C8:  BTFSS  x5B.7
052CA:  BRA    52DA
052CC:  MOVF   01,W
052CE:  SUBLW  19
052D0:  BZ    52DA
052D2:  BSF    x5B.0
052D4:  NOP   
052D6:  BTFSC  x5B.0
052D8:  BRA    52D6
....................             delay_ms(10);
052DA:  MOVLW  0A
052DC:  MOVLB  7
052DE:  MOVWF  x25
052E0:  MOVLB  0
052E2:  CALL   0436
....................             read_adc(ADC_START_ONLY);
052E6:  MOVLB  F
052E8:  BSF    x5B.0
052EA:  NOP   
....................             state = 3;
052EC:  MOVLW  03
052EE:  MOVLB  1
052F0:  MOVWF  xE6
....................          break;
052F2:  BRA    55FE
....................          
....................          case 3:     // vMon5VA
....................             monitorVals.v5VA = read_adc(ADC_READ_ONLY) * monCal.v5VA[1] + monCal.v5VA[0];
052F4:  MOVLB  F
052F6:  BTFSC  x5B.0
052F8:  BRA    52F6
052FA:  MOVFF  F5F,02
052FE:  MOVFF  F5E,01
05302:  MOVFF  02,717
05306:  MOVFF  01,716
0530A:  MOVFF  02,771
0530E:  MOVFF  01,770
05312:  MOVLB  0
05314:  CALL   2DB8
05318:  MOVFF  03,76F
0531C:  MOVFF  02,76E
05320:  MOVFF  01,76D
05324:  MOVFF  00,76C
05328:  MOVFF  E1,773
0532C:  MOVFF  E0,772
05330:  MOVFF  DF,771
05334:  MOVFF  DE,770
05338:  CALL   1116
0533C:  MOVFF  03,719
05340:  MOVFF  02,718
05344:  MOVFF  01,717
05348:  MOVFF  00,716
0534C:  BCF    FD8.1
0534E:  MOVFF  03,773
05352:  MOVFF  02,772
05356:  MOVFF  01,771
0535A:  MOVFF  00,770
0535E:  MOVFF  DD,777
05362:  MOVFF  DC,776
05366:  MOVFF  DB,775
0536A:  MOVFF  DA,774
0536E:  CALL   0DDC
05372:  MOVFF  03,10A
05376:  MOVFF  02,109
0537A:  MOVFF  01,108
0537E:  MOVFF  00,107
....................             set_adc_channel(vMon3V6X);
05382:  MOVLB  F
05384:  MOVF   x5A,W
05386:  ANDLW  3F
05388:  MOVWF  01
0538A:  MOVLW  11
0538C:  MOVWF  x5A
0538E:  BTFSS  x5B.7
05390:  BRA    53A0
05392:  MOVF   01,W
05394:  SUBLW  11
05396:  BZ    53A0
05398:  BSF    x5B.0
0539A:  NOP   
0539C:  BTFSC  x5B.0
0539E:  BRA    539C
....................             delay_ms(10);
053A0:  MOVLW  0A
053A2:  MOVLB  7
053A4:  MOVWF  x25
053A6:  MOVLB  0
053A8:  CALL   0436
....................             read_adc(ADC_START_ONLY);
053AC:  MOVLB  F
053AE:  BSF    x5B.0
053B0:  NOP   
....................             state = 4;
053B2:  MOVLW  04
053B4:  MOVLB  1
053B6:  MOVWF  xE6
....................          break;
053B8:  BRA    55FE
....................          
....................          case 4:     // vMon3V6X
....................             monitorVals.v3V6X = read_adc(ADC_READ_ONLY) * monCal.v3V6X[1] + monCal.v3V6X[0];
053BA:  MOVLB  F
053BC:  BTFSC  x5B.0
053BE:  BRA    53BC
053C0:  MOVFF  F5F,02
053C4:  MOVFF  F5E,01
053C8:  MOVFF  02,717
053CC:  MOVFF  01,716
053D0:  MOVFF  02,771
053D4:  MOVFF  01,770
053D8:  MOVLB  0
053DA:  CALL   2DB8
053DE:  MOVFF  03,76F
053E2:  MOVFF  02,76E
053E6:  MOVFF  01,76D
053EA:  MOVFF  00,76C
053EE:  MOVFF  E9,773
053F2:  MOVFF  E8,772
053F6:  MOVFF  E7,771
053FA:  MOVFF  E6,770
053FE:  CALL   1116
05402:  MOVFF  03,719
05406:  MOVFF  02,718
0540A:  MOVFF  01,717
0540E:  MOVFF  00,716
05412:  BCF    FD8.1
05414:  MOVFF  03,773
05418:  MOVFF  02,772
0541C:  MOVFF  01,771
05420:  MOVFF  00,770
05424:  MOVFF  E5,777
05428:  MOVFF  E4,776
0542C:  MOVFF  E3,775
05430:  MOVFF  E2,774
05434:  CALL   0DDC
05438:  MOVFF  03,10E
0543C:  MOVFF  02,10D
05440:  MOVFF  01,10C
05444:  MOVFF  00,10B
....................             set_adc_channel(vMon3V3A);
05448:  MOVLB  F
0544A:  MOVF   x5A,W
0544C:  ANDLW  3F
0544E:  MOVWF  01
05450:  MOVLW  1B
05452:  MOVWF  x5A
05454:  BTFSS  x5B.7
05456:  BRA    5466
05458:  MOVF   01,W
0545A:  SUBLW  1B
0545C:  BZ    5466
0545E:  BSF    x5B.0
05460:  NOP   
05462:  BTFSC  x5B.0
05464:  BRA    5462
....................             delay_ms(10);
05466:  MOVLW  0A
05468:  MOVLB  7
0546A:  MOVWF  x25
0546C:  MOVLB  0
0546E:  CALL   0436
....................             read_adc(ADC_START_ONLY);
05472:  MOVLB  F
05474:  BSF    x5B.0
05476:  NOP   
....................             state = 5;
05478:  MOVLW  05
0547A:  MOVLB  1
0547C:  MOVWF  xE6
....................          break;
0547E:  BRA    55FE
....................          
....................          case 5:     // vMon3V3A
....................             monitorVals.v3V3A = read_adc(ADC_READ_ONLY) * monCal.v3V3A[1] + monCal.v3V3A[0];
05480:  MOVLB  F
05482:  BTFSC  x5B.0
05484:  BRA    5482
05486:  MOVFF  F5F,02
0548A:  MOVFF  F5E,01
0548E:  MOVFF  02,717
05492:  MOVFF  01,716
05496:  MOVFF  02,771
0549A:  MOVFF  01,770
0549E:  MOVLB  0
054A0:  CALL   2DB8
054A4:  MOVFF  03,76F
054A8:  MOVFF  02,76E
054AC:  MOVFF  01,76D
054B0:  MOVFF  00,76C
054B4:  MOVFF  F1,773
054B8:  MOVFF  F0,772
054BC:  MOVFF  EF,771
054C0:  MOVFF  EE,770
054C4:  CALL   1116
054C8:  MOVFF  03,719
054CC:  MOVFF  02,718
054D0:  MOVFF  01,717
054D4:  MOVFF  00,716
054D8:  BCF    FD8.1
054DA:  MOVFF  03,773
054DE:  MOVFF  02,772
054E2:  MOVFF  01,771
054E6:  MOVFF  00,770
054EA:  MOVFF  ED,777
054EE:  MOVFF  EC,776
054F2:  MOVFF  EB,775
054F6:  MOVFF  EA,774
054FA:  CALL   0DDC
054FE:  MOVFF  03,112
05502:  MOVFF  02,111
05506:  MOVFF  01,110
0550A:  MOVFF  00,10F
....................             set_adc_channel(vMon3V3D);
0550E:  MOVLB  F
05510:  MOVF   x5A,W
05512:  ANDLW  3F
05514:  MOVWF  01
05516:  MOVLW  1A
05518:  MOVWF  x5A
0551A:  BTFSS  x5B.7
0551C:  BRA    552C
0551E:  MOVF   01,W
05520:  SUBLW  1A
05522:  BZ    552C
05524:  BSF    x5B.0
05526:  NOP   
05528:  BTFSC  x5B.0
0552A:  BRA    5528
....................             delay_ms(10);
0552C:  MOVLW  0A
0552E:  MOVLB  7
05530:  MOVWF  x25
05532:  MOVLB  0
05534:  CALL   0436
....................             read_adc(ADC_START_ONLY);
05538:  MOVLB  F
0553A:  BSF    x5B.0
0553C:  NOP   
....................             state = 6;
0553E:  MOVLW  06
05540:  MOVLB  1
05542:  MOVWF  xE6
....................          break;
05544:  BRA    55FE
....................          
....................          case 6:    // vMon3V3D
....................             monitorVals.v3V3D = read_adc(ADC_READ_ONLY) * monCal.v3V3D[1] + monCal.v3V3D[0];
05546:  MOVLB  F
05548:  BTFSC  x5B.0
0554A:  BRA    5548
0554C:  MOVFF  F5F,02
05550:  MOVFF  F5E,01
05554:  MOVFF  02,717
05558:  MOVFF  01,716
0555C:  MOVFF  02,771
05560:  MOVFF  01,770
05564:  MOVLB  0
05566:  CALL   2DB8
0556A:  MOVFF  03,76F
0556E:  MOVFF  02,76E
05572:  MOVFF  01,76D
05576:  MOVFF  00,76C
0557A:  MOVFF  F9,773
0557E:  MOVFF  F8,772
05582:  MOVFF  F7,771
05586:  MOVFF  F6,770
0558A:  CALL   1116
0558E:  MOVFF  03,719
05592:  MOVFF  02,718
05596:  MOVFF  01,717
0559A:  MOVFF  00,716
0559E:  BCF    FD8.1
055A0:  MOVFF  03,773
055A4:  MOVFF  02,772
055A8:  MOVFF  01,771
055AC:  MOVFF  00,770
055B0:  MOVFF  F5,777
055B4:  MOVFF  F4,776
055B8:  MOVFF  F3,775
055BC:  MOVFF  F2,774
055C0:  CALL   0DDC
055C4:  MOVFF  03,116
055C8:  MOVFF  02,115
055CC:  MOVFF  01,114
055D0:  MOVFF  00,113
....................             set_adc_channel(vMonN15);
055D4:  MOVLB  F
055D6:  MOVF   x5A,W
055D8:  ANDLW  3F
055DA:  MOVWF  01
055DC:  MOVLW  06
055DE:  MOVWF  x5A
055E0:  BTFSS  x5B.7
055E2:  BRA    55F2
055E4:  MOVF   01,W
055E6:  SUBLW  06
055E8:  BZ    55F2
055EA:  BSF    x5B.0
055EC:  NOP   
055EE:  BTFSC  x5B.0
055F0:  BRA    55EE
....................             read_adc(ADC_START_ONLY);
055F2:  BSF    x5B.0
055F4:  NOP   
....................             state = 0;
055F6:  MOVLB  1
055F8:  CLRF   xE6
....................          break;   
055FA:  BRA    55FE
055FC:  MOVLB  1
055FE:  MOVLB  F
....................       }
....................    }
05600:  MOVLB  0
05602:  GOTO   B1D4 (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* PROCESS ADC SENSOR DATA                                                   */
.................... /*****************************************************************************/
.................... void sensor_process_data(int8 ch){
....................    adcVals[ch].sinLast = adcVals[ch].sinCounts;
*
03D9C:  MOVLB  7
03D9E:  MOVF   x29,W
03DA0:  MULLW  26
03DA2:  MOVF   FF3,W
03DA4:  CLRF   x33
03DA6:  MOVWF  x32
03DA8:  MOVLW  10
03DAA:  ADDWF  x32,W
03DAC:  MOVWF  01
03DAE:  MOVLW  00
03DB0:  ADDWFC x33,W
03DB2:  MOVWF  03
03DB4:  MOVF   01,W
03DB6:  ADDLW  17
03DB8:  MOVWF  01
03DBA:  MOVLW  01
03DBC:  ADDWFC 03,F
03DBE:  MOVFF  01,732
03DC2:  MOVFF  03,733
03DC6:  MOVF   x29,W
03DC8:  MULLW  26
03DCA:  MOVF   FF3,W
03DCC:  CLRF   x35
03DCE:  MOVWF  x34
03DD0:  MOVLW  08
03DD2:  ADDWF  x34,W
03DD4:  MOVWF  01
03DD6:  MOVLW  00
03DD8:  ADDWFC x35,W
03DDA:  MOVWF  03
03DDC:  MOVF   01,W
03DDE:  ADDLW  17
03DE0:  MOVWF  FE9
03DE2:  MOVLW  01
03DE4:  ADDWFC 03,W
03DE6:  MOVWF  FEA
03DE8:  MOVFF  FEF,00
03DEC:  MOVFF  FEC,01
03DF0:  MOVFF  FEC,02
03DF4:  MOVFF  FEC,03
03DF8:  MOVFF  733,FEA
03DFC:  MOVFF  732,FE9
03E00:  MOVFF  00,FEF
03E04:  MOVFF  01,FEC
03E08:  MOVFF  02,FEC
03E0C:  MOVFF  03,FEC
....................    adcVals[ch].cosLast = adcVals[ch].cosCounts;
03E10:  MOVF   x29,W
03E12:  MULLW  26
03E14:  MOVF   FF3,W
03E16:  CLRF   x33
03E18:  MOVWF  x32
03E1A:  MOVLW  14
03E1C:  ADDWF  x32,W
03E1E:  MOVWF  01
03E20:  MOVLW  00
03E22:  ADDWFC x33,W
03E24:  MOVWF  03
03E26:  MOVF   01,W
03E28:  ADDLW  17
03E2A:  MOVWF  01
03E2C:  MOVLW  01
03E2E:  ADDWFC 03,F
03E30:  MOVFF  01,732
03E34:  MOVFF  03,733
03E38:  MOVF   x29,W
03E3A:  MULLW  26
03E3C:  MOVF   FF3,W
03E3E:  CLRF   x35
03E40:  MOVWF  x34
03E42:  MOVLW  0C
03E44:  ADDWF  x34,W
03E46:  MOVWF  01
03E48:  MOVLW  00
03E4A:  ADDWFC x35,W
03E4C:  MOVWF  03
03E4E:  MOVF   01,W
03E50:  ADDLW  17
03E52:  MOVWF  FE9
03E54:  MOVLW  01
03E56:  ADDWFC 03,W
03E58:  MOVWF  FEA
03E5A:  MOVFF  FEF,00
03E5E:  MOVFF  FEC,01
03E62:  MOVFF  FEC,02
03E66:  MOVFF  FEC,03
03E6A:  MOVFF  733,FEA
03E6E:  MOVFF  732,FE9
03E72:  MOVFF  00,FEF
03E76:  MOVFF  01,FEC
03E7A:  MOVFF  02,FEC
03E7E:  MOVFF  03,FEC
....................    
....................    adcVals[ch].sinRaw = (float)smData[ch].avgSin;
03E82:  MOVF   x29,W
03E84:  MULLW  26
03E86:  MOVF   FF3,W
03E88:  CLRF   x33
03E8A:  MOVWF  x32
03E8C:  MOVLW  17
03E8E:  ADDWF  x32,W
03E90:  MOVWF  01
03E92:  MOVLW  01
03E94:  ADDWFC x33,W
03E96:  MOVWF  03
03E98:  MOVFF  01,734
03E9C:  MOVWF  x35
03E9E:  MOVF   x29,W
03EA0:  MULLW  09
03EA2:  MOVF   FF3,W
03EA4:  CLRF   x37
03EA6:  MOVWF  x36
03EA8:  MOVLW  01
03EAA:  ADDWF  x36,W
03EAC:  MOVWF  01
03EAE:  MOVLW  00
03EB0:  ADDWFC x37,W
03EB2:  MOVWF  03
03EB4:  MOVF   01,W
03EB6:  ADDLW  D4
03EB8:  MOVWF  FE9
03EBA:  MOVLW  01
03EBC:  ADDWFC 03,W
03EBE:  MOVWF  FEA
03EC0:  MOVFF  FEF,736
03EC4:  MOVFF  FEC,01
03EC8:  MOVFF  FEC,02
03ECC:  MOVFF  FEC,03
03ED0:  MOVFF  03,739
03ED4:  MOVFF  02,738
03ED8:  MOVFF  01,737
03EDC:  MOVLB  0
03EDE:  CALL   23D4
03EE2:  MOVFF  735,FEA
03EE6:  MOVFF  734,FE9
03EEA:  MOVFF  00,FEF
03EEE:  MOVFF  01,FEC
03EF2:  MOVFF  02,FEC
03EF6:  MOVFF  03,FEC
....................    adcVals[ch].cosRaw = (float)smData[ch].avgCos;
03EFA:  MOVLB  7
03EFC:  MOVF   x29,W
03EFE:  MULLW  26
03F00:  MOVF   FF3,W
03F02:  CLRF   x33
03F04:  MOVWF  x32
03F06:  MOVLW  04
03F08:  ADDWF  x32,W
03F0A:  MOVWF  01
03F0C:  MOVLW  00
03F0E:  ADDWFC x33,W
03F10:  MOVWF  03
03F12:  MOVF   01,W
03F14:  ADDLW  17
03F16:  MOVWF  01
03F18:  MOVLW  01
03F1A:  ADDWFC 03,F
03F1C:  MOVFF  01,732
03F20:  MOVFF  03,733
03F24:  MOVF   x29,W
03F26:  MULLW  09
03F28:  MOVF   FF3,W
03F2A:  CLRF   x35
03F2C:  MOVWF  x34
03F2E:  MOVLW  05
03F30:  ADDWF  x34,W
03F32:  MOVWF  01
03F34:  MOVLW  00
03F36:  ADDWFC x35,W
03F38:  MOVWF  03
03F3A:  MOVF   01,W
03F3C:  ADDLW  D4
03F3E:  MOVWF  FE9
03F40:  MOVLW  01
03F42:  ADDWFC 03,W
03F44:  MOVWF  FEA
03F46:  MOVFF  FEF,736
03F4A:  MOVFF  FEC,01
03F4E:  MOVFF  FEC,02
03F52:  MOVFF  FEC,03
03F56:  MOVFF  03,739
03F5A:  MOVFF  02,738
03F5E:  MOVFF  01,737
03F62:  MOVLB  0
03F64:  CALL   23D4
03F68:  MOVFF  733,FEA
03F6C:  MOVFF  732,FE9
03F70:  MOVFF  00,FEF
03F74:  MOVFF  01,FEC
03F78:  MOVFF  02,FEC
03F7C:  MOVFF  03,FEC
....................    
....................    adcVals[ch].sinCounts = adcVals[ch].sinRaw * adcCal[ch].sinGain + adcCal[ch].sinOS;
03F80:  MOVLB  7
03F82:  MOVF   x29,W
03F84:  MULLW  26
03F86:  MOVF   FF3,W
03F88:  CLRF   x33
03F8A:  MOVWF  x32
03F8C:  MOVLW  08
03F8E:  ADDWF  x32,W
03F90:  MOVWF  01
03F92:  MOVLW  00
03F94:  ADDWFC x33,W
03F96:  MOVWF  03
03F98:  MOVF   01,W
03F9A:  ADDLW  17
03F9C:  MOVWF  01
03F9E:  MOVLW  01
03FA0:  ADDWFC 03,F
03FA2:  MOVFF  01,732
03FA6:  MOVFF  03,733
03FAA:  MOVF   x29,W
03FAC:  MULLW  26
03FAE:  MOVF   FF3,W
03FB0:  CLRF   x35
03FB2:  MOVWF  x34
03FB4:  MOVLW  17
03FB6:  ADDWF  x34,W
03FB8:  MOVWF  FE9
03FBA:  MOVLW  01
03FBC:  ADDWFC x35,W
03FBE:  MOVWF  FEA
03FC0:  MOVFF  FEF,76C
03FC4:  MOVFF  FEC,76D
03FC8:  MOVFF  FEC,76E
03FCC:  MOVFF  FEC,76F
03FD0:  MOVF   x29,W
03FD2:  MULLW  10
03FD4:  MOVF   FF3,W
03FD6:  CLRF   x3B
03FD8:  MOVWF  x3A
03FDA:  MOVLW  08
03FDC:  ADDWF  x3A,W
03FDE:  MOVWF  01
03FE0:  MOVLW  00
03FE2:  ADDWFC x3B,W
03FE4:  MOVWF  03
03FE6:  MOVF   01,W
03FE8:  ADDLW  72
03FEA:  MOVWF  FE9
03FEC:  MOVLW  00
03FEE:  ADDWFC 03,W
03FF0:  MOVWF  FEA
03FF2:  MOVFF  FEF,770
03FF6:  MOVFF  FEC,01
03FFA:  MOVFF  FEC,02
03FFE:  MOVFF  FEC,03
04002:  MOVFF  03,773
04006:  MOVFF  02,772
0400A:  MOVFF  01,771
0400E:  MOVLB  0
04010:  CALL   1116
04014:  MOVFF  03,773
04018:  MOVFF  02,772
0401C:  MOVFF  01,771
04020:  MOVFF  00,770
04024:  MOVLB  7
04026:  MOVF   x29,W
04028:  MULLW  10
0402A:  MOVF   FF3,W
0402C:  CLRF   x3B
0402E:  MOVWF  x3A
04030:  MOVLW  72
04032:  ADDWF  x3A,W
04034:  MOVWF  FE9
04036:  MOVLW  00
04038:  ADDWFC x3B,W
0403A:  MOVWF  FEA
0403C:  MOVFF  FEF,774
04040:  MOVFF  FEC,01
04044:  MOVFF  FEC,02
04048:  MOVFF  FEC,03
0404C:  BCF    FD8.1
0404E:  MOVFF  03,777
04052:  MOVFF  02,776
04056:  MOVFF  01,775
0405A:  MOVLB  0
0405C:  CALL   0DDC
04060:  MOVFF  733,FEA
04064:  MOVFF  732,FE9
04068:  MOVFF  00,FEF
0406C:  MOVFF  01,FEC
04070:  MOVFF  02,FEC
04074:  MOVFF  03,FEC
....................    adcVals[ch].cosCounts = adcVals[ch].cosRaw * adcCal[ch].cosGain + adcCal[ch].cosOS;
04078:  MOVLB  7
0407A:  MOVF   x29,W
0407C:  MULLW  26
0407E:  MOVF   FF3,W
04080:  CLRF   x33
04082:  MOVWF  x32
04084:  MOVLW  0C
04086:  ADDWF  x32,W
04088:  MOVWF  01
0408A:  MOVLW  00
0408C:  ADDWFC x33,W
0408E:  MOVWF  03
04090:  MOVF   01,W
04092:  ADDLW  17
04094:  MOVWF  01
04096:  MOVLW  01
04098:  ADDWFC 03,F
0409A:  MOVFF  01,732
0409E:  MOVFF  03,733
040A2:  MOVF   x29,W
040A4:  MULLW  26
040A6:  MOVF   FF3,W
040A8:  CLRF   x35
040AA:  MOVWF  x34
040AC:  MOVLW  04
040AE:  ADDWF  x34,W
040B0:  MOVWF  01
040B2:  MOVLW  00
040B4:  ADDWFC x35,W
040B6:  MOVWF  03
040B8:  MOVF   01,W
040BA:  ADDLW  17
040BC:  MOVWF  FE9
040BE:  MOVLW  01
040C0:  ADDWFC 03,W
040C2:  MOVWF  FEA
040C4:  MOVFF  FEF,76C
040C8:  MOVFF  FEC,76D
040CC:  MOVFF  FEC,76E
040D0:  MOVFF  FEC,76F
040D4:  MOVF   x29,W
040D6:  MULLW  10
040D8:  MOVF   FF3,W
040DA:  CLRF   x39
040DC:  MOVWF  x38
040DE:  MOVLW  0C
040E0:  ADDWF  x38,W
040E2:  MOVWF  01
040E4:  MOVLW  00
040E6:  ADDWFC x39,W
040E8:  MOVWF  03
040EA:  MOVF   01,W
040EC:  ADDLW  72
040EE:  MOVWF  FE9
040F0:  MOVLW  00
040F2:  ADDWFC 03,W
040F4:  MOVWF  FEA
040F6:  MOVFF  FEF,770
040FA:  MOVFF  FEC,01
040FE:  MOVFF  FEC,02
04102:  MOVFF  FEC,03
04106:  MOVFF  03,773
0410A:  MOVFF  02,772
0410E:  MOVFF  01,771
04112:  MOVLB  0
04114:  CALL   1116
04118:  MOVFF  03,773
0411C:  MOVFF  02,772
04120:  MOVFF  01,771
04124:  MOVFF  00,770
04128:  MOVLB  7
0412A:  MOVF   x29,W
0412C:  MULLW  10
0412E:  MOVF   FF3,W
04130:  CLRF   x39
04132:  MOVWF  x38
04134:  MOVLW  04
04136:  ADDWF  x38,W
04138:  MOVWF  01
0413A:  MOVLW  00
0413C:  ADDWFC x39,W
0413E:  MOVWF  03
04140:  MOVF   01,W
04142:  ADDLW  72
04144:  MOVWF  FE9
04146:  MOVLW  00
04148:  ADDWFC 03,W
0414A:  MOVWF  FEA
0414C:  MOVFF  FEF,774
04150:  MOVFF  FEC,01
04154:  MOVFF  FEC,02
04158:  MOVFF  FEC,03
0415C:  BCF    FD8.1
0415E:  MOVFF  03,777
04162:  MOVFF  02,776
04166:  MOVFF  01,775
0416A:  MOVLB  0
0416C:  CALL   0DDC
04170:  MOVFF  733,FEA
04174:  MOVFF  732,FE9
04178:  MOVFF  00,FEF
0417C:  MOVFF  01,FEC
04180:  MOVFF  02,FEC
04184:  MOVFF  03,FEC
....................    float pTmp = 0;
....................    float polePitch = magPP;
04188:  MOVLB  7
0418A:  CLRF   x2D
0418C:  CLRF   x2C
0418E:  CLRF   x2B
04190:  CLRF   x2A
04192:  CLRF   x31
04194:  CLRF   x30
04196:  CLRF   x2F
04198:  MOVLW  7F
0419A:  MOVWF  x2E
....................    
....................    if (adcVals[ch].cosCounts < 0){
0419C:  MOVF   x29,W
0419E:  MULLW  26
041A0:  MOVF   FF3,W
041A2:  CLRF   x33
041A4:  MOVWF  x32
041A6:  MOVLW  0C
041A8:  ADDWF  x32,W
041AA:  MOVWF  01
041AC:  MOVLW  00
041AE:  ADDWFC x33,W
041B0:  MOVWF  03
041B2:  MOVF   01,W
041B4:  ADDLW  17
041B6:  MOVWF  FE9
041B8:  MOVLW  01
041BA:  ADDWFC 03,W
041BC:  MOVWF  FEA
041BE:  MOVFF  FEF,76C
041C2:  MOVFF  FEC,76D
041C6:  MOVFF  FEC,76E
041CA:  MOVFF  FEC,76F
041CE:  CLRF   x73
041D0:  CLRF   x72
041D2:  CLRF   x71
041D4:  CLRF   x70
041D6:  MOVLB  0
041D8:  CALL   0D62
041DC:  BTFSS  FD8.0
041DE:  BRA    4348
....................       if ((adcVals[ch].sinCounts > 0) && (adcVals[ch].sinLast < 0)){
041E0:  MOVLB  7
041E2:  MOVF   x29,W
041E4:  MULLW  26
041E6:  MOVF   FF3,W
041E8:  CLRF   x33
041EA:  MOVWF  x32
041EC:  MOVLW  08
041EE:  ADDWF  x32,W
041F0:  MOVWF  01
041F2:  MOVLW  00
041F4:  ADDWFC x33,W
041F6:  MOVWF  03
041F8:  MOVF   01,W
041FA:  ADDLW  17
041FC:  MOVWF  FE9
041FE:  MOVLW  01
04200:  ADDWFC 03,W
04202:  MOVWF  FEA
04204:  MOVFF  FEF,770
04208:  MOVFF  FEC,733
0420C:  MOVFF  FEC,772
04210:  MOVFF  FEC,773
04214:  CLRF   x6F
04216:  CLRF   x6E
04218:  CLRF   x6D
0421A:  CLRF   x6C
0421C:  MOVFF  733,771
04220:  MOVLB  0
04222:  CALL   0D62
04226:  BNC   4294
04228:  MOVLB  7
0422A:  MOVF   x29,W
0422C:  MULLW  26
0422E:  MOVF   FF3,W
04230:  CLRF   x33
04232:  MOVWF  x32
04234:  MOVLW  10
04236:  ADDWF  x32,W
04238:  MOVWF  01
0423A:  MOVLW  00
0423C:  ADDWFC x33,W
0423E:  MOVWF  03
04240:  MOVF   01,W
04242:  ADDLW  17
04244:  MOVWF  FE9
04246:  MOVLW  01
04248:  ADDWFC 03,W
0424A:  MOVWF  FEA
0424C:  MOVFF  FEF,76C
04250:  MOVFF  FEC,76D
04254:  MOVFF  FEC,76E
04258:  MOVFF  FEC,76F
0425C:  CLRF   x73
0425E:  CLRF   x72
04260:  CLRF   x71
04262:  CLRF   x70
04264:  MOVLB  0
04266:  CALL   0D62
0426A:  BNC   4294
....................          adcVals[ch].npoles--;
0426C:  MOVLB  7
0426E:  MOVF   x29,W
04270:  MULLW  26
04272:  MOVF   FF3,W
04274:  CLRF   x33
04276:  MOVWF  x32
04278:  MOVLW  1C
0427A:  ADDWF  x32,W
0427C:  MOVWF  01
0427E:  MOVLW  00
04280:  ADDWFC x33,W
04282:  MOVWF  03
04284:  MOVF   01,W
04286:  ADDLW  17
04288:  MOVWF  FE9
0428A:  MOVLW  01
0428C:  ADDWFC 03,W
0428E:  MOVWF  FEA
04290:  DECF   FEF,F
....................       }
04292:  BRA    4346
....................       else if ((adcVals[ch].sinCounts < 0) && (adcVals[ch].sinLast > 0)){
04294:  MOVLB  7
04296:  MOVF   x29,W
04298:  MULLW  26
0429A:  MOVF   FF3,W
0429C:  CLRF   x33
0429E:  MOVWF  x32
042A0:  MOVLW  08
042A2:  ADDWF  x32,W
042A4:  MOVWF  01
042A6:  MOVLW  00
042A8:  ADDWFC x33,W
042AA:  MOVWF  03
042AC:  MOVF   01,W
042AE:  ADDLW  17
042B0:  MOVWF  FE9
042B2:  MOVLW  01
042B4:  ADDWFC 03,W
042B6:  MOVWF  FEA
042B8:  MOVFF  FEF,76C
042BC:  MOVFF  FEC,733
042C0:  MOVFF  FEC,76E
042C4:  MOVFF  FEC,76F
042C8:  MOVFF  733,76D
042CC:  CLRF   x73
042CE:  CLRF   x72
042D0:  CLRF   x71
042D2:  CLRF   x70
042D4:  MOVLB  0
042D6:  CALL   0D62
042DA:  BNC   4348
042DC:  MOVLB  7
042DE:  MOVF   x29,W
042E0:  MULLW  26
042E2:  MOVF   FF3,W
042E4:  CLRF   x33
042E6:  MOVWF  x32
042E8:  MOVLW  10
042EA:  ADDWF  x32,W
042EC:  MOVWF  01
042EE:  MOVLW  00
042F0:  ADDWFC x33,W
042F2:  MOVWF  03
042F4:  MOVF   01,W
042F6:  ADDLW  17
042F8:  MOVWF  FE9
042FA:  MOVLW  01
042FC:  ADDWFC 03,W
042FE:  MOVWF  FEA
04300:  MOVFF  FEF,770
04304:  MOVFF  FEC,771
04308:  MOVFF  FEC,772
0430C:  MOVFF  FEC,773
04310:  CLRF   x6F
04312:  CLRF   x6E
04314:  CLRF   x6D
04316:  CLRF   x6C
04318:  MOVLB  0
0431A:  CALL   0D62
0431E:  BNC   4348
....................          adcVals[ch].npoles++;
04320:  MOVLB  7
04322:  MOVF   x29,W
04324:  MULLW  26
04326:  MOVF   FF3,W
04328:  CLRF   x33
0432A:  MOVWF  x32
0432C:  MOVLW  1C
0432E:  ADDWF  x32,W
04330:  MOVWF  01
04332:  MOVLW  00
04334:  ADDWFC x33,W
04336:  MOVWF  03
04338:  MOVF   01,W
0433A:  ADDLW  17
0433C:  MOVWF  FE9
0433E:  MOVLW  01
04340:  ADDWFC 03,W
04342:  MOVWF  FEA
04344:  INCF   FEF,F
04346:  MOVLB  0
....................       }
....................    }
....................    
....................    adcVals[ch].p0 = polePitch * ( 1000 / (2*PI) ) * atan2( (float)adcVals[ch].sinCounts, (float)adcVals[ch].cosCounts );
04348:  MOVLB  7
0434A:  MOVF   x29,W
0434C:  MULLW  26
0434E:  MOVF   FF3,W
04350:  CLRF   x33
04352:  MOVWF  x32
04354:  MOVLW  18
04356:  ADDWF  x32,W
04358:  MOVWF  01
0435A:  MOVLW  00
0435C:  ADDWFC x33,W
0435E:  MOVWF  03
04360:  MOVF   01,W
04362:  ADDLW  17
04364:  MOVWF  01
04366:  MOVLW  01
04368:  ADDWFC 03,F
0436A:  MOVFF  01,732
0436E:  MOVFF  03,733
04372:  MOVFF  731,76F
04376:  MOVFF  730,76E
0437A:  MOVFF  72F,76D
0437E:  MOVFF  72E,76C
04382:  MOVLW  AA
04384:  MOVWF  x73
04386:  MOVLW  27
04388:  MOVWF  x72
0438A:  MOVLW  1F
0438C:  MOVWF  x71
0438E:  MOVLW  86
04390:  MOVWF  x70
04392:  MOVLB  0
04394:  CALL   1116
04398:  MOVFF  03,737
0439C:  MOVFF  02,736
043A0:  MOVFF  01,735
043A4:  MOVFF  00,734
043A8:  MOVLB  7
043AA:  MOVF   x29,W
043AC:  MULLW  26
043AE:  MOVF   FF3,W
043B0:  CLRF   x39
043B2:  MOVWF  x38
043B4:  MOVLW  08
043B6:  ADDWF  x38,W
043B8:  MOVWF  01
043BA:  MOVLW  00
043BC:  ADDWFC x39,W
043BE:  MOVWF  03
043C0:  MOVF   01,W
043C2:  ADDLW  17
043C4:  MOVWF  FE9
043C6:  MOVLW  01
043C8:  ADDWFC 03,W
043CA:  MOVWF  FEA
043CC:  MOVFF  FEF,738
043D0:  MOVFF  FEC,739
043D4:  MOVFF  FEC,73A
043D8:  MOVFF  FEC,73B
043DC:  MOVF   x29,W
043DE:  MULLW  26
043E0:  MOVF   FF3,W
043E2:  CLRF   x3D
043E4:  MOVWF  x3C
043E6:  MOVLW  0C
043E8:  ADDWF  x3C,W
043EA:  MOVWF  01
043EC:  MOVLW  00
043EE:  ADDWFC x3D,W
043F0:  MOVWF  03
043F2:  MOVF   01,W
043F4:  ADDLW  17
043F6:  MOVWF  FE9
043F8:  MOVLW  01
043FA:  ADDWFC 03,W
043FC:  MOVWF  FEA
043FE:  MOVFF  FEF,00
04402:  MOVFF  FEC,01
04406:  MOVFF  FEC,02
0440A:  MOVFF  FEC,03
0440E:  MOVFF  03,73F
04412:  MOVFF  02,73E
04416:  MOVFF  01,73D
0441A:  MOVFF  00,73C
0441E:  MOVFF  73B,743
04422:  MOVFF  73A,742
04426:  MOVFF  739,741
0442A:  MOVFF  738,740
0442E:  MOVFF  03,747
04432:  MOVFF  02,746
04436:  MOVFF  01,745
0443A:  MOVFF  00,744
0443E:  MOVLB  0
04440:  GOTO   2ABA
04444:  MOVFF  737,76F
04448:  MOVFF  736,76E
0444C:  MOVFF  735,76D
04450:  MOVFF  734,76C
04454:  MOVFF  03,773
04458:  MOVFF  02,772
0445C:  MOVFF  01,771
04460:  MOVFF  00,770
04464:  CALL   1116
04468:  MOVFF  733,FEA
0446C:  MOVFF  732,FE9
04470:  MOVFF  00,FEF
04474:  MOVFF  01,FEC
04478:  MOVFF  02,FEC
0447C:  MOVFF  03,FEC
....................    pTmp = adcVals[ch].p0 + ( 1000 * polePitch * (float)adcVals[ch].npoles );
04480:  MOVLB  7
04482:  MOVF   x29,W
04484:  MULLW  26
04486:  MOVF   FF3,W
04488:  CLRF   x33
0448A:  MOVWF  x32
0448C:  MOVLW  18
0448E:  ADDWF  x32,W
04490:  MOVWF  01
04492:  MOVLW  00
04494:  ADDWFC x33,W
04496:  MOVWF  03
04498:  MOVF   01,W
0449A:  ADDLW  17
0449C:  MOVWF  FE9
0449E:  MOVLW  01
044A0:  ADDWFC 03,W
044A2:  MOVWF  FEA
044A4:  MOVFF  FEF,732
044A8:  MOVFF  FEC,733
044AC:  MOVFF  FEC,734
044B0:  MOVFF  FEC,735
044B4:  CLRF   x6F
044B6:  CLRF   x6E
044B8:  MOVLW  7A
044BA:  MOVWF  x6D
044BC:  MOVLW  88
044BE:  MOVWF  x6C
044C0:  MOVFF  731,773
044C4:  MOVFF  730,772
044C8:  MOVFF  72F,771
044CC:  MOVFF  72E,770
044D0:  MOVLB  0
044D2:  CALL   1116
044D6:  MOVFF  03,739
044DA:  MOVFF  02,738
044DE:  MOVFF  01,737
044E2:  MOVFF  00,736
044E6:  MOVLB  7
044E8:  MOVF   x29,W
044EA:  MULLW  26
044EC:  MOVF   FF3,W
044EE:  CLRF   x3B
044F0:  MOVWF  x3A
044F2:  MOVLW  1C
044F4:  ADDWF  x3A,W
044F6:  MOVWF  01
044F8:  MOVLW  00
044FA:  ADDWFC x3B,W
044FC:  MOVWF  03
044FE:  MOVF   01,W
04500:  ADDLW  17
04502:  MOVWF  FE9
04504:  MOVLW  01
04506:  ADDWFC 03,W
04508:  MOVWF  FEA
0450A:  MOVF   FEF,W
0450C:  CLRF   x63
0450E:  MOVWF  x62
04510:  BTFSC  x62.7
04512:  DECF   x63,F
04514:  MOVLB  0
04516:  CALL   2D68
0451A:  MOVFF  739,76F
0451E:  MOVFF  738,76E
04522:  MOVFF  737,76D
04526:  MOVFF  736,76C
0452A:  MOVFF  03,773
0452E:  MOVFF  02,772
04532:  MOVFF  01,771
04536:  MOVFF  00,770
0453A:  CALL   1116
0453E:  MOVFF  FEA,737
04542:  MOVFF  FE9,736
04546:  BCF    FD8.1
04548:  MOVFF  735,773
0454C:  MOVFF  734,772
04550:  MOVFF  733,771
04554:  MOVFF  732,770
04558:  MOVFF  03,777
0455C:  MOVFF  02,776
04560:  MOVFF  01,775
04564:  MOVFF  00,774
04568:  CALL   0DDC
0456C:  MOVFF  737,FEA
04570:  MOVFF  736,FE9
04574:  MOVFF  03,72D
04578:  MOVFF  02,72C
0457C:  MOVFF  01,72B
04580:  MOVFF  00,72A
....................    
....................    adcVals[ch].pReal = sc[ch].c5*pow(pTmp,5) + sc[ch].c4*pow(pTmp,4) + sc[ch].c3*pow(pTmp,3) + sc[ch].c2*pow(pTmp,2) + sc[ch].c1*(pTmp) + sc[ch].c0;
04584:  MOVLB  7
04586:  MOVF   x29,W
04588:  MULLW  26
0458A:  MOVF   FF3,W
0458C:  CLRF   x33
0458E:  MOVWF  x32
04590:  MOVLW  1D
04592:  ADDWF  x32,W
04594:  MOVWF  01
04596:  MOVLW  00
04598:  ADDWFC x33,W
0459A:  MOVWF  03
0459C:  MOVF   01,W
0459E:  ADDLW  17
045A0:  MOVWF  01
045A2:  MOVLW  01
045A4:  ADDWFC 03,F
045A6:  MOVFF  01,732
045AA:  MOVFF  03,733
045AE:  MOVF   x29,W
045B0:  MULLW  18
045B2:  MOVF   FF3,W
045B4:  CLRF   x35
045B6:  MOVWF  x34
045B8:  MOVLW  14
045BA:  ADDWF  x34,W
045BC:  MOVWF  01
045BE:  MOVLW  00
045C0:  ADDWFC x35,W
045C2:  MOVWF  03
045C4:  MOVF   01,W
045C6:  ADDLW  92
045C8:  MOVWF  FE9
045CA:  MOVLW  00
045CC:  ADDWFC 03,W
045CE:  MOVWF  FEA
045D0:  MOVFF  FEF,734
045D4:  MOVFF  FEC,735
045D8:  MOVFF  FEC,736
045DC:  MOVFF  FEC,737
045E0:  MOVFF  72D,743
045E4:  MOVFF  72C,742
045E8:  MOVFF  72B,741
045EC:  MOVFF  72A,740
045F0:  CLRF   x47
045F2:  CLRF   x46
045F4:  MOVLW  20
045F6:  MOVWF  x45
045F8:  MOVLW  81
045FA:  MOVWF  x44
045FC:  MOVLB  0
045FE:  CALL   3A9E
04602:  MOVFF  737,76F
04606:  MOVFF  736,76E
0460A:  MOVFF  735,76D
0460E:  MOVFF  734,76C
04612:  MOVFF  03,773
04616:  MOVFF  02,772
0461A:  MOVFF  01,771
0461E:  MOVFF  00,770
04622:  CALL   1116
04626:  MOVFF  03,737
0462A:  MOVFF  02,736
0462E:  MOVFF  01,735
04632:  MOVFF  00,734
04636:  MOVLB  7
04638:  MOVF   x29,W
0463A:  MULLW  18
0463C:  MOVF   FF3,W
0463E:  CLRF   x39
04640:  MOVWF  x38
04642:  MOVLW  10
04644:  ADDWF  x38,W
04646:  MOVWF  01
04648:  MOVLW  00
0464A:  ADDWFC x39,W
0464C:  MOVWF  03
0464E:  MOVF   01,W
04650:  ADDLW  92
04652:  MOVWF  FE9
04654:  MOVLW  00
04656:  ADDWFC 03,W
04658:  MOVWF  FEA
0465A:  MOVFF  FEF,738
0465E:  MOVFF  FEC,739
04662:  MOVFF  FEC,73A
04666:  MOVFF  FEC,73B
0466A:  MOVFF  72D,743
0466E:  MOVFF  72C,742
04672:  MOVFF  72B,741
04676:  MOVFF  72A,740
0467A:  CLRF   x47
0467C:  CLRF   x46
0467E:  CLRF   x45
04680:  MOVLW  81
04682:  MOVWF  x44
04684:  MOVLB  0
04686:  CALL   3A9E
0468A:  MOVFF  73B,76F
0468E:  MOVFF  73A,76E
04692:  MOVFF  739,76D
04696:  MOVFF  738,76C
0469A:  MOVFF  03,773
0469E:  MOVFF  02,772
046A2:  MOVFF  01,771
046A6:  MOVFF  00,770
046AA:  CALL   1116
046AE:  MOVFF  FEA,739
046B2:  MOVFF  FE9,738
046B6:  BCF    FD8.1
046B8:  MOVFF  737,773
046BC:  MOVFF  736,772
046C0:  MOVFF  735,771
046C4:  MOVFF  734,770
046C8:  MOVFF  03,777
046CC:  MOVFF  02,776
046D0:  MOVFF  01,775
046D4:  MOVFF  00,774
046D8:  CALL   0DDC
046DC:  MOVFF  739,FEA
046E0:  MOVFF  738,FE9
046E4:  MOVFF  03,737
046E8:  MOVFF  02,736
046EC:  MOVFF  01,735
046F0:  MOVFF  00,734
046F4:  MOVLB  7
046F6:  MOVF   x29,W
046F8:  MULLW  18
046FA:  MOVF   FF3,W
046FC:  CLRF   x3B
046FE:  MOVWF  x3A
04700:  MOVLW  0C
04702:  ADDWF  x3A,W
04704:  MOVWF  01
04706:  MOVLW  00
04708:  ADDWFC x3B,W
0470A:  MOVWF  03
0470C:  MOVF   01,W
0470E:  ADDLW  92
04710:  MOVWF  FE9
04712:  MOVLW  00
04714:  ADDWFC 03,W
04716:  MOVWF  FEA
04718:  MOVFF  FEF,73A
0471C:  MOVFF  FEC,73B
04720:  MOVFF  FEC,73C
04724:  MOVFF  FEC,73D
04728:  MOVFF  72D,743
0472C:  MOVFF  72C,742
04730:  MOVFF  72B,741
04734:  MOVFF  72A,740
04738:  CLRF   x47
0473A:  CLRF   x46
0473C:  MOVLW  40
0473E:  MOVWF  x45
04740:  MOVLW  80
04742:  MOVWF  x44
04744:  MOVLB  0
04746:  CALL   3A9E
0474A:  MOVFF  73D,76F
0474E:  MOVFF  73C,76E
04752:  MOVFF  73B,76D
04756:  MOVFF  73A,76C
0475A:  MOVFF  03,773
0475E:  MOVFF  02,772
04762:  MOVFF  01,771
04766:  MOVFF  00,770
0476A:  CALL   1116
0476E:  MOVFF  FEA,73B
04772:  MOVFF  FE9,73A
04776:  BCF    FD8.1
04778:  MOVFF  737,773
0477C:  MOVFF  736,772
04780:  MOVFF  735,771
04784:  MOVFF  734,770
04788:  MOVFF  03,777
0478C:  MOVFF  02,776
04790:  MOVFF  01,775
04794:  MOVFF  00,774
04798:  CALL   0DDC
0479C:  MOVFF  73B,FEA
047A0:  MOVFF  73A,FE9
047A4:  MOVFF  03,737
047A8:  MOVFF  02,736
047AC:  MOVFF  01,735
047B0:  MOVFF  00,734
047B4:  MOVLB  7
047B6:  MOVF   x29,W
047B8:  MULLW  18
047BA:  MOVF   FF3,W
047BC:  CLRF   x3D
047BE:  MOVWF  x3C
047C0:  MOVLW  08
047C2:  ADDWF  x3C,W
047C4:  MOVWF  01
047C6:  MOVLW  00
047C8:  ADDWFC x3D,W
047CA:  MOVWF  03
047CC:  MOVF   01,W
047CE:  ADDLW  92
047D0:  MOVWF  FE9
047D2:  MOVLW  00
047D4:  ADDWFC 03,W
047D6:  MOVWF  FEA
047D8:  MOVFF  FEF,73C
047DC:  MOVFF  FEC,73D
047E0:  MOVFF  FEC,73E
047E4:  MOVFF  FEC,73F
047E8:  MOVFF  72D,743
047EC:  MOVFF  72C,742
047F0:  MOVFF  72B,741
047F4:  MOVFF  72A,740
047F8:  CLRF   x47
047FA:  CLRF   x46
047FC:  CLRF   x45
047FE:  MOVLW  80
04800:  MOVWF  x44
04802:  MOVLB  0
04804:  CALL   3A9E
04808:  MOVFF  73F,76F
0480C:  MOVFF  73E,76E
04810:  MOVFF  73D,76D
04814:  MOVFF  73C,76C
04818:  MOVFF  03,773
0481C:  MOVFF  02,772
04820:  MOVFF  01,771
04824:  MOVFF  00,770
04828:  CALL   1116
0482C:  MOVFF  FEA,73D
04830:  MOVFF  FE9,73C
04834:  BCF    FD8.1
04836:  MOVFF  737,773
0483A:  MOVFF  736,772
0483E:  MOVFF  735,771
04842:  MOVFF  734,770
04846:  MOVFF  03,777
0484A:  MOVFF  02,776
0484E:  MOVFF  01,775
04852:  MOVFF  00,774
04856:  CALL   0DDC
0485A:  MOVFF  73D,FEA
0485E:  MOVFF  73C,FE9
04862:  MOVFF  03,737
04866:  MOVFF  02,736
0486A:  MOVFF  01,735
0486E:  MOVFF  00,734
04872:  MOVLB  7
04874:  MOVF   x29,W
04876:  MULLW  18
04878:  MOVF   FF3,W
0487A:  CLRF   x3F
0487C:  MOVWF  x3E
0487E:  MOVLW  04
04880:  ADDWF  x3E,W
04882:  MOVWF  01
04884:  MOVLW  00
04886:  ADDWFC x3F,W
04888:  MOVWF  03
0488A:  MOVF   01,W
0488C:  ADDLW  92
0488E:  MOVWF  FE9
04890:  MOVLW  00
04892:  ADDWFC 03,W
04894:  MOVWF  FEA
04896:  MOVFF  FEF,76C
0489A:  MOVFF  FEC,76D
0489E:  MOVFF  FEC,76E
048A2:  MOVFF  FEC,741
048A6:  MOVFF  741,76F
048AA:  MOVFF  72D,773
048AE:  MOVFF  72C,772
048B2:  MOVFF  72B,771
048B6:  MOVFF  72A,770
048BA:  MOVLB  0
048BC:  CALL   1116
048C0:  MOVFF  FEA,73F
048C4:  MOVFF  FE9,73E
048C8:  BCF    FD8.1
048CA:  MOVFF  737,773
048CE:  MOVFF  736,772
048D2:  MOVFF  735,771
048D6:  MOVFF  734,770
048DA:  MOVFF  03,777
048DE:  MOVFF  02,776
048E2:  MOVFF  01,775
048E6:  MOVFF  00,774
048EA:  CALL   0DDC
048EE:  MOVFF  73F,FEA
048F2:  MOVFF  73E,FE9
048F6:  MOVFF  03,773
048FA:  MOVFF  02,772
048FE:  MOVFF  01,771
04902:  MOVFF  00,770
04906:  MOVLB  7
04908:  MOVF   x29,W
0490A:  MULLW  18
0490C:  MOVF   FF3,W
0490E:  CLRF   x41
04910:  MOVWF  x40
04912:  MOVLW  92
04914:  ADDWF  x40,W
04916:  MOVWF  FE9
04918:  MOVLW  00
0491A:  ADDWFC x41,W
0491C:  MOVWF  FEA
0491E:  MOVFF  FEF,774
04922:  MOVFF  FEC,01
04926:  MOVFF  FEC,02
0492A:  MOVFF  FEC,03
0492E:  BCF    FD8.1
04930:  MOVFF  03,777
04934:  MOVFF  02,776
04938:  MOVFF  01,775
0493C:  MOVLB  0
0493E:  CALL   0DDC
04942:  MOVFF  733,FEA
04946:  MOVFF  732,FE9
0494A:  MOVFF  00,FEF
0494E:  MOVFF  01,FEC
04952:  MOVFF  02,FEC
04956:  MOVFF  03,FEC
....................    adcVals[ch].pReal -= adcVals[ch].pHome;
0495A:  MOVLB  7
0495C:  MOVF   x29,W
0495E:  MULLW  26
04960:  MOVF   FF3,W
04962:  CLRF   x33
04964:  MOVWF  x32
04966:  MOVLW  1D
04968:  ADDWF  x32,W
0496A:  MOVWF  01
0496C:  MOVLW  00
0496E:  ADDWFC x33,W
04970:  MOVWF  03
04972:  MOVF   01,W
04974:  ADDLW  17
04976:  MOVWF  01
04978:  MOVLW  01
0497A:  ADDWFC 03,F
0497C:  MOVFF  01,732
04980:  MOVFF  03,733
04984:  MOVFF  03,FEA
04988:  MOVFF  01,FE9
0498C:  MOVFF  FEF,770
04990:  MOVFF  FEC,771
04994:  MOVFF  FEC,772
04998:  MOVFF  FEC,773
0499C:  MOVF   x29,W
0499E:  MULLW  26
049A0:  MOVF   FF3,W
049A2:  CLRF   x39
049A4:  MOVWF  x38
049A6:  MOVLW  21
049A8:  ADDWF  x38,W
049AA:  MOVWF  01
049AC:  MOVLW  00
049AE:  ADDWFC x39,W
049B0:  MOVWF  03
049B2:  MOVF   01,W
049B4:  ADDLW  17
049B6:  MOVWF  FE9
049B8:  MOVLW  01
049BA:  ADDWFC 03,W
049BC:  MOVWF  FEA
049BE:  MOVFF  FEF,774
049C2:  MOVFF  FEC,01
049C6:  MOVFF  FEC,02
049CA:  MOVFF  FEC,03
049CE:  BSF    FD8.1
049D0:  MOVFF  03,777
049D4:  MOVFF  02,776
049D8:  MOVFF  01,775
049DC:  MOVLB  0
049DE:  CALL   0DDC
049E2:  MOVFF  733,FEA
049E6:  MOVFF  732,FE9
049EA:  MOVFF  00,FEF
049EE:  MOVFF  01,FEC
049F2:  MOVFF  02,FEC
049F6:  MOVFF  03,FEC
....................    if (ch == chX) adcVals[ch].pReal *= -1;
049FA:  MOVLB  7
049FC:  MOVF   x29,F
049FE:  BNZ   4A5C
04A00:  MOVF   x29,W
04A02:  MULLW  26
04A04:  MOVF   FF3,W
04A06:  CLRF   x33
04A08:  MOVWF  x32
04A0A:  MOVLW  1D
04A0C:  ADDWF  x32,W
04A0E:  MOVWF  01
04A10:  MOVLW  00
04A12:  ADDWFC x33,W
04A14:  MOVWF  03
04A16:  MOVF   01,W
04A18:  ADDLW  17
04A1A:  MOVWF  FE9
04A1C:  MOVLW  01
04A1E:  ADDWFC 03,W
04A20:  MOVWF  FEA
04A22:  MOVFF  FEF,76C
04A26:  MOVFF  FEC,76D
04A2A:  MOVFF  FEC,76E
04A2E:  MOVFF  FEC,76F
04A32:  MOVF   FED,F
04A34:  MOVF   FED,F
04A36:  MOVF   FED,F
04A38:  CLRF   x73
04A3A:  CLRF   x72
04A3C:  MOVLW  80
04A3E:  MOVWF  x71
04A40:  MOVLW  7F
04A42:  MOVWF  x70
04A44:  MOVLB  0
04A46:  CALL   1116
04A4A:  MOVFF  00,FEF
04A4E:  MOVFF  01,FEC
04A52:  MOVFF  02,FEC
04A56:  MOVFF  03,FEC
04A5A:  MOVLB  7
....................    
....................    PID[ch].PVold = PID[ch].PV;
04A5C:  MOVF   x29,W
04A5E:  MULLW  28
04A60:  MOVF   FF3,W
04A62:  CLRF   x33
04A64:  MOVWF  x32
04A66:  MOVLW  14
04A68:  ADDWF  x32,W
04A6A:  MOVWF  01
04A6C:  MOVLW  00
04A6E:  ADDWFC x33,W
04A70:  MOVWF  03
04A72:  MOVF   01,W
04A74:  ADDLW  20
04A76:  MOVWF  01
04A78:  MOVLW  00
04A7A:  ADDWFC 03,F
04A7C:  MOVFF  01,732
04A80:  MOVFF  03,733
04A84:  MOVF   x29,W
04A86:  MULLW  28
04A88:  MOVF   FF3,W
04A8A:  CLRF   x35
04A8C:  MOVWF  x34
04A8E:  MOVLW  10
04A90:  ADDWF  x34,W
04A92:  MOVWF  01
04A94:  MOVLW  00
04A96:  ADDWFC x35,W
04A98:  MOVWF  03
04A9A:  MOVF   01,W
04A9C:  ADDLW  20
04A9E:  MOVWF  FE9
04AA0:  MOVLW  00
04AA2:  ADDWFC 03,W
04AA4:  MOVWF  FEA
04AA6:  MOVFF  FEF,00
04AAA:  MOVFF  FEC,01
04AAE:  MOVFF  FEC,02
04AB2:  MOVFF  FEC,03
04AB6:  MOVFF  733,FEA
04ABA:  MOVFF  732,FE9
04ABE:  MOVFF  00,FEF
04AC2:  MOVFF  01,FEC
04AC6:  MOVFF  02,FEC
04ACA:  MOVFF  03,FEC
....................    PID[ch].PV = adcVals[ch].pReal;
04ACE:  MOVF   x29,W
04AD0:  MULLW  28
04AD2:  MOVF   FF3,W
04AD4:  CLRF   x33
04AD6:  MOVWF  x32
04AD8:  MOVLW  10
04ADA:  ADDWF  x32,W
04ADC:  MOVWF  01
04ADE:  MOVLW  00
04AE0:  ADDWFC x33,W
04AE2:  MOVWF  03
04AE4:  MOVF   01,W
04AE6:  ADDLW  20
04AE8:  MOVWF  01
04AEA:  MOVLW  00
04AEC:  ADDWFC 03,F
04AEE:  MOVFF  01,732
04AF2:  MOVFF  03,733
04AF6:  MOVF   x29,W
04AF8:  MULLW  26
04AFA:  MOVF   FF3,W
04AFC:  CLRF   x35
04AFE:  MOVWF  x34
04B00:  MOVLW  1D
04B02:  ADDWF  x34,W
04B04:  MOVWF  01
04B06:  MOVLW  00
04B08:  ADDWFC x35,W
04B0A:  MOVWF  03
04B0C:  MOVF   01,W
04B0E:  ADDLW  17
04B10:  MOVWF  FE9
04B12:  MOVLW  01
04B14:  ADDWFC 03,W
04B16:  MOVWF  FEA
04B18:  MOVFF  FEF,00
04B1C:  MOVFF  FEC,01
04B20:  MOVFF  FEC,02
04B24:  MOVFF  FEC,03
04B28:  MOVFF  733,FEA
04B2C:  MOVFF  732,FE9
04B30:  MOVFF  00,FEF
04B34:  MOVFF  01,FEC
04B38:  MOVFF  02,FEC
04B3C:  MOVFF  03,FEC
04B40:  MOVLB  0
04B42:  GOTO   4C9E (RETURN)
.................... }  
.................... 
.................... /*****************************************************************************/
.................... /* SENSOR MONITOR INTERRUPT TASK                                             */
.................... /* starts conversion of the other two ADCs                                   */
.................... /*****************************************************************************/
.................... void sensor_monitor_interrupt_task(){
....................    static int8 ch = 0;
....................    
....................    if (!smData[ch].adcBusy){
*
001C0:  MOVLB  1
001C2:  MOVF   xE7,W
001C4:  MULLW  09
001C6:  MOVF   FF3,W
001C8:  MOVLB  7
001CA:  CLRF   x86
001CC:  MOVWF  x85
001CE:  MOVLW  D4
001D0:  ADDWF  x85,W
001D2:  MOVWF  FE9
001D4:  MOVLW  01
001D6:  ADDWFC x86,W
001D8:  MOVWF  FEA
001DA:  BTFSC  FEF.1
001DC:  BRA    0256
....................       smData[ch].adcBusy = true;
001DE:  MOVLB  1
001E0:  MOVF   xE7,W
001E2:  MULLW  09
001E4:  MOVF   FF3,W
001E6:  MOVLB  7
001E8:  CLRF   x86
001EA:  MOVWF  x85
001EC:  MOVLW  D4
001EE:  ADDWF  x85,W
001F0:  MOVWF  FE9
001F2:  MOVLW  01
001F4:  ADDWFC x86,W
001F6:  MOVWF  FEA
001F8:  BSF    FEF.1
....................          
....................       ads_start_conv_block(ch);
001FA:  MOVFF  1E7,785
001FE:  MOVLB  0
00200:  BRA    01A4
....................       ch = !ch;
00202:  MOVLB  1
00204:  MOVF   xE7,F
00206:  BZ    020C
00208:  MOVLW  00
0020A:  BRA    020E
0020C:  MOVLW  01
0020E:  MOVWF  xE7
....................          
....................       smData[!ch].dataReady = true;
00210:  MOVF   xE7,F
00212:  BZ    0218
00214:  MOVLW  00
00216:  BRA    021A
00218:  MOVLW  01
0021A:  MULLW  09
0021C:  MOVF   FF3,W
0021E:  MOVLB  7
00220:  CLRF   x86
00222:  MOVWF  x85
00224:  MOVLW  D4
00226:  ADDWF  x85,W
00228:  MOVWF  FE9
0022A:  MOVLW  01
0022C:  ADDWFC x86,W
0022E:  MOVWF  FEA
00230:  BSF    FEF.0
....................       smData[!ch].adcBusy = false;
00232:  MOVLB  1
00234:  MOVF   xE7,F
00236:  BZ    023C
00238:  MOVLW  00
0023A:  BRA    023E
0023C:  MOVLW  01
0023E:  MULLW  09
00240:  MOVF   FF3,W
00242:  MOVLB  7
00244:  CLRF   x86
00246:  MOVWF  x85
00248:  MOVLW  D4
0024A:  ADDWF  x85,W
0024C:  MOVWF  FE9
0024E:  MOVLW  01
00250:  ADDWFC x86,W
00252:  MOVWF  FEA
00254:  BCF    FEF.1
....................    }
00256:  MOVLB  0
00258:  GOTO   031A (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Interquartile Mean Ring Buffer                                            */
.................... /* Filters the ADC data to remove spurious readings                          */
.................... /*****************************************************************************/
.................... void iqm_ring_buffer(int8 ch, signed int32 sinCnts, signed int32 cosCnts){
*
01E78:  MOVLB  7
01E7A:  CLRF   x3D
01E7C:  CLRF   x3C
01E7E:  CLRF   x3B
01E80:  CLRF   x3A
01E82:  CLRF   x41
01E84:  CLRF   x40
01E86:  CLRF   x3F
01E88:  CLRF   x3E
01E8A:  CLRF   x45
01E8C:  CLRF   x44
01E8E:  CLRF   x43
01E90:  CLRF   x42
01E92:  CLRF   x49
01E94:  CLRF   x48
01E96:  CLRF   x47
01E98:  CLRF   x46
01E9A:  CLRF   x4D
01E9C:  CLRF   x4C
01E9E:  CLRF   x4B
01EA0:  CLRF   x4A
01EA2:  CLRF   x51
01EA4:  CLRF   x50
01EA6:  CLRF   x4F
01EA8:  CLRF   x4E
....................    signed int32* sQ_ch;
....................    signed int32* cQ_ch;
....................    int* sIn_ch;
....................    int* cIn_ch;
.................... 
....................    signed int32 sumSin=0;
....................    signed int32 sumCos=0;
....................    
....................    signed int32 sinMax=0;
....................    signed int32 sinMin=0;
....................    signed int32 cosMax=0;
....................    signed int32 cosMin=0;
....................    
....................    if (ch==0){
01EAA:  MOVF   x29,F
01EAC:  BNZ   1ED0
....................       sQ_ch = sQ_x;
01EAE:  MOVLW  01
01EB0:  MOVWF  x33
01EB2:  MOVLW  80
01EB4:  MOVWF  x32
....................       cQ_ch = cQ_x;
01EB6:  MOVLW  01
01EB8:  MOVWF  x35
01EBA:  MOVLW  94
01EBC:  MOVWF  x34
....................       sIn_ch = &sIn_x;
01EBE:  MOVLW  01
01EC0:  MOVWF  x37
01EC2:  MOVLW  D0
01EC4:  MOVWF  x36
....................       cIn_ch = &cIn_x;
01EC6:  MOVLW  01
01EC8:  MOVWF  x39
01ECA:  MOVLW  D1
01ECC:  MOVWF  x38
....................    }
01ECE:  BRA    1EF4
....................    else if (ch==1){
01ED0:  DECFSZ x29,W
01ED2:  BRA    1EF4
....................       sQ_ch = sQ_y;
01ED4:  MOVLW  01
01ED6:  MOVWF  x33
01ED8:  MOVLW  A8
01EDA:  MOVWF  x32
....................       cQ_ch = cQ_y;
01EDC:  MOVLW  01
01EDE:  MOVWF  x35
01EE0:  MOVLW  BC
01EE2:  MOVWF  x34
....................       sIn_ch = &sIn_y;
01EE4:  MOVLW  01
01EE6:  MOVWF  x37
01EE8:  MOVLW  D2
01EEA:  MOVWF  x36
....................       cIn_ch = &cIn_y;
01EEC:  MOVLW  01
01EEE:  MOVWF  x39
01EF0:  MOVLW  D3
01EF2:  MOVWF  x38
....................    }
.................... 
....................    push(sQ_ch, sIn_ch, sinCnts); // push new data into queues
01EF4:  MOVFF  733,754
01EF8:  MOVFF  732,753
01EFC:  MOVFF  737,756
01F00:  MOVFF  736,755
01F04:  MOVFF  72D,75A
01F08:  MOVFF  72C,759
01F0C:  MOVFF  72B,758
01F10:  MOVFF  72A,757
01F14:  MOVLB  0
01F16:  CALL   08BC
....................    push(cQ_ch, cIn_ch, cosCnts);
01F1A:  MOVFF  735,754
01F1E:  MOVFF  734,753
01F22:  MOVFF  739,756
01F26:  MOVFF  738,755
01F2A:  MOVFF  731,75A
01F2E:  MOVFF  730,759
01F32:  MOVFF  72F,758
01F36:  MOVFF  72E,757
01F3A:  CALL   08BC
....................    
....................    // MAX and MIN of the rolling buffer initial vals
....................    sinMax=sQ_ch[0];
01F3E:  MOVLB  7
01F40:  MOVFF  732,FE9
01F44:  MOVFF  733,FEA
01F48:  MOVFF  FEF,742
01F4C:  MOVFF  FEC,743
01F50:  MOVFF  FEC,744
01F54:  MOVFF  FEC,745
....................    sinMin=sQ_ch[0];
01F58:  MOVFF  732,FE9
01F5C:  MOVFF  733,FEA
01F60:  MOVFF  FEF,746
01F64:  MOVFF  FEC,747
01F68:  MOVFF  FEC,748
01F6C:  MOVFF  FEC,749
....................    cosMax=cQ_ch[0];
01F70:  MOVFF  734,FE9
01F74:  MOVFF  735,FEA
01F78:  MOVFF  FEF,74A
01F7C:  MOVFF  FEC,74B
01F80:  MOVFF  FEC,74C
01F84:  MOVFF  FEC,74D
....................    cosMin=cQ_ch[0];
01F88:  MOVFF  734,FE9
01F8C:  MOVFF  735,FEA
01F90:  MOVFF  FEF,74E
01F94:  MOVFF  FEC,74F
01F98:  MOVFF  FEC,750
01F9C:  MOVFF  FEC,751
....................    
....................    // step thru buffer, adding up all vals and finding MAX and MIN
....................    for (int i=1; i<BUFFER_SIZE; i++){
01FA0:  MOVLW  01
01FA2:  MOVWF  x52
01FA4:  MOVF   x52,W
01FA6:  SUBLW  04
01FA8:  BTFSS  FD8.0
01FAA:  BRA    22BA
....................       (sinMax < sQ_ch[i]) ? (sinMax=sQ_ch[i]) : (0);
01FAC:  CLRF   x5D
01FAE:  MOVFF  752,75C
01FB2:  CLRF   x5F
01FB4:  MOVLW  04
01FB6:  MOVWF  x5E
01FB8:  MOVLB  0
01FBA:  CALL   086E
01FBE:  MOVFF  02,03
01FC2:  MOVF   01,W
01FC4:  MOVLB  7
01FC6:  ADDWF  x32,W
01FC8:  MOVWF  FE9
01FCA:  MOVF   x33,W
01FCC:  ADDWFC 02,W
01FCE:  MOVWF  FEA
01FD0:  MOVFF  FEF,00
01FD4:  MOVFF  FEC,01
01FD8:  MOVFF  FEC,02
01FDC:  MOVFF  FEC,03
01FE0:  BTFSS  x45.7
01FE2:  BRA    1FEA
01FE4:  BTFSS  03.7
01FE6:  BRA    200C
01FE8:  BRA    1FEE
01FEA:  BTFSC  03.7
01FEC:  BRA    2042
01FEE:  MOVF   x45,W
01FF0:  SUBWF  03,W
01FF2:  BNC   2042
01FF4:  BNZ   200C
01FF6:  MOVF   x44,W
01FF8:  SUBWF  02,W
01FFA:  BNC   2042
01FFC:  BNZ   200C
01FFE:  MOVF   x43,W
02000:  SUBWF  01,W
02002:  BNC   2042
02004:  BNZ   200C
02006:  MOVF   00,W
02008:  SUBWF  x42,W
0200A:  BC    2042
0200C:  CLRF   x5D
0200E:  MOVFF  752,75C
02012:  CLRF   x5F
02014:  MOVLW  04
02016:  MOVWF  x5E
02018:  MOVLB  0
0201A:  CALL   086E
0201E:  MOVFF  02,03
02022:  MOVF   01,W
02024:  MOVLB  7
02026:  ADDWF  x32,W
02028:  MOVWF  FE9
0202A:  MOVF   x33,W
0202C:  ADDWFC 02,W
0202E:  MOVWF  FEA
02030:  MOVFF  FEF,742
02034:  MOVFF  FEC,743
02038:  MOVFF  FEC,744
0203C:  MOVFF  FEC,745
02040:  MOVF   x42,W
....................       (sinMin > sQ_ch[i]) ? (sinMin=sQ_ch[i]) : (0);
02042:  CLRF   x5D
02044:  MOVFF  752,75C
02048:  CLRF   x5F
0204A:  MOVLW  04
0204C:  MOVWF  x5E
0204E:  MOVLB  0
02050:  CALL   086E
02054:  MOVFF  02,03
02058:  MOVF   01,W
0205A:  MOVLB  7
0205C:  ADDWF  x32,W
0205E:  MOVWF  FE9
02060:  MOVF   x33,W
02062:  ADDWFC 02,W
02064:  MOVWF  FEA
02066:  MOVFF  FEF,00
0206A:  MOVFF  FEC,01
0206E:  MOVFF  FEC,02
02072:  MOVFF  FEC,03
02076:  BTFSS  03.7
02078:  BRA    2080
0207A:  BTFSS  x49.7
0207C:  BRA    20A2
0207E:  BRA    2084
02080:  BTFSC  x49.7
02082:  BRA    20E6
02084:  MOVF   03,W
02086:  SUBWF  x49,W
02088:  BNC   20E6
0208A:  BNZ   20A2
0208C:  MOVF   02,W
0208E:  SUBWF  x48,W
02090:  BNC   20E6
02092:  BNZ   20A2
02094:  MOVF   01,W
02096:  SUBWF  x47,W
02098:  BNC   20E6
0209A:  BNZ   20A2
0209C:  MOVF   x46,W
0209E:  SUBWF  00,W
020A0:  BC    20E6
020A2:  CLRF   x5D
020A4:  MOVFF  752,75C
020A8:  CLRF   x5F
020AA:  MOVLW  04
020AC:  MOVWF  x5E
020AE:  MOVLB  0
020B0:  CALL   086E
020B4:  MOVFF  02,03
020B8:  MOVF   01,W
020BA:  MOVLB  7
020BC:  ADDWF  x32,W
020BE:  MOVWF  FE9
020C0:  MOVF   x33,W
020C2:  ADDWFC 02,W
020C4:  MOVWF  FEA
020C6:  MOVFF  FEF,746
020CA:  MOVFF  FEC,747
020CE:  MOVFF  FEC,748
020D2:  MOVFF  FEC,749
020D6:  MOVFF  746,00
020DA:  MOVFF  747,01
020DE:  MOVFF  748,02
020E2:  MOVFF  749,03
....................       (cosMax < cQ_ch[i]) ? (cosMax=cQ_ch[i]) : (0);
020E6:  CLRF   x5D
020E8:  MOVFF  752,75C
020EC:  CLRF   x5F
020EE:  MOVLW  04
020F0:  MOVWF  x5E
020F2:  MOVLB  0
020F4:  CALL   086E
020F8:  MOVFF  02,03
020FC:  MOVF   01,W
020FE:  MOVLB  7
02100:  ADDWF  x34,W
02102:  MOVWF  FE9
02104:  MOVF   x35,W
02106:  ADDWFC 02,W
02108:  MOVWF  FEA
0210A:  MOVFF  FEF,00
0210E:  MOVFF  FEC,01
02112:  MOVFF  FEC,02
02116:  MOVFF  FEC,03
0211A:  BTFSS  x4D.7
0211C:  BRA    2124
0211E:  BTFSS  03.7
02120:  BRA    2146
02122:  BRA    2128
02124:  BTFSC  03.7
02126:  BRA    218A
02128:  MOVF   x4D,W
0212A:  SUBWF  03,W
0212C:  BNC   218A
0212E:  BNZ   2146
02130:  MOVF   x4C,W
02132:  SUBWF  02,W
02134:  BNC   218A
02136:  BNZ   2146
02138:  MOVF   x4B,W
0213A:  SUBWF  01,W
0213C:  BNC   218A
0213E:  BNZ   2146
02140:  MOVF   00,W
02142:  SUBWF  x4A,W
02144:  BC    218A
02146:  CLRF   x5D
02148:  MOVFF  752,75C
0214C:  CLRF   x5F
0214E:  MOVLW  04
02150:  MOVWF  x5E
02152:  MOVLB  0
02154:  CALL   086E
02158:  MOVFF  02,03
0215C:  MOVF   01,W
0215E:  MOVLB  7
02160:  ADDWF  x34,W
02162:  MOVWF  FE9
02164:  MOVF   x35,W
02166:  ADDWFC 02,W
02168:  MOVWF  FEA
0216A:  MOVFF  FEF,74A
0216E:  MOVFF  FEC,74B
02172:  MOVFF  FEC,74C
02176:  MOVFF  FEC,74D
0217A:  MOVFF  74A,00
0217E:  MOVFF  74B,01
02182:  MOVFF  74C,02
02186:  MOVFF  74D,03
....................       (cosMin > cQ_ch[i]) ? (cosMin=cQ_ch[i]) : (0);
0218A:  CLRF   x5D
0218C:  MOVFF  752,75C
02190:  CLRF   x5F
02192:  MOVLW  04
02194:  MOVWF  x5E
02196:  MOVLB  0
02198:  CALL   086E
0219C:  MOVFF  02,03
021A0:  MOVF   01,W
021A2:  MOVLB  7
021A4:  ADDWF  x34,W
021A6:  MOVWF  FE9
021A8:  MOVF   x35,W
021AA:  ADDWFC 02,W
021AC:  MOVWF  FEA
021AE:  MOVFF  FEF,00
021B2:  MOVFF  FEC,01
021B6:  MOVFF  FEC,02
021BA:  MOVFF  FEC,03
021BE:  BTFSS  03.7
021C0:  BRA    21C8
021C2:  BTFSS  x51.7
021C4:  BRA    21EA
021C6:  BRA    21CC
021C8:  BTFSC  x51.7
021CA:  BRA    222E
021CC:  MOVF   03,W
021CE:  SUBWF  x51,W
021D0:  BNC   222E
021D2:  BNZ   21EA
021D4:  MOVF   02,W
021D6:  SUBWF  x50,W
021D8:  BNC   222E
021DA:  BNZ   21EA
021DC:  MOVF   01,W
021DE:  SUBWF  x4F,W
021E0:  BNC   222E
021E2:  BNZ   21EA
021E4:  MOVF   x4E,W
021E6:  SUBWF  00,W
021E8:  BC    222E
021EA:  CLRF   x5D
021EC:  MOVFF  752,75C
021F0:  CLRF   x5F
021F2:  MOVLW  04
021F4:  MOVWF  x5E
021F6:  MOVLB  0
021F8:  CALL   086E
021FC:  MOVFF  02,03
02200:  MOVF   01,W
02202:  MOVLB  7
02204:  ADDWF  x34,W
02206:  MOVWF  FE9
02208:  MOVF   x35,W
0220A:  ADDWFC 02,W
0220C:  MOVWF  FEA
0220E:  MOVFF  FEF,74E
02212:  MOVFF  FEC,74F
02216:  MOVFF  FEC,750
0221A:  MOVFF  FEC,751
0221E:  MOVFF  74E,00
02222:  MOVFF  74F,01
02226:  MOVFF  750,02
0222A:  MOVFF  751,03
....................       sumSin+=sQ_ch[i];
0222E:  CLRF   x5D
02230:  MOVFF  752,75C
02234:  CLRF   x5F
02236:  MOVLW  04
02238:  MOVWF  x5E
0223A:  MOVLB  0
0223C:  CALL   086E
02240:  MOVFF  02,03
02244:  MOVF   01,W
02246:  MOVLB  7
02248:  ADDWF  x32,W
0224A:  MOVWF  FE9
0224C:  MOVF   x33,W
0224E:  ADDWFC 02,W
02250:  MOVWF  FEA
02252:  MOVFF  FEF,00
02256:  MOVFF  FEC,01
0225A:  MOVFF  FEC,02
0225E:  MOVFF  FEC,03
02262:  MOVF   00,W
02264:  ADDWF  x3A,F
02266:  MOVF   01,W
02268:  ADDWFC x3B,F
0226A:  MOVF   02,W
0226C:  ADDWFC x3C,F
0226E:  MOVF   03,W
02270:  ADDWFC x3D,F
....................       sumCos+=cQ_ch[i];
02272:  CLRF   x5D
02274:  MOVFF  752,75C
02278:  CLRF   x5F
0227A:  MOVLW  04
0227C:  MOVWF  x5E
0227E:  MOVLB  0
02280:  CALL   086E
02284:  MOVFF  02,03
02288:  MOVF   01,W
0228A:  MOVLB  7
0228C:  ADDWF  x34,W
0228E:  MOVWF  FE9
02290:  MOVF   x35,W
02292:  ADDWFC 02,W
02294:  MOVWF  FEA
02296:  MOVFF  FEF,00
0229A:  MOVFF  FEC,01
0229E:  MOVFF  FEC,02
022A2:  MOVFF  FEC,03
022A6:  MOVF   00,W
022A8:  ADDWF  x3E,F
022AA:  MOVF   01,W
022AC:  ADDWFC x3F,F
022AE:  MOVF   02,W
022B0:  ADDWFC x40,F
022B2:  MOVF   03,W
022B4:  ADDWFC x41,F
022B6:  INCF   x52,F
022B8:  BRA    1FA4
....................    }
....................    
....................    // subtract MAX and MIN from sum
....................    sumSin-=(sinMax+sinMin);
022BA:  MOVF   x46,W
022BC:  ADDWF  x42,W
022BE:  MOVWF  00
022C0:  MOVF   x47,W
022C2:  ADDWFC x43,W
022C4:  MOVWF  01
022C6:  MOVF   x48,W
022C8:  ADDWFC x44,W
022CA:  MOVWF  02
022CC:  MOVF   x49,W
022CE:  ADDWFC x45,W
022D0:  MOVWF  03
022D2:  MOVF   00,W
022D4:  SUBWF  x3A,F
022D6:  MOVF   01,W
022D8:  SUBWFB x3B,F
022DA:  MOVF   02,W
022DC:  SUBWFB x3C,F
022DE:  MOVF   03,W
022E0:  SUBWFB x3D,F
....................    sumCos-=(cosMax+cosMin);
022E2:  MOVF   x4E,W
022E4:  ADDWF  x4A,W
022E6:  MOVWF  00
022E8:  MOVF   x4F,W
022EA:  ADDWFC x4B,W
022EC:  MOVWF  01
022EE:  MOVF   x50,W
022F0:  ADDWFC x4C,W
022F2:  MOVWF  02
022F4:  MOVF   x51,W
022F6:  ADDWFC x4D,W
022F8:  MOVWF  03
022FA:  MOVF   00,W
022FC:  SUBWF  x3E,F
022FE:  MOVF   01,W
02300:  SUBWFB x3F,F
02302:  MOVF   02,W
02304:  SUBWFB x40,F
02306:  MOVF   03,W
02308:  SUBWFB x41,F
....................    
....................    // calc AVG
....................    smData[ch].avgSin = sumSin / (BUFFER_SIZE-2);
0230A:  MOVF   x29,W
0230C:  MULLW  09
0230E:  MOVF   FF3,W
02310:  CLRF   x54
02312:  MOVWF  x53
02314:  MOVLW  01
02316:  ADDWF  x53,W
02318:  MOVWF  01
0231A:  MOVLW  00
0231C:  ADDWFC x54,W
0231E:  MOVWF  03
02320:  MOVF   01,W
02322:  ADDLW  D4
02324:  MOVWF  FE9
02326:  MOVLW  01
02328:  ADDWFC 03,W
0232A:  MOVWF  FEA
0232C:  MOVFF  FEA,756
02330:  MOVFF  FE9,755
02334:  BCF    FD8.1
02336:  MOVFF  73D,75A
0233A:  MOVFF  73C,759
0233E:  MOVFF  73B,758
02342:  MOVFF  73A,757
02346:  CLRF   x5E
02348:  CLRF   x5D
0234A:  CLRF   x5C
0234C:  MOVLW  03
0234E:  MOVWF  x5B
02350:  MOVLB  0
02352:  RCALL  1D8E
02354:  MOVFF  756,FEA
02358:  MOVFF  755,FE9
0235C:  MOVFF  00,FEF
02360:  MOVFF  01,FEC
02364:  MOVFF  02,FEC
02368:  MOVFF  03,FEC
....................    smData[ch].avgCos = sumCos / (BUFFER_SIZE-2);
0236C:  MOVLB  7
0236E:  MOVF   x29,W
02370:  MULLW  09
02372:  MOVF   FF3,W
02374:  CLRF   x54
02376:  MOVWF  x53
02378:  MOVLW  05
0237A:  ADDWF  x53,W
0237C:  MOVWF  01
0237E:  MOVLW  00
02380:  ADDWFC x54,W
02382:  MOVWF  03
02384:  MOVF   01,W
02386:  ADDLW  D4
02388:  MOVWF  FE9
0238A:  MOVLW  01
0238C:  ADDWFC 03,W
0238E:  MOVWF  FEA
02390:  MOVFF  FEA,756
02394:  MOVFF  FE9,755
02398:  BCF    FD8.1
0239A:  MOVFF  741,75A
0239E:  MOVFF  740,759
023A2:  MOVFF  73F,758
023A6:  MOVFF  73E,757
023AA:  CLRF   x5E
023AC:  CLRF   x5D
023AE:  CLRF   x5C
023B0:  MOVLW  03
023B2:  MOVWF  x5B
023B4:  MOVLB  0
023B6:  RCALL  1D8E
023B8:  MOVFF  756,FEA
023BC:  MOVFF  755,FE9
023C0:  MOVFF  00,FEF
023C4:  MOVFF  01,FEC
023C8:  MOVFF  02,FEC
023CC:  MOVFF  03,FEC
023D0:  GOTO   4C26 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SENSOR MONITOR task - gets magnetoresistive sensor counts                 */
.................... /* gets two values each time the task is run                                 */
.................... /*****************************************************************************/
.................... void sensor_monitor_task(){
*
04B46:  MOVLB  7
04B48:  CLRF   x24
04B4A:  CLRF   x23
04B4C:  CLRF   x22
04B4E:  CLRF   x21
04B50:  CLRF   x28
04B52:  CLRF   x27
04B54:  CLRF   x26
04B56:  CLRF   x25
....................    static int8 ch = 0;
....................    signed int32 sinNew = 0;
....................    signed int32 cosNew = 0;
....................    
....................    if ( (!smData[ch].adcBusy) && smData[ch].dataReady ){
04B58:  MOVLB  1
04B5A:  MOVF   xE8,W
04B5C:  MULLW  09
04B5E:  MOVF   FF3,W
04B60:  MOVLB  7
04B62:  CLRF   x2A
04B64:  MOVWF  x29
04B66:  MOVLW  D4
04B68:  ADDWF  x29,W
04B6A:  MOVWF  FE9
04B6C:  MOVLW  01
04B6E:  ADDWFC x2A,W
04B70:  MOVWF  FEA
04B72:  BTFSC  FEF.1
04B74:  BRA    4CF2
04B76:  MOVLB  1
04B78:  MOVF   xE8,W
04B7A:  MULLW  09
04B7C:  MOVF   FF3,W
04B7E:  MOVLB  7
04B80:  CLRF   x2C
04B82:  MOVWF  x2B
04B84:  MOVLW  D4
04B86:  ADDWF  x2B,W
04B88:  MOVWF  FE9
04B8A:  MOVLW  01
04B8C:  ADDWFC x2C,W
04B8E:  MOVWF  FEA
04B90:  BTFSS  FEF.0
04B92:  BRA    4CF2
....................       smData[ch].adcBusy = true;
04B94:  MOVLB  1
04B96:  MOVF   xE8,W
04B98:  MULLW  09
04B9A:  MOVF   FF3,W
04B9C:  MOVLB  7
04B9E:  CLRF   x2A
04BA0:  MOVWF  x29
04BA2:  MOVLW  D4
04BA4:  ADDWF  x29,W
04BA6:  MOVWF  FE9
04BA8:  MOVLW  01
04BAA:  ADDWFC x2A,W
04BAC:  MOVWF  FEA
04BAE:  BSF    FEF.1
....................       
....................       sinNew = ads_read_data(ch*2);
04BB0:  BCF    FD8.0
04BB2:  MOVLB  1
04BB4:  RLCF   xE8,W
04BB6:  MOVLB  7
04BB8:  MOVWF  x29
04BBA:  MOVWF  x2A
04BBC:  MOVLB  0
04BBE:  CALL   0814
04BC2:  MOVFF  03,724
04BC6:  MOVFF  02,723
04BCA:  MOVFF  01,722
04BCE:  MOVFF  00,721
....................       cosNew = ads_read_data(ch*2+1);      
04BD2:  BCF    FD8.0
04BD4:  MOVLB  1
04BD6:  RLCF   xE8,W
04BD8:  ADDLW  01
04BDA:  MOVLB  7
04BDC:  MOVWF  x29
04BDE:  MOVWF  x2A
04BE0:  MOVLB  0
04BE2:  CALL   0814
04BE6:  MOVFF  03,728
04BEA:  MOVFF  02,727
04BEE:  MOVFF  01,726
04BF2:  MOVFF  00,725
....................       
....................       if (adcFilter){
04BF6:  MOVLB  1
04BF8:  BTFSS  x63.0
04BFA:  BRA    4C2A
....................          iqm_ring_buffer(ch, sinNew, cosNew);
04BFC:  MOVFF  1E8,729
04C00:  MOVFF  724,72D
04C04:  MOVFF  723,72C
04C08:  MOVFF  722,72B
04C0C:  MOVFF  721,72A
04C10:  MOVFF  728,731
04C14:  MOVFF  727,730
04C18:  MOVFF  726,72F
04C1C:  MOVFF  725,72E
04C20:  MOVLB  0
04C22:  GOTO   1E78
....................       }
04C26:  BRA    4C96
04C28:  MOVLB  1
....................       else{
....................          smData[ch].avgSin = sinNew;
04C2A:  MOVF   xE8,W
04C2C:  MULLW  09
04C2E:  MOVF   FF3,W
04C30:  MOVLB  7
04C32:  CLRF   x2A
04C34:  MOVWF  x29
04C36:  MOVLW  01
04C38:  ADDWF  x29,W
04C3A:  MOVWF  01
04C3C:  MOVLW  00
04C3E:  ADDWFC x2A,W
04C40:  MOVWF  03
04C42:  MOVF   01,W
04C44:  ADDLW  D4
04C46:  MOVWF  FE9
04C48:  MOVLW  01
04C4A:  ADDWFC 03,W
04C4C:  MOVWF  FEA
04C4E:  MOVFF  721,FEF
04C52:  MOVFF  722,FEC
04C56:  MOVFF  723,FEC
04C5A:  MOVFF  724,FEC
....................          smData[ch].avgCos = cosNew;
04C5E:  MOVLB  1
04C60:  MOVF   xE8,W
04C62:  MULLW  09
04C64:  MOVF   FF3,W
04C66:  MOVLB  7
04C68:  CLRF   x2A
04C6A:  MOVWF  x29
04C6C:  MOVLW  05
04C6E:  ADDWF  x29,W
04C70:  MOVWF  01
04C72:  MOVLW  00
04C74:  ADDWFC x2A,W
04C76:  MOVWF  03
04C78:  MOVF   01,W
04C7A:  ADDLW  D4
04C7C:  MOVWF  FE9
04C7E:  MOVLW  01
04C80:  ADDWFC 03,W
04C82:  MOVWF  FEA
04C84:  MOVFF  725,FEF
04C88:  MOVFF  726,FEC
04C8C:  MOVFF  727,FEC
04C90:  MOVFF  728,FEC
04C94:  MOVLB  0
....................       }
....................       
....................       sensor_process_data(ch);
04C96:  MOVFF  1E8,729
04C9A:  GOTO   3D9C
....................       ch = !ch;
04C9E:  MOVLB  1
04CA0:  MOVF   xE8,F
04CA2:  BZ    4CA8
04CA4:  MOVLW  00
04CA6:  BRA    4CAA
04CA8:  MOVLW  01
04CAA:  MOVWF  xE8
....................       
....................       smData[!ch].dataReady = false;
04CAC:  MOVF   xE8,F
04CAE:  BZ    4CB4
04CB0:  MOVLW  00
04CB2:  BRA    4CB6
04CB4:  MOVLW  01
04CB6:  MULLW  09
04CB8:  MOVF   FF3,W
04CBA:  MOVLB  7
04CBC:  CLRF   x2A
04CBE:  MOVWF  x29
04CC0:  MOVLW  D4
04CC2:  ADDWF  x29,W
04CC4:  MOVWF  FE9
04CC6:  MOVLW  01
04CC8:  ADDWFC x2A,W
04CCA:  MOVWF  FEA
04CCC:  BCF    FEF.0
....................       smData[!ch].adcBusy = false;
04CCE:  MOVLB  1
04CD0:  MOVF   xE8,F
04CD2:  BZ    4CD8
04CD4:  MOVLW  00
04CD6:  BRA    4CDA
04CD8:  MOVLW  01
04CDA:  MULLW  09
04CDC:  MOVF   FF3,W
04CDE:  MOVLB  7
04CE0:  CLRF   x2A
04CE2:  MOVWF  x29
04CE4:  MOVLW  D4
04CE6:  ADDWF  x29,W
04CE8:  MOVWF  FE9
04CEA:  MOVLW  01
04CEC:  ADDWFC x2A,W
04CEE:  MOVWF  FEA
04CF0:  BCF    FEF.1
....................    }
04CF2:  MOVLB  0
04CF4:  RETURN 0
.................... }
.................... /*****************************************************************************/
.................... /* INITIALIZE ADC's                                                          */
.................... /*****************************************************************************/
.................... void setup_external_ADCs(){
*
00922:  MOVLB  7
00924:  CLRF   x16
00926:  CLRF   x17
00928:  CLRF   x18
0092A:  CLRF   x19
....................    unsigned int8 rc0=0;
....................    unsigned int8 rc1=0;
....................    unsigned int8 rc2=0;
....................    unsigned int8 rc3=0;
....................    
....................    for (int ch = 0; ch < 4; ch++){
0092C:  CLRF   x1A
0092E:  MOVF   x1A,W
00930:  SUBLW  03
00932:  BNC   0968
....................       rc0=reg0config;
00934:  MOVLW  30
00936:  MOVWF  x16
....................       rc1=reg1config;
00938:  MOVLW  10
0093A:  MOVWF  x17
....................       rc2=reg2config;
0093C:  CLRF   x18
....................       rc3=reg3config;
0093E:  CLRF   x19
....................       
....................       ADS1220init(ch, rc0, rc1, rc2, rc3);
00940:  MOVFF  71A,71C
00944:  MOVFF  716,71D
00948:  MOVFF  717,71E
0094C:  MOVFF  718,71F
00950:  MOVFF  719,720
00954:  MOVLB  0
00956:  BRA    0746
....................       delay_ms(100);
00958:  MOVLW  64
0095A:  MOVLB  7
0095C:  MOVWF  x25
0095E:  MOVLB  0
00960:  RCALL  0436
00962:  MOVLB  7
00964:  INCF   x1A,F
00966:  BRA    092E
....................    }
....................    
....................    if (adcFilter){
00968:  MOVLB  1
0096A:  BTFSS  x63.0
0096C:  BRA    0A8E
....................       for (int i = 0; i < BUFFER_SIZE; i++){
0096E:  MOVLB  7
00970:  CLRF   x1B
00972:  MOVF   x1B,W
00974:  SUBLW  04
00976:  BTFSS  FD8.0
00978:  BRA    0A8C
....................          ads_start_conv_all();
0097A:  MOVLB  0
0097C:  BRA    07E4
....................          delay_ms(50);
0097E:  MOVLW  32
00980:  MOVLB  7
00982:  MOVWF  x25
00984:  MOVLB  0
00986:  RCALL  0436
....................          push(sQ_x, &sIn_x, ads_read_data(0));
00988:  MOVLB  7
0098A:  CLRF   x2A
0098C:  MOVLB  0
0098E:  RCALL  0814
00990:  MOVFF  03,71F
00994:  MOVFF  02,71E
00998:  MOVFF  01,71D
0099C:  MOVFF  00,71C
009A0:  MOVLW  01
009A2:  MOVLB  7
009A4:  MOVWF  x54
009A6:  MOVLW  80
009A8:  MOVWF  x53
009AA:  MOVLW  01
009AC:  MOVWF  x56
009AE:  MOVLW  D0
009B0:  MOVWF  x55
009B2:  MOVFF  03,75A
009B6:  MOVFF  02,759
009BA:  MOVFF  01,758
009BE:  MOVFF  00,757
009C2:  MOVLB  0
009C4:  RCALL  08BC
....................          push(cQ_x, &cIn_x, ads_read_data(1));      
009C6:  MOVLW  01
009C8:  MOVLB  7
009CA:  MOVWF  x2A
009CC:  MOVLB  0
009CE:  RCALL  0814
009D0:  MOVFF  03,71F
009D4:  MOVFF  02,71E
009D8:  MOVFF  01,71D
009DC:  MOVFF  00,71C
009E0:  MOVLW  01
009E2:  MOVLB  7
009E4:  MOVWF  x54
009E6:  MOVLW  94
009E8:  MOVWF  x53
009EA:  MOVLW  01
009EC:  MOVWF  x56
009EE:  MOVLW  D1
009F0:  MOVWF  x55
009F2:  MOVFF  03,75A
009F6:  MOVFF  02,759
009FA:  MOVFF  01,758
009FE:  MOVFF  00,757
00A02:  MOVLB  0
00A04:  RCALL  08BC
....................          push(sQ_y, &sIn_y, ads_read_data(2));
00A06:  MOVLW  02
00A08:  MOVLB  7
00A0A:  MOVWF  x2A
00A0C:  MOVLB  0
00A0E:  RCALL  0814
00A10:  MOVFF  03,71F
00A14:  MOVFF  02,71E
00A18:  MOVFF  01,71D
00A1C:  MOVFF  00,71C
00A20:  MOVLW  01
00A22:  MOVLB  7
00A24:  MOVWF  x54
00A26:  MOVLW  A8
00A28:  MOVWF  x53
00A2A:  MOVLW  01
00A2C:  MOVWF  x56
00A2E:  MOVLW  D2
00A30:  MOVWF  x55
00A32:  MOVFF  03,75A
00A36:  MOVFF  02,759
00A3A:  MOVFF  01,758
00A3E:  MOVFF  00,757
00A42:  MOVLB  0
00A44:  RCALL  08BC
....................          push(cQ_y, &cIn_y, ads_read_data(3));      
00A46:  MOVLW  03
00A48:  MOVLB  7
00A4A:  MOVWF  x2A
00A4C:  MOVLB  0
00A4E:  RCALL  0814
00A50:  MOVFF  03,71F
00A54:  MOVFF  02,71E
00A58:  MOVFF  01,71D
00A5C:  MOVFF  00,71C
00A60:  MOVLW  01
00A62:  MOVLB  7
00A64:  MOVWF  x54
00A66:  MOVLW  BC
00A68:  MOVWF  x53
00A6A:  MOVLW  01
00A6C:  MOVWF  x56
00A6E:  MOVLW  D3
00A70:  MOVWF  x55
00A72:  MOVFF  03,75A
00A76:  MOVFF  02,759
00A7A:  MOVFF  01,758
00A7E:  MOVFF  00,757
00A82:  MOVLB  0
00A84:  RCALL  08BC
00A86:  MOVLB  7
00A88:  INCF   x1B,F
00A8A:  BRA    0972
00A8C:  MOVLB  1
....................       }
....................    }
00A8E:  MOVLB  0
00A90:  GOTO   0AF4 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE MONITOR -- sets up ADC channels                                */
.................... /*****************************************************************************/
.................... void monitor_init(){
....................    setup_adc_ports(sAN6 | sAN16 | sAN17 | sAN24 | sAN25 | sAN26 | sAN27, NO_ANALOGS_P2, VSS_VDD);
00A94:  MOVLW  00
00A96:  MOVLB  F
00A98:  MOVWF  x53
00A9A:  MOVLW  40
00A9C:  MOVWF  x0C
00A9E:  MOVLW  00
00AA0:  MOVWF  x14
00AA2:  MOVLW  03
00AA4:  MOVWF  x1C
00AA6:  MOVLW  0F
00AA8:  MOVWF  x21
00AAA:  MOVLW  00
00AAC:  MOVWF  x29
....................    setup_adc(ADC_CLOCK_INTERNAL | ADC_TAD_MUL_255 | ADC_LEGACY_MODE | ADC_THRESHOLD_INT_DISABLED);
00AAE:  MOVLW  08
00AB0:  MOVWF  x55
00AB2:  CLRF   x56
00AB4:  CLRF   x52
00AB6:  SETF   x57
00AB8:  CLRF   F61
00ABA:  MOVLW  94
00ABC:  MOVWF  x5B
....................    output_high(EN_EXC);
00ABE:  MOVLW  E8
00AC0:  MOVWF  F8B
00AC2:  BSF    F86.0
....................    set_adc_channel(vMonN15); // internal MUX
00AC4:  MOVF   x5A,W
00AC6:  ANDLW  3F
00AC8:  MOVWF  01
00ACA:  MOVLW  06
00ACC:  MOVWF  x5A
00ACE:  BTFSS  x5B.7
00AD0:  BRA    0AE0
00AD2:  MOVF   01,W
00AD4:  SUBLW  06
00AD6:  BZ    0AE0
00AD8:  BSF    x5B.0
00ADA:  NOP   
00ADC:  BTFSC  x5B.0
00ADE:  BRA    0ADC
....................    delay_ms(10);
00AE0:  MOVLW  0A
00AE2:  MOVLB  7
00AE4:  MOVWF  x25
00AE6:  MOVLB  0
00AE8:  RCALL  0436
....................    read_adc(ADC_START_ONLY);
00AEA:  MOVLB  F
00AEC:  BSF    x5B.0
00AEE:  NOP   
....................    setup_external_ADCs();
00AF0:  MOVLB  0
00AF2:  BRA    0922
....................    intTimeoutReg = sensorSampleRate;
00AF4:  MOVLB  1
00AF6:  CLRF   x7F
00AF8:  MOVLW  32
00AFA:  MOVWF  x7E
00AFC:  MOVLB  0
00AFE:  GOTO   B196 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <control.h>
.................... #ifndef control
.................... #define control
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................     float kP;      // proportional gain
....................     float kI;      // integral gain
....................     float kD;      // derivative gain
....................     float SP;      // set point-- desired output
....................     float PV;      // process variable-- measured output
....................     float PVold;   // oldPV value  
....................     float CV;      // control variable-- output -- 0 to 100%
....................     float I;       // integral value
....................     float maxSP;   // Max setpoint in microns
....................     float minSP;   // Min setpoint in microns
.................... }PID[2] = {
....................    //  P     I     D
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}, 
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}
....................     };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... // @FLAG
.................... #define op_upper_bound 63  // CRYO
.................... #define op_lower_bound -63 // CRYO
.................... 
.................... //!#define op_upper_bound 63  // AMBIENT 
.................... //!#define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {-0.2701,-0.97313,0,0,0,0},  // @FLAG: Switched Channels
....................                     {-0.3964,-0.96557,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    BOOLEAN homeFlag;       // Flag to trigger the homing routine
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,-1,0,0,FALSE},  // @FLAG: Y-Axis passes -pole during cooldown
....................    {0,0,0,0,0,0,0, 0,0,0,FALSE}
.................... };
.................... 
.................... BOOLEAN adcFilter = TRUE;
.................... 
.................... struct dacV
.................... {
....................     BOOLEAN invV;
....................     unsigned int16 ipVal;
....................     float opPcnt;
....................    
.................... }dacVals[2] = 
.................... {
....................     {FALSE,0,0},
....................     {FALSE,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <pid.h>
.................... #ifndef pidcontroller
.................... #define pidcontroller
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................     float kP;      // proportional gain
....................     float kI;      // integral gain
....................     float kD;      // derivative gain
....................     float SP;      // set point-- desired output
....................     float PV;      // process variable-- measured output
....................     float PVold;   // oldPV value  
....................     float CV;      // control variable-- output -- 0 to 100%
....................     float I;       // integral value
....................     float maxSP;   // Max setpoint in microns
....................     float minSP;   // Min setpoint in microns
.................... }PID[2] = {
....................    //  P     I     D
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}, 
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}
....................     };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... // @FLAG
.................... #define op_upper_bound 63  // CRYO
.................... #define op_lower_bound -63 // CRYO
.................... 
.................... //!#define op_upper_bound 63  // AMBIENT 
.................... //!#define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {-0.2701,-0.97313,0,0,0,0},  // @FLAG: Switched Channels
....................                     {-0.3964,-0.96557,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    BOOLEAN homeFlag;       // Flag to trigger the homing routine
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,-1,0,0,FALSE},  // @FLAG: Y-Axis passes -pole during cooldown
....................    {0,0,0,0,0,0,0, 0,0,0,FALSE}
.................... };
.................... 
.................... BOOLEAN adcFilter = TRUE;
.................... 
.................... struct dacV
.................... {
....................     BOOLEAN invV;
....................     unsigned int16 ipVal;
....................     float opPcnt;
....................    
.................... }dacVals[2] = 
.................... {
....................     {FALSE,0,0},
....................     {FALSE,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float32)(unsigned int16)y;
.................... 
....................  else if (y < 10000000.0)
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
....................       res = 32768.0*(float32)l;
....................       res += (float32)(unsigned int16)y;
....................    }
.................... 
....................  else
....................   res = y;
.................... 
....................  y = y - (float32)(unsigned int16)y;
.................... 
....................  if (s)
....................   res = -res;
.................... 
....................  if (y != 0)
....................  {
....................   if (s == 1 && n == 0)
....................    res -= 1.0;
.................... 
....................   if (s == 0 && n == 1)
....................    res += 1.0;
....................  }
....................  if (x == 0)
....................     res = 0;
.................... 
....................  return (res);
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl[0]*y2 + pl[1];
.................... 
....................       r = ql[0]*y2 + ql[1];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
....................          r = -(float32)-n;
....................       else
....................          r = (float32)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* UPDATE the Control Variable (CV)                                          */
.................... /*****************************************************************************/
.................... void pid_update (channelMap ch){
*
01248:  MOVLB  7
0124A:  MOVF   x26,W
0124C:  MULLW  28
0124E:  MOVF   FF3,W
01250:  CLRF   x34
01252:  MOVWF  x33
01254:  MOVLW  0C
01256:  ADDWF  x33,W
01258:  MOVWF  01
0125A:  MOVLW  00
0125C:  ADDWFC x34,W
0125E:  MOVWF  03
01260:  MOVF   01,W
01262:  ADDLW  20
01264:  MOVWF  FE9
01266:  MOVLW  00
01268:  ADDWFC 03,W
0126A:  MOVWF  FEA
0126C:  MOVFF  FEF,770
01270:  MOVFF  FEC,771
01274:  MOVFF  FEC,772
01278:  MOVFF  FEC,773
0127C:  MOVF   x26,W
0127E:  MULLW  28
01280:  MOVF   FF3,W
01282:  CLRF   x38
01284:  MOVWF  x37
01286:  MOVLW  10
01288:  ADDWF  x37,W
0128A:  MOVWF  01
0128C:  MOVLW  00
0128E:  ADDWFC x38,W
01290:  MOVWF  03
01292:  MOVF   01,W
01294:  ADDLW  20
01296:  MOVWF  FE9
01298:  MOVLW  00
0129A:  ADDWFC 03,W
0129C:  MOVWF  FEA
0129E:  MOVFF  FEF,774
012A2:  MOVFF  FEC,01
012A6:  MOVFF  FEC,02
012AA:  MOVFF  FEC,03
012AE:  MOVFF  FEA,738
012B2:  MOVFF  FE9,737
012B6:  BSF    FD8.1
012B8:  MOVFF  03,777
012BC:  MOVFF  02,776
012C0:  MOVFF  01,775
012C4:  MOVLB  0
012C6:  RCALL  0DDC
012C8:  MOVFF  738,FEA
012CC:  MOVFF  737,FE9
012D0:  MOVFF  03,72A
012D4:  MOVFF  02,729
012D8:  MOVFF  01,728
012DC:  MOVFF  00,727
....................    float err = PID[ch].SP - PID[ch].PV;  // error = set value - measured
....................    
....................    PID[ch].I += err*PID[ch].kI;
012E0:  MOVLB  7
012E2:  MOVF   x26,W
012E4:  MULLW  28
012E6:  MOVF   FF3,W
012E8:  CLRF   x34
012EA:  MOVWF  x33
012EC:  MOVLW  1C
012EE:  ADDWF  x33,W
012F0:  MOVWF  01
012F2:  MOVLW  00
012F4:  ADDWFC x34,W
012F6:  MOVWF  03
012F8:  MOVF   01,W
012FA:  ADDLW  20
012FC:  MOVWF  01
012FE:  MOVLW  00
01300:  ADDWFC 03,F
01302:  MOVFF  01,733
01306:  MOVFF  03,734
0130A:  MOVFF  03,FEA
0130E:  MOVFF  01,FE9
01312:  MOVFF  FEF,735
01316:  MOVFF  FEC,736
0131A:  MOVFF  FEC,737
0131E:  MOVFF  FEC,738
01322:  MOVF   x26,W
01324:  MULLW  28
01326:  MOVF   FF3,W
01328:  CLRF   x3A
0132A:  MOVWF  x39
0132C:  MOVLW  04
0132E:  ADDWF  x39,W
01330:  MOVWF  01
01332:  MOVLW  00
01334:  ADDWFC x3A,W
01336:  MOVWF  03
01338:  MOVF   01,W
0133A:  ADDLW  20
0133C:  MOVWF  FE9
0133E:  MOVLW  00
01340:  ADDWFC 03,W
01342:  MOVWF  FEA
01344:  MOVFF  FEF,770
01348:  MOVFF  FEC,01
0134C:  MOVFF  FEC,02
01350:  MOVFF  FEC,03
01354:  MOVFF  72A,76F
01358:  MOVFF  729,76E
0135C:  MOVFF  728,76D
01360:  MOVFF  727,76C
01364:  MOVFF  03,773
01368:  MOVFF  02,772
0136C:  MOVFF  01,771
01370:  MOVLB  0
01372:  RCALL  1116
01374:  BCF    FD8.1
01376:  MOVFF  738,773
0137A:  MOVFF  737,772
0137E:  MOVFF  736,771
01382:  MOVFF  735,770
01386:  MOVFF  03,777
0138A:  MOVFF  02,776
0138E:  MOVFF  01,775
01392:  MOVFF  00,774
01396:  RCALL  0DDC
01398:  MOVFF  734,FEA
0139C:  MOVFF  733,FE9
013A0:  MOVFF  00,FEF
013A4:  MOVFF  01,FEC
013A8:  MOVFF  02,FEC
013AC:  MOVFF  03,FEC
....................    if (PID[ch].I > op_upper_bound) PID[ch].I = op_upper_bound; // anti-windup
013B0:  MOVLB  7
013B2:  MOVF   x26,W
013B4:  MULLW  28
013B6:  MOVF   FF3,W
013B8:  CLRF   x34
013BA:  MOVWF  x33
013BC:  MOVLW  1C
013BE:  ADDWF  x33,W
013C0:  MOVWF  01
013C2:  MOVLW  00
013C4:  ADDWFC x34,W
013C6:  MOVWF  03
013C8:  MOVF   01,W
013CA:  ADDLW  20
013CC:  MOVWF  FE9
013CE:  MOVLW  00
013D0:  ADDWFC 03,W
013D2:  MOVWF  FEA
013D4:  MOVFF  FEF,770
013D8:  MOVFF  FEC,734
013DC:  MOVFF  FEC,772
013E0:  MOVFF  FEC,773
013E4:  CLRF   x6F
013E6:  CLRF   x6E
013E8:  MOVLW  7C
013EA:  MOVWF  x6D
013EC:  MOVLW  84
013EE:  MOVWF  x6C
013F0:  MOVFF  734,771
013F4:  MOVLB  0
013F6:  RCALL  0D62
013F8:  BNC   142C
013FA:  MOVLB  7
013FC:  MOVF   x26,W
013FE:  MULLW  28
01400:  MOVF   FF3,W
01402:  CLRF   x34
01404:  MOVWF  x33
01406:  MOVLW  1C
01408:  ADDWF  x33,W
0140A:  MOVWF  01
0140C:  MOVLW  00
0140E:  ADDWFC x34,W
01410:  MOVWF  03
01412:  MOVF   01,W
01414:  ADDLW  20
01416:  MOVWF  FE9
01418:  MOVLW  00
0141A:  ADDWFC 03,W
0141C:  MOVWF  FEA
0141E:  MOVLW  84
01420:  MOVWF  FEF
01422:  MOVLW  7C
01424:  MOVWF  FEC
01426:  CLRF   FEC
01428:  CLRF   FEC
0142A:  BRA    14A6
....................    else if (PID[ch].I < op_lower_bound) PID[ch].I = op_lower_bound;
0142C:  MOVLB  7
0142E:  MOVF   x26,W
01430:  MULLW  28
01432:  MOVF   FF3,W
01434:  CLRF   x34
01436:  MOVWF  x33
01438:  MOVLW  1C
0143A:  ADDWF  x33,W
0143C:  MOVWF  01
0143E:  MOVLW  00
01440:  ADDWFC x34,W
01442:  MOVWF  03
01444:  MOVF   01,W
01446:  ADDLW  20
01448:  MOVWF  FE9
0144A:  MOVLW  00
0144C:  ADDWFC 03,W
0144E:  MOVWF  FEA
01450:  MOVFF  FEF,76C
01454:  MOVFF  FEC,734
01458:  MOVFF  FEC,76E
0145C:  MOVFF  FEC,76F
01460:  MOVFF  734,76D
01464:  CLRF   x73
01466:  CLRF   x72
01468:  MOVLW  FC
0146A:  MOVWF  x71
0146C:  MOVLW  84
0146E:  MOVWF  x70
01470:  MOVLB  0
01472:  RCALL  0D62
01474:  BNC   14A8
01476:  MOVLB  7
01478:  MOVF   x26,W
0147A:  MULLW  28
0147C:  MOVF   FF3,W
0147E:  CLRF   x34
01480:  MOVWF  x33
01482:  MOVLW  1C
01484:  ADDWF  x33,W
01486:  MOVWF  01
01488:  MOVLW  00
0148A:  ADDWFC x34,W
0148C:  MOVWF  03
0148E:  MOVF   01,W
01490:  ADDLW  20
01492:  MOVWF  FE9
01494:  MOVLW  00
01496:  ADDWFC 03,W
01498:  MOVWF  FEA
0149A:  MOVLW  84
0149C:  MOVWF  FEF
0149E:  MOVLW  FC
014A0:  MOVWF  FEC
014A2:  CLRF   FEC
014A4:  CLRF   FEC
014A6:  MOVLB  0
....................    
....................    float P = err * PID[ch].kP;  // proportional value
....................    
....................    float D = PID[ch].kD * (PID[ch].PV - PID[ch].PVold);  // derivative value
014A8:  MOVLB  7
014AA:  MOVF   x26,W
014AC:  MULLW  28
014AE:  MOVF   FF3,W
014B0:  CLRF   x34
014B2:  MOVWF  x33
014B4:  MOVLW  20
014B6:  ADDWF  x33,W
014B8:  MOVWF  FE9
014BA:  MOVLW  00
014BC:  ADDWFC x34,W
014BE:  MOVWF  FEA
014C0:  MOVFF  FEF,770
014C4:  MOVFF  FEC,01
014C8:  MOVFF  FEC,02
014CC:  MOVFF  FEC,03
014D0:  MOVFF  72A,76F
014D4:  MOVFF  729,76E
014D8:  MOVFF  728,76D
014DC:  MOVFF  727,76C
014E0:  MOVFF  03,773
014E4:  MOVFF  02,772
014E8:  MOVFF  01,771
014EC:  MOVLB  0
014EE:  RCALL  1116
014F0:  MOVFF  03,72E
014F4:  MOVFF  02,72D
014F8:  MOVFF  01,72C
014FC:  MOVFF  00,72B
01500:  MOVLB  7
01502:  MOVF   x26,W
01504:  MULLW  28
01506:  MOVF   FF3,W
01508:  CLRF   x36
0150A:  MOVWF  x35
0150C:  MOVLW  08
0150E:  ADDWF  x35,W
01510:  MOVWF  01
01512:  MOVLW  00
01514:  ADDWFC x36,W
01516:  MOVWF  03
01518:  MOVF   01,W
0151A:  ADDLW  20
0151C:  MOVWF  FE9
0151E:  MOVLW  00
01520:  ADDWFC 03,W
01522:  MOVWF  FEA
01524:  MOVFF  FEF,735
01528:  MOVFF  FEC,736
0152C:  MOVFF  FEC,737
01530:  MOVFF  FEC,738
01534:  MOVF   x26,W
01536:  MULLW  28
01538:  MOVF   FF3,W
0153A:  CLRF   x3A
0153C:  MOVWF  x39
0153E:  MOVLW  10
01540:  ADDWF  x39,W
01542:  MOVWF  01
01544:  MOVLW  00
01546:  ADDWFC x3A,W
01548:  MOVWF  03
0154A:  MOVF   01,W
0154C:  ADDLW  20
0154E:  MOVWF  FE9
01550:  MOVLW  00
01552:  ADDWFC 03,W
01554:  MOVWF  FEA
01556:  MOVFF  FEF,770
0155A:  MOVFF  FEC,771
0155E:  MOVFF  FEC,772
01562:  MOVFF  FEC,773
01566:  MOVF   x26,W
01568:  MULLW  28
0156A:  MOVF   FF3,W
0156C:  CLRF   x3E
0156E:  MOVWF  x3D
01570:  MOVLW  14
01572:  ADDWF  x3D,W
01574:  MOVWF  01
01576:  MOVLW  00
01578:  ADDWFC x3E,W
0157A:  MOVWF  03
0157C:  MOVF   01,W
0157E:  ADDLW  20
01580:  MOVWF  FE9
01582:  MOVLW  00
01584:  ADDWFC 03,W
01586:  MOVWF  FEA
01588:  MOVFF  FEF,774
0158C:  MOVFF  FEC,01
01590:  MOVFF  FEC,02
01594:  MOVFF  FEC,03
01598:  MOVFF  FEA,73E
0159C:  MOVFF  FE9,73D
015A0:  BSF    FD8.1
015A2:  MOVFF  03,777
015A6:  MOVFF  02,776
015AA:  MOVFF  01,775
015AE:  MOVLB  0
015B0:  RCALL  0DDC
015B2:  MOVFF  73E,FEA
015B6:  MOVFF  73D,FE9
015BA:  MOVFF  738,76F
015BE:  MOVFF  737,76E
015C2:  MOVFF  736,76D
015C6:  MOVFF  735,76C
015CA:  MOVFF  03,773
015CE:  MOVFF  02,772
015D2:  MOVFF  01,771
015D6:  MOVFF  00,770
015DA:  RCALL  1116
015DC:  MOVFF  03,732
015E0:  MOVFF  02,731
015E4:  MOVFF  01,730
015E8:  MOVFF  00,72F
....................    
....................    PID[ch].CV = P + PID[ch].I + D;  // new control variable
015EC:  MOVLB  7
015EE:  MOVF   x26,W
015F0:  MULLW  28
015F2:  MOVF   FF3,W
015F4:  CLRF   x34
015F6:  MOVWF  x33
015F8:  MOVLW  18
015FA:  ADDWF  x33,W
015FC:  MOVWF  01
015FE:  MOVLW  00
01600:  ADDWFC x34,W
01602:  MOVWF  03
01604:  MOVF   01,W
01606:  ADDLW  20
01608:  MOVWF  01
0160A:  MOVLW  00
0160C:  ADDWFC 03,F
0160E:  MOVFF  01,733
01612:  MOVFF  03,734
01616:  MOVF   x26,W
01618:  MULLW  28
0161A:  MOVF   FF3,W
0161C:  CLRF   x36
0161E:  MOVWF  x35
01620:  MOVLW  1C
01622:  ADDWF  x35,W
01624:  MOVWF  01
01626:  MOVLW  00
01628:  ADDWFC x36,W
0162A:  MOVWF  03
0162C:  MOVF   01,W
0162E:  ADDLW  20
01630:  MOVWF  FE9
01632:  MOVLW  00
01634:  ADDWFC 03,W
01636:  MOVWF  FEA
01638:  MOVFF  FEF,774
0163C:  MOVFF  FEC,01
01640:  MOVFF  FEC,02
01644:  MOVFF  FEC,03
01648:  MOVFF  FEA,736
0164C:  MOVFF  FE9,735
01650:  BCF    FD8.1
01652:  MOVFF  72E,773
01656:  MOVFF  72D,772
0165A:  MOVFF  72C,771
0165E:  MOVFF  72B,770
01662:  MOVFF  03,777
01666:  MOVFF  02,776
0166A:  MOVFF  01,775
0166E:  MOVLB  0
01670:  CALL   0DDC
01674:  MOVFF  736,FEA
01678:  MOVFF  735,FE9
0167C:  MOVFF  03,73A
01680:  MOVFF  02,739
01684:  MOVFF  01,738
01688:  MOVFF  00,737
0168C:  BCF    FD8.1
0168E:  MOVFF  03,773
01692:  MOVFF  02,772
01696:  MOVFF  01,771
0169A:  MOVFF  00,770
0169E:  MOVFF  732,777
016A2:  MOVFF  731,776
016A6:  MOVFF  730,775
016AA:  MOVFF  72F,774
016AE:  CALL   0DDC
016B2:  MOVFF  734,FEA
016B6:  MOVFF  733,FE9
016BA:  MOVFF  00,FEF
016BE:  MOVFF  01,FEC
016C2:  MOVFF  02,FEC
016C6:  MOVFF  03,FEC
....................    if (PID[ch].CV > op_upper_bound) PID[ch].CV = op_upper_bound; // limit positive output
016CA:  MOVLB  7
016CC:  MOVF   x26,W
016CE:  MULLW  28
016D0:  MOVF   FF3,W
016D2:  CLRF   x34
016D4:  MOVWF  x33
016D6:  MOVLW  18
016D8:  ADDWF  x33,W
016DA:  MOVWF  01
016DC:  MOVLW  00
016DE:  ADDWFC x34,W
016E0:  MOVWF  03
016E2:  MOVF   01,W
016E4:  ADDLW  20
016E6:  MOVWF  FE9
016E8:  MOVLW  00
016EA:  ADDWFC 03,W
016EC:  MOVWF  FEA
016EE:  MOVFF  FEF,770
016F2:  MOVFF  FEC,734
016F6:  MOVFF  FEC,772
016FA:  MOVFF  FEC,773
016FE:  CLRF   x6F
01700:  CLRF   x6E
01702:  MOVLW  7C
01704:  MOVWF  x6D
01706:  MOVLW  84
01708:  MOVWF  x6C
0170A:  MOVFF  734,771
0170E:  MOVLB  0
01710:  CALL   0D62
01714:  BNC   1748
01716:  MOVLB  7
01718:  MOVF   x26,W
0171A:  MULLW  28
0171C:  MOVF   FF3,W
0171E:  CLRF   x34
01720:  MOVWF  x33
01722:  MOVLW  18
01724:  ADDWF  x33,W
01726:  MOVWF  01
01728:  MOVLW  00
0172A:  ADDWFC x34,W
0172C:  MOVWF  03
0172E:  MOVF   01,W
01730:  ADDLW  20
01732:  MOVWF  FE9
01734:  MOVLW  00
01736:  ADDWFC 03,W
01738:  MOVWF  FEA
0173A:  MOVLW  84
0173C:  MOVWF  FEF
0173E:  MOVLW  7C
01740:  MOVWF  FEC
01742:  CLRF   FEC
01744:  CLRF   FEC
01746:  BRA    17C4
....................    else if (PID[ch].CV < op_lower_bound) PID[ch].CV = op_lower_bound; // limit negative output
01748:  MOVLB  7
0174A:  MOVF   x26,W
0174C:  MULLW  28
0174E:  MOVF   FF3,W
01750:  CLRF   x34
01752:  MOVWF  x33
01754:  MOVLW  18
01756:  ADDWF  x33,W
01758:  MOVWF  01
0175A:  MOVLW  00
0175C:  ADDWFC x34,W
0175E:  MOVWF  03
01760:  MOVF   01,W
01762:  ADDLW  20
01764:  MOVWF  FE9
01766:  MOVLW  00
01768:  ADDWFC 03,W
0176A:  MOVWF  FEA
0176C:  MOVFF  FEF,76C
01770:  MOVFF  FEC,734
01774:  MOVFF  FEC,76E
01778:  MOVFF  FEC,76F
0177C:  MOVFF  734,76D
01780:  CLRF   x73
01782:  CLRF   x72
01784:  MOVLW  FC
01786:  MOVWF  x71
01788:  MOVLW  84
0178A:  MOVWF  x70
0178C:  MOVLB  0
0178E:  CALL   0D62
01792:  BNC   17C4
01794:  MOVLB  7
01796:  MOVF   x26,W
01798:  MULLW  28
0179A:  MOVF   FF3,W
0179C:  CLRF   x34
0179E:  MOVWF  x33
017A0:  MOVLW  18
017A2:  ADDWF  x33,W
017A4:  MOVWF  01
017A6:  MOVLW  00
017A8:  ADDWFC x34,W
017AA:  MOVWF  03
017AC:  MOVF   01,W
017AE:  ADDLW  20
017B0:  MOVWF  FE9
017B2:  MOVLW  00
017B4:  ADDWFC 03,W
017B6:  MOVWF  FEA
017B8:  MOVLW  84
017BA:  MOVWF  FEF
017BC:  MOVLW  FC
017BE:  MOVWF  FEC
017C0:  CLRF   FEC
017C2:  CLRF   FEC
017C4:  MOVLB  0
017C6:  GOTO   183E (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PID Task - looks for change to PV and updates CV                          */
.................... /*****************************************************************************/
.................... void pid_task(channelMap ch){
....................    static int index = 0;
....................    if (PID[ch].SP != PID[ch].PV) pid_update(ch);
017CA:  MOVLB  7
017CC:  MOVF   x25,W
017CE:  MULLW  28
017D0:  MOVF   FF3,W
017D2:  CLRF   x27
017D4:  MOVWF  x26
017D6:  MOVLW  0C
017D8:  ADDWF  x26,W
017DA:  MOVWF  01
017DC:  MOVLW  00
017DE:  ADDWFC x27,W
017E0:  MOVWF  03
017E2:  MOVF   01,W
017E4:  ADDLW  20
017E6:  MOVWF  FE9
017E8:  MOVLW  00
017EA:  ADDWFC 03,W
017EC:  MOVWF  FEA
017EE:  MOVFF  FEF,76C
017F2:  MOVFF  FEC,76D
017F6:  MOVFF  FEC,76E
017FA:  MOVFF  FEC,76F
017FE:  MOVF   x25,W
01800:  MULLW  28
01802:  MOVF   FF3,W
01804:  CLRF   x2B
01806:  MOVWF  x2A
01808:  MOVLW  10
0180A:  ADDWF  x2A,W
0180C:  MOVWF  01
0180E:  MOVLW  00
01810:  ADDWFC x2B,W
01812:  MOVWF  03
01814:  MOVF   01,W
01816:  ADDLW  20
01818:  MOVWF  FE9
0181A:  MOVLW  00
0181C:  ADDWFC 03,W
0181E:  MOVWF  FEA
01820:  MOVFF  FEF,770
01824:  MOVFF  FEC,771
01828:  MOVFF  FEC,772
0182C:  MOVFF  FEC,773
01830:  MOVLB  0
01832:  CALL   0D62
01836:  BZ    183E
01838:  MOVFF  725,726
0183C:  BRA    1248
....................    if ((index++) >= numChannels) index = 0;
0183E:  MOVLB  1
01840:  MOVF   xE9,W
01842:  INCF   xE9,F
01844:  SUBLW  01
01846:  BC    184A
01848:  CLRF   xE9
0184A:  MOVLB  0
0184C:  GOTO   195C (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... #pin_select SCK1=PIN_C3
.................... #pin_select SDO1=PIN_C2
.................... #use spi (MASTER, SPI1, BAUD=100000, MODE=2, STREAM=SPI_ctrl)
*
00B02:  CLRF   03
00B04:  MOVF   F91,W
00B06:  MOVFF  727,F91
00B0A:  RRCF   F94,W
00B0C:  BNC   0B0A
00B0E:  MOVF   F91,W
00B10:  MOVWF  02
00B12:  MOVFF  726,F91
00B16:  RRCF   F94,W
00B18:  BNC   0B16
00B1A:  MOVF   F91,W
00B1C:  MOVWF  01
00B1E:  MOVFF  725,F91
00B22:  RRCF   F94,W
00B24:  BNC   0B22
00B26:  MOVFF  F91,00
00B2A:  RETURN 0
.................... 
.................... #define DACfullScale 655.35 // full scale/100 because CV = %
.................... 
.................... /*****************************************************************************/
.................... /*  Inverts the output voltage ( -180V - 0V )                                */ 
.................... /*****************************************************************************/
.................... void invert_voltage(channelMap ch, BOOLEAN inv_v){
....................    if ( inv_v ) {
*
0108A:  MOVLB  7
0108C:  MOVF   x26,F
0108E:  BZ    10D2
....................       if (chMap[0] == ch) output_low(INV_HVX);
01090:  MOVLW  00
01092:  MOVLB  0
01094:  BTFSC  x70.0
01096:  MOVLW  01
01098:  MOVLB  7
0109A:  SUBWF  x25,W
0109C:  BNZ   10A4
0109E:  MOVLW  04
010A0:  MOVWF  F88
010A2:  BCF    F83.4
....................       if (chMap[1] == ch) output_low(INV_HVY);
010A4:  MOVLW  00
010A6:  MOVLB  0
010A8:  BTFSC  x70.1
010AA:  MOVLW  01
010AC:  MOVLB  7
010AE:  SUBWF  x25,W
010B0:  BNZ   10B8
010B2:  MOVLW  04
010B4:  MOVWF  F88
010B6:  BCF    F83.5
....................       dacVals[ch].invV = TRUE;
010B8:  MOVF   x25,W
010BA:  MULLW  07
010BC:  MOVF   FF3,W
010BE:  CLRF   x28
010C0:  MOVWF  x27
010C2:  MOVLW  64
010C4:  ADDWF  x27,W
010C6:  MOVWF  FE9
010C8:  MOVLW  01
010CA:  ADDWFC x28,W
010CC:  MOVWF  FEA
010CE:  BSF    FEF.0
....................    }
010D0:  BRA    1112
....................    else {
....................       if (chMap[0] == ch) output_high(INV_HVX);
010D2:  MOVLW  00
010D4:  MOVLB  0
010D6:  BTFSC  x70.0
010D8:  MOVLW  01
010DA:  MOVLB  7
010DC:  SUBWF  x25,W
010DE:  BNZ   10E6
010E0:  MOVLW  04
010E2:  MOVWF  F88
010E4:  BSF    F83.4
....................       if (chMap[1] == ch) output_high(INV_HVY);
010E6:  MOVLW  00
010E8:  MOVLB  0
010EA:  BTFSC  x70.1
010EC:  MOVLW  01
010EE:  MOVLB  7
010F0:  SUBWF  x25,W
010F2:  BNZ   10FA
010F4:  MOVLW  04
010F6:  MOVWF  F88
010F8:  BSF    F83.5
....................       dacVals[ch].invV = FALSE;
010FA:  MOVF   x25,W
010FC:  MULLW  07
010FE:  MOVF   FF3,W
01100:  CLRF   x28
01102:  MOVWF  x27
01104:  MOVLW  64
01106:  ADDWF  x27,W
01108:  MOVWF  FE9
0110A:  MOVLW  01
0110C:  ADDWFC x28,W
0110E:  MOVWF  FEA
01110:  BCF    FEF.0
....................    }
01112:  MOVLB  0
01114:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  Nano DAC's have a 16bit serial shift register. Data is sync'ed to output */ 
.................... /*****************************************************************************/
.................... void set_nanoDAC_outputs(channelMap ch){
*
01850:  MOVLB  7
01852:  CLRF   x24
01854:  CLRF   x23
....................     unsigned int16 txData = 0;
....................    
....................     // use dacVals.opPcnt values if channel is manual mode
....................     // else, use PID control variable
....................     if (chMode[ch] == MANUAL){
01856:  MOVFF  722,725
0185A:  CLRF   x27
0185C:  MOVLW  71
0185E:  MOVWF  x26
01860:  MOVLB  0
01862:  CALL   1054
01866:  MOVF   01,F
01868:  BNZ   1956
....................         if ( dacVals[ch].opPcnt < 0) invert_voltage(ch, TRUE); 
0186A:  MOVLB  7
0186C:  MOVF   x22,W
0186E:  MULLW  07
01870:  MOVF   FF3,W
01872:  CLRF   x26
01874:  MOVWF  x25
01876:  MOVLW  03
01878:  ADDWF  x25,W
0187A:  MOVWF  01
0187C:  MOVLW  00
0187E:  ADDWFC x26,W
01880:  MOVWF  03
01882:  MOVF   01,W
01884:  ADDLW  64
01886:  MOVWF  FE9
01888:  MOVLW  01
0188A:  ADDWFC 03,W
0188C:  MOVWF  FEA
0188E:  MOVFF  FEF,76C
01892:  MOVFF  FEC,76D
01896:  MOVFF  FEC,76E
0189A:  MOVFF  FEC,76F
0189E:  CLRF   x73
018A0:  CLRF   x72
018A2:  CLRF   x71
018A4:  CLRF   x70
018A6:  MOVLB  0
018A8:  CALL   0D62
018AC:  BNC   18C0
018AE:  MOVFF  722,725
018B2:  MOVLW  01
018B4:  MOVLB  7
018B6:  MOVWF  x26
018B8:  MOVLB  0
018BA:  CALL   108A
018BE:  BRA    18CE
....................         else                         invert_voltage(ch, FALSE);
018C0:  MOVFF  722,725
018C4:  MOVLB  7
018C6:  CLRF   x26
018C8:  MOVLB  0
018CA:  CALL   108A
....................       
....................         txData = (unsigned int16)(abs(dacVals[ch].opPcnt) * DACfullScale);
018CE:  MOVLB  7
018D0:  MOVF   x22,W
018D2:  MULLW  07
018D4:  MOVF   FF3,W
018D6:  CLRF   x26
018D8:  MOVWF  x25
018DA:  MOVLW  03
018DC:  ADDWF  x25,W
018DE:  MOVWF  01
018E0:  MOVLW  00
018E2:  ADDWFC x26,W
018E4:  MOVWF  03
018E6:  MOVF   01,W
018E8:  ADDLW  64
018EA:  MOVWF  FE9
018EC:  MOVLW  01
018EE:  ADDWFC 03,W
018F0:  MOVWF  FEA
018F2:  MOVFF  FEF,00
018F6:  MOVFF  FEC,01
018FA:  MOVFF  FEC,02
018FE:  MOVFF  FEC,03
01902:  BCF    01.7
01904:  MOVFF  03,728
01908:  MOVFF  02,727
0190C:  MOVFF  01,726
01910:  MOVFF  00,725
01914:  MOVFF  03,76F
01918:  MOVFF  02,76E
0191C:  MOVFF  01,76D
01920:  MOVFF  00,76C
01924:  MOVLW  66
01926:  MOVWF  x73
01928:  MOVLW  D6
0192A:  MOVWF  x72
0192C:  MOVLW  23
0192E:  MOVWF  x71
01930:  MOVLW  88
01932:  MOVWF  x70
01934:  MOVLB  0
01936:  CALL   1116
0193A:  MOVFF  03,76F
0193E:  MOVFF  02,76E
01942:  MOVFF  01,76D
01946:  MOVFF  00,76C
0194A:  RCALL  120C
0194C:  MOVFF  02,724
01950:  MOVFF  01,723
....................     }
01954:  BRA    1A48
....................     else {
....................         pid_task(ch);
01956:  MOVFF  722,725
0195A:  BRA    17CA
....................         if ( PID[(int)ch].CV < 0 ) invert_voltage(ch, TRUE); 
0195C:  MOVLB  7
0195E:  MOVF   x22,W
01960:  MULLW  28
01962:  MOVF   FF3,W
01964:  CLRF   x26
01966:  MOVWF  x25
01968:  MOVLW  18
0196A:  ADDWF  x25,W
0196C:  MOVWF  01
0196E:  MOVLW  00
01970:  ADDWFC x26,W
01972:  MOVWF  03
01974:  MOVF   01,W
01976:  ADDLW  20
01978:  MOVWF  FE9
0197A:  MOVLW  00
0197C:  ADDWFC 03,W
0197E:  MOVWF  FEA
01980:  MOVFF  FEF,76C
01984:  MOVFF  FEC,76D
01988:  MOVFF  FEC,76E
0198C:  MOVFF  FEC,76F
01990:  CLRF   x73
01992:  CLRF   x72
01994:  CLRF   x71
01996:  CLRF   x70
01998:  MOVLB  0
0199A:  CALL   0D62
0199E:  BNC   19B2
019A0:  MOVFF  722,725
019A4:  MOVLW  01
019A6:  MOVLB  7
019A8:  MOVWF  x26
019AA:  MOVLB  0
019AC:  CALL   108A
019B0:  BRA    19C0
....................         else                       invert_voltage(ch, FALSE);
019B2:  MOVFF  722,725
019B6:  MOVLB  7
019B8:  CLRF   x26
019BA:  MOVLB  0
019BC:  CALL   108A
....................       
....................         txData = (unsigned int16)(abs(PID[(int)ch].CV) * DACfullScale);
019C0:  MOVLB  7
019C2:  MOVF   x22,W
019C4:  MULLW  28
019C6:  MOVF   FF3,W
019C8:  CLRF   x26
019CA:  MOVWF  x25
019CC:  MOVLW  18
019CE:  ADDWF  x25,W
019D0:  MOVWF  01
019D2:  MOVLW  00
019D4:  ADDWFC x26,W
019D6:  MOVWF  03
019D8:  MOVF   01,W
019DA:  ADDLW  20
019DC:  MOVWF  FE9
019DE:  MOVLW  00
019E0:  ADDWFC 03,W
019E2:  MOVWF  FEA
019E4:  MOVFF  FEF,00
019E8:  MOVFF  FEC,01
019EC:  MOVFF  FEC,02
019F0:  MOVFF  FEC,03
019F4:  BCF    01.7
019F6:  MOVFF  03,728
019FA:  MOVFF  02,727
019FE:  MOVFF  01,726
01A02:  MOVFF  00,725
01A06:  MOVFF  03,76F
01A0A:  MOVFF  02,76E
01A0E:  MOVFF  01,76D
01A12:  MOVFF  00,76C
01A16:  MOVLW  66
01A18:  MOVWF  x73
01A1A:  MOVLW  D6
01A1C:  MOVWF  x72
01A1E:  MOVLW  23
01A20:  MOVWF  x71
01A22:  MOVLW  88
01A24:  MOVWF  x70
01A26:  MOVLB  0
01A28:  CALL   1116
01A2C:  MOVFF  03,76F
01A30:  MOVFF  02,76E
01A34:  MOVFF  01,76D
01A38:  MOVFF  00,76C
01A3C:  CALL   120C
01A40:  MOVFF  02,724
01A44:  MOVFF  01,723
....................     }
....................    
....................     dacVals[ch].ipVal = txData;
01A48:  MOVLB  7
01A4A:  MOVF   x22,W
01A4C:  MULLW  07
01A4E:  MOVF   FF3,W
01A50:  CLRF   x26
01A52:  MOVWF  x25
01A54:  MOVLW  01
01A56:  ADDWF  x25,W
01A58:  MOVWF  01
01A5A:  MOVLW  00
01A5C:  ADDWFC x26,W
01A5E:  MOVWF  03
01A60:  MOVF   01,W
01A62:  ADDLW  64
01A64:  MOVWF  FE9
01A66:  MOVLW  01
01A68:  ADDWFC 03,W
01A6A:  MOVWF  FEA
01A6C:  MOVFF  724,FEC
01A70:  MOVF   FED,F
01A72:  MOVFF  723,FEF
....................    
....................     // use channel map to decide which outputs channels to update
....................     // strobe _sync low to push data to the outputs
....................     if (chMap[0] == ch) output_high(_SYNC_X);
01A76:  MOVLW  00
01A78:  MOVLB  0
01A7A:  BTFSC  x70.0
01A7C:  MOVLW  01
01A7E:  MOVLB  7
01A80:  SUBWF  x22,W
01A82:  BNZ   1A8A
01A84:  MOVLW  E8
01A86:  MOVWF  F8B
01A88:  BSF    F86.2
....................     if (chMap[1] == ch) output_high(_SYNC_Y);
01A8A:  MOVLW  00
01A8C:  MOVLB  0
01A8E:  BTFSC  x70.1
01A90:  MOVLW  01
01A92:  MOVLB  7
01A94:  SUBWF  x22,W
01A96:  BNZ   1A9E
01A98:  MOVLW  E8
01A9A:  MOVWF  F8B
01A9C:  BSF    F86.1
....................    
....................     delay_ms(1);
01A9E:  MOVLW  01
01AA0:  MOVWF  x25
01AA2:  MOVLB  0
01AA4:  CALL   0436
....................    
....................     if (chMap[0] == ch) output_low(_SYNC_X);
01AA8:  MOVLW  00
01AAA:  BTFSC  x70.0
01AAC:  MOVLW  01
01AAE:  MOVLB  7
01AB0:  SUBWF  x22,W
01AB2:  BNZ   1ABA
01AB4:  MOVLW  E8
01AB6:  MOVWF  F8B
01AB8:  BCF    F86.2
....................     if (chMap[1] == ch) output_low(_SYNC_Y);
01ABA:  MOVLW  00
01ABC:  MOVLB  0
01ABE:  BTFSC  x70.1
01AC0:  MOVLW  01
01AC2:  MOVLB  7
01AC4:  SUBWF  x22,W
01AC6:  BNZ   1ACE
01AC8:  MOVLW  E8
01ACA:  MOVWF  F8B
01ACC:  BCF    F86.1
....................     delay_ms(1);
01ACE:  MOVLW  01
01AD0:  MOVWF  x25
01AD2:  MOVLB  0
01AD4:  CALL   0436
....................    
....................     // shift 16 bits of data
....................     spi_xfer(SPI_ctrl, txData, 24);
01AD8:  MOVLB  7
01ADA:  CLRF   x28
01ADC:  CLRF   x27
01ADE:  MOVFF  724,726
01AE2:  MOVFF  723,725
01AE6:  MOVLB  0
01AE8:  CALL   0B02
....................     delay_ms(1);
01AEC:  MOVLW  01
01AEE:  MOVLB  7
01AF0:  MOVWF  x25
01AF2:  MOVLB  0
01AF4:  CALL   0436
....................    
....................     if (chMap[0] == ch) output_high(_SYNC_X);
01AF8:  MOVLW  00
01AFA:  BTFSC  x70.0
01AFC:  MOVLW  01
01AFE:  MOVLB  7
01B00:  SUBWF  x22,W
01B02:  BNZ   1B0A
01B04:  MOVLW  E8
01B06:  MOVWF  F8B
01B08:  BSF    F86.2
....................     if (chMap[1] == ch) output_high(_SYNC_Y);
01B0A:  MOVLW  00
01B0C:  MOVLB  0
01B0E:  BTFSC  x70.1
01B10:  MOVLW  01
01B12:  MOVLB  7
01B14:  SUBWF  x22,W
01B16:  BNZ   1B1E
01B18:  MOVLW  E8
01B1A:  MOVWF  F8B
01B1C:  BSF    F86.1
01B1E:  MOVLB  0
01B20:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  Axis homing routines and helper functions                                */ 
.................... /*****************************************************************************/
.................... void slew_to_upper_bound(channelMap ch){
....................     chMode[ch] = MANUAL;        // set channel to manual
01B22:  MOVFF  721,738
01B26:  MOVLB  7
01B28:  CLRF   x39
01B2A:  CLRF   x3B
01B2C:  MOVLW  71
01B2E:  MOVWF  x3A
01B30:  MOVLB  0
01B32:  CALL   0D20
....................     
....................     while (dacVals[ch].opPcnt < op_upper_bound){
01B36:  MOVLB  7
01B38:  MOVF   x21,W
01B3A:  MULLW  07
01B3C:  MOVF   FF3,W
01B3E:  CLRF   x23
01B40:  MOVWF  x22
01B42:  MOVLW  03
01B44:  ADDWF  x22,W
01B46:  MOVWF  01
01B48:  MOVLW  00
01B4A:  ADDWFC x23,W
01B4C:  MOVWF  03
01B4E:  MOVF   01,W
01B50:  ADDLW  64
01B52:  MOVWF  FE9
01B54:  MOVLW  01
01B56:  ADDWFC 03,W
01B58:  MOVWF  FEA
01B5A:  MOVFF  FEF,76C
01B5E:  MOVFF  FEC,76D
01B62:  MOVFF  FEC,76E
01B66:  MOVFF  FEC,76F
01B6A:  CLRF   x73
01B6C:  CLRF   x72
01B6E:  MOVLW  7C
01B70:  MOVWF  x71
01B72:  MOVLW  84
01B74:  MOVWF  x70
01B76:  MOVLB  0
01B78:  CALL   0D62
01B7C:  BNC   1C06
....................         dacVals[ch].opPcnt += 10;   // increase output by 10%
01B7E:  MOVLB  7
01B80:  MOVF   x21,W
01B82:  MULLW  07
01B84:  MOVF   FF3,W
01B86:  CLRF   x23
01B88:  MOVWF  x22
01B8A:  MOVLW  03
01B8C:  ADDWF  x22,W
01B8E:  MOVWF  01
01B90:  MOVLW  00
01B92:  ADDWFC x23,W
01B94:  MOVWF  03
01B96:  MOVF   01,W
01B98:  ADDLW  64
01B9A:  MOVWF  FE9
01B9C:  MOVLW  01
01B9E:  ADDWFC 03,W
01BA0:  MOVWF  FEA
01BA2:  MOVFF  FEA,729
01BA6:  MOVFF  FE9,728
01BAA:  BCF    FD8.1
01BAC:  MOVFF  FEF,770
01BB0:  MOVFF  FEC,771
01BB4:  MOVFF  FEC,772
01BB8:  MOVFF  FEC,773
01BBC:  CLRF   x77
01BBE:  CLRF   x76
01BC0:  MOVLW  20
01BC2:  MOVWF  x75
01BC4:  MOVLW  82
01BC6:  MOVWF  x74
01BC8:  MOVLB  0
01BCA:  CALL   0DDC
01BCE:  MOVFF  729,FEA
01BD2:  MOVFF  728,FE9
01BD6:  MOVFF  00,FEF
01BDA:  MOVFF  01,FEC
01BDE:  MOVFF  02,FEC
01BE2:  MOVFF  03,FEC
....................         set_nanoDAC_outputs(ch);
01BE6:  MOVFF  721,722
01BEA:  RCALL  1850
....................         delay_ms(500);
01BEC:  MOVLW  02
01BEE:  MOVLB  7
01BF0:  MOVWF  x22
01BF2:  MOVLW  FA
01BF4:  MOVWF  x25
01BF6:  MOVLB  0
01BF8:  CALL   0436
01BFC:  MOVLB  7
01BFE:  DECFSZ x22,F
01C00:  BRA    1BF2
01C02:  BRA    1B38
01C04:  MOVLB  0
....................     }
....................     dacVals[ch].opPcnt = op_upper_bound;    // set output to upper bound
01C06:  MOVLB  7
01C08:  MOVF   x21,W
01C0A:  MULLW  07
01C0C:  MOVF   FF3,W
01C0E:  CLRF   x23
01C10:  MOVWF  x22
01C12:  MOVLW  03
01C14:  ADDWF  x22,W
01C16:  MOVWF  01
01C18:  MOVLW  00
01C1A:  ADDWFC x23,W
01C1C:  MOVWF  03
01C1E:  MOVF   01,W
01C20:  ADDLW  64
01C22:  MOVWF  FE9
01C24:  MOVLW  01
01C26:  ADDWFC 03,W
01C28:  MOVWF  FEA
01C2A:  MOVLW  84
01C2C:  MOVWF  FEF
01C2E:  MOVLW  7C
01C30:  MOVWF  FEC
01C32:  CLRF   FEC
01C34:  CLRF   FEC
....................     set_nanoDAC_outputs(ch);
01C36:  MOVFF  721,722
01C3A:  MOVLB  0
01C3C:  RCALL  1850
....................     delay_ms(500);
01C3E:  MOVLW  02
01C40:  MOVLB  7
01C42:  MOVWF  x22
01C44:  MOVLW  FA
01C46:  MOVWF  x25
01C48:  MOVLB  0
01C4A:  CALL   0436
01C4E:  MOVLB  7
01C50:  DECFSZ x22,F
01C52:  BRA    1C44
01C54:  MOVLB  0
01C56:  RETURN 0
.................... }
.................... 
.................... void slew_to_lower_bound(channelMap ch){
....................     chMode[ch] = MANUAL;        // set channel to manual
01C58:  MOVFF  721,738
01C5C:  MOVLB  7
01C5E:  CLRF   x39
01C60:  CLRF   x3B
01C62:  MOVLW  71
01C64:  MOVWF  x3A
01C66:  MOVLB  0
01C68:  CALL   0D20
....................     
....................     while (dacVals[ch].opPcnt > op_lower_bound){
01C6C:  MOVLB  7
01C6E:  MOVF   x21,W
01C70:  MULLW  07
01C72:  MOVF   FF3,W
01C74:  CLRF   x23
01C76:  MOVWF  x22
01C78:  MOVLW  03
01C7A:  ADDWF  x22,W
01C7C:  MOVWF  01
01C7E:  MOVLW  00
01C80:  ADDWFC x23,W
01C82:  MOVWF  03
01C84:  MOVF   01,W
01C86:  ADDLW  64
01C88:  MOVWF  FE9
01C8A:  MOVLW  01
01C8C:  ADDWFC 03,W
01C8E:  MOVWF  FEA
01C90:  MOVFF  FEF,770
01C94:  MOVFF  FEC,771
01C98:  MOVFF  FEC,772
01C9C:  MOVFF  FEC,773
01CA0:  CLRF   x6F
01CA2:  CLRF   x6E
01CA4:  MOVLW  FC
01CA6:  MOVWF  x6D
01CA8:  MOVLW  84
01CAA:  MOVWF  x6C
01CAC:  MOVLB  0
01CAE:  CALL   0D62
01CB2:  BNC   1D3C
....................         dacVals[ch].opPcnt -= 10;   // decrease output by 10%
01CB4:  MOVLB  7
01CB6:  MOVF   x21,W
01CB8:  MULLW  07
01CBA:  MOVF   FF3,W
01CBC:  CLRF   x23
01CBE:  MOVWF  x22
01CC0:  MOVLW  03
01CC2:  ADDWF  x22,W
01CC4:  MOVWF  01
01CC6:  MOVLW  00
01CC8:  ADDWFC x23,W
01CCA:  MOVWF  03
01CCC:  MOVF   01,W
01CCE:  ADDLW  64
01CD0:  MOVWF  FE9
01CD2:  MOVLW  01
01CD4:  ADDWFC 03,W
01CD6:  MOVWF  FEA
01CD8:  MOVFF  FEA,729
01CDC:  MOVFF  FE9,728
01CE0:  BSF    FD8.1
01CE2:  MOVFF  FEF,770
01CE6:  MOVFF  FEC,771
01CEA:  MOVFF  FEC,772
01CEE:  MOVFF  FEC,773
01CF2:  CLRF   x77
01CF4:  CLRF   x76
01CF6:  MOVLW  20
01CF8:  MOVWF  x75
01CFA:  MOVLW  82
01CFC:  MOVWF  x74
01CFE:  MOVLB  0
01D00:  CALL   0DDC
01D04:  MOVFF  729,FEA
01D08:  MOVFF  728,FE9
01D0C:  MOVFF  00,FEF
01D10:  MOVFF  01,FEC
01D14:  MOVFF  02,FEC
01D18:  MOVFF  03,FEC
....................         set_nanoDAC_outputs(ch);
01D1C:  MOVFF  721,722
01D20:  RCALL  1850
....................         delay_ms(500);
01D22:  MOVLW  02
01D24:  MOVLB  7
01D26:  MOVWF  x22
01D28:  MOVLW  FA
01D2A:  MOVWF  x25
01D2C:  MOVLB  0
01D2E:  CALL   0436
01D32:  MOVLB  7
01D34:  DECFSZ x22,F
01D36:  BRA    1D28
01D38:  BRA    1C6E
01D3A:  MOVLB  0
....................     }
....................     dacVals[ch].opPcnt = op_lower_bound;    // set output to lower bound
01D3C:  MOVLB  7
01D3E:  MOVF   x21,W
01D40:  MULLW  07
01D42:  MOVF   FF3,W
01D44:  CLRF   x23
01D46:  MOVWF  x22
01D48:  MOVLW  03
01D4A:  ADDWF  x22,W
01D4C:  MOVWF  01
01D4E:  MOVLW  00
01D50:  ADDWFC x23,W
01D52:  MOVWF  03
01D54:  MOVF   01,W
01D56:  ADDLW  64
01D58:  MOVWF  FE9
01D5A:  MOVLW  01
01D5C:  ADDWFC 03,W
01D5E:  MOVWF  FEA
01D60:  MOVLW  84
01D62:  MOVWF  FEF
01D64:  MOVLW  FC
01D66:  MOVWF  FEC
01D68:  CLRF   FEC
01D6A:  CLRF   FEC
....................     set_nanoDAC_outputs(ch);
01D6C:  MOVFF  721,722
01D70:  MOVLB  0
01D72:  RCALL  1850
....................     delay_ms(500);
01D74:  MOVLW  02
01D76:  MOVLB  7
01D78:  MOVWF  x22
01D7A:  MOVLW  FA
01D7C:  MOVWF  x25
01D7E:  MOVLB  0
01D80:  CALL   0436
01D84:  MOVLB  7
01D86:  DECFSZ x22,F
01D88:  BRA    1D7A
01D8A:  MOVLB  0
01D8C:  RETURN 0
.................... }
.................... 
.................... void home_axis(channelMap ch){
*
04CF6:  MOVLB  7
04CF8:  CLRF   x1A
04CFA:  CLRF   x19
04CFC:  CLRF   x18
04CFE:  CLRF   x17
04D00:  CLRF   x1E
04D02:  CLRF   x1D
04D04:  CLRF   x1C
04D06:  CLRF   x1B
04D08:  MOVLW  03
04D0A:  MOVWF  x1F
....................     float maxSP = 0;
....................     float minSP = 0;
....................     int loops = 3;
....................     
....................     adcVals[ch].pHome = 0;
04D0C:  MOVF   x16,W
04D0E:  MULLW  26
04D10:  MOVF   FF3,W
04D12:  CLRF   x22
04D14:  MOVWF  x21
04D16:  MOVLW  21
04D18:  ADDWF  x21,W
04D1A:  MOVWF  01
04D1C:  MOVLW  00
04D1E:  ADDWFC x22,W
04D20:  MOVWF  03
04D22:  MOVF   01,W
04D24:  ADDLW  17
04D26:  MOVWF  FE9
04D28:  MOVLW  01
04D2A:  ADDWFC 03,W
04D2C:  MOVWF  FEA
04D2E:  CLRF   FEF
04D30:  CLRF   FEC
04D32:  CLRF   FEC
04D34:  CLRF   FEC
....................     
....................     // Slew up and down a couple times then set output to 0 to settle the piezo
....................     slew_to_upper_bound(ch);
04D36:  MOVFF  716,721
04D3A:  MOVLB  0
04D3C:  CALL   1B22
....................     slew_to_lower_bound(ch);
04D40:  MOVFF  716,721
04D44:  CALL   1C58
....................     slew_to_upper_bound(ch);
04D48:  MOVFF  716,721
04D4C:  CALL   1B22
....................     slew_to_lower_bound(ch);
04D50:  MOVFF  716,721
04D54:  CALL   1C58
.................... //!    dacVals[ch].opPcnt = 0;
.................... //!    set_nanoDAC_outputs(ch);
.................... //!    delay_ms(500);
....................     
....................     for (int i=0; i<loops; i++){
04D58:  MOVLB  7
04D5A:  CLRF   x20
04D5C:  MOVF   x1F,W
04D5E:  SUBWF  x20,W
04D60:  BTFSC  FD8.0
04D62:  BRA    4E70
....................         slew_to_upper_bound(ch);
04D64:  MOVFF  716,721
04D68:  MOVLB  0
04D6A:  CALL   1B22
....................         sensor_monitor_task();
04D6E:  RCALL  4B46
....................         maxSP+=adcVals[ch].pReal;
04D70:  MOVLB  7
04D72:  MOVF   x16,W
04D74:  MULLW  26
04D76:  MOVF   FF3,W
04D78:  CLRF   x22
04D7A:  MOVWF  x21
04D7C:  MOVLW  1D
04D7E:  ADDWF  x21,W
04D80:  MOVWF  01
04D82:  MOVLW  00
04D84:  ADDWFC x22,W
04D86:  MOVWF  03
04D88:  MOVF   01,W
04D8A:  ADDLW  17
04D8C:  MOVWF  FE9
04D8E:  MOVLW  01
04D90:  ADDWFC 03,W
04D92:  MOVWF  FEA
04D94:  MOVFF  FEF,774
04D98:  MOVFF  FEC,01
04D9C:  MOVFF  FEC,02
04DA0:  MOVFF  FEC,03
04DA4:  MOVFF  FEA,722
04DA8:  MOVFF  FE9,721
04DAC:  BCF    FD8.1
04DAE:  MOVFF  71A,773
04DB2:  MOVFF  719,772
04DB6:  MOVFF  718,771
04DBA:  MOVFF  717,770
04DBE:  MOVFF  03,777
04DC2:  MOVFF  02,776
04DC6:  MOVFF  01,775
04DCA:  MOVLB  0
04DCC:  CALL   0DDC
04DD0:  MOVFF  722,FEA
04DD4:  MOVFF  721,FE9
04DD8:  MOVFF  03,71A
04DDC:  MOVFF  02,719
04DE0:  MOVFF  01,718
04DE4:  MOVFF  00,717
....................         
....................         slew_to_lower_bound(ch);
04DE8:  MOVFF  716,721
04DEC:  CALL   1C58
....................         sensor_monitor_task();
04DF0:  RCALL  4B46
....................         minSP+=adcVals[ch].pReal;
04DF2:  MOVLB  7
04DF4:  MOVF   x16,W
04DF6:  MULLW  26
04DF8:  MOVF   FF3,W
04DFA:  CLRF   x22
04DFC:  MOVWF  x21
04DFE:  MOVLW  1D
04E00:  ADDWF  x21,W
04E02:  MOVWF  01
04E04:  MOVLW  00
04E06:  ADDWFC x22,W
04E08:  MOVWF  03
04E0A:  MOVF   01,W
04E0C:  ADDLW  17
04E0E:  MOVWF  FE9
04E10:  MOVLW  01
04E12:  ADDWFC 03,W
04E14:  MOVWF  FEA
04E16:  MOVFF  FEF,774
04E1A:  MOVFF  FEC,01
04E1E:  MOVFF  FEC,02
04E22:  MOVFF  FEC,03
04E26:  MOVFF  FEA,722
04E2A:  MOVFF  FE9,721
04E2E:  BCF    FD8.1
04E30:  MOVFF  71E,773
04E34:  MOVFF  71D,772
04E38:  MOVFF  71C,771
04E3C:  MOVFF  71B,770
04E40:  MOVFF  03,777
04E44:  MOVFF  02,776
04E48:  MOVFF  01,775
04E4C:  MOVLB  0
04E4E:  CALL   0DDC
04E52:  MOVFF  722,FEA
04E56:  MOVFF  721,FE9
04E5A:  MOVFF  03,71E
04E5E:  MOVFF  02,71D
04E62:  MOVFF  01,71C
04E66:  MOVFF  00,71B
04E6A:  MOVLB  7
04E6C:  INCF   x20,F
04E6E:  BRA    4D5C
....................     }
....................     
....................     PID[ch].maxSP = maxSP / (float)loops;
04E70:  MOVF   x16,W
04E72:  MULLW  28
04E74:  MOVF   FF3,W
04E76:  CLRF   x22
04E78:  MOVWF  x21
04E7A:  MOVLW  20
04E7C:  ADDWF  x21,W
04E7E:  MOVWF  01
04E80:  MOVLW  00
04E82:  ADDWFC x22,W
04E84:  MOVWF  03
04E86:  MOVF   01,W
04E88:  ADDLW  20
04E8A:  MOVWF  FE9
04E8C:  MOVLW  00
04E8E:  ADDWFC 03,W
04E90:  MOVWF  FEA
04E92:  CLRF   x71
04E94:  MOVFF  71F,770
04E98:  MOVLB  0
04E9A:  CALL   2DB8
04E9E:  MOVFF  71A,768
04EA2:  MOVFF  719,767
04EA6:  MOVFF  718,766
04EAA:  MOVFF  717,765
04EAE:  MOVFF  03,76C
04EB2:  MOVFF  02,76B
04EB6:  MOVFF  01,76A
04EBA:  MOVFF  00,769
04EBE:  CALL   242E
04EC2:  MOVFF  00,FEF
04EC6:  MOVFF  01,FEC
04ECA:  MOVFF  02,FEC
04ECE:  MOVFF  03,FEC
....................     PID[ch].minSP = minSP / (float)loops;
04ED2:  MOVLB  7
04ED4:  MOVF   x16,W
04ED6:  MULLW  28
04ED8:  MOVF   FF3,W
04EDA:  CLRF   x22
04EDC:  MOVWF  x21
04EDE:  MOVLW  24
04EE0:  ADDWF  x21,W
04EE2:  MOVWF  01
04EE4:  MOVLW  00
04EE6:  ADDWFC x22,W
04EE8:  MOVWF  03
04EEA:  MOVF   01,W
04EEC:  ADDLW  20
04EEE:  MOVWF  FE9
04EF0:  MOVLW  00
04EF2:  ADDWFC 03,W
04EF4:  MOVWF  FEA
04EF6:  CLRF   x71
04EF8:  MOVFF  71F,770
04EFC:  MOVLB  0
04EFE:  CALL   2DB8
04F02:  MOVFF  71E,768
04F06:  MOVFF  71D,767
04F0A:  MOVFF  71C,766
04F0E:  MOVFF  71B,765
04F12:  MOVFF  03,76C
04F16:  MOVFF  02,76B
04F1A:  MOVFF  01,76A
04F1E:  MOVFF  00,769
04F22:  CALL   242E
04F26:  MOVFF  00,FEF
04F2A:  MOVFF  01,FEC
04F2E:  MOVFF  02,FEC
04F32:  MOVFF  03,FEC
....................     adcVals[ch].pHome = (maxSP+minSP) / ((float)loops*2);
04F36:  MOVLB  7
04F38:  MOVF   x16,W
04F3A:  MULLW  26
04F3C:  MOVF   FF3,W
04F3E:  CLRF   x22
04F40:  MOVWF  x21
04F42:  MOVLW  21
04F44:  ADDWF  x21,W
04F46:  MOVWF  01
04F48:  MOVLW  00
04F4A:  ADDWFC x22,W
04F4C:  MOVWF  03
04F4E:  MOVF   01,W
04F50:  ADDLW  17
04F52:  MOVWF  FE9
04F54:  MOVLW  01
04F56:  ADDWFC 03,W
04F58:  MOVWF  FEA
04F5A:  MOVFF  FEA,724
04F5E:  MOVFF  FE9,723
04F62:  BCF    FD8.1
04F64:  MOVFF  71A,773
04F68:  MOVFF  719,772
04F6C:  MOVFF  718,771
04F70:  MOVFF  717,770
04F74:  MOVFF  71E,777
04F78:  MOVFF  71D,776
04F7C:  MOVFF  71C,775
04F80:  MOVFF  71B,774
04F84:  MOVLB  0
04F86:  CALL   0DDC
04F8A:  MOVFF  724,FEA
04F8E:  MOVFF  723,FE9
04F92:  MOVFF  03,728
04F96:  MOVFF  02,727
04F9A:  MOVFF  01,726
04F9E:  MOVFF  00,725
04FA2:  MOVLB  7
04FA4:  CLRF   x71
04FA6:  MOVFF  71F,770
04FAA:  MOVLB  0
04FAC:  CALL   2DB8
04FB0:  MOVFF  03,72C
04FB4:  MOVFF  02,72B
04FB8:  MOVFF  01,72A
04FBC:  MOVFF  00,729
04FC0:  MOVFF  03,76F
04FC4:  MOVFF  02,76E
04FC8:  MOVFF  01,76D
04FCC:  MOVFF  00,76C
04FD0:  MOVLB  7
04FD2:  CLRF   x73
04FD4:  CLRF   x72
04FD6:  CLRF   x71
04FD8:  MOVLW  80
04FDA:  MOVWF  x70
04FDC:  MOVLB  0
04FDE:  CALL   1116
04FE2:  MOVFF  728,768
04FE6:  MOVFF  727,767
04FEA:  MOVFF  726,766
04FEE:  MOVFF  725,765
04FF2:  MOVFF  03,76C
04FF6:  MOVFF  02,76B
04FFA:  MOVFF  01,76A
04FFE:  MOVFF  00,769
05002:  CALL   242E
05006:  MOVFF  00,FEF
0500A:  MOVFF  01,FEC
0500E:  MOVFF  02,FEC
05012:  MOVFF  03,FEC
....................     dacVals[ch].opPcnt = 0;
05016:  MOVLB  7
05018:  MOVF   x16,W
0501A:  MULLW  07
0501C:  MOVF   FF3,W
0501E:  CLRF   x22
05020:  MOVWF  x21
05022:  MOVLW  03
05024:  ADDWF  x21,W
05026:  MOVWF  01
05028:  MOVLW  00
0502A:  ADDWFC x22,W
0502C:  MOVWF  03
0502E:  MOVF   01,W
05030:  ADDLW  64
05032:  MOVWF  FE9
05034:  MOVLW  01
05036:  ADDWFC 03,W
05038:  MOVWF  FEA
0503A:  CLRF   FEF
0503C:  CLRF   FEC
0503E:  CLRF   FEC
05040:  CLRF   FEC
....................     set_nanoDAC_outputs(ch);
05042:  MOVFF  716,722
05046:  MOVLB  0
05048:  CALL   1850
....................     delay_ms(500);
0504C:  MOVLW  02
0504E:  MOVLB  7
05050:  MOVWF  x21
05052:  MOVLW  FA
05054:  MOVWF  x25
05056:  MOVLB  0
05058:  CALL   0436
0505C:  MOVLB  7
0505E:  DECFSZ x21,F
05060:  BRA    5052
....................     adcVals[ch].homeFlag = False;
05062:  MOVF   x16,W
05064:  MULLW  26
05066:  MOVF   FF3,W
05068:  CLRF   x22
0506A:  MOVWF  x21
0506C:  MOVLW  25
0506E:  ADDWF  x21,W
05070:  MOVWF  01
05072:  MOVLW  00
05074:  ADDWFC x22,W
05076:  MOVWF  03
05078:  MOVF   01,W
0507A:  ADDLW  17
0507C:  MOVWF  FE9
0507E:  MOVLW  01
05080:  ADDWFC 03,W
05082:  MOVWF  FEA
05084:  BCF    FEF.0
05086:  MOVLB  0
05088:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  control task sets up the outputs channels                                */ 
.................... /*****************************************************************************/
.................... void control_task(){
....................    static int state = 0;
....................    
....................    switch (state)
*
0562E:  MOVLB  1
05630:  MOVF   xEA,W
05632:  XORLW  00
05634:  MOVLB  0
05636:  BZ    563E
05638:  XORLW  01
0563A:  BZ    5652
0563C:  BRA    5664
....................    {
....................       case 0:
....................          set_nanoDAC_outputs(chX);
0563E:  MOVLB  7
05640:  CLRF   x22
05642:  MOVLB  0
05644:  CALL   1850
....................          state = 1;
05648:  MOVLW  01
0564A:  MOVLB  1
0564C:  MOVWF  xEA
....................       break;
0564E:  MOVLB  0
05650:  BRA    5664
....................       case 1:
....................          set_nanoDAC_outputs(chY);
05652:  MOVLW  01
05654:  MOVLB  7
05656:  MOVWF  x22
05658:  MOVLB  0
0565A:  CALL   1850
....................          state = 0;
0565E:  MOVLB  1
05660:  CLRF   xEA
....................       break;
05662:  MOVLB  0
....................    }
05664:  GOTO   B1EA (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  control task sets up the outputs channels                                */ 
.................... /*****************************************************************************/
.................... void control_init(){
....................    spi_xfer(SPI_ctrl, 0, 24);
*
00B2C:  MOVLB  7
00B2E:  CLRF   x28
00B30:  CLRF   x27
00B32:  CLRF   x26
00B34:  CLRF   x25
00B36:  MOVLB  0
00B38:  RCALL  0B02
....................    output_low(_SYNC_X);
00B3A:  MOVLW  E8
00B3C:  MOVWF  F8B
00B3E:  BCF    F86.2
....................    output_low(_SYNC_Y);
00B40:  MOVWF  F8B
00B42:  BCF    F86.1
....................    output_high(_SYNC_X);
00B44:  MOVWF  F8B
00B46:  BSF    F86.2
....................    output_high(_SYNC_Y);
00B48:  MOVWF  F8B
00B4A:  BSF    F86.1
00B4C:  GOTO   B19A (RETURN)
.................... }
.................... #endif
.................... 
.................... #include <serialport.h>
.................... #ifndef serialPort
.................... #define serialPort
.................... #include <cmdBuffer.h>
.................... #ifndef cmd_buffer
.................... #define cmd_buffer
.................... 
.................... /*****************************************************************************/
.................... /* DIFCS COMMAND BUFFER                                                      */
.................... /* The beginning of a message is signified by an address record. The address */
.................... /* is 4 characters. The first 2 are the hardware identifier (TC - temperature*/
.................... /* controller, DC - difics controller, etc..) The second 2 characters dev-   */
.................... /* ice ID... Valid values are 00 thru 0F. A device ID of FF writes to all    */
.................... /* boards. This might be used to feed angles data to all listeners.          */
.................... /*****************************************************************************/
.................... 
.................... // t,p0,p1,p2,p3,p4,p5,p6
.................... // t is the start character, p0 is the address, p1 is command, p2-6 are params
.................... // these characters used for storing messages
.................... 
.................... #define startChr '~' // start character. Also diagnostic command type
.................... #define diagCmdType startChr
.................... #define endChr '\n'
.................... #define delimiter ','
.................... #define ignoreChr1 '\r'
.................... #define ignoreChr2 ' '
.................... #define noRecordFound (char)0xFF
.................... 
.................... #define numRecords 4
.................... #define numParam 7
.................... #define lenParam 25
.................... 
.................... #define useSerial
.................... //#define useTCPIP
.................... 
.................... typedef enum cmdMode {tcp, ser};
.................... 
.................... // this structure holds a command. This is used by the serial routine as well
.................... // as the TCP routine to store an incoming command + parameters
.................... // in the case of TCP socket id is also passed in this structure
.................... typedef struct cmd 
.................... {
....................    BOOLEAN full;        // if full, command is ready to execute
....................    unsigned int8 chrIndex;
....................    unsigned int8 paramIndex;
....................    unsigned int8 recReadIndex;
....................    unsigned int8 recWriteIndex;
....................    #ifdef useTCPIP
....................    TCP_SOCKET s;              // socket ID for TCP commands 
....................    #endif
....................    char t;
....................    char p[numParam][lenParam];   // only used with ~ type command
.................... };
.................... 
.................... #ifdef useSerial
.................... struct cmd SERcmd[numRecords]; // holds serial command 
.................... unsigned int8 SRI = 0; //usb readindex
.................... unsigned int8 SWI = 0; //usb write index
.................... #endif
.................... 
.................... #ifdef useTCPIP
.................... struct cmd TCPcmd[numRecords]; // holds TCP command
.................... unsigned int8 TRI = 0; //usb readindex
.................... unsigned int8 TWI = 0; //usb write index
.................... #endif
.................... 
.................... char retData[100]; // this is used to hold return data 
.................... 
.................... #ifdef useSerial
.................... /*****************************************************************************/
.................... /* RESET SER COMMAND -- ready for a new command                              */
.................... /*****************************************************************************/
.................... void resetSERcmd(unsigned int8 recNum)
.................... {
....................    if (recNum < numRecords)
00B50:  MOVLB  7
00B52:  MOVF   x17,W
00B54:  SUBLW  03
00B56:  BTFSS  FD8.0
00B58:  BRA    0CC6
....................    {
....................       for (int i = 0; i <numParam; i ++)
00B5A:  CLRF   x18
00B5C:  MOVF   x18,W
00B5E:  SUBLW  06
00B60:  BNC   0BB0
....................       {
....................          SERcmd[recNum].p[i][0] = '\0';
00B62:  CLRF   x5D
00B64:  MOVFF  717,75C
00B68:  CLRF   x5F
00B6A:  MOVLW  B5
00B6C:  MOVWF  x5E
00B6E:  MOVLB  0
00B70:  RCALL  086E
00B72:  MOVFF  02,71A
00B76:  MOVFF  01,719
00B7A:  MOVLW  06
00B7C:  MOVLB  7
00B7E:  ADDWF  x19,F
00B80:  MOVLW  00
00B82:  ADDWFC x1A,F
00B84:  CLRF   x5D
00B86:  MOVFF  718,75C
00B8A:  CLRF   x5F
00B8C:  MOVLW  19
00B8E:  MOVWF  x5E
00B90:  MOVLB  0
00B92:  RCALL  086E
00B94:  MOVF   01,W
00B96:  MOVLB  7
00B98:  ADDWF  x19,F
00B9A:  MOVF   02,W
00B9C:  ADDWFC x1A,F
00B9E:  MOVLW  EB
00BA0:  ADDWF  x19,W
00BA2:  MOVWF  FE9
00BA4:  MOVLW  01
00BA6:  ADDWFC x1A,W
00BA8:  MOVWF  FEA
00BAA:  CLRF   FEF
00BAC:  INCF   x18,F
00BAE:  BRA    0B5C
....................       }
....................       SERcmd[recNum].t = 0;
00BB0:  CLRF   x5D
00BB2:  MOVFF  717,75C
00BB6:  CLRF   x5F
00BB8:  MOVLW  B5
00BBA:  MOVWF  x5E
00BBC:  MOVLB  0
00BBE:  RCALL  086E
00BC0:  MOVFF  01,719
00BC4:  MOVLW  05
00BC6:  MOVLB  7
00BC8:  ADDWF  01,W
00BCA:  MOVWF  01
00BCC:  MOVLW  00
00BCE:  ADDWFC 02,W
00BD0:  MOVWF  03
00BD2:  MOVF   01,W
00BD4:  ADDLW  EB
00BD6:  MOVWF  FE9
00BD8:  MOVLW  01
00BDA:  ADDWFC 03,W
00BDC:  MOVWF  FEA
00BDE:  CLRF   FEF
....................       SERcmd[recNum].chrIndex = 0;
00BE0:  CLRF   x5D
00BE2:  MOVFF  717,75C
00BE6:  CLRF   x5F
00BE8:  MOVLW  B5
00BEA:  MOVWF  x5E
00BEC:  MOVLB  0
00BEE:  RCALL  086E
00BF0:  MOVFF  01,719
00BF4:  MOVLW  01
00BF6:  MOVLB  7
00BF8:  ADDWF  01,W
00BFA:  MOVWF  01
00BFC:  MOVLW  00
00BFE:  ADDWFC 02,W
00C00:  MOVWF  03
00C02:  MOVF   01,W
00C04:  ADDLW  EB
00C06:  MOVWF  FE9
00C08:  MOVLW  01
00C0A:  ADDWFC 03,W
00C0C:  MOVWF  FEA
00C0E:  CLRF   FEF
....................       SERcmd[recNum].paramIndex = 0;
00C10:  CLRF   x5D
00C12:  MOVFF  717,75C
00C16:  CLRF   x5F
00C18:  MOVLW  B5
00C1A:  MOVWF  x5E
00C1C:  MOVLB  0
00C1E:  RCALL  086E
00C20:  MOVFF  01,719
00C24:  MOVLW  02
00C26:  MOVLB  7
00C28:  ADDWF  01,W
00C2A:  MOVWF  01
00C2C:  MOVLW  00
00C2E:  ADDWFC 02,W
00C30:  MOVWF  03
00C32:  MOVF   01,W
00C34:  ADDLW  EB
00C36:  MOVWF  FE9
00C38:  MOVLW  01
00C3A:  ADDWFC 03,W
00C3C:  MOVWF  FEA
00C3E:  CLRF   FEF
....................       SERcmd[recNum].recReadIndex = 0;
00C40:  CLRF   x5D
00C42:  MOVFF  717,75C
00C46:  CLRF   x5F
00C48:  MOVLW  B5
00C4A:  MOVWF  x5E
00C4C:  MOVLB  0
00C4E:  RCALL  086E
00C50:  MOVFF  01,719
00C54:  MOVLW  03
00C56:  MOVLB  7
00C58:  ADDWF  01,W
00C5A:  MOVWF  01
00C5C:  MOVLW  00
00C5E:  ADDWFC 02,W
00C60:  MOVWF  03
00C62:  MOVF   01,W
00C64:  ADDLW  EB
00C66:  MOVWF  FE9
00C68:  MOVLW  01
00C6A:  ADDWFC 03,W
00C6C:  MOVWF  FEA
00C6E:  CLRF   FEF
....................       SERcmd[recNum].recWriteIndex = 0;
00C70:  CLRF   x5D
00C72:  MOVFF  717,75C
00C76:  CLRF   x5F
00C78:  MOVLW  B5
00C7A:  MOVWF  x5E
00C7C:  MOVLB  0
00C7E:  RCALL  086E
00C80:  MOVFF  01,719
00C84:  MOVLW  04
00C86:  MOVLB  7
00C88:  ADDWF  01,W
00C8A:  MOVWF  01
00C8C:  MOVLW  00
00C8E:  ADDWFC 02,W
00C90:  MOVWF  03
00C92:  MOVF   01,W
00C94:  ADDLW  EB
00C96:  MOVWF  FE9
00C98:  MOVLW  01
00C9A:  ADDWFC 03,W
00C9C:  MOVWF  FEA
00C9E:  CLRF   FEF
....................       SERcmd[recNum].full = FALSE;
00CA0:  CLRF   x5D
00CA2:  MOVFF  717,75C
00CA6:  CLRF   x5F
00CA8:  MOVLW  B5
00CAA:  MOVWF  x5E
00CAC:  MOVLB  0
00CAE:  RCALL  086E
00CB0:  MOVLW  EB
00CB2:  MOVLB  7
00CB4:  ADDWF  01,W
00CB6:  MOVWF  FE9
00CB8:  MOVLW  01
00CBA:  ADDWFC 02,W
00CBC:  MOVWF  FEA
00CBE:  BCF    FEF.0
....................       retData[0] = '\0';
00CC0:  MOVLB  4
00CC2:  CLRF   xC1
00CC4:  MOVLB  7
....................    }
00CC6:  MOVLB  0
00CC8:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next serial read index (SRI)                                          */
.................... /*****************************************************************************/
.................... BOOLEAN getNextSERReadIndex()
.................... {
....................    while (!SERcmd[SRI].full)
*
05C24:  MOVLB  7
05C26:  CLRF   x5D
05C28:  MOVFF  4BF,75C
05C2C:  CLRF   x5F
05C2E:  MOVLW  B5
05C30:  MOVWF  x5E
05C32:  MOVLB  0
05C34:  CALL   086E
05C38:  MOVFF  02,718
05C3C:  MOVFF  01,717
05C40:  MOVLW  EB
05C42:  MOVLB  7
05C44:  ADDWF  01,W
05C46:  MOVWF  FE9
05C48:  MOVLW  01
05C4A:  ADDWFC 02,W
05C4C:  MOVWF  FEA
05C4E:  BTFSC  FEF.0
05C50:  BRA    5C72
....................    {
....................       if (SRI == SWI) return FALSE;
05C52:  MOVLB  4
05C54:  MOVF   xC0,W
05C56:  SUBWF  xBF,W
05C58:  BNZ   5C60
05C5A:  MOVLW  00
05C5C:  MOVWF  01
05C5E:  BRA    5C78
....................       SRI +=1;
05C60:  MOVLW  01
05C62:  ADDWF  xBF,F
....................       if (SRI >= numRecords) SRI=0;
05C64:  MOVF   xBF,W
05C66:  SUBLW  03
05C68:  BC    5C6C
05C6A:  CLRF   xBF
05C6C:  MOVLB  0
05C6E:  BRA    5C24
05C70:  MOVLB  7
....................    }
....................    return TRUE;
05C72:  MOVLW  01
05C74:  MOVWF  01
05C76:  MOVLB  4
05C78:  MOVLB  0
05C7A:  GOTO   AC34 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next serial write index (SWI)                                         */
.................... /*****************************************************************************/
.................... void setNextSERWriteIndex()
.................... {
....................    SWI +=1;
*
056A0:  MOVLW  01
056A2:  MOVLB  4
056A4:  ADDWF  xC0,F
....................    if (SWI >= numRecords) SWI=0;
056A6:  MOVF   xC0,W
056A8:  SUBLW  03
056AA:  BC    56AE
056AC:  CLRF   xC0
056AE:  MOVLB  0
056B0:  RETURN 0
.................... }
.................... #endif
.................... 
.................... #ifdef useTCPIP
.................... /*****************************************************************************/
.................... /* RESET TCP COMMAND -- ready for a new command                              */
.................... /*****************************************************************************/
.................... void resetTCPcmd(unsigned int8 recNum)
.................... {
....................    if(recNum < numRecords)
....................    {
....................       for (int i = 0; i <numParam; i ++)
....................       {
....................          TCPcmd[recNum].p[i][0] = '\0';
....................       }
....................       TCPcmd[recNum].t = 0;
....................       TCPcmd[recNum].chrIndex = 0;
....................       TCPcmd[recNum].paramIndex = 0;
....................       TCPcmd[recNum].full = FALSE;
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next TCP read index (TRI)                                             */
.................... /*****************************************************************************/
.................... BOOLEAN getNextTCPReadIndex()
.................... {
....................    while (!TCPcmd[TRI].full)
....................    {
....................       if (TRI == TWI) return FALSE;
....................       TRI +=1;
....................       if (TRI >= numRecords) TRI=0;
....................    }
....................    return TRUE;
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next TCP write index (TWI)                                            */
.................... /*****************************************************************************/
.................... void setNextTCPWriteIndex()
.................... {
....................    TWI +=1;
....................    if (TWI >= numRecords) TWI=0;
.................... }
.................... #endif
.................... #endif
.................... 
.................... 
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B7,PIN_B6,PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
....................    output_b(portB_reset);
....................    output_c(portC_reset);
....................    output_d(portD_reset);
....................    output_e(portE_reset);
....................    
....................    port_a_pullups(portA_pullups);
....................    port_b_pullups(portB_pullups);
....................    port_c_pullups(portC_pullups);
....................    port_d_pullups(portD_pullups);
....................    port_e_pullups(portE_pullups);
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... #define use_RS485 // adds RX enable pin//
.................... 
.................... #define oneByteCmdTestValue 128
.................... #define UART_BUFFER_SIZE 60
.................... #define UART_EOT_CHAR1 0x0D //Carriage Return
.................... #define UART_EOT_CHAR2 0x0A //Line Feed
.................... #define UART_SOT_CHAR  '~' // START CHARACTER
.................... #define line_turnaround_char 0xFF
.................... 
.................... #bit UART_TXBuffer_Empty = 0x0FAC.1
.................... 
.................... char UART_BUFFER[UART_BUFFER_SIZE] = {0};
.................... unsigned int8 UART_WR_PTR = 0;
.................... unsigned int8 UART_RD_PTR = 0;
.................... boolean BYTES_AVAILABLE= FALSE;
.................... 
.................... #ifdef DEBUG_1
.................... #use rs232(ICD, DISABLE_INTS, stream=ICD_STREAM)
.................... #endif
.................... 
.................... #ifdef use_RS485
.................... #use rs232(baud=baudRate, UART1, stream=SERIAL, ERRORS)
*
000CA:  MOVLB  E
000CC:  BTFSS  xC8.5
000CE:  BRA    00CC
000D0:  MOVFF  F9C,563
000D4:  MOVLB  5
000D6:  MOVFF  F98,01
000DA:  BTFSS  x63.1
000DC:  BRA    00E2
000DE:  BCF    F9C.4
000E0:  BSF    F9C.4
000E2:  MOVLB  0
000E4:  GOTO   010C (RETURN)
.................... //!#use rs232(baud=baudRate, xmit=TX_PIN, rcv=RX_PIN, stream=SERIAL, ERRORS)
.................... #else
.................... #use rs232(baud=baudRate, xmit=TX_PIN, rcv=RX_PIN, stream=SERIAL)
.................... #endif
.................... 
.................... // Message format: [SOT]addr ,cmd, arg1, arg2, arg3[EOT]} 
.................... // arguments are optional
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* SERIAL PRINTOUT                                                           */
.................... /*****************************************************************************/
.................... void serial_out(char* printBuffer){
....................     output_high(TX_ENABLE);
*
056DE:  MOVLW  93
056E0:  MOVWF  F89
056E2:  BSF    F84.5
....................     delay_us(200);
056E4:  MOVLW  C8
056E6:  MOVLB  7
056E8:  MOVWF  x22
056EA:  MOVLB  0
056EC:  CALL   06FC
....................     
....................     fprintf(SERIAL, "%s\n", printBuffer);
056F0:  MOVFF  718,FEA
056F4:  MOVFF  717,FE9
056F8:  BRA    56B2
056FA:  MOVLW  0A
056FC:  MOVLB  E
056FE:  BTFSS  xC8.4
05700:  BRA    56FE
05702:  MOVWF  F99
....................     delay_us(200);
05704:  MOVLW  C8
05706:  MOVLB  7
05708:  MOVWF  x22
0570A:  MOVLB  0
0570C:  CALL   06FC
....................     
....................     output_low(TX_ENABLE);
05710:  MOVLW  93
05712:  MOVWF  F89
05714:  BCF    F84.5
05716:  RETURN 0
.................... }
.................... 
.................... //!void icd_out(char* printBuffer){
.................... //!    fprintf(ICD_STREAM, "%s\n", printBuffer);
.................... //!}
.................... 
.................... /*****************************************************************************/
.................... /* SERIAL PORT ISR                                                           */
.................... /*****************************************************************************/
.................... #INT_RDA
.................... void RX_isr() {           
*
000E8:  MOVLB  0
....................     while (kbhit(SERIAL)) {
000EA:  MOVLB  E
000EC:  BTFSS  xC8.5
000EE:  BRA    0130
....................         UART_BUFFER[UART_WR_PTR]=fgetc(SERIAL);
000F0:  CLRF   03
000F2:  MOVLB  5
000F4:  MOVF   x61,W
000F6:  ADDLW  25
000F8:  MOVWF  FE9
000FA:  MOVLW  05
000FC:  ADDWFC 03,W
000FE:  MOVWF  FEA
00100:  MOVFF  FEA,788
00104:  MOVFF  FE9,787
00108:  MOVLB  0
0010A:  BRA    00CA
0010C:  MOVFF  788,FEA
00110:  MOVFF  787,FE9
00114:  MOVFF  01,FEF
....................         UART_WR_PTR +=1;
00118:  MOVLW  01
0011A:  MOVLB  5
0011C:  ADDWF  x61,F
....................         if (UART_WR_PTR>=UART_BUFFER_SIZE) UART_WR_PTR=0;
0011E:  MOVF   x61,W
00120:  SUBLW  3B
00122:  BC    0126
00124:  CLRF   x61
....................         BYTES_AVAILABLE=TRUE;
00126:  MOVLB  1
00128:  BSF    x63.1
0012A:  MOVLB  0
0012C:  BRA    00EA
0012E:  MOVLB  E
....................     }
00130:  BCF    xC8.5
00132:  MOVLB  0
00134:  GOTO   006E
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get character from buffer                                                 */
.................... /*****************************************************************************/
.................... char getchFromBuffer()
*
05668:  CLRF   03
0566A:  MOVLB  5
0566C:  MOVF   x62,W
0566E:  ADDLW  25
05670:  MOVWF  FE9
05672:  MOVLW  05
05674:  ADDWFC 03,W
05676:  MOVWF  FEA
05678:  MOVFF  FEF,717
.................... {
....................    char data = UART_BUFFER[UART_RD_PTR];
....................    UART_RD_PTR +=1;
0567C:  MOVLW  01
0567E:  ADDWF  x62,F
....................    if (UART_RD_PTR>=UART_BUFFER_SIZE) UART_RD_PTR=0;
05680:  MOVF   x62,W
05682:  SUBLW  3B
05684:  BC    5688
05686:  CLRF   x62
....................    if (UART_RD_PTR == UART_WR_PTR) BYTES_AVAILABLE=FALSE;
05688:  MOVF   x61,W
0568A:  SUBWF  x62,W
0568C:  BNZ   5694
0568E:  MOVLB  1
05690:  BCF    x63.1
05692:  MOVLB  5
....................    return data;
05694:  MOVLB  7
05696:  MOVFF  717,01
0569A:  MOVLB  0
0569C:  GOTO   5760 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Serial Task transfers bytes to command buffer                             */
.................... /*****************************************************************************/
.................... void serial_task()
.................... {
....................    while(BYTES_AVAILABLE && SERcmd[SWI].full==FALSE)
*
05718:  MOVLB  1
0571A:  BTFSS  x63.1
0571C:  BRA    5C18
0571E:  MOVLB  7
05720:  CLRF   x5D
05722:  MOVFF  4C0,75C
05726:  CLRF   x5F
05728:  MOVLW  B5
0572A:  MOVWF  x5E
0572C:  MOVLB  0
0572E:  CALL   086E
05732:  MOVFF  02,718
05736:  MOVFF  01,717
0573A:  MOVLW  EB
0573C:  MOVLB  7
0573E:  ADDWF  01,W
05740:  MOVWF  01
05742:  MOVLW  01
05744:  ADDWFC 02,W
05746:  MOVWF  03
05748:  MOVFF  01,FE9
0574C:  MOVWF  FEA
0574E:  BTFSS  FEF.0
05750:  BRA    5756
05752:  MOVLB  1
05754:  BRA    5C18
....................    {  
....................       output_high(TX_ENABLE);
05756:  MOVLW  93
05758:  MOVWF  F89
0575A:  BSF    F84.5
....................       unsigned int8 rxChar = getchFromBuffer();
0575C:  MOVLB  0
0575E:  BRA    5668
05760:  MOVFF  01,716
....................       if (rxChar == ignoreChr1 || rxChar == ignoreChr2)
05764:  MOVLB  7
05766:  MOVF   x16,W
05768:  SUBLW  0D
0576A:  BZ    5772
0576C:  MOVF   x16,W
0576E:  SUBLW  20
05770:  BNZ   5774
....................       {
....................       }
05772:  BRA    5C12
....................       else if (rxChar == UART_SOT_CHAR)
05774:  MOVF   x16,W
05776:  SUBLW  7E
05778:  BNZ   57BC
....................       {
....................          resetSERcmd(SWI);
0577A:  MOVFF  4C0,717
0577E:  MOVLB  0
05780:  CALL   0B50
....................          SERcmd[SWI].t = rxChar;
05784:  MOVLB  7
05786:  CLRF   x5D
05788:  MOVFF  4C0,75C
0578C:  CLRF   x5F
0578E:  MOVLW  B5
05790:  MOVWF  x5E
05792:  MOVLB  0
05794:  CALL   086E
05798:  MOVFF  01,717
0579C:  MOVLW  05
0579E:  MOVLB  7
057A0:  ADDWF  01,W
057A2:  MOVWF  01
057A4:  MOVLW  00
057A6:  ADDWFC 02,W
057A8:  MOVWF  03
057AA:  MOVF   01,W
057AC:  ADDLW  EB
057AE:  MOVWF  FE9
057B0:  MOVLW  01
057B2:  ADDWFC 03,W
057B4:  MOVWF  FEA
057B6:  MOVFF  716,FEF
....................       }
057BA:  BRA    5C12
....................       else if (rxChar >= oneByteCmdTestValue)
057BC:  MOVF   x16,W
057BE:  SUBLW  7F
057C0:  BC    582C
....................       {
....................          resetSERcmd(SWI);
057C2:  MOVFF  4C0,717
057C6:  MOVLB  0
057C8:  CALL   0B50
....................          SERcmd[SWI].t = rxChar;
057CC:  MOVLB  7
057CE:  CLRF   x5D
057D0:  MOVFF  4C0,75C
057D4:  CLRF   x5F
057D6:  MOVLW  B5
057D8:  MOVWF  x5E
057DA:  MOVLB  0
057DC:  CALL   086E
057E0:  MOVFF  01,717
057E4:  MOVLW  05
057E6:  MOVLB  7
057E8:  ADDWF  01,W
057EA:  MOVWF  01
057EC:  MOVLW  00
057EE:  ADDWFC 02,W
057F0:  MOVWF  03
057F2:  MOVF   01,W
057F4:  ADDLW  EB
057F6:  MOVWF  FE9
057F8:  MOVLW  01
057FA:  ADDWFC 03,W
057FC:  MOVWF  FEA
057FE:  MOVFF  716,FEF
....................          SERcmd[SWI].full = TRUE;
05802:  CLRF   x5D
05804:  MOVFF  4C0,75C
05808:  CLRF   x5F
0580A:  MOVLW  B5
0580C:  MOVWF  x5E
0580E:  MOVLB  0
05810:  CALL   086E
05814:  MOVLW  EB
05816:  MOVLB  7
05818:  ADDWF  01,W
0581A:  MOVWF  FE9
0581C:  MOVLW  01
0581E:  ADDWFC 02,W
05820:  MOVWF  FEA
05822:  BSF    FEF.0
....................          setNextSERWriteIndex();
05824:  MOVLB  0
05826:  RCALL  56A0
....................       }
05828:  BRA    5C10
0582A:  MOVLB  7
....................       else if (rxChar == UART_EOT_CHAR2)
0582C:  MOVF   x16,W
0582E:  SUBLW  0A
05830:  BTFSS  FD8.2
05832:  BRA    5938
....................       {
....................          SERcmd[SWI].full = TRUE;
05834:  CLRF   x5D
05836:  MOVFF  4C0,75C
0583A:  CLRF   x5F
0583C:  MOVLW  B5
0583E:  MOVWF  x5E
05840:  MOVLB  0
05842:  CALL   086E
05846:  MOVLW  EB
05848:  MOVLB  7
0584A:  ADDWF  01,W
0584C:  MOVWF  FE9
0584E:  MOVLW  01
05850:  ADDWFC 02,W
05852:  MOVWF  FEA
05854:  BSF    FEF.0
....................          SERcmd[SWI].recWriteIndex = SERcmd[SWI].paramIndex;
05856:  CLRF   x5D
05858:  MOVFF  4C0,75C
0585C:  CLRF   x5F
0585E:  MOVLW  B5
05860:  MOVWF  x5E
05862:  MOVLB  0
05864:  CALL   086E
05868:  MOVFF  01,717
0586C:  MOVLW  04
0586E:  MOVLB  7
05870:  ADDWF  01,W
05872:  MOVWF  01
05874:  MOVLW  00
05876:  ADDWFC 02,W
05878:  MOVWF  03
0587A:  MOVF   01,W
0587C:  ADDLW  EB
0587E:  MOVWF  01
05880:  MOVLW  01
05882:  ADDWFC 03,F
05884:  MOVFF  01,717
05888:  MOVFF  03,718
0588C:  CLRF   x5D
0588E:  MOVFF  4C0,75C
05892:  CLRF   x5F
05894:  MOVLW  B5
05896:  MOVWF  x5E
05898:  MOVLB  0
0589A:  CALL   086E
0589E:  MOVFF  01,719
058A2:  MOVLW  02
058A4:  MOVLB  7
058A6:  ADDWF  01,W
058A8:  MOVWF  01
058AA:  MOVLW  00
058AC:  ADDWFC 02,W
058AE:  MOVWF  03
058B0:  MOVF   01,W
058B2:  ADDLW  EB
058B4:  MOVWF  FE9
058B6:  MOVLW  01
058B8:  ADDWFC 03,W
058BA:  MOVWF  FEA
058BC:  MOVFF  FEF,719
058C0:  MOVFF  718,FEA
058C4:  MOVFF  717,FE9
058C8:  MOVFF  719,FEF
....................          SERcmd[SWI].chrIndex = 0;
058CC:  CLRF   x5D
058CE:  MOVFF  4C0,75C
058D2:  CLRF   x5F
058D4:  MOVLW  B5
058D6:  MOVWF  x5E
058D8:  MOVLB  0
058DA:  CALL   086E
058DE:  MOVFF  01,717
058E2:  MOVLW  01
058E4:  MOVLB  7
058E6:  ADDWF  01,W
058E8:  MOVWF  01
058EA:  MOVLW  00
058EC:  ADDWFC 02,W
058EE:  MOVWF  03
058F0:  MOVF   01,W
058F2:  ADDLW  EB
058F4:  MOVWF  FE9
058F6:  MOVLW  01
058F8:  ADDWFC 03,W
058FA:  MOVWF  FEA
058FC:  CLRF   FEF
....................          SERcmd[SWI].paramIndex = 0;
058FE:  CLRF   x5D
05900:  MOVFF  4C0,75C
05904:  CLRF   x5F
05906:  MOVLW  B5
05908:  MOVWF  x5E
0590A:  MOVLB  0
0590C:  CALL   086E
05910:  MOVFF  01,717
05914:  MOVLW  02
05916:  MOVLB  7
05918:  ADDWF  01,W
0591A:  MOVWF  01
0591C:  MOVLW  00
0591E:  ADDWFC 02,W
05920:  MOVWF  03
05922:  MOVF   01,W
05924:  ADDLW  EB
05926:  MOVWF  FE9
05928:  MOVLW  01
0592A:  ADDWFC 03,W
0592C:  MOVWF  FEA
0592E:  CLRF   FEF
....................          setNextSERWriteIndex();
05930:  MOVLB  0
05932:  RCALL  56A0
....................       }
05934:  BRA    5C10
05936:  MOVLB  7
....................       else if (rxChar == delimiter)
05938:  MOVF   x16,W
0593A:  SUBLW  2C
0593C:  BNZ   59FE
....................       {
....................          if (SERcmd[SWI].paramIndex < numParam-1)
0593E:  CLRF   x5D
05940:  MOVFF  4C0,75C
05944:  CLRF   x5F
05946:  MOVLW  B5
05948:  MOVWF  x5E
0594A:  MOVLB  0
0594C:  CALL   086E
05950:  MOVFF  02,718
05954:  MOVFF  01,717
05958:  MOVLW  02
0595A:  MOVLB  7
0595C:  ADDWF  01,W
0595E:  MOVWF  01
05960:  MOVLW  00
05962:  ADDWFC 02,W
05964:  MOVWF  03
05966:  MOVF   01,W
05968:  ADDLW  EB
0596A:  MOVWF  FE9
0596C:  MOVLW  01
0596E:  ADDWFC 03,W
05970:  MOVWF  FEA
05972:  MOVF   FEF,W
05974:  SUBLW  05
05976:  BNC   59E2
....................          {
....................             SERcmd[SWI].paramIndex +=1;
05978:  CLRF   x5D
0597A:  MOVFF  4C0,75C
0597E:  CLRF   x5F
05980:  MOVLW  B5
05982:  MOVWF  x5E
05984:  MOVLB  0
05986:  CALL   086E
0598A:  MOVFF  01,717
0598E:  MOVLW  02
05990:  MOVLB  7
05992:  ADDWF  01,W
05994:  MOVWF  01
05996:  MOVLW  00
05998:  ADDWFC 02,W
0599A:  MOVWF  03
0599C:  MOVF   01,W
0599E:  ADDLW  EB
059A0:  MOVWF  FE9
059A2:  MOVLW  01
059A4:  ADDWFC 03,W
059A6:  MOVWF  FEA
059A8:  MOVLW  01
059AA:  ADDWF  FEF,W
059AC:  MOVWF  FEF
....................             SERcmd[SWI].chrIndex = 0;
059AE:  CLRF   x5D
059B0:  MOVFF  4C0,75C
059B4:  CLRF   x5F
059B6:  MOVLW  B5
059B8:  MOVWF  x5E
059BA:  MOVLB  0
059BC:  CALL   086E
059C0:  MOVFF  01,717
059C4:  MOVLW  01
059C6:  MOVLB  7
059C8:  ADDWF  01,W
059CA:  MOVWF  01
059CC:  MOVLW  00
059CE:  ADDWFC 02,W
059D0:  MOVWF  03
059D2:  MOVF   01,W
059D4:  ADDLW  EB
059D6:  MOVWF  FE9
059D8:  MOVLW  01
059DA:  ADDWFC 03,W
059DC:  MOVWF  FEA
059DE:  CLRF   FEF
....................          }
059E0:  BRA    59FC
....................          else
....................          {
....................             resetSERcmd(SWI); // exceed number of params... reset capture
059E2:  MOVFF  4C0,717
059E6:  MOVLB  0
059E8:  CALL   0B50
....................             serial_out(retData);
059EC:  MOVLW  04
059EE:  MOVLB  7
059F0:  MOVWF  x18
059F2:  MOVLW  C1
059F4:  MOVWF  x17
059F6:  MOVLB  0
059F8:  RCALL  56DE
059FA:  MOVLB  7
....................          }
....................       }
059FC:  BRA    5C12
....................       
....................       else
....................       {
....................          if (SERcmd[SWI].chrIndex < lenParam)
059FE:  CLRF   x5D
05A00:  MOVFF  4C0,75C
05A04:  CLRF   x5F
05A06:  MOVLW  B5
05A08:  MOVWF  x5E
05A0A:  MOVLB  0
05A0C:  CALL   086E
05A10:  MOVFF  02,718
05A14:  MOVFF  01,717
05A18:  MOVLW  01
05A1A:  MOVLB  7
05A1C:  ADDWF  01,W
05A1E:  MOVWF  01
05A20:  MOVLW  00
05A22:  ADDWFC 02,W
05A24:  MOVWF  03
05A26:  MOVF   01,W
05A28:  ADDLW  EB
05A2A:  MOVWF  FE9
05A2C:  MOVLW  01
05A2E:  ADDWFC 03,W
05A30:  MOVWF  FEA
05A32:  MOVF   FEF,W
05A34:  SUBLW  18
05A36:  BTFSS  FD8.0
05A38:  BRA    5BF8
....................          {
....................             SERcmd[SWI].p[SERcmd[SWI].paramIndex][SERcmd[SWI].chrIndex] = rxChar;
05A3A:  CLRF   x5D
05A3C:  MOVFF  4C0,75C
05A40:  CLRF   x5F
05A42:  MOVLW  B5
05A44:  MOVWF  x5E
05A46:  MOVLB  0
05A48:  CALL   086E
05A4C:  MOVFF  02,718
05A50:  MOVFF  01,717
05A54:  MOVLW  06
05A56:  MOVLB  7
05A58:  ADDWF  x17,F
05A5A:  MOVLW  00
05A5C:  ADDWFC x18,F
05A5E:  CLRF   x5D
05A60:  MOVFF  4C0,75C
05A64:  CLRF   x5F
05A66:  MOVLW  B5
05A68:  MOVWF  x5E
05A6A:  MOVLB  0
05A6C:  CALL   086E
05A70:  MOVFF  02,71A
05A74:  MOVFF  01,719
05A78:  MOVLW  02
05A7A:  MOVLB  7
05A7C:  ADDWF  01,W
05A7E:  MOVWF  01
05A80:  MOVLW  00
05A82:  ADDWFC 02,W
05A84:  MOVWF  03
05A86:  MOVF   01,W
05A88:  ADDLW  EB
05A8A:  MOVWF  FE9
05A8C:  MOVLW  01
05A8E:  ADDWFC 03,W
05A90:  MOVWF  FEA
05A92:  CLRF   x5D
05A94:  MOVFF  FEF,75C
05A98:  CLRF   x5F
05A9A:  MOVLW  19
05A9C:  MOVWF  x5E
05A9E:  MOVLB  0
05AA0:  CALL   086E
05AA4:  MOVFF  02,03
05AA8:  MOVF   01,W
05AAA:  MOVLB  7
05AAC:  ADDWF  x17,F
05AAE:  MOVF   02,W
05AB0:  ADDWFC x18,F
05AB2:  CLRF   x5D
05AB4:  MOVFF  4C0,75C
05AB8:  CLRF   x5F
05ABA:  MOVLW  B5
05ABC:  MOVWF  x5E
05ABE:  MOVLB  0
05AC0:  CALL   086E
05AC4:  MOVFF  01,719
05AC8:  MOVLW  01
05ACA:  MOVLB  7
05ACC:  ADDWF  01,W
05ACE:  MOVWF  01
05AD0:  MOVLW  00
05AD2:  ADDWFC 02,W
05AD4:  MOVWF  03
05AD6:  MOVF   01,W
05AD8:  ADDLW  EB
05ADA:  MOVWF  FE9
05ADC:  MOVLW  01
05ADE:  ADDWFC 03,W
05AE0:  MOVWF  FEA
05AE2:  MOVF   FEF,W
05AE4:  ADDWF  x17,W
05AE6:  MOVWF  01
05AE8:  MOVLW  00
05AEA:  ADDWFC x18,W
05AEC:  MOVWF  03
05AEE:  MOVF   01,W
05AF0:  ADDLW  EB
05AF2:  MOVWF  FE9
05AF4:  MOVLW  01
05AF6:  ADDWFC 03,W
05AF8:  MOVWF  FEA
05AFA:  MOVFF  716,FEF
....................             SERcmd[SWI].chrIndex += 1;
05AFE:  CLRF   x5D
05B00:  MOVFF  4C0,75C
05B04:  CLRF   x5F
05B06:  MOVLW  B5
05B08:  MOVWF  x5E
05B0A:  MOVLB  0
05B0C:  CALL   086E
05B10:  MOVFF  01,717
05B14:  MOVLW  01
05B16:  MOVLB  7
05B18:  ADDWF  01,W
05B1A:  MOVWF  01
05B1C:  MOVLW  00
05B1E:  ADDWFC 02,W
05B20:  MOVWF  03
05B22:  MOVF   01,W
05B24:  ADDLW  EB
05B26:  MOVWF  FE9
05B28:  MOVLW  01
05B2A:  ADDWFC 03,W
05B2C:  MOVWF  FEA
05B2E:  MOVLW  01
05B30:  ADDWF  FEF,W
05B32:  MOVWF  FEF
....................             SERcmd[SWI].p[SERcmd[SWI].paramIndex][SERcmd[SWI].chrIndex] = '\0';
05B34:  CLRF   x5D
05B36:  MOVFF  4C0,75C
05B3A:  CLRF   x5F
05B3C:  MOVLW  B5
05B3E:  MOVWF  x5E
05B40:  MOVLB  0
05B42:  CALL   086E
05B46:  MOVFF  02,718
05B4A:  MOVFF  01,717
05B4E:  MOVLW  06
05B50:  MOVLB  7
05B52:  ADDWF  x17,F
05B54:  MOVLW  00
05B56:  ADDWFC x18,F
05B58:  CLRF   x5D
05B5A:  MOVFF  4C0,75C
05B5E:  CLRF   x5F
05B60:  MOVLW  B5
05B62:  MOVWF  x5E
05B64:  MOVLB  0
05B66:  CALL   086E
05B6A:  MOVFF  02,71A
05B6E:  MOVFF  01,719
05B72:  MOVLW  02
05B74:  MOVLB  7
05B76:  ADDWF  01,W
05B78:  MOVWF  01
05B7A:  MOVLW  00
05B7C:  ADDWFC 02,W
05B7E:  MOVWF  03
05B80:  MOVF   01,W
05B82:  ADDLW  EB
05B84:  MOVWF  FE9
05B86:  MOVLW  01
05B88:  ADDWFC 03,W
05B8A:  MOVWF  FEA
05B8C:  CLRF   x5D
05B8E:  MOVFF  FEF,75C
05B92:  CLRF   x5F
05B94:  MOVLW  19
05B96:  MOVWF  x5E
05B98:  MOVLB  0
05B9A:  CALL   086E
05B9E:  MOVFF  02,03
05BA2:  MOVF   01,W
05BA4:  MOVLB  7
05BA6:  ADDWF  x17,F
05BA8:  MOVF   02,W
05BAA:  ADDWFC x18,F
05BAC:  CLRF   x5D
05BAE:  MOVFF  4C0,75C
05BB2:  CLRF   x5F
05BB4:  MOVLW  B5
05BB6:  MOVWF  x5E
05BB8:  MOVLB  0
05BBA:  CALL   086E
05BBE:  MOVFF  01,719
05BC2:  MOVLW  01
05BC4:  MOVLB  7
05BC6:  ADDWF  01,W
05BC8:  MOVWF  01
05BCA:  MOVLW  00
05BCC:  ADDWFC 02,W
05BCE:  MOVWF  03
05BD0:  MOVF   01,W
05BD2:  ADDLW  EB
05BD4:  MOVWF  FE9
05BD6:  MOVLW  01
05BD8:  ADDWFC 03,W
05BDA:  MOVWF  FEA
05BDC:  MOVF   FEF,W
05BDE:  ADDWF  x17,W
05BE0:  MOVWF  01
05BE2:  MOVLW  00
05BE4:  ADDWFC x18,W
05BE6:  MOVWF  03
05BE8:  MOVF   01,W
05BEA:  ADDLW  EB
05BEC:  MOVWF  FE9
05BEE:  MOVLW  01
05BF0:  ADDWFC 03,W
05BF2:  MOVWF  FEA
05BF4:  CLRF   FEF
....................          }
05BF6:  BRA    5C12
....................          else
....................          {
....................             resetSERcmd(SWI); // exceed number of characters... reset capture
05BF8:  MOVFF  4C0,717
05BFC:  MOVLB  0
05BFE:  CALL   0B50
....................             serial_out(retData);
05C02:  MOVLW  04
05C04:  MOVLB  7
05C06:  MOVWF  x18
05C08:  MOVLW  C1
05C0A:  MOVWF  x17
05C0C:  MOVLB  0
05C0E:  RCALL  56DE
05C10:  MOVLB  7
....................          }
....................       }
05C12:  MOVLB  0
05C14:  BRA    5718
05C16:  MOVLB  1
....................    }
....................    output_low(TX_ENABLE);
05C18:  MOVLW  93
05C1A:  MOVWF  F89
05C1C:  BCF    F84.5
05C1E:  MOVLB  0
05C20:  GOTO   B1FE (RETURN)
.................... }
....................            
.................... /*****************************************************************************/
.................... /* serialInit ROUTINE  - Sets up serial port                                 */
.................... /*****************************************************************************/ 
.................... void serial_init()
.................... {
....................    for (int i = 0; i < numRecords; i++) 
*
00CCA:  MOVLB  7
00CCC:  CLRF   x16
00CCE:  MOVF   x16,W
00CD0:  SUBLW  03
00CD2:  BNC   0CE2
....................    {
....................       resetSERcmd(i);
00CD4:  MOVFF  716,717
00CD8:  MOVLB  0
00CDA:  RCALL  0B50
00CDC:  MOVLB  7
00CDE:  INCF   x16,F
00CE0:  BRA    0CCE
....................    }
....................    enable_interrupts(INT_RDA);
00CE2:  MOVLB  E
00CE4:  BSF    xC0.5
00CE6:  MOVLB  0
00CE8:  GOTO   B19E (RETURN)
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #include <pid.h>
.................... #ifndef pidcontroller
.................... #define pidcontroller
.................... #include <parameters.h>
.................... #include <math.h>
.................... 
.................... /*****************************************************************************/
.................... /* UPDATE the Control Variable (CV)                                          */
.................... /*****************************************************************************/
.................... void pid_update (channelMap ch){
....................    float err = PID[ch].SP - PID[ch].PV;  // error = set value - measured
....................    
....................    PID[ch].I += err*PID[ch].kI;
....................    if (PID[ch].I > op_upper_bound) PID[ch].I = op_upper_bound; // anti-windup
....................    else if (PID[ch].I < op_lower_bound) PID[ch].I = op_lower_bound;
....................    
....................    float P = err * PID[ch].kP;  // proportional value
....................    
....................    float D = PID[ch].kD * (PID[ch].PV - PID[ch].PVold);  // derivative value
....................    
....................    PID[ch].CV = P + PID[ch].I + D;  // new control variable
....................    if (PID[ch].CV > op_upper_bound) PID[ch].CV = op_upper_bound; // limit positive output
....................    else if (PID[ch].CV < op_lower_bound) PID[ch].CV = op_lower_bound; // limit negative output
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PID Task - looks for change to PV and updates CV                          */
.................... /*****************************************************************************/
.................... void pid_task(channelMap ch){
....................    static int index = 0;
....................    if (PID[ch].SP != PID[ch].PV) pid_update(ch);
....................    if ((index++) >= numChannels) index = 0;
.................... }
.................... 
.................... #endif
.................... 
.................... #include <eventTimer.h>
.................... #ifndef timeout
.................... #define timeout
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................     float kP;      // proportional gain
....................     float kI;      // integral gain
....................     float kD;      // derivative gain
....................     float SP;      // set point-- desired output
....................     float PV;      // process variable-- measured output
....................     float PVold;   // oldPV value  
....................     float CV;      // control variable-- output -- 0 to 100%
....................     float I;       // integral value
....................     float maxSP;   // Max setpoint in microns
....................     float minSP;   // Min setpoint in microns
.................... }PID[2] = {
....................    //  P     I     D
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}, 
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}
....................     };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... // @FLAG
.................... #define op_upper_bound 63  // CRYO
.................... #define op_lower_bound -63 // CRYO
.................... 
.................... //!#define op_upper_bound 63  // AMBIENT 
.................... //!#define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {-0.2701,-0.97313,0,0,0,0},  // @FLAG: Switched Channels
....................                     {-0.3964,-0.96557,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    BOOLEAN homeFlag;       // Flag to trigger the homing routine
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,-1,0,0,FALSE},  // @FLAG: Y-Axis passes -pole during cooldown
....................    {0,0,0,0,0,0,0, 0,0,0,FALSE}
.................... };
.................... 
.................... BOOLEAN adcFilter = TRUE;
.................... 
.................... struct dacV
.................... {
....................     BOOLEAN invV;
....................     unsigned int16 ipVal;
....................     float opPcnt;
....................    
.................... }dacVals[2] = 
.................... {
....................     {FALSE,0,0},
....................     {FALSE,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/           
.................... /* Global timers used by all routnes                                         */
.................... /* timeoutReg0-2 are used for timeouts. Other routines monitor the value of  */
.................... /* intTimeoutReg. On boot, they will be loaded from EEProm. Any              */
.................... /* configuration changes will be changed in EEprom, hence will be restored on*/
.................... /* subsequent boot.                                                          */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* Register definitions                                                      */
.................... /*****************************************************************************/
.................... //!unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... //!unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... //!unsigned int32 timeoutReg2 = 0;
.................... //!unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... unsigned int32 timeCounter = 0;
.................... 
.................... /*****************************************************************************/
.................... /* TIMEOUT_INIT initializes the timer                                        */
.................... /*****************************************************************************/
.................... void event_timer_init()
.................... {        
....................    disable_interrupts(INT_TIMER1);
00CEC:  MOVLB  E
00CEE:  BCF    xC1.0
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_1);
00CF0:  MOVLW  01
00CF2:  MOVWF  FD1
00CF4:  MOVLW  07
00CF6:  MOVWF  FCE
00CF8:  CLRF   FCF
00CFA:  CLRF   FD0
....................    timeoutReg0 = 0;  // clear all the timers
00CFC:  MOVLB  1
00CFE:  CLRF   x75
00D00:  CLRF   x74
00D02:  CLRF   x73
00D04:  CLRF   x72
....................    timeoutReg1 = 0;
00D06:  CLRF   x79
00D08:  CLRF   x78
00D0A:  CLRF   x77
00D0C:  CLRF   x76
....................    timeoutReg2 = 0;
00D0E:  CLRF   x7D
00D10:  CLRF   x7C
00D12:  CLRF   x7B
00D14:  CLRF   x7A
.................... //!   intTimeoutReg = 50;
....................    enable_interrupts(INT_TIMER1);
00D16:  MOVLB  E
00D18:  BSF    xC1.0
00D1A:  MOVLB  0
00D1C:  GOTO   B1A2 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* TIMEOUT INTERRUPT decrements the timeout registers every second           */
.................... /*****************************************************************************/
.................... #INT_TIMER1
.................... void TIMER1_isr(void) 
*
0025C:  MOVLB  0
.................... {
....................    set_timer1(0x0BDB); // load timer register to allow 10 millisecond interupts
0025E:  MOVLW  0B
00260:  MOVWF  FCD
00262:  MOVLW  DB
00264:  MOVWF  FCC
00266:  NOP   
....................    if (timeoutReg0 > 10) timeoutReg0 -= 10; else timeoutReg0 = 0;
00268:  MOVLB  1
0026A:  MOVF   x75,F
0026C:  BNZ   027C
0026E:  MOVF   x74,F
00270:  BNZ   027C
00272:  MOVF   x73,F
00274:  BNZ   027C
00276:  MOVF   x72,W
00278:  SUBLW  0A
0027A:  BC    028A
0027C:  MOVLW  0A
0027E:  SUBWF  x72,F
00280:  MOVLW  00
00282:  SUBWFB x73,F
00284:  SUBWFB x74,F
00286:  SUBWFB x75,F
00288:  BRA    0292
0028A:  CLRF   x75
0028C:  CLRF   x74
0028E:  CLRF   x73
00290:  CLRF   x72
....................    if (timeoutReg1 > 10) timeoutReg1 -= 10; else timeoutReg1 = 0;
00292:  MOVF   x79,F
00294:  BNZ   02A4
00296:  MOVF   x78,F
00298:  BNZ   02A4
0029A:  MOVF   x77,F
0029C:  BNZ   02A4
0029E:  MOVF   x76,W
002A0:  SUBLW  0A
002A2:  BC    02B2
002A4:  MOVLW  0A
002A6:  SUBWF  x76,F
002A8:  MOVLW  00
002AA:  SUBWFB x77,F
002AC:  SUBWFB x78,F
002AE:  SUBWFB x79,F
002B0:  BRA    02BA
002B2:  CLRF   x79
002B4:  CLRF   x78
002B6:  CLRF   x77
002B8:  CLRF   x76
....................    if (timeoutReg2 > 10) timeoutReg2 -= 10; else timeoutReg2 = 0;
002BA:  MOVF   x7D,F
002BC:  BNZ   02CC
002BE:  MOVF   x7C,F
002C0:  BNZ   02CC
002C2:  MOVF   x7B,F
002C4:  BNZ   02CC
002C6:  MOVF   x7A,W
002C8:  SUBLW  0A
002CA:  BC    02DA
002CC:  MOVLW  0A
002CE:  SUBWF  x7A,F
002D0:  MOVLW  00
002D2:  SUBWFB x7B,F
002D4:  SUBWFB x7C,F
002D6:  SUBWFB x7D,F
002D8:  BRA    02E2
002DA:  CLRF   x7D
002DC:  CLRF   x7C
002DE:  CLRF   x7B
002E0:  CLRF   x7A
....................    if (intTimeoutReg != 0) // INTERRUPTING TIMER
002E2:  MOVF   x7E,F
002E4:  BNZ   02EA
002E6:  MOVF   x7F,F
002E8:  BZ    0326
....................    {
....................       timeCounter+=10;
002EA:  MOVLW  0A
002EC:  MOVLB  5
002EE:  ADDWF  x66,F
002F0:  MOVLW  00
002F2:  ADDWFC x67,F
002F4:  ADDWFC x68,F
002F6:  ADDWFC x69,F
....................       if (timeCounter >= intTimeoutReg)
002F8:  MOVF   x69,F
002FA:  BNZ   0316
002FC:  MOVF   x68,F
002FE:  BNZ   0316
00300:  MOVLB  1
00302:  MOVF   x7F,W
00304:  MOVLB  5
00306:  SUBWF  x67,W
00308:  BNC   0324
0030A:  BNZ   0316
0030C:  MOVLB  1
0030E:  MOVF   x7E,W
00310:  MOVLB  5
00312:  SUBWF  x66,W
00314:  BNC   0324
....................       {
....................          sensor_monitor_interrupt_task();
00316:  MOVLB  0
00318:  BRA    01C0
....................          timeCounter = 0;
0031A:  MOVLB  5
0031C:  CLRF   x69
0031E:  CLRF   x68
00320:  CLRF   x67
00322:  CLRF   x66
00324:  MOVLB  1
....................       }
....................    }
.................... }
.................... 
.................... #endif
.................... 
.................... #include <commandHandler.c>
.................... #ifndef cmdHandlerC
.................... #define cmdHandlerC
.................... #include <commandHandler.h>
.................... #ifndef cmdHandler
.................... #define cmdHandler
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................     float kP;      // proportional gain
....................     float kI;      // integral gain
....................     float kD;      // derivative gain
....................     float SP;      // set point-- desired output
....................     float PV;      // process variable-- measured output
....................     float PVold;   // oldPV value  
....................     float CV;      // control variable-- output -- 0 to 100%
....................     float I;       // integral value
....................     float maxSP;   // Max setpoint in microns
....................     float minSP;   // Min setpoint in microns
.................... }PID[2] = {
....................    //  P     I     D
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}, 
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}
....................     };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... // @FLAG
.................... #define op_upper_bound 63  // CRYO
.................... #define op_lower_bound -63 // CRYO
.................... 
.................... //!#define op_upper_bound 63  // AMBIENT 
.................... //!#define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {-0.2701,-0.97313,0,0,0,0},  // @FLAG: Switched Channels
....................                     {-0.3964,-0.96557,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    BOOLEAN homeFlag;       // Flag to trigger the homing routine
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,-1,0,0,FALSE},  // @FLAG: Y-Axis passes -pole during cooldown
....................    {0,0,0,0,0,0,0, 0,0,0,FALSE}
.................... };
.................... 
.................... BOOLEAN adcFilter = TRUE;
.................... 
.................... struct dacV
.................... {
....................     BOOLEAN invV;
....................     unsigned int16 ipVal;
....................     float opPcnt;
....................    
.................... }dacVals[2] = 
.................... {
....................     {FALSE,0,0},
....................     {FALSE,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... 
00326:  MOVLB  E
00328:  BCF    xC9.0
0032A:  MOVLB  0
0032C:  GOTO   006E
.................... #define hwID 'D'   // DiFCS
.................... 
.................... /*****************************************************************************/
.................... /* RESPONSE MESSAGES                                                         */
.................... /*****************************************************************************/
.................... typedef struct response {
....................     int8 id;
....................     char *msg;
.................... } resp;
.................... 
.................... //!#define INVALID_DATA "error - invalid data"
.................... //!#define invalidTime "error - invalid TO value"
.................... //!#define overrun "error - buffer overrun"
.................... //!#define dcVoltage "VDC:%f1"
.................... //!#define USBVoltage "VUSB:%f"
.................... //!#define USBupstream "VUSBup:%f"
.................... //!#define plus5V "5V Rail:%f"
.................... //!#define plus3V3 "3V3 Rai:%f"
.................... //!#define allVoltages "All Voltages = %f, %f, %f, %f, %f"
.................... //!#define USBdownstream "USB downstream status:\r\nPG:%s\r\nch0:%s\r\nch1:%s"
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC MESSGAGE DUMP                                                  */
.................... /*****************************************************************************/
.................... //!#define voltageMsg "V0:%f\r\nV1:%f\r\nV2:%f\r\nV3:%f\r\nV4:%f"
.................... //!#define TimerMsg "T0:%Lu\r\nT1:%Lu\r\nT2:%Lu\r\Tint:%Lu\r\nTtick:%Lu"
.................... //!#define ioStatusMsg "Inputs:%u\r\nOutputs:%u\r\nStatus:%u"
.................... //!#define diagnosticMsg "V0:%f\r\nV1:%f\r\nV2:%f\r\nV3:%f\r\nV4:%f\r\nT0:%Lu\r\nT1:%Lu\r\nT2:%Lu\r\nTint:%Lu\r\nTtick:%Lu\r\nInputs:%u\r\nOutputs:%u\r\nStatus:%u"
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC COMMAND PROTOTYPES                                             */
.................... /*****************************************************************************/
.................... int8 getRev(unsigned int8);                 // gr 
.................... int8 getSN(unsigned int8);                  // gs
.................... 
.................... int8 saveParams(unsigned int8);             // sParams
.................... 
.................... int8 getOPchMap(unsigned int8);             // gChMap,   {1|2}
.................... int8 setOPchMap(unsigned int8);             // sChMap,   {1|2}, {X|Y}
.................... 
.................... int8 getIPchMode(unsigned int8);            // gChMode,  {1|2}
.................... int8 setIPchMode(unsigned int8);            // sChMode,  {1|2}, {MANUAL|MAGSNS}
....................    
.................... int8 getPIDvals(unsigned int8);             // gPID,     {1|2}, {P|I|D}
.................... int8 setPIDvals(unsigned int8);             // sPID,     {1|2}, {P|I|D}, <float>
.................... 
.................... int8 enablePID(unsigned int8);              // enaPID,   {1|2}
.................... int8 disablePID(unsigned int8);             // disPID,   {1|2}
.................... 
.................... int8 getSetPoint(unsigned int8);            // gSP,      {1|2}
.................... int8 setSetPoint(unsigned int8);            // sSP,      {1|2}, <float>
.................... 
.................... int8 getAllSensorCalParams(unsigned int8);  // gSCals,   {1|2}
.................... int8 getSensorCalParam(unsigned int8);      // gSCal,    {1|2}, {0|1|2|3|4|5}
.................... int8 setSensorCalParam(unsigned int8);      // sSCal,    {1|2}, {0|1|2|3|4|5}, <float>
.................... 
.................... int8 getMonitorCalParam(unsigned int8);     // gMCal,    {N15|200|5V6|5VA|3V6X|3V3A|3V3D}
.................... int8 setMonitorCalParam(unsigned int8);     // sMCal,    {N15|200|5V6|5VA|3V6X|3V3A|3V3D}, <float>, <float>
.................... int8 getMonitorValue(unsigned int8);        // gMon,     {N15|200|5V6|5VA|3V6X|3V3A|3V3D|all}
.................... 
.................... int8 getPIDdata(unsigned int8);             // gPIDdata, {1|2}, {PV|CV|PVold|I}
.................... 
.................... int8 getIPdata(unsigned int8);              // gIPdata,  {1|2}, {raw|calib|p0|poles|real}
....................    
.................... int8 getManOPvals(unsigned int8);           // gManOP,   {1|2}  
.................... int8 setManOPvals(unsigned int8);           // sManOP,   {1|2}, <float>  
.................... 
.................... int8 setFilterOn(unsigned int8);            // sFiltOn
.................... int8 setFilterOff(unsigned int8);           // sFiltOff
.................... 
.................... int8 setHomeAxis(unsigned int8);            // sHome,    {1|2}      
.................... int8 getHome(unsigned int8);                // gHome,    {1|2}
.................... 
.................... int8 getTelemetry(unsigned int8);           // gTlm
....................                                                       
.................... int8 invalidCmd(unsigned int8);
.................... 
.................... struct command {
....................     char *cmd_name;
....................     int8 (*cmd_func)(unsigned int8);
.................... };
.................... 
.................... BOOLEAN arg_is_float(char *);
.................... BOOLEAN is_valid_channel(char *);
.................... int8 hex_to_int(char);
.................... void echo_cmd(unsigned int8 rec);
.................... int8 command_parser(unsigned int8 rec);
.................... void command_handler_task();
.................... 
.................... #endif
.................... 
.................... 
.................... /* LIST OF DIAGNOSTIC COMMAND KEYWORDS AND THEIR FUNCTIONS */
.................... struct command cmd_list[] = {
....................     {"gr",       &getRev},
....................     {"gs",       &getSN},
....................     {"sPrm",     &saveParams},
....................     {"gChMap",   &getOPchMap},
....................     {"sChMap",   &setOPchMap},
....................     {"gChMode",  &getIPchMode},
....................     {"sChMode",  &setIPchMode},
....................     {"gPID",     &getPIDvals},
....................     {"sPID",     &setPIDvals},
....................     {"gSP",      &getSetPoint},
....................     {"sSP",      &setSetPoint},
....................     {"gSCals",   &getAllSensorCalParams},
....................     {"gSCal",    &getSensorCalParam},
....................     {"sSCal",    &setSensorCalParam},
....................     {"gMCal",    &getMonitorCalParam},
....................     {"sMCal",    &setMonitorCalParam},
....................     {"gMon",     &getMonitorValue},
....................     {"gPIDdata", &getPIDdata},
....................     {"gIPdata",  &getIPdata},
....................     {"gManOP",   &getManOPvals},
....................     {"sManOP",   &setManOPvals},
....................     {"sFiltOn",  &setFilterOn},
....................     {"sFiltOff", &setFilterOff},
....................     {"sHome",    &setHomeAxis},
....................     {"gHome",    &getHome},
....................     {"gTlm",     &getTelemetry},
....................     {"\0", &invalidCmd}
.................... };
.................... 
.................... /* LIST OF RESPONSE MESSAGES */
.................... enum resp_e { 
....................    SUCCESS,
....................    INV_CMD,
....................    INV_PARAM 
.................... };
.................... 
.................... resp resp_list[] = {
....................    {SUCCESS, "SUCCESS"},
....................    {INV_CMD, "INVALID COMMAND"},
....................    {INV_PARAM, "INVALID PARAMETER"}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC COMMAND DEFINITIONS                                            */
.................... /*****************************************************************************/
....................                           
.................... int8 getRev(unsigned int8 rec){
....................     sprintf(retData+strlen(retData), "%s,", version);
*
05DCC:  MOVLW  04
05DCE:  MOVLB  7
05DD0:  MOVWF  x58
05DD2:  MOVLW  C1
05DD4:  MOVWF  x57
05DD6:  MOVLB  0
05DD8:  RCALL  5C7E
05DDA:  MOVFF  02,03
05DDE:  MOVF   01,W
05DE0:  ADDLW  C1
05DE2:  MOVLB  7
05DE4:  MOVWF  x21
05DE6:  MOVLW  04
05DE8:  ADDWFC 02,W
05DEA:  MOVWF  x22
05DEC:  MOVFF  FE8,565
05DF0:  MOVFF  721,564
05DF4:  MOVLW  30
05DF6:  MOVWF  FF6
05DF8:  MOVLW  03
05DFA:  MOVWF  FF7
05DFC:  MOVLB  0
05DFE:  RCALL  5DAC
05E00:  MOVLW  2C
05E02:  MOVLB  7
05E04:  MOVWF  x66
05E06:  MOVLB  0
05E08:  RCALL  5CB6
....................     return SUCCESS;
05E0A:  MOVLW  00
05E0C:  MOVWF  01
05E0E:  RETURN 0
.................... }
.................... 
.................... int8 getSN(unsigned int8 rec){
....................     sprintf(retData+strlen(retData), "%s,", serialID);
05E10:  MOVLW  04
05E12:  MOVLB  7
05E14:  MOVWF  x58
05E16:  MOVLW  C1
05E18:  MOVWF  x57
05E1A:  MOVLB  0
05E1C:  RCALL  5C7E
05E1E:  MOVFF  02,03
05E22:  MOVF   01,W
05E24:  ADDLW  C1
05E26:  MOVLB  7
05E28:  MOVWF  x21
05E2A:  MOVLW  04
05E2C:  ADDWFC 02,W
05E2E:  MOVWF  x22
05E30:  MOVFF  FE8,565
05E34:  MOVFF  721,564
05E38:  MOVLW  3A
05E3A:  MOVWF  FF6
05E3C:  MOVLW  03
05E3E:  MOVWF  FF7
05E40:  MOVLB  0
05E42:  RCALL  5DAC
05E44:  MOVLW  2C
05E46:  MOVLB  7
05E48:  MOVWF  x66
05E4A:  MOVLB  0
05E4C:  RCALL  5CB6
....................     return SUCCESS;
05E4E:  MOVLW  00
05E50:  MOVWF  01
05E52:  RETURN 0
.................... }
.................... 
.................... int8 saveParams(unsigned int8 rec){
....................     params_save_to_ee();
05E54:  CALL   04C6
....................     return SUCCESS;
05E58:  MOVLW  00
05E5A:  MOVWF  01
05E5C:  RETURN 0
.................... }
.................... 
.................... int8 getOPchMap(unsigned int8 rec){
....................     /*** ARG CHECKS ********************/
....................     int8 arg1;
....................    
....................     if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
06362:  MOVLB  7
06364:  CLRF   x5D
06366:  MOVFF  6AB,75C
0636A:  CLRF   x5F
0636C:  MOVLW  B5
0636E:  MOVWF  x5E
06370:  MOVLB  0
06372:  CALL   086E
06376:  MOVFF  02,723
0637A:  MOVFF  01,722
0637E:  MOVLW  06
06380:  MOVLB  7
06382:  ADDWF  x22,F
06384:  MOVLW  00
06386:  ADDWFC x23,F
06388:  MOVLW  32
0638A:  ADDWF  x22,W
0638C:  MOVWF  01
0638E:  MOVLW  00
06390:  ADDWFC x23,W
06392:  MOVWF  03
06394:  MOVF   01,W
06396:  ADDLW  EB
06398:  MOVWF  01
0639A:  MOVLW  01
0639C:  ADDWFC 03,F
0639E:  MOVFF  01,722
063A2:  MOVFF  03,723
063A6:  MOVFF  03,74A
063AA:  MOVFF  01,749
063AE:  MOVLB  0
063B0:  RCALL  5E5E
063B2:  MOVF   01,F
063B4:  BNZ   63BE
063B6:  MOVLW  02
063B8:  MOVWF  01
063BA:  BRA    6504
063BC:  BRA    641A
....................     else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
063BE:  MOVLB  7
063C0:  CLRF   x5D
063C2:  MOVFF  6AB,75C
063C6:  CLRF   x5F
063C8:  MOVLW  B5
063CA:  MOVWF  x5E
063CC:  MOVLB  0
063CE:  CALL   086E
063D2:  MOVFF  02,723
063D6:  MOVFF  01,722
063DA:  MOVLW  06
063DC:  MOVLB  7
063DE:  ADDWF  x22,F
063E0:  MOVLW  00
063E2:  ADDWFC x23,F
063E4:  MOVLW  32
063E6:  ADDWF  x22,W
063E8:  MOVWF  01
063EA:  MOVLW  00
063EC:  ADDWFC x23,W
063EE:  MOVWF  03
063F0:  MOVF   01,W
063F2:  ADDLW  EB
063F4:  MOVWF  01
063F6:  MOVLW  01
063F8:  ADDWFC 03,F
063FA:  MOVFF  01,722
063FE:  MOVFF  03,723
06402:  MOVFF  03,74A
06406:  MOVFF  01,749
0640A:  CLRF   x4C
0640C:  CLRF   x4B
0640E:  MOVLW  0A
06410:  MOVWF  x4D
06412:  MOVLB  0
06414:  RCALL  5F4E
06416:  MOVFF  01,721
....................    
....................     /*** GET CHANNEL MAP ***************/ 
....................     if      (0 == chMap[arg1-1]) sprintf(retData+strlen(retData), "%d,%c,", arg1, 'X');
0641A:  MOVLW  01
0641C:  MOVLB  7
0641E:  SUBWF  x21,W
06420:  MOVWF  x25
06422:  CLRF   x27
06424:  MOVLW  70
06426:  MOVWF  x26
06428:  MOVLB  0
0642A:  CALL   1054
0642E:  BTFSC  01.0
06430:  BRA    6486
06432:  MOVLW  04
06434:  MOVLB  7
06436:  MOVWF  x58
06438:  MOVLW  C1
0643A:  MOVWF  x57
0643C:  MOVLB  0
0643E:  RCALL  5C7E
06440:  MOVFF  02,03
06444:  MOVF   01,W
06446:  ADDLW  C1
06448:  MOVLB  7
0644A:  MOVWF  x22
0644C:  MOVLW  04
0644E:  ADDWFC 02,W
06450:  MOVWF  x23
06452:  MOVFF  FE8,565
06456:  MOVFF  722,564
0645A:  MOVFF  721,74A
0645E:  MOVLW  18
06460:  MOVWF  x4B
06462:  MOVLB  0
06464:  RCALL  62A2
06466:  MOVLW  2C
06468:  MOVLB  7
0646A:  MOVWF  x66
0646C:  MOVLB  0
0646E:  RCALL  5CB6
06470:  MOVLW  58
06472:  MOVLB  7
06474:  MOVWF  x66
06476:  MOVLB  0
06478:  RCALL  5CB6
0647A:  MOVLW  2C
0647C:  MOVLB  7
0647E:  MOVWF  x66
06480:  MOVLB  0
06482:  RCALL  5CB6
06484:  BRA    6500
....................     else if (1 == chMap[arg1-1]) sprintf(retData+strlen(retData), "%d,%c,", arg1, 'Y');
06486:  MOVLW  01
06488:  MOVLB  7
0648A:  SUBWF  x21,W
0648C:  MOVWF  x25
0648E:  CLRF   x27
06490:  MOVLW  70
06492:  MOVWF  x26
06494:  MOVLB  0
06496:  CALL   1054
0649A:  BTFSS  01.0
0649C:  BRA    64FA
0649E:  MOVLW  04
064A0:  MOVLB  7
064A2:  MOVWF  x58
064A4:  MOVLW  C1
064A6:  MOVWF  x57
064A8:  MOVLB  0
064AA:  CALL   5C7E
064AE:  MOVFF  02,03
064B2:  MOVF   01,W
064B4:  ADDLW  C1
064B6:  MOVLB  7
064B8:  MOVWF  x22
064BA:  MOVLW  04
064BC:  ADDWFC 02,W
064BE:  MOVWF  x23
064C0:  MOVFF  FE8,565
064C4:  MOVFF  722,564
064C8:  MOVFF  721,74A
064CC:  MOVLW  18
064CE:  MOVWF  x4B
064D0:  MOVLB  0
064D2:  RCALL  62A2
064D4:  MOVLW  2C
064D6:  MOVLB  7
064D8:  MOVWF  x66
064DA:  MOVLB  0
064DC:  CALL   5CB6
064E0:  MOVLW  59
064E2:  MOVLB  7
064E4:  MOVWF  x66
064E6:  MOVLB  0
064E8:  CALL   5CB6
064EC:  MOVLW  2C
064EE:  MOVLB  7
064F0:  MOVWF  x66
064F2:  MOVLB  0
064F4:  CALL   5CB6
064F8:  BRA    6500
....................     else return INV_PARAM;
064FA:  MOVLW  02
064FC:  MOVWF  01
064FE:  BRA    6504
....................    
....................     return SUCCESS;
06500:  MOVLW  00
06502:  MOVWF  01
06504:  RETURN 0
.................... }
.................... 
.................... int8 setOPchMap(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
06506:  MOVLB  7
06508:  CLRF   x5D
0650A:  MOVFF  6AB,75C
0650E:  CLRF   x5F
06510:  MOVLW  B5
06512:  MOVWF  x5E
06514:  MOVLB  0
06516:  CALL   086E
0651A:  MOVFF  02,724
0651E:  MOVFF  01,723
06522:  MOVLW  06
06524:  MOVLB  7
06526:  ADDWF  x23,F
06528:  MOVLW  00
0652A:  ADDWFC x24,F
0652C:  MOVLW  32
0652E:  ADDWF  x23,W
06530:  MOVWF  01
06532:  MOVLW  00
06534:  ADDWFC x24,W
06536:  MOVWF  03
06538:  MOVF   01,W
0653A:  ADDLW  EB
0653C:  MOVWF  01
0653E:  MOVLW  01
06540:  ADDWFC 03,F
06542:  MOVFF  01,723
06546:  MOVFF  03,724
0654A:  MOVFF  03,74A
0654E:  MOVFF  01,749
06552:  MOVLB  0
06554:  RCALL  5E5E
06556:  MOVF   01,F
06558:  BNZ   6562
0655A:  MOVLW  02
0655C:  MOVWF  01
0655E:  BRA    66B6
06560:  BRA    65BE
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06562:  MOVLB  7
06564:  CLRF   x5D
06566:  MOVFF  6AB,75C
0656A:  CLRF   x5F
0656C:  MOVLW  B5
0656E:  MOVWF  x5E
06570:  MOVLB  0
06572:  CALL   086E
06576:  MOVFF  02,724
0657A:  MOVFF  01,723
0657E:  MOVLW  06
06580:  MOVLB  7
06582:  ADDWF  x23,F
06584:  MOVLW  00
06586:  ADDWFC x24,F
06588:  MOVLW  32
0658A:  ADDWF  x23,W
0658C:  MOVWF  01
0658E:  MOVLW  00
06590:  ADDWFC x24,W
06592:  MOVWF  03
06594:  MOVF   01,W
06596:  ADDLW  EB
06598:  MOVWF  01
0659A:  MOVLW  01
0659C:  ADDWFC 03,F
0659E:  MOVFF  01,723
065A2:  MOVFF  03,724
065A6:  MOVFF  03,74A
065AA:  MOVFF  01,749
065AE:  CLRF   x4C
065B0:  CLRF   x4B
065B2:  MOVLW  0A
065B4:  MOVWF  x4D
065B6:  MOVLB  0
065B8:  RCALL  5F4E
065BA:  MOVFF  01,721
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
065BE:  MOVLB  7
065C0:  CLRF   x5D
065C2:  MOVFF  6AB,75C
065C6:  CLRF   x5F
065C8:  MOVLW  B5
065CA:  MOVWF  x5E
065CC:  MOVLB  0
065CE:  CALL   086E
065D2:  MOVFF  02,724
065D6:  MOVFF  01,723
065DA:  MOVLW  06
065DC:  MOVLB  7
065DE:  ADDWF  x23,F
065E0:  MOVLW  00
065E2:  ADDWFC x24,F
065E4:  MOVLW  4B
065E6:  ADDWF  x23,W
065E8:  MOVWF  01
065EA:  MOVLW  00
065EC:  ADDWFC x24,W
065EE:  MOVWF  03
065F0:  MOVF   01,W
065F2:  ADDLW  EB
065F4:  MOVWF  01
065F6:  MOVLW  01
065F8:  ADDWFC 03,F
065FA:  MOVFF  01,723
065FE:  MOVFF  03,724
06602:  MOVFF  03,758
06606:  MOVFF  01,757
0660A:  MOVLB  0
0660C:  CALL   5C7E
06610:  MOVFF  02,03
06614:  MOVF   01,W
06616:  SUBLW  01
06618:  BNZ   661E
0661A:  MOVF   03,F
0661C:  BZ    6626
0661E:  MOVLW  02
06620:  MOVWF  01
06622:  BRA    66B6
06624:  BRA    6666
....................    else arg2 = SERcmd[rec].p[3][0];
06626:  MOVLB  7
06628:  CLRF   x5D
0662A:  MOVFF  6AB,75C
0662E:  CLRF   x5F
06630:  MOVLW  B5
06632:  MOVWF  x5E
06634:  MOVLB  0
06636:  CALL   086E
0663A:  MOVFF  02,724
0663E:  MOVFF  01,723
06642:  MOVLW  06
06644:  MOVLB  7
06646:  ADDWF  x23,F
06648:  MOVLW  00
0664A:  ADDWFC x24,F
0664C:  MOVLW  4B
0664E:  ADDWF  x23,F
06650:  MOVLW  00
06652:  ADDWFC x24,F
06654:  MOVLW  EB
06656:  ADDWF  x23,W
06658:  MOVWF  FE9
0665A:  MOVLW  01
0665C:  ADDWFC x24,W
0665E:  MOVWF  FEA
06660:  MOVFF  FEF,722
06664:  MOVLB  0
....................    
....................    /*** SET CHANNEL MAP ***************/
....................    if      ('X' == arg2) chMap[arg1-1] = chX;
06666:  MOVLB  7
06668:  MOVF   x22,W
0666A:  SUBLW  58
0666C:  BNZ   6688
0666E:  MOVLW  01
06670:  SUBWF  x21,W
06672:  MOVWF  x23
06674:  MOVWF  x38
06676:  CLRF   x39
06678:  CLRF   x3B
0667A:  MOVLW  70
0667C:  MOVWF  x3A
0667E:  MOVLB  0
06680:  CALL   0D20
06684:  BRA    66B2
06686:  MOVLB  7
....................    else if ('Y' == arg2) chMap[arg1-1] = chY;
06688:  MOVF   x22,W
0668A:  SUBLW  59
0668C:  BNZ   66AA
0668E:  MOVLW  01
06690:  SUBWF  x21,W
06692:  MOVWF  x23
06694:  MOVWF  x38
06696:  MOVLW  01
06698:  MOVWF  x39
0669A:  CLRF   x3B
0669C:  MOVLW  70
0669E:  MOVWF  x3A
066A0:  MOVLB  0
066A2:  CALL   0D20
066A6:  BRA    66B2
066A8:  MOVLB  7
....................    else return INV_PARAM;
066AA:  MOVLW  02
066AC:  MOVWF  01
066AE:  MOVLB  0
066B0:  BRA    66B6
....................    
....................    return SUCCESS;
066B2:  MOVLW  00
066B4:  MOVWF  01
066B6:  RETURN 0
.................... }
.................... 
.................... int8 getIPchMode(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
066E2:  MOVLB  7
066E4:  CLRF   x5D
066E6:  MOVFF  6AB,75C
066EA:  CLRF   x5F
066EC:  MOVLW  B5
066EE:  MOVWF  x5E
066F0:  MOVLB  0
066F2:  CALL   086E
066F6:  MOVFF  02,723
066FA:  MOVFF  01,722
066FE:  MOVLW  06
06700:  MOVLB  7
06702:  ADDWF  x22,F
06704:  MOVLW  00
06706:  ADDWFC x23,F
06708:  MOVLW  32
0670A:  ADDWF  x22,W
0670C:  MOVWF  01
0670E:  MOVLW  00
06710:  ADDWFC x23,W
06712:  MOVWF  03
06714:  MOVF   01,W
06716:  ADDLW  EB
06718:  MOVWF  01
0671A:  MOVLW  01
0671C:  ADDWFC 03,F
0671E:  MOVFF  01,722
06722:  MOVFF  03,723
06726:  MOVFF  03,74A
0672A:  MOVFF  01,749
0672E:  MOVLB  0
06730:  CALL   5E5E
06734:  MOVF   01,F
06736:  BNZ   6740
06738:  MOVLW  02
0673A:  MOVWF  01
0673C:  BRA    686C
0673E:  BRA    679E
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06740:  MOVLB  7
06742:  CLRF   x5D
06744:  MOVFF  6AB,75C
06748:  CLRF   x5F
0674A:  MOVLW  B5
0674C:  MOVWF  x5E
0674E:  MOVLB  0
06750:  CALL   086E
06754:  MOVFF  02,723
06758:  MOVFF  01,722
0675C:  MOVLW  06
0675E:  MOVLB  7
06760:  ADDWF  x22,F
06762:  MOVLW  00
06764:  ADDWFC x23,F
06766:  MOVLW  32
06768:  ADDWF  x22,W
0676A:  MOVWF  01
0676C:  MOVLW  00
0676E:  ADDWFC x23,W
06770:  MOVWF  03
06772:  MOVF   01,W
06774:  ADDLW  EB
06776:  MOVWF  01
06778:  MOVLW  01
0677A:  ADDWFC 03,F
0677C:  MOVFF  01,722
06780:  MOVFF  03,723
06784:  MOVFF  03,74A
06788:  MOVFF  01,749
0678C:  CLRF   x4C
0678E:  CLRF   x4B
06790:  MOVLW  0A
06792:  MOVWF  x4D
06794:  MOVLB  0
06796:  CALL   5F4E
0679A:  MOVFF  01,721
....................    
....................    /*** GET INPUT MAP *****************/
....................    if      (0 == chMode[arg1-1]) sprintf(retData+strlen(retData), "%d,MANUAL,", arg1);
0679E:  MOVLW  01
067A0:  MOVLB  7
067A2:  SUBWF  x21,W
067A4:  MOVWF  x25
067A6:  CLRF   x27
067A8:  MOVLW  71
067AA:  MOVWF  x26
067AC:  MOVLB  0
067AE:  CALL   1054
067B2:  BTFSC  01.0
067B4:  BRA    6800
067B6:  MOVLW  04
067B8:  MOVLB  7
067BA:  MOVWF  x58
067BC:  MOVLW  C1
067BE:  MOVWF  x57
067C0:  MOVLB  0
067C2:  CALL   5C7E
067C6:  MOVFF  02,03
067CA:  MOVF   01,W
067CC:  ADDLW  C1
067CE:  MOVLB  7
067D0:  MOVWF  x22
067D2:  MOVLW  04
067D4:  ADDWFC 02,W
067D6:  MOVWF  x23
067D8:  MOVFF  FE8,565
067DC:  MOVFF  722,564
067E0:  MOVFF  721,74A
067E4:  MOVLW  18
067E6:  MOVWF  x4B
067E8:  MOVLB  0
067EA:  RCALL  62A2
067EC:  MOVLW  42
067EE:  MOVWF  FF6
067F0:  MOVLW  03
067F2:  MOVWF  FF7
067F4:  MOVLW  08
067F6:  MOVLB  7
067F8:  MOVWF  x2E
067FA:  MOVLB  0
067FC:  RCALL  66B8
067FE:  BRA    6868
....................    else if (1 == chMode[arg1-1]) sprintf(retData+strlen(retData), "%d,MAGSNS,", arg1);
06800:  MOVLW  01
06802:  MOVLB  7
06804:  SUBWF  x21,W
06806:  MOVWF  x25
06808:  CLRF   x27
0680A:  MOVLW  71
0680C:  MOVWF  x26
0680E:  MOVLB  0
06810:  CALL   1054
06814:  BTFSS  01.0
06816:  BRA    6862
06818:  MOVLW  04
0681A:  MOVLB  7
0681C:  MOVWF  x58
0681E:  MOVLW  C1
06820:  MOVWF  x57
06822:  MOVLB  0
06824:  CALL   5C7E
06828:  MOVFF  02,03
0682C:  MOVF   01,W
0682E:  ADDLW  C1
06830:  MOVLB  7
06832:  MOVWF  x22
06834:  MOVLW  04
06836:  ADDWFC 02,W
06838:  MOVWF  x23
0683A:  MOVFF  FE8,565
0683E:  MOVFF  722,564
06842:  MOVFF  721,74A
06846:  MOVLW  18
06848:  MOVWF  x4B
0684A:  MOVLB  0
0684C:  RCALL  62A2
0684E:  MOVLW  4E
06850:  MOVWF  FF6
06852:  MOVLW  03
06854:  MOVWF  FF7
06856:  MOVLW  08
06858:  MOVLB  7
0685A:  MOVWF  x2E
0685C:  MOVLB  0
0685E:  RCALL  66B8
06860:  BRA    6868
....................    else return INV_PARAM;
06862:  MOVLW  02
06864:  MOVWF  01
06866:  BRA    686C
....................    
....................    return SUCCESS;
06868:  MOVLW  00
0686A:  MOVWF  01
0686C:  RETURN 0
.................... }
.................... 
.................... int8 setIPchMode(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char *arg2;
....................    char *s_manual = "MANUAL";
0686E:  MOVLW  4D
06870:  MOVLB  7
06872:  MOVWF  x26
06874:  MOVLW  41
06876:  MOVWF  x27
06878:  MOVLW  4E
0687A:  MOVWF  x28
0687C:  MOVLW  55
0687E:  MOVWF  x29
06880:  MOVLW  41
06882:  MOVWF  x2A
06884:  MOVLW  4C
06886:  MOVWF  x2B
06888:  CLRF   x2C
0688A:  MOVLW  07
0688C:  MOVWF  x25
0688E:  MOVLW  26
06890:  MOVWF  x24
....................    char *s_magsns = "MAGSNS";
06892:  MOVLW  4D
06894:  MOVWF  x2F
06896:  MOVLW  41
06898:  MOVWF  x30
0689A:  MOVLW  47
0689C:  MOVWF  x31
0689E:  MOVLW  53
068A0:  MOVWF  x32
068A2:  MOVLW  4E
068A4:  MOVWF  x33
068A6:  MOVLW  53
068A8:  MOVWF  x34
068AA:  CLRF   x35
068AC:  MOVLW  07
068AE:  MOVWF  x2E
068B0:  MOVLW  2F
068B2:  MOVWF  x2D
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
068B4:  CLRF   x5D
068B6:  MOVFF  6AB,75C
068BA:  CLRF   x5F
068BC:  MOVLW  B5
068BE:  MOVWF  x5E
068C0:  MOVLB  0
068C2:  CALL   086E
068C6:  MOVFF  02,737
068CA:  MOVFF  01,736
068CE:  MOVLW  06
068D0:  MOVLB  7
068D2:  ADDWF  x36,F
068D4:  MOVLW  00
068D6:  ADDWFC x37,F
068D8:  MOVLW  32
068DA:  ADDWF  x36,W
068DC:  MOVWF  01
068DE:  MOVLW  00
068E0:  ADDWFC x37,W
068E2:  MOVWF  03
068E4:  MOVF   01,W
068E6:  ADDLW  EB
068E8:  MOVWF  01
068EA:  MOVLW  01
068EC:  ADDWFC 03,F
068EE:  MOVFF  01,736
068F2:  MOVFF  03,737
068F6:  MOVFF  03,74A
068FA:  MOVFF  01,749
068FE:  MOVLB  0
06900:  CALL   5E5E
06904:  MOVF   01,F
06906:  BNZ   6910
06908:  MOVLW  02
0690A:  MOVWF  01
0690C:  BRA    6A8A
0690E:  BRA    696E
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06910:  MOVLB  7
06912:  CLRF   x5D
06914:  MOVFF  6AB,75C
06918:  CLRF   x5F
0691A:  MOVLW  B5
0691C:  MOVWF  x5E
0691E:  MOVLB  0
06920:  CALL   086E
06924:  MOVFF  02,737
06928:  MOVFF  01,736
0692C:  MOVLW  06
0692E:  MOVLB  7
06930:  ADDWF  x36,F
06932:  MOVLW  00
06934:  ADDWFC x37,F
06936:  MOVLW  32
06938:  ADDWF  x36,W
0693A:  MOVWF  01
0693C:  MOVLW  00
0693E:  ADDWFC x37,W
06940:  MOVWF  03
06942:  MOVF   01,W
06944:  ADDLW  EB
06946:  MOVWF  01
06948:  MOVLW  01
0694A:  ADDWFC 03,F
0694C:  MOVFF  01,736
06950:  MOVFF  03,737
06954:  MOVFF  03,74A
06958:  MOVFF  01,749
0695C:  CLRF   x4C
0695E:  CLRF   x4B
06960:  MOVLW  0A
06962:  MOVWF  x4D
06964:  MOVLB  0
06966:  CALL   5F4E
0696A:  MOVFF  01,721
....................    
....................    if (0 == strlen(SERcmd[rec].p[3])) return INV_PARAM;
0696E:  MOVLB  7
06970:  CLRF   x5D
06972:  MOVFF  6AB,75C
06976:  CLRF   x5F
06978:  MOVLW  B5
0697A:  MOVWF  x5E
0697C:  MOVLB  0
0697E:  CALL   086E
06982:  MOVFF  02,737
06986:  MOVFF  01,736
0698A:  MOVLW  06
0698C:  MOVLB  7
0698E:  ADDWF  x36,F
06990:  MOVLW  00
06992:  ADDWFC x37,F
06994:  MOVLW  4B
06996:  ADDWF  x36,W
06998:  MOVWF  01
0699A:  MOVLW  00
0699C:  ADDWFC x37,W
0699E:  MOVWF  03
069A0:  MOVF   01,W
069A2:  ADDLW  EB
069A4:  MOVWF  01
069A6:  MOVLW  01
069A8:  ADDWFC 03,F
069AA:  MOVFF  01,736
069AE:  MOVFF  03,737
069B2:  MOVFF  03,758
069B6:  MOVFF  01,757
069BA:  MOVLB  0
069BC:  CALL   5C7E
069C0:  MOVFF  02,03
069C4:  MOVF   01,W
069C6:  BNZ   69D4
069C8:  MOVF   03,F
069CA:  BNZ   69D4
069CC:  MOVLW  02
069CE:  MOVWF  01
069D0:  BRA    6A8A
069D2:  BRA    6A1A
....................    else arg2 = SERcmd[rec].p[3];
069D4:  MOVLB  7
069D6:  CLRF   x5D
069D8:  MOVFF  6AB,75C
069DC:  CLRF   x5F
069DE:  MOVLW  B5
069E0:  MOVWF  x5E
069E2:  MOVLB  0
069E4:  CALL   086E
069E8:  MOVFF  02,737
069EC:  MOVFF  01,736
069F0:  MOVLW  06
069F2:  MOVLB  7
069F4:  ADDWF  x36,F
069F6:  MOVLW  00
069F8:  ADDWFC x37,F
069FA:  MOVLW  4B
069FC:  ADDWF  x36,W
069FE:  MOVWF  01
06A00:  MOVLW  00
06A02:  ADDWFC x37,W
06A04:  MOVWF  03
06A06:  MOVF   01,W
06A08:  ADDLW  EB
06A0A:  MOVWF  01
06A0C:  MOVLW  01
06A0E:  ADDWFC 03,F
06A10:  MOVFF  01,722
06A14:  MOVFF  03,723
06A18:  MOVLB  0
....................    
....................    /*** SET INPUT MAP *****************/
....................    if      (0 == strcmp(s_manual, arg2)) chMode[arg1-1] = MANUAL;
06A1A:  MOVFF  725,758
06A1E:  MOVFF  724,757
06A22:  MOVFF  723,75A
06A26:  MOVFF  722,759
06A2A:  CALL   5D34
06A2E:  MOVF   01,F
06A30:  BNZ   6A4C
06A32:  MOVLW  01
06A34:  MOVLB  7
06A36:  SUBWF  x21,W
06A38:  MOVWF  x36
06A3A:  MOVWF  x38
06A3C:  CLRF   x39
06A3E:  CLRF   x3B
06A40:  MOVLW  71
06A42:  MOVWF  x3A
06A44:  MOVLB  0
06A46:  CALL   0D20
06A4A:  BRA    6A86
....................    else if (0 == strcmp(s_magsns, arg2)) chMode[arg1-1] = MAGSNS;
06A4C:  MOVFF  72E,758
06A50:  MOVFF  72D,757
06A54:  MOVFF  723,75A
06A58:  MOVFF  722,759
06A5C:  CALL   5D34
06A60:  MOVF   01,F
06A62:  BNZ   6A80
06A64:  MOVLW  01
06A66:  MOVLB  7
06A68:  SUBWF  x21,W
06A6A:  MOVWF  x36
06A6C:  MOVWF  x38
06A6E:  MOVLW  01
06A70:  MOVWF  x39
06A72:  CLRF   x3B
06A74:  MOVLW  71
06A76:  MOVWF  x3A
06A78:  MOVLB  0
06A7A:  CALL   0D20
06A7E:  BRA    6A86
....................    else return INV_PARAM;
06A80:  MOVLW  02
06A82:  MOVWF  01
06A84:  BRA    6A8A
....................    
....................    return SUCCESS;
06A86:  MOVLW  00
06A88:  MOVWF  01
06A8A:  RETURN 0
.................... }
.................... 
.................... int8 getPIDvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/ 
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
06D12:  MOVLB  7
06D14:  CLRF   x5D
06D16:  MOVFF  6AB,75C
06D1A:  CLRF   x5F
06D1C:  MOVLW  B5
06D1E:  MOVWF  x5E
06D20:  MOVLB  0
06D22:  CALL   086E
06D26:  MOVFF  02,724
06D2A:  MOVFF  01,723
06D2E:  MOVLW  06
06D30:  MOVLB  7
06D32:  ADDWF  x23,F
06D34:  MOVLW  00
06D36:  ADDWFC x24,F
06D38:  MOVLW  32
06D3A:  ADDWF  x23,W
06D3C:  MOVWF  01
06D3E:  MOVLW  00
06D40:  ADDWFC x24,W
06D42:  MOVWF  03
06D44:  MOVF   01,W
06D46:  ADDLW  EB
06D48:  MOVWF  01
06D4A:  MOVLW  01
06D4C:  ADDWFC 03,F
06D4E:  MOVFF  01,723
06D52:  MOVFF  03,724
06D56:  MOVFF  03,74A
06D5A:  MOVFF  01,749
06D5E:  MOVLB  0
06D60:  CALL   5E5E
06D64:  MOVF   01,F
06D66:  BNZ   6D70
06D68:  MOVLW  02
06D6A:  MOVWF  01
06D6C:  BRA    71C6
06D6E:  BRA    6DCE
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06D70:  MOVLB  7
06D72:  CLRF   x5D
06D74:  MOVFF  6AB,75C
06D78:  CLRF   x5F
06D7A:  MOVLW  B5
06D7C:  MOVWF  x5E
06D7E:  MOVLB  0
06D80:  CALL   086E
06D84:  MOVFF  02,724
06D88:  MOVFF  01,723
06D8C:  MOVLW  06
06D8E:  MOVLB  7
06D90:  ADDWF  x23,F
06D92:  MOVLW  00
06D94:  ADDWFC x24,F
06D96:  MOVLW  32
06D98:  ADDWF  x23,W
06D9A:  MOVWF  01
06D9C:  MOVLW  00
06D9E:  ADDWFC x24,W
06DA0:  MOVWF  03
06DA2:  MOVF   01,W
06DA4:  ADDLW  EB
06DA6:  MOVWF  01
06DA8:  MOVLW  01
06DAA:  ADDWFC 03,F
06DAC:  MOVFF  01,723
06DB0:  MOVFF  03,724
06DB4:  MOVFF  03,74A
06DB8:  MOVFF  01,749
06DBC:  CLRF   x4C
06DBE:  CLRF   x4B
06DC0:  MOVLW  0A
06DC2:  MOVWF  x4D
06DC4:  MOVLB  0
06DC6:  CALL   5F4E
06DCA:  MOVFF  01,721
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
06DCE:  MOVLB  7
06DD0:  CLRF   x5D
06DD2:  MOVFF  6AB,75C
06DD6:  CLRF   x5F
06DD8:  MOVLW  B5
06DDA:  MOVWF  x5E
06DDC:  MOVLB  0
06DDE:  CALL   086E
06DE2:  MOVFF  02,724
06DE6:  MOVFF  01,723
06DEA:  MOVLW  06
06DEC:  MOVLB  7
06DEE:  ADDWF  x23,F
06DF0:  MOVLW  00
06DF2:  ADDWFC x24,F
06DF4:  MOVLW  4B
06DF6:  ADDWF  x23,W
06DF8:  MOVWF  01
06DFA:  MOVLW  00
06DFC:  ADDWFC x24,W
06DFE:  MOVWF  03
06E00:  MOVF   01,W
06E02:  ADDLW  EB
06E04:  MOVWF  01
06E06:  MOVLW  01
06E08:  ADDWFC 03,F
06E0A:  MOVFF  01,723
06E0E:  MOVFF  03,724
06E12:  MOVFF  03,758
06E16:  MOVFF  01,757
06E1A:  MOVLB  0
06E1C:  CALL   5C7E
06E20:  MOVFF  02,03
06E24:  MOVF   01,W
06E26:  SUBLW  01
06E28:  BNZ   6E2E
06E2A:  MOVF   03,F
06E2C:  BZ    6E36
06E2E:  MOVLW  02
06E30:  MOVWF  01
06E32:  BRA    71C6
06E34:  BRA    6E76
....................    else arg2 = SERcmd[rec].p[3][0];
06E36:  MOVLB  7
06E38:  CLRF   x5D
06E3A:  MOVFF  6AB,75C
06E3E:  CLRF   x5F
06E40:  MOVLW  B5
06E42:  MOVWF  x5E
06E44:  MOVLB  0
06E46:  CALL   086E
06E4A:  MOVFF  02,724
06E4E:  MOVFF  01,723
06E52:  MOVLW  06
06E54:  MOVLB  7
06E56:  ADDWF  x23,F
06E58:  MOVLW  00
06E5A:  ADDWFC x24,F
06E5C:  MOVLW  4B
06E5E:  ADDWF  x23,F
06E60:  MOVLW  00
06E62:  ADDWFC x24,F
06E64:  MOVLW  EB
06E66:  ADDWF  x23,W
06E68:  MOVWF  FE9
06E6A:  MOVLW  01
06E6C:  ADDWFC x24,W
06E6E:  MOVWF  FEA
06E70:  MOVFF  FEF,722
06E74:  MOVLB  0
....................    
....................    /*** GET P, I, D, or A(LL) VALUE **********/
....................    if      ('P' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kP);
06E76:  MOVLB  7
06E78:  MOVF   x22,W
06E7A:  SUBLW  50
06E7C:  BNZ   6F16
06E7E:  MOVLW  04
06E80:  MOVWF  x58
06E82:  MOVLW  C1
06E84:  MOVWF  x57
06E86:  MOVLB  0
06E88:  CALL   5C7E
06E8C:  MOVFF  02,03
06E90:  MOVF   01,W
06E92:  ADDLW  C1
06E94:  MOVLB  7
06E96:  MOVWF  x23
06E98:  MOVLW  04
06E9A:  ADDWFC 02,W
06E9C:  MOVWF  x24
06E9E:  MOVLW  01
06EA0:  SUBWF  x21,W
06EA2:  MULLW  28
06EA4:  MOVF   FF3,W
06EA6:  CLRF   x26
06EA8:  MOVWF  x25
06EAA:  MOVLW  20
06EAC:  ADDWF  x25,W
06EAE:  MOVWF  FE9
06EB0:  MOVLW  00
06EB2:  ADDWFC x26,W
06EB4:  MOVWF  FEA
06EB6:  MOVFF  FEF,727
06EBA:  MOVFF  FEC,728
06EBE:  MOVFF  FEC,729
06EC2:  MOVFF  FEC,72A
06EC6:  MOVFF  724,565
06ECA:  MOVFF  723,564
06ECE:  MOVFF  721,74A
06ED2:  MOVLW  18
06ED4:  MOVWF  x4B
06ED6:  MOVLB  0
06ED8:  CALL   62A2
06EDC:  MOVLW  2C
06EDE:  MOVLB  7
06EE0:  MOVWF  x66
06EE2:  MOVLB  0
06EE4:  CALL   5CB6
06EE8:  MOVLW  89
06EEA:  MOVWF  FE9
06EEC:  MOVFF  72A,75C
06EF0:  MOVFF  729,75B
06EF4:  MOVFF  728,75A
06EF8:  MOVFF  727,759
06EFC:  MOVLW  02
06EFE:  MOVLB  7
06F00:  MOVWF  x5D
06F02:  MOVLB  0
06F04:  RCALL  6B62
06F06:  MOVLW  2C
06F08:  MOVLB  7
06F0A:  MOVWF  x66
06F0C:  MOVLB  0
06F0E:  CALL   5CB6
06F12:  BRA    71C2
06F14:  MOVLB  7
....................    else if ('I' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kI);
06F16:  MOVF   x22,W
06F18:  SUBLW  49
06F1A:  BNZ   6FBC
06F1C:  MOVLW  04
06F1E:  MOVWF  x58
06F20:  MOVLW  C1
06F22:  MOVWF  x57
06F24:  MOVLB  0
06F26:  CALL   5C7E
06F2A:  MOVF   01,W
06F2C:  ADDLW  C1
06F2E:  MOVLB  7
06F30:  MOVWF  x23
06F32:  MOVLW  04
06F34:  ADDWFC 02,W
06F36:  MOVWF  x24
06F38:  MOVLW  01
06F3A:  SUBWF  x21,W
06F3C:  MULLW  28
06F3E:  MOVF   FF3,W
06F40:  CLRF   x26
06F42:  MOVWF  x25
06F44:  MOVLW  04
06F46:  ADDWF  x25,W
06F48:  MOVWF  01
06F4A:  MOVLW  00
06F4C:  ADDWFC x26,W
06F4E:  MOVWF  03
06F50:  MOVF   01,W
06F52:  ADDLW  20
06F54:  MOVWF  FE9
06F56:  MOVLW  00
06F58:  ADDWFC 03,W
06F5A:  MOVWF  FEA
06F5C:  MOVFF  FEF,725
06F60:  MOVFF  FEC,726
06F64:  MOVFF  FEC,727
06F68:  MOVFF  FEC,728
06F6C:  MOVFF  724,565
06F70:  MOVFF  723,564
06F74:  MOVFF  721,74A
06F78:  MOVLW  18
06F7A:  MOVWF  x4B
06F7C:  MOVLB  0
06F7E:  CALL   62A2
06F82:  MOVLW  2C
06F84:  MOVLB  7
06F86:  MOVWF  x66
06F88:  MOVLB  0
06F8A:  CALL   5CB6
06F8E:  MOVLW  89
06F90:  MOVWF  FE9
06F92:  MOVFF  728,75C
06F96:  MOVFF  727,75B
06F9A:  MOVFF  726,75A
06F9E:  MOVFF  725,759
06FA2:  MOVLW  02
06FA4:  MOVLB  7
06FA6:  MOVWF  x5D
06FA8:  MOVLB  0
06FAA:  RCALL  6B62
06FAC:  MOVLW  2C
06FAE:  MOVLB  7
06FB0:  MOVWF  x66
06FB2:  MOVLB  0
06FB4:  CALL   5CB6
06FB8:  BRA    71C2
06FBA:  MOVLB  7
....................    else if ('D' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kD);
06FBC:  MOVF   x22,W
06FBE:  SUBLW  44
06FC0:  BNZ   7062
06FC2:  MOVLW  04
06FC4:  MOVWF  x58
06FC6:  MOVLW  C1
06FC8:  MOVWF  x57
06FCA:  MOVLB  0
06FCC:  CALL   5C7E
06FD0:  MOVF   01,W
06FD2:  ADDLW  C1
06FD4:  MOVLB  7
06FD6:  MOVWF  x23
06FD8:  MOVLW  04
06FDA:  ADDWFC 02,W
06FDC:  MOVWF  x24
06FDE:  MOVLW  01
06FE0:  SUBWF  x21,W
06FE2:  MULLW  28
06FE4:  MOVF   FF3,W
06FE6:  CLRF   x26
06FE8:  MOVWF  x25
06FEA:  MOVLW  08
06FEC:  ADDWF  x25,W
06FEE:  MOVWF  01
06FF0:  MOVLW  00
06FF2:  ADDWFC x26,W
06FF4:  MOVWF  03
06FF6:  MOVF   01,W
06FF8:  ADDLW  20
06FFA:  MOVWF  FE9
06FFC:  MOVLW  00
06FFE:  ADDWFC 03,W
07000:  MOVWF  FEA
07002:  MOVFF  FEF,725
07006:  MOVFF  FEC,726
0700A:  MOVFF  FEC,727
0700E:  MOVFF  FEC,728
07012:  MOVFF  724,565
07016:  MOVFF  723,564
0701A:  MOVFF  721,74A
0701E:  MOVLW  18
07020:  MOVWF  x4B
07022:  MOVLB  0
07024:  CALL   62A2
07028:  MOVLW  2C
0702A:  MOVLB  7
0702C:  MOVWF  x66
0702E:  MOVLB  0
07030:  CALL   5CB6
07034:  MOVLW  89
07036:  MOVWF  FE9
07038:  MOVFF  728,75C
0703C:  MOVFF  727,75B
07040:  MOVFF  726,75A
07044:  MOVFF  725,759
07048:  MOVLW  02
0704A:  MOVLB  7
0704C:  MOVWF  x5D
0704E:  MOVLB  0
07050:  RCALL  6B62
07052:  MOVLW  2C
07054:  MOVLB  7
07056:  MOVWF  x66
07058:  MOVLB  0
0705A:  CALL   5CB6
0705E:  BRA    71C2
07060:  MOVLB  7
....................    else if ('A' == arg2) sprintf(retData+strlen(retData), "%d,%f,%f,%f,", arg1, PID[arg1-1].kP, PID[arg1-1].kI, PID[arg1-1].kD);
07062:  MOVF   x22,W
07064:  SUBLW  41
07066:  BTFSS  FD8.2
07068:  BRA    71BA
0706A:  MOVLW  04
0706C:  MOVWF  x58
0706E:  MOVLW  C1
07070:  MOVWF  x57
07072:  MOVLB  0
07074:  CALL   5C7E
07078:  MOVF   01,W
0707A:  ADDLW  C1
0707C:  MOVLB  7
0707E:  MOVWF  x23
07080:  MOVLW  04
07082:  ADDWFC 02,W
07084:  MOVWF  x24
07086:  MOVLW  01
07088:  SUBWF  x21,W
0708A:  MULLW  28
0708C:  MOVF   FF3,W
0708E:  CLRF   x26
07090:  MOVWF  x25
07092:  MOVLW  20
07094:  ADDWF  x25,W
07096:  MOVWF  FE9
07098:  MOVLW  00
0709A:  ADDWFC x26,W
0709C:  MOVWF  FEA
0709E:  MOVFF  FEF,727
070A2:  MOVFF  FEC,728
070A6:  MOVFF  FEC,729
070AA:  MOVFF  FEC,72A
070AE:  MOVLW  01
070B0:  SUBWF  x21,W
070B2:  MULLW  28
070B4:  MOVF   FF3,W
070B6:  CLRF   x2C
070B8:  MOVWF  x2B
070BA:  MOVLW  04
070BC:  ADDWF  x2B,W
070BE:  MOVWF  01
070C0:  MOVLW  00
070C2:  ADDWFC x2C,W
070C4:  MOVWF  03
070C6:  MOVF   01,W
070C8:  ADDLW  20
070CA:  MOVWF  FE9
070CC:  MOVLW  00
070CE:  ADDWFC 03,W
070D0:  MOVWF  FEA
070D2:  MOVFF  FEF,72B
070D6:  MOVFF  FEC,72C
070DA:  MOVFF  FEC,72D
070DE:  MOVFF  FEC,72E
070E2:  MOVLW  01
070E4:  SUBWF  x21,W
070E6:  MULLW  28
070E8:  MOVF   FF3,W
070EA:  CLRF   x30
070EC:  MOVWF  x2F
070EE:  MOVLW  08
070F0:  ADDWF  x2F,W
070F2:  MOVWF  01
070F4:  MOVLW  00
070F6:  ADDWFC x30,W
070F8:  MOVWF  03
070FA:  MOVF   01,W
070FC:  ADDLW  20
070FE:  MOVWF  FE9
07100:  MOVLW  00
07102:  ADDWFC 03,W
07104:  MOVWF  FEA
07106:  MOVFF  FEF,72F
0710A:  MOVFF  FEC,730
0710E:  MOVFF  FEC,731
07112:  MOVFF  FEC,732
07116:  MOVFF  724,565
0711A:  MOVFF  723,564
0711E:  MOVFF  721,74A
07122:  MOVLW  18
07124:  MOVWF  x4B
07126:  MOVLB  0
07128:  CALL   62A2
0712C:  MOVLW  2C
0712E:  MOVLB  7
07130:  MOVWF  x66
07132:  MOVLB  0
07134:  CALL   5CB6
07138:  MOVLW  89
0713A:  MOVWF  FE9
0713C:  MOVFF  72A,75C
07140:  MOVFF  729,75B
07144:  MOVFF  728,75A
07148:  MOVFF  727,759
0714C:  MOVLW  02
0714E:  MOVLB  7
07150:  MOVWF  x5D
07152:  MOVLB  0
07154:  RCALL  6B62
07156:  MOVLW  2C
07158:  MOVLB  7
0715A:  MOVWF  x66
0715C:  MOVLB  0
0715E:  CALL   5CB6
07162:  MOVLW  89
07164:  MOVWF  FE9
07166:  MOVFF  72E,75C
0716A:  MOVFF  72D,75B
0716E:  MOVFF  72C,75A
07172:  MOVFF  72B,759
07176:  MOVLW  02
07178:  MOVLB  7
0717A:  MOVWF  x5D
0717C:  MOVLB  0
0717E:  RCALL  6B62
07180:  MOVLW  2C
07182:  MOVLB  7
07184:  MOVWF  x66
07186:  MOVLB  0
07188:  CALL   5CB6
0718C:  MOVLW  89
0718E:  MOVWF  FE9
07190:  MOVFF  732,75C
07194:  MOVFF  731,75B
07198:  MOVFF  730,75A
0719C:  MOVFF  72F,759
071A0:  MOVLW  02
071A2:  MOVLB  7
071A4:  MOVWF  x5D
071A6:  MOVLB  0
071A8:  RCALL  6B62
071AA:  MOVLW  2C
071AC:  MOVLB  7
071AE:  MOVWF  x66
071B0:  MOVLB  0
071B2:  CALL   5CB6
071B6:  BRA    71C2
071B8:  MOVLB  7
....................    else return INV_PARAM;
071BA:  MOVLW  02
071BC:  MOVWF  01
071BE:  MOVLB  0
071C0:  BRA    71C6
....................    
....................    return SUCCESS;
071C2:  MOVLW  00
071C4:  MOVWF  01
071C6:  RETURN 0
.................... }
.................... 
.................... int8 setPIDvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char  arg2;
....................    float arg3;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
074E4:  MOVLB  7
074E6:  CLRF   x5D
074E8:  MOVFF  6AB,75C
074EC:  CLRF   x5F
074EE:  MOVLW  B5
074F0:  MOVWF  x5E
074F2:  MOVLB  0
074F4:  CALL   086E
074F8:  MOVFF  02,728
074FC:  MOVFF  01,727
07500:  MOVLW  06
07502:  MOVLB  7
07504:  ADDWF  x27,F
07506:  MOVLW  00
07508:  ADDWFC x28,F
0750A:  MOVLW  32
0750C:  ADDWF  x27,W
0750E:  MOVWF  01
07510:  MOVLW  00
07512:  ADDWFC x28,W
07514:  MOVWF  03
07516:  MOVF   01,W
07518:  ADDLW  EB
0751A:  MOVWF  01
0751C:  MOVLW  01
0751E:  ADDWFC 03,F
07520:  MOVFF  01,727
07524:  MOVFF  03,728
07528:  MOVFF  03,74A
0752C:  MOVFF  01,749
07530:  MOVLB  0
07532:  CALL   5E5E
07536:  MOVF   01,F
07538:  BNZ   7542
0753A:  MOVLW  02
0753C:  MOVWF  01
0753E:  BRA    77C2
07540:  BRA    75A0
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07542:  MOVLB  7
07544:  CLRF   x5D
07546:  MOVFF  6AB,75C
0754A:  CLRF   x5F
0754C:  MOVLW  B5
0754E:  MOVWF  x5E
07550:  MOVLB  0
07552:  CALL   086E
07556:  MOVFF  02,728
0755A:  MOVFF  01,727
0755E:  MOVLW  06
07560:  MOVLB  7
07562:  ADDWF  x27,F
07564:  MOVLW  00
07566:  ADDWFC x28,F
07568:  MOVLW  32
0756A:  ADDWF  x27,W
0756C:  MOVWF  01
0756E:  MOVLW  00
07570:  ADDWFC x28,W
07572:  MOVWF  03
07574:  MOVF   01,W
07576:  ADDLW  EB
07578:  MOVWF  01
0757A:  MOVLW  01
0757C:  ADDWFC 03,F
0757E:  MOVFF  01,727
07582:  MOVFF  03,728
07586:  MOVFF  03,74A
0758A:  MOVFF  01,749
0758E:  CLRF   x4C
07590:  CLRF   x4B
07592:  MOVLW  0A
07594:  MOVWF  x4D
07596:  MOVLB  0
07598:  CALL   5F4E
0759C:  MOVFF  01,721
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
075A0:  MOVLB  7
075A2:  CLRF   x5D
075A4:  MOVFF  6AB,75C
075A8:  CLRF   x5F
075AA:  MOVLW  B5
075AC:  MOVWF  x5E
075AE:  MOVLB  0
075B0:  CALL   086E
075B4:  MOVFF  02,728
075B8:  MOVFF  01,727
075BC:  MOVLW  06
075BE:  MOVLB  7
075C0:  ADDWF  x27,F
075C2:  MOVLW  00
075C4:  ADDWFC x28,F
075C6:  MOVLW  4B
075C8:  ADDWF  x27,W
075CA:  MOVWF  01
075CC:  MOVLW  00
075CE:  ADDWFC x28,W
075D0:  MOVWF  03
075D2:  MOVF   01,W
075D4:  ADDLW  EB
075D6:  MOVWF  01
075D8:  MOVLW  01
075DA:  ADDWFC 03,F
075DC:  MOVFF  01,727
075E0:  MOVFF  03,728
075E4:  MOVFF  03,758
075E8:  MOVFF  01,757
075EC:  MOVLB  0
075EE:  CALL   5C7E
075F2:  MOVFF  02,03
075F6:  MOVF   01,W
075F8:  SUBLW  01
075FA:  BNZ   7600
075FC:  MOVF   03,F
075FE:  BZ    7608
07600:  MOVLW  02
07602:  MOVWF  01
07604:  BRA    77C2
07606:  BRA    7648
....................    else arg2 = SERcmd[rec].p[3][0];
07608:  MOVLB  7
0760A:  CLRF   x5D
0760C:  MOVFF  6AB,75C
07610:  CLRF   x5F
07612:  MOVLW  B5
07614:  MOVWF  x5E
07616:  MOVLB  0
07618:  CALL   086E
0761C:  MOVFF  02,728
07620:  MOVFF  01,727
07624:  MOVLW  06
07626:  MOVLB  7
07628:  ADDWF  x27,F
0762A:  MOVLW  00
0762C:  ADDWFC x28,F
0762E:  MOVLW  4B
07630:  ADDWF  x27,F
07632:  MOVLW  00
07634:  ADDWFC x28,F
07636:  MOVLW  EB
07638:  ADDWF  x27,W
0763A:  MOVWF  FE9
0763C:  MOVLW  01
0763E:  ADDWFC x28,W
07640:  MOVWF  FEA
07642:  MOVFF  FEF,722
07646:  MOVLB  0
....................    
....................    if (!arg_is_float(SERcmd[rec].p[4])) return INV_PARAM;
07648:  MOVLB  7
0764A:  CLRF   x5D
0764C:  MOVFF  6AB,75C
07650:  CLRF   x5F
07652:  MOVLW  B5
07654:  MOVWF  x5E
07656:  MOVLB  0
07658:  CALL   086E
0765C:  MOVFF  02,728
07660:  MOVFF  01,727
07664:  MOVLW  06
07666:  MOVLB  7
07668:  ADDWF  x27,F
0766A:  MOVLW  00
0766C:  ADDWFC x28,F
0766E:  MOVLW  64
07670:  ADDWF  x27,W
07672:  MOVWF  01
07674:  MOVLW  00
07676:  ADDWFC x28,W
07678:  MOVWF  03
0767A:  MOVF   01,W
0767C:  ADDLW  EB
0767E:  MOVWF  01
07680:  MOVLW  01
07682:  ADDWFC 03,F
07684:  MOVFF  01,727
07688:  MOVFF  03,728
0768C:  MOVFF  03,72B
07690:  MOVFF  01,72A
07694:  MOVLB  0
07696:  RCALL  71C8
07698:  MOVF   01,F
0769A:  BNZ   76A4
0769C:  MOVLW  02
0769E:  MOVWF  01
076A0:  BRA    77C2
076A2:  BRA    7708
....................    else arg3 = strtod(SERcmd[rec].p[4], '\0');
076A4:  MOVLB  7
076A6:  CLRF   x5D
076A8:  MOVFF  6AB,75C
076AC:  CLRF   x5F
076AE:  MOVLW  B5
076B0:  MOVWF  x5E
076B2:  MOVLB  0
076B4:  CALL   086E
076B8:  MOVFF  02,728
076BC:  MOVFF  01,727
076C0:  MOVLW  06
076C2:  MOVLB  7
076C4:  ADDWF  x27,F
076C6:  MOVLW  00
076C8:  ADDWFC x28,F
076CA:  MOVLW  64
076CC:  ADDWF  x27,W
076CE:  MOVWF  01
076D0:  MOVLW  00
076D2:  ADDWFC x28,W
076D4:  MOVWF  03
076D6:  MOVF   01,W
076D8:  ADDLW  EB
076DA:  MOVWF  01
076DC:  MOVLW  01
076DE:  ADDWFC 03,F
076E0:  MOVFF  01,727
076E4:  MOVFF  03,728
076E8:  MOVFF  03,72B
076EC:  MOVFF  01,72A
076F0:  CLRF   x2D
076F2:  CLRF   x2C
076F4:  MOVLB  0
076F6:  RCALL  728A
076F8:  MOVFF  03,726
076FC:  MOVFF  02,725
07700:  MOVFF  01,724
07704:  MOVFF  00,723
....................    
....................    /*** SET P, I, or D VALUE **********/
....................    if      ('P' == arg2) PID[arg1-1].kP = arg3;
07708:  MOVLB  7
0770A:  MOVF   x22,W
0770C:  SUBLW  50
0770E:  BNZ   773A
07710:  MOVLW  01
07712:  SUBWF  x21,W
07714:  MULLW  28
07716:  MOVF   FF3,W
07718:  CLRF   x28
0771A:  MOVWF  x27
0771C:  MOVLW  20
0771E:  ADDWF  x27,W
07720:  MOVWF  FE9
07722:  MOVLW  00
07724:  ADDWFC x28,W
07726:  MOVWF  FEA
07728:  MOVFF  723,FEF
0772C:  MOVFF  724,FEC
07730:  MOVFF  725,FEC
07734:  MOVFF  726,FEC
07738:  BRA    77BC
....................    else if ('I' == arg2) PID[arg1-1].kI = arg3;
0773A:  MOVF   x22,W
0773C:  SUBLW  49
0773E:  BNZ   7776
07740:  MOVLW  01
07742:  SUBWF  x21,W
07744:  MULLW  28
07746:  MOVF   FF3,W
07748:  CLRF   x28
0774A:  MOVWF  x27
0774C:  MOVLW  04
0774E:  ADDWF  x27,W
07750:  MOVWF  01
07752:  MOVLW  00
07754:  ADDWFC x28,W
07756:  MOVWF  03
07758:  MOVF   01,W
0775A:  ADDLW  20
0775C:  MOVWF  FE9
0775E:  MOVLW  00
07760:  ADDWFC 03,W
07762:  MOVWF  FEA
07764:  MOVFF  723,FEF
07768:  MOVFF  724,FEC
0776C:  MOVFF  725,FEC
07770:  MOVFF  726,FEC
07774:  BRA    77BC
....................    else if ('D' == arg2) PID[arg1-1].kD = arg3;
07776:  MOVF   x22,W
07778:  SUBLW  44
0777A:  BNZ   77B2
0777C:  MOVLW  01
0777E:  SUBWF  x21,W
07780:  MULLW  28
07782:  MOVF   FF3,W
07784:  CLRF   x28
07786:  MOVWF  x27
07788:  MOVLW  08
0778A:  ADDWF  x27,W
0778C:  MOVWF  01
0778E:  MOVLW  00
07790:  ADDWFC x28,W
07792:  MOVWF  03
07794:  MOVF   01,W
07796:  ADDLW  20
07798:  MOVWF  FE9
0779A:  MOVLW  00
0779C:  ADDWFC 03,W
0779E:  MOVWF  FEA
077A0:  MOVFF  723,FEF
077A4:  MOVFF  724,FEC
077A8:  MOVFF  725,FEC
077AC:  MOVFF  726,FEC
077B0:  BRA    77BC
....................    else return INV_PARAM;
077B2:  MOVLW  02
077B4:  MOVWF  01
077B6:  MOVLB  0
077B8:  BRA    77C2
077BA:  MOVLB  7
....................    
....................    return SUCCESS;
077BC:  MOVLW  00
077BE:  MOVWF  01
077C0:  MOVLB  0
077C2:  RETURN 0
.................... }
.................... 
.................... int8 getSetPoint(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
077C4:  MOVLB  7
077C6:  CLRF   x5D
077C8:  MOVFF  6AB,75C
077CC:  CLRF   x5F
077CE:  MOVLW  B5
077D0:  MOVWF  x5E
077D2:  MOVLB  0
077D4:  CALL   086E
077D8:  MOVFF  02,723
077DC:  MOVFF  01,722
077E0:  MOVLW  06
077E2:  MOVLB  7
077E4:  ADDWF  x22,F
077E6:  MOVLW  00
077E8:  ADDWFC x23,F
077EA:  MOVLW  32
077EC:  ADDWF  x22,W
077EE:  MOVWF  01
077F0:  MOVLW  00
077F2:  ADDWFC x23,W
077F4:  MOVWF  03
077F6:  MOVF   01,W
077F8:  ADDLW  EB
077FA:  MOVWF  01
077FC:  MOVLW  01
077FE:  ADDWFC 03,F
07800:  MOVFF  01,722
07804:  MOVFF  03,723
07808:  MOVFF  03,74A
0780C:  MOVFF  01,749
07810:  MOVLB  0
07812:  CALL   5E5E
07816:  MOVF   01,F
07818:  BNZ   7822
0781A:  MOVLW  02
0781C:  MOVWF  01
0781E:  BRA    7924
07820:  BRA    7880
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07822:  MOVLB  7
07824:  CLRF   x5D
07826:  MOVFF  6AB,75C
0782A:  CLRF   x5F
0782C:  MOVLW  B5
0782E:  MOVWF  x5E
07830:  MOVLB  0
07832:  CALL   086E
07836:  MOVFF  02,723
0783A:  MOVFF  01,722
0783E:  MOVLW  06
07840:  MOVLB  7
07842:  ADDWF  x22,F
07844:  MOVLW  00
07846:  ADDWFC x23,F
07848:  MOVLW  32
0784A:  ADDWF  x22,W
0784C:  MOVWF  01
0784E:  MOVLW  00
07850:  ADDWFC x23,W
07852:  MOVWF  03
07854:  MOVF   01,W
07856:  ADDLW  EB
07858:  MOVWF  01
0785A:  MOVLW  01
0785C:  ADDWFC 03,F
0785E:  MOVFF  01,722
07862:  MOVFF  03,723
07866:  MOVFF  03,74A
0786A:  MOVFF  01,749
0786E:  CLRF   x4C
07870:  CLRF   x4B
07872:  MOVLW  0A
07874:  MOVWF  x4D
07876:  MOVLB  0
07878:  CALL   5F4E
0787C:  MOVFF  01,721
....................    
....................    /*** GET SETPOINT ******************/ 
....................    sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].SP);
07880:  MOVLW  04
07882:  MOVLB  7
07884:  MOVWF  x58
07886:  MOVLW  C1
07888:  MOVWF  x57
0788A:  MOVLB  0
0788C:  CALL   5C7E
07890:  MOVF   01,W
07892:  ADDLW  C1
07894:  MOVLB  7
07896:  MOVWF  x22
07898:  MOVLW  04
0789A:  ADDWFC 02,W
0789C:  MOVWF  x23
0789E:  MOVLW  01
078A0:  SUBWF  x21,W
078A2:  MULLW  28
078A4:  MOVF   FF3,W
078A6:  CLRF   x25
078A8:  MOVWF  x24
078AA:  MOVLW  0C
078AC:  ADDWF  x24,W
078AE:  MOVWF  01
078B0:  MOVLW  00
078B2:  ADDWFC x25,W
078B4:  MOVWF  03
078B6:  MOVF   01,W
078B8:  ADDLW  20
078BA:  MOVWF  FE9
078BC:  MOVLW  00
078BE:  ADDWFC 03,W
078C0:  MOVWF  FEA
078C2:  MOVFF  FEF,724
078C6:  MOVFF  FEC,725
078CA:  MOVFF  FEC,726
078CE:  MOVFF  FEC,727
078D2:  MOVFF  723,565
078D6:  MOVFF  722,564
078DA:  MOVFF  721,74A
078DE:  MOVLW  18
078E0:  MOVWF  x4B
078E2:  MOVLB  0
078E4:  CALL   62A2
078E8:  MOVLW  2C
078EA:  MOVLB  7
078EC:  MOVWF  x66
078EE:  MOVLB  0
078F0:  CALL   5CB6
078F4:  MOVLW  89
078F6:  MOVWF  FE9
078F8:  MOVFF  727,75C
078FC:  MOVFF  726,75B
07900:  MOVFF  725,75A
07904:  MOVFF  724,759
07908:  MOVLW  02
0790A:  MOVLB  7
0790C:  MOVWF  x5D
0790E:  MOVLB  0
07910:  CALL   6B62
07914:  MOVLW  2C
07916:  MOVLB  7
07918:  MOVWF  x66
0791A:  MOVLB  0
0791C:  CALL   5CB6
....................    return SUCCESS;
07920:  MOVLW  00
07922:  MOVWF  01
07924:  RETURN 0
.................... }
.................... 
.................... int8 setSetPoint(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/   
....................    int8  arg1;
....................    float arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
07926:  MOVLB  7
07928:  CLRF   x5D
0792A:  MOVFF  6AB,75C
0792E:  CLRF   x5F
07930:  MOVLW  B5
07932:  MOVWF  x5E
07934:  MOVLB  0
07936:  CALL   086E
0793A:  MOVFF  02,727
0793E:  MOVFF  01,726
07942:  MOVLW  06
07944:  MOVLB  7
07946:  ADDWF  x26,F
07948:  MOVLW  00
0794A:  ADDWFC x27,F
0794C:  MOVLW  32
0794E:  ADDWF  x26,W
07950:  MOVWF  01
07952:  MOVLW  00
07954:  ADDWFC x27,W
07956:  MOVWF  03
07958:  MOVF   01,W
0795A:  ADDLW  EB
0795C:  MOVWF  01
0795E:  MOVLW  01
07960:  ADDWFC 03,F
07962:  MOVFF  01,726
07966:  MOVFF  03,727
0796A:  MOVFF  03,74A
0796E:  MOVFF  01,749
07972:  MOVLB  0
07974:  CALL   5E5E
07978:  MOVF   01,F
0797A:  BNZ   7984
0797C:  MOVLW  02
0797E:  MOVWF  01
07980:  BRA    7AE2
07982:  BRA    79E2
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07984:  MOVLB  7
07986:  CLRF   x5D
07988:  MOVFF  6AB,75C
0798C:  CLRF   x5F
0798E:  MOVLW  B5
07990:  MOVWF  x5E
07992:  MOVLB  0
07994:  CALL   086E
07998:  MOVFF  02,727
0799C:  MOVFF  01,726
079A0:  MOVLW  06
079A2:  MOVLB  7
079A4:  ADDWF  x26,F
079A6:  MOVLW  00
079A8:  ADDWFC x27,F
079AA:  MOVLW  32
079AC:  ADDWF  x26,W
079AE:  MOVWF  01
079B0:  MOVLW  00
079B2:  ADDWFC x27,W
079B4:  MOVWF  03
079B6:  MOVF   01,W
079B8:  ADDLW  EB
079BA:  MOVWF  01
079BC:  MOVLW  01
079BE:  ADDWFC 03,F
079C0:  MOVFF  01,726
079C4:  MOVFF  03,727
079C8:  MOVFF  03,74A
079CC:  MOVFF  01,749
079D0:  CLRF   x4C
079D2:  CLRF   x4B
079D4:  MOVLW  0A
079D6:  MOVWF  x4D
079D8:  MOVLB  0
079DA:  CALL   5F4E
079DE:  MOVFF  01,721
....................    
....................    if (!arg_is_float(SERcmd[rec].p[3])) return INV_PARAM;
079E2:  MOVLB  7
079E4:  CLRF   x5D
079E6:  MOVFF  6AB,75C
079EA:  CLRF   x5F
079EC:  MOVLW  B5
079EE:  MOVWF  x5E
079F0:  MOVLB  0
079F2:  CALL   086E
079F6:  MOVFF  02,727
079FA:  MOVFF  01,726
079FE:  MOVLW  06
07A00:  MOVLB  7
07A02:  ADDWF  x26,F
07A04:  MOVLW  00
07A06:  ADDWFC x27,F
07A08:  MOVLW  4B
07A0A:  ADDWF  x26,W
07A0C:  MOVWF  01
07A0E:  MOVLW  00
07A10:  ADDWFC x27,W
07A12:  MOVWF  03
07A14:  MOVF   01,W
07A16:  ADDLW  EB
07A18:  MOVWF  01
07A1A:  MOVLW  01
07A1C:  ADDWFC 03,F
07A1E:  MOVFF  01,726
07A22:  MOVFF  03,727
07A26:  MOVFF  03,72B
07A2A:  MOVFF  01,72A
07A2E:  MOVLB  0
07A30:  CALL   71C8
07A34:  MOVF   01,F
07A36:  BNZ   7A40
07A38:  MOVLW  02
07A3A:  MOVWF  01
07A3C:  BRA    7AE2
07A3E:  BRA    7AA6
....................    else arg2 = strtod(SERcmd[rec].p[3], '\0');
07A40:  MOVLB  7
07A42:  CLRF   x5D
07A44:  MOVFF  6AB,75C
07A48:  CLRF   x5F
07A4A:  MOVLW  B5
07A4C:  MOVWF  x5E
07A4E:  MOVLB  0
07A50:  CALL   086E
07A54:  MOVFF  02,727
07A58:  MOVFF  01,726
07A5C:  MOVLW  06
07A5E:  MOVLB  7
07A60:  ADDWF  x26,F
07A62:  MOVLW  00
07A64:  ADDWFC x27,F
07A66:  MOVLW  4B
07A68:  ADDWF  x26,W
07A6A:  MOVWF  01
07A6C:  MOVLW  00
07A6E:  ADDWFC x27,W
07A70:  MOVWF  03
07A72:  MOVF   01,W
07A74:  ADDLW  EB
07A76:  MOVWF  01
07A78:  MOVLW  01
07A7A:  ADDWFC 03,F
07A7C:  MOVFF  01,726
07A80:  MOVFF  03,727
07A84:  MOVFF  03,72B
07A88:  MOVFF  01,72A
07A8C:  CLRF   x2D
07A8E:  CLRF   x2C
07A90:  MOVLB  0
07A92:  CALL   728A
07A96:  MOVFF  03,725
07A9A:  MOVFF  02,724
07A9E:  MOVFF  01,723
07AA2:  MOVFF  00,722
....................    
....................    /*** SET SETPOINT ******************/ 
....................    PID[arg1-1].SP = arg2;
07AA6:  MOVLW  01
07AA8:  MOVLB  7
07AAA:  SUBWF  x21,W
07AAC:  MULLW  28
07AAE:  MOVF   FF3,W
07AB0:  CLRF   x27
07AB2:  MOVWF  x26
07AB4:  MOVLW  0C
07AB6:  ADDWF  x26,W
07AB8:  MOVWF  01
07ABA:  MOVLW  00
07ABC:  ADDWFC x27,W
07ABE:  MOVWF  03
07AC0:  MOVF   01,W
07AC2:  ADDLW  20
07AC4:  MOVWF  FE9
07AC6:  MOVLW  00
07AC8:  ADDWFC 03,W
07ACA:  MOVWF  FEA
07ACC:  MOVFF  722,FEF
07AD0:  MOVFF  723,FEC
07AD4:  MOVFF  724,FEC
07AD8:  MOVFF  725,FEC
....................    
....................    return SUCCESS;
07ADC:  MOVLW  00
07ADE:  MOVWF  01
07AE0:  MOVLB  0
07AE2:  RETURN 0
.................... }
.................... 
.................... int8 getAllSensorCalParams(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
07AE4:  MOVLB  7
07AE6:  CLRF   x5D
07AE8:  MOVFF  6AB,75C
07AEC:  CLRF   x5F
07AEE:  MOVLW  B5
07AF0:  MOVWF  x5E
07AF2:  MOVLB  0
07AF4:  CALL   086E
07AF8:  MOVFF  02,723
07AFC:  MOVFF  01,722
07B00:  MOVLW  06
07B02:  MOVLB  7
07B04:  ADDWF  x22,F
07B06:  MOVLW  00
07B08:  ADDWFC x23,F
07B0A:  MOVLW  32
07B0C:  ADDWF  x22,W
07B0E:  MOVWF  01
07B10:  MOVLW  00
07B12:  ADDWFC x23,W
07B14:  MOVWF  03
07B16:  MOVF   01,W
07B18:  ADDLW  EB
07B1A:  MOVWF  01
07B1C:  MOVLW  01
07B1E:  ADDWFC 03,F
07B20:  MOVFF  01,722
07B24:  MOVFF  03,723
07B28:  MOVFF  03,74A
07B2C:  MOVFF  01,749
07B30:  MOVLB  0
07B32:  CALL   5E5E
07B36:  MOVF   01,F
07B38:  BNZ   7B42
07B3A:  MOVLW  02
07B3C:  MOVWF  01
07B3E:  BRA    7E98
07B40:  BRA    7BA0
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07B42:  MOVLB  7
07B44:  CLRF   x5D
07B46:  MOVFF  6AB,75C
07B4A:  CLRF   x5F
07B4C:  MOVLW  B5
07B4E:  MOVWF  x5E
07B50:  MOVLB  0
07B52:  CALL   086E
07B56:  MOVFF  02,723
07B5A:  MOVFF  01,722
07B5E:  MOVLW  06
07B60:  MOVLB  7
07B62:  ADDWF  x22,F
07B64:  MOVLW  00
07B66:  ADDWFC x23,F
07B68:  MOVLW  32
07B6A:  ADDWF  x22,W
07B6C:  MOVWF  01
07B6E:  MOVLW  00
07B70:  ADDWFC x23,W
07B72:  MOVWF  03
07B74:  MOVF   01,W
07B76:  ADDLW  EB
07B78:  MOVWF  01
07B7A:  MOVLW  01
07B7C:  ADDWFC 03,F
07B7E:  MOVFF  01,722
07B82:  MOVFF  03,723
07B86:  MOVFF  03,74A
07B8A:  MOVFF  01,749
07B8E:  CLRF   x4C
07B90:  CLRF   x4B
07B92:  MOVLW  0A
07B94:  MOVWF  x4D
07B96:  MOVLB  0
07B98:  CALL   5F4E
07B9C:  MOVFF  01,721
....................    
....................    /*** GET ALL SENSOR CAL PARAMS *****/
....................    sprintf(retData+strlen(retData), "%d,", arg1);
07BA0:  MOVLW  04
07BA2:  MOVLB  7
07BA4:  MOVWF  x58
07BA6:  MOVLW  C1
07BA8:  MOVWF  x57
07BAA:  MOVLB  0
07BAC:  CALL   5C7E
07BB0:  MOVFF  02,03
07BB4:  MOVF   01,W
07BB6:  ADDLW  C1
07BB8:  MOVLB  7
07BBA:  MOVWF  x22
07BBC:  MOVLW  04
07BBE:  ADDWFC 02,W
07BC0:  MOVWF  x23
07BC2:  MOVFF  FE8,565
07BC6:  MOVFF  722,564
07BCA:  MOVFF  721,74A
07BCE:  MOVLW  18
07BD0:  MOVWF  x4B
07BD2:  MOVLB  0
07BD4:  CALL   62A2
07BD8:  MOVLW  2C
07BDA:  MOVLB  7
07BDC:  MOVWF  x66
07BDE:  MOVLB  0
07BE0:  CALL   5CB6
....................    sprintf(retData+strlen(retData), "%.5f,", sensorCal[arg1-1].c0);
07BE4:  MOVLW  04
07BE6:  MOVLB  7
07BE8:  MOVWF  x58
07BEA:  MOVLW  C1
07BEC:  MOVWF  x57
07BEE:  MOVLB  0
07BF0:  CALL   5C7E
07BF4:  MOVFF  02,03
07BF8:  MOVF   01,W
07BFA:  ADDLW  C1
07BFC:  MOVLB  7
07BFE:  MOVWF  x22
07C00:  MOVLW  04
07C02:  ADDWFC 02,W
07C04:  MOVWF  x23
07C06:  MOVLW  01
07C08:  SUBWF  x21,W
07C0A:  MULLW  18
07C0C:  MOVF   FF3,W
07C0E:  CLRF   x25
07C10:  MOVWF  x24
07C12:  MOVLW  92
07C14:  ADDWF  x24,W
07C16:  MOVWF  FE9
07C18:  MOVLW  00
07C1A:  ADDWFC x25,W
07C1C:  MOVWF  FEA
07C1E:  MOVFF  FEF,759
07C22:  MOVFF  FEC,75A
07C26:  MOVFF  FEC,75B
07C2A:  MOVFF  FEC,75C
07C2E:  MOVFF  723,565
07C32:  MOVFF  722,564
07C36:  MOVLW  89
07C38:  MOVWF  FE9
07C3A:  MOVLW  05
07C3C:  MOVWF  x5D
07C3E:  MOVLB  0
07C40:  CALL   6B62
07C44:  MOVLW  2C
07C46:  MOVLB  7
07C48:  MOVWF  x66
07C4A:  MOVLB  0
07C4C:  CALL   5CB6
....................    sprintf(retData+strlen(retData), "%.5f,", sensorCal[arg1-1].c1);
07C50:  MOVLW  04
07C52:  MOVLB  7
07C54:  MOVWF  x58
07C56:  MOVLW  C1
07C58:  MOVWF  x57
07C5A:  MOVLB  0
07C5C:  CALL   5C7E
07C60:  MOVF   01,W
07C62:  ADDLW  C1
07C64:  MOVLB  7
07C66:  MOVWF  x22
07C68:  MOVLW  04
07C6A:  ADDWFC 02,W
07C6C:  MOVWF  x23
07C6E:  MOVLW  01
07C70:  SUBWF  x21,W
07C72:  MULLW  18
07C74:  MOVF   FF3,W
07C76:  CLRF   x25
07C78:  MOVWF  x24
07C7A:  MOVLW  04
07C7C:  ADDWF  x24,W
07C7E:  MOVWF  01
07C80:  MOVLW  00
07C82:  ADDWFC x25,W
07C84:  MOVWF  03
07C86:  MOVF   01,W
07C88:  ADDLW  92
07C8A:  MOVWF  FE9
07C8C:  MOVLW  00
07C8E:  ADDWFC 03,W
07C90:  MOVWF  FEA
07C92:  MOVFF  FEF,759
07C96:  MOVFF  FEC,75A
07C9A:  MOVFF  FEC,75B
07C9E:  MOVFF  FEC,75C
07CA2:  MOVFF  723,565
07CA6:  MOVFF  722,564
07CAA:  MOVLW  89
07CAC:  MOVWF  FE9
07CAE:  MOVLW  05
07CB0:  MOVWF  x5D
07CB2:  MOVLB  0
07CB4:  CALL   6B62
07CB8:  MOVLW  2C
07CBA:  MOVLB  7
07CBC:  MOVWF  x66
07CBE:  MOVLB  0
07CC0:  CALL   5CB6
....................    sprintf(retData+strlen(retData), "%.5f,", sensorCal[arg1-1].c2);
07CC4:  MOVLW  04
07CC6:  MOVLB  7
07CC8:  MOVWF  x58
07CCA:  MOVLW  C1
07CCC:  MOVWF  x57
07CCE:  MOVLB  0
07CD0:  CALL   5C7E
07CD4:  MOVF   01,W
07CD6:  ADDLW  C1
07CD8:  MOVLB  7
07CDA:  MOVWF  x22
07CDC:  MOVLW  04
07CDE:  ADDWFC 02,W
07CE0:  MOVWF  x23
07CE2:  MOVLW  01
07CE4:  SUBWF  x21,W
07CE6:  MULLW  18
07CE8:  MOVF   FF3,W
07CEA:  CLRF   x25
07CEC:  MOVWF  x24
07CEE:  MOVLW  08
07CF0:  ADDWF  x24,W
07CF2:  MOVWF  01
07CF4:  MOVLW  00
07CF6:  ADDWFC x25,W
07CF8:  MOVWF  03
07CFA:  MOVF   01,W
07CFC:  ADDLW  92
07CFE:  MOVWF  FE9
07D00:  MOVLW  00
07D02:  ADDWFC 03,W
07D04:  MOVWF  FEA
07D06:  MOVFF  FEF,759
07D0A:  MOVFF  FEC,75A
07D0E:  MOVFF  FEC,75B
07D12:  MOVFF  FEC,75C
07D16:  MOVFF  723,565
07D1A:  MOVFF  722,564
07D1E:  MOVLW  89
07D20:  MOVWF  FE9
07D22:  MOVLW  05
07D24:  MOVWF  x5D
07D26:  MOVLB  0
07D28:  CALL   6B62
07D2C:  MOVLW  2C
07D2E:  MOVLB  7
07D30:  MOVWF  x66
07D32:  MOVLB  0
07D34:  CALL   5CB6
....................    sprintf(retData+strlen(retData), "%.5f,", sensorCal[arg1-1].c3);
07D38:  MOVLW  04
07D3A:  MOVLB  7
07D3C:  MOVWF  x58
07D3E:  MOVLW  C1
07D40:  MOVWF  x57
07D42:  MOVLB  0
07D44:  CALL   5C7E
07D48:  MOVF   01,W
07D4A:  ADDLW  C1
07D4C:  MOVLB  7
07D4E:  MOVWF  x22
07D50:  MOVLW  04
07D52:  ADDWFC 02,W
07D54:  MOVWF  x23
07D56:  MOVLW  01
07D58:  SUBWF  x21,W
07D5A:  MULLW  18
07D5C:  MOVF   FF3,W
07D5E:  CLRF   x25
07D60:  MOVWF  x24
07D62:  MOVLW  0C
07D64:  ADDWF  x24,W
07D66:  MOVWF  01
07D68:  MOVLW  00
07D6A:  ADDWFC x25,W
07D6C:  MOVWF  03
07D6E:  MOVF   01,W
07D70:  ADDLW  92
07D72:  MOVWF  FE9
07D74:  MOVLW  00
07D76:  ADDWFC 03,W
07D78:  MOVWF  FEA
07D7A:  MOVFF  FEF,759
07D7E:  MOVFF  FEC,75A
07D82:  MOVFF  FEC,75B
07D86:  MOVFF  FEC,75C
07D8A:  MOVFF  723,565
07D8E:  MOVFF  722,564
07D92:  MOVLW  89
07D94:  MOVWF  FE9
07D96:  MOVLW  05
07D98:  MOVWF  x5D
07D9A:  MOVLB  0
07D9C:  CALL   6B62
07DA0:  MOVLW  2C
07DA2:  MOVLB  7
07DA4:  MOVWF  x66
07DA6:  MOVLB  0
07DA8:  CALL   5CB6
....................    sprintf(retData+strlen(retData), "%.5f,", sensorCal[arg1-1].c4);
07DAC:  MOVLW  04
07DAE:  MOVLB  7
07DB0:  MOVWF  x58
07DB2:  MOVLW  C1
07DB4:  MOVWF  x57
07DB6:  MOVLB  0
07DB8:  CALL   5C7E
07DBC:  MOVF   01,W
07DBE:  ADDLW  C1
07DC0:  MOVLB  7
07DC2:  MOVWF  x22
07DC4:  MOVLW  04
07DC6:  ADDWFC 02,W
07DC8:  MOVWF  x23
07DCA:  MOVLW  01
07DCC:  SUBWF  x21,W
07DCE:  MULLW  18
07DD0:  MOVF   FF3,W
07DD2:  CLRF   x25
07DD4:  MOVWF  x24
07DD6:  MOVLW  10
07DD8:  ADDWF  x24,W
07DDA:  MOVWF  01
07DDC:  MOVLW  00
07DDE:  ADDWFC x25,W
07DE0:  MOVWF  03
07DE2:  MOVF   01,W
07DE4:  ADDLW  92
07DE6:  MOVWF  FE9
07DE8:  MOVLW  00
07DEA:  ADDWFC 03,W
07DEC:  MOVWF  FEA
07DEE:  MOVFF  FEF,759
07DF2:  MOVFF  FEC,75A
07DF6:  MOVFF  FEC,75B
07DFA:  MOVFF  FEC,75C
07DFE:  MOVFF  723,565
07E02:  MOVFF  722,564
07E06:  MOVLW  89
07E08:  MOVWF  FE9
07E0A:  MOVLW  05
07E0C:  MOVWF  x5D
07E0E:  MOVLB  0
07E10:  CALL   6B62
07E14:  MOVLW  2C
07E16:  MOVLB  7
07E18:  MOVWF  x66
07E1A:  MOVLB  0
07E1C:  CALL   5CB6
....................    sprintf(retData+strlen(retData), "%.5f,", sensorCal[arg1-1].c5);
07E20:  MOVLW  04
07E22:  MOVLB  7
07E24:  MOVWF  x58
07E26:  MOVLW  C1
07E28:  MOVWF  x57
07E2A:  MOVLB  0
07E2C:  CALL   5C7E
07E30:  MOVF   01,W
07E32:  ADDLW  C1
07E34:  MOVLB  7
07E36:  MOVWF  x22
07E38:  MOVLW  04
07E3A:  ADDWFC 02,W
07E3C:  MOVWF  x23
07E3E:  MOVLW  01
07E40:  SUBWF  x21,W
07E42:  MULLW  18
07E44:  MOVF   FF3,W
07E46:  CLRF   x25
07E48:  MOVWF  x24
07E4A:  MOVLW  14
07E4C:  ADDWF  x24,W
07E4E:  MOVWF  01
07E50:  MOVLW  00
07E52:  ADDWFC x25,W
07E54:  MOVWF  03
07E56:  MOVF   01,W
07E58:  ADDLW  92
07E5A:  MOVWF  FE9
07E5C:  MOVLW  00
07E5E:  ADDWFC 03,W
07E60:  MOVWF  FEA
07E62:  MOVFF  FEF,759
07E66:  MOVFF  FEC,75A
07E6A:  MOVFF  FEC,75B
07E6E:  MOVFF  FEC,75C
07E72:  MOVFF  723,565
07E76:  MOVFF  722,564
07E7A:  MOVLW  89
07E7C:  MOVWF  FE9
07E7E:  MOVLW  05
07E80:  MOVWF  x5D
07E82:  MOVLB  0
07E84:  CALL   6B62
07E88:  MOVLW  2C
07E8A:  MOVLB  7
07E8C:  MOVWF  x66
07E8E:  MOVLB  0
07E90:  CALL   5CB6
....................    
....................    return SUCCESS;
07E94:  MOVLW  00
07E96:  MOVWF  01
07E98:  RETURN 0
.................... }
.................... 
.................... int8 getSensorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
07E9A:  MOVLB  7
07E9C:  CLRF   x5D
07E9E:  MOVFF  6AB,75C
07EA2:  CLRF   x5F
07EA4:  MOVLW  B5
07EA6:  MOVWF  x5E
07EA8:  MOVLB  0
07EAA:  CALL   086E
07EAE:  MOVFF  02,724
07EB2:  MOVFF  01,723
07EB6:  MOVLW  06
07EB8:  MOVLB  7
07EBA:  ADDWF  x23,F
07EBC:  MOVLW  00
07EBE:  ADDWFC x24,F
07EC0:  MOVLW  32
07EC2:  ADDWF  x23,W
07EC4:  MOVWF  01
07EC6:  MOVLW  00
07EC8:  ADDWFC x24,W
07ECA:  MOVWF  03
07ECC:  MOVF   01,W
07ECE:  ADDLW  EB
07ED0:  MOVWF  01
07ED2:  MOVLW  01
07ED4:  ADDWFC 03,F
07ED6:  MOVFF  01,723
07EDA:  MOVFF  03,724
07EDE:  MOVFF  03,74A
07EE2:  MOVFF  01,749
07EE6:  MOVLB  0
07EE8:  CALL   5E5E
07EEC:  MOVF   01,F
07EEE:  BNZ   7EF8
07EF0:  MOVLW  02
07EF2:  MOVWF  01
07EF4:  BRA    83F4
07EF6:  BRA    7F56
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07EF8:  MOVLB  7
07EFA:  CLRF   x5D
07EFC:  MOVFF  6AB,75C
07F00:  CLRF   x5F
07F02:  MOVLW  B5
07F04:  MOVWF  x5E
07F06:  MOVLB  0
07F08:  CALL   086E
07F0C:  MOVFF  02,724
07F10:  MOVFF  01,723
07F14:  MOVLW  06
07F16:  MOVLB  7
07F18:  ADDWF  x23,F
07F1A:  MOVLW  00
07F1C:  ADDWFC x24,F
07F1E:  MOVLW  32
07F20:  ADDWF  x23,W
07F22:  MOVWF  01
07F24:  MOVLW  00
07F26:  ADDWFC x24,W
07F28:  MOVWF  03
07F2A:  MOVF   01,W
07F2C:  ADDLW  EB
07F2E:  MOVWF  01
07F30:  MOVLW  01
07F32:  ADDWFC 03,F
07F34:  MOVFF  01,723
07F38:  MOVFF  03,724
07F3C:  MOVFF  03,74A
07F40:  MOVFF  01,749
07F44:  CLRF   x4C
07F46:  CLRF   x4B
07F48:  MOVLW  0A
07F4A:  MOVWF  x4D
07F4C:  MOVLB  0
07F4E:  CALL   5F4E
07F52:  MOVFF  01,721
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
07F56:  MOVLB  7
07F58:  CLRF   x5D
07F5A:  MOVFF  6AB,75C
07F5E:  CLRF   x5F
07F60:  MOVLW  B5
07F62:  MOVWF  x5E
07F64:  MOVLB  0
07F66:  CALL   086E
07F6A:  MOVFF  02,724
07F6E:  MOVFF  01,723
07F72:  MOVLW  06
07F74:  MOVLB  7
07F76:  ADDWF  x23,F
07F78:  MOVLW  00
07F7A:  ADDWFC x24,F
07F7C:  MOVLW  4B
07F7E:  ADDWF  x23,W
07F80:  MOVWF  01
07F82:  MOVLW  00
07F84:  ADDWFC x24,W
07F86:  MOVWF  03
07F88:  MOVF   01,W
07F8A:  ADDLW  EB
07F8C:  MOVWF  01
07F8E:  MOVLW  01
07F90:  ADDWFC 03,F
07F92:  MOVFF  01,723
07F96:  MOVFF  03,724
07F9A:  MOVFF  03,758
07F9E:  MOVFF  01,757
07FA2:  MOVLB  0
07FA4:  CALL   5C7E
07FA8:  MOVFF  02,03
07FAC:  MOVF   01,W
07FAE:  SUBLW  01
07FB0:  BNZ   7FB6
07FB2:  MOVF   03,F
07FB4:  BZ    7FBE
07FB6:  MOVLW  02
07FB8:  MOVWF  01
07FBA:  BRA    83F4
07FBC:  BRA    7FFE
....................    else arg2 = SERcmd[rec].p[3][0];
07FBE:  MOVLB  7
07FC0:  CLRF   x5D
07FC2:  MOVFF  6AB,75C
07FC6:  CLRF   x5F
07FC8:  MOVLW  B5
07FCA:  MOVWF  x5E
07FCC:  MOVLB  0
07FCE:  CALL   086E
07FD2:  MOVFF  02,724
07FD6:  MOVFF  01,723
07FDA:  MOVLW  06
07FDC:  MOVLB  7
07FDE:  ADDWF  x23,F
07FE0:  MOVLW  00
07FE2:  ADDWFC x24,F
07FE4:  MOVLW  4B
07FE6:  ADDWF  x23,F
07FE8:  MOVLW  00
07FEA:  ADDWFC x24,F
07FEC:  MOVLW  EB
07FEE:  ADDWF  x23,W
07FF0:  MOVWF  FE9
07FF2:  MOVLW  01
07FF4:  ADDWFC x24,W
07FF6:  MOVWF  FEA
07FF8:  MOVFF  FEF,722
07FFC:  MOVLB  0
....................    
....................    /*** GET SENSOR CAL PARAM **********/
....................    if      ('0' == arg2) sprintf(retData+strlen(retData), "%d,%.5f,", arg1, sensorCal[arg1-1].c0);
07FFE:  MOVLB  7
08000:  MOVF   x22,W
08002:  SUBLW  30
08004:  BNZ   80A0
08006:  MOVLW  04
08008:  MOVWF  x58
0800A:  MOVLW  C1
0800C:  MOVWF  x57
0800E:  MOVLB  0
08010:  CALL   5C7E
08014:  MOVFF  02,03
08018:  MOVF   01,W
0801A:  ADDLW  C1
0801C:  MOVLB  7
0801E:  MOVWF  x23
08020:  MOVLW  04
08022:  ADDWFC 02,W
08024:  MOVWF  x24
08026:  MOVLW  01
08028:  SUBWF  x21,W
0802A:  MULLW  18
0802C:  MOVF   FF3,W
0802E:  CLRF   x26
08030:  MOVWF  x25
08032:  MOVLW  92
08034:  ADDWF  x25,W
08036:  MOVWF  FE9
08038:  MOVLW  00
0803A:  ADDWFC x26,W
0803C:  MOVWF  FEA
0803E:  MOVFF  FEF,727
08042:  MOVFF  FEC,728
08046:  MOVFF  FEC,729
0804A:  MOVFF  FEC,72A
0804E:  MOVFF  724,565
08052:  MOVFF  723,564
08056:  MOVFF  721,74A
0805A:  MOVLW  18
0805C:  MOVWF  x4B
0805E:  MOVLB  0
08060:  CALL   62A2
08064:  MOVLW  2C
08066:  MOVLB  7
08068:  MOVWF  x66
0806A:  MOVLB  0
0806C:  CALL   5CB6
08070:  MOVLW  89
08072:  MOVWF  FE9
08074:  MOVFF  72A,75C
08078:  MOVFF  729,75B
0807C:  MOVFF  728,75A
08080:  MOVFF  727,759
08084:  MOVLW  05
08086:  MOVLB  7
08088:  MOVWF  x5D
0808A:  MOVLB  0
0808C:  CALL   6B62
08090:  MOVLW  2C
08092:  MOVLB  7
08094:  MOVWF  x66
08096:  MOVLB  0
08098:  CALL   5CB6
0809C:  BRA    83F0
0809E:  MOVLB  7
....................    else if ('1' == arg2) sprintf(retData+strlen(retData), "%d,%.5f,", arg1, sensorCal[arg1-1].c1);
080A0:  MOVF   x22,W
080A2:  SUBLW  31
080A4:  BNZ   8148
080A6:  MOVLW  04
080A8:  MOVWF  x58
080AA:  MOVLW  C1
080AC:  MOVWF  x57
080AE:  MOVLB  0
080B0:  CALL   5C7E
080B4:  MOVF   01,W
080B6:  ADDLW  C1
080B8:  MOVLB  7
080BA:  MOVWF  x23
080BC:  MOVLW  04
080BE:  ADDWFC 02,W
080C0:  MOVWF  x24
080C2:  MOVLW  01
080C4:  SUBWF  x21,W
080C6:  MULLW  18
080C8:  MOVF   FF3,W
080CA:  CLRF   x26
080CC:  MOVWF  x25
080CE:  MOVLW  04
080D0:  ADDWF  x25,W
080D2:  MOVWF  01
080D4:  MOVLW  00
080D6:  ADDWFC x26,W
080D8:  MOVWF  03
080DA:  MOVF   01,W
080DC:  ADDLW  92
080DE:  MOVWF  FE9
080E0:  MOVLW  00
080E2:  ADDWFC 03,W
080E4:  MOVWF  FEA
080E6:  MOVFF  FEF,725
080EA:  MOVFF  FEC,726
080EE:  MOVFF  FEC,727
080F2:  MOVFF  FEC,728
080F6:  MOVFF  724,565
080FA:  MOVFF  723,564
080FE:  MOVFF  721,74A
08102:  MOVLW  18
08104:  MOVWF  x4B
08106:  MOVLB  0
08108:  CALL   62A2
0810C:  MOVLW  2C
0810E:  MOVLB  7
08110:  MOVWF  x66
08112:  MOVLB  0
08114:  CALL   5CB6
08118:  MOVLW  89
0811A:  MOVWF  FE9
0811C:  MOVFF  728,75C
08120:  MOVFF  727,75B
08124:  MOVFF  726,75A
08128:  MOVFF  725,759
0812C:  MOVLW  05
0812E:  MOVLB  7
08130:  MOVWF  x5D
08132:  MOVLB  0
08134:  CALL   6B62
08138:  MOVLW  2C
0813A:  MOVLB  7
0813C:  MOVWF  x66
0813E:  MOVLB  0
08140:  CALL   5CB6
08144:  BRA    83F0
08146:  MOVLB  7
....................    else if ('2' == arg2) sprintf(retData+strlen(retData), "%d,%.5f,", arg1, sensorCal[arg1-1].c2);
08148:  MOVF   x22,W
0814A:  SUBLW  32
0814C:  BNZ   81F0
0814E:  MOVLW  04
08150:  MOVWF  x58
08152:  MOVLW  C1
08154:  MOVWF  x57
08156:  MOVLB  0
08158:  CALL   5C7E
0815C:  MOVF   01,W
0815E:  ADDLW  C1
08160:  MOVLB  7
08162:  MOVWF  x23
08164:  MOVLW  04
08166:  ADDWFC 02,W
08168:  MOVWF  x24
0816A:  MOVLW  01
0816C:  SUBWF  x21,W
0816E:  MULLW  18
08170:  MOVF   FF3,W
08172:  CLRF   x26
08174:  MOVWF  x25
08176:  MOVLW  08
08178:  ADDWF  x25,W
0817A:  MOVWF  01
0817C:  MOVLW  00
0817E:  ADDWFC x26,W
08180:  MOVWF  03
08182:  MOVF   01,W
08184:  ADDLW  92
08186:  MOVWF  FE9
08188:  MOVLW  00
0818A:  ADDWFC 03,W
0818C:  MOVWF  FEA
0818E:  MOVFF  FEF,725
08192:  MOVFF  FEC,726
08196:  MOVFF  FEC,727
0819A:  MOVFF  FEC,728
0819E:  MOVFF  724,565
081A2:  MOVFF  723,564
081A6:  MOVFF  721,74A
081AA:  MOVLW  18
081AC:  MOVWF  x4B
081AE:  MOVLB  0
081B0:  CALL   62A2
081B4:  MOVLW  2C
081B6:  MOVLB  7
081B8:  MOVWF  x66
081BA:  MOVLB  0
081BC:  CALL   5CB6
081C0:  MOVLW  89
081C2:  MOVWF  FE9
081C4:  MOVFF  728,75C
081C8:  MOVFF  727,75B
081CC:  MOVFF  726,75A
081D0:  MOVFF  725,759
081D4:  MOVLW  05
081D6:  MOVLB  7
081D8:  MOVWF  x5D
081DA:  MOVLB  0
081DC:  CALL   6B62
081E0:  MOVLW  2C
081E2:  MOVLB  7
081E4:  MOVWF  x66
081E6:  MOVLB  0
081E8:  CALL   5CB6
081EC:  BRA    83F0
081EE:  MOVLB  7
....................    else if ('3' == arg2) sprintf(retData+strlen(retData), "%d,%.5f,", arg1, sensorCal[arg1-1].c3);
081F0:  MOVF   x22,W
081F2:  SUBLW  33
081F4:  BNZ   8298
081F6:  MOVLW  04
081F8:  MOVWF  x58
081FA:  MOVLW  C1
081FC:  MOVWF  x57
081FE:  MOVLB  0
08200:  CALL   5C7E
08204:  MOVF   01,W
08206:  ADDLW  C1
08208:  MOVLB  7
0820A:  MOVWF  x23
0820C:  MOVLW  04
0820E:  ADDWFC 02,W
08210:  MOVWF  x24
08212:  MOVLW  01
08214:  SUBWF  x21,W
08216:  MULLW  18
08218:  MOVF   FF3,W
0821A:  CLRF   x26
0821C:  MOVWF  x25
0821E:  MOVLW  0C
08220:  ADDWF  x25,W
08222:  MOVWF  01
08224:  MOVLW  00
08226:  ADDWFC x26,W
08228:  MOVWF  03
0822A:  MOVF   01,W
0822C:  ADDLW  92
0822E:  MOVWF  FE9
08230:  MOVLW  00
08232:  ADDWFC 03,W
08234:  MOVWF  FEA
08236:  MOVFF  FEF,725
0823A:  MOVFF  FEC,726
0823E:  MOVFF  FEC,727
08242:  MOVFF  FEC,728
08246:  MOVFF  724,565
0824A:  MOVFF  723,564
0824E:  MOVFF  721,74A
08252:  MOVLW  18
08254:  MOVWF  x4B
08256:  MOVLB  0
08258:  CALL   62A2
0825C:  MOVLW  2C
0825E:  MOVLB  7
08260:  MOVWF  x66
08262:  MOVLB  0
08264:  CALL   5CB6
08268:  MOVLW  89
0826A:  MOVWF  FE9
0826C:  MOVFF  728,75C
08270:  MOVFF  727,75B
08274:  MOVFF  726,75A
08278:  MOVFF  725,759
0827C:  MOVLW  05
0827E:  MOVLB  7
08280:  MOVWF  x5D
08282:  MOVLB  0
08284:  CALL   6B62
08288:  MOVLW  2C
0828A:  MOVLB  7
0828C:  MOVWF  x66
0828E:  MOVLB  0
08290:  CALL   5CB6
08294:  BRA    83F0
08296:  MOVLB  7
....................    else if ('4' == arg2) sprintf(retData+strlen(retData), "%d,%.5f,", arg1, sensorCal[arg1-1].c4);
08298:  MOVF   x22,W
0829A:  SUBLW  34
0829C:  BNZ   8340
0829E:  MOVLW  04
082A0:  MOVWF  x58
082A2:  MOVLW  C1
082A4:  MOVWF  x57
082A6:  MOVLB  0
082A8:  CALL   5C7E
082AC:  MOVF   01,W
082AE:  ADDLW  C1
082B0:  MOVLB  7
082B2:  MOVWF  x23
082B4:  MOVLW  04
082B6:  ADDWFC 02,W
082B8:  MOVWF  x24
082BA:  MOVLW  01
082BC:  SUBWF  x21,W
082BE:  MULLW  18
082C0:  MOVF   FF3,W
082C2:  CLRF   x26
082C4:  MOVWF  x25
082C6:  MOVLW  10
082C8:  ADDWF  x25,W
082CA:  MOVWF  01
082CC:  MOVLW  00
082CE:  ADDWFC x26,W
082D0:  MOVWF  03
082D2:  MOVF   01,W
082D4:  ADDLW  92
082D6:  MOVWF  FE9
082D8:  MOVLW  00
082DA:  ADDWFC 03,W
082DC:  MOVWF  FEA
082DE:  MOVFF  FEF,725
082E2:  MOVFF  FEC,726
082E6:  MOVFF  FEC,727
082EA:  MOVFF  FEC,728
082EE:  MOVFF  724,565
082F2:  MOVFF  723,564
082F6:  MOVFF  721,74A
082FA:  MOVLW  18
082FC:  MOVWF  x4B
082FE:  MOVLB  0
08300:  CALL   62A2
08304:  MOVLW  2C
08306:  MOVLB  7
08308:  MOVWF  x66
0830A:  MOVLB  0
0830C:  CALL   5CB6
08310:  MOVLW  89
08312:  MOVWF  FE9
08314:  MOVFF  728,75C
08318:  MOVFF  727,75B
0831C:  MOVFF  726,75A
08320:  MOVFF  725,759
08324:  MOVLW  05
08326:  MOVLB  7
08328:  MOVWF  x5D
0832A:  MOVLB  0
0832C:  CALL   6B62
08330:  MOVLW  2C
08332:  MOVLB  7
08334:  MOVWF  x66
08336:  MOVLB  0
08338:  CALL   5CB6
0833C:  BRA    83F0
0833E:  MOVLB  7
....................    else if ('5' == arg2) sprintf(retData+strlen(retData), "%d,%.5f,", arg1, sensorCal[arg1-1].c5);
08340:  MOVF   x22,W
08342:  SUBLW  35
08344:  BNZ   83E8
08346:  MOVLW  04
08348:  MOVWF  x58
0834A:  MOVLW  C1
0834C:  MOVWF  x57
0834E:  MOVLB  0
08350:  CALL   5C7E
08354:  MOVF   01,W
08356:  ADDLW  C1
08358:  MOVLB  7
0835A:  MOVWF  x23
0835C:  MOVLW  04
0835E:  ADDWFC 02,W
08360:  MOVWF  x24
08362:  MOVLW  01
08364:  SUBWF  x21,W
08366:  MULLW  18
08368:  MOVF   FF3,W
0836A:  CLRF   x26
0836C:  MOVWF  x25
0836E:  MOVLW  14
08370:  ADDWF  x25,W
08372:  MOVWF  01
08374:  MOVLW  00
08376:  ADDWFC x26,W
08378:  MOVWF  03
0837A:  MOVF   01,W
0837C:  ADDLW  92
0837E:  MOVWF  FE9
08380:  MOVLW  00
08382:  ADDWFC 03,W
08384:  MOVWF  FEA
08386:  MOVFF  FEF,725
0838A:  MOVFF  FEC,726
0838E:  MOVFF  FEC,727
08392:  MOVFF  FEC,728
08396:  MOVFF  724,565
0839A:  MOVFF  723,564
0839E:  MOVFF  721,74A
083A2:  MOVLW  18
083A4:  MOVWF  x4B
083A6:  MOVLB  0
083A8:  CALL   62A2
083AC:  MOVLW  2C
083AE:  MOVLB  7
083B0:  MOVWF  x66
083B2:  MOVLB  0
083B4:  CALL   5CB6
083B8:  MOVLW  89
083BA:  MOVWF  FE9
083BC:  MOVFF  728,75C
083C0:  MOVFF  727,75B
083C4:  MOVFF  726,75A
083C8:  MOVFF  725,759
083CC:  MOVLW  05
083CE:  MOVLB  7
083D0:  MOVWF  x5D
083D2:  MOVLB  0
083D4:  CALL   6B62
083D8:  MOVLW  2C
083DA:  MOVLB  7
083DC:  MOVWF  x66
083DE:  MOVLB  0
083E0:  CALL   5CB6
083E4:  BRA    83F0
083E6:  MOVLB  7
....................    else return INV_PARAM;
083E8:  MOVLW  02
083EA:  MOVWF  01
083EC:  MOVLB  0
083EE:  BRA    83F4
....................    
....................    return SUCCESS;
083F0:  MOVLW  00
083F2:  MOVWF  01
083F4:  RETURN 0
.................... }
.................... 
.................... int8 setSensorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char  arg2;
....................    float arg3;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
083F6:  MOVLB  7
083F8:  CLRF   x5D
083FA:  MOVFF  6AB,75C
083FE:  CLRF   x5F
08400:  MOVLW  B5
08402:  MOVWF  x5E
08404:  MOVLB  0
08406:  CALL   086E
0840A:  MOVFF  02,728
0840E:  MOVFF  01,727
08412:  MOVLW  06
08414:  MOVLB  7
08416:  ADDWF  x27,F
08418:  MOVLW  00
0841A:  ADDWFC x28,F
0841C:  MOVLW  32
0841E:  ADDWF  x27,W
08420:  MOVWF  01
08422:  MOVLW  00
08424:  ADDWFC x28,W
08426:  MOVWF  03
08428:  MOVF   01,W
0842A:  ADDLW  EB
0842C:  MOVWF  01
0842E:  MOVLW  01
08430:  ADDWFC 03,F
08432:  MOVFF  01,727
08436:  MOVFF  03,728
0843A:  MOVFF  03,74A
0843E:  MOVFF  01,749
08442:  MOVLB  0
08444:  CALL   5E5E
08448:  MOVF   01,F
0844A:  BNZ   8454
0844C:  MOVLW  02
0844E:  MOVWF  01
08450:  BRA    878C
08452:  BRA    84B2
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
08454:  MOVLB  7
08456:  CLRF   x5D
08458:  MOVFF  6AB,75C
0845C:  CLRF   x5F
0845E:  MOVLW  B5
08460:  MOVWF  x5E
08462:  MOVLB  0
08464:  CALL   086E
08468:  MOVFF  02,728
0846C:  MOVFF  01,727
08470:  MOVLW  06
08472:  MOVLB  7
08474:  ADDWF  x27,F
08476:  MOVLW  00
08478:  ADDWFC x28,F
0847A:  MOVLW  32
0847C:  ADDWF  x27,W
0847E:  MOVWF  01
08480:  MOVLW  00
08482:  ADDWFC x28,W
08484:  MOVWF  03
08486:  MOVF   01,W
08488:  ADDLW  EB
0848A:  MOVWF  01
0848C:  MOVLW  01
0848E:  ADDWFC 03,F
08490:  MOVFF  01,727
08494:  MOVFF  03,728
08498:  MOVFF  03,74A
0849C:  MOVFF  01,749
084A0:  CLRF   x4C
084A2:  CLRF   x4B
084A4:  MOVLW  0A
084A6:  MOVWF  x4D
084A8:  MOVLB  0
084AA:  CALL   5F4E
084AE:  MOVFF  01,721
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
084B2:  MOVLB  7
084B4:  CLRF   x5D
084B6:  MOVFF  6AB,75C
084BA:  CLRF   x5F
084BC:  MOVLW  B5
084BE:  MOVWF  x5E
084C0:  MOVLB  0
084C2:  CALL   086E
084C6:  MOVFF  02,728
084CA:  MOVFF  01,727
084CE:  MOVLW  06
084D0:  MOVLB  7
084D2:  ADDWF  x27,F
084D4:  MOVLW  00
084D6:  ADDWFC x28,F
084D8:  MOVLW  4B
084DA:  ADDWF  x27,W
084DC:  MOVWF  01
084DE:  MOVLW  00
084E0:  ADDWFC x28,W
084E2:  MOVWF  03
084E4:  MOVF   01,W
084E6:  ADDLW  EB
084E8:  MOVWF  01
084EA:  MOVLW  01
084EC:  ADDWFC 03,F
084EE:  MOVFF  01,727
084F2:  MOVFF  03,728
084F6:  MOVFF  03,758
084FA:  MOVFF  01,757
084FE:  MOVLB  0
08500:  CALL   5C7E
08504:  MOVFF  02,03
08508:  MOVF   01,W
0850A:  SUBLW  01
0850C:  BNZ   8512
0850E:  MOVF   03,F
08510:  BZ    851A
08512:  MOVLW  02
08514:  MOVWF  01
08516:  BRA    878C
08518:  BRA    855A
....................    else arg2 = SERcmd[rec].p[3][0];
0851A:  MOVLB  7
0851C:  CLRF   x5D
0851E:  MOVFF  6AB,75C
08522:  CLRF   x5F
08524:  MOVLW  B5
08526:  MOVWF  x5E
08528:  MOVLB  0
0852A:  CALL   086E
0852E:  MOVFF  02,728
08532:  MOVFF  01,727
08536:  MOVLW  06
08538:  MOVLB  7
0853A:  ADDWF  x27,F
0853C:  MOVLW  00
0853E:  ADDWFC x28,F
08540:  MOVLW  4B
08542:  ADDWF  x27,F
08544:  MOVLW  00
08546:  ADDWFC x28,F
08548:  MOVLW  EB
0854A:  ADDWF  x27,W
0854C:  MOVWF  FE9
0854E:  MOVLW  01
08550:  ADDWFC x28,W
08552:  MOVWF  FEA
08554:  MOVFF  FEF,722
08558:  MOVLB  0
....................    
....................    if (!arg_is_float(SERcmd[rec].p[4])) return INV_PARAM;
0855A:  MOVLB  7
0855C:  CLRF   x5D
0855E:  MOVFF  6AB,75C
08562:  CLRF   x5F
08564:  MOVLW  B5
08566:  MOVWF  x5E
08568:  MOVLB  0
0856A:  CALL   086E
0856E:  MOVFF  02,728
08572:  MOVFF  01,727
08576:  MOVLW  06
08578:  MOVLB  7
0857A:  ADDWF  x27,F
0857C:  MOVLW  00
0857E:  ADDWFC x28,F
08580:  MOVLW  64
08582:  ADDWF  x27,W
08584:  MOVWF  01
08586:  MOVLW  00
08588:  ADDWFC x28,W
0858A:  MOVWF  03
0858C:  MOVF   01,W
0858E:  ADDLW  EB
08590:  MOVWF  01
08592:  MOVLW  01
08594:  ADDWFC 03,F
08596:  MOVFF  01,727
0859A:  MOVFF  03,728
0859E:  MOVFF  03,72B
085A2:  MOVFF  01,72A
085A6:  MOVLB  0
085A8:  CALL   71C8
085AC:  MOVF   01,F
085AE:  BNZ   85B8
085B0:  MOVLW  02
085B2:  MOVWF  01
085B4:  BRA    878C
085B6:  BRA    861E
....................    else arg3 = strtod(SERcmd[rec].p[4], '\0');
085B8:  MOVLB  7
085BA:  CLRF   x5D
085BC:  MOVFF  6AB,75C
085C0:  CLRF   x5F
085C2:  MOVLW  B5
085C4:  MOVWF  x5E
085C6:  MOVLB  0
085C8:  CALL   086E
085CC:  MOVFF  02,728
085D0:  MOVFF  01,727
085D4:  MOVLW  06
085D6:  MOVLB  7
085D8:  ADDWF  x27,F
085DA:  MOVLW  00
085DC:  ADDWFC x28,F
085DE:  MOVLW  64
085E0:  ADDWF  x27,W
085E2:  MOVWF  01
085E4:  MOVLW  00
085E6:  ADDWFC x28,W
085E8:  MOVWF  03
085EA:  MOVF   01,W
085EC:  ADDLW  EB
085EE:  MOVWF  01
085F0:  MOVLW  01
085F2:  ADDWFC 03,F
085F4:  MOVFF  01,727
085F8:  MOVFF  03,728
085FC:  MOVFF  03,72B
08600:  MOVFF  01,72A
08604:  CLRF   x2D
08606:  CLRF   x2C
08608:  MOVLB  0
0860A:  CALL   728A
0860E:  MOVFF  03,726
08612:  MOVFF  02,725
08616:  MOVFF  01,724
0861A:  MOVFF  00,723
....................    
....................    /*** SET SENSOR CAL PARAM **********/
....................    if      ('0' == arg2) sensorCal[arg1-1].c0 = arg3;
0861E:  MOVLB  7
08620:  MOVF   x22,W
08622:  SUBLW  30
08624:  BNZ   8650
08626:  MOVLW  01
08628:  SUBWF  x21,W
0862A:  MULLW  18
0862C:  MOVF   FF3,W
0862E:  CLRF   x28
08630:  MOVWF  x27
08632:  MOVLW  92
08634:  ADDWF  x27,W
08636:  MOVWF  FE9
08638:  MOVLW  00
0863A:  ADDWFC x28,W
0863C:  MOVWF  FEA
0863E:  MOVFF  723,FEF
08642:  MOVFF  724,FEC
08646:  MOVFF  725,FEC
0864A:  MOVFF  726,FEC
0864E:  BRA    8786
....................    else if ('1' == arg2) sensorCal[arg1-1].c1 = arg3;
08650:  MOVF   x22,W
08652:  SUBLW  31
08654:  BNZ   868C
08656:  MOVLW  01
08658:  SUBWF  x21,W
0865A:  MULLW  18
0865C:  MOVF   FF3,W
0865E:  CLRF   x28
08660:  MOVWF  x27
08662:  MOVLW  04
08664:  ADDWF  x27,W
08666:  MOVWF  01
08668:  MOVLW  00
0866A:  ADDWFC x28,W
0866C:  MOVWF  03
0866E:  MOVF   01,W
08670:  ADDLW  92
08672:  MOVWF  FE9
08674:  MOVLW  00
08676:  ADDWFC 03,W
08678:  MOVWF  FEA
0867A:  MOVFF  723,FEF
0867E:  MOVFF  724,FEC
08682:  MOVFF  725,FEC
08686:  MOVFF  726,FEC
0868A:  BRA    8786
....................    else if ('2' == arg2) sensorCal[arg1-1].c2 = arg3;
0868C:  MOVF   x22,W
0868E:  SUBLW  32
08690:  BNZ   86C8
08692:  MOVLW  01
08694:  SUBWF  x21,W
08696:  MULLW  18
08698:  MOVF   FF3,W
0869A:  CLRF   x28
0869C:  MOVWF  x27
0869E:  MOVLW  08
086A0:  ADDWF  x27,W
086A2:  MOVWF  01
086A4:  MOVLW  00
086A6:  ADDWFC x28,W
086A8:  MOVWF  03
086AA:  MOVF   01,W
086AC:  ADDLW  92
086AE:  MOVWF  FE9
086B0:  MOVLW  00
086B2:  ADDWFC 03,W
086B4:  MOVWF  FEA
086B6:  MOVFF  723,FEF
086BA:  MOVFF  724,FEC
086BE:  MOVFF  725,FEC
086C2:  MOVFF  726,FEC
086C6:  BRA    8786
....................    else if ('3' == arg2) sensorCal[arg1-1].c3 = arg3;
086C8:  MOVF   x22,W
086CA:  SUBLW  33
086CC:  BNZ   8704
086CE:  MOVLW  01
086D0:  SUBWF  x21,W
086D2:  MULLW  18
086D4:  MOVF   FF3,W
086D6:  CLRF   x28
086D8:  MOVWF  x27
086DA:  MOVLW  0C
086DC:  ADDWF  x27,W
086DE:  MOVWF  01
086E0:  MOVLW  00
086E2:  ADDWFC x28,W
086E4:  MOVWF  03
086E6:  MOVF   01,W
086E8:  ADDLW  92
086EA:  MOVWF  FE9
086EC:  MOVLW  00
086EE:  ADDWFC 03,W
086F0:  MOVWF  FEA
086F2:  MOVFF  723,FEF
086F6:  MOVFF  724,FEC
086FA:  MOVFF  725,FEC
086FE:  MOVFF  726,FEC
08702:  BRA    8786
....................    else if ('4' == arg2) sensorCal[arg1-1].c4 = arg3;
08704:  MOVF   x22,W
08706:  SUBLW  34
08708:  BNZ   8740
0870A:  MOVLW  01
0870C:  SUBWF  x21,W
0870E:  MULLW  18
08710:  MOVF   FF3,W
08712:  CLRF   x28
08714:  MOVWF  x27
08716:  MOVLW  10
08718:  ADDWF  x27,W
0871A:  MOVWF  01
0871C:  MOVLW  00
0871E:  ADDWFC x28,W
08720:  MOVWF  03
08722:  MOVF   01,W
08724:  ADDLW  92
08726:  MOVWF  FE9
08728:  MOVLW  00
0872A:  ADDWFC 03,W
0872C:  MOVWF  FEA
0872E:  MOVFF  723,FEF
08732:  MOVFF  724,FEC
08736:  MOVFF  725,FEC
0873A:  MOVFF  726,FEC
0873E:  BRA    8786
....................    else if ('5' == arg2) sensorCal[arg1-1].c5 = arg3;
08740:  MOVF   x22,W
08742:  SUBLW  35
08744:  BNZ   877C
08746:  MOVLW  01
08748:  SUBWF  x21,W
0874A:  MULLW  18
0874C:  MOVF   FF3,W
0874E:  CLRF   x28
08750:  MOVWF  x27
08752:  MOVLW  14
08754:  ADDWF  x27,W
08756:  MOVWF  01
08758:  MOVLW  00
0875A:  ADDWFC x28,W
0875C:  MOVWF  03
0875E:  MOVF   01,W
08760:  ADDLW  92
08762:  MOVWF  FE9
08764:  MOVLW  00
08766:  ADDWFC 03,W
08768:  MOVWF  FEA
0876A:  MOVFF  723,FEF
0876E:  MOVFF  724,FEC
08772:  MOVFF  725,FEC
08776:  MOVFF  726,FEC
0877A:  BRA    8786
....................    else return INV_PARAM;
0877C:  MOVLW  02
0877E:  MOVWF  01
08780:  MOVLB  0
08782:  BRA    878C
08784:  MOVLB  7
....................    
....................    return SUCCESS;
08786:  MOVLW  00
08788:  MOVWF  01
0878A:  MOVLB  0
0878C:  RETURN 0
.................... }
.................... 
.................... int8 getMonitorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    char *arg1;
....................    char *s_N15 = "N15";
0878E:  MOVLW  4E
08790:  MOVLB  7
08792:  MOVWF  x25
08794:  MOVLW  31
08796:  MOVWF  x26
08798:  MOVLW  35
0879A:  MOVWF  x27
0879C:  CLRF   x28
0879E:  MOVLW  07
087A0:  MOVWF  x24
087A2:  MOVLW  25
087A4:  MOVWF  x23
....................    char *s_200 = "200";
087A6:  MOVLW  32
087A8:  MOVWF  x2B
087AA:  MOVLW  30
087AC:  MOVWF  x2C
087AE:  MOVWF  x2D
087B0:  CLRF   x2E
087B2:  MOVLW  07
087B4:  MOVWF  x2A
087B6:  MOVLW  2B
087B8:  MOVWF  x29
....................    char *s_5V6 = "5V6";
087BA:  MOVLW  35
087BC:  MOVWF  x31
087BE:  MOVLW  56
087C0:  MOVWF  x32
087C2:  MOVLW  36
087C4:  MOVWF  x33
087C6:  CLRF   x34
087C8:  MOVLW  07
087CA:  MOVWF  x30
087CC:  MOVLW  31
087CE:  MOVWF  x2F
....................    char *s_5VA = "5VA";
087D0:  MOVLW  35
087D2:  MOVWF  x37
087D4:  MOVLW  56
087D6:  MOVWF  x38
087D8:  MOVLW  41
087DA:  MOVWF  x39
087DC:  CLRF   x3A
087DE:  MOVLW  07
087E0:  MOVWF  x36
087E2:  MOVLW  37
087E4:  MOVWF  x35
....................    char *s_3V6X = "3V6X";
087E6:  MOVLW  33
087E8:  MOVWF  x3D
087EA:  MOVLW  56
087EC:  MOVWF  x3E
087EE:  MOVLW  36
087F0:  MOVWF  x3F
087F2:  MOVLW  58
087F4:  MOVWF  x40
087F6:  CLRF   x41
087F8:  MOVLW  07
087FA:  MOVWF  x3C
087FC:  MOVLW  3D
087FE:  MOVWF  x3B
....................    char *s_3V3A = "3V3A";
08800:  MOVLW  33
08802:  MOVWF  x44
08804:  MOVLW  56
08806:  MOVWF  x45
08808:  MOVLW  33
0880A:  MOVWF  x46
0880C:  MOVLW  41
0880E:  MOVWF  x47
08810:  CLRF   x48
08812:  MOVLW  07
08814:  MOVWF  x43
08816:  MOVLW  44
08818:  MOVWF  x42
....................    char *s_3V3D = "3V3D";
0881A:  MOVLW  33
0881C:  MOVWF  x4B
0881E:  MOVLW  56
08820:  MOVWF  x4C
08822:  MOVLW  33
08824:  MOVWF  x4D
08826:  MOVLW  44
08828:  MOVWF  x4E
0882A:  CLRF   x4F
0882C:  MOVLW  07
0882E:  MOVWF  x4A
08830:  MOVLW  4B
08832:  MOVWF  x49
.................... //!   char *s_all = "all";
....................    
....................    arg1 = SERcmd[rec].p[2];
08834:  CLRF   x5D
08836:  MOVFF  6AB,75C
0883A:  CLRF   x5F
0883C:  MOVLW  B5
0883E:  MOVWF  x5E
08840:  MOVLB  0
08842:  CALL   086E
08846:  MOVFF  02,751
0884A:  MOVFF  01,750
0884E:  MOVLW  06
08850:  MOVLB  7
08852:  ADDWF  x50,F
08854:  MOVLW  00
08856:  ADDWFC x51,F
08858:  MOVLW  32
0885A:  ADDWF  x50,W
0885C:  MOVWF  01
0885E:  MOVLW  00
08860:  ADDWFC x51,W
08862:  MOVWF  03
08864:  MOVF   01,W
08866:  ADDLW  EB
08868:  MOVWF  01
0886A:  MOVLW  01
0886C:  ADDWFC 03,F
0886E:  MOVFF  01,721
08872:  MOVFF  03,722
....................    
....................    /*** GET MONITOR VALUES ************/
....................    if      (0 == strcmp(s_N15, arg1)) {
08876:  MOVFF  724,758
0887A:  MOVFF  723,757
0887E:  MOVFF  722,75A
08882:  MOVFF  721,759
08886:  MOVLB  0
08888:  CALL   5D34
0888C:  MOVF   01,F
0888E:  BNZ   8912
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.vN15[0],monCal.vN15[1]);
08890:  MOVLW  04
08892:  MOVLB  7
08894:  MOVWF  x58
08896:  MOVLW  C1
08898:  MOVWF  x57
0889A:  MOVLB  0
0889C:  CALL   5C7E
088A0:  MOVFF  02,03
088A4:  MOVF   01,W
088A6:  ADDLW  C1
088A8:  MOVLB  7
088AA:  MOVWF  x50
088AC:  MOVLW  04
088AE:  ADDWFC 02,W
088B0:  MOVWF  x51
088B2:  MOVFF  FE8,565
088B6:  MOVFF  750,564
088BA:  MOVLW  89
088BC:  MOVWF  FE9
088BE:  MOVFF  C5,75C
088C2:  MOVFF  C4,75B
088C6:  MOVFF  C3,75A
088CA:  MOVFF  C2,759
088CE:  MOVLW  02
088D0:  MOVWF  x5D
088D2:  MOVLB  0
088D4:  CALL   6B62
088D8:  MOVLW  2C
088DA:  MOVLB  7
088DC:  MOVWF  x66
088DE:  MOVLB  0
088E0:  CALL   5CB6
088E4:  MOVLW  89
088E6:  MOVWF  FE9
088E8:  MOVFF  C9,75C
088EC:  MOVFF  C8,75B
088F0:  MOVFF  C7,75A
088F4:  MOVFF  C6,759
088F8:  MOVLW  02
088FA:  MOVLB  7
088FC:  MOVWF  x5D
088FE:  MOVLB  0
08900:  CALL   6B62
08904:  MOVLW  2C
08906:  MOVLB  7
08908:  MOVWF  x66
0890A:  MOVLB  0
0890C:  CALL   5CB6
....................    }
08910:  BRA    8CB4
....................    else if (0 == strcmp(s_200, arg1)) {
08912:  MOVFF  72A,758
08916:  MOVFF  729,757
0891A:  MOVFF  722,75A
0891E:  MOVFF  721,759
08922:  CALL   5D34
08926:  MOVF   01,F
08928:  BNZ   89AC
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v200[0],monCal.v200[1]);
0892A:  MOVLW  04
0892C:  MOVLB  7
0892E:  MOVWF  x58
08930:  MOVLW  C1
08932:  MOVWF  x57
08934:  MOVLB  0
08936:  CALL   5C7E
0893A:  MOVFF  02,03
0893E:  MOVF   01,W
08940:  ADDLW  C1
08942:  MOVLB  7
08944:  MOVWF  x50
08946:  MOVLW  04
08948:  ADDWFC 02,W
0894A:  MOVWF  x51
0894C:  MOVFF  FE8,565
08950:  MOVFF  750,564
08954:  MOVLW  89
08956:  MOVWF  FE9
08958:  MOVFF  CD,75C
0895C:  MOVFF  CC,75B
08960:  MOVFF  CB,75A
08964:  MOVFF  CA,759
08968:  MOVLW  02
0896A:  MOVWF  x5D
0896C:  MOVLB  0
0896E:  CALL   6B62
08972:  MOVLW  2C
08974:  MOVLB  7
08976:  MOVWF  x66
08978:  MOVLB  0
0897A:  CALL   5CB6
0897E:  MOVLW  89
08980:  MOVWF  FE9
08982:  MOVFF  D1,75C
08986:  MOVFF  D0,75B
0898A:  MOVFF  CF,75A
0898E:  MOVFF  CE,759
08992:  MOVLW  02
08994:  MOVLB  7
08996:  MOVWF  x5D
08998:  MOVLB  0
0899A:  CALL   6B62
0899E:  MOVLW  2C
089A0:  MOVLB  7
089A2:  MOVWF  x66
089A4:  MOVLB  0
089A6:  CALL   5CB6
....................    }
089AA:  BRA    8CB4
....................    else if (0 == strcmp(s_5V6, arg1)) {
089AC:  MOVFF  730,758
089B0:  MOVFF  72F,757
089B4:  MOVFF  722,75A
089B8:  MOVFF  721,759
089BC:  CALL   5D34
089C0:  MOVF   01,F
089C2:  BNZ   8A46
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v5V6[0],monCal.v5V6[1]);
089C4:  MOVLW  04
089C6:  MOVLB  7
089C8:  MOVWF  x58
089CA:  MOVLW  C1
089CC:  MOVWF  x57
089CE:  MOVLB  0
089D0:  CALL   5C7E
089D4:  MOVFF  02,03
089D8:  MOVF   01,W
089DA:  ADDLW  C1
089DC:  MOVLB  7
089DE:  MOVWF  x50
089E0:  MOVLW  04
089E2:  ADDWFC 02,W
089E4:  MOVWF  x51
089E6:  MOVFF  FE8,565
089EA:  MOVFF  750,564
089EE:  MOVLW  89
089F0:  MOVWF  FE9
089F2:  MOVFF  D5,75C
089F6:  MOVFF  D4,75B
089FA:  MOVFF  D3,75A
089FE:  MOVFF  D2,759
08A02:  MOVLW  02
08A04:  MOVWF  x5D
08A06:  MOVLB  0
08A08:  CALL   6B62
08A0C:  MOVLW  2C
08A0E:  MOVLB  7
08A10:  MOVWF  x66
08A12:  MOVLB  0
08A14:  CALL   5CB6
08A18:  MOVLW  89
08A1A:  MOVWF  FE9
08A1C:  MOVFF  D9,75C
08A20:  MOVFF  D8,75B
08A24:  MOVFF  D7,75A
08A28:  MOVFF  D6,759
08A2C:  MOVLW  02
08A2E:  MOVLB  7
08A30:  MOVWF  x5D
08A32:  MOVLB  0
08A34:  CALL   6B62
08A38:  MOVLW  2C
08A3A:  MOVLB  7
08A3C:  MOVWF  x66
08A3E:  MOVLB  0
08A40:  CALL   5CB6
....................    }
08A44:  BRA    8CB4
....................    else if (0 == strcmp(s_5VA, arg1)) {
08A46:  MOVFF  736,758
08A4A:  MOVFF  735,757
08A4E:  MOVFF  722,75A
08A52:  MOVFF  721,759
08A56:  CALL   5D34
08A5A:  MOVF   01,F
08A5C:  BNZ   8AE0
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v5VA[0],monCal.v5VA[1]);
08A5E:  MOVLW  04
08A60:  MOVLB  7
08A62:  MOVWF  x58
08A64:  MOVLW  C1
08A66:  MOVWF  x57
08A68:  MOVLB  0
08A6A:  CALL   5C7E
08A6E:  MOVFF  02,03
08A72:  MOVF   01,W
08A74:  ADDLW  C1
08A76:  MOVLB  7
08A78:  MOVWF  x50
08A7A:  MOVLW  04
08A7C:  ADDWFC 02,W
08A7E:  MOVWF  x51
08A80:  MOVFF  FE8,565
08A84:  MOVFF  750,564
08A88:  MOVLW  89
08A8A:  MOVWF  FE9
08A8C:  MOVFF  DD,75C
08A90:  MOVFF  DC,75B
08A94:  MOVFF  DB,75A
08A98:  MOVFF  DA,759
08A9C:  MOVLW  02
08A9E:  MOVWF  x5D
08AA0:  MOVLB  0
08AA2:  CALL   6B62
08AA6:  MOVLW  2C
08AA8:  MOVLB  7
08AAA:  MOVWF  x66
08AAC:  MOVLB  0
08AAE:  CALL   5CB6
08AB2:  MOVLW  89
08AB4:  MOVWF  FE9
08AB6:  MOVFF  E1,75C
08ABA:  MOVFF  E0,75B
08ABE:  MOVFF  DF,75A
08AC2:  MOVFF  DE,759
08AC6:  MOVLW  02
08AC8:  MOVLB  7
08ACA:  MOVWF  x5D
08ACC:  MOVLB  0
08ACE:  CALL   6B62
08AD2:  MOVLW  2C
08AD4:  MOVLB  7
08AD6:  MOVWF  x66
08AD8:  MOVLB  0
08ADA:  CALL   5CB6
....................    }
08ADE:  BRA    8CB4
....................    else if (0 == strcmp(s_3V6X, arg1)) {
08AE0:  MOVFF  73C,758
08AE4:  MOVFF  73B,757
08AE8:  MOVFF  722,75A
08AEC:  MOVFF  721,759
08AF0:  CALL   5D34
08AF4:  MOVF   01,F
08AF6:  BNZ   8B7A
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V6X[0],monCal.v3V6X[1]);
08AF8:  MOVLW  04
08AFA:  MOVLB  7
08AFC:  MOVWF  x58
08AFE:  MOVLW  C1
08B00:  MOVWF  x57
08B02:  MOVLB  0
08B04:  CALL   5C7E
08B08:  MOVFF  02,03
08B0C:  MOVF   01,W
08B0E:  ADDLW  C1
08B10:  MOVLB  7
08B12:  MOVWF  x50
08B14:  MOVLW  04
08B16:  ADDWFC 02,W
08B18:  MOVWF  x51
08B1A:  MOVFF  FE8,565
08B1E:  MOVFF  750,564
08B22:  MOVLW  89
08B24:  MOVWF  FE9
08B26:  MOVFF  E5,75C
08B2A:  MOVFF  E4,75B
08B2E:  MOVFF  E3,75A
08B32:  MOVFF  E2,759
08B36:  MOVLW  02
08B38:  MOVWF  x5D
08B3A:  MOVLB  0
08B3C:  CALL   6B62
08B40:  MOVLW  2C
08B42:  MOVLB  7
08B44:  MOVWF  x66
08B46:  MOVLB  0
08B48:  CALL   5CB6
08B4C:  MOVLW  89
08B4E:  MOVWF  FE9
08B50:  MOVFF  E9,75C
08B54:  MOVFF  E8,75B
08B58:  MOVFF  E7,75A
08B5C:  MOVFF  E6,759
08B60:  MOVLW  02
08B62:  MOVLB  7
08B64:  MOVWF  x5D
08B66:  MOVLB  0
08B68:  CALL   6B62
08B6C:  MOVLW  2C
08B6E:  MOVLB  7
08B70:  MOVWF  x66
08B72:  MOVLB  0
08B74:  CALL   5CB6
....................    }
08B78:  BRA    8CB4
....................    else if (0 == strcmp(s_3V3A, arg1)) {
08B7A:  MOVFF  743,758
08B7E:  MOVFF  742,757
08B82:  MOVFF  722,75A
08B86:  MOVFF  721,759
08B8A:  CALL   5D34
08B8E:  MOVF   01,F
08B90:  BNZ   8C14
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3A[0],monCal.v3V3A[1]);
08B92:  MOVLW  04
08B94:  MOVLB  7
08B96:  MOVWF  x58
08B98:  MOVLW  C1
08B9A:  MOVWF  x57
08B9C:  MOVLB  0
08B9E:  CALL   5C7E
08BA2:  MOVFF  02,03
08BA6:  MOVF   01,W
08BA8:  ADDLW  C1
08BAA:  MOVLB  7
08BAC:  MOVWF  x50
08BAE:  MOVLW  04
08BB0:  ADDWFC 02,W
08BB2:  MOVWF  x51
08BB4:  MOVFF  FE8,565
08BB8:  MOVFF  750,564
08BBC:  MOVLW  89
08BBE:  MOVWF  FE9
08BC0:  MOVFF  ED,75C
08BC4:  MOVFF  EC,75B
08BC8:  MOVFF  EB,75A
08BCC:  MOVFF  EA,759
08BD0:  MOVLW  02
08BD2:  MOVWF  x5D
08BD4:  MOVLB  0
08BD6:  CALL   6B62
08BDA:  MOVLW  2C
08BDC:  MOVLB  7
08BDE:  MOVWF  x66
08BE0:  MOVLB  0
08BE2:  CALL   5CB6
08BE6:  MOVLW  89
08BE8:  MOVWF  FE9
08BEA:  MOVFF  F1,75C
08BEE:  MOVFF  F0,75B
08BF2:  MOVFF  EF,75A
08BF6:  MOVFF  EE,759
08BFA:  MOVLW  02
08BFC:  MOVLB  7
08BFE:  MOVWF  x5D
08C00:  MOVLB  0
08C02:  CALL   6B62
08C06:  MOVLW  2C
08C08:  MOVLB  7
08C0A:  MOVWF  x66
08C0C:  MOVLB  0
08C0E:  CALL   5CB6
....................    }
08C12:  BRA    8CB4
....................    else if (0 == strcmp(s_3V3D, arg1)) {
08C14:  MOVFF  74A,758
08C18:  MOVFF  749,757
08C1C:  MOVFF  722,75A
08C20:  MOVFF  721,759
08C24:  CALL   5D34
08C28:  MOVF   01,F
08C2A:  BNZ   8CAE
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3D[0],monCal.v3V3D[1]);
08C2C:  MOVLW  04
08C2E:  MOVLB  7
08C30:  MOVWF  x58
08C32:  MOVLW  C1
08C34:  MOVWF  x57
08C36:  MOVLB  0
08C38:  CALL   5C7E
08C3C:  MOVFF  02,03
08C40:  MOVF   01,W
08C42:  ADDLW  C1
08C44:  MOVLB  7
08C46:  MOVWF  x50
08C48:  MOVLW  04
08C4A:  ADDWFC 02,W
08C4C:  MOVWF  x51
08C4E:  MOVFF  FE8,565
08C52:  MOVFF  750,564
08C56:  MOVLW  89
08C58:  MOVWF  FE9
08C5A:  MOVFF  F5,75C
08C5E:  MOVFF  F4,75B
08C62:  MOVFF  F3,75A
08C66:  MOVFF  F2,759
08C6A:  MOVLW  02
08C6C:  MOVWF  x5D
08C6E:  MOVLB  0
08C70:  CALL   6B62
08C74:  MOVLW  2C
08C76:  MOVLB  7
08C78:  MOVWF  x66
08C7A:  MOVLB  0
08C7C:  CALL   5CB6
08C80:  MOVLW  89
08C82:  MOVWF  FE9
08C84:  MOVFF  F9,75C
08C88:  MOVFF  F8,75B
08C8C:  MOVFF  F7,75A
08C90:  MOVFF  F6,759
08C94:  MOVLW  02
08C96:  MOVLB  7
08C98:  MOVWF  x5D
08C9A:  MOVLB  0
08C9C:  CALL   6B62
08CA0:  MOVLW  2C
08CA2:  MOVLB  7
08CA4:  MOVWF  x66
08CA6:  MOVLB  0
08CA8:  CALL   5CB6
....................    }
08CAC:  BRA    8CB4
....................    else return INV_PARAM;
08CAE:  MOVLW  02
08CB0:  MOVWF  01
08CB2:  BRA    8CB8
....................    
....................    return SUCCESS;
08CB4:  MOVLW  00
08CB6:  MOVWF  01
08CB8:  RETURN 0
.................... }
.................... 
.................... int8 setMonitorCalParam(unsigned int8 rec){
....................    return SUCCESS;
08CBA:  MOVLW  00
08CBC:  MOVWF  01
08CBE:  RETURN 0
.................... }
.................... 
.................... int8 getMonitorValue(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    char *arg1;
....................    char *s_N15 = "N15";
08CC0:  MOVLW  4E
08CC2:  MOVLB  7
08CC4:  MOVWF  x25
08CC6:  MOVLW  31
08CC8:  MOVWF  x26
08CCA:  MOVLW  35
08CCC:  MOVWF  x27
08CCE:  CLRF   x28
08CD0:  MOVLW  07
08CD2:  MOVWF  x24
08CD4:  MOVLW  25
08CD6:  MOVWF  x23
....................    char *s_200 = "200";
08CD8:  MOVLW  32
08CDA:  MOVWF  x2B
08CDC:  MOVLW  30
08CDE:  MOVWF  x2C
08CE0:  MOVWF  x2D
08CE2:  CLRF   x2E
08CE4:  MOVLW  07
08CE6:  MOVWF  x2A
08CE8:  MOVLW  2B
08CEA:  MOVWF  x29
....................    char *s_5V6 = "5V6";
08CEC:  MOVLW  35
08CEE:  MOVWF  x31
08CF0:  MOVLW  56
08CF2:  MOVWF  x32
08CF4:  MOVLW  36
08CF6:  MOVWF  x33
08CF8:  CLRF   x34
08CFA:  MOVLW  07
08CFC:  MOVWF  x30
08CFE:  MOVLW  31
08D00:  MOVWF  x2F
....................    char *s_5VA = "5VA";
08D02:  MOVLW  35
08D04:  MOVWF  x37
08D06:  MOVLW  56
08D08:  MOVWF  x38
08D0A:  MOVLW  41
08D0C:  MOVWF  x39
08D0E:  CLRF   x3A
08D10:  MOVLW  07
08D12:  MOVWF  x36
08D14:  MOVLW  37
08D16:  MOVWF  x35
....................    char *s_3V6X = "3V6X";
08D18:  MOVLW  33
08D1A:  MOVWF  x3D
08D1C:  MOVLW  56
08D1E:  MOVWF  x3E
08D20:  MOVLW  36
08D22:  MOVWF  x3F
08D24:  MOVLW  58
08D26:  MOVWF  x40
08D28:  CLRF   x41
08D2A:  MOVLW  07
08D2C:  MOVWF  x3C
08D2E:  MOVLW  3D
08D30:  MOVWF  x3B
....................    char *s_3V3A = "3V3A";
08D32:  MOVLW  33
08D34:  MOVWF  x44
08D36:  MOVLW  56
08D38:  MOVWF  x45
08D3A:  MOVLW  33
08D3C:  MOVWF  x46
08D3E:  MOVLW  41
08D40:  MOVWF  x47
08D42:  CLRF   x48
08D44:  MOVLW  07
08D46:  MOVWF  x43
08D48:  MOVLW  44
08D4A:  MOVWF  x42
....................    char *s_3V3D = "3V3D";
08D4C:  MOVLW  33
08D4E:  MOVWF  x4B
08D50:  MOVLW  56
08D52:  MOVWF  x4C
08D54:  MOVLW  33
08D56:  MOVWF  x4D
08D58:  MOVLW  44
08D5A:  MOVWF  x4E
08D5C:  CLRF   x4F
08D5E:  MOVLW  07
08D60:  MOVWF  x4A
08D62:  MOVLW  4B
08D64:  MOVWF  x49
....................    char *s_all = "all";
08D66:  MOVLW  61
08D68:  MOVWF  x52
08D6A:  MOVLW  6C
08D6C:  MOVWF  x53
08D6E:  MOVWF  x54
08D70:  CLRF   x55
08D72:  MOVLW  07
08D74:  MOVWF  x51
08D76:  MOVLW  52
08D78:  MOVWF  x50
....................    
....................    arg1 = SERcmd[rec].p[2];
08D7A:  CLRF   x5D
08D7C:  MOVFF  6AB,75C
08D80:  CLRF   x5F
08D82:  MOVLW  B5
08D84:  MOVWF  x5E
08D86:  MOVLB  0
08D88:  CALL   086E
08D8C:  MOVFF  02,757
08D90:  MOVFF  01,756
08D94:  MOVLW  06
08D96:  MOVLB  7
08D98:  ADDWF  x56,F
08D9A:  MOVLW  00
08D9C:  ADDWFC x57,F
08D9E:  MOVLW  32
08DA0:  ADDWF  x56,W
08DA2:  MOVWF  01
08DA4:  MOVLW  00
08DA6:  ADDWFC x57,W
08DA8:  MOVWF  03
08DAA:  MOVF   01,W
08DAC:  ADDLW  EB
08DAE:  MOVWF  01
08DB0:  MOVLW  01
08DB2:  ADDWFC 03,F
08DB4:  MOVFF  01,721
08DB8:  MOVFF  03,722
....................    
....................    /*** GET MONITOR VALUES ************/
....................    if      (0 == strcmp(s_N15, arg1)) {
08DBC:  MOVFF  724,758
08DC0:  MOVFF  723,757
08DC4:  MOVFF  722,75A
08DC8:  MOVFF  721,759
08DCC:  MOVLB  0
08DCE:  CALL   5D34
08DD2:  MOVF   01,F
08DD4:  BNZ   8E2C
....................       sprintf(retData+strlen(retData), "%.2f,", monitorVals.vN15);
08DD6:  MOVLW  04
08DD8:  MOVLB  7
08DDA:  MOVWF  x58
08DDC:  MOVLW  C1
08DDE:  MOVWF  x57
08DE0:  MOVLB  0
08DE2:  CALL   5C7E
08DE6:  MOVFF  02,03
08DEA:  MOVF   01,W
08DEC:  ADDLW  C1
08DEE:  MOVLB  7
08DF0:  MOVWF  x56
08DF2:  MOVLW  04
08DF4:  ADDWFC 02,W
08DF6:  MOVWF  x57
08DF8:  MOVFF  FE8,565
08DFC:  MOVFF  756,564
08E00:  MOVLW  89
08E02:  MOVWF  FE9
08E04:  MOVFF  FE,75C
08E08:  MOVFF  FD,75B
08E0C:  MOVFF  FC,75A
08E10:  MOVFF  FB,759
08E14:  MOVLW  02
08E16:  MOVWF  x5D
08E18:  MOVLB  0
08E1A:  CALL   6B62
08E1E:  MOVLW  2C
08E20:  MOVLB  7
08E22:  MOVWF  x66
08E24:  MOVLB  0
08E26:  CALL   5CB6
....................    }
08E2A:  BRA    932E
....................    else if (0 == strcmp(s_200, arg1)) {
08E2C:  MOVFF  72A,758
08E30:  MOVFF  729,757
08E34:  MOVFF  722,75A
08E38:  MOVFF  721,759
08E3C:  CALL   5D34
08E40:  MOVF   01,F
08E42:  BNZ   8E9A
....................       sprintf(retData+strlen(retData), "%.1f,", monitorVals.v200);
08E44:  MOVLW  04
08E46:  MOVLB  7
08E48:  MOVWF  x58
08E4A:  MOVLW  C1
08E4C:  MOVWF  x57
08E4E:  MOVLB  0
08E50:  CALL   5C7E
08E54:  MOVFF  02,03
08E58:  MOVF   01,W
08E5A:  ADDLW  C1
08E5C:  MOVLB  7
08E5E:  MOVWF  x56
08E60:  MOVLW  04
08E62:  ADDWFC 02,W
08E64:  MOVWF  x57
08E66:  MOVFF  FE8,565
08E6A:  MOVFF  756,564
08E6E:  MOVLW  89
08E70:  MOVWF  FE9
08E72:  MOVFF  102,75C
08E76:  MOVFF  101,75B
08E7A:  MOVFF  100,75A
08E7E:  MOVFF  FF,759
08E82:  MOVLW  01
08E84:  MOVWF  x5D
08E86:  MOVLB  0
08E88:  CALL   6B62
08E8C:  MOVLW  2C
08E8E:  MOVLB  7
08E90:  MOVWF  x66
08E92:  MOVLB  0
08E94:  CALL   5CB6
....................    }
08E98:  BRA    932E
....................    else if (0 == strcmp(s_5V6, arg1)) {
08E9A:  MOVFF  730,758
08E9E:  MOVFF  72F,757
08EA2:  MOVFF  722,75A
08EA6:  MOVFF  721,759
08EAA:  CALL   5D34
08EAE:  MOVF   01,F
08EB0:  BNZ   8F08
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5V6);
08EB2:  MOVLW  04
08EB4:  MOVLB  7
08EB6:  MOVWF  x58
08EB8:  MOVLW  C1
08EBA:  MOVWF  x57
08EBC:  MOVLB  0
08EBE:  CALL   5C7E
08EC2:  MOVFF  02,03
08EC6:  MOVF   01,W
08EC8:  ADDLW  C1
08ECA:  MOVLB  7
08ECC:  MOVWF  x56
08ECE:  MOVLW  04
08ED0:  ADDWFC 02,W
08ED2:  MOVWF  x57
08ED4:  MOVFF  FE8,565
08ED8:  MOVFF  756,564
08EDC:  MOVLW  89
08EDE:  MOVWF  FE9
08EE0:  MOVFF  106,75C
08EE4:  MOVFF  105,75B
08EE8:  MOVFF  104,75A
08EEC:  MOVFF  103,759
08EF0:  MOVLW  03
08EF2:  MOVWF  x5D
08EF4:  MOVLB  0
08EF6:  CALL   6B62
08EFA:  MOVLW  2C
08EFC:  MOVLB  7
08EFE:  MOVWF  x66
08F00:  MOVLB  0
08F02:  CALL   5CB6
....................    }
08F06:  BRA    932E
....................    else if (0 == strcmp(s_5VA, arg1)) {
08F08:  MOVFF  736,758
08F0C:  MOVFF  735,757
08F10:  MOVFF  722,75A
08F14:  MOVFF  721,759
08F18:  CALL   5D34
08F1C:  MOVF   01,F
08F1E:  BNZ   8F76
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5VA);
08F20:  MOVLW  04
08F22:  MOVLB  7
08F24:  MOVWF  x58
08F26:  MOVLW  C1
08F28:  MOVWF  x57
08F2A:  MOVLB  0
08F2C:  CALL   5C7E
08F30:  MOVFF  02,03
08F34:  MOVF   01,W
08F36:  ADDLW  C1
08F38:  MOVLB  7
08F3A:  MOVWF  x56
08F3C:  MOVLW  04
08F3E:  ADDWFC 02,W
08F40:  MOVWF  x57
08F42:  MOVFF  FE8,565
08F46:  MOVFF  756,564
08F4A:  MOVLW  89
08F4C:  MOVWF  FE9
08F4E:  MOVFF  10A,75C
08F52:  MOVFF  109,75B
08F56:  MOVFF  108,75A
08F5A:  MOVFF  107,759
08F5E:  MOVLW  03
08F60:  MOVWF  x5D
08F62:  MOVLB  0
08F64:  CALL   6B62
08F68:  MOVLW  2C
08F6A:  MOVLB  7
08F6C:  MOVWF  x66
08F6E:  MOVLB  0
08F70:  CALL   5CB6
....................    }
08F74:  BRA    932E
....................    else if (0 == strcmp(s_3V6X, arg1)) {
08F76:  MOVFF  73C,758
08F7A:  MOVFF  73B,757
08F7E:  MOVFF  722,75A
08F82:  MOVFF  721,759
08F86:  CALL   5D34
08F8A:  MOVF   01,F
08F8C:  BNZ   8FE4
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V6X);
08F8E:  MOVLW  04
08F90:  MOVLB  7
08F92:  MOVWF  x58
08F94:  MOVLW  C1
08F96:  MOVWF  x57
08F98:  MOVLB  0
08F9A:  CALL   5C7E
08F9E:  MOVFF  02,03
08FA2:  MOVF   01,W
08FA4:  ADDLW  C1
08FA6:  MOVLB  7
08FA8:  MOVWF  x56
08FAA:  MOVLW  04
08FAC:  ADDWFC 02,W
08FAE:  MOVWF  x57
08FB0:  MOVFF  FE8,565
08FB4:  MOVFF  756,564
08FB8:  MOVLW  89
08FBA:  MOVWF  FE9
08FBC:  MOVFF  10E,75C
08FC0:  MOVFF  10D,75B
08FC4:  MOVFF  10C,75A
08FC8:  MOVFF  10B,759
08FCC:  MOVLW  03
08FCE:  MOVWF  x5D
08FD0:  MOVLB  0
08FD2:  CALL   6B62
08FD6:  MOVLW  2C
08FD8:  MOVLB  7
08FDA:  MOVWF  x66
08FDC:  MOVLB  0
08FDE:  CALL   5CB6
....................    }
08FE2:  BRA    932E
....................    else if (0 == strcmp(s_3V3A, arg1)) {
08FE4:  MOVFF  743,758
08FE8:  MOVFF  742,757
08FEC:  MOVFF  722,75A
08FF0:  MOVFF  721,759
08FF4:  CALL   5D34
08FF8:  MOVF   01,F
08FFA:  BNZ   9052
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3A);
08FFC:  MOVLW  04
08FFE:  MOVLB  7
09000:  MOVWF  x58
09002:  MOVLW  C1
09004:  MOVWF  x57
09006:  MOVLB  0
09008:  CALL   5C7E
0900C:  MOVFF  02,03
09010:  MOVF   01,W
09012:  ADDLW  C1
09014:  MOVLB  7
09016:  MOVWF  x56
09018:  MOVLW  04
0901A:  ADDWFC 02,W
0901C:  MOVWF  x57
0901E:  MOVFF  FE8,565
09022:  MOVFF  756,564
09026:  MOVLW  89
09028:  MOVWF  FE9
0902A:  MOVFF  112,75C
0902E:  MOVFF  111,75B
09032:  MOVFF  110,75A
09036:  MOVFF  10F,759
0903A:  MOVLW  03
0903C:  MOVWF  x5D
0903E:  MOVLB  0
09040:  CALL   6B62
09044:  MOVLW  2C
09046:  MOVLB  7
09048:  MOVWF  x66
0904A:  MOVLB  0
0904C:  CALL   5CB6
....................    }
09050:  BRA    932E
....................    else if (0 == strcmp(s_3V3D, arg1)) {
09052:  MOVFF  74A,758
09056:  MOVFF  749,757
0905A:  MOVFF  722,75A
0905E:  MOVFF  721,759
09062:  CALL   5D34
09066:  MOVF   01,F
09068:  BNZ   90C0
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3D);
0906A:  MOVLW  04
0906C:  MOVLB  7
0906E:  MOVWF  x58
09070:  MOVLW  C1
09072:  MOVWF  x57
09074:  MOVLB  0
09076:  CALL   5C7E
0907A:  MOVFF  02,03
0907E:  MOVF   01,W
09080:  ADDLW  C1
09082:  MOVLB  7
09084:  MOVWF  x56
09086:  MOVLW  04
09088:  ADDWFC 02,W
0908A:  MOVWF  x57
0908C:  MOVFF  FE8,565
09090:  MOVFF  756,564
09094:  MOVLW  89
09096:  MOVWF  FE9
09098:  MOVFF  116,75C
0909C:  MOVFF  115,75B
090A0:  MOVFF  114,75A
090A4:  MOVFF  113,759
090A8:  MOVLW  03
090AA:  MOVWF  x5D
090AC:  MOVLB  0
090AE:  CALL   6B62
090B2:  MOVLW  2C
090B4:  MOVLB  7
090B6:  MOVWF  x66
090B8:  MOVLB  0
090BA:  CALL   5CB6
....................    }
090BE:  BRA    932E
....................    else if (0 == strcmp(s_all, arg1)) {
090C0:  MOVFF  751,758
090C4:  MOVFF  750,757
090C8:  MOVFF  722,75A
090CC:  MOVFF  721,759
090D0:  CALL   5D34
090D4:  MOVF   01,F
090D6:  BTFSS  FD8.2
090D8:  BRA    9328
....................       sprintf(retData+strlen(retData), "%.2f,", monitorVals.vN15);
090DA:  MOVLW  04
090DC:  MOVLB  7
090DE:  MOVWF  x58
090E0:  MOVLW  C1
090E2:  MOVWF  x57
090E4:  MOVLB  0
090E6:  CALL   5C7E
090EA:  MOVFF  02,03
090EE:  MOVF   01,W
090F0:  ADDLW  C1
090F2:  MOVLB  7
090F4:  MOVWF  x56
090F6:  MOVLW  04
090F8:  ADDWFC 02,W
090FA:  MOVWF  x57
090FC:  MOVFF  FE8,565
09100:  MOVFF  756,564
09104:  MOVLW  89
09106:  MOVWF  FE9
09108:  MOVFF  FE,75C
0910C:  MOVFF  FD,75B
09110:  MOVFF  FC,75A
09114:  MOVFF  FB,759
09118:  MOVLW  02
0911A:  MOVWF  x5D
0911C:  MOVLB  0
0911E:  CALL   6B62
09122:  MOVLW  2C
09124:  MOVLB  7
09126:  MOVWF  x66
09128:  MOVLB  0
0912A:  CALL   5CB6
....................       sprintf(retData+strlen(retData), "%.1f,", monitorVals.v200);
0912E:  MOVLW  04
09130:  MOVLB  7
09132:  MOVWF  x58
09134:  MOVLW  C1
09136:  MOVWF  x57
09138:  MOVLB  0
0913A:  CALL   5C7E
0913E:  MOVFF  02,03
09142:  MOVF   01,W
09144:  ADDLW  C1
09146:  MOVLB  7
09148:  MOVWF  x56
0914A:  MOVLW  04
0914C:  ADDWFC 02,W
0914E:  MOVWF  x57
09150:  MOVFF  FE8,565
09154:  MOVFF  756,564
09158:  MOVLW  89
0915A:  MOVWF  FE9
0915C:  MOVFF  102,75C
09160:  MOVFF  101,75B
09164:  MOVFF  100,75A
09168:  MOVFF  FF,759
0916C:  MOVLW  01
0916E:  MOVWF  x5D
09170:  MOVLB  0
09172:  CALL   6B62
09176:  MOVLW  2C
09178:  MOVLB  7
0917A:  MOVWF  x66
0917C:  MOVLB  0
0917E:  CALL   5CB6
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5V6);
09182:  MOVLW  04
09184:  MOVLB  7
09186:  MOVWF  x58
09188:  MOVLW  C1
0918A:  MOVWF  x57
0918C:  MOVLB  0
0918E:  CALL   5C7E
09192:  MOVFF  02,03
09196:  MOVF   01,W
09198:  ADDLW  C1
0919A:  MOVLB  7
0919C:  MOVWF  x56
0919E:  MOVLW  04
091A0:  ADDWFC 02,W
091A2:  MOVWF  x57
091A4:  MOVFF  FE8,565
091A8:  MOVFF  756,564
091AC:  MOVLW  89
091AE:  MOVWF  FE9
091B0:  MOVFF  106,75C
091B4:  MOVFF  105,75B
091B8:  MOVFF  104,75A
091BC:  MOVFF  103,759
091C0:  MOVLW  03
091C2:  MOVWF  x5D
091C4:  MOVLB  0
091C6:  CALL   6B62
091CA:  MOVLW  2C
091CC:  MOVLB  7
091CE:  MOVWF  x66
091D0:  MOVLB  0
091D2:  CALL   5CB6
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5VA);
091D6:  MOVLW  04
091D8:  MOVLB  7
091DA:  MOVWF  x58
091DC:  MOVLW  C1
091DE:  MOVWF  x57
091E0:  MOVLB  0
091E2:  CALL   5C7E
091E6:  MOVFF  02,03
091EA:  MOVF   01,W
091EC:  ADDLW  C1
091EE:  MOVLB  7
091F0:  MOVWF  x56
091F2:  MOVLW  04
091F4:  ADDWFC 02,W
091F6:  MOVWF  x57
091F8:  MOVFF  FE8,565
091FC:  MOVFF  756,564
09200:  MOVLW  89
09202:  MOVWF  FE9
09204:  MOVFF  10A,75C
09208:  MOVFF  109,75B
0920C:  MOVFF  108,75A
09210:  MOVFF  107,759
09214:  MOVLW  03
09216:  MOVWF  x5D
09218:  MOVLB  0
0921A:  CALL   6B62
0921E:  MOVLW  2C
09220:  MOVLB  7
09222:  MOVWF  x66
09224:  MOVLB  0
09226:  CALL   5CB6
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V6X);
0922A:  MOVLW  04
0922C:  MOVLB  7
0922E:  MOVWF  x58
09230:  MOVLW  C1
09232:  MOVWF  x57
09234:  MOVLB  0
09236:  CALL   5C7E
0923A:  MOVFF  02,03
0923E:  MOVF   01,W
09240:  ADDLW  C1
09242:  MOVLB  7
09244:  MOVWF  x56
09246:  MOVLW  04
09248:  ADDWFC 02,W
0924A:  MOVWF  x57
0924C:  MOVFF  FE8,565
09250:  MOVFF  756,564
09254:  MOVLW  89
09256:  MOVWF  FE9
09258:  MOVFF  10E,75C
0925C:  MOVFF  10D,75B
09260:  MOVFF  10C,75A
09264:  MOVFF  10B,759
09268:  MOVLW  03
0926A:  MOVWF  x5D
0926C:  MOVLB  0
0926E:  CALL   6B62
09272:  MOVLW  2C
09274:  MOVLB  7
09276:  MOVWF  x66
09278:  MOVLB  0
0927A:  CALL   5CB6
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3A);
0927E:  MOVLW  04
09280:  MOVLB  7
09282:  MOVWF  x58
09284:  MOVLW  C1
09286:  MOVWF  x57
09288:  MOVLB  0
0928A:  CALL   5C7E
0928E:  MOVFF  02,03
09292:  MOVF   01,W
09294:  ADDLW  C1
09296:  MOVLB  7
09298:  MOVWF  x56
0929A:  MOVLW  04
0929C:  ADDWFC 02,W
0929E:  MOVWF  x57
092A0:  MOVFF  FE8,565
092A4:  MOVFF  756,564
092A8:  MOVLW  89
092AA:  MOVWF  FE9
092AC:  MOVFF  112,75C
092B0:  MOVFF  111,75B
092B4:  MOVFF  110,75A
092B8:  MOVFF  10F,759
092BC:  MOVLW  03
092BE:  MOVWF  x5D
092C0:  MOVLB  0
092C2:  CALL   6B62
092C6:  MOVLW  2C
092C8:  MOVLB  7
092CA:  MOVWF  x66
092CC:  MOVLB  0
092CE:  CALL   5CB6
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3D);
092D2:  MOVLW  04
092D4:  MOVLB  7
092D6:  MOVWF  x58
092D8:  MOVLW  C1
092DA:  MOVWF  x57
092DC:  MOVLB  0
092DE:  CALL   5C7E
092E2:  MOVFF  02,03
092E6:  MOVF   01,W
092E8:  ADDLW  C1
092EA:  MOVLB  7
092EC:  MOVWF  x56
092EE:  MOVLW  04
092F0:  ADDWFC 02,W
092F2:  MOVWF  x57
092F4:  MOVFF  FE8,565
092F8:  MOVFF  756,564
092FC:  MOVLW  89
092FE:  MOVWF  FE9
09300:  MOVFF  116,75C
09304:  MOVFF  115,75B
09308:  MOVFF  114,75A
0930C:  MOVFF  113,759
09310:  MOVLW  03
09312:  MOVWF  x5D
09314:  MOVLB  0
09316:  CALL   6B62
0931A:  MOVLW  2C
0931C:  MOVLB  7
0931E:  MOVWF  x66
09320:  MOVLB  0
09322:  CALL   5CB6
....................    }
09326:  BRA    932E
....................    else return INV_PARAM;
09328:  MOVLW  02
0932A:  MOVWF  01
0932C:  BRA    9332
....................    
....................    return SUCCESS;
0932E:  MOVLW  00
09330:  MOVWF  01
09332:  RETURN 0
.................... }
.................... 
.................... int8 getPIDdata(unsigned int8 rec){
....................   /*** ARG CHECKS ********************/ 
....................    int8 arg1;
....................    char *arg2;
....................    char *s_PV = "PV";
09334:  MOVLW  50
09336:  MOVLB  7
09338:  MOVWF  x26
0933A:  MOVLW  56
0933C:  MOVWF  x27
0933E:  CLRF   x28
09340:  MOVLW  07
09342:  MOVWF  x25
09344:  MOVLW  26
09346:  MOVWF  x24
....................    char *s_CV = "CV";
09348:  MOVLW  43
0934A:  MOVWF  x2B
0934C:  MOVLW  56
0934E:  MOVWF  x2C
09350:  CLRF   x2D
09352:  MOVLW  07
09354:  MOVWF  x2A
09356:  MOVLW  2B
09358:  MOVWF  x29
....................    char *s_PVold = "PVold";
0935A:  MOVLW  50
0935C:  MOVWF  x30
0935E:  MOVLW  56
09360:  MOVWF  x31
09362:  MOVLW  6F
09364:  MOVWF  x32
09366:  MOVLW  6C
09368:  MOVWF  x33
0936A:  MOVLW  64
0936C:  MOVWF  x34
0936E:  CLRF   x35
09370:  MOVLW  07
09372:  MOVWF  x2F
09374:  MOVLW  30
09376:  MOVWF  x2E
....................    char *s_I = "I";
09378:  MOVLW  49
0937A:  MOVWF  x38
0937C:  CLRF   x39
0937E:  MOVLW  07
09380:  MOVWF  x37
09382:  MOVLW  38
09384:  MOVWF  x36
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
09386:  CLRF   x5D
09388:  MOVFF  6AB,75C
0938C:  CLRF   x5F
0938E:  MOVLW  B5
09390:  MOVWF  x5E
09392:  MOVLB  0
09394:  CALL   086E
09398:  MOVFF  02,73B
0939C:  MOVFF  01,73A
093A0:  MOVLW  06
093A2:  MOVLB  7
093A4:  ADDWF  x3A,F
093A6:  MOVLW  00
093A8:  ADDWFC x3B,F
093AA:  MOVLW  32
093AC:  ADDWF  x3A,W
093AE:  MOVWF  01
093B0:  MOVLW  00
093B2:  ADDWFC x3B,W
093B4:  MOVWF  03
093B6:  MOVF   01,W
093B8:  ADDLW  EB
093BA:  MOVWF  01
093BC:  MOVLW  01
093BE:  ADDWFC 03,F
093C0:  MOVFF  01,73A
093C4:  MOVFF  03,73B
093C8:  MOVFF  03,74A
093CC:  MOVFF  01,749
093D0:  MOVLB  0
093D2:  CALL   5E5E
093D6:  MOVF   01,F
093D8:  BNZ   93E2
093DA:  MOVLW  02
093DC:  MOVWF  01
093DE:  BRA    9778
093E0:  BRA    9440
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
093E2:  MOVLB  7
093E4:  CLRF   x5D
093E6:  MOVFF  6AB,75C
093EA:  CLRF   x5F
093EC:  MOVLW  B5
093EE:  MOVWF  x5E
093F0:  MOVLB  0
093F2:  CALL   086E
093F6:  MOVFF  02,73B
093FA:  MOVFF  01,73A
093FE:  MOVLW  06
09400:  MOVLB  7
09402:  ADDWF  x3A,F
09404:  MOVLW  00
09406:  ADDWFC x3B,F
09408:  MOVLW  32
0940A:  ADDWF  x3A,W
0940C:  MOVWF  01
0940E:  MOVLW  00
09410:  ADDWFC x3B,W
09412:  MOVWF  03
09414:  MOVF   01,W
09416:  ADDLW  EB
09418:  MOVWF  01
0941A:  MOVLW  01
0941C:  ADDWFC 03,F
0941E:  MOVFF  01,73A
09422:  MOVFF  03,73B
09426:  MOVFF  03,74A
0942A:  MOVFF  01,749
0942E:  CLRF   x4C
09430:  CLRF   x4B
09432:  MOVLW  0A
09434:  MOVWF  x4D
09436:  MOVLB  0
09438:  CALL   5F4E
0943C:  MOVFF  01,721
....................    
....................    arg2 = SERcmd[rec].p[3];
09440:  MOVLB  7
09442:  CLRF   x5D
09444:  MOVFF  6AB,75C
09448:  CLRF   x5F
0944A:  MOVLW  B5
0944C:  MOVWF  x5E
0944E:  MOVLB  0
09450:  CALL   086E
09454:  MOVFF  02,73B
09458:  MOVFF  01,73A
0945C:  MOVLW  06
0945E:  MOVLB  7
09460:  ADDWF  x3A,F
09462:  MOVLW  00
09464:  ADDWFC x3B,F
09466:  MOVLW  4B
09468:  ADDWF  x3A,W
0946A:  MOVWF  01
0946C:  MOVLW  00
0946E:  ADDWFC x3B,W
09470:  MOVWF  03
09472:  MOVF   01,W
09474:  ADDLW  EB
09476:  MOVWF  01
09478:  MOVLW  01
0947A:  ADDWFC 03,F
0947C:  MOVFF  01,722
09480:  MOVFF  03,723
....................    
....................    /*** GET PV, CV, PVold, I, or A(LL) VALUE **********/
....................    if      (0 == strcmp(s_PV, arg2))     sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].PV);
09484:  MOVFF  725,758
09488:  MOVFF  724,757
0948C:  MOVFF  723,75A
09490:  MOVFF  722,759
09494:  MOVLB  0
09496:  CALL   5D34
0949A:  MOVF   01,F
0949C:  BNZ   9540
0949E:  MOVLW  04
094A0:  MOVLB  7
094A2:  MOVWF  x58
094A4:  MOVLW  C1
094A6:  MOVWF  x57
094A8:  MOVLB  0
094AA:  CALL   5C7E
094AE:  MOVF   01,W
094B0:  ADDLW  C1
094B2:  MOVLB  7
094B4:  MOVWF  x3A
094B6:  MOVLW  04
094B8:  ADDWFC 02,W
094BA:  MOVWF  x3B
094BC:  MOVLW  01
094BE:  SUBWF  x21,W
094C0:  MULLW  28
094C2:  MOVF   FF3,W
094C4:  CLRF   x3D
094C6:  MOVWF  x3C
094C8:  MOVLW  10
094CA:  ADDWF  x3C,W
094CC:  MOVWF  01
094CE:  MOVLW  00
094D0:  ADDWFC x3D,W
094D2:  MOVWF  03
094D4:  MOVF   01,W
094D6:  ADDLW  20
094D8:  MOVWF  FE9
094DA:  MOVLW  00
094DC:  ADDWFC 03,W
094DE:  MOVWF  FEA
094E0:  MOVFF  FEF,73C
094E4:  MOVFF  FEC,73D
094E8:  MOVFF  FEC,73E
094EC:  MOVFF  FEC,73F
094F0:  MOVFF  73B,565
094F4:  MOVFF  73A,564
094F8:  MOVFF  721,74A
094FC:  MOVLW  18
094FE:  MOVWF  x4B
09500:  MOVLB  0
09502:  CALL   62A2
09506:  MOVLW  2C
09508:  MOVLB  7
0950A:  MOVWF  x66
0950C:  MOVLB  0
0950E:  CALL   5CB6
09512:  MOVLW  89
09514:  MOVWF  FE9
09516:  MOVFF  73F,75C
0951A:  MOVFF  73E,75B
0951E:  MOVFF  73D,75A
09522:  MOVFF  73C,759
09526:  MOVLW  02
09528:  MOVLB  7
0952A:  MOVWF  x5D
0952C:  MOVLB  0
0952E:  CALL   6B62
09532:  MOVLW  2C
09534:  MOVLB  7
09536:  MOVWF  x66
09538:  MOVLB  0
0953A:  CALL   5CB6
0953E:  BRA    9774
....................    else if (0 == strcmp(s_CV, arg2))     sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].CV);
09540:  MOVFF  72A,758
09544:  MOVFF  729,757
09548:  MOVFF  723,75A
0954C:  MOVFF  722,759
09550:  CALL   5D34
09554:  MOVF   01,F
09556:  BNZ   95FA
09558:  MOVLW  04
0955A:  MOVLB  7
0955C:  MOVWF  x58
0955E:  MOVLW  C1
09560:  MOVWF  x57
09562:  MOVLB  0
09564:  CALL   5C7E
09568:  MOVF   01,W
0956A:  ADDLW  C1
0956C:  MOVLB  7
0956E:  MOVWF  x3A
09570:  MOVLW  04
09572:  ADDWFC 02,W
09574:  MOVWF  x3B
09576:  MOVLW  01
09578:  SUBWF  x21,W
0957A:  MULLW  28
0957C:  MOVF   FF3,W
0957E:  CLRF   x3D
09580:  MOVWF  x3C
09582:  MOVLW  18
09584:  ADDWF  x3C,W
09586:  MOVWF  01
09588:  MOVLW  00
0958A:  ADDWFC x3D,W
0958C:  MOVWF  03
0958E:  MOVF   01,W
09590:  ADDLW  20
09592:  MOVWF  FE9
09594:  MOVLW  00
09596:  ADDWFC 03,W
09598:  MOVWF  FEA
0959A:  MOVFF  FEF,73C
0959E:  MOVFF  FEC,73D
095A2:  MOVFF  FEC,73E
095A6:  MOVFF  FEC,73F
095AA:  MOVFF  73B,565
095AE:  MOVFF  73A,564
095B2:  MOVFF  721,74A
095B6:  MOVLW  18
095B8:  MOVWF  x4B
095BA:  MOVLB  0
095BC:  CALL   62A2
095C0:  MOVLW  2C
095C2:  MOVLB  7
095C4:  MOVWF  x66
095C6:  MOVLB  0
095C8:  CALL   5CB6
095CC:  MOVLW  89
095CE:  MOVWF  FE9
095D0:  MOVFF  73F,75C
095D4:  MOVFF  73E,75B
095D8:  MOVFF  73D,75A
095DC:  MOVFF  73C,759
095E0:  MOVLW  02
095E2:  MOVLB  7
095E4:  MOVWF  x5D
095E6:  MOVLB  0
095E8:  CALL   6B62
095EC:  MOVLW  2C
095EE:  MOVLB  7
095F0:  MOVWF  x66
095F2:  MOVLB  0
095F4:  CALL   5CB6
095F8:  BRA    9774
....................    else if (0 == strcmp(s_PVold, arg2))  sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].PVold);
095FA:  MOVFF  72F,758
095FE:  MOVFF  72E,757
09602:  MOVFF  723,75A
09606:  MOVFF  722,759
0960A:  CALL   5D34
0960E:  MOVF   01,F
09610:  BNZ   96B4
09612:  MOVLW  04
09614:  MOVLB  7
09616:  MOVWF  x58
09618:  MOVLW  C1
0961A:  MOVWF  x57
0961C:  MOVLB  0
0961E:  CALL   5C7E
09622:  MOVF   01,W
09624:  ADDLW  C1
09626:  MOVLB  7
09628:  MOVWF  x3A
0962A:  MOVLW  04
0962C:  ADDWFC 02,W
0962E:  MOVWF  x3B
09630:  MOVLW  01
09632:  SUBWF  x21,W
09634:  MULLW  28
09636:  MOVF   FF3,W
09638:  CLRF   x3D
0963A:  MOVWF  x3C
0963C:  MOVLW  14
0963E:  ADDWF  x3C,W
09640:  MOVWF  01
09642:  MOVLW  00
09644:  ADDWFC x3D,W
09646:  MOVWF  03
09648:  MOVF   01,W
0964A:  ADDLW  20
0964C:  MOVWF  FE9
0964E:  MOVLW  00
09650:  ADDWFC 03,W
09652:  MOVWF  FEA
09654:  MOVFF  FEF,73C
09658:  MOVFF  FEC,73D
0965C:  MOVFF  FEC,73E
09660:  MOVFF  FEC,73F
09664:  MOVFF  73B,565
09668:  MOVFF  73A,564
0966C:  MOVFF  721,74A
09670:  MOVLW  18
09672:  MOVWF  x4B
09674:  MOVLB  0
09676:  CALL   62A2
0967A:  MOVLW  2C
0967C:  MOVLB  7
0967E:  MOVWF  x66
09680:  MOVLB  0
09682:  CALL   5CB6
09686:  MOVLW  89
09688:  MOVWF  FE9
0968A:  MOVFF  73F,75C
0968E:  MOVFF  73E,75B
09692:  MOVFF  73D,75A
09696:  MOVFF  73C,759
0969A:  MOVLW  02
0969C:  MOVLB  7
0969E:  MOVWF  x5D
096A0:  MOVLB  0
096A2:  CALL   6B62
096A6:  MOVLW  2C
096A8:  MOVLB  7
096AA:  MOVWF  x66
096AC:  MOVLB  0
096AE:  CALL   5CB6
096B2:  BRA    9774
....................    else if (0 == strcmp(s_I, arg2))      sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].I);
096B4:  MOVFF  737,758
096B8:  MOVFF  736,757
096BC:  MOVFF  723,75A
096C0:  MOVFF  722,759
096C4:  CALL   5D34
096C8:  MOVF   01,F
096CA:  BNZ   976E
096CC:  MOVLW  04
096CE:  MOVLB  7
096D0:  MOVWF  x58
096D2:  MOVLW  C1
096D4:  MOVWF  x57
096D6:  MOVLB  0
096D8:  CALL   5C7E
096DC:  MOVF   01,W
096DE:  ADDLW  C1
096E0:  MOVLB  7
096E2:  MOVWF  x3A
096E4:  MOVLW  04
096E6:  ADDWFC 02,W
096E8:  MOVWF  x3B
096EA:  MOVLW  01
096EC:  SUBWF  x21,W
096EE:  MULLW  28
096F0:  MOVF   FF3,W
096F2:  CLRF   x3D
096F4:  MOVWF  x3C
096F6:  MOVLW  1C
096F8:  ADDWF  x3C,W
096FA:  MOVWF  01
096FC:  MOVLW  00
096FE:  ADDWFC x3D,W
09700:  MOVWF  03
09702:  MOVF   01,W
09704:  ADDLW  20
09706:  MOVWF  FE9
09708:  MOVLW  00
0970A:  ADDWFC 03,W
0970C:  MOVWF  FEA
0970E:  MOVFF  FEF,73C
09712:  MOVFF  FEC,73D
09716:  MOVFF  FEC,73E
0971A:  MOVFF  FEC,73F
0971E:  MOVFF  73B,565
09722:  MOVFF  73A,564
09726:  MOVFF  721,74A
0972A:  MOVLW  18
0972C:  MOVWF  x4B
0972E:  MOVLB  0
09730:  CALL   62A2
09734:  MOVLW  2C
09736:  MOVLB  7
09738:  MOVWF  x66
0973A:  MOVLB  0
0973C:  CALL   5CB6
09740:  MOVLW  89
09742:  MOVWF  FE9
09744:  MOVFF  73F,75C
09748:  MOVFF  73E,75B
0974C:  MOVFF  73D,75A
09750:  MOVFF  73C,759
09754:  MOVLW  02
09756:  MOVLB  7
09758:  MOVWF  x5D
0975A:  MOVLB  0
0975C:  CALL   6B62
09760:  MOVLW  2C
09762:  MOVLB  7
09764:  MOVWF  x66
09766:  MOVLB  0
09768:  CALL   5CB6
0976C:  BRA    9774
....................    else return INV_PARAM;
0976E:  MOVLW  02
09770:  MOVWF  01
09772:  BRA    9778
....................    
....................    return SUCCESS;
09774:  MOVLW  00
09776:  MOVWF  01
09778:  RETURN 0
.................... }
.................... 
.................... int8 getIPdata(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char *arg2;
....................    char *s_raw = "raw";
*
09898:  MOVLW  72
0989A:  MOVLB  7
0989C:  MOVWF  x26
0989E:  MOVLW  61
098A0:  MOVWF  x27
098A2:  MOVLW  77
098A4:  MOVWF  x28
098A6:  CLRF   x29
098A8:  MOVLW  07
098AA:  MOVWF  x25
098AC:  MOVLW  26
098AE:  MOVWF  x24
....................    char *s_calibrated = "calib";
098B0:  MOVLW  63
098B2:  MOVWF  x2C
098B4:  MOVLW  61
098B6:  MOVWF  x2D
098B8:  MOVLW  6C
098BA:  MOVWF  x2E
098BC:  MOVLW  69
098BE:  MOVWF  x2F
098C0:  MOVLW  62
098C2:  MOVWF  x30
098C4:  CLRF   x31
098C6:  MOVLW  07
098C8:  MOVWF  x2B
098CA:  MOVLW  2C
098CC:  MOVWF  x2A
....................    char *s_p0 = "p0";
098CE:  MOVLW  70
098D0:  MOVWF  x34
098D2:  MOVLW  30
098D4:  MOVWF  x35
098D6:  CLRF   x36
098D8:  MOVLW  07
098DA:  MOVWF  x33
098DC:  MOVLW  34
098DE:  MOVWF  x32
....................    char *s_poles = "poles";
098E0:  MOVLW  70
098E2:  MOVWF  x39
098E4:  MOVLW  6F
098E6:  MOVWF  x3A
098E8:  MOVLW  6C
098EA:  MOVWF  x3B
098EC:  MOVLW  65
098EE:  MOVWF  x3C
098F0:  MOVLW  73
098F2:  MOVWF  x3D
098F4:  CLRF   x3E
098F6:  MOVLW  07
098F8:  MOVWF  x38
098FA:  MOVLW  39
098FC:  MOVWF  x37
....................    char *s_real = "real";
098FE:  MOVLW  72
09900:  MOVWF  x41
09902:  MOVLW  65
09904:  MOVWF  x42
09906:  MOVLW  61
09908:  MOVWF  x43
0990A:  MOVLW  6C
0990C:  MOVWF  x44
0990E:  CLRF   x45
09910:  MOVLW  07
09912:  MOVWF  x40
09914:  MOVLW  41
09916:  MOVWF  x3F
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
09918:  CLRF   x5D
0991A:  MOVFF  6AB,75C
0991E:  CLRF   x5F
09920:  MOVLW  B5
09922:  MOVWF  x5E
09924:  MOVLB  0
09926:  CALL   086E
0992A:  MOVFF  02,747
0992E:  MOVFF  01,746
09932:  MOVLW  06
09934:  MOVLB  7
09936:  ADDWF  x46,F
09938:  MOVLW  00
0993A:  ADDWFC x47,F
0993C:  MOVLW  32
0993E:  ADDWF  x46,W
09940:  MOVWF  01
09942:  MOVLW  00
09944:  ADDWFC x47,W
09946:  MOVWF  03
09948:  MOVF   01,W
0994A:  ADDLW  EB
0994C:  MOVWF  01
0994E:  MOVLW  01
09950:  ADDWFC 03,F
09952:  MOVFF  01,746
09956:  MOVFF  03,747
0995A:  MOVFF  03,74A
0995E:  MOVFF  01,749
09962:  MOVLB  0
09964:  CALL   5E5E
09968:  MOVF   01,F
0996A:  BNZ   9974
0996C:  MOVLW  02
0996E:  MOVWF  01
09970:  BRA    9FB8
09972:  BRA    99D2
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
09974:  MOVLB  7
09976:  CLRF   x5D
09978:  MOVFF  6AB,75C
0997C:  CLRF   x5F
0997E:  MOVLW  B5
09980:  MOVWF  x5E
09982:  MOVLB  0
09984:  CALL   086E
09988:  MOVFF  02,747
0998C:  MOVFF  01,746
09990:  MOVLW  06
09992:  MOVLB  7
09994:  ADDWF  x46,F
09996:  MOVLW  00
09998:  ADDWFC x47,F
0999A:  MOVLW  32
0999C:  ADDWF  x46,W
0999E:  MOVWF  01
099A0:  MOVLW  00
099A2:  ADDWFC x47,W
099A4:  MOVWF  03
099A6:  MOVF   01,W
099A8:  ADDLW  EB
099AA:  MOVWF  01
099AC:  MOVLW  01
099AE:  ADDWFC 03,F
099B0:  MOVFF  01,746
099B4:  MOVFF  03,747
099B8:  MOVFF  03,74A
099BC:  MOVFF  01,749
099C0:  CLRF   x4C
099C2:  CLRF   x4B
099C4:  MOVLW  0A
099C6:  MOVWF  x4D
099C8:  MOVLB  0
099CA:  CALL   5F4E
099CE:  MOVFF  01,721
....................    
....................    arg2 = SERcmd[rec].p[3];
099D2:  MOVLB  7
099D4:  CLRF   x5D
099D6:  MOVFF  6AB,75C
099DA:  CLRF   x5F
099DC:  MOVLW  B5
099DE:  MOVWF  x5E
099E0:  MOVLB  0
099E2:  CALL   086E
099E6:  MOVFF  02,747
099EA:  MOVFF  01,746
099EE:  MOVLW  06
099F0:  MOVLB  7
099F2:  ADDWF  x46,F
099F4:  MOVLW  00
099F6:  ADDWFC x47,F
099F8:  MOVLW  4B
099FA:  ADDWF  x46,W
099FC:  MOVWF  01
099FE:  MOVLW  00
09A00:  ADDWFC x47,W
09A02:  MOVWF  03
09A04:  MOVF   01,W
09A06:  ADDLW  EB
09A08:  MOVWF  01
09A0A:  MOVLW  01
09A0C:  ADDWFC 03,F
09A0E:  MOVFF  01,722
09A12:  MOVFF  03,723
....................    
....................    /*** GET INPUT DATA ****************/
....................    if      (0 == strcmp(s_raw, arg2)) {
09A16:  MOVFF  725,758
09A1A:  MOVFF  724,757
09A1E:  MOVFF  723,75A
09A22:  MOVFF  722,759
09A26:  MOVLB  0
09A28:  CALL   5D34
09A2C:  MOVF   01,F
09A2E:  BTFSS  FD8.2
09A30:  BRA    9BAC
....................       sprintf(retData+strlen(retData), "%d,", arg1);
09A32:  MOVLW  04
09A34:  MOVLB  7
09A36:  MOVWF  x58
09A38:  MOVLW  C1
09A3A:  MOVWF  x57
09A3C:  MOVLB  0
09A3E:  CALL   5C7E
09A42:  MOVFF  02,03
09A46:  MOVF   01,W
09A48:  ADDLW  C1
09A4A:  MOVLB  7
09A4C:  MOVWF  x46
09A4E:  MOVLW  04
09A50:  ADDWFC 02,W
09A52:  MOVWF  x47
09A54:  MOVFF  FE8,565
09A58:  MOVFF  746,564
09A5C:  MOVFF  721,74A
09A60:  MOVLW  18
09A62:  MOVWF  x4B
09A64:  MOVLB  0
09A66:  CALL   62A2
09A6A:  MOVLW  2C
09A6C:  MOVLB  7
09A6E:  MOVWF  x66
09A70:  MOVLB  0
09A72:  CALL   5CB6
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].sinRaw);
09A76:  MOVLW  04
09A78:  MOVLB  7
09A7A:  MOVWF  x58
09A7C:  MOVLW  C1
09A7E:  MOVWF  x57
09A80:  MOVLB  0
09A82:  CALL   5C7E
09A86:  MOVFF  02,03
09A8A:  MOVF   01,W
09A8C:  ADDLW  C1
09A8E:  MOVLB  7
09A90:  MOVWF  x46
09A92:  MOVLW  04
09A94:  ADDWFC 02,W
09A96:  MOVWF  x47
09A98:  MOVLW  01
09A9A:  SUBWF  x21,W
09A9C:  MULLW  26
09A9E:  MOVF   FF3,W
09AA0:  CLRF   x49
09AA2:  MOVWF  x48
09AA4:  MOVLW  17
09AA6:  ADDWF  x48,W
09AA8:  MOVWF  FE9
09AAA:  MOVLW  01
09AAC:  ADDWFC x49,W
09AAE:  MOVWF  FEA
09AB0:  MOVFF  FEF,766
09AB4:  MOVFF  FEC,01
09AB8:  MOVFF  FEC,02
09ABC:  MOVFF  FEC,03
09AC0:  MOVFF  03,769
09AC4:  MOVFF  02,768
09AC8:  MOVFF  01,767
09ACC:  MOVLB  0
09ACE:  CALL   6A8C
09AD2:  MOVFF  03,74D
09AD6:  MOVFF  02,74C
09ADA:  MOVFF  01,74B
09ADE:  MOVFF  00,74A
09AE2:  MOVFF  747,565
09AE6:  MOVFF  746,564
09AEA:  MOVLW  41
09AEC:  MOVWF  FE9
09AEE:  MOVFF  03,752
09AF2:  MOVFF  02,751
09AF6:  MOVFF  01,750
09AFA:  MOVFF  00,74F
09AFE:  RCALL  977A
09B00:  MOVLW  2C
09B02:  MOVLB  7
09B04:  MOVWF  x66
09B06:  MOVLB  0
09B08:  CALL   5CB6
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].cosRaw);
09B0C:  MOVLW  04
09B0E:  MOVLB  7
09B10:  MOVWF  x58
09B12:  MOVLW  C1
09B14:  MOVWF  x57
09B16:  MOVLB  0
09B18:  CALL   5C7E
09B1C:  MOVF   01,W
09B1E:  ADDLW  C1
09B20:  MOVLB  7
09B22:  MOVWF  x46
09B24:  MOVLW  04
09B26:  ADDWFC 02,W
09B28:  MOVWF  x47
09B2A:  MOVLW  01
09B2C:  SUBWF  x21,W
09B2E:  MULLW  26
09B30:  MOVF   FF3,W
09B32:  CLRF   x49
09B34:  MOVWF  x48
09B36:  MOVLW  04
09B38:  ADDWF  x48,W
09B3A:  MOVWF  01
09B3C:  MOVLW  00
09B3E:  ADDWFC x49,W
09B40:  MOVWF  03
09B42:  MOVF   01,W
09B44:  ADDLW  17
09B46:  MOVWF  FE9
09B48:  MOVLW  01
09B4A:  ADDWFC 03,W
09B4C:  MOVWF  FEA
09B4E:  MOVFF  FEF,766
09B52:  MOVFF  FEC,01
09B56:  MOVFF  FEC,02
09B5A:  MOVFF  FEC,03
09B5E:  MOVFF  03,769
09B62:  MOVFF  02,768
09B66:  MOVFF  01,767
09B6A:  MOVLB  0
09B6C:  CALL   6A8C
09B70:  MOVFF  03,74B
09B74:  MOVFF  02,74A
09B78:  MOVFF  01,749
09B7C:  MOVFF  00,748
09B80:  MOVFF  747,565
09B84:  MOVFF  746,564
09B88:  MOVLW  41
09B8A:  MOVWF  FE9
09B8C:  MOVFF  03,752
09B90:  MOVFF  02,751
09B94:  MOVFF  01,750
09B98:  MOVFF  00,74F
09B9C:  RCALL  977A
09B9E:  MOVLW  2C
09BA0:  MOVLB  7
09BA2:  MOVWF  x66
09BA4:  MOVLB  0
09BA6:  CALL   5CB6
....................    }
09BAA:  BRA    9FB4
....................    else if (0 == strcmp(s_calibrated, arg2)) {
09BAC:  MOVFF  72B,758
09BB0:  MOVFF  72A,757
09BB4:  MOVFF  723,75A
09BB8:  MOVFF  722,759
09BBC:  CALL   5D34
09BC0:  MOVF   01,F
09BC2:  BTFSS  FD8.2
09BC4:  BRA    9D48
....................       sprintf(retData+strlen(retData), "%d,", arg1);
09BC6:  MOVLW  04
09BC8:  MOVLB  7
09BCA:  MOVWF  x58
09BCC:  MOVLW  C1
09BCE:  MOVWF  x57
09BD0:  MOVLB  0
09BD2:  CALL   5C7E
09BD6:  MOVFF  02,03
09BDA:  MOVF   01,W
09BDC:  ADDLW  C1
09BDE:  MOVLB  7
09BE0:  MOVWF  x46
09BE2:  MOVLW  04
09BE4:  ADDWFC 02,W
09BE6:  MOVWF  x47
09BE8:  MOVFF  FE8,565
09BEC:  MOVFF  746,564
09BF0:  MOVFF  721,74A
09BF4:  MOVLW  18
09BF6:  MOVWF  x4B
09BF8:  MOVLB  0
09BFA:  CALL   62A2
09BFE:  MOVLW  2C
09C00:  MOVLB  7
09C02:  MOVWF  x66
09C04:  MOVLB  0
09C06:  CALL   5CB6
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].sinCounts);
09C0A:  MOVLW  04
09C0C:  MOVLB  7
09C0E:  MOVWF  x58
09C10:  MOVLW  C1
09C12:  MOVWF  x57
09C14:  MOVLB  0
09C16:  CALL   5C7E
09C1A:  MOVF   01,W
09C1C:  ADDLW  C1
09C1E:  MOVLB  7
09C20:  MOVWF  x46
09C22:  MOVLW  04
09C24:  ADDWFC 02,W
09C26:  MOVWF  x47
09C28:  MOVLW  01
09C2A:  SUBWF  x21,W
09C2C:  MULLW  26
09C2E:  MOVF   FF3,W
09C30:  CLRF   x49
09C32:  MOVWF  x48
09C34:  MOVLW  08
09C36:  ADDWF  x48,W
09C38:  MOVWF  01
09C3A:  MOVLW  00
09C3C:  ADDWFC x49,W
09C3E:  MOVWF  03
09C40:  MOVF   01,W
09C42:  ADDLW  17
09C44:  MOVWF  FE9
09C46:  MOVLW  01
09C48:  ADDWFC 03,W
09C4A:  MOVWF  FEA
09C4C:  MOVFF  FEF,766
09C50:  MOVFF  FEC,01
09C54:  MOVFF  FEC,02
09C58:  MOVFF  FEC,03
09C5C:  MOVFF  03,769
09C60:  MOVFF  02,768
09C64:  MOVFF  01,767
09C68:  MOVLB  0
09C6A:  CALL   6A8C
09C6E:  MOVFF  03,74B
09C72:  MOVFF  02,74A
09C76:  MOVFF  01,749
09C7A:  MOVFF  00,748
09C7E:  MOVFF  747,565
09C82:  MOVFF  746,564
09C86:  MOVLW  41
09C88:  MOVWF  FE9
09C8A:  MOVFF  03,752
09C8E:  MOVFF  02,751
09C92:  MOVFF  01,750
09C96:  MOVFF  00,74F
09C9A:  RCALL  977A
09C9C:  MOVLW  2C
09C9E:  MOVLB  7
09CA0:  MOVWF  x66
09CA2:  MOVLB  0
09CA4:  CALL   5CB6
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].cosCounts);
09CA8:  MOVLW  04
09CAA:  MOVLB  7
09CAC:  MOVWF  x58
09CAE:  MOVLW  C1
09CB0:  MOVWF  x57
09CB2:  MOVLB  0
09CB4:  CALL   5C7E
09CB8:  MOVF   01,W
09CBA:  ADDLW  C1
09CBC:  MOVLB  7
09CBE:  MOVWF  x46
09CC0:  MOVLW  04
09CC2:  ADDWFC 02,W
09CC4:  MOVWF  x47
09CC6:  MOVLW  01
09CC8:  SUBWF  x21,W
09CCA:  MULLW  26
09CCC:  MOVF   FF3,W
09CCE:  CLRF   x49
09CD0:  MOVWF  x48
09CD2:  MOVLW  0C
09CD4:  ADDWF  x48,W
09CD6:  MOVWF  01
09CD8:  MOVLW  00
09CDA:  ADDWFC x49,W
09CDC:  MOVWF  03
09CDE:  MOVF   01,W
09CE0:  ADDLW  17
09CE2:  MOVWF  FE9
09CE4:  MOVLW  01
09CE6:  ADDWFC 03,W
09CE8:  MOVWF  FEA
09CEA:  MOVFF  FEF,766
09CEE:  MOVFF  FEC,01
09CF2:  MOVFF  FEC,02
09CF6:  MOVFF  FEC,03
09CFA:  MOVFF  03,769
09CFE:  MOVFF  02,768
09D02:  MOVFF  01,767
09D06:  MOVLB  0
09D08:  CALL   6A8C
09D0C:  MOVFF  03,74B
09D10:  MOVFF  02,74A
09D14:  MOVFF  01,749
09D18:  MOVFF  00,748
09D1C:  MOVFF  747,565
09D20:  MOVFF  746,564
09D24:  MOVLW  41
09D26:  MOVWF  FE9
09D28:  MOVFF  03,752
09D2C:  MOVFF  02,751
09D30:  MOVFF  01,750
09D34:  MOVFF  00,74F
09D38:  RCALL  977A
09D3A:  MOVLW  2C
09D3C:  MOVLB  7
09D3E:  MOVWF  x66
09D40:  MOVLB  0
09D42:  CALL   5CB6
....................    }
09D46:  BRA    9FB4
....................    else if (0 == strcmp(s_p0, arg2)) {
09D48:  MOVFF  733,758
09D4C:  MOVFF  732,757
09D50:  MOVFF  723,75A
09D54:  MOVFF  722,759
09D58:  CALL   5D34
09D5C:  MOVF   01,F
09D5E:  BNZ   9E1A
....................       sprintf(retData+strlen(retData), "%d,", arg1);
09D60:  MOVLW  04
09D62:  MOVLB  7
09D64:  MOVWF  x58
09D66:  MOVLW  C1
09D68:  MOVWF  x57
09D6A:  MOVLB  0
09D6C:  CALL   5C7E
09D70:  MOVFF  02,03
09D74:  MOVF   01,W
09D76:  ADDLW  C1
09D78:  MOVLB  7
09D7A:  MOVWF  x46
09D7C:  MOVLW  04
09D7E:  ADDWFC 02,W
09D80:  MOVWF  x47
09D82:  MOVFF  FE8,565
09D86:  MOVFF  746,564
09D8A:  MOVFF  721,74A
09D8E:  MOVLW  18
09D90:  MOVWF  x4B
09D92:  MOVLB  0
09D94:  CALL   62A2
09D98:  MOVLW  2C
09D9A:  MOVLB  7
09D9C:  MOVWF  x66
09D9E:  MOVLB  0
09DA0:  CALL   5CB6
....................       sprintf(retData+strlen(retData), "%f,", adcVals[arg1-1].p0);
09DA4:  MOVLW  04
09DA6:  MOVLB  7
09DA8:  MOVWF  x58
09DAA:  MOVLW  C1
09DAC:  MOVWF  x57
09DAE:  MOVLB  0
09DB0:  CALL   5C7E
09DB4:  MOVF   01,W
09DB6:  ADDLW  C1
09DB8:  MOVLB  7
09DBA:  MOVWF  x46
09DBC:  MOVLW  04
09DBE:  ADDWFC 02,W
09DC0:  MOVWF  x47
09DC2:  MOVLW  01
09DC4:  SUBWF  x21,W
09DC6:  MULLW  26
09DC8:  MOVF   FF3,W
09DCA:  CLRF   x49
09DCC:  MOVWF  x48
09DCE:  MOVLW  18
09DD0:  ADDWF  x48,W
09DD2:  MOVWF  01
09DD4:  MOVLW  00
09DD6:  ADDWFC x49,W
09DD8:  MOVWF  03
09DDA:  MOVF   01,W
09DDC:  ADDLW  17
09DDE:  MOVWF  FE9
09DE0:  MOVLW  01
09DE2:  ADDWFC 03,W
09DE4:  MOVWF  FEA
09DE6:  MOVFF  FEF,759
09DEA:  MOVFF  FEC,75A
09DEE:  MOVFF  FEC,75B
09DF2:  MOVFF  FEC,75C
09DF6:  MOVFF  747,565
09DFA:  MOVFF  746,564
09DFE:  MOVLW  89
09E00:  MOVWF  FE9
09E02:  MOVLW  02
09E04:  MOVWF  x5D
09E06:  MOVLB  0
09E08:  CALL   6B62
09E0C:  MOVLW  2C
09E0E:  MOVLB  7
09E10:  MOVWF  x66
09E12:  MOVLB  0
09E14:  CALL   5CB6
....................    }
09E18:  BRA    9FB4
....................    else if (0 == strcmp(s_poles, arg2)) {
09E1A:  MOVFF  738,758
09E1E:  MOVFF  737,757
09E22:  MOVFF  723,75A
09E26:  MOVFF  722,759
09E2A:  CALL   5D34
09E2E:  MOVF   01,F
09E30:  BNZ   9EDC
....................       sprintf(retData+strlen(retData), "%d,", arg1);
09E32:  MOVLW  04
09E34:  MOVLB  7
09E36:  MOVWF  x58
09E38:  MOVLW  C1
09E3A:  MOVWF  x57
09E3C:  MOVLB  0
09E3E:  CALL   5C7E
09E42:  MOVFF  02,03
09E46:  MOVF   01,W
09E48:  ADDLW  C1
09E4A:  MOVLB  7
09E4C:  MOVWF  x46
09E4E:  MOVLW  04
09E50:  ADDWFC 02,W
09E52:  MOVWF  x47
09E54:  MOVFF  FE8,565
09E58:  MOVFF  746,564
09E5C:  MOVFF  721,74A
09E60:  MOVLW  18
09E62:  MOVWF  x4B
09E64:  MOVLB  0
09E66:  CALL   62A2
09E6A:  MOVLW  2C
09E6C:  MOVLB  7
09E6E:  MOVWF  x66
09E70:  MOVLB  0
09E72:  CALL   5CB6
....................       sprintf(retData+strlen(retData), "%d,", adcVals[arg1-1].npoles);
09E76:  MOVLW  04
09E78:  MOVLB  7
09E7A:  MOVWF  x58
09E7C:  MOVLW  C1
09E7E:  MOVWF  x57
09E80:  MOVLB  0
09E82:  CALL   5C7E
09E86:  MOVF   01,W
09E88:  ADDLW  C1
09E8A:  MOVLB  7
09E8C:  MOVWF  x46
09E8E:  MOVLW  04
09E90:  ADDWFC 02,W
09E92:  MOVWF  x47
09E94:  MOVLW  01
09E96:  SUBWF  x21,W
09E98:  MULLW  26
09E9A:  MOVF   FF3,W
09E9C:  CLRF   x49
09E9E:  MOVWF  x48
09EA0:  MOVLW  1C
09EA2:  ADDWF  x48,W
09EA4:  MOVWF  01
09EA6:  MOVLW  00
09EA8:  ADDWFC x49,W
09EAA:  MOVWF  03
09EAC:  MOVF   01,W
09EAE:  ADDLW  17
09EB0:  MOVWF  FE9
09EB2:  MOVLW  01
09EB4:  ADDWFC 03,W
09EB6:  MOVWF  FEA
09EB8:  MOVFF  FEF,74A
09EBC:  MOVFF  747,565
09EC0:  MOVFF  746,564
09EC4:  MOVLW  18
09EC6:  MOVWF  x4B
09EC8:  MOVLB  0
09ECA:  CALL   62A2
09ECE:  MOVLW  2C
09ED0:  MOVLB  7
09ED2:  MOVWF  x66
09ED4:  MOVLB  0
09ED6:  CALL   5CB6
....................    }
09EDA:  BRA    9FB4
....................    else if (0 == strcmp(s_real, arg2)) {
09EDC:  MOVFF  740,758
09EE0:  MOVFF  73F,757
09EE4:  MOVFF  723,75A
09EE8:  MOVFF  722,759
09EEC:  CALL   5D34
09EF0:  MOVF   01,F
09EF2:  BNZ   9FAE
....................       sprintf(retData+strlen(retData), "%d,", arg1);
09EF4:  MOVLW  04
09EF6:  MOVLB  7
09EF8:  MOVWF  x58
09EFA:  MOVLW  C1
09EFC:  MOVWF  x57
09EFE:  MOVLB  0
09F00:  CALL   5C7E
09F04:  MOVFF  02,03
09F08:  MOVF   01,W
09F0A:  ADDLW  C1
09F0C:  MOVLB  7
09F0E:  MOVWF  x46
09F10:  MOVLW  04
09F12:  ADDWFC 02,W
09F14:  MOVWF  x47
09F16:  MOVFF  FE8,565
09F1A:  MOVFF  746,564
09F1E:  MOVFF  721,74A
09F22:  MOVLW  18
09F24:  MOVWF  x4B
09F26:  MOVLB  0
09F28:  CALL   62A2
09F2C:  MOVLW  2C
09F2E:  MOVLB  7
09F30:  MOVWF  x66
09F32:  MOVLB  0
09F34:  CALL   5CB6
....................       sprintf(retData+strlen(retData), "%f,", adcVals[arg1-1].pReal);
09F38:  MOVLW  04
09F3A:  MOVLB  7
09F3C:  MOVWF  x58
09F3E:  MOVLW  C1
09F40:  MOVWF  x57
09F42:  MOVLB  0
09F44:  CALL   5C7E
09F48:  MOVF   01,W
09F4A:  ADDLW  C1
09F4C:  MOVLB  7
09F4E:  MOVWF  x46
09F50:  MOVLW  04
09F52:  ADDWFC 02,W
09F54:  MOVWF  x47
09F56:  MOVLW  01
09F58:  SUBWF  x21,W
09F5A:  MULLW  26
09F5C:  MOVF   FF3,W
09F5E:  CLRF   x49
09F60:  MOVWF  x48
09F62:  MOVLW  1D
09F64:  ADDWF  x48,W
09F66:  MOVWF  01
09F68:  MOVLW  00
09F6A:  ADDWFC x49,W
09F6C:  MOVWF  03
09F6E:  MOVF   01,W
09F70:  ADDLW  17
09F72:  MOVWF  FE9
09F74:  MOVLW  01
09F76:  ADDWFC 03,W
09F78:  MOVWF  FEA
09F7A:  MOVFF  FEF,759
09F7E:  MOVFF  FEC,75A
09F82:  MOVFF  FEC,75B
09F86:  MOVFF  FEC,75C
09F8A:  MOVFF  747,565
09F8E:  MOVFF  746,564
09F92:  MOVLW  89
09F94:  MOVWF  FE9
09F96:  MOVLW  02
09F98:  MOVWF  x5D
09F9A:  MOVLB  0
09F9C:  CALL   6B62
09FA0:  MOVLW  2C
09FA2:  MOVLB  7
09FA4:  MOVWF  x66
09FA6:  MOVLB  0
09FA8:  CALL   5CB6
....................    }
09FAC:  BRA    9FB4
....................    else return INV_PARAM;
09FAE:  MOVLW  02
09FB0:  MOVWF  01
09FB2:  BRA    9FB8
....................    
....................    return SUCCESS;
09FB4:  MOVLW  00
09FB6:  MOVWF  01
09FB8:  RETURN 0
.................... }
.................... 
.................... int8 getManOPvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
09FBA:  MOVLB  7
09FBC:  CLRF   x5D
09FBE:  MOVFF  6AB,75C
09FC2:  CLRF   x5F
09FC4:  MOVLW  B5
09FC6:  MOVWF  x5E
09FC8:  MOVLB  0
09FCA:  CALL   086E
09FCE:  MOVFF  02,723
09FD2:  MOVFF  01,722
09FD6:  MOVLW  06
09FD8:  MOVLB  7
09FDA:  ADDWF  x22,F
09FDC:  MOVLW  00
09FDE:  ADDWFC x23,F
09FE0:  MOVLW  32
09FE2:  ADDWF  x22,W
09FE4:  MOVWF  01
09FE6:  MOVLW  00
09FE8:  ADDWFC x23,W
09FEA:  MOVWF  03
09FEC:  MOVF   01,W
09FEE:  ADDLW  EB
09FF0:  MOVWF  01
09FF2:  MOVLW  01
09FF4:  ADDWFC 03,F
09FF6:  MOVFF  01,722
09FFA:  MOVFF  03,723
09FFE:  MOVFF  03,74A
0A002:  MOVFF  01,749
0A006:  MOVLB  0
0A008:  CALL   5E5E
0A00C:  MOVF   01,F
0A00E:  BNZ   A018
0A010:  MOVLW  02
0A012:  MOVWF  01
0A014:  BRA    A11A
0A016:  BRA    A076
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
0A018:  MOVLB  7
0A01A:  CLRF   x5D
0A01C:  MOVFF  6AB,75C
0A020:  CLRF   x5F
0A022:  MOVLW  B5
0A024:  MOVWF  x5E
0A026:  MOVLB  0
0A028:  CALL   086E
0A02C:  MOVFF  02,723
0A030:  MOVFF  01,722
0A034:  MOVLW  06
0A036:  MOVLB  7
0A038:  ADDWF  x22,F
0A03A:  MOVLW  00
0A03C:  ADDWFC x23,F
0A03E:  MOVLW  32
0A040:  ADDWF  x22,W
0A042:  MOVWF  01
0A044:  MOVLW  00
0A046:  ADDWFC x23,W
0A048:  MOVWF  03
0A04A:  MOVF   01,W
0A04C:  ADDLW  EB
0A04E:  MOVWF  01
0A050:  MOVLW  01
0A052:  ADDWFC 03,F
0A054:  MOVFF  01,722
0A058:  MOVFF  03,723
0A05C:  MOVFF  03,74A
0A060:  MOVFF  01,749
0A064:  CLRF   x4C
0A066:  CLRF   x4B
0A068:  MOVLW  0A
0A06A:  MOVWF  x4D
0A06C:  MOVLB  0
0A06E:  CALL   5F4E
0A072:  MOVFF  01,721
....................    
....................    /*** GET MANUAL OUTPUT VALUE ***************/ 
....................    sprintf(retData+strlen(retData), "%d,%f,", arg1, dacVals[arg1-1].opPcnt);
0A076:  MOVLW  04
0A078:  MOVLB  7
0A07A:  MOVWF  x58
0A07C:  MOVLW  C1
0A07E:  MOVWF  x57
0A080:  MOVLB  0
0A082:  CALL   5C7E
0A086:  MOVF   01,W
0A088:  ADDLW  C1
0A08A:  MOVLB  7
0A08C:  MOVWF  x22
0A08E:  MOVLW  04
0A090:  ADDWFC 02,W
0A092:  MOVWF  x23
0A094:  MOVLW  01
0A096:  SUBWF  x21,W
0A098:  MULLW  07
0A09A:  MOVF   FF3,W
0A09C:  CLRF   x25
0A09E:  MOVWF  x24
0A0A0:  MOVLW  03
0A0A2:  ADDWF  x24,W
0A0A4:  MOVWF  01
0A0A6:  MOVLW  00
0A0A8:  ADDWFC x25,W
0A0AA:  MOVWF  03
0A0AC:  MOVF   01,W
0A0AE:  ADDLW  64
0A0B0:  MOVWF  FE9
0A0B2:  MOVLW  01
0A0B4:  ADDWFC 03,W
0A0B6:  MOVWF  FEA
0A0B8:  MOVFF  FEF,724
0A0BC:  MOVFF  FEC,725
0A0C0:  MOVFF  FEC,726
0A0C4:  MOVFF  FEC,727
0A0C8:  MOVFF  723,565
0A0CC:  MOVFF  722,564
0A0D0:  MOVFF  721,74A
0A0D4:  MOVLW  18
0A0D6:  MOVWF  x4B
0A0D8:  MOVLB  0
0A0DA:  CALL   62A2
0A0DE:  MOVLW  2C
0A0E0:  MOVLB  7
0A0E2:  MOVWF  x66
0A0E4:  MOVLB  0
0A0E6:  CALL   5CB6
0A0EA:  MOVLW  89
0A0EC:  MOVWF  FE9
0A0EE:  MOVFF  727,75C
0A0F2:  MOVFF  726,75B
0A0F6:  MOVFF  725,75A
0A0FA:  MOVFF  724,759
0A0FE:  MOVLW  02
0A100:  MOVLB  7
0A102:  MOVWF  x5D
0A104:  MOVLB  0
0A106:  CALL   6B62
0A10A:  MOVLW  2C
0A10C:  MOVLB  7
0A10E:  MOVWF  x66
0A110:  MOVLB  0
0A112:  CALL   5CB6
....................    
....................    return SUCCESS;
0A116:  MOVLW  00
0A118:  MOVWF  01
0A11A:  RETURN 0
.................... }
.................... 
.................... int8 setManOPvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    float arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0A11C:  MOVLB  7
0A11E:  CLRF   x5D
0A120:  MOVFF  6AB,75C
0A124:  CLRF   x5F
0A126:  MOVLW  B5
0A128:  MOVWF  x5E
0A12A:  MOVLB  0
0A12C:  CALL   086E
0A130:  MOVFF  02,727
0A134:  MOVFF  01,726
0A138:  MOVLW  06
0A13A:  MOVLB  7
0A13C:  ADDWF  x26,F
0A13E:  MOVLW  00
0A140:  ADDWFC x27,F
0A142:  MOVLW  32
0A144:  ADDWF  x26,W
0A146:  MOVWF  01
0A148:  MOVLW  00
0A14A:  ADDWFC x27,W
0A14C:  MOVWF  03
0A14E:  MOVF   01,W
0A150:  ADDLW  EB
0A152:  MOVWF  01
0A154:  MOVLW  01
0A156:  ADDWFC 03,F
0A158:  MOVFF  01,726
0A15C:  MOVFF  03,727
0A160:  MOVFF  03,74A
0A164:  MOVFF  01,749
0A168:  MOVLB  0
0A16A:  CALL   5E5E
0A16E:  MOVF   01,F
0A170:  BNZ   A17A
0A172:  MOVLW  02
0A174:  MOVWF  01
0A176:  BRA    A38C
0A178:  BRA    A1D8
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
0A17A:  MOVLB  7
0A17C:  CLRF   x5D
0A17E:  MOVFF  6AB,75C
0A182:  CLRF   x5F
0A184:  MOVLW  B5
0A186:  MOVWF  x5E
0A188:  MOVLB  0
0A18A:  CALL   086E
0A18E:  MOVFF  02,727
0A192:  MOVFF  01,726
0A196:  MOVLW  06
0A198:  MOVLB  7
0A19A:  ADDWF  x26,F
0A19C:  MOVLW  00
0A19E:  ADDWFC x27,F
0A1A0:  MOVLW  32
0A1A2:  ADDWF  x26,W
0A1A4:  MOVWF  01
0A1A6:  MOVLW  00
0A1A8:  ADDWFC x27,W
0A1AA:  MOVWF  03
0A1AC:  MOVF   01,W
0A1AE:  ADDLW  EB
0A1B0:  MOVWF  01
0A1B2:  MOVLW  01
0A1B4:  ADDWFC 03,F
0A1B6:  MOVFF  01,726
0A1BA:  MOVFF  03,727
0A1BE:  MOVFF  03,74A
0A1C2:  MOVFF  01,749
0A1C6:  CLRF   x4C
0A1C8:  CLRF   x4B
0A1CA:  MOVLW  0A
0A1CC:  MOVWF  x4D
0A1CE:  MOVLB  0
0A1D0:  CALL   5F4E
0A1D4:  MOVFF  01,721
....................    
....................    if (!arg_is_float(SERcmd[rec].p[3])) return INV_PARAM;
0A1D8:  MOVLB  7
0A1DA:  CLRF   x5D
0A1DC:  MOVFF  6AB,75C
0A1E0:  CLRF   x5F
0A1E2:  MOVLW  B5
0A1E4:  MOVWF  x5E
0A1E6:  MOVLB  0
0A1E8:  CALL   086E
0A1EC:  MOVFF  02,727
0A1F0:  MOVFF  01,726
0A1F4:  MOVLW  06
0A1F6:  MOVLB  7
0A1F8:  ADDWF  x26,F
0A1FA:  MOVLW  00
0A1FC:  ADDWFC x27,F
0A1FE:  MOVLW  4B
0A200:  ADDWF  x26,W
0A202:  MOVWF  01
0A204:  MOVLW  00
0A206:  ADDWFC x27,W
0A208:  MOVWF  03
0A20A:  MOVF   01,W
0A20C:  ADDLW  EB
0A20E:  MOVWF  01
0A210:  MOVLW  01
0A212:  ADDWFC 03,F
0A214:  MOVFF  01,726
0A218:  MOVFF  03,727
0A21C:  MOVFF  03,72B
0A220:  MOVFF  01,72A
0A224:  MOVLB  0
0A226:  CALL   71C8
0A22A:  MOVF   01,F
0A22C:  BNZ   A236
0A22E:  MOVLW  02
0A230:  MOVWF  01
0A232:  BRA    A38C
0A234:  BRA    A29C
....................    else arg2 = strtod(SERcmd[rec].p[3], '\0');
0A236:  MOVLB  7
0A238:  CLRF   x5D
0A23A:  MOVFF  6AB,75C
0A23E:  CLRF   x5F
0A240:  MOVLW  B5
0A242:  MOVWF  x5E
0A244:  MOVLB  0
0A246:  CALL   086E
0A24A:  MOVFF  02,727
0A24E:  MOVFF  01,726
0A252:  MOVLW  06
0A254:  MOVLB  7
0A256:  ADDWF  x26,F
0A258:  MOVLW  00
0A25A:  ADDWFC x27,F
0A25C:  MOVLW  4B
0A25E:  ADDWF  x26,W
0A260:  MOVWF  01
0A262:  MOVLW  00
0A264:  ADDWFC x27,W
0A266:  MOVWF  03
0A268:  MOVF   01,W
0A26A:  ADDLW  EB
0A26C:  MOVWF  01
0A26E:  MOVLW  01
0A270:  ADDWFC 03,F
0A272:  MOVFF  01,726
0A276:  MOVFF  03,727
0A27A:  MOVFF  03,72B
0A27E:  MOVFF  01,72A
0A282:  CLRF   x2D
0A284:  CLRF   x2C
0A286:  MOVLB  0
0A288:  CALL   728A
0A28C:  MOVFF  03,725
0A290:  MOVFF  02,724
0A294:  MOVFF  01,723
0A298:  MOVFF  00,722
....................    
....................    /*** SET MANUAL OUTPUT VALUE ***************/
....................    if (arg2 > op_upper_bound) dacVals[arg1-1].opPcnt = op_upper_bound;
0A29C:  MOVLB  7
0A29E:  CLRF   x6F
0A2A0:  CLRF   x6E
0A2A2:  MOVLW  7C
0A2A4:  MOVWF  x6D
0A2A6:  MOVLW  84
0A2A8:  MOVWF  x6C
0A2AA:  MOVFF  725,773
0A2AE:  MOVFF  724,772
0A2B2:  MOVFF  723,771
0A2B6:  MOVFF  722,770
0A2BA:  MOVLB  0
0A2BC:  CALL   0D62
0A2C0:  BNC   A2F6
0A2C2:  MOVLW  01
0A2C4:  MOVLB  7
0A2C6:  SUBWF  x21,W
0A2C8:  MULLW  07
0A2CA:  MOVF   FF3,W
0A2CC:  CLRF   x27
0A2CE:  MOVWF  x26
0A2D0:  MOVLW  03
0A2D2:  ADDWF  x26,W
0A2D4:  MOVWF  01
0A2D6:  MOVLW  00
0A2D8:  ADDWFC x27,W
0A2DA:  MOVWF  03
0A2DC:  MOVF   01,W
0A2DE:  ADDLW  64
0A2E0:  MOVWF  FE9
0A2E2:  MOVLW  01
0A2E4:  ADDWFC 03,W
0A2E6:  MOVWF  FEA
0A2E8:  MOVLW  84
0A2EA:  MOVWF  FEF
0A2EC:  MOVLW  7C
0A2EE:  MOVWF  FEC
0A2F0:  CLRF   FEC
0A2F2:  CLRF   FEC
0A2F4:  BRA    A386
....................    else if (arg2 < op_lower_bound) dacVals[arg1-1].opPcnt = op_lower_bound;  
0A2F6:  MOVFF  725,76F
0A2FA:  MOVFF  724,76E
0A2FE:  MOVFF  723,76D
0A302:  MOVFF  722,76C
0A306:  MOVLB  7
0A308:  CLRF   x73
0A30A:  CLRF   x72
0A30C:  MOVLW  FC
0A30E:  MOVWF  x71
0A310:  MOVLW  84
0A312:  MOVWF  x70
0A314:  MOVLB  0
0A316:  CALL   0D62
0A31A:  BNC   A350
0A31C:  MOVLW  01
0A31E:  MOVLB  7
0A320:  SUBWF  x21,W
0A322:  MULLW  07
0A324:  MOVF   FF3,W
0A326:  CLRF   x27
0A328:  MOVWF  x26
0A32A:  MOVLW  03
0A32C:  ADDWF  x26,W
0A32E:  MOVWF  01
0A330:  MOVLW  00
0A332:  ADDWFC x27,W
0A334:  MOVWF  03
0A336:  MOVF   01,W
0A338:  ADDLW  64
0A33A:  MOVWF  FE9
0A33C:  MOVLW  01
0A33E:  ADDWFC 03,W
0A340:  MOVWF  FEA
0A342:  MOVLW  84
0A344:  MOVWF  FEF
0A346:  MOVLW  FC
0A348:  MOVWF  FEC
0A34A:  CLRF   FEC
0A34C:  CLRF   FEC
0A34E:  BRA    A386
....................    else dacVals[arg1-1].opPcnt = arg2;
0A350:  MOVLW  01
0A352:  MOVLB  7
0A354:  SUBWF  x21,W
0A356:  MULLW  07
0A358:  MOVF   FF3,W
0A35A:  CLRF   x27
0A35C:  MOVWF  x26
0A35E:  MOVLW  03
0A360:  ADDWF  x26,W
0A362:  MOVWF  01
0A364:  MOVLW  00
0A366:  ADDWFC x27,W
0A368:  MOVWF  03
0A36A:  MOVF   01,W
0A36C:  ADDLW  64
0A36E:  MOVWF  FE9
0A370:  MOVLW  01
0A372:  ADDWFC 03,W
0A374:  MOVWF  FEA
0A376:  MOVFF  722,FEF
0A37A:  MOVFF  723,FEC
0A37E:  MOVFF  724,FEC
0A382:  MOVFF  725,FEC
....................    
....................    return SUCCESS;
0A386:  MOVLW  00
0A388:  MOVWF  01
0A38A:  MOVLB  0
0A38C:  RETURN 0
.................... }
.................... 
.................... int8 setFilterOn(unsigned int8 rec){
....................    adcFilter = TRUE;
0A38E:  MOVLB  1
0A390:  BSF    x63.0
....................    return SUCCESS;
0A392:  MOVLW  00
0A394:  MOVWF  01
0A396:  MOVLB  0
0A398:  RETURN 0
.................... }
.................... 
.................... int8 setFilterOff(unsigned int8 rec){
....................    adcFilter = FALSE;
0A39A:  MOVLB  1
0A39C:  BCF    x63.0
....................    return SUCCESS;
0A39E:  MOVLW  00
0A3A0:  MOVWF  01
0A3A2:  MOVLB  0
0A3A4:  RETURN 0
.................... }
.................... 
.................... int8 setHomeAxis(unsigned int8 rec){
....................     /*** ARG CHECKS ********************/
....................     int8 arg1;
....................     
....................     if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0A3A6:  MOVLB  7
0A3A8:  CLRF   x5D
0A3AA:  MOVFF  6AB,75C
0A3AE:  CLRF   x5F
0A3B0:  MOVLW  B5
0A3B2:  MOVWF  x5E
0A3B4:  MOVLB  0
0A3B6:  CALL   086E
0A3BA:  MOVFF  02,723
0A3BE:  MOVFF  01,722
0A3C2:  MOVLW  06
0A3C4:  MOVLB  7
0A3C6:  ADDWF  x22,F
0A3C8:  MOVLW  00
0A3CA:  ADDWFC x23,F
0A3CC:  MOVLW  32
0A3CE:  ADDWF  x22,W
0A3D0:  MOVWF  01
0A3D2:  MOVLW  00
0A3D4:  ADDWFC x23,W
0A3D6:  MOVWF  03
0A3D8:  MOVF   01,W
0A3DA:  ADDLW  EB
0A3DC:  MOVWF  01
0A3DE:  MOVLW  01
0A3E0:  ADDWFC 03,F
0A3E2:  MOVFF  01,722
0A3E6:  MOVFF  03,723
0A3EA:  MOVFF  03,74A
0A3EE:  MOVFF  01,749
0A3F2:  MOVLB  0
0A3F4:  CALL   5E5E
0A3F8:  MOVF   01,F
0A3FA:  BNZ   A404
0A3FC:  MOVLW  02
0A3FE:  MOVWF  01
0A400:  BRA    A490
0A402:  BRA    A462
....................     else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
0A404:  MOVLB  7
0A406:  CLRF   x5D
0A408:  MOVFF  6AB,75C
0A40C:  CLRF   x5F
0A40E:  MOVLW  B5
0A410:  MOVWF  x5E
0A412:  MOVLB  0
0A414:  CALL   086E
0A418:  MOVFF  02,723
0A41C:  MOVFF  01,722
0A420:  MOVLW  06
0A422:  MOVLB  7
0A424:  ADDWF  x22,F
0A426:  MOVLW  00
0A428:  ADDWFC x23,F
0A42A:  MOVLW  32
0A42C:  ADDWF  x22,W
0A42E:  MOVWF  01
0A430:  MOVLW  00
0A432:  ADDWFC x23,W
0A434:  MOVWF  03
0A436:  MOVF   01,W
0A438:  ADDLW  EB
0A43A:  MOVWF  01
0A43C:  MOVLW  01
0A43E:  ADDWFC 03,F
0A440:  MOVFF  01,722
0A444:  MOVFF  03,723
0A448:  MOVFF  03,74A
0A44C:  MOVFF  01,749
0A450:  CLRF   x4C
0A452:  CLRF   x4B
0A454:  MOVLW  0A
0A456:  MOVWF  x4D
0A458:  MOVLB  0
0A45A:  CALL   5F4E
0A45E:  MOVFF  01,721
....................     
....................     adcVals[arg1-1].homeFlag = TRUE;
0A462:  MOVLW  01
0A464:  MOVLB  7
0A466:  SUBWF  x21,W
0A468:  MULLW  26
0A46A:  MOVF   FF3,W
0A46C:  CLRF   x23
0A46E:  MOVWF  x22
0A470:  MOVLW  25
0A472:  ADDWF  x22,W
0A474:  MOVWF  01
0A476:  MOVLW  00
0A478:  ADDWFC x23,W
0A47A:  MOVWF  03
0A47C:  MOVF   01,W
0A47E:  ADDLW  17
0A480:  MOVWF  FE9
0A482:  MOVLW  01
0A484:  ADDWFC 03,W
0A486:  MOVWF  FEA
0A488:  BSF    FEF.0
....................     
....................     return SUCCESS;
0A48A:  MOVLW  00
0A48C:  MOVWF  01
0A48E:  MOVLB  0
0A490:  RETURN 0
.................... }
.................... 
.................... int8 getHome(unsigned int8 rec){
....................     /*** ARG CHECKS ********************/
....................     int8 arg1;
....................     
....................     if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
0A518:  MOVLB  7
0A51A:  CLRF   x5D
0A51C:  MOVFF  6AB,75C
0A520:  CLRF   x5F
0A522:  MOVLW  B5
0A524:  MOVWF  x5E
0A526:  MOVLB  0
0A528:  CALL   086E
0A52C:  MOVFF  02,723
0A530:  MOVFF  01,722
0A534:  MOVLW  06
0A536:  MOVLB  7
0A538:  ADDWF  x22,F
0A53A:  MOVLW  00
0A53C:  ADDWFC x23,F
0A53E:  MOVLW  32
0A540:  ADDWF  x22,W
0A542:  MOVWF  01
0A544:  MOVLW  00
0A546:  ADDWFC x23,W
0A548:  MOVWF  03
0A54A:  MOVF   01,W
0A54C:  ADDLW  EB
0A54E:  MOVWF  01
0A550:  MOVLW  01
0A552:  ADDWFC 03,F
0A554:  MOVFF  01,722
0A558:  MOVFF  03,723
0A55C:  MOVFF  03,74A
0A560:  MOVFF  01,749
0A564:  MOVLB  0
0A566:  CALL   5E5E
0A56A:  MOVF   01,F
0A56C:  BNZ   A576
0A56E:  MOVLW  02
0A570:  MOVWF  01
0A572:  BRA    A694
0A574:  BRA    A5D4
....................     else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
0A576:  MOVLB  7
0A578:  CLRF   x5D
0A57A:  MOVFF  6AB,75C
0A57E:  CLRF   x5F
0A580:  MOVLW  B5
0A582:  MOVWF  x5E
0A584:  MOVLB  0
0A586:  CALL   086E
0A58A:  MOVFF  02,723
0A58E:  MOVFF  01,722
0A592:  MOVLW  06
0A594:  MOVLB  7
0A596:  ADDWF  x22,F
0A598:  MOVLW  00
0A59A:  ADDWFC x23,F
0A59C:  MOVLW  32
0A59E:  ADDWF  x22,W
0A5A0:  MOVWF  01
0A5A2:  MOVLW  00
0A5A4:  ADDWFC x23,W
0A5A6:  MOVWF  03
0A5A8:  MOVF   01,W
0A5AA:  ADDLW  EB
0A5AC:  MOVWF  01
0A5AE:  MOVLW  01
0A5B0:  ADDWFC 03,F
0A5B2:  MOVFF  01,722
0A5B6:  MOVFF  03,723
0A5BA:  MOVFF  03,74A
0A5BE:  MOVFF  01,749
0A5C2:  CLRF   x4C
0A5C4:  CLRF   x4B
0A5C6:  MOVLW  0A
0A5C8:  MOVWF  x4D
0A5CA:  MOVLB  0
0A5CC:  CALL   5F4E
0A5D0:  MOVFF  01,721
....................     
....................     adcVals[arg1-1].pHome;
0A5D4:  MOVLW  01
0A5D6:  MOVLB  7
0A5D8:  SUBWF  x21,W
0A5DA:  MULLW  26
0A5DC:  MOVF   FF3,W
0A5DE:  MOVWF  x22
....................     sprintf(retData+strlen(retData), "HOME,%u,%f;", arg1, adcVals[arg1-1].pHome);
0A5E0:  MOVLW  04
0A5E2:  MOVWF  x58
0A5E4:  MOVLW  C1
0A5E6:  MOVWF  x57
0A5E8:  MOVLB  0
0A5EA:  CALL   5C7E
0A5EE:  MOVF   01,W
0A5F0:  ADDLW  C1
0A5F2:  MOVLB  7
0A5F4:  MOVWF  x22
0A5F6:  MOVLW  04
0A5F8:  ADDWFC 02,W
0A5FA:  MOVWF  x23
0A5FC:  MOVLW  01
0A5FE:  SUBWF  x21,W
0A600:  MULLW  26
0A602:  MOVF   FF3,W
0A604:  CLRF   x25
0A606:  MOVWF  x24
0A608:  MOVLW  21
0A60A:  ADDWF  x24,W
0A60C:  MOVWF  01
0A60E:  MOVLW  00
0A610:  ADDWFC x25,W
0A612:  MOVWF  03
0A614:  MOVF   01,W
0A616:  ADDLW  17
0A618:  MOVWF  FE9
0A61A:  MOVLW  01
0A61C:  ADDWFC 03,W
0A61E:  MOVWF  FEA
0A620:  MOVFF  FEF,724
0A624:  MOVFF  FEC,725
0A628:  MOVFF  FEC,726
0A62C:  MOVFF  FEC,727
0A630:  MOVFF  723,565
0A634:  MOVFF  722,564
0A638:  MOVLW  58
0A63A:  MOVWF  FF6
0A63C:  MOVLW  03
0A63E:  MOVWF  FF7
0A640:  MOVLW  05
0A642:  MOVWF  x2E
0A644:  MOVLB  0
0A646:  CALL   66B8
0A64A:  MOVFF  721,72E
0A64E:  MOVLW  1B
0A650:  MOVLB  7
0A652:  MOVWF  x2F
0A654:  MOVLB  0
0A656:  RCALL  A492
0A658:  MOVLW  2C
0A65A:  MOVLB  7
0A65C:  MOVWF  x66
0A65E:  MOVLB  0
0A660:  CALL   5CB6
0A664:  MOVLW  89
0A666:  MOVWF  FE9
0A668:  MOVFF  727,75C
0A66C:  MOVFF  726,75B
0A670:  MOVFF  725,75A
0A674:  MOVFF  724,759
0A678:  MOVLW  02
0A67A:  MOVLB  7
0A67C:  MOVWF  x5D
0A67E:  MOVLB  0
0A680:  CALL   6B62
0A684:  MOVLW  3B
0A686:  MOVLB  7
0A688:  MOVWF  x66
0A68A:  MOVLB  0
0A68C:  CALL   5CB6
....................     return SUCCESS;
0A690:  MOVLW  00
0A692:  MOVWF  01
0A694:  RETURN 0
.................... }
.................... 
.................... int8 getTelemetry(unsigned int8 rec){
....................     for (int ch=0; ch<2; ch++){
*
0A75E:  MOVLB  7
0A760:  CLRF   x21
0A762:  MOVF   x21,W
0A764:  SUBLW  01
0A766:  BTFSS  FD8.0
0A768:  BRA    AA9C
....................         sprintf(retData+strlen(retData), "CNT,%u,%.0f,%.0f;", ch+1, adcVals[ch].sinCounts, adcVals[ch].cosCounts);
0A76A:  MOVLW  04
0A76C:  MOVWF  x58
0A76E:  MOVLW  C1
0A770:  MOVWF  x57
0A772:  MOVLB  0
0A774:  CALL   5C7E
0A778:  MOVF   01,W
0A77A:  ADDLW  C1
0A77C:  MOVLB  7
0A77E:  MOVWF  x22
0A780:  MOVLW  04
0A782:  ADDWFC 02,W
0A784:  MOVWF  x23
0A786:  MOVLW  01
0A788:  ADDWF  x21,W
0A78A:  MOVWF  x24
0A78C:  MOVF   x21,W
0A78E:  MULLW  26
0A790:  MOVF   FF3,W
0A792:  CLRF   x26
0A794:  MOVWF  x25
0A796:  MOVLW  08
0A798:  ADDWF  x25,W
0A79A:  MOVWF  01
0A79C:  MOVLW  00
0A79E:  ADDWFC x26,W
0A7A0:  MOVWF  03
0A7A2:  MOVF   01,W
0A7A4:  ADDLW  17
0A7A6:  MOVWF  FE9
0A7A8:  MOVLW  01
0A7AA:  ADDWFC 03,W
0A7AC:  MOVWF  FEA
0A7AE:  MOVFF  FEF,725
0A7B2:  MOVFF  FEC,726
0A7B6:  MOVFF  FEC,727
0A7BA:  MOVFF  FEC,728
0A7BE:  MOVF   x21,W
0A7C0:  MULLW  26
0A7C2:  MOVF   FF3,W
0A7C4:  CLRF   x2A
0A7C6:  MOVWF  x29
0A7C8:  MOVLW  0C
0A7CA:  ADDWF  x29,W
0A7CC:  MOVWF  01
0A7CE:  MOVLW  00
0A7D0:  ADDWFC x2A,W
0A7D2:  MOVWF  03
0A7D4:  MOVF   01,W
0A7D6:  ADDLW  17
0A7D8:  MOVWF  FE9
0A7DA:  MOVLW  01
0A7DC:  ADDWFC 03,W
0A7DE:  MOVWF  FEA
0A7E0:  MOVFF  FEF,729
0A7E4:  MOVFF  FEC,72A
0A7E8:  MOVFF  FEC,72B
0A7EC:  MOVFF  FEC,72C
0A7F0:  MOVFF  723,565
0A7F4:  MOVFF  722,564
0A7F8:  MOVLW  64
0A7FA:  MOVWF  FF6
0A7FC:  MOVLW  03
0A7FE:  MOVWF  FF7
0A800:  MOVLW  04
0A802:  MOVWF  x2E
0A804:  MOVLB  0
0A806:  CALL   66B8
0A80A:  MOVFF  724,72E
0A80E:  MOVLW  1B
0A810:  MOVLB  7
0A812:  MOVWF  x2F
0A814:  MOVLB  0
0A816:  RCALL  A492
0A818:  MOVLW  2C
0A81A:  MOVLB  7
0A81C:  MOVWF  x66
0A81E:  MOVLB  0
0A820:  CALL   5CB6
0A824:  MOVLW  89
0A826:  MOVWF  FE9
0A828:  MOVFF  728,75C
0A82C:  MOVFF  727,75B
0A830:  MOVFF  726,75A
0A834:  MOVFF  725,759
0A838:  MOVLB  7
0A83A:  CLRF   x5D
0A83C:  MOVLB  0
0A83E:  CALL   6B62
0A842:  MOVLW  2C
0A844:  MOVLB  7
0A846:  MOVWF  x66
0A848:  MOVLB  0
0A84A:  CALL   5CB6
0A84E:  MOVLW  89
0A850:  MOVWF  FE9
0A852:  MOVFF  72C,75C
0A856:  MOVFF  72B,75B
0A85A:  MOVFF  72A,75A
0A85E:  MOVFF  729,759
0A862:  MOVLB  7
0A864:  CLRF   x5D
0A866:  MOVLB  0
0A868:  CALL   6B62
0A86C:  MOVLW  3B
0A86E:  MOVLB  7
0A870:  MOVWF  x66
0A872:  MOVLB  0
0A874:  CALL   5CB6
....................         sprintf(retData+strlen(retData), "POS,%u,%.3f;", ch+1, adcVals[ch].pReal);
0A878:  MOVLW  04
0A87A:  MOVLB  7
0A87C:  MOVWF  x58
0A87E:  MOVLW  C1
0A880:  MOVWF  x57
0A882:  MOVLB  0
0A884:  CALL   5C7E
0A888:  MOVF   01,W
0A88A:  ADDLW  C1
0A88C:  MOVLB  7
0A88E:  MOVWF  x22
0A890:  MOVLW  04
0A892:  ADDWFC 02,W
0A894:  MOVWF  x23
0A896:  MOVLW  01
0A898:  ADDWF  x21,W
0A89A:  MOVWF  x24
0A89C:  MOVF   x21,W
0A89E:  MULLW  26
0A8A0:  MOVF   FF3,W
0A8A2:  CLRF   x26
0A8A4:  MOVWF  x25
0A8A6:  MOVLW  1D
0A8A8:  ADDWF  x25,W
0A8AA:  MOVWF  01
0A8AC:  MOVLW  00
0A8AE:  ADDWFC x26,W
0A8B0:  MOVWF  03
0A8B2:  MOVF   01,W
0A8B4:  ADDLW  17
0A8B6:  MOVWF  FE9
0A8B8:  MOVLW  01
0A8BA:  ADDWFC 03,W
0A8BC:  MOVWF  FEA
0A8BE:  MOVFF  FEF,725
0A8C2:  MOVFF  FEC,726
0A8C6:  MOVFF  FEC,727
0A8CA:  MOVFF  FEC,728
0A8CE:  MOVFF  723,565
0A8D2:  MOVFF  722,564
0A8D6:  MOVLW  76
0A8D8:  MOVWF  FF6
0A8DA:  MOVLW  03
0A8DC:  MOVWF  FF7
0A8DE:  MOVLW  04
0A8E0:  MOVWF  x2E
0A8E2:  MOVLB  0
0A8E4:  CALL   66B8
0A8E8:  MOVFF  724,72E
0A8EC:  MOVLW  1B
0A8EE:  MOVLB  7
0A8F0:  MOVWF  x2F
0A8F2:  MOVLB  0
0A8F4:  RCALL  A492
0A8F6:  MOVLW  2C
0A8F8:  MOVLB  7
0A8FA:  MOVWF  x66
0A8FC:  MOVLB  0
0A8FE:  CALL   5CB6
0A902:  MOVLW  89
0A904:  MOVWF  FE9
0A906:  MOVFF  728,75C
0A90A:  MOVFF  727,75B
0A90E:  MOVFF  726,75A
0A912:  MOVFF  725,759
0A916:  MOVLW  03
0A918:  MOVLB  7
0A91A:  MOVWF  x5D
0A91C:  MOVLB  0
0A91E:  CALL   6B62
0A922:  MOVLW  3B
0A924:  MOVLB  7
0A926:  MOVWF  x66
0A928:  MOVLB  0
0A92A:  CALL   5CB6
....................         if ( dacVals[ch].invV ) sprintf(retData+strlen(retData), "OUT,%u,-,%Lu;", ch+1, dacVals[ch].ipVal);
0A92E:  MOVLB  7
0A930:  MOVF   x21,W
0A932:  MULLW  07
0A934:  MOVF   FF3,W
0A936:  CLRF   x23
0A938:  MOVWF  x22
0A93A:  MOVLW  64
0A93C:  ADDWF  x22,W
0A93E:  MOVWF  FE9
0A940:  MOVLW  01
0A942:  ADDWFC x23,W
0A944:  MOVWF  FEA
0A946:  BTFSS  FEF.0
0A948:  BRA    A9F2
0A94A:  MOVLW  04
0A94C:  MOVWF  x58
0A94E:  MOVLW  C1
0A950:  MOVWF  x57
0A952:  MOVLB  0
0A954:  CALL   5C7E
0A958:  MOVF   01,W
0A95A:  ADDLW  C1
0A95C:  MOVLB  7
0A95E:  MOVWF  x22
0A960:  MOVLW  04
0A962:  ADDWFC 02,W
0A964:  MOVWF  x23
0A966:  MOVLW  01
0A968:  ADDWF  x21,W
0A96A:  MOVWF  x24
0A96C:  MOVF   x21,W
0A96E:  MULLW  07
0A970:  MOVF   FF3,W
0A972:  CLRF   x26
0A974:  MOVWF  x25
0A976:  MOVLW  01
0A978:  ADDWF  x25,W
0A97A:  MOVWF  01
0A97C:  MOVLW  00
0A97E:  ADDWFC x26,W
0A980:  MOVWF  03
0A982:  MOVF   01,W
0A984:  ADDLW  64
0A986:  MOVWF  FE9
0A988:  MOVLW  01
0A98A:  ADDWFC 03,W
0A98C:  MOVWF  FEA
0A98E:  MOVFF  FEC,726
0A992:  MOVF   FED,F
0A994:  MOVFF  FEF,725
0A998:  MOVFF  723,565
0A99C:  MOVFF  722,564
0A9A0:  MOVLW  84
0A9A2:  MOVWF  FF6
0A9A4:  MOVLW  03
0A9A6:  MOVWF  FF7
0A9A8:  MOVLW  04
0A9AA:  MOVWF  x2E
0A9AC:  MOVLB  0
0A9AE:  CALL   66B8
0A9B2:  MOVFF  724,72E
0A9B6:  MOVLW  1B
0A9B8:  MOVLB  7
0A9BA:  MOVWF  x2F
0A9BC:  MOVLB  0
0A9BE:  RCALL  A492
0A9C0:  MOVLW  8A
0A9C2:  MOVWF  FF6
0A9C4:  MOVLW  03
0A9C6:  MOVWF  FF7
0A9C8:  MOVLW  03
0A9CA:  MOVLB  7
0A9CC:  MOVWF  x2E
0A9CE:  MOVLB  0
0A9D0:  CALL   66B8
0A9D4:  MOVLW  10
0A9D6:  MOVWF  FE9
0A9D8:  MOVFF  726,729
0A9DC:  MOVFF  725,728
0A9E0:  RCALL  A696
0A9E2:  MOVLW  3B
0A9E4:  MOVLB  7
0A9E6:  MOVWF  x66
0A9E8:  MOVLB  0
0A9EA:  CALL   5CB6
0A9EE:  BRA    AA96
0A9F0:  MOVLB  7
....................         else                    sprintf(retData+strlen(retData), "OUT,%u,+,%Lu;", ch+1, dacVals[ch].ipVal);
0A9F2:  MOVLW  04
0A9F4:  MOVWF  x58
0A9F6:  MOVLW  C1
0A9F8:  MOVWF  x57
0A9FA:  MOVLB  0
0A9FC:  CALL   5C7E
0AA00:  MOVF   01,W
0AA02:  ADDLW  C1
0AA04:  MOVLB  7
0AA06:  MOVWF  x22
0AA08:  MOVLW  04
0AA0A:  ADDWFC 02,W
0AA0C:  MOVWF  x23
0AA0E:  MOVLW  01
0AA10:  ADDWF  x21,W
0AA12:  MOVWF  x24
0AA14:  MOVF   x21,W
0AA16:  MULLW  07
0AA18:  MOVF   FF3,W
0AA1A:  CLRF   x26
0AA1C:  MOVWF  x25
0AA1E:  MOVLW  01
0AA20:  ADDWF  x25,W
0AA22:  MOVWF  01
0AA24:  MOVLW  00
0AA26:  ADDWFC x26,W
0AA28:  MOVWF  03
0AA2A:  MOVF   01,W
0AA2C:  ADDLW  64
0AA2E:  MOVWF  FE9
0AA30:  MOVLW  01
0AA32:  ADDWFC 03,W
0AA34:  MOVWF  FEA
0AA36:  MOVFF  FEC,726
0AA3A:  MOVF   FED,F
0AA3C:  MOVFF  FEF,725
0AA40:  MOVFF  723,565
0AA44:  MOVFF  722,564
0AA48:  MOVLW  92
0AA4A:  MOVWF  FF6
0AA4C:  MOVLW  03
0AA4E:  MOVWF  FF7
0AA50:  MOVLW  04
0AA52:  MOVWF  x2E
0AA54:  MOVLB  0
0AA56:  CALL   66B8
0AA5A:  MOVFF  724,72E
0AA5E:  MOVLW  1B
0AA60:  MOVLB  7
0AA62:  MOVWF  x2F
0AA64:  MOVLB  0
0AA66:  RCALL  A492
0AA68:  MOVLW  98
0AA6A:  MOVWF  FF6
0AA6C:  MOVLW  03
0AA6E:  MOVWF  FF7
0AA70:  MOVLW  03
0AA72:  MOVLB  7
0AA74:  MOVWF  x2E
0AA76:  MOVLB  0
0AA78:  CALL   66B8
0AA7C:  MOVLW  10
0AA7E:  MOVWF  FE9
0AA80:  MOVFF  726,729
0AA84:  MOVFF  725,728
0AA88:  RCALL  A696
0AA8A:  MOVLW  3B
0AA8C:  MOVLB  7
0AA8E:  MOVWF  x66
0AA90:  MOVLB  0
0AA92:  CALL   5CB6
0AA96:  MOVLB  7
0AA98:  INCF   x21,F
0AA9A:  BRA    A762
....................     }
....................     return SUCCESS;
0AA9C:  MOVLW  00
0AA9E:  MOVWF  01
0AAA0:  MOVLB  0
0AAA2:  RETURN 0
.................... }
.................... 
.................... int8 invalidCmd(unsigned int8 rec){
....................    return INV_CMD;
0AAA4:  MOVLW  01
0AAA6:  MOVWF  01
0AAA8:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* ARG VALIDATION HELPER FUNCS                                               */
.................... /*****************************************************************************/
.................... BOOLEAN arg_is_float(char *arg){
*
071C8:  MOVLB  7
071CA:  BCF    x2C.0
....................    BOOLEAN decimal = FALSE;
....................    for (int i=0; i<strlen(arg); i++){
071CC:  CLRF   x2D
071CE:  MOVFF  72B,758
071D2:  MOVFF  72A,757
071D6:  MOVLB  0
071D8:  CALL   5C7E
071DC:  MOVFF  02,03
071E0:  MOVF   01,W
071E2:  MOVF   03,F
071E4:  BNZ   71F0
071E6:  MOVF   01,W
071E8:  MOVLB  7
071EA:  SUBWF  x2D,W
071EC:  BC    7282
071EE:  MOVLB  0
....................       if (!isdigit(arg[i])){
071F0:  MOVLB  7
071F2:  MOVF   x2D,W
071F4:  ADDWF  x2A,W
071F6:  MOVWF  FE9
071F8:  MOVLW  00
071FA:  ADDWFC x2B,W
071FC:  MOVWF  FEA
071FE:  MOVFF  FEF,72E
07202:  MOVF   x2E,W
07204:  SUBLW  2F
07206:  BC    720E
07208:  MOVF   x2E,W
0720A:  SUBLW  39
0720C:  BC    727A
....................          // Check for negative sign
....................          if ('-' != arg[i]){
0720E:  MOVF   x2D,W
07210:  ADDWF  x2A,W
07212:  MOVWF  FE9
07214:  MOVLW  00
07216:  ADDWFC x2B,W
07218:  MOVWF  FEA
0721A:  MOVF   FEF,W
0721C:  SUBLW  2D
0721E:  BZ    724A
....................             // Check for decimal
....................             if ('.' != arg[i]) return FALSE;
07220:  MOVF   x2D,W
07222:  ADDWF  x2A,W
07224:  MOVWF  FE9
07226:  MOVLW  00
07228:  ADDWFC x2B,W
0722A:  MOVWF  FEA
0722C:  MOVF   FEF,W
0722E:  SUBLW  2E
07230:  BZ    723A
07232:  MOVLW  00
07234:  MOVWF  01
07236:  BRA    7286
07238:  BRA    7248
....................             else if  (decimal) return FALSE;
0723A:  BTFSS  x2C.0
0723C:  BRA    7246
0723E:  MOVLW  00
07240:  MOVWF  01
07242:  BRA    7286
07244:  BRA    7248
....................             else decimal = TRUE;
07246:  BSF    x2C.0
....................          }
07248:  BRA    727A
....................          else if (0 != i) return FALSE;
0724A:  MOVF   x2D,F
0724C:  BZ    7256
0724E:  MOVLW  00
07250:  MOVWF  01
07252:  BRA    7286
07254:  BRA    727A
....................          else if (1 == strlen(arg)) return FALSE;
07256:  MOVFF  72B,758
0725A:  MOVFF  72A,757
0725E:  MOVLB  0
07260:  CALL   5C7E
07264:  MOVFF  02,03
07268:  MOVF   01,W
0726A:  SUBLW  01
0726C:  BNZ   727C
0726E:  MOVF   03,F
07270:  BNZ   727C
07272:  MOVLW  00
07274:  MOVWF  01
07276:  MOVLB  7
07278:  BRA    7286
0727A:  MOVLB  0
....................       }
0727C:  MOVLB  7
0727E:  INCF   x2D,F
07280:  BRA    71CE
....................    }
....................    return TRUE;
07282:  MOVLW  01
07284:  MOVWF  01
07286:  MOVLB  0
07288:  RETURN 0
.................... }
.................... 
.................... BOOLEAN is_valid_channel(char *arg){
....................     if (1 != strlen(arg)) return FALSE;
*
05E5E:  MOVFF  74A,758
05E62:  MOVFF  749,757
05E66:  RCALL  5C7E
05E68:  MOVFF  02,03
05E6C:  MOVF   01,W
05E6E:  SUBLW  01
05E70:  BNZ   5E76
05E72:  MOVF   03,F
05E74:  BZ    5E7E
05E76:  MOVLW  00
05E78:  MOVWF  01
05E7A:  BRA    5EAC
05E7C:  BRA    5EA4
....................     else if ('1' != arg[0] && '2' != arg[0]) return FALSE;
05E7E:  MOVLB  7
05E80:  MOVFF  749,FE9
05E84:  MOVFF  74A,FEA
05E88:  MOVF   FEF,W
05E8A:  SUBLW  31
05E8C:  BZ    5EA6
05E8E:  MOVFF  749,FE9
05E92:  MOVFF  74A,FEA
05E96:  MOVF   FEF,W
05E98:  SUBLW  32
05E9A:  BZ    5EA6
05E9C:  MOVLW  00
05E9E:  MOVWF  01
05EA0:  MOVLB  0
05EA2:  BRA    5EAC
05EA4:  MOVLB  7
....................     return TRUE;
05EA6:  MOVLW  01
05EA8:  MOVWF  01
05EAA:  MOVLB  0
05EAC:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* ASCII HEX CHARACTER TO INT                                                */
.................... /*****************************************************************************/
.................... int8 hex_to_int(char ascii){
....................    if (ascii >= '0' && ascii <= '9') return ascii-'0';
*
05CFA:  MOVLB  7
05CFC:  MOVF   x20,W
05CFE:  SUBLW  2F
05D00:  BC    5D12
05D02:  MOVF   x20,W
05D04:  SUBLW  39
05D06:  BNC   5D12
05D08:  MOVLW  30
05D0A:  SUBWF  x20,W
05D0C:  MOVWF  01
05D0E:  BRA    5D2E
05D10:  BRA    5D2E
....................    else if (ascii >= 'A' && ascii <= 'F') return ascii-'A'+10;
05D12:  MOVF   x20,W
05D14:  SUBLW  40
05D16:  BC    5D2A
05D18:  MOVF   x20,W
05D1A:  SUBLW  46
05D1C:  BNC   5D2A
05D1E:  MOVLW  41
05D20:  SUBWF  x20,W
05D22:  ADDLW  0A
05D24:  MOVWF  01
05D26:  BRA    5D2E
05D28:  BRA    5D2E
....................    else return 0xFF;
05D2A:  MOVLW  FF
05D2C:  MOVWF  01
05D2E:  MOVLB  0
05D30:  GOTO   AB4E (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* COMMAND HANDLER/PARSER FUNCS                                              */
.................... /*****************************************************************************/
.................... void echo_cmd(unsigned int8 rec){
....................    /* NEEDS FIXING
....................    fprintf(SERIAL, "%c", SERcmd[rec].t);
....................    while (SERcmd[rec].recReadIndex <= SERcmd[rec].recWriteIndex)
....................    {
....................       if (SERcmd[rec].recReadIndex != 0) fprintf(SERIAL, "%c", delimiter);
....................       fprintf(SERIAL, "%s", SERcmd[rec].p[SERcmd[rec].recReadIndex]);
....................       SERcmd[rec].recReadIndex++;
....................    }
....................    SERcmd[rec].recReadIndex=0;
....................    */
.................... }
.................... 
.................... int8 command_parser(unsigned int8 rec){
*
0AAAA:  MOVLB  7
0AAAC:  CLRF   x5D
0AAAE:  MOVFF  717,75C
0AAB2:  CLRF   x5F
0AAB4:  MOVLW  B5
0AAB6:  MOVWF  x5E
0AAB8:  MOVLB  0
0AABA:  CALL   086E
0AABE:  MOVFF  02,720
0AAC2:  MOVFF  01,71F
0AAC6:  MOVLW  06
0AAC8:  MOVLB  7
0AACA:  ADDWF  x1F,F
0AACC:  MOVLW  00
0AACE:  ADDWFC x20,F
0AAD0:  MOVLW  EB
0AAD2:  ADDWF  x1F,W
0AAD4:  MOVWF  01
0AAD6:  MOVLW  01
0AAD8:  ADDWFC x20,W
0AADA:  MOVWF  03
0AADC:  MOVFF  01,718
0AAE0:  MOVWF  x19
0AAE2:  CLRF   x5D
0AAE4:  MOVFF  717,75C
0AAE8:  CLRF   x5F
0AAEA:  MOVLW  B5
0AAEC:  MOVWF  x5E
0AAEE:  MOVLB  0
0AAF0:  CALL   086E
0AAF4:  MOVFF  02,722
0AAF8:  MOVFF  01,721
0AAFC:  MOVLW  06
0AAFE:  MOVLB  7
0AB00:  ADDWF  x21,F
0AB02:  MOVLW  00
0AB04:  ADDWFC x22,F
0AB06:  MOVLW  19
0AB08:  ADDWF  x21,W
0AB0A:  MOVWF  01
0AB0C:  MOVLW  00
0AB0E:  ADDWFC x22,W
0AB10:  MOVWF  03
0AB12:  MOVF   01,W
0AB14:  ADDLW  EB
0AB16:  MOVWF  01
0AB18:  MOVLW  01
0AB1A:  ADDWFC 03,F
0AB1C:  MOVFF  01,71A
0AB20:  MOVFF  03,71B
0AB24:  CLRF   x1C
0AB26:  CLRF   x1D
....................    char *cmd_adr = SERcmd[rec].p[0];
....................    char *cmd_str = SERcmd[rec].p[1];
.................... //!   int8 devID = input_a();
....................    int8 devID = 0;
....................    int8 i = 0;
....................    
....................    if (hwID == cmd_adr[0]){
0AB28:  MOVFF  718,FE9
0AB2C:  MOVFF  719,FEA
0AB30:  MOVF   FEF,W
0AB32:  SUBLW  44
0AB34:  BTFSS  FD8.2
0AB36:  BRA    AC26
....................       if (hex_to_int(cmd_adr[1]) == (devID & 0x0F)){
0AB38:  MOVLW  01
0AB3A:  ADDWF  x18,W
0AB3C:  MOVWF  FE9
0AB3E:  MOVLW  00
0AB40:  ADDWFC x19,W
0AB42:  MOVWF  FEA
0AB44:  MOVFF  FEF,720
0AB48:  MOVLB  0
0AB4A:  GOTO   5CFA
0AB4E:  MOVFF  01,71F
0AB52:  MOVLB  7
0AB54:  MOVF   x1C,W
0AB56:  ANDLW  0F
0AB58:  SUBWF  01,W
0AB5A:  BNZ   AC1E
....................          while (0 != strlen(cmd_list[i].cmd_name)){
0AB5C:  MOVF   x1D,W
0AB5E:  MULLW  04
0AB60:  MOVF   FF3,W
0AB62:  CLRF   x20
0AB64:  MOVWF  x1F
0AB66:  MOVLW  6A
0AB68:  ADDWF  x1F,W
0AB6A:  MOVWF  FE9
0AB6C:  MOVLW  05
0AB6E:  ADDWFC x20,W
0AB70:  MOVWF  FEA
0AB72:  MOVFF  FEC,758
0AB76:  MOVF   FED,F
0AB78:  MOVFF  FEF,757
0AB7C:  MOVLB  0
0AB7E:  CALL   5C7E
0AB82:  MOVFF  02,03
0AB86:  MOVF   01,W
0AB88:  BNZ   AB8E
0AB8A:  MOVF   03,F
0AB8C:  BZ    AC14
....................             if (0 == strcmp(cmd_str, cmd_list[i].cmd_name))
0AB8E:  MOVLB  7
0AB90:  MOVF   x1D,W
0AB92:  MULLW  04
0AB94:  MOVF   FF3,W
0AB96:  CLRF   x20
0AB98:  MOVWF  x1F
0AB9A:  MOVLW  6A
0AB9C:  ADDWF  x1F,W
0AB9E:  MOVWF  FE9
0ABA0:  MOVLW  05
0ABA2:  ADDWFC x20,W
0ABA4:  MOVWF  FEA
0ABA6:  MOVFF  FEC,75A
0ABAA:  MOVF   FED,F
0ABAC:  MOVFF  FEF,759
0ABB0:  MOVFF  71B,758
0ABB4:  MOVFF  71A,757
0ABB8:  MOVLB  0
0ABBA:  CALL   5D34
0ABBE:  MOVF   01,F
0ABC0:  BNZ   AC0C
....................             {
....................                int8 return_code = cmd_list[i].cmd_func(rec);
0ABC2:  MOVLB  7
0ABC4:  MOVF   x1D,W
0ABC6:  MULLW  04
0ABC8:  MOVF   FF3,W
0ABCA:  CLRF   x20
0ABCC:  MOVWF  x1F
0ABCE:  MOVLW  02
0ABD0:  ADDWF  x1F,W
0ABD2:  MOVWF  01
0ABD4:  MOVLW  00
0ABD6:  ADDWFC x20,W
0ABD8:  MOVWF  03
0ABDA:  MOVF   01,W
0ABDC:  ADDLW  6A
0ABDE:  MOVWF  01
0ABE0:  MOVLW  05
0ABE2:  ADDWFC 03,F
0ABE4:  MOVFF  01,71F
0ABE8:  MOVFF  03,720
0ABEC:  MOVFF  03,FEA
0ABF0:  MOVFF  01,FE9
0ABF4:  MOVFF  717,6AB
0ABF8:  MOVLB  0
0ABFA:  CALL   00BC
0ABFE:  MOVFF  01,71E
....................                return return_code;
0AC02:  MOVLB  7
0AC04:  MOVFF  71E,01
0AC08:  BRA    AC2A
0AC0A:  MOVLB  0
....................             }
....................             i++;
0AC0C:  MOVLB  7
0AC0E:  INCF   x1D,F
0AC10:  BRA    AB5C
0AC12:  MOVLB  0
....................          }
....................          return INV_CMD; // INVALID_CMD
0AC14:  MOVLW  01
0AC16:  MOVWF  01
0AC18:  MOVLB  7
0AC1A:  BRA    AC2A
....................       } else return 254; // NOT THIS ADDRESS
0AC1C:  BRA    AC24
0AC1E:  MOVLW  FE
0AC20:  MOVWF  01
0AC22:  BRA    AC2A
....................    } else return 255; // NOT THIS DEVICE TYPE
0AC24:  BRA    AC2A
0AC26:  MOVLW  FF
0AC28:  MOVWF  01
0AC2A:  MOVLB  0
0AC2C:  GOTO   ACCC (RETURN)
.................... }
.................... 
.................... void command_handler_task(){
....................     while (getNextSERReadIndex())
0AC30:  GOTO   5C24
0AC34:  MOVF   01,F
0AC36:  BTFSC  FD8.2
0AC38:  BRA    AD54
....................     {
....................         int8 return_code;
....................         //echo_cmd(SRI);
....................         sprintf(retData + strlen(retData), "$%s,", SERcmd[SRI].p[0]);
0AC3A:  MOVLW  04
0AC3C:  MOVLB  7
0AC3E:  MOVWF  x58
0AC40:  MOVLW  C1
0AC42:  MOVWF  x57
0AC44:  MOVLB  0
0AC46:  CALL   5C7E
0AC4A:  MOVFF  02,03
0AC4E:  MOVF   01,W
0AC50:  ADDLW  C1
0AC52:  MOVLB  7
0AC54:  MOVWF  x17
0AC56:  MOVLW  04
0AC58:  ADDWFC 02,W
0AC5A:  MOVWF  x18
0AC5C:  CLRF   x5D
0AC5E:  MOVFF  4BF,75C
0AC62:  CLRF   x5F
0AC64:  MOVLW  B5
0AC66:  MOVWF  x5E
0AC68:  MOVLB  0
0AC6A:  CALL   086E
0AC6E:  MOVFF  02,71A
0AC72:  MOVFF  01,719
0AC76:  MOVLW  06
0AC78:  MOVLB  7
0AC7A:  ADDWF  x19,F
0AC7C:  MOVLW  00
0AC7E:  ADDWFC x1A,F
0AC80:  MOVLW  EB
0AC82:  ADDWF  x19,W
0AC84:  MOVWF  01
0AC86:  MOVLW  01
0AC88:  ADDWFC x1A,W
0AC8A:  MOVWF  03
0AC8C:  MOVFF  01,71B
0AC90:  MOVWF  x1C
0AC92:  MOVFF  718,565
0AC96:  MOVFF  717,564
0AC9A:  MOVLW  24
0AC9C:  MOVWF  x66
0AC9E:  MOVLB  0
0ACA0:  CALL   5CB6
0ACA4:  MOVFF  565,FEA
0ACA8:  MOVFF  564,FE9
0ACAC:  CLRF   FEF
0ACAE:  MOVFF  71C,FEA
0ACB2:  MOVFF  71B,FE9
0ACB6:  CALL   5CD6
0ACBA:  MOVLW  2C
0ACBC:  MOVLB  7
0ACBE:  MOVWF  x66
0ACC0:  MOVLB  0
0ACC2:  CALL   5CB6
....................         
....................         return_code = command_parser(SRI);
0ACC6:  MOVFF  4BF,717
0ACCA:  BRA    AAAA
0ACCC:  MOVFF  01,716
....................         
....................         sprintf(retData + strlen(retData), "%s", resp_list[return_code].msg);
0ACD0:  MOVLW  04
0ACD2:  MOVLB  7
0ACD4:  MOVWF  x58
0ACD6:  MOVLW  C1
0ACD8:  MOVWF  x57
0ACDA:  MOVLB  0
0ACDC:  CALL   5C7E
0ACE0:  MOVF   01,W
0ACE2:  ADDLW  C1
0ACE4:  MOVLB  7
0ACE6:  MOVWF  x17
0ACE8:  MOVLW  04
0ACEA:  ADDWFC 02,W
0ACEC:  MOVWF  x18
0ACEE:  MOVF   x16,W
0ACF0:  MULLW  03
0ACF2:  MOVF   FF3,W
0ACF4:  CLRF   x1A
0ACF6:  MOVWF  x19
0ACF8:  MOVLW  01
0ACFA:  ADDWF  x19,W
0ACFC:  MOVWF  01
0ACFE:  MOVLW  00
0AD00:  ADDWFC x1A,W
0AD02:  MOVWF  03
0AD04:  MOVF   01,W
0AD06:  ADDLW  78
0AD08:  MOVWF  FE9
0AD0A:  MOVLW  06
0AD0C:  ADDWFC 03,W
0AD0E:  MOVWF  FEA
0AD10:  MOVFF  FEC,71A
0AD14:  MOVF   FED,F
0AD16:  MOVFF  FEF,719
0AD1A:  MOVFF  718,565
0AD1E:  MOVFF  717,564
0AD22:  MOVFF  565,FEA
0AD26:  MOVFF  564,FE9
0AD2A:  CLRF   FEF
0AD2C:  MOVFF  71A,FEA
0AD30:  MOVFF  719,FE9
0AD34:  MOVLB  0
0AD36:  CALL   5CD6
....................         
....................         serial_out(retData);
0AD3A:  MOVLW  04
0AD3C:  MOVLB  7
0AD3E:  MOVWF  x18
0AD40:  MOVLW  C1
0AD42:  MOVWF  x17
0AD44:  MOVLB  0
0AD46:  CALL   56DE
....................         
....................         resetSERcmd(SRI);
0AD4A:  MOVFF  4BF,717
0AD4E:  CALL   0B50
0AD52:  BRA    AC30
....................     }
0AD54:  GOTO   B200 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... //!#define DEBUG_1
.................... 
.................... void main()
0AD58:  CLRF   FF8
0AD5A:  BCF    FF2.5
0AD5C:  BSF    07.7
0AD5E:  MOVLB  E
0AD60:  MOVLW  55
0AD62:  MOVWF  x9B
0AD64:  MOVLW  AA
0AD66:  MOVWF  x9B
0AD68:  BCF    x9B.0
0AD6A:  MOVLW  17
0AD6C:  MOVWF  xB0
0AD6E:  MOVLW  13
0AD70:  MOVWF  xB2
0AD72:  MOVLW  09
0AD74:  MOVWF  x8A
0AD76:  MOVLW  0A
0AD78:  MOVWF  x8B
0AD7A:  MOVLW  11
0AD7C:  MOVWF  xEB
0AD7E:  MOVLW  12
0AD80:  MOVWF  xED
0AD82:  MOVLW  10
0AD84:  MOVWF  xF4
0AD86:  MOVLW  0F
0AD88:  MOVWF  xF5
0AD8A:  MOVLW  09
0AD8C:  MOVWF  xF8
0AD8E:  MOVLW  55
0AD90:  MOVWF  x9B
0AD92:  MOVLW  AA
0AD94:  MOVWF  x9B
0AD96:  BSF    x9B.0
0AD98:  CLRF   xD8
0AD9A:  CLRF   xD5
0AD9C:  CLRF   xD7
0AD9E:  MOVLW  08
0ADA0:  MOVWF  xD9
0ADA2:  MOVLW  60
0ADA4:  MOVWF  xD3
0ADA6:  MOVLW  AA
0ADA8:  MOVLB  0
0ADAA:  MOVWF  xFA
0ADAC:  MOVLB  1
0ADAE:  BSF    x63.0
0ADB0:  CLRF   x75
0ADB2:  CLRF   x74
0ADB4:  CLRF   x73
0ADB6:  CLRF   x72
0ADB8:  CLRF   x79
0ADBA:  CLRF   x78
0ADBC:  CLRF   x77
0ADBE:  CLRF   x76
0ADC0:  CLRF   x7D
0ADC2:  CLRF   x7C
0ADC4:  CLRF   x7B
0ADC6:  CLRF   x7A
0ADC8:  CLRF   x7F
0ADCA:  CLRF   x7E
0ADCC:  MOVLB  E
0ADCE:  BCF    x91.5
0ADD0:  MOVLW  00
0ADD2:  MOVWF  x90
0ADD4:  MOVLW  03
0ADD6:  MOVWF  x8E
0ADD8:  MOVLW  2A
0ADDA:  MOVWF  x91
0ADDC:  MOVLW  04
0ADDE:  MOVWF  F88
0ADE0:  MOVWF  F88
0ADE2:  MOVWF  F88
0ADE4:  MOVLB  1
0ADE6:  CLRF   xD0
0ADE8:  CLRF   xD1
0ADEA:  CLRF   xD2
0ADEC:  CLRF   xD3
0ADEE:  BCF    F95.5
0ADF0:  MOVLW  40
0ADF2:  MOVWF  F94
0ADF4:  MOVLW  9F
0ADF6:  MOVWF  F92
0ADF8:  MOVLW  3A
0ADFA:  MOVWF  F95
0ADFC:  MOVLW  93
0ADFE:  MOVWF  F89
0AE00:  MOVWF  F89
0AE02:  MOVLB  4
0AE04:  CLRF   xBF
0AE06:  CLRF   xC0
0AE08:  MOVLB  5
0AE0A:  CLRF   x61
0AE0C:  CLRF   x62
0AE0E:  MOVLB  1
0AE10:  BCF    x63.1
0AE12:  MOVLB  5
0AE14:  CLRF   x63
0AE16:  BSF    F9E.3
0AE18:  MOVLW  7C
0AE1A:  MOVWF  F9A
0AE1C:  MOVLW  00
0AE1E:  MOVWF  F9B
0AE20:  MOVLW  A6
0AE22:  MOVWF  F9D
0AE24:  MOVLW  90
0AE26:  MOVWF  F9C
0AE28:  CLRF   x65
0AE2A:  CLRF   x64
0AE2C:  CLRF   x69
0AE2E:  CLRF   x68
0AE30:  CLRF   x67
0AE32:  CLRF   x66
0AE34:  MOVLB  F
0AE36:  CLRF   x0C
0AE38:  CLRF   x14
0AE3A:  CLRF   x1C
0AE3C:  CLRF   x21
0AE3E:  CLRF   x29
0AE40:  CLRF   x35
0AE42:  CLRF   x36
0AE44:  CLRF   x37
0AE46:  CLRF   x34
0AE48:  CLRF   x31
0AE4A:  CLRF   x32
0AE4C:  CLRF   x33
0AE4E:  CLRF   x30
0AE50:  MOVLW  5D
0AE52:  MOVLB  5
0AE54:  MOVWF  x6D
0AE56:  MOVLW  CC
0AE58:  MOVWF  x6C
0AE5A:  MOVLW  5E
0AE5C:  MOVWF  x71
0AE5E:  MOVLW  10
0AE60:  MOVWF  x70
0AE62:  MOVLW  5E
0AE64:  MOVWF  x75
0AE66:  MOVLW  54
0AE68:  MOVWF  x74
0AE6A:  MOVLW  63
0AE6C:  MOVWF  x79
0AE6E:  MOVLW  62
0AE70:  MOVWF  x78
0AE72:  MOVLW  65
0AE74:  MOVWF  x7D
0AE76:  MOVLW  06
0AE78:  MOVWF  x7C
0AE7A:  MOVLW  66
0AE7C:  MOVWF  x81
0AE7E:  MOVLW  E2
0AE80:  MOVWF  x80
0AE82:  MOVLW  68
0AE84:  MOVWF  x85
0AE86:  MOVLW  6E
0AE88:  MOVWF  x84
0AE8A:  MOVLW  6D
0AE8C:  MOVWF  x89
0AE8E:  MOVLW  12
0AE90:  MOVWF  x88
0AE92:  MOVLW  74
0AE94:  MOVWF  x8D
0AE96:  MOVLW  E4
0AE98:  MOVWF  x8C
0AE9A:  MOVLW  77
0AE9C:  MOVWF  x91
0AE9E:  MOVLW  C4
0AEA0:  MOVWF  x90
0AEA2:  MOVLW  79
0AEA4:  MOVWF  x95
0AEA6:  MOVLW  26
0AEA8:  MOVWF  x94
0AEAA:  MOVLW  7A
0AEAC:  MOVWF  x99
0AEAE:  MOVLW  E4
0AEB0:  MOVWF  x98
0AEB2:  MOVLW  7E
0AEB4:  MOVWF  x9D
0AEB6:  MOVLW  9A
0AEB8:  MOVWF  x9C
0AEBA:  MOVLW  83
0AEBC:  MOVWF  xA1
0AEBE:  MOVLW  F6
0AEC0:  MOVWF  xA0
0AEC2:  MOVLW  87
0AEC4:  MOVWF  xA5
0AEC6:  MOVLW  8E
0AEC8:  MOVWF  xA4
0AECA:  MOVLW  8C
0AECC:  MOVWF  xA9
0AECE:  MOVLW  BA
0AED0:  MOVWF  xA8
0AED2:  MOVLW  8C
0AED4:  MOVWF  xAD
0AED6:  MOVLW  C0
0AED8:  MOVWF  xAC
0AEDA:  MOVLW  93
0AEDC:  MOVWF  xB1
0AEDE:  MOVLW  34
0AEE0:  MOVWF  xB0
0AEE2:  MOVLW  98
0AEE4:  MOVWF  xB5
0AEE6:  MOVLW  98
0AEE8:  MOVWF  xB4
0AEEA:  MOVLW  9F
0AEEC:  MOVWF  xB9
0AEEE:  MOVLW  BA
0AEF0:  MOVWF  xB8
0AEF2:  MOVLW  A1
0AEF4:  MOVWF  xBD
0AEF6:  MOVLW  1C
0AEF8:  MOVWF  xBC
0AEFA:  MOVLW  A3
0AEFC:  MOVWF  xC1
0AEFE:  MOVLW  8E
0AF00:  MOVWF  xC0
0AF02:  MOVLW  A3
0AF04:  MOVWF  xC5
0AF06:  MOVLW  9A
0AF08:  MOVWF  xC4
0AF0A:  MOVLW  A3
0AF0C:  MOVWF  xC9
0AF0E:  MOVLW  A6
0AF10:  MOVWF  xC8
0AF12:  MOVLW  A5
0AF14:  MOVWF  xCD
0AF16:  MOVLW  18
0AF18:  MOVWF  xCC
0AF1A:  MOVLW  A7
0AF1C:  MOVWF  xD1
0AF1E:  MOVLW  5E
0AF20:  MOVWF  xD0
0AF22:  MOVLW  AA
0AF24:  MOVWF  xD5
0AF26:  MOVLW  A4
0AF28:  MOVWF  xD4
0AF2A:  BRA    B13A
0AF2C:  DATA 02,00
0AF2E:  DATA 1A,00
0AF30:  DATA 00,0C
0AF32:  DATA 00,20
0AF34:  DATA 78,23
0AF36:  DATA D7,0A
0AF38:  DATA 7D,19
0AF3A:  DATA 99,9A
0AF3C:  DATA 7B,4C
0AF3E:  DATA CC,CD
0AF40:  DATA 1C,C0
0AF42:  DATA 00,0C
0AF44:  DATA 80,78
0AF46:  DATA 23,D7
0AF48:  DATA 0A,7D
0AF4A:  DATA 19,99
0AF4C:  DATA 9A,7B
0AF4E:  DATA 4C,CC
0AF50:  DATA CD,1C
0AF52:  DATA C0,00
0AF54:  DATA 01,80
0AF56:  DATA 02,09
0AF58:  DATA C0,00
0AF5A:  DATA 05,80
0AF5C:  DATA 7F,00
0AF5E:  DATA 00,00
0AF60:  DATA 7F,0B
0AF62:  DATA C0,00
0AF64:  DATA 10,80
0AF66:  DATA 7F,00
0AF68:  DATA 00,00
0AF6A:  DATA 7F,00
0AF6C:  DATA 00,00
0AF6E:  DATA 7D,8A
0AF70:  DATA 4A,8C
0AF72:  DATA 7E,F9
0AF74:  DATA 1F,0C
0AF76:  DATA 10,C0
0AF78:  DATA 00,08
0AF7A:  DATA 80,7D
0AF7C:  DATA CA,F4
0AF7E:  DATA F1,7E
0AF80:  DATA F7,2F
0AF82:  DATA 98,14
0AF84:  DATA C0,00
0AF86:  DATA 04,80
0AF88:  DATA 79,B7
0AF8A:  DATA F3,BD
0AF8C:  DATA 04,C0
0AF8E:  DATA 00,04
0AF90:  DATA 80,7C
0AF92:  DATA 59,DF
0AF94:  DATA 4E,04
0AF96:  DATA C0,00
0AF98:  DATA 04,80
0AF9A:  DATA 78,0A
0AF9C:  DATA 28,88
0AF9E:  DATA 04,C0
0AFA0:  DATA 00,04
0AFA2:  DATA 80,78
0AFA4:  DATA 05,EA
0AFA6:  DATA 16,04
0AFA8:  DATA C0,00
0AFAA:  DATA 04,80
0AFAC:  DATA 78,1E
0AFAE:  DATA 33,D7
0AFB0:  DATA 04,C0
0AFB2:  DATA 00,04
0AFB4:  DATA 80,77
0AFB6:  DATA 68,7B
0AFB8:  DATA BB,04
0AFBA:  DATA C0,00
0AFBC:  DATA 04,80
0AFBE:  DATA 77,68
0AFC0:  DATA 0D,C6
0AFC2:  DATA 38,40
0AFC4:  DATA FB,00
0AFC6:  DATA 01,80
0AFC8:  DATA FF,2F
0AFCA:  DATA C0,00
0AFCC:  DATA 0E,41
0AFCE:  DATA 64,00
0AFD0:  DATA 17,41
0AFD2:  DATA D4,00
0AFD4:  DATA 3C,45
0AFD6:  DATA 25,00
0AFD8:  DATA 02,05
0AFDA:  DATA 6A,D6
0AFDC:  DATA 05,02
0AFDE:  DATA 05,6E
0AFE0:  DATA D9,05
0AFE2:  DATA 02,05
0AFE4:  DATA 72,DC
0AFE6:  DATA 05,02
0AFE8:  DATA 05,76
0AFEA:  DATA E1,05
0AFEC:  DATA 02,05
0AFEE:  DATA 7A,E8
0AFF0:  DATA 05,02
0AFF2:  DATA 05,7E
0AFF4:  DATA EF,05
0AFF6:  DATA 02,05
0AFF8:  DATA 82,F7
0AFFA:  DATA 05,02
0AFFC:  DATA 05,86
0AFFE:  DATA FF,05
0B000:  DATA 02,05
0B002:  DATA 8A,04
0B004:  DATA 06,02
0B006:  DATA 05,8E
0B008:  DATA 09,06
0B00A:  DATA 02,05
0B00C:  DATA 92,0D
0B00E:  DATA 06,02
0B010:  DATA 05,96
0B012:  DATA 11,06
0B014:  DATA 02,05
0B016:  DATA 9A,18
0B018:  DATA 06,02
0B01A:  DATA 05,9E
0B01C:  DATA 1E,06
0B01E:  DATA 02,05
0B020:  DATA A2,24
0B022:  DATA 06,02
0B024:  DATA 05,A6
0B026:  DATA 2A,06
0B028:  DATA 02,05
0B02A:  DATA AA,30
0B02C:  DATA 06,02
0B02E:  DATA 05,AE
0B030:  DATA 35,06
0B032:  DATA 02,05
0B034:  DATA B2,3E
0B036:  DATA 06,02
0B038:  DATA 05,B6
0B03A:  DATA 46,06
0B03C:  DATA 02,05
0B03E:  DATA BA,4D
0B040:  DATA 06,02
0B042:  DATA 05,BE
0B044:  DATA 54,06
0B046:  DATA 02,05
0B048:  DATA C2,5C
0B04A:  DATA 06,02
0B04C:  DATA 05,C6
0B04E:  DATA 65,06
0B050:  DATA 02,05
0B052:  DATA CA,6B
0B054:  DATA 06,02
0B056:  DATA 05,CE
0B058:  DATA 71,06
0B05A:  DATA 02,05
0B05C:  DATA D2,76
0B05E:  DATA 06,9F
0B060:  DATA 05,D6
0B062:  DATA 67,72
0B064:  DATA 00,67
0B066:  DATA 73,00
0B068:  DATA 73,50
0B06A:  DATA 72,6D
0B06C:  DATA 00,67
0B06E:  DATA 43,68
0B070:  DATA 4D,61
0B072:  DATA 70,00
0B074:  DATA 73,43
0B076:  DATA 68,4D
0B078:  DATA 61,70
0B07A:  DATA 00,67
0B07C:  DATA 43,68
0B07E:  DATA 4D,6F
0B080:  DATA 64,65
0B082:  DATA 00,73
0B084:  DATA 43,68
0B086:  DATA 4D,6F
0B088:  DATA 64,65
0B08A:  DATA 00,67
0B08C:  DATA 50,49
0B08E:  DATA 44,00
0B090:  DATA 73,50
0B092:  DATA 49,44
0B094:  DATA 00,67
0B096:  DATA 53,50
0B098:  DATA 00,73
0B09A:  DATA 53,50
0B09C:  DATA 00,67
0B09E:  DATA 53,43
0B0A0:  DATA 61,6C
0B0A2:  DATA 73,00
0B0A4:  DATA 67,53
0B0A6:  DATA 43,61
0B0A8:  DATA 6C,00
0B0AA:  DATA 73,53
0B0AC:  DATA 43,61
0B0AE:  DATA 6C,00
0B0B0:  DATA 67,4D
0B0B2:  DATA 43,61
0B0B4:  DATA 6C,00
0B0B6:  DATA 73,4D
0B0B8:  DATA 43,61
0B0BA:  DATA 6C,00
0B0BC:  DATA 67,4D
0B0BE:  DATA 6F,6E
0B0C0:  DATA 00,67
0B0C2:  DATA 50,49
0B0C4:  DATA 44,64
0B0C6:  DATA 61,74
0B0C8:  DATA 61,00
0B0CA:  DATA 67,49
0B0CC:  DATA 50,64
0B0CE:  DATA 61,74
0B0D0:  DATA 61,00
0B0D2:  DATA 67,4D
0B0D4:  DATA 61,6E
0B0D6:  DATA 4F,50
0B0D8:  DATA 00,73
0B0DA:  DATA 4D,61
0B0DC:  DATA 6E,4F
0B0DE:  DATA 50,00
0B0E0:  DATA 73,46
0B0E2:  DATA 69,6C
0B0E4:  DATA 74,4F
0B0E6:  DATA 6E,00
0B0E8:  DATA 73,46
0B0EA:  DATA 69,6C
0B0EC:  DATA 74,4F
0B0EE:  DATA 66,66
0B0F0:  DATA 00,73
0B0F2:  DATA 48,6F
0B0F4:  DATA 6D,65
0B0F6:  DATA 00,67
0B0F8:  DATA 48,6F
0B0FA:  DATA 6D,65
0B0FC:  DATA 00,67
0B0FE:  DATA 54,6C
0B100:  DATA 6D,04
0B102:  DATA C0,00
0B104:  DATA 32,80
0B106:  DATA 81,06
0B108:  DATA 01,89
0B10A:  DATA 06,02
0B10C:  DATA 99,06
0B10E:  DATA 53,55
0B110:  DATA 43,43
0B112:  DATA 45,53
0B114:  DATA 53,00
0B116:  DATA 49,4E
0B118:  DATA 56,41
0B11A:  DATA 4C,49
0B11C:  DATA 44,20
0B11E:  DATA 43,4F
0B120:  DATA 4D,4D
0B122:  DATA 41,4E
0B124:  DATA 44,00
0B126:  DATA 49,4E
0B128:  DATA 56,41
0B12A:  DATA 4C,49
0B12C:  DATA 44,20
0B12E:  DATA 50,41
0B130:  DATA 52,41
0B132:  DATA 4D,45
0B134:  DATA 54,45
0B136:  DATA 52,00
0B138:  DATA 00,00
0B13A:  MOVLW  00
0B13C:  MOVWF  FF8
0B13E:  MOVLW  AF
0B140:  MOVWF  FF7
0B142:  MOVLW  2C
0B144:  MOVWF  FF6
0B146:  TBLRD*+
0B148:  MOVF   FF5,W
0B14A:  MOVWF  00
0B14C:  XORLW  00
0B14E:  BZ    B176
0B150:  TBLRD*+
0B152:  MOVF   FF5,W
0B154:  MOVWF  01
0B156:  BTFSC  FE8.7
0B158:  BRA    B164
0B15A:  ANDLW  3F
0B15C:  MOVWF  FEA
0B15E:  TBLRD*+
0B160:  MOVFF  FF5,FE9
0B164:  BTFSC  01.6
0B166:  TBLRD*+
0B168:  BTFSS  01.6
0B16A:  TBLRD*+
0B16C:  MOVFF  FF5,FEE
0B170:  DCFSNZ 00,F
0B172:  BRA    B146
0B174:  BRA    B168
0B176:  CLRF   FF8
0B178:  MOVLB  6
0B17A:  CLRF   xAD
0B17C:  MOVLW  64
0B17E:  MOVWF  xAC
0B180:  CLRF   xAF
0B182:  CLRF   xAE
0B184:  CLRF   xB1
0B186:  CLRF   xB0
.................... {
....................     int16 loopDelay = 100;
....................     int16 controlCounter = 0;
....................     int16 debugCounter = 0;
....................    
....................     char pBuff[100];
....................     
....................     IO_init();                    // set up IO 
0B188:  MOVLB  0
0B18A:  GOTO   03A0
....................     params_init();                // load parameters
0B18E:  GOTO   0646
....................     monitor_init();               // initialize internal ADC for voltage and current telemetry
0B192:  GOTO   0A94
....................     control_init();               // initialize the output control DACs
0B196:  GOTO   0B2C
....................     serial_init();                // setup the serial port
0B19A:  GOTO   0CCA
....................     event_timer_init();
0B19E:  GOTO   0CEC
.................... //!    setup_wdt(WDT_512MS);
....................     enable_interrupts(GLOBAL);
0B1A2:  MOVLW  C0
0B1A4:  IORWF  FF2,F
....................     
....................     while(TRUE)
....................     {
.................... //!        restart_wdt();
....................         pBuff[0] = '\0';
0B1A6:  MOVLB  6
0B1A8:  CLRF   xB2
....................         
....................         if (adcVals[chX].homeFlag) home_axis(chX);
0B1AA:  MOVLB  1
0B1AC:  BTFSS  x3C.0
0B1AE:  BRA    B1BC
0B1B0:  MOVLB  7
0B1B2:  CLRF   x16
0B1B4:  MOVLB  0
0B1B6:  CALL   4CF6
0B1BA:  MOVLB  1
....................         if (adcVals[chY].homeFlag) home_axis(chY);
0B1BC:  BTFSS  x62.0
0B1BE:  BRA    B1CE
0B1C0:  MOVLW  01
0B1C2:  MOVLB  7
0B1C4:  MOVWF  x16
0B1C6:  MOVLB  0
0B1C8:  CALL   4CF6
0B1CC:  MOVLB  1
....................                 
....................         internal_monitor_task();   //Update monitored voltage and currents etc
0B1CE:  MOVLB  0
0B1D0:  GOTO   508A
....................         sensor_monitor_task();     //get magnetoresistive sensor data
0B1D4:  CALL   4B46
....................       
....................         if (controlCounter >= 2){
0B1D8:  MOVLB  6
0B1DA:  MOVF   xAF,F
0B1DC:  BNZ   B1E4
0B1DE:  MOVF   xAE,W
0B1E0:  SUBLW  01
0B1E2:  BC    B1F2
....................             control_task();
0B1E4:  MOVLB  0
0B1E6:  GOTO   562E
....................             controlCounter = 0;
0B1EA:  MOVLB  6
0B1EC:  CLRF   xAF
0B1EE:  CLRF   xAE
....................         }else controlCounter++;
0B1F0:  BRA    B1F8
0B1F2:  INCF   xAE,F
0B1F4:  BTFSC  FD8.2
0B1F6:  INCF   xAF,F
....................       
....................         serial_task();             
0B1F8:  MOVLB  0
0B1FA:  GOTO   5718
....................         command_handler_task();    //execute commands
0B1FE:  BRA    AC30
....................         
....................         #ifdef DEBUG_1
....................         if (debugCounter >= 0){
....................             static int8 ch = 0;
....................             sprintf(pBuff+strlen(pBuff), "CNT,%u,%.0f,%.0f;", ch+1, adcVals[ch].sinCounts, adcVals[ch].cosCounts);
....................             sprintf(pBuff+strlen(pBuff), "POS,%u,%3.3f;", ch+1, adcVals[ch].pReal);
....................             if ( dacVals[ch].invV ) sprintf(pBuff+strlen(pBuff), "OUT,%u,-,%Lu;", ch+1, dacVals[ch].ipVal);
....................             else                    sprintf(pBuff+strlen(pBuff), "OUT,%u,+,%Lu;", ch+1, dacVals[ch].ipVal);
....................             ch = !ch;
....................             debugCounter = 0;
....................         }else debugCounter++;
.................... //!        fprintf(ICD_STREAM, "%s\n", pBuff);
....................         serial_out(pBuff);
....................         #endif
....................       
....................         delay_ms(loopDelay);
0B200:  MOVFF  6AD,716
0B204:  MOVLB  7
0B206:  INCF   x16,F
0B208:  DECF   x16,F
0B20A:  BTFSC  FD8.2
0B20C:  BRA    B21A
0B20E:  SETF   x25
0B210:  MOVLB  0
0B212:  CALL   0436
0B216:  MOVLB  7
0B218:  BRA    B208
0B21A:  MOVFF  6AC,725
0B21E:  MOVLB  0
0B220:  CALL   0436
0B224:  BRA    B1A6
....................     }
.................... }
0B226:  SLEEP 

Configuration Fuses:
   Word  1: FF8C   NOEXTOSC RSTOSC_HFINTRC_64MHZ NOCLKOUT CKS FCMEN
   Word  2: FFFD   MCLR PUT NOLPBOR BROWNOUT BORV19 ZCDDIS PPS1WAY STVREN NODEBUG NOXINST
   Word  3: FF9F   WDTSW NOWDT WDTWIN_SW WDTCLK_SW
   Word  4: DFFF   NOWRT NOWRTC NOWRTB NOWRTD SCANE NOLVP
   Word  5: FFFF   NOPROTECT NOCPD
   Word  6: FFFF   NOEBTR NOEBTRB
