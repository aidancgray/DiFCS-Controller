CCS PCH C Compiler, Version 5.109, 62303               13-Jun-25 17:25

               Filename:   C:\Users\Aidan\Documents\GitHub\DiFCS-Controller\src\main.lst

               ROM used:   30222 bytes (46%)
                           Largest free fragment is 35312
               RAM used:   1496 (41%) at main() level
                           1606 (44%) worst case
               Stack used: 7 locations (4 in main + 3 for interrupts)
               Stack size: 30

*
00000:  NOP   
00002:  GOTO   7266
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  MOVLB  E
00056:  BTFSS  xC0.5
00058:  GOTO   0062
0005C:  BTFSC  xC8.5
0005E:  GOTO   00E8
00062:  BTFSS  xC1.0
00064:  GOTO   006E
00068:  BTFSC  xC9.0
0006A:  GOTO   021E
0006E:  MOVFF  0E,00
00072:  MOVFF  0F,01
00076:  MOVFF  10,02
0007A:  MOVFF  11,03
0007E:  MOVFF  0C,FE9
00082:  MOVFF  07,FEA
00086:  BSF    07.7
00088:  MOVFF  08,FE1
0008C:  MOVFF  09,FE2
00090:  MOVFF  0A,FD9
00094:  MOVFF  0B,FDA
00098:  MOVFF  12,FF3
0009C:  MOVFF  13,FF4
000A0:  MOVFF  14,FFA
000A4:  MOVFF  15,FF5
000A8:  MOVFF  16,FF6
000AC:  MOVFF  17,FF7
000B0:  MOVF   04,W
000B2:  MOVFF  06,FE0
000B6:  MOVFF  05,FD8
000BA:  RETFIE 0
.................... #include <main.h>
.................... #include <18F46Q10.h>
.................... //////////// Standard Header file for the PIC18F46Q10 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F46Q10
000BC:  MOVFF  FEC,FFA
000C0:  MOVF   FED,F
000C2:  MOVFF  FEF,FE8
000C6:  MOVWF  FF9
000C8:  RETURN 0
*
002F2:  DATA 32,30
002F4:  DATA 32,35
002F6:  DATA 30,35
002F8:  DATA 32,32
002FA:  DATA 00,00
002FC:  DATA 30,30
002FE:  DATA 30,30
00300:  DATA 00,00
00302:  DATA 4D,41
00304:  DATA 4E,55
00306:  DATA 41,4C
00308:  DATA 2C,00
0030A:  DATA 4D,41
0030C:  DATA 47,53
0030E:  DATA 4E,53
00310:  DATA 2C,00
*
00816:  MOVLB  5
00818:  MOVF   xFA,W
0081A:  MULWF  xFC
0081C:  MOVFF  FF3,01
00820:  MOVFF  FF4,00
00824:  MULWF  xFD
00826:  MOVF   FF3,W
00828:  ADDWF  00,F
0082A:  MOVF   xFB,W
0082C:  MULWF  xFC
0082E:  MOVF   FF3,W
00830:  ADDWFC 00,W
00832:  MOVWF  02
00834:  MOVLB  0
00836:  RETURN 0
*
00A0E:  MOVLW  8E
00A10:  MOVWF  00
00A12:  MOVFF  631,01
00A16:  MOVFF  630,02
00A1A:  CLRF   03
00A1C:  MOVF   01,F
00A1E:  BNZ   0A32
00A20:  MOVFF  02,01
00A24:  CLRF   02
00A26:  MOVLW  08
00A28:  SUBWF  00,F
00A2A:  MOVF   01,F
00A2C:  BNZ   0A32
00A2E:  CLRF   00
00A30:  BRA    0A42
00A32:  BCF    FD8.0
00A34:  BTFSC  01.7
00A36:  BRA    0A40
00A38:  RLCF   02,F
00A3A:  RLCF   01,F
00A3C:  DECF   00,F
00A3E:  BRA    0A32
00A40:  BCF    01.7
00A42:  RETURN 0
00A44:  MOVLB  6
00A46:  MOVF   x2C,W
00A48:  BTFSC  FD8.2
00A4A:  BRA    0B2E
00A4C:  MOVWF  00
00A4E:  MOVF   x30,W
00A50:  BTFSC  FD8.2
00A52:  BRA    0B2E
00A54:  ADDWF  00,F
00A56:  BNC   0A60
00A58:  MOVLW  81
00A5A:  ADDWF  00,F
00A5C:  BC    0B2E
00A5E:  BRA    0A68
00A60:  MOVLW  7F
00A62:  SUBWF  00,F
00A64:  BNC   0B2E
00A66:  BZ    0B2E
00A68:  MOVFF  62D,634
00A6C:  MOVF   x31,W
00A6E:  XORWF  x34,F
00A70:  BSF    x2D.7
00A72:  BSF    x31.7
00A74:  MOVF   x2F,W
00A76:  MULWF  x33
00A78:  MOVFF  FF4,636
00A7C:  MOVF   x2E,W
00A7E:  MULWF  x32
00A80:  MOVFF  FF4,03
00A84:  MOVFF  FF3,635
00A88:  MULWF  x33
00A8A:  MOVF   FF3,W
00A8C:  ADDWF  x36,F
00A8E:  MOVF   FF4,W
00A90:  ADDWFC x35,F
00A92:  MOVLW  00
00A94:  ADDWFC 03,F
00A96:  MOVF   x2F,W
00A98:  MULWF  x32
00A9A:  MOVF   FF3,W
00A9C:  ADDWF  x36,F
00A9E:  MOVF   FF4,W
00AA0:  ADDWFC x35,F
00AA2:  MOVLW  00
00AA4:  CLRF   02
00AA6:  ADDWFC 03,F
00AA8:  ADDWFC 02,F
00AAA:  MOVF   x2D,W
00AAC:  MULWF  x33
00AAE:  MOVF   FF3,W
00AB0:  ADDWF  x35,F
00AB2:  MOVF   FF4,W
00AB4:  ADDWFC 03,F
00AB6:  MOVLW  00
00AB8:  ADDWFC 02,F
00ABA:  MOVF   x2D,W
00ABC:  MULWF  x32
00ABE:  MOVF   FF3,W
00AC0:  ADDWF  03,F
00AC2:  MOVF   FF4,W
00AC4:  ADDWFC 02,F
00AC6:  MOVLW  00
00AC8:  CLRF   01
00ACA:  ADDWFC 01,F
00ACC:  MOVF   x2F,W
00ACE:  MULWF  x31
00AD0:  MOVF   FF3,W
00AD2:  ADDWF  x35,F
00AD4:  MOVF   FF4,W
00AD6:  ADDWFC 03,F
00AD8:  MOVLW  00
00ADA:  ADDWFC 02,F
00ADC:  ADDWFC 01,F
00ADE:  MOVF   x2E,W
00AE0:  MULWF  x31
00AE2:  MOVF   FF3,W
00AE4:  ADDWF  03,F
00AE6:  MOVF   FF4,W
00AE8:  ADDWFC 02,F
00AEA:  MOVLW  00
00AEC:  ADDWFC 01,F
00AEE:  MOVF   x2D,W
00AF0:  MULWF  x31
00AF2:  MOVF   FF3,W
00AF4:  ADDWF  02,F
00AF6:  MOVF   FF4,W
00AF8:  ADDWFC 01,F
00AFA:  INCF   00,F
00AFC:  BTFSC  01.7
00AFE:  BRA    0B0A
00B00:  RLCF   x35,F
00B02:  RLCF   03,F
00B04:  RLCF   02,F
00B06:  RLCF   01,F
00B08:  DECF   00,F
00B0A:  MOVLW  00
00B0C:  BTFSS  x35.7
00B0E:  BRA    0B24
00B10:  INCF   03,F
00B12:  ADDWFC 02,F
00B14:  ADDWFC 01,F
00B16:  MOVF   01,W
00B18:  BNZ   0B24
00B1A:  MOVF   02,W
00B1C:  BNZ   0B24
00B1E:  MOVF   03,W
00B20:  BNZ   0B24
00B22:  INCF   00,F
00B24:  BTFSC  x34.7
00B26:  BSF    01.7
00B28:  BTFSS  x34.7
00B2A:  BCF    01.7
00B2C:  BRA    0B36
00B2E:  CLRF   00
00B30:  CLRF   01
00B32:  CLRF   02
00B34:  CLRF   03
00B36:  MOVLB  0
00B38:  RETURN 0
00B3A:  MOVLW  80
00B3C:  BTFSS  FD8.1
00B3E:  BRA    0B44
00B40:  MOVLB  6
00B42:  XORWF  x35,F
00B44:  MOVLB  6
00B46:  CLRF   x3A
00B48:  CLRF   x3B
00B4A:  MOVFF  631,639
00B4E:  MOVF   x35,W
00B50:  XORWF  x39,F
00B52:  MOVF   x30,W
00B54:  BTFSC  FD8.2
00B56:  BRA    0D16
00B58:  MOVWF  x38
00B5A:  MOVWF  00
00B5C:  MOVF   x34,W
00B5E:  BTFSC  FD8.2
00B60:  BRA    0D28
00B62:  SUBWF  x38,F
00B64:  BTFSC  FD8.2
00B66:  BRA    0C6E
00B68:  BNC   0BE6
00B6A:  MOVFF  635,63E
00B6E:  BSF    x3E.7
00B70:  MOVFF  636,63D
00B74:  MOVFF  637,63C
00B78:  CLRF   x3B
00B7A:  BCF    FD8.0
00B7C:  RRCF   x3E,F
00B7E:  RRCF   x3D,F
00B80:  RRCF   x3C,F
00B82:  RRCF   x3B,F
00B84:  DECFSZ x38,F
00B86:  BRA    0B78
00B88:  BTFSS  x39.7
00B8A:  BRA    0B92
00B8C:  BSF    x3A.0
00B8E:  BRA    0D50
00B90:  BCF    x3A.0
00B92:  BCF    x38.0
00B94:  BSF    x3A.4
00B96:  MOVLW  06
00B98:  MOVWF  FEA
00B9A:  MOVLW  33
00B9C:  MOVWF  FE9
00B9E:  BRA    0D76
00BA0:  BCF    x3A.4
00BA2:  BTFSC  x39.7
00BA4:  BRA    0BBA
00BA6:  BTFSS  x38.0
00BA8:  BRA    0BD0
00BAA:  RRCF   x3E,F
00BAC:  RRCF   x3D,F
00BAE:  RRCF   x3C,F
00BB0:  RRCF   x3B,F
00BB2:  INCF   00,F
00BB4:  BTFSC  FD8.2
00BB6:  BRA    0D46
00BB8:  BRA    0BD0
00BBA:  BTFSC  x3E.7
00BBC:  BRA    0BD6
00BBE:  BCF    FD8.0
00BC0:  RLCF   x3B,F
00BC2:  RLCF   x3C,F
00BC4:  RLCF   x3D,F
00BC6:  RLCF   x3E,F
00BC8:  DECF   00,F
00BCA:  BTFSC  FD8.2
00BCC:  BRA    0D46
00BCE:  BRA    0BBA
00BD0:  BSF    x3A.6
00BD2:  BRA    0CAE
00BD4:  BCF    x3A.6
00BD6:  MOVFF  631,639
00BDA:  BTFSS  x31.7
00BDC:  BRA    0BE2
00BDE:  BSF    x3E.7
00BE0:  BRA    0D38
00BE2:  BCF    x3E.7
00BE4:  BRA    0D38
00BE6:  MOVFF  634,638
00BEA:  MOVFF  634,00
00BEE:  MOVF   x30,W
00BF0:  SUBWF  x38,F
00BF2:  MOVFF  631,63E
00BF6:  BSF    x3E.7
00BF8:  MOVFF  632,63D
00BFC:  MOVFF  633,63C
00C00:  CLRF   x3B
00C02:  BCF    FD8.0
00C04:  RRCF   x3E,F
00C06:  RRCF   x3D,F
00C08:  RRCF   x3C,F
00C0A:  RRCF   x3B,F
00C0C:  DECFSZ x38,F
00C0E:  BRA    0C00
00C10:  BTFSS  x39.7
00C12:  BRA    0C1A
00C14:  BSF    x3A.1
00C16:  BRA    0D50
00C18:  BCF    x3A.1
00C1A:  BCF    x38.0
00C1C:  BSF    x3A.5
00C1E:  MOVLW  06
00C20:  MOVWF  FEA
00C22:  MOVLW  37
00C24:  MOVWF  FE9
00C26:  BRA    0D76
00C28:  BCF    x3A.5
00C2A:  BTFSC  x39.7
00C2C:  BRA    0C42
00C2E:  BTFSS  x38.0
00C30:  BRA    0C58
00C32:  RRCF   x3E,F
00C34:  RRCF   x3D,F
00C36:  RRCF   x3C,F
00C38:  RRCF   x3B,F
00C3A:  INCF   00,F
00C3C:  BTFSC  FD8.2
00C3E:  BRA    0D46
00C40:  BRA    0C58
00C42:  BTFSC  x3E.7
00C44:  BRA    0C5E
00C46:  BCF    FD8.0
00C48:  RLCF   x3B,F
00C4A:  RLCF   x3C,F
00C4C:  RLCF   x3D,F
00C4E:  RLCF   x3E,F
00C50:  DECF   00,F
00C52:  BTFSC  FD8.2
00C54:  BRA    0D46
00C56:  BRA    0C42
00C58:  BSF    x3A.7
00C5A:  BRA    0CAE
00C5C:  BCF    x3A.7
00C5E:  MOVFF  635,639
00C62:  BTFSS  x35.7
00C64:  BRA    0C6A
00C66:  BSF    x3E.7
00C68:  BRA    0D38
00C6A:  BCF    x3E.7
00C6C:  BRA    0D38
00C6E:  MOVFF  635,63E
00C72:  BSF    x3E.7
00C74:  MOVFF  636,63D
00C78:  MOVFF  637,63C
00C7C:  BTFSS  x39.7
00C7E:  BRA    0C88
00C80:  BCF    x3E.7
00C82:  BSF    x3A.2
00C84:  BRA    0D50
00C86:  BCF    x3A.2
00C88:  CLRF   x3B
00C8A:  BCF    x38.0
00C8C:  MOVLW  06
00C8E:  MOVWF  FEA
00C90:  MOVLW  33
00C92:  MOVWF  FE9
00C94:  BRA    0D76
00C96:  BTFSC  x39.7
00C98:  BRA    0CD2
00C9A:  MOVFF  631,639
00C9E:  BTFSS  x38.0
00CA0:  BRA    0CAE
00CA2:  RRCF   x3E,F
00CA4:  RRCF   x3D,F
00CA6:  RRCF   x3C,F
00CA8:  RRCF   x3B,F
00CAA:  INCF   00,F
00CAC:  BZ    0D46
00CAE:  BTFSS  x3B.7
00CB0:  BRA    0CC8
00CB2:  INCF   x3C,F
00CB4:  BNZ   0CC8
00CB6:  INCF   x3D,F
00CB8:  BNZ   0CC8
00CBA:  INCF   x3E,F
00CBC:  BNZ   0CC8
00CBE:  RRCF   x3E,F
00CC0:  RRCF   x3D,F
00CC2:  RRCF   x3C,F
00CC4:  INCF   00,F
00CC6:  BZ    0D46
00CC8:  BTFSC  x3A.6
00CCA:  BRA    0BD4
00CCC:  BTFSC  x3A.7
00CCE:  BRA    0C5C
00CD0:  BRA    0D0A
00CD2:  MOVLW  80
00CD4:  XORWF  x3E,F
00CD6:  BTFSS  x3E.7
00CD8:  BRA    0CE2
00CDA:  BRA    0D50
00CDC:  MOVFF  635,639
00CE0:  BRA    0CF6
00CE2:  MOVFF  631,639
00CE6:  MOVF   x3E,F
00CE8:  BNZ   0CF6
00CEA:  MOVF   x3D,F
00CEC:  BNZ   0CF6
00CEE:  MOVF   x3C,F
00CF0:  BNZ   0CF6
00CF2:  CLRF   00
00CF4:  BRA    0D38
00CF6:  BTFSC  x3E.7
00CF8:  BRA    0D0A
00CFA:  BCF    FD8.0
00CFC:  RLCF   x3B,F
00CFE:  RLCF   x3C,F
00D00:  RLCF   x3D,F
00D02:  RLCF   x3E,F
00D04:  DECFSZ 00,F
00D06:  BRA    0CF6
00D08:  BRA    0D46
00D0A:  BTFSS  x39.7
00D0C:  BRA    0D12
00D0E:  BSF    x3E.7
00D10:  BRA    0D38
00D12:  BCF    x3E.7
00D14:  BRA    0D38
00D16:  MOVFF  634,00
00D1A:  MOVFF  635,63E
00D1E:  MOVFF  636,63D
00D22:  MOVFF  637,63C
00D26:  BRA    0D38
00D28:  MOVFF  630,00
00D2C:  MOVFF  631,63E
00D30:  MOVFF  632,63D
00D34:  MOVFF  633,63C
00D38:  MOVFF  63E,01
00D3C:  MOVFF  63D,02
00D40:  MOVFF  63C,03
00D44:  BRA    0DAE
00D46:  CLRF   00
00D48:  CLRF   01
00D4A:  CLRF   02
00D4C:  CLRF   03
00D4E:  BRA    0DAE
00D50:  CLRF   x3B
00D52:  COMF   x3C,F
00D54:  COMF   x3D,F
00D56:  COMF   x3E,F
00D58:  COMF   x3B,F
00D5A:  INCF   x3B,F
00D5C:  BNZ   0D68
00D5E:  INCF   x3C,F
00D60:  BNZ   0D68
00D62:  INCF   x3D,F
00D64:  BNZ   0D68
00D66:  INCF   x3E,F
00D68:  BTFSC  x3A.0
00D6A:  BRA    0B90
00D6C:  BTFSC  x3A.1
00D6E:  BRA    0C18
00D70:  BTFSC  x3A.2
00D72:  BRA    0C86
00D74:  BRA    0CDC
00D76:  MOVF   FEF,W
00D78:  ADDWF  x3C,F
00D7A:  BNC   0D86
00D7C:  INCF   x3D,F
00D7E:  BNZ   0D86
00D80:  INCF   x3E,F
00D82:  BTFSC  FD8.2
00D84:  BSF    x38.0
00D86:  MOVF   FED,F
00D88:  MOVF   FEF,W
00D8A:  ADDWF  x3D,F
00D8C:  BNC   0D94
00D8E:  INCF   x3E,F
00D90:  BTFSC  FD8.2
00D92:  BSF    x38.0
00D94:  MOVF   FED,F
00D96:  MOVF   FEF,W
00D98:  BTFSC  FEF.7
00D9A:  BRA    0D9E
00D9C:  XORLW  80
00D9E:  ADDWF  x3E,F
00DA0:  BTFSC  FD8.0
00DA2:  BSF    x38.0
00DA4:  BTFSC  x3A.4
00DA6:  BRA    0BA0
00DA8:  BTFSC  x3A.5
00DAA:  BRA    0C28
00DAC:  BRA    0C96
00DAE:  MOVLB  0
00DB0:  RETURN 0
*
0133E:  MOVLW  B6
01340:  MOVWF  00
01342:  CLRF   03
01344:  CLRF   02
01346:  CLRF   01
01348:  MOVLB  5
0134A:  MOVF   xF5,W
0134C:  IORWF  xF6,W
0134E:  IORWF  xF7,W
01350:  IORWF  xF8,W
01352:  BNZ   1358
01354:  CLRF   00
01356:  BRA    1372
01358:  BCF    FD8.0
0135A:  BTFSC  01.7
0135C:  BRA    1370
0135E:  RLCF   xF5,F
01360:  RLCF   xF6,F
01362:  RLCF   xF7,F
01364:  RLCF   xF8,F
01366:  RLCF   03,F
01368:  RLCF   02,F
0136A:  RLCF   01,F
0136C:  DECFSZ 00,F
0136E:  BRA    1358
01370:  BCF    01.7
01372:  MOVLB  0
01374:  RETURN 0
01376:  MOVFF  62D,634
0137A:  MOVLB  6
0137C:  MOVF   x31,W
0137E:  XORWF  x34,F
01380:  BTFSS  x34.7
01382:  BRA    138E
01384:  BCF    FD8.2
01386:  BCF    FD8.0
01388:  BTFSC  x2D.7
0138A:  BSF    FD8.0
0138C:  BRA    13EC
0138E:  MOVFF  62D,634
01392:  MOVFF  630,635
01396:  MOVF   x2C,W
01398:  SUBWF  x35,F
0139A:  BZ    13A8
0139C:  BTFSS  x34.7
0139E:  BRA    13EC
013A0:  MOVF   FD8,W
013A2:  XORLW  01
013A4:  MOVWF  FD8
013A6:  BRA    13EC
013A8:  MOVFF  631,635
013AC:  MOVF   x2D,W
013AE:  SUBWF  x35,F
013B0:  BZ    13BE
013B2:  BTFSS  x34.7
013B4:  BRA    13EC
013B6:  MOVF   FD8,W
013B8:  XORLW  01
013BA:  MOVWF  FD8
013BC:  BRA    13EC
013BE:  MOVFF  632,635
013C2:  MOVF   x2E,W
013C4:  SUBWF  x35,F
013C6:  BZ    13D4
013C8:  BTFSS  x34.7
013CA:  BRA    13EC
013CC:  MOVF   FD8,W
013CE:  XORLW  01
013D0:  MOVWF  FD8
013D2:  BRA    13EC
013D4:  MOVFF  633,635
013D8:  MOVF   x2F,W
013DA:  SUBWF  x35,F
013DC:  BZ    13EA
013DE:  BTFSS  x34.7
013E0:  BRA    13EC
013E2:  MOVF   FD8,W
013E4:  XORLW  01
013E6:  MOVWF  FD8
013E8:  BRA    13EC
013EA:  BCF    FD8.0
013EC:  MOVLB  0
013EE:  RETURN 0
013F0:  MOVLB  6
013F2:  MOVF   x25,W
013F4:  BTFSC  FD8.2
013F6:  BRA    1542
013F8:  MOVWF  x31
013FA:  MOVF   x29,W
013FC:  BTFSC  FD8.2
013FE:  BRA    1542
01400:  SUBWF  x31,F
01402:  BNC   140E
01404:  MOVLW  7F
01406:  ADDWF  x31,F
01408:  BTFSC  FD8.0
0140A:  BRA    1542
0140C:  BRA    141A
0140E:  MOVLW  81
01410:  SUBWF  x31,F
01412:  BTFSS  FD8.0
01414:  BRA    1542
01416:  BTFSC  FD8.2
01418:  BRA    1542
0141A:  MOVFF  631,00
0141E:  CLRF   01
01420:  CLRF   02
01422:  CLRF   03
01424:  CLRF   x30
01426:  MOVFF  626,62F
0142A:  BSF    x2F.7
0142C:  MOVFF  627,62E
01430:  MOVFF  628,62D
01434:  MOVLW  19
01436:  MOVWF  x31
01438:  MOVF   x2C,W
0143A:  SUBWF  x2D,F
0143C:  BC    1458
0143E:  MOVLW  01
01440:  SUBWF  x2E,F
01442:  BC    1458
01444:  SUBWF  x2F,F
01446:  BC    1458
01448:  SUBWF  x30,F
0144A:  BC    1458
0144C:  INCF   x30,F
0144E:  INCF   x2F,F
01450:  INCF   x2E,F
01452:  MOVF   x2C,W
01454:  ADDWF  x2D,F
01456:  BRA    14A8
01458:  MOVF   x2B,W
0145A:  SUBWF  x2E,F
0145C:  BC    1482
0145E:  MOVLW  01
01460:  SUBWF  x2F,F
01462:  BC    1482
01464:  SUBWF  x30,F
01466:  BC    1482
01468:  INCF   x30,F
0146A:  INCF   x2F,F
0146C:  MOVF   x2B,W
0146E:  ADDWF  x2E,F
01470:  MOVF   x2C,W
01472:  ADDWF  x2D,F
01474:  BNC   14A8
01476:  INCF   x2E,F
01478:  BNZ   14A8
0147A:  INCF   x2F,F
0147C:  BNZ   14A8
0147E:  INCF   x30,F
01480:  BRA    14A8
01482:  MOVF   x2A,W
01484:  IORLW  80
01486:  SUBWF  x2F,F
01488:  BC    14A6
0148A:  MOVLW  01
0148C:  SUBWF  x30,F
0148E:  BC    14A6
01490:  INCF   x30,F
01492:  MOVF   x2A,W
01494:  IORLW  80
01496:  ADDWF  x2F,F
01498:  MOVF   x2B,W
0149A:  ADDWF  x2E,F
0149C:  BNC   1470
0149E:  INCF   x2F,F
014A0:  BNZ   1470
014A2:  INCF   x30,F
014A4:  BRA    1470
014A6:  BSF    03.0
014A8:  DECFSZ x31,F
014AA:  BRA    14AE
014AC:  BRA    14C4
014AE:  BCF    FD8.0
014B0:  RLCF   x2D,F
014B2:  RLCF   x2E,F
014B4:  RLCF   x2F,F
014B6:  RLCF   x30,F
014B8:  BCF    FD8.0
014BA:  RLCF   03,F
014BC:  RLCF   02,F
014BE:  RLCF   01,F
014C0:  RLCF   x32,F
014C2:  BRA    1438
014C4:  BTFSS  x32.0
014C6:  BRA    14D4
014C8:  BCF    FD8.0
014CA:  RRCF   01,F
014CC:  RRCF   02,F
014CE:  RRCF   03,F
014D0:  RRCF   x32,F
014D2:  BRA    14D8
014D4:  DECF   00,F
014D6:  BZ    1542
014D8:  BTFSC  x32.7
014DA:  BRA    1518
014DC:  BCF    FD8.0
014DE:  RLCF   x2D,F
014E0:  RLCF   x2E,F
014E2:  RLCF   x2F,F
014E4:  RLCF   x30,F
014E6:  MOVF   x2C,W
014E8:  SUBWF  x2D,F
014EA:  BC    14FA
014EC:  MOVLW  01
014EE:  SUBWF  x2E,F
014F0:  BC    14FA
014F2:  SUBWF  x2F,F
014F4:  BC    14FA
014F6:  SUBWF  x30,F
014F8:  BNC   152E
014FA:  MOVF   x2B,W
014FC:  SUBWF  x2E,F
014FE:  BC    150A
01500:  MOVLW  01
01502:  SUBWF  x2F,F
01504:  BC    150A
01506:  SUBWF  x30,F
01508:  BNC   152E
0150A:  MOVF   x2A,W
0150C:  IORLW  80
0150E:  SUBWF  x2F,F
01510:  BC    1518
01512:  MOVLW  01
01514:  SUBWF  x30,F
01516:  BNC   152E
01518:  INCF   03,F
0151A:  BNZ   152E
0151C:  INCF   02,F
0151E:  BNZ   152E
01520:  INCF   01,F
01522:  BNZ   152E
01524:  INCF   00,F
01526:  BZ    1542
01528:  RRCF   01,F
0152A:  RRCF   02,F
0152C:  RRCF   03,F
0152E:  MOVFF  626,631
01532:  MOVF   x2A,W
01534:  XORWF  x31,F
01536:  BTFSS  x31.7
01538:  BRA    153E
0153A:  BSF    01.7
0153C:  BRA    154A
0153E:  BCF    01.7
01540:  BRA    154A
01542:  CLRF   00
01544:  CLRF   01
01546:  CLRF   02
01548:  CLRF   03
0154A:  MOVLB  0
0154C:  RETURN 0
*
01CF8:  ADDWF  FE8,W
01CFA:  CLRF   FF7
01CFC:  RLCF   FF7,F
01CFE:  ADDLW  13
01D00:  MOVWF  FF6
01D02:  MOVLW  1D
01D04:  ADDWFC FF7,F
01D06:  TBLRD*-
01D08:  MOVF   FF5,W
01D0A:  MOVWF  FFA
01D0C:  TBLRD*
01D0E:  MOVF   FF5,W
01D10:  MOVWF  FF9
01D12:  DATA 00,1C
01D14:  DATA 1A,1C
01D16:  DATA 6E,1C
01D18:  DATA D2,1C
01D1A:  MOVLW  8E
01D1C:  MOVWF  00
01D1E:  MOVLB  6
01D20:  MOVF   x2C,W
01D22:  SUBWF  00,F
01D24:  MOVFF  62D,02
01D28:  MOVFF  62E,01
01D2C:  BSF    02.7
01D2E:  MOVF   00,F
01D30:  BZ    1D44
01D32:  BCF    FD8.0
01D34:  MOVF   02,F
01D36:  BNZ   1D3C
01D38:  MOVF   01,F
01D3A:  BZ    1D44
01D3C:  RRCF   02,F
01D3E:  RRCF   01,F
01D40:  DECFSZ 00,F
01D42:  BRA    1D32
01D44:  BTFSS  x2D.7
01D46:  BRA    1D52
01D48:  COMF   01,F
01D4A:  COMF   02,F
01D4C:  INCF   01,F
01D4E:  BTFSC  FD8.2
01D50:  INCF   02,F
01D52:  MOVLB  0
01D54:  RETURN 0
*
02266:  MOVLW  8E
02268:  MOVWF  00
0226A:  MOVFF  623,01
0226E:  MOVFF  622,02
02272:  CLRF   03
02274:  BTFSS  01.7
02276:  BRA    2282
02278:  COMF   01,F
0227A:  COMF   02,F
0227C:  INCF   02,F
0227E:  BNZ   2282
02280:  INCF   01,F
02282:  MOVF   01,F
02284:  BNZ   2298
02286:  MOVFF  02,01
0228A:  CLRF   02
0228C:  MOVLW  08
0228E:  SUBWF  00,F
02290:  MOVF   01,F
02292:  BNZ   2298
02294:  CLRF   00
02296:  BRA    22B4
02298:  BCF    FD8.0
0229A:  BTFSC  01.7
0229C:  BRA    22A6
0229E:  RLCF   02,F
022A0:  RLCF   01,F
022A2:  DECF   00,F
022A4:  BRA    2298
022A6:  MOVLB  6
022A8:  BTFSS  x23.7
022AA:  BRA    22B0
022AC:  MOVLB  0
022AE:  BRA    22B4
022B0:  BCF    01.7
022B2:  MOVLB  0
022B4:  RETURN 0
*
037EA:  MOVLB  5
037EC:  MOVF   xE4,W
037EE:  ANDLW  07
037F0:  MOVWF  00
037F2:  RRCF   xE4,W
037F4:  MOVWF  01
037F6:  RRCF   01,F
037F8:  RRCF   01,F
037FA:  MOVLW  1F
037FC:  ANDWF  01,F
037FE:  MOVF   01,W
03800:  ADDWF  xE5,W
03802:  MOVWF  FE9
03804:  MOVLW  00
03806:  ADDWFC xE6,W
03808:  MOVWF  FEA
0380A:  MOVFF  FEF,01
0380E:  INCF   00,F
03810:  BRA    3814
03812:  RRCF   01,F
03814:  DECFSZ 00,F
03816:  BRA    3812
03818:  MOVLW  01
0381A:  ANDWF  01,F
0381C:  MOVLB  0
0381E:  RETURN 0
*
03B8C:  MOVF   FEF,F
03B8E:  BZ    3BAE
03B90:  MOVFF  FEA,5DD
03B94:  MOVFF  FE9,5DC
03B98:  MOVFF  FEF,5DE
03B9C:  RCALL  3B64
03B9E:  MOVFF  5DD,FEA
03BA2:  MOVFF  5DC,FE9
03BA6:  INCF   FE9,F
03BA8:  BTFSC  FD8.2
03BAA:  INCF   FEA,F
03BAC:  BRA    3B8C
03BAE:  RETURN 0
*
041F4:  MOVFF  4CE,FEA
041F8:  MOVFF  4CD,FE9
041FC:  MOVFF  60D,FEF
04200:  INCF   FE9,F
04202:  BTFSC  FD8.2
04204:  INCF   FEA,F
04206:  CLRF   FEF
04208:  MOVLB  4
0420A:  INCF   xCD,F
0420C:  BTFSC  FD8.2
0420E:  INCF   xCE,F
04210:  MOVLB  0
04212:  RETURN 0
04214:  TBLRD*+
04216:  MOVF   FF5,F
04218:  BZ    4232
0421A:  MOVFF  FF6,5E6
0421E:  MOVFF  FF7,5E7
04222:  MOVFF  FF5,60D
04226:  RCALL  41F4
04228:  MOVFF  5E6,FF6
0422C:  MOVFF  5E7,FF7
04230:  BRA    4214
04232:  RETURN 0
*
04356:  MOVLB  6
04358:  MOVF   x31,W
0435A:  XORWF  x33,W
0435C:  ANDLW  80
0435E:  MOVWF  x35
04360:  BTFSS  x31.7
04362:  BRA    436E
04364:  COMF   x30,F
04366:  COMF   x31,F
04368:  INCF   x30,F
0436A:  BTFSC  FD8.2
0436C:  INCF   x31,F
0436E:  BTFSS  x33.7
04370:  BRA    437C
04372:  COMF   x32,F
04374:  COMF   x33,F
04376:  INCF   x32,F
04378:  BTFSC  FD8.2
0437A:  INCF   x33,F
0437C:  MOVF   x30,W
0437E:  MULWF  x32
04380:  MOVFF  FF3,01
04384:  MOVFF  FF4,00
04388:  MULWF  x33
0438A:  MOVF   FF3,W
0438C:  ADDWF  00,F
0438E:  MOVF   x31,W
04390:  MULWF  x32
04392:  MOVF   FF3,W
04394:  ADDWFC 00,W
04396:  MOVWF  02
04398:  BTFSS  x35.7
0439A:  BRA    43A6
0439C:  COMF   01,F
0439E:  COMF   02,F
043A0:  INCF   01,F
043A2:  BTFSC  FD8.2
043A4:  INCF   02,F
043A6:  MOVLB  0
043A8:  GOTO   463C (RETURN)
*
0487A:  MOVLB  5
0487C:  MOVF   xF9,W
0487E:  ANDLW  07
04880:  MOVWF  00
04882:  RRCF   xF9,W
04884:  MOVWF  01
04886:  RRCF   01,F
04888:  RRCF   01,F
0488A:  MOVLW  1F
0488C:  ANDWF  01,F
0488E:  MOVF   01,W
04890:  ADDWF  xFB,W
04892:  MOVWF  FE9
04894:  MOVLW  00
04896:  ADDWFC xFC,W
04898:  MOVWF  FEA
0489A:  CLRF   01
0489C:  INCF   01,F
0489E:  INCF   00,F
048A0:  BRA    48A4
048A2:  RLCF   01,F
048A4:  DECFSZ 00,F
048A6:  BRA    48A2
048A8:  MOVF   xFA,F
048AA:  BZ    48B2
048AC:  MOVF   01,W
048AE:  IORWF  FEF,F
048B0:  BRA    48B8
048B2:  COMF   01,F
048B4:  MOVF   01,W
048B6:  ANDWF  FEF,F
048B8:  MOVLB  0
048BA:  RETURN 0
*
04DF2:  MOVLB  6
04DF4:  MOVF   x0D,W
04DF6:  SUBLW  B6
04DF8:  MOVWF  x0D
04DFA:  CLRF   03
04DFC:  MOVFF  60E,611
04E00:  BSF    x0E.7
04E02:  BCF    FD8.0
04E04:  RRCF   x0E,F
04E06:  RRCF   x0F,F
04E08:  RRCF   x10,F
04E0A:  RRCF   03,F
04E0C:  RRCF   02,F
04E0E:  RRCF   01,F
04E10:  RRCF   00,F
04E12:  DECFSZ x0D,F
04E14:  BRA    4E02
04E16:  BTFSS  x11.7
04E18:  BRA    4E30
04E1A:  COMF   00,F
04E1C:  COMF   01,F
04E1E:  COMF   02,F
04E20:  COMF   03,F
04E22:  INCF   00,F
04E24:  BTFSC  FD8.2
04E26:  INCF   01,F
04E28:  BTFSC  FD8.2
04E2A:  INCF   02,F
04E2C:  BTFSC  FD8.2
04E2E:  INCF   03,F
04E30:  MOVLB  0
04E32:  GOTO   4F22 (RETURN)
04E36:  BTFSC  FD8.1
04E38:  BRA    4E42
04E3A:  MOVLW  06
04E3C:  MOVWF  FEA
04E3E:  MOVLW  15
04E40:  MOVWF  FE9
04E42:  CLRF   00
04E44:  CLRF   01
04E46:  CLRF   02
04E48:  CLRF   03
04E4A:  MOVLB  6
04E4C:  CLRF   x15
04E4E:  CLRF   x16
04E50:  CLRF   x17
04E52:  CLRF   x18
04E54:  MOVF   x14,W
04E56:  IORWF  x13,W
04E58:  IORWF  x12,W
04E5A:  IORWF  x11,W
04E5C:  BZ    4EB6
04E5E:  MOVLW  20
04E60:  MOVWF  x19
04E62:  BCF    FD8.0
04E64:  RLCF   x0D,F
04E66:  RLCF   x0E,F
04E68:  RLCF   x0F,F
04E6A:  RLCF   x10,F
04E6C:  RLCF   x15,F
04E6E:  RLCF   x16,F
04E70:  RLCF   x17,F
04E72:  RLCF   x18,F
04E74:  MOVF   x14,W
04E76:  SUBWF  x18,W
04E78:  BNZ   4E8A
04E7A:  MOVF   x13,W
04E7C:  SUBWF  x17,W
04E7E:  BNZ   4E8A
04E80:  MOVF   x12,W
04E82:  SUBWF  x16,W
04E84:  BNZ   4E8A
04E86:  MOVF   x11,W
04E88:  SUBWF  x15,W
04E8A:  BNC   4EAA
04E8C:  MOVF   x11,W
04E8E:  SUBWF  x15,F
04E90:  MOVF   x12,W
04E92:  BTFSS  FD8.0
04E94:  INCFSZ x12,W
04E96:  SUBWF  x16,F
04E98:  MOVF   x13,W
04E9A:  BTFSS  FD8.0
04E9C:  INCFSZ x13,W
04E9E:  SUBWF  x17,F
04EA0:  MOVF   x14,W
04EA2:  BTFSS  FD8.0
04EA4:  INCFSZ x14,W
04EA6:  SUBWF  x18,F
04EA8:  BSF    FD8.0
04EAA:  RLCF   00,F
04EAC:  RLCF   01,F
04EAE:  RLCF   02,F
04EB0:  RLCF   03,F
04EB2:  DECFSZ x19,F
04EB4:  BRA    4E62
04EB6:  MOVFF  615,FEF
04EBA:  MOVFF  616,FEC
04EBE:  MOVFF  617,FEC
04EC2:  MOVFF  618,FEC
04EC6:  MOVLB  0
04EC8:  RETURN 0
04ECA:  MOVF   FE9,W
04ECC:  MOVLB  6
04ECE:  MOVWF  x05
04ED0:  MOVF   x04,W
04ED2:  MOVWF  x07
04ED4:  BZ    4F0E
04ED6:  MOVFF  603,62F
04EDA:  MOVFF  602,62E
04EDE:  MOVFF  601,62D
04EE2:  MOVFF  600,62C
04EE6:  CLRF   x33
04EE8:  CLRF   x32
04EEA:  MOVLW  20
04EEC:  MOVWF  x31
04EEE:  MOVLW  82
04EF0:  MOVWF  x30
04EF2:  MOVLB  0
04EF4:  CALL   0A44
04EF8:  MOVFF  03,603
04EFC:  MOVFF  02,602
04F00:  MOVFF  01,601
04F04:  MOVFF  00,600
04F08:  MOVLB  6
04F0A:  DECFSZ x07,F
04F0C:  BRA    4ED6
04F0E:  MOVFF  603,610
04F12:  MOVFF  602,60F
04F16:  MOVFF  601,60E
04F1A:  MOVFF  600,60D
04F1E:  MOVLB  0
04F20:  BRA    4DF2
04F22:  MOVFF  03,603
04F26:  MOVFF  02,602
04F2A:  MOVFF  01,601
04F2E:  MOVFF  00,600
04F32:  MOVLB  6
04F34:  BTFSS  x03.7
04F36:  BRA    4F52
04F38:  DECF   x05,F
04F3A:  BSF    x05.5
04F3C:  COMF   x00,F
04F3E:  COMF   x01,F
04F40:  COMF   x02,F
04F42:  COMF   x03,F
04F44:  INCF   x00,F
04F46:  BTFSC  FD8.2
04F48:  INCF   x01,F
04F4A:  BTFSC  FD8.2
04F4C:  INCF   x02,F
04F4E:  BTFSC  FD8.2
04F50:  INCF   x03,F
04F52:  MOVLW  3B
04F54:  MOVWF  x0C
04F56:  MOVLW  9A
04F58:  MOVWF  x0B
04F5A:  MOVLW  CA
04F5C:  MOVWF  x0A
04F5E:  CLRF   x09
04F60:  MOVLW  0A
04F62:  MOVWF  x07
04F64:  MOVF   x04,W
04F66:  BTFSC  FD8.2
04F68:  INCF   x05,F
04F6A:  BSF    FD8.1
04F6C:  MOVLW  06
04F6E:  MOVWF  FEA
04F70:  CLRF   FE9
04F72:  MOVFF  603,610
04F76:  MOVFF  602,60F
04F7A:  MOVFF  601,60E
04F7E:  MOVFF  600,60D
04F82:  MOVFF  60C,614
04F86:  MOVFF  60B,613
04F8A:  MOVFF  60A,612
04F8E:  MOVFF  609,611
04F92:  MOVLB  0
04F94:  RCALL  4E36
04F96:  MOVF   01,W
04F98:  MOVF   00,F
04F9A:  BNZ   4FC2
04F9C:  MOVLB  6
04F9E:  INCF   x04,W
04FA0:  SUBWF  x07,W
04FA2:  BTFSS  FD8.2
04FA4:  BRA    4FAA
04FA6:  MOVLB  0
04FA8:  BRA    4FC2
04FAA:  MOVF   x05,W
04FAC:  BZ    4FC8
04FAE:  ANDLW  0F
04FB0:  SUBWF  x07,W
04FB2:  BZ    4FB6
04FB4:  BC    503E
04FB6:  BTFSC  x05.7
04FB8:  BRA    503E
04FBA:  BTFSC  x05.6
04FBC:  BRA    4FC8
04FBE:  MOVLW  20
04FC0:  BRA    5030
04FC2:  MOVLW  20
04FC4:  MOVLB  6
04FC6:  ANDWF  x05,F
04FC8:  BTFSS  x05.5
04FCA:  BRA    4FEA
04FCC:  BCF    x05.5
04FCE:  MOVF   x04,W
04FD0:  BTFSS  FD8.2
04FD2:  DECF   x05,F
04FD4:  MOVF   00,W
04FD6:  MOVWF  x05
04FD8:  MOVLW  2D
04FDA:  MOVWF  x0D
04FDC:  MOVLB  0
04FDE:  CALL   41F4
04FE2:  MOVLB  6
04FE4:  MOVF   x05,W
04FE6:  MOVWF  00
04FE8:  CLRF   x05
04FEA:  MOVF   x04,W
04FEC:  SUBWF  x07,W
04FEE:  BNZ   500A
04FF0:  MOVF   00,W
04FF2:  MOVWF  x05
04FF4:  MOVLW  2E
04FF6:  MOVWF  x0D
04FF8:  MOVLB  0
04FFA:  CALL   41F4
04FFE:  MOVLB  6
05000:  MOVF   x05,W
05002:  MOVWF  00
05004:  MOVLW  20
05006:  ANDWF  x05,F
05008:  MOVLW  00
0500A:  MOVLW  30
0500C:  BTFSS  x05.5
0500E:  BRA    5030
05010:  BCF    x05.5
05012:  MOVF   x04,W
05014:  BTFSS  FD8.2
05016:  DECF   x05,F
05018:  MOVF   00,W
0501A:  MOVWF  x05
0501C:  MOVLW  2D
0501E:  MOVWF  x0D
05020:  MOVLB  0
05022:  CALL   41F4
05026:  MOVLB  6
05028:  MOVF   x05,W
0502A:  MOVWF  00
0502C:  CLRF   x05
0502E:  MOVLW  30
05030:  ADDWF  00,F
05032:  MOVFF  00,60D
05036:  MOVLB  0
05038:  CALL   41F4
0503C:  MOVLB  6
0503E:  BCF    FD8.1
05040:  MOVFF  60C,610
05044:  MOVFF  60B,60F
05048:  MOVFF  60A,60E
0504C:  MOVFF  609,60D
05050:  CLRF   x14
05052:  CLRF   x13
05054:  CLRF   x12
05056:  MOVLW  0A
05058:  MOVWF  x11
0505A:  MOVLB  0
0505C:  RCALL  4E36
0505E:  MOVFF  03,60C
05062:  MOVFF  02,60B
05066:  MOVFF  01,60A
0506A:  MOVFF  00,609
0506E:  MOVLB  6
05070:  DECFSZ x07,F
05072:  BRA    4F6A
05074:  MOVLB  0
05076:  RETURN 0
*
0686C:  MOVFF  FEA,60A
06870:  MOVFF  FE9,609
06874:  MOVLB  6
06876:  BTFSS  x03.7
06878:  BRA    688A
0687A:  BSF    x09.7
0687C:  BTFSS  x09.4
0687E:  INCF   x09,F
06880:  COMF   x02,F
06882:  COMF   x03,F
06884:  INCF   x02,F
06886:  BTFSC  FD8.2
06888:  INCF   x03,F
0688A:  SWAPF  x03,W
0688C:  IORLW  F0
0688E:  MOVWF  x05
06890:  ADDWF  x05,F
06892:  ADDLW  E2
06894:  MOVWF  x06
06896:  ADDLW  32
06898:  MOVWF  x08
0689A:  MOVF   x03,W
0689C:  ANDLW  0F
0689E:  ADDWF  x06,F
068A0:  ADDWF  x06,F
068A2:  ADDWF  x08,F
068A4:  ADDLW  E9
068A6:  MOVWF  x07
068A8:  ADDWF  x07,F
068AA:  ADDWF  x07,F
068AC:  SWAPF  x02,W
068AE:  ANDLW  0F
068B0:  ADDWF  x07,F
068B2:  ADDWF  x08,F
068B4:  RLCF   x07,F
068B6:  RLCF   x08,F
068B8:  COMF   x08,F
068BA:  RLCF   x08,F
068BC:  MOVF   x02,W
068BE:  ANDLW  0F
068C0:  ADDWF  x08,F
068C2:  RLCF   x05,F
068C4:  MOVLW  07
068C6:  MOVWF  x04
068C8:  MOVLW  0A
068CA:  DECF   x07,F
068CC:  ADDWF  x08,F
068CE:  BNC   68CA
068D0:  DECF   x06,F
068D2:  ADDWF  x07,F
068D4:  BNC   68D0
068D6:  DECF   x05,F
068D8:  ADDWF  x06,F
068DA:  BNC   68D6
068DC:  DECF   x04,F
068DE:  ADDWF  x05,F
068E0:  BNC   68DC
068E2:  MOVLW  06
068E4:  MOVWF  FEA
068E6:  MOVLW  04
068E8:  MOVWF  FE9
068EA:  MOVLW  07
068EC:  ANDWF  x09,W
068EE:  BCF    x09.6
068F0:  MOVF   FED,F
068F2:  ANDWF  x09,W
068F4:  BNZ   6904
068F6:  BTFSC  x09.4
068F8:  MOVF   FEE,F
068FA:  BTFSC  x09.4
068FC:  BRA    6904
068FE:  MOVLW  20
06900:  MOVWF  00
06902:  BRA    6946
06904:  ADDWF  FE9,F
06906:  MOVLW  00
06908:  ADDWFC FEA,F
0690A:  MOVF   FE9,W
0690C:  SUBLW  08
0690E:  BNZ   6918
06910:  MOVF   FEA,W
06912:  SUBLW  06
06914:  BNZ   6918
06916:  BSF    x09.6
06918:  MOVF   FEF,W
0691A:  MOVWF  00
0691C:  BNZ   692E
0691E:  BTFSC  x09.6
06920:  BRA    692E
06922:  BTFSC  x09.4
06924:  BRA    6962
06926:  BTFSC  x09.3
06928:  BRA    692E
0692A:  MOVLW  20
0692C:  BRA    6944
0692E:  BTFSS  x09.7
06930:  BRA    693E
06932:  MOVLW  2D
06934:  MOVWF  00
06936:  MOVF   FED,W
06938:  BCF    x09.6
0693A:  BCF    x09.7
0693C:  BRA    6946
0693E:  BSF    x09.3
06940:  BCF    x09.4
06942:  MOVLW  30
06944:  ADDWF  00,F
06946:  MOVFF  FEA,603
0694A:  MOVFF  FE9,602
0694E:  MOVFF  00,60D
06952:  MOVLB  0
06954:  CALL   41F4
06958:  MOVFF  603,FEA
0695C:  MOVFF  602,FE9
06960:  MOVLB  6
06962:  MOVF   FEE,W
06964:  BTFSS  x09.6
06966:  BRA    690A
06968:  MOVLB  0
0696A:  RETURN 0
*
0715A:  MOVF   FEF,F
0715C:  BZ    717E
0715E:  MOVFF  FEA,5DD
07162:  MOVFF  FE9,5DC
07166:  MOVFF  FEF,60D
0716A:  CALL   41F4
0716E:  MOVFF  5DD,FEA
07172:  MOVFF  5DC,FE9
07176:  INCF   FE9,F
07178:  BTFSC  FD8.2
0717A:  INCF   FEA,F
0717C:  BRA    715A
0717E:  GOTO   71FC (RETURN)
.................... 
.................... #list
.................... 
.................... 
.................... #device ADC=10
.................... 
.................... //!#FUSES WDT                      //Watch Dog Timer
.................... //!#FUSES WDT4096                  //Watch Dog Timer uses 1:4096 Postscale
.................... 
.................... #use delay(internal=64000000)
*
003A8:  MOVLW  05
003AA:  MOVWF  FEA
003AC:  MOVLW  DA
003AE:  MOVWF  FE9
003B0:  MOVF   FEF,W
003B2:  BZ    03D0
003B4:  MOVLW  14
003B6:  MOVWF  01
003B8:  CLRF   00
003BA:  DECFSZ 00,F
003BC:  BRA    03BA
003BE:  DECFSZ 01,F
003C0:  BRA    03B8
003C2:  MOVLW  BF
003C4:  MOVWF  00
003C6:  DECFSZ 00,F
003C8:  BRA    03C6
003CA:  BRA    03CC
003CC:  DECFSZ FEF,F
003CE:  BRA    03B4
003D0:  RETURN 0
*
0065A:  MOVLW  01
0065C:  MOVLB  5
0065E:  SUBWF  xE1,F
00660:  BNC   067A
00662:  MOVLW  05
00664:  MOVWF  FEA
00666:  MOVLW  E1
00668:  MOVWF  FE9
0066A:  MOVF   FEF,W
0066C:  BZ    067A
0066E:  MOVLW  04
00670:  MOVWF  00
00672:  DECFSZ 00,F
00674:  BRA    0672
00676:  DECFSZ FEF,F
00678:  BRA    066E
0067A:  MOVLB  0
0067C:  GOTO   06CC (RETURN)
.................... #define baudRate 128000
.................... #define numChannels 2
.................... 
.................... #define version  "20250522" // SW Version
.................... #define serialID "0000"     // Unique Serial ID
.................... #define magPP 1             // Magnetoresistive Sensor Pole Pitch in mm       
.................... 
.................... 
.................... 
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
*
00312:  MOVLW  CF
00314:  MOVWF  F87
00316:  CLRF   F82
....................    output_b(portB_reset);
00318:  MOVLW  C4
0031A:  MOVWF  F88
0031C:  CLRF   F83
....................    output_c(portC_reset);
0031E:  MOVLW  93
00320:  MOVWF  F89
00322:  CLRF   F84
....................    output_d(portD_reset);
00324:  MOVLW  1F
00326:  MOVWF  F8A
00328:  CLRF   F85
....................    output_e(portE_reset);
0032A:  BCF    F8B.0
0032C:  BCF    F8B.1
0032E:  BCF    F8B.2
00330:  BCF    F8B.3
00332:  CLRF   F86
....................    
....................    port_a_pullups(portA_pullups);
00334:  MOVLB  F
00336:  SETF   x0B
....................    port_b_pullups(portB_pullups);
00338:  CLRF   x13
....................    port_c_pullups(portC_pullups);
0033A:  CLRF   x1B
....................    port_d_pullups(portD_pullups);
0033C:  SETF   x20
....................    port_e_pullups(portE_pullups);
0033E:  CLRF   x28
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
00340:  MOVLW  40
00342:  MOVWF  x0C
00344:  CLRF   x14
00346:  MOVLW  03
00348:  MOVWF  x1C
0034A:  MOVLW  0F
0034C:  MOVWF  x21
0034E:  CLRF   x29
00350:  MOVLB  0
00352:  GOTO   75CA (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
*
0417C:  MOVFF  5FB,FEA
04180:  MOVLB  5
04182:  MOVFF  5FA,FE9
04186:  MOVFF  FEF,5FE
0418A:  MOVFF  5FD,FEA
0418E:  MOVFF  5FC,FE9
04192:  MOVF   FEF,W
04194:  SUBWF  xFE,W
04196:  BNZ   41C6
....................       if (*s1 == '\0')
04198:  MOVFF  5FB,03
0419C:  MOVFF  5FA,FE9
041A0:  MOVFF  03,FEA
041A4:  MOVF   FEF,F
041A6:  BNZ   41AE
....................          return(0);
041A8:  MOVLW  00
041AA:  MOVWF  01
041AC:  BRA    41F0
041AE:  MOVFF  5FB,03
041B2:  MOVF   xFA,W
041B4:  INCF   xFA,F
041B6:  BTFSC  FD8.2
041B8:  INCF   xFB,F
041BA:  INCF   xFC,F
041BC:  BTFSC  FD8.2
041BE:  INCF   xFD,F
041C0:  MOVLB  0
041C2:  BRA    417C
041C4:  MOVLB  5
....................    return((*s1 < *s2) ? -1: 1);
041C6:  MOVFF  5FB,03
041CA:  MOVFF  5FA,FE9
041CE:  MOVFF  03,FEA
041D2:  MOVFF  FEF,5FE
041D6:  MOVFF  5FD,03
041DA:  MOVFF  5FC,FE9
041DE:  MOVFF  03,FEA
041E2:  MOVF   FEF,W
041E4:  SUBWF  xFE,W
041E6:  BC    41EC
041E8:  MOVLW  FF
041EA:  BRA    41EE
041EC:  MOVLW  01
041EE:  MOVWF  01
041F0:  MOVLB  0
041F2:  RETURN 0
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
*
0430C:  MOVFF  631,634
....................    for(su=s;0<n;++su,--n)
04310:  MOVFF  630,636
04314:  MOVFF  62F,635
04318:  MOVLB  6
0431A:  MOVF   x33,F
0431C:  BNZ   4324
0431E:  MOVF   x32,W
04320:  SUBLW  00
04322:  BC    434C
....................       if(*su==uc)
04324:  MOVFF  636,FEA
04328:  MOVFF  635,FE9
0432C:  MOVF   x34,W
0432E:  SUBWF  FEF,W
04330:  BNZ   433C
....................       return su;
04332:  MOVFF  635,01
04336:  MOVFF  636,02
0433A:  BRA    4352
0433C:  INCF   x35,F
0433E:  BTFSC  FD8.2
04340:  INCF   x36,F
04342:  MOVF   x32,W
04344:  BTFSC  FD8.2
04346:  DECF   x33,F
04348:  DECF   x32,F
0434A:  BRA    431A
....................    return NULL;
0434C:  MOVLW  00
0434E:  MOVWF  01
04350:  MOVWF  02
04352:  MOVLB  0
04354:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
*
0413C:  MOVFF  5FF,601
04140:  MOVFF  5FE,600
04144:  MOVFF  601,FEA
04148:  MOVLB  6
0414A:  MOVFF  600,FE9
0414E:  MOVF   FEF,F
04150:  BZ    415E
04152:  INCF   x00,F
04154:  BTFSC  FD8.2
04156:  INCF   x01,F
04158:  MOVLB  0
0415A:  BRA    4144
0415C:  MOVLB  6
....................    return(sc - s);
0415E:  MOVLB  5
04160:  MOVF   xFE,W
04162:  MOVLB  6
04164:  SUBWF  x00,W
04166:  MOVWF  00
04168:  MOVLB  5
0416A:  MOVF   xFF,W
0416C:  MOVLB  6
0416E:  SUBWFB x01,W
04170:  MOVWF  03
04172:  MOVFF  00,01
04176:  MOVWF  02
04178:  MOVLB  0
0417A:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
*
0535A:  MOVLB  5
0535C:  CLRF   xF2
0535E:  CLRF   xF1
05360:  CLRF   xF0
05362:  MOVLW  7F
05364:  MOVWF  xEF
05366:  CLRF   xF6
05368:  CLRF   xF5
0536A:  CLRF   xF4
0536C:  CLRF   xF3
0536E:  BSF    xF7.0
05370:  BCF    xF7.1
05372:  BCF    xF7.2
05374:  CLRF   xF9
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
05376:  MOVF   xEB,W
05378:  IORWF  xEC,W
0537A:  BNZ   5386
....................       return 0;
0537C:  CLRF   00
0537E:  CLRF   01
05380:  CLRF   02
05382:  CLRF   03
05384:  BRA    55B6
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
05386:  MOVF   xF9,W
05388:  INCF   xF9,F
0538A:  ADDWF  xEB,W
0538C:  MOVWF  FE9
0538E:  MOVLW  00
05390:  ADDWFC xEC,W
05392:  MOVWF  FEA
05394:  MOVFF  FEF,5F8
05398:  MOVF   xF8,F
0539A:  BTFSC  FD8.2
0539C:  BRA    5538
....................    {
....................       if (skip && !isspace(c))
0539E:  BTFSS  xF7.0
053A0:  BRA    53C0
053A2:  MOVF   xF8,W
053A4:  SUBLW  20
053A6:  BZ    53C0
....................       {
....................          skip = 0;
053A8:  BCF    xF7.0
....................          if (c == '+')
053AA:  MOVF   xF8,W
053AC:  SUBLW  2B
053AE:  BNZ   53B6
....................          {
....................             sign = 0;
053B0:  BCF    xF7.1
....................             continue;
053B2:  BRA    5520
....................          }            
053B4:  BRA    53C0
....................          else if (c == '-')
053B6:  MOVF   xF8,W
053B8:  SUBLW  2D
053BA:  BNZ   53C0
....................          {
....................             sign = 1;
053BC:  BSF    xF7.1
....................             continue;
053BE:  BRA    5520
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
053C0:  BTFSC  xF7.0
053C2:  BRA    53D2
053C4:  MOVF   xF8,W
053C6:  SUBLW  2E
053C8:  BNZ   53D2
053CA:  BTFSC  xF7.2
053CC:  BRA    53D2
....................          point = 1;
053CE:  BSF    xF7.2
053D0:  BRA    5520
....................       else if (!skip && isdigit(c))
053D2:  BTFSC  xF7.0
053D4:  BRA    551A
053D6:  MOVF   xF8,W
053D8:  SUBLW  2F
053DA:  BTFSC  FD8.0
053DC:  BRA    551A
053DE:  MOVF   xF8,W
053E0:  SUBLW  39
053E2:  BTFSS  FD8.0
053E4:  BRA    551A
....................       {
....................          c -= '0';
053E6:  MOVLW  30
053E8:  SUBWF  xF8,F
....................          if (point)
053EA:  BTFSS  xF7.2
053EC:  BRA    549E
....................          {
....................             pow10 = pow10 * 10.0;
053EE:  MOVFF  5F2,62F
053F2:  MOVFF  5F1,62E
053F6:  MOVFF  5F0,62D
053FA:  MOVFF  5EF,62C
053FE:  MOVLB  6
05400:  CLRF   x33
05402:  CLRF   x32
05404:  MOVLW  20
05406:  MOVWF  x31
05408:  MOVLW  82
0540A:  MOVWF  x30
0540C:  MOVLB  0
0540E:  CALL   0A44
05412:  MOVFF  03,5F2
05416:  MOVFF  02,5F1
0541A:  MOVFF  01,5F0
0541E:  MOVFF  00,5EF
....................             result += (float)c / pow10;   
05422:  MOVLB  6
05424:  CLRF   x31
05426:  MOVFF  5F8,630
0542A:  MOVLB  0
0542C:  CALL   0A0E
05430:  MOVFF  03,5FD
05434:  MOVFF  02,5FC
05438:  MOVFF  01,5FB
0543C:  MOVFF  00,5FA
05440:  MOVFF  03,628
05444:  MOVFF  02,627
05448:  MOVFF  01,626
0544C:  MOVFF  00,625
05450:  MOVFF  5F2,62C
05454:  MOVFF  5F1,62B
05458:  MOVFF  5F0,62A
0545C:  MOVFF  5EF,629
05460:  CALL   13F0
05464:  BCF    FD8.1
05466:  MOVFF  5F6,633
0546A:  MOVFF  5F5,632
0546E:  MOVFF  5F4,631
05472:  MOVFF  5F3,630
05476:  MOVFF  03,637
0547A:  MOVFF  02,636
0547E:  MOVFF  01,635
05482:  MOVFF  00,634
05486:  CALL   0B3A
0548A:  MOVFF  03,5F6
0548E:  MOVFF  02,5F5
05492:  MOVFF  01,5F4
05496:  MOVFF  00,5F3
....................          }
0549A:  BRA    5516
0549C:  MOVLB  5
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
0549E:  MOVLB  6
054A0:  CLRF   x2F
054A2:  CLRF   x2E
054A4:  MOVLW  20
054A6:  MOVWF  x2D
054A8:  MOVLW  82
054AA:  MOVWF  x2C
054AC:  MOVFF  5F6,633
054B0:  MOVFF  5F5,632
054B4:  MOVFF  5F4,631
054B8:  MOVFF  5F3,630
054BC:  MOVLB  0
054BE:  CALL   0A44
054C2:  MOVFF  03,5FD
054C6:  MOVFF  02,5FC
054CA:  MOVFF  01,5FB
054CE:  MOVFF  00,5FA
054D2:  MOVLB  6
054D4:  CLRF   x31
054D6:  MOVFF  5F8,630
054DA:  MOVLB  0
054DC:  CALL   0A0E
054E0:  BCF    FD8.1
054E2:  MOVFF  5FD,633
054E6:  MOVFF  5FC,632
054EA:  MOVFF  5FB,631
054EE:  MOVFF  5FA,630
054F2:  MOVFF  03,637
054F6:  MOVFF  02,636
054FA:  MOVFF  01,635
054FE:  MOVFF  00,634
05502:  CALL   0B3A
05506:  MOVFF  03,5F6
0550A:  MOVFF  02,5F5
0550E:  MOVFF  01,5F4
05512:  MOVFF  00,5F3
....................          }
....................       }
05516:  BRA    5522
05518:  MOVLB  5
....................       else if (!skip)
0551A:  BTFSC  xF7.0
0551C:  BRA    5520
....................          break;
0551E:  BRA    5538
05520:  MOVLB  0
05522:  MOVLB  5
05524:  MOVF   xF9,W
05526:  INCF   xF9,F
05528:  ADDWF  xEB,W
0552A:  MOVWF  FE9
0552C:  MOVLW  00
0552E:  ADDWFC xEC,W
05530:  MOVWF  FEA
05532:  MOVFF  FEF,5F8
05536:  BRA    5398
....................    }
.................... 
....................    if (sign)
05538:  BTFSS  xF7.1
0553A:  BRA    5572
....................       result = -1*result;
0553C:  MOVLB  6
0553E:  CLRF   x2F
05540:  CLRF   x2E
05542:  MOVLW  80
05544:  MOVWF  x2D
05546:  MOVLW  7F
05548:  MOVWF  x2C
0554A:  MOVFF  5F6,633
0554E:  MOVFF  5F5,632
05552:  MOVFF  5F4,631
05556:  MOVFF  5F3,630
0555A:  MOVLB  0
0555C:  CALL   0A44
05560:  MOVFF  03,5F6
05564:  MOVFF  02,5F5
05568:  MOVFF  01,5F4
0556C:  MOVFF  00,5F3
05570:  MOVLB  5
....................       
....................    if(endptr)
05572:  MOVF   xED,W
05574:  IORWF  xEE,W
05576:  BZ    55A6
....................    {
....................       if (ptr) {
05578:  MOVF   xF9,F
0557A:  BZ    5594
....................          ptr--;
0557C:  DECF   xF9,F
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
0557E:  MOVFF  5EE,FEA
05582:  MOVFF  5ED,FE9
05586:  MOVF   xF9,W
05588:  ADDWF  xEB,W
0558A:  MOVWF  FEF
0558C:  MOVLW  00
0558E:  ADDWFC xEC,W
05590:  MOVWF  FEC
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
05592:  BRA    55A6
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
05594:  MOVFF  5EE,FEA
05598:  MOVFF  5ED,FE9
0559C:  MOVFF  5EC,FEC
055A0:  MOVF   FED,F
055A2:  MOVFF  5EB,FEF
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
055A6:  MOVFF  5F3,00
055AA:  MOVFF  5F4,01
055AE:  MOVFF  5F5,02
055B2:  MOVFF  5F6,03
055B6:  MOVLB  0
055B8:  RETURN 0
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
*
043AC:  MOVLB  6
043AE:  CLRF   x08
043B0:  CLRF   x07
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
043B2:  MOVLW  30
043B4:  MOVWF  x0A
043B6:  MOVLW  31
043B8:  MOVWF  x0B
043BA:  MOVLW  32
043BC:  MOVWF  x0C
043BE:  MOVLW  33
043C0:  MOVWF  x0D
043C2:  MOVLW  34
043C4:  MOVWF  x0E
043C6:  MOVLW  35
043C8:  MOVWF  x0F
043CA:  MOVLW  36
043CC:  MOVWF  x10
043CE:  MOVLW  37
043D0:  MOVWF  x11
043D2:  MOVLW  38
043D4:  MOVWF  x12
043D6:  MOVLW  39
043D8:  MOVWF  x13
043DA:  MOVLW  61
043DC:  MOVWF  x14
043DE:  MOVLW  62
043E0:  MOVWF  x15
043E2:  MOVLW  63
043E4:  MOVWF  x16
043E6:  MOVLW  64
043E8:  MOVWF  x17
043EA:  MOVLW  65
043EC:  MOVWF  x18
043EE:  MOVLW  66
043F0:  MOVWF  x19
043F2:  MOVLW  67
043F4:  MOVWF  x1A
043F6:  MOVLW  68
043F8:  MOVWF  x1B
043FA:  MOVLW  69
043FC:  MOVWF  x1C
043FE:  MOVLW  6A
04400:  MOVWF  x1D
04402:  MOVLW  6B
04404:  MOVWF  x1E
04406:  MOVLW  6C
04408:  MOVWF  x1F
0440A:  MOVLW  6D
0440C:  MOVWF  x20
0440E:  MOVLW  6E
04410:  MOVWF  x21
04412:  MOVLW  6F
04414:  MOVWF  x22
04416:  MOVLW  70
04418:  MOVWF  x23
0441A:  MOVLW  71
0441C:  MOVWF  x24
0441E:  MOVLW  73
04420:  MOVWF  x25
04422:  MOVLW  74
04424:  MOVWF  x26
04426:  MOVLW  75
04428:  MOVWF  x27
0442A:  MOVLW  76
0442C:  MOVWF  x28
0442E:  MOVLW  77
04430:  MOVWF  x29
04432:  MOVLW  78
04434:  MOVWF  x2A
04436:  MOVLW  79
04438:  MOVWF  x2B
0443A:  MOVLW  7A
0443C:  MOVWF  x2C
0443E:  CLRF   x2D
....................    for(sc=s;isspace(*sc);++sc);
04440:  MOVFF  5FD,602
04444:  MOVFF  5FC,601
04448:  MOVFF  602,FEA
0444C:  MOVFF  601,FE9
04450:  MOVF   FEF,W
04452:  SUBLW  20
04454:  BNZ   445E
04456:  INCF   x01,F
04458:  BTFSC  FD8.2
0445A:  INCF   x02,F
0445C:  BRA    4448
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
0445E:  MOVFF  602,03
04462:  MOVFF  601,FE9
04466:  MOVFF  03,FEA
0446A:  MOVF   FEF,W
0446C:  SUBLW  2D
0446E:  BZ    447E
04470:  MOVFF  602,FEA
04474:  MOVFF  601,FE9
04478:  MOVF   FEF,W
0447A:  SUBLW  2B
0447C:  BNZ   4490
0447E:  MOVFF  602,FEA
04482:  MOVF   x01,W
04484:  INCF   x01,F
04486:  BTFSC  FD8.2
04488:  INCF   x02,F
0448A:  MOVWF  FE9
0448C:  MOVF   FEF,W
0448E:  BRA    4492
04490:  MOVLW  2B
04492:  MOVWF  x09
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
04494:  MOVF   x09,W
04496:  SUBLW  2D
04498:  BZ    44AE
0449A:  BTFSC  x00.7
0449C:  BRA    44AE
0449E:  DECFSZ x00,W
044A0:  BRA    44A4
044A2:  BRA    44AE
044A4:  BTFSC  x00.7
044A6:  BRA    44B2
044A8:  MOVF   x00,W
044AA:  SUBLW  24
044AC:  BC    44B2
....................    goto StrtoulGO;
044AE:  BRA    46BA
044B0:  BRA    45AA
.................... 
....................    else if (base)
044B2:  MOVF   x00,F
044B4:  BZ    4542
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
044B6:  MOVF   x00,W
044B8:  SUBLW  10
044BA:  BNZ   44F6
044BC:  MOVFF  602,FEA
044C0:  MOVFF  601,FE9
044C4:  MOVF   FEF,W
044C6:  SUBLW  30
044C8:  BNZ   44F6
044CA:  MOVLW  01
044CC:  ADDWF  x01,W
044CE:  MOVWF  FE9
044D0:  MOVLW  00
044D2:  ADDWFC x02,W
044D4:  MOVWF  FEA
044D6:  MOVF   FEF,W
044D8:  SUBLW  78
044DA:  BZ    44EE
044DC:  MOVLW  01
044DE:  ADDWF  x01,W
044E0:  MOVWF  FE9
044E2:  MOVLW  00
044E4:  ADDWFC x02,W
044E6:  MOVWF  FEA
044E8:  MOVF   FEF,W
044EA:  SUBLW  58
044EC:  BNZ   44F6
....................          sc+=2;
044EE:  MOVLW  02
044F0:  ADDWF  x01,F
044F2:  MOVLW  00
044F4:  ADDWFC x02,F
....................       if(base==8 && *sc =='0')
044F6:  MOVF   x00,W
044F8:  SUBLW  08
044FA:  BNZ   4512
044FC:  MOVFF  602,FEA
04500:  MOVFF  601,FE9
04504:  MOVF   FEF,W
04506:  SUBLW  30
04508:  BNZ   4512
....................          sc+=1;
0450A:  MOVLW  01
0450C:  ADDWF  x01,F
0450E:  MOVLW  00
04510:  ADDWFC x02,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
04512:  MOVF   x00,W
04514:  SUBLW  02
04516:  BNZ   4540
04518:  MOVFF  602,FEA
0451C:  MOVFF  601,FE9
04520:  MOVF   FEF,W
04522:  SUBLW  30
04524:  BNZ   4540
04526:  MOVLW  01
04528:  ADDWF  x01,W
0452A:  MOVWF  FE9
0452C:  MOVLW  00
0452E:  ADDWFC x02,W
04530:  MOVWF  FEA
04532:  MOVF   FEF,W
04534:  SUBLW  62
04536:  BNZ   4540
....................          sc+=2;
04538:  MOVLW  02
0453A:  ADDWF  x01,F
0453C:  MOVLW  00
0453E:  ADDWFC x02,F
.................... 
....................    }
04540:  BRA    45AA
....................    else if(*sc!='0') // base is 0, find base
04542:  MOVFF  602,FEA
04546:  MOVFF  601,FE9
0454A:  MOVF   FEF,W
0454C:  SUBLW  30
0454E:  BZ    4556
....................       base=10;
04550:  MOVLW  0A
04552:  MOVWF  x00
04554:  BRA    45AA
....................    else if (sc[1]=='x' || sc[1]=='X')
04556:  MOVLW  01
04558:  ADDWF  x01,W
0455A:  MOVWF  FE9
0455C:  MOVLW  00
0455E:  ADDWFC x02,W
04560:  MOVWF  FEA
04562:  MOVF   FEF,W
04564:  SUBLW  78
04566:  BZ    457A
04568:  MOVLW  01
0456A:  ADDWF  x01,W
0456C:  MOVWF  FE9
0456E:  MOVLW  00
04570:  ADDWFC x02,W
04572:  MOVWF  FEA
04574:  MOVF   FEF,W
04576:  SUBLW  58
04578:  BNZ   4588
....................       base =16,sc+=2;
0457A:  MOVLW  10
0457C:  MOVWF  x00
0457E:  MOVLW  02
04580:  ADDWF  x01,F
04582:  MOVLW  00
04584:  ADDWFC x02,F
04586:  BRA    45AA
....................    else if(sc[1]=='b')
04588:  MOVLW  01
0458A:  ADDWF  x01,W
0458C:  MOVWF  FE9
0458E:  MOVLW  00
04590:  ADDWFC x02,W
04592:  MOVWF  FEA
04594:  MOVF   FEF,W
04596:  SUBLW  62
04598:  BNZ   45A6
....................       base=2,sc+=2;
0459A:  MOVLW  02
0459C:  MOVWF  x00
0459E:  ADDWF  x01,F
045A0:  MOVLW  00
045A2:  ADDWFC x02,F
045A4:  BRA    45AA
....................    else
....................       base=8;
045A6:  MOVLW  08
045A8:  MOVWF  x00
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
045AA:  MOVFF  602,604
045AE:  MOVFF  601,603
045B2:  MOVFF  602,FEA
045B6:  MOVFF  601,FE9
045BA:  MOVF   FEF,W
045BC:  SUBLW  30
045BE:  BNZ   45C8
045C0:  INCF   x01,F
045C2:  BTFSC  FD8.2
045C4:  INCF   x02,F
045C6:  BRA    45B2
....................    sd=memchr(digits,tolower(*sc),base);
045C8:  MOVFF  602,03
045CC:  MOVFF  601,FE9
045D0:  MOVFF  03,FEA
045D4:  MOVFF  FEF,62E
045D8:  MOVF   x2E,W
045DA:  SUBLW  40
045DC:  BC    45EA
045DE:  MOVF   x2E,W
045E0:  SUBLW  5A
045E2:  BNC   45EA
045E4:  MOVF   x2E,W
045E6:  IORLW  20
045E8:  BRA    45EC
045EA:  MOVF   x2E,W
045EC:  MOVWF  x2E
045EE:  MOVLW  06
045F0:  MOVWF  x30
045F2:  MOVLW  0A
045F4:  MOVWF  x2F
045F6:  MOVFF  62E,631
045FA:  CLRF   x33
045FC:  MOVFF  600,632
04600:  BTFSC  x32.7
04602:  DECF   x33,F
04604:  MOVLB  0
04606:  RCALL  430C
04608:  MOVFF  02,606
0460C:  MOVFF  01,605
....................    for(; sd!=0; )
04610:  MOVLB  6
04612:  MOVF   x05,F
04614:  BNZ   461A
04616:  MOVF   x06,F
04618:  BZ    46AE
....................    {
....................       x=x*base+(int16)(sd-digits);
0461A:  CLRF   03
0461C:  MOVF   x00,W
0461E:  MOVWF  00
04620:  BTFSC  FE8.7
04622:  DECF   03,F
04624:  MOVWF  x2E
04626:  MOVFF  03,62F
0462A:  MOVFF  608,631
0462E:  MOVFF  607,630
04632:  MOVFF  03,633
04636:  MOVWF  x32
04638:  MOVLB  0
0463A:  BRA    4356
0463C:  MOVFF  01,62E
04640:  MOVLW  0A
04642:  MOVLB  6
04644:  SUBWF  x05,W
04646:  MOVWF  00
04648:  MOVLW  06
0464A:  SUBWFB x06,W
0464C:  MOVWF  03
0464E:  MOVF   00,W
04650:  ADDWF  01,W
04652:  MOVWF  01
04654:  MOVF   02,W
04656:  ADDWFC 03,F
04658:  MOVFF  01,607
0465C:  MOVFF  03,608
....................       ++sc;
04660:  INCF   x01,F
04662:  BTFSC  FD8.2
04664:  INCF   x02,F
....................       sd=memchr(digits,tolower(*sc),base);
04666:  MOVFF  602,FEA
0466A:  MOVFF  601,FE9
0466E:  MOVFF  FEF,62E
04672:  MOVF   x2E,W
04674:  SUBLW  40
04676:  BC    4684
04678:  MOVF   x2E,W
0467A:  SUBLW  5A
0467C:  BNC   4684
0467E:  MOVF   x2E,W
04680:  IORLW  20
04682:  BRA    4686
04684:  MOVF   x2E,W
04686:  MOVWF  x2E
04688:  MOVLW  06
0468A:  MOVWF  x30
0468C:  MOVLW  0A
0468E:  MOVWF  x2F
04690:  MOVFF  62E,631
04694:  CLRF   x33
04696:  MOVFF  600,632
0469A:  BTFSC  x32.7
0469C:  DECF   x33,F
0469E:  MOVLB  0
046A0:  RCALL  430C
046A2:  MOVFF  02,606
046A6:  MOVFF  01,605
046AA:  BRA    4610
046AC:  MOVLB  6
....................    }
....................    if(s1==sc)
046AE:  MOVF   x01,W
046B0:  SUBWF  x03,W
046B2:  BNZ   46DE
046B4:  MOVF   x02,W
046B6:  SUBWF  x04,W
046B8:  BNZ   46DE
....................    {
....................    StrtoulGO:
....................       if (endptr)
046BA:  MOVLB  5
046BC:  MOVF   xFE,W
046BE:  IORWF  xFF,W
046C0:  BZ    46D4
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
046C2:  MOVFF  5FF,FEA
046C6:  MOVFF  5FE,FE9
046CA:  MOVFF  5FD,FEC
046CE:  MOVF   FED,F
046D0:  MOVFF  5FC,FEF
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
046D4:  MOVLW  00
046D6:  MOVWF  01
046D8:  MOVWF  02
046DA:  BRA    4704
046DC:  MOVLB  6
....................    }
....................    if (endptr)
046DE:  MOVLB  5
046E0:  MOVF   xFE,W
046E2:  IORWF  xFF,W
046E4:  BZ    46F8
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
046E6:  MOVFF  5FF,FEA
046EA:  MOVFF  5FE,FE9
046EE:  MOVFF  602,FEC
046F2:  MOVF   FED,F
046F4:  MOVFF  601,FEF
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
046F8:  MOVLB  6
046FA:  MOVFF  607,01
046FE:  MOVFF  608,02
04702:  MOVLB  5
04704:  MOVLB  0
04706:  RETURN 0
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... //!typedef enum sensorType {kmxp1000, kmxp2000}; // Magsensors
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2];
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = 
.................... {
....................    {0,1}, {0,1}, {0,1}, {0,1}, {0,1}, {0,1}, {0,1}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals;
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;    // adc raw count data
....................    float cosRaw;    // adc raw count data
....................    float sinCounts; // calibrated counts
....................    float cosCounts; // calibrated counts
....................    float p0;               // position in units of pole-pitch
....................    int8  npoles;           // number of poles passed
....................    float pReal;            // real position
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0},
....................    {0,0,0,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
*
003D2:  MOVLB  5
003D4:  CLRF   xDC
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
003D6:  CLRF   xDC
003D8:  MOVF   xDB,W
003DA:  SUBWF  xDC,W
003DC:  BC    0434
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
003DE:  MOVF   xDC,W
003E0:  ADDWF  xD9,W
003E2:  MOVWF  xDD
003E4:  MOVLW  00
003E6:  ADDWFC xDA,W
003E8:  MOVWF  xDE
003EA:  MOVF   xDC,W
003EC:  ADDWF  xD7,W
003EE:  MOVWF  01
003F0:  MOVLW  00
003F2:  ADDWFC xD8,W
003F4:  MOVWF  03
003F6:  MOVF   01,W
003F8:  MOVWF  FE9
003FA:  MOVFF  03,FEA
003FE:  MOVFF  FEF,5DF
00402:  BSF    F7F.7
00404:  MOVF   FF2,W
00406:  MOVWF  00
00408:  BCF    FF2.7
0040A:  MOVFF  5DE,F7A
0040E:  MOVFF  5DD,F79
00412:  MOVLW  31
00414:  MOVWF  F7B
00416:  MOVFF  5DF,F7C
0041A:  MOVLB  F
0041C:  MOVLW  55
0041E:  MOVWF  F81
00420:  MOVLW  AA
00422:  MOVWF  F81
00424:  BSF    F80.4
00426:  BTFSC  F80.4
00428:  BRA    0426
0042A:  MOVF   00,W
0042C:  IORWF  FF2,F
0042E:  MOVLB  5
00430:  INCF   xDC,F
00432:  BRA    03D8
....................    }
00434:  MOVLB  0
00436:  RETURN 0
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
*
00356:  MOVLB  5
00358:  CLRF   xDC
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
0035A:  CLRF   xDC
0035C:  MOVF   xDB,W
0035E:  SUBWF  xDC,W
00360:  BC    03A4
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
00362:  MOVF   xDC,W
00364:  ADDWF  xD7,W
00366:  MOVWF  01
00368:  MOVLW  00
0036A:  ADDWFC xD8,W
0036C:  MOVWF  03
0036E:  MOVF   01,W
00370:  MOVWF  FE9
00372:  MOVFF  03,FEA
00376:  MOVF   xDC,W
00378:  ADDWF  xD9,W
0037A:  MOVWF  xDF
0037C:  MOVLW  00
0037E:  ADDWFC xDA,W
00380:  MOVWF  xE0
00382:  BSF    F7F.7
00384:  MOVFF  FF2,5E1
00388:  BCF    FF2.7
0038A:  MOVFF  5E0,F7A
0038E:  MOVFF  5DF,F79
00392:  MOVLW  31
00394:  MOVWF  F7B
00396:  BSF    F80.0
00398:  MOVF   F7C,W
0039A:  BTFSC  xE1.7
0039C:  BSF    FF2.7
0039E:  MOVWF  FEF
003A0:  INCF   xDC,F
003A2:  BRA    035C
....................    }
003A4:  MOVLB  0
003A6:  RETURN 0
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
*
00438:  MOVLB  5
0043A:  CLRF   xD8
0043C:  MOVLW  20
0043E:  MOVWF  xD7
00440:  CLRF   xDA
00442:  CLRF   xD9
00444:  MOVLW  80
00446:  MOVWF  xDB
00448:  MOVLB  0
0044A:  RCALL  03D2
....................    delay_ms(1);
0044C:  MOVLW  01
0044E:  MOVLB  5
00450:  MOVWF  xDA
00452:  MOVLB  0
00454:  RCALL  03A8
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
00456:  MOVLB  5
00458:  CLRF   xD8
0045A:  MOVLW  60
0045C:  MOVWF  xD7
0045E:  CLRF   xDA
00460:  MOVLW  80
00462:  MOVWF  xD9
00464:  MOVLW  02
00466:  MOVWF  xDB
00468:  MOVLB  0
0046A:  RCALL  03D2
....................    delay_ms(1);
0046C:  MOVLW  01
0046E:  MOVLB  5
00470:  MOVWF  xDA
00472:  MOVLB  0
00474:  RCALL  03A8
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
00476:  MOVLB  5
00478:  CLRF   xD8
0047A:  MOVLW  61
0047C:  MOVWF  xD7
0047E:  CLRF   xDA
00480:  MOVLW  90
00482:  MOVWF  xD9
00484:  MOVLW  02
00486:  MOVWF  xDB
00488:  MOVLB  0
0048A:  RCALL  03D2
....................    delay_ms(1);
0048C:  MOVLW  01
0048E:  MOVLB  5
00490:  MOVWF  xDA
00492:  MOVLB  0
00494:  RCALL  03A8
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
00496:  MOVLB  5
00498:  CLRF   xD8
0049A:  MOVLW  62
0049C:  MOVWF  xD7
0049E:  CLRF   xDA
004A0:  MOVLW  A0
004A2:  MOVWF  xD9
004A4:  MOVLW  20
004A6:  MOVWF  xDB
004A8:  MOVLB  0
004AA:  RCALL  03D2
....................    delay_ms(1);
004AC:  MOVLW  01
004AE:  MOVLB  5
004B0:  MOVWF  xDA
004B2:  MOVLB  0
004B4:  RCALL  03A8
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
004B6:  MOVLB  5
004B8:  CLRF   xD8
004BA:  MOVLW  82
004BC:  MOVWF  xD7
004BE:  CLRF   xDA
004C0:  MOVLW  C0
004C2:  MOVWF  xD9
004C4:  MOVLW  30
004C6:  MOVWF  xDB
004C8:  MOVLB  0
004CA:  RCALL  03D2
....................    delay_ms(1);
004CC:  MOVLW  01
004CE:  MOVLB  5
004D0:  MOVWF  xDA
004D2:  MOVLB  0
004D4:  RCALL  03A8
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
004D6:  MOVLB  5
004D8:  CLRF   xD8
004DA:  MOVLW  B2
004DC:  MOVWF  xD7
004DE:  CLRF   xDA
004E0:  MOVLW  F0
004E2:  MOVWF  xD9
004E4:  MOVLW  38
004E6:  MOVWF  xDB
004E8:  MOVLB  0
004EA:  RCALL  03D2
....................    delay_ms(1);
004EC:  MOVLW  01
004EE:  MOVLB  5
004F0:  MOVWF  xDA
004F2:  MOVLB  0
004F4:  RCALL  03A8
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
004F6:  MOVLB  5
004F8:  CLRF   xD8
004FA:  MOVLW  F2
004FC:  MOVWF  xD7
004FE:  MOVLW  01
00500:  MOVWF  xDA
00502:  MOVLW  40
00504:  MOVWF  xD9
00506:  MOVLW  01
00508:  MOVWF  xDB
0050A:  MOVLB  0
0050C:  RCALL  03D2
....................    delay_ms(1);
0050E:  MOVLW  01
00510:  MOVLB  5
00512:  MOVWF  xDA
00514:  MOVLB  0
00516:  RCALL  03A8
00518:  GOTO   05E8 (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
0051C:  MOVLB  5
0051E:  CLRF   xD8
00520:  MOVLW  20
00522:  MOVWF  xD7
00524:  CLRF   xDA
00526:  CLRF   xD9
00528:  MOVLW  80
0052A:  MOVWF  xDB
0052C:  MOVLB  0
0052E:  RCALL  0356
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
00530:  MOVLB  5
00532:  CLRF   xD8
00534:  MOVLW  60
00536:  MOVWF  xD7
00538:  CLRF   xDA
0053A:  MOVLW  80
0053C:  MOVWF  xD9
0053E:  MOVLW  02
00540:  MOVWF  xDB
00542:  MOVLB  0
00544:  RCALL  0356
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
00546:  MOVLB  5
00548:  CLRF   xD8
0054A:  MOVLW  61
0054C:  MOVWF  xD7
0054E:  CLRF   xDA
00550:  MOVLW  90
00552:  MOVWF  xD9
00554:  MOVLW  02
00556:  MOVWF  xDB
00558:  MOVLB  0
0055A:  RCALL  0356
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
0055C:  MOVLB  5
0055E:  CLRF   xD8
00560:  MOVLW  62
00562:  MOVWF  xD7
00564:  CLRF   xDA
00566:  MOVLW  A0
00568:  MOVWF  xD9
0056A:  MOVLW  20
0056C:  MOVWF  xDB
0056E:  MOVLB  0
00570:  RCALL  0356
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
00572:  MOVLB  5
00574:  CLRF   xD8
00576:  MOVLW  82
00578:  MOVWF  xD7
0057A:  CLRF   xDA
0057C:  MOVLW  C0
0057E:  MOVWF  xD9
00580:  MOVLW  30
00582:  MOVWF  xDB
00584:  MOVLB  0
00586:  RCALL  0356
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
00588:  MOVLB  5
0058A:  CLRF   xD8
0058C:  MOVLW  B2
0058E:  MOVWF  xD7
00590:  CLRF   xDA
00592:  MOVLW  F0
00594:  MOVWF  xD9
00596:  MOVLW  38
00598:  MOVWF  xDB
0059A:  MOVLB  0
0059C:  RCALL  0356
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
0059E:  MOVLB  5
005A0:  CLRF   xD8
005A2:  MOVLW  F2
005A4:  MOVWF  xD7
005A6:  MOVLW  01
005A8:  MOVWF  xDA
005AA:  MOVLW  40
005AC:  MOVWF  xD9
005AE:  MOVLW  01
005B0:  MOVWF  xDB
005B2:  MOVLB  0
005B4:  RCALL  0356
005B6:  GOTO   05EC (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
005BA:  MOVLB  5
005BC:  CLRF   xD8
005BE:  MOVLW  F2
005C0:  MOVWF  xD7
005C2:  MOVLW  01
005C4:  MOVWF  xDA
005C6:  MOVLW  40
005C8:  MOVWF  xD9
005CA:  MOVLW  01
005CC:  MOVWF  xDB
005CE:  MOVLB  0
005D0:  RCALL  0356
....................    delay_ms(1);
005D2:  MOVLW  01
005D4:  MOVLB  5
005D6:  MOVWF  xDA
005D8:  MOVLB  0
005DA:  RCALL  03A8
....................    if (paramsValid != isValid)
005DC:  MOVF   xF2,W
005DE:  SUBLW  AA
005E0:  BZ    05EA
....................    {
....................       paramsValid = isValid;
005E2:  MOVLW  AA
005E4:  MOVWF  xF2
....................       params_save_to_ee(); // saves the base parameters on first boot
005E6:  BRA    0438
....................    }
005E8:  BRA    05EC
....................    else
....................    {
....................       params_load_from_ee();
005EA:  BRA    051C
....................    }
005EC:  GOTO   75CE (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <monitor.h>
.................... #ifndef monitor
.................... #define monitor
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
....................    output_b(portB_reset);
....................    output_c(portC_reset);
....................    output_d(portD_reset);
....................    output_e(portE_reset);
....................    
....................    port_a_pullups(portA_pullups);
....................    port_b_pullups(portB_pullups);
....................    port_c_pullups(portC_pullups);
....................    port_d_pullups(portD_pullups);
....................    port_e_pullups(portE_pullups);
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... //!typedef enum sensorType {kmxp1000, kmxp2000}; // Magsensors
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2];
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = 
.................... {
....................    {0,1}, {0,1}, {0,1}, {0,1}, {0,1}, {0,1}, {0,1}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals;
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;    // adc raw count data
....................    float cosRaw;    // adc raw count data
....................    float sinCounts; // calibrated counts
....................    float cosCounts; // calibrated counts
....................    float p0;               // position in units of pole-pitch
....................    int8  npoles;           // number of poles passed
....................    float pReal;            // real position
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0},
....................    {0,0,0,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <ADS1220.h>
.................... #ifndef ADS1220
.................... #define ADS1220
.................... 
.................... /*****************************************************************************/
.................... /* SET UP PORTS FOR USE WITH DRIVER                                          */
.................... /*****************************************************************************/
.................... #define _CS0  PIN_D5 // chip select pins 
.................... #define _CS1  PIN_D6
.................... #define _CS2  PIN_D7
.................... #define _CS3  PIN_B0
.................... 
.................... #pin_select SCK2=PIN_B1
.................... #pin_select SDI2=PIN_B2
.................... #pin_select SDO2=PIN_B3
.................... #use spi(MASTER, SPI2, BAUD=1000000, MODE=1, STREAM=SPI_mon)
*
00190:  MOVLB  E
00192:  MOVF   x8D,W
00194:  MOVFF  645,E8D
00198:  RRCF   x90,W
0019A:  BNC   0198
0019C:  MOVF   x8D,W
0019E:  MOVWF  03
001A0:  MOVFF  644,E8D
001A4:  RRCF   x90,W
001A6:  BNC   01A4
001A8:  MOVF   x8D,W
001AA:  MOVWF  02
001AC:  MOVFF  643,E8D
001B0:  RRCF   x90,W
001B2:  BNC   01B0
001B4:  MOVF   x8D,W
001B6:  MOVWF  01
001B8:  MOVFF  642,E8D
001BC:  RRCF   x90,W
001BE:  BNC   01BC
001C0:  MOVFF  E8D,00
001C4:  MOVLB  0
001C6:  RETURN 0
*
012C8:  CLRF   03
012CA:  MOVLB  E
012CC:  MOVF   x8D,W
012CE:  MOVFF  5E7,E8D
012D2:  RRCF   x90,W
012D4:  BNC   12D2
012D6:  MOVF   x8D,W
012D8:  MOVWF  02
012DA:  MOVFF  5E6,E8D
012DE:  RRCF   x90,W
012E0:  BNC   12DE
012E2:  MOVF   x8D,W
012E4:  MOVWF  01
012E6:  MOVFF  5E5,E8D
012EA:  RRCF   x90,W
012EC:  BNC   12EA
012EE:  MOVFF  E8D,00
012F2:  MOVLB  0
012F4:  GOTO   1316 (RETURN)
.................... 
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* REGISTER DEFINITIONS                                                      */
.................... /*****************************************************************************/
.................... typedef enum {reg0 = 0x00,reg1 = 0x04 ,reg2 = 0x08, reg3 = 0x0C}adsReg;
.................... 
.................... //REGISTER 0 OPTIONS
.................... 
.................... #define IPp0n1 0x00
.................... #define IPp0n2 0x10
.................... #define IPp0n3 0x20
.................... #define IPp1n2 0x30
.................... #define IPp1n3 0x40
.................... #define IPp2n3 0x50
.................... #define IPp1n0 0x60
.................... #define IPp3n2 0x70
.................... #define IPp0nVss 0x80
.................... #define IPp1nVss 0x90
.................... #define IPp2nVss 0xA0
.................... #define IPp3nVss 0xB0
.................... #define IPVrpVrn 0xC0
.................... #define IPVddVss 0xD0
.................... #define IPhalfRail 0xE0
.................... 
.................... #define g1 0x00
.................... #define g2 0x02
.................... #define g4 0x04
.................... #define g8 0x06
.................... #define g16 0x08
.................... #define g32 0x0A
.................... #define g64 0x0C
.................... #define g128 0x0E
.................... 
.................... #define PGAenabled 0x00
.................... #define PGAbypass 0x01
.................... 
.................... //REGISTER 1 OPTIONS
.................... 
.................... #define DRn20 0x00
.................... #define DRn45 0x20
.................... #define DRn90 0x40
.................... #define DRn175 0x60
.................... #define DRn330 0x80
.................... #define DRn600 0xA0
.................... #define DRn1000 0xC0
.................... 
.................... #define MDnormal 0x00
.................... #define MDduty 0x80
.................... #define MDturbo 0x10
.................... 
.................... #define CMsingle 0x00
.................... #define CMcont 0x40
.................... 
.................... #define TSdisable 0x00
.................... #define TSenable 0x20
.................... 
.................... #define BCSoff 0x00
.................... #define BCSon 0x01
.................... 
.................... //REGISTER 2 OPTIONS
.................... 
.................... #define REFinternal 0x00
.................... #define REFp0n0 0x40
.................... #define REFp1n1 0x80
.................... #define REFVddVss 0xC0
.................... 
.................... #define FIRoff 0x00
.................... #define FIR5060 0x10
.................... #define FIR50 0x20
.................... #define FIR60 0x30
.................... 
.................... #define PSWopen 0x00
.................... #define PSWstart 0x08
.................... 
.................... #define Ioff 0x00
.................... #define Iu10 0x01
.................... #define Iu50 0x02
.................... #define Iu100 0x03
.................... #define Iu250 0x04
.................... #define Iu500 0x05
.................... #define Iu1000 0x06
.................... #define Iu1500 0x07  
.................... 
.................... //REGISTER 3 OPTIONS
.................... 
.................... #define I1disabled 0x00
.................... #define I1a0p1 0x20
.................... #define I1a1 0x40
.................... #define I1a2 0x60
.................... #define I1a3n1 0x80
.................... #define I1p0 0xA0
.................... #define I1n0 0xC0
.................... 
.................... #define I2disabled 0x00
.................... #define I2a0p1 0x04
.................... #define I2a1 0x08
.................... #define I2a2 0x0A
.................... #define I2a3n1 0x10
.................... #define I2p0 0x14
.................... #define I2n0 0x18
.................... 
.................... #define drdyPin 0x00
.................... #define doutPin 0x20
.................... 
.................... // REGISTER CONGIGURATIONS FOR THIS APP
.................... #define reg0config IPp1n2|g16|PGAenabled // 0x3A//
.................... #define reg1config DRn20|MDturbo|CMsingle|TSDisable|BCSoff //0x00
.................... #define reg2config REFinternal|FIR60|PSWopen|Ioff //0x30
.................... #define reg3config I1disabled|I2disabled|drdyPin //0x00
.................... 
.................... //COMMANDS
.................... #define ADSreset 0x06
.................... #define ADSstart 0x08
.................... #define ADSpowerDn 0x02
.................... #define ADSreadData 0x10
.................... #define ADSreadReg 0x20
.................... #define ADSwriteReg 0x40
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* DESELECT ALL ADCs                                                         */
.................... /*****************************************************************************/
.................... void ads_deselect_all()
.................... {
....................    output_high(_CS0); // deselect all chip select pins
*
00136:  MOVLW  1F
00138:  MOVWF  F8A
0013A:  BSF    F85.5
....................    output_high(_CS1);
0013C:  MOVWF  F8A
0013E:  BSF    F85.6
....................    output_high(_CS2);
00140:  MOVWF  F8A
00142:  BSF    F85.7
....................    output_high(_CS3);
00144:  MOVLW  C4
00146:  MOVWF  F88
00148:  BSF    F83.0
0014A:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT DESIRED ADC                                                        */
.................... /*****************************************************************************/
.................... void ads_select_ch(int8 ch)
.................... {
....................    ads_deselect_all();
*
005F0:  RCALL  0136
....................    switch(ch)
005F2:  MOVLB  5
005F4:  MOVF   xE7,W
005F6:  XORLW  00
005F8:  MOVLB  0
005FA:  BZ    0606
005FC:  XORLW  01
005FE:  BZ    060E
00600:  XORLW  03
00602:  BZ    0616
00604:  BRA    061E
....................    {
....................       case 0:
....................          output_low(_CS0);
00606:  MOVLW  1F
00608:  MOVWF  F8A
0060A:  BCF    F85.5
....................       break; 
0060C:  BRA    0632
....................       case 1:
....................          output_low(_CS1);
0060E:  MOVLW  1F
00610:  MOVWF  F8A
00612:  BCF    F85.6
....................       break;   
00614:  BRA    0632
....................       case 2:
....................          output_low(_CS2);
00616:  MOVLW  1F
00618:  MOVWF  F8A
0061A:  BCF    F85.7
....................       break;   
0061C:  BRA    0632
....................       default: // select all
....................          output_low(_CS0);
0061E:  MOVLW  1F
00620:  MOVWF  F8A
00622:  BCF    F85.5
....................          output_low(_CS1);
00624:  MOVWF  F8A
00626:  BCF    F85.6
....................          output_low(_CS2);
00628:  MOVWF  F8A
0062A:  BCF    F85.7
....................          output_low(_CS3);
0062C:  MOVLW  C4
0062E:  MOVWF  F88
00630:  BCF    F83.0
....................       break;             
....................    }
00632:  GOTO   063C (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT ADC BLOCK (2 ADCs/BLOCK)                                           */
.................... /*****************************************************************************/
.................... void ads_select_block(int8 block)
.................... {
....................    ads_deselect_all();
*
0014C:  RCALL  0136
....................    switch(block)
0014E:  MOVLB  6
00150:  MOVF   x42,W
00152:  XORLW  00
00154:  MOVLB  0
00156:  BZ    015E
00158:  XORLW  01
0015A:  BZ    016A
0015C:  BRA    0178
....................    {
....................       case 0:
....................          output_low(_CS0);
0015E:  MOVLW  1F
00160:  MOVWF  F8A
00162:  BCF    F85.5
....................          output_low(_CS1);
00164:  MOVWF  F8A
00166:  BCF    F85.6
....................       break; 
00168:  BRA    018C
....................       case 1:
....................          output_low(_CS2);
0016A:  MOVLW  1F
0016C:  MOVWF  F8A
0016E:  BCF    F85.7
....................          output_low(_CS3);
00170:  MOVLW  C4
00172:  MOVWF  F88
00174:  BCF    F83.0
....................       break;   
00176:  BRA    018C
....................       default: // select all
....................          output_low(_CS0);
00178:  MOVLW  1F
0017A:  MOVWF  F8A
0017C:  BCF    F85.5
....................          output_low(_CS1);
0017E:  MOVWF  F8A
00180:  BCF    F85.6
....................          output_low(_CS2);
00182:  MOVWF  F8A
00184:  BCF    F85.7
....................          output_low(_CS3);
00186:  MOVLW  C4
00188:  MOVWF  F88
0018A:  BCF    F83.0
....................       break;             
....................    }
0018C:  GOTO   01CE (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE                                                    */
.................... /*****************************************************************************/
.................... void ads_write_command(int8 ch, unsigned int8 command)
.................... {
....................    ads_select_ch(ch);
*
00636:  MOVFF  5E5,5E7
0063A:  BRA    05F0
0063C:  CLRF   19
0063E:  BTFSC  FF2.7
00640:  BSF    19.7
00642:  BCF    FF2.7
....................    spi_xfer(SPI_mon, command);
00644:  MOVLB  6
00646:  CLRF   x45
00648:  CLRF   x44
0064A:  CLRF   x43
0064C:  MOVFF  5E6,642
00650:  MOVLB  0
00652:  RCALL  0190
00654:  BTFSC  19.7
00656:  BSF    FF2.7
00658:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO A BLOCK OF ADCs                                 */
.................... /*****************************************************************************/
.................... void ads_write_command_block(int8 block, unsigned int8 command)
.................... {
....................    ads_select_block(block);
*
001C8:  MOVFF  640,642
001CC:  BRA    014C
....................    spi_xfer(SPI_mon, command);
001CE:  MOVLB  6
001D0:  CLRF   x45
001D2:  CLRF   x44
001D4:  CLRF   x43
001D6:  MOVFF  641,642
001DA:  MOVLB  0
001DC:  RCALL  0190
001DE:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE REGISTER DATA                                                       */
.................... /*****************************************************************************/
.................... void ads_write_reg(int8 ch, adsReg regID, int8 data)
*
00680:  MOVLB  5
00682:  MOVF   xE2,W
00684:  IORLW  40
00686:  MOVWF  xE4
.................... {
....................    unsigned int8 command = ADSwriteReg | regID | 0; // 0 is numbytes to write-1
....................    ads_write_command(ch, command);
00688:  MOVFF  5E1,5E5
0068C:  MOVFF  5E4,5E6
00690:  MOVLB  0
00692:  RCALL  0636
00694:  CLRF   19
00696:  BTFSC  FF2.7
00698:  BSF    19.7
0069A:  BCF    FF2.7
....................    spi_xfer(SPI_mon, data);
0069C:  MOVLB  6
0069E:  CLRF   x45
006A0:  CLRF   x44
006A2:  CLRF   x43
006A4:  MOVFF  5E3,642
006A8:  MOVLB  0
006AA:  RCALL  0190
006AC:  BTFSC  19.7
006AE:  BSF    FF2.7
....................    ads_deselect_all();
006B0:  RCALL  0136
006B2:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER REGISTER                                                    */
.................... /*****************************************************************************/
.................... unsigned int8 ads_read_reg(int8 ch, adsReg regID)
.................... {
....................    unsigned int8 command = ADSreadReg | regID | 0;
....................    ads_write_command(ch, command);
....................    unsigned int8 data = spi_xfer(SPI_mon, 0, 8);
....................    ads_deselect_all();
....................    return data;
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* READ DATA                                                                 */
.................... /*****************************************************************************/
.................... unsigned int32 ads_read_data(int8 ch)
.................... {
....................    ads_write_command(ch, ADSreadData);
*
012F8:  MOVFF  5E0,5E5
012FC:  MOVLW  10
012FE:  MOVLB  5
01300:  MOVWF  xE6
01302:  MOVLB  0
01304:  CALL   0636
....................    unsigned int32 data = spi_xfer(SPI_mon, 0, 24);
01308:  MOVLB  5
0130A:  CLRF   xE8
0130C:  CLRF   xE7
0130E:  CLRF   xE6
01310:  CLRF   xE5
01312:  MOVLB  0
01314:  BRA    12C8
01316:  MOVF   01,W
01318:  MOVFF  03,5E4
0131C:  MOVFF  02,5E3
01320:  MOVFF  01,5E2
01324:  MOVFF  00,5E1
....................    ads_deselect_all();
01328:  CALL   0136
....................    return data;
0132C:  MOVFF  5E1,00
01330:  MOVFF  5E2,01
01334:  MOVFF  5E3,02
01338:  MOVFF  5E4,03
0133C:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE A CHANNEL                                                      */
.................... /*****************************************************************************/
.................... 
.................... void ADS1220init(int8 ch, rc0=reg0config, rc1=reg1config, rc2=reg2config, rc3=reg3config)
.................... {
....................    ads_write_command(ch, ADSreset);   //reset the device
*
006B4:  MOVFF  5DC,5E5
006B8:  MOVLW  06
006BA:  MOVLB  5
006BC:  MOVWF  xE6
006BE:  MOVLB  0
006C0:  RCALL  0636
....................    delay_us(100);                    
006C2:  MOVLW  64
006C4:  MOVLB  5
006C6:  MOVWF  xE1
006C8:  MOVLB  0
006CA:  BRA    065A
....................    ads_write_reg(ch, reg0, rc0);   //send default configurations
006CC:  MOVFF  5DC,5E1
006D0:  MOVLB  5
006D2:  CLRF   xE2
006D4:  MOVFF  5DD,5E3
006D8:  MOVLB  0
006DA:  RCALL  0680
....................    ads_write_reg(ch, reg1, rc1);
006DC:  MOVFF  5DC,5E1
006E0:  MOVLW  04
006E2:  MOVLB  5
006E4:  MOVWF  xE2
006E6:  MOVFF  5DE,5E3
006EA:  MOVLB  0
006EC:  RCALL  0680
....................    ads_write_reg(ch, reg2, rc2);
006EE:  MOVFF  5DC,5E1
006F2:  MOVLW  08
006F4:  MOVLB  5
006F6:  MOVWF  xE2
006F8:  MOVFF  5DF,5E3
006FC:  MOVLB  0
006FE:  RCALL  0680
....................    ads_write_reg(ch, reg3, rc3);  
00700:  MOVFF  5DC,5E1
00704:  MOVLW  0C
00706:  MOVLB  5
00708:  MOVWF  xE2
0070A:  MOVFF  5E0,5E3
0070E:  MOVLB  0
00710:  RCALL  0680
00712:  GOTO   074E (RETURN)
.................... }
.................... #endif 
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
*
01D56:  MOVLB  6
01D58:  BCF    x2B.0
....................    y = x;
01D5A:  MOVFF  61F,624
01D5E:  MOVFF  61E,623
01D62:  MOVFF  61D,622
01D66:  MOVFF  61C,621
.................... 
....................    if (x < 0)
01D6A:  MOVFF  61F,62F
01D6E:  MOVFF  61E,62E
01D72:  MOVFF  61D,62D
01D76:  MOVFF  61C,62C
01D7A:  CLRF   x33
01D7C:  CLRF   x32
01D7E:  CLRF   x31
01D80:  CLRF   x30
01D82:  MOVLB  0
01D84:  CALL   1376
01D88:  BNC   1D96
....................    {
....................       s = 1;
01D8A:  MOVLB  6
01D8C:  BSF    x2B.0
....................       y = -y;
01D8E:  MOVF   x22,W
01D90:  XORLW  80
01D92:  MOVWF  x22
01D94:  MOVLB  0
....................    }
.................... 
....................    if (y <= 32768.0)
01D96:  MOVFF  624,62F
01D9A:  MOVFF  623,62E
01D9E:  MOVFF  622,62D
01DA2:  MOVFF  621,62C
01DA6:  MOVLB  6
01DA8:  CLRF   x33
01DAA:  CLRF   x32
01DAC:  CLRF   x31
01DAE:  MOVLW  8E
01DB0:  MOVWF  x30
01DB2:  MOVLB  0
01DB4:  CALL   1376
01DB8:  BC    1DBC
01DBA:  BNZ   1DEC
....................       res = (float32)(unsigned int16)y;
01DBC:  MOVFF  624,62F
01DC0:  MOVFF  623,62E
01DC4:  MOVFF  622,62D
01DC8:  MOVFF  621,62C
01DCC:  RCALL  1D1A
01DCE:  MOVFF  02,631
01DD2:  MOVFF  01,630
01DD6:  CALL   0A0E
01DDA:  MOVFF  03,628
01DDE:  MOVFF  02,627
01DE2:  MOVFF  01,626
01DE6:  MOVFF  00,625
01DEA:  BRA    1F8E
.................... 
....................  else if (y < 10000000.0)
01DEC:  MOVFF  624,62F
01DF0:  MOVFF  623,62E
01DF4:  MOVFF  622,62D
01DF8:  MOVFF  621,62C
01DFC:  MOVLW  80
01DFE:  MOVLB  6
01E00:  MOVWF  x33
01E02:  MOVLW  96
01E04:  MOVWF  x32
01E06:  MOVLW  18
01E08:  MOVWF  x31
01E0A:  MOVLW  96
01E0C:  MOVWF  x30
01E0E:  MOVLB  0
01E10:  CALL   1376
01E14:  BTFSS  FD8.0
01E16:  BRA    1F7E
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
01E18:  MOVFF  624,62F
01E1C:  MOVFF  623,62E
01E20:  MOVFF  622,62D
01E24:  MOVFF  621,62C
01E28:  MOVLB  6
01E2A:  CLRF   x33
01E2C:  CLRF   x32
01E2E:  CLRF   x31
01E30:  MOVLW  70
01E32:  MOVWF  x30
01E34:  MOVLB  0
01E36:  CALL   0A44
01E3A:  MOVFF  03,62F
01E3E:  MOVFF  02,62E
01E42:  MOVFF  01,62D
01E46:  MOVFF  00,62C
01E4A:  RCALL  1D1A
01E4C:  MOVFF  02,62A
01E50:  MOVFF  01,629
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
01E54:  MOVFF  624,62F
01E58:  MOVFF  623,62E
01E5C:  MOVFF  622,62D
01E60:  MOVFF  621,62C
01E64:  MOVLB  6
01E66:  CLRF   x33
01E68:  CLRF   x32
01E6A:  CLRF   x31
01E6C:  MOVLW  70
01E6E:  MOVWF  x30
01E70:  MOVLB  0
01E72:  CALL   0A44
01E76:  MOVFF  03,62F
01E7A:  MOVFF  02,62E
01E7E:  MOVFF  01,62D
01E82:  MOVFF  00,62C
01E86:  MOVFF  62A,631
01E8A:  MOVFF  629,630
01E8E:  CALL   0A0E
01E92:  BSF    FD8.1
01E94:  MOVFF  62F,633
01E98:  MOVFF  62E,632
01E9C:  MOVFF  62D,631
01EA0:  MOVFF  62C,630
01EA4:  MOVFF  03,637
01EA8:  MOVFF  02,636
01EAC:  MOVFF  01,635
01EB0:  MOVFF  00,634
01EB4:  CALL   0B3A
01EB8:  MOVLB  6
01EBA:  CLRF   x2F
01EBC:  CLRF   x2E
01EBE:  CLRF   x2D
01EC0:  MOVLW  8E
01EC2:  MOVWF  x2C
01EC4:  MOVFF  03,633
01EC8:  MOVFF  02,632
01ECC:  MOVFF  01,631
01ED0:  MOVFF  00,630
01ED4:  MOVLB  0
01ED6:  CALL   0A44
01EDA:  MOVFF  03,624
01EDE:  MOVFF  02,623
01EE2:  MOVFF  01,622
01EE6:  MOVFF  00,621
....................       res = 32768.0*(float32)l;
01EEA:  MOVFF  62A,631
01EEE:  MOVFF  629,630
01EF2:  CALL   0A0E
01EF6:  MOVLB  6
01EF8:  CLRF   x2F
01EFA:  CLRF   x2E
01EFC:  CLRF   x2D
01EFE:  MOVLW  8E
01F00:  MOVWF  x2C
01F02:  MOVFF  03,633
01F06:  MOVFF  02,632
01F0A:  MOVFF  01,631
01F0E:  MOVFF  00,630
01F12:  MOVLB  0
01F14:  CALL   0A44
01F18:  MOVFF  03,628
01F1C:  MOVFF  02,627
01F20:  MOVFF  01,626
01F24:  MOVFF  00,625
....................       res += (float32)(unsigned int16)y;
01F28:  MOVFF  624,62F
01F2C:  MOVFF  623,62E
01F30:  MOVFF  622,62D
01F34:  MOVFF  621,62C
01F38:  RCALL  1D1A
01F3A:  MOVFF  02,631
01F3E:  MOVFF  01,630
01F42:  CALL   0A0E
01F46:  BCF    FD8.1
01F48:  MOVFF  628,633
01F4C:  MOVFF  627,632
01F50:  MOVFF  626,631
01F54:  MOVFF  625,630
01F58:  MOVFF  03,637
01F5C:  MOVFF  02,636
01F60:  MOVFF  01,635
01F64:  MOVFF  00,634
01F68:  CALL   0B3A
01F6C:  MOVFF  03,628
01F70:  MOVFF  02,627
01F74:  MOVFF  01,626
01F78:  MOVFF  00,625
....................    }
01F7C:  BRA    1F8E
.................... 
....................  else
....................   res = y;
01F7E:  MOVFF  624,628
01F82:  MOVFF  623,627
01F86:  MOVFF  622,626
01F8A:  MOVFF  621,625
.................... 
....................  y = y - (float32)(unsigned int16)y;
01F8E:  MOVFF  624,62F
01F92:  MOVFF  623,62E
01F96:  MOVFF  622,62D
01F9A:  MOVFF  621,62C
01F9E:  RCALL  1D1A
01FA0:  MOVFF  02,631
01FA4:  MOVFF  01,630
01FA8:  CALL   0A0E
01FAC:  BSF    FD8.1
01FAE:  MOVFF  624,633
01FB2:  MOVFF  623,632
01FB6:  MOVFF  622,631
01FBA:  MOVFF  621,630
01FBE:  MOVFF  03,637
01FC2:  MOVFF  02,636
01FC6:  MOVFF  01,635
01FCA:  MOVFF  00,634
01FCE:  CALL   0B3A
01FD2:  MOVFF  03,624
01FD6:  MOVFF  02,623
01FDA:  MOVFF  01,622
01FDE:  MOVFF  00,621
.................... 
....................  if (s)
01FE2:  MOVLB  6
01FE4:  BTFSS  x2B.0
01FE6:  BRA    1FEE
....................   res = -res;
01FE8:  MOVF   x26,W
01FEA:  XORLW  80
01FEC:  MOVWF  x26
.................... 
....................  if (y != 0)
01FEE:  MOVFF  624,62F
01FF2:  MOVFF  623,62E
01FF6:  MOVFF  622,62D
01FFA:  MOVFF  621,62C
01FFE:  CLRF   x33
02000:  CLRF   x32
02002:  CLRF   x31
02004:  CLRF   x30
02006:  MOVLB  0
02008:  CALL   1376
0200C:  BZ    2086
....................  {
....................   if (s == 1 && n == 0)
0200E:  MOVLB  6
02010:  BTFSS  x2B.0
02012:  BRA    204C
02014:  MOVF   x20,F
02016:  BNZ   204C
....................    res -= 1.0;
02018:  BSF    FD8.1
0201A:  MOVFF  628,633
0201E:  MOVFF  627,632
02022:  MOVFF  626,631
02026:  MOVFF  625,630
0202A:  CLRF   x37
0202C:  CLRF   x36
0202E:  CLRF   x35
02030:  MOVLW  7F
02032:  MOVWF  x34
02034:  MOVLB  0
02036:  CALL   0B3A
0203A:  MOVFF  03,628
0203E:  MOVFF  02,627
02042:  MOVFF  01,626
02046:  MOVFF  00,625
0204A:  MOVLB  6
.................... 
....................   if (s == 0 && n == 1)
0204C:  BTFSC  x2B.0
0204E:  BRA    2088
02050:  DECFSZ x20,W
02052:  BRA    2088
....................    res += 1.0;
02054:  BCF    FD8.1
02056:  MOVFF  628,633
0205A:  MOVFF  627,632
0205E:  MOVFF  626,631
02062:  MOVFF  625,630
02066:  CLRF   x37
02068:  CLRF   x36
0206A:  CLRF   x35
0206C:  MOVLW  7F
0206E:  MOVWF  x34
02070:  MOVLB  0
02072:  CALL   0B3A
02076:  MOVFF  03,628
0207A:  MOVFF  02,627
0207E:  MOVFF  01,626
02082:  MOVFF  00,625
02086:  MOVLB  6
....................  }
....................  if (x == 0)
02088:  MOVFF  61F,62F
0208C:  MOVFF  61E,62E
02090:  MOVFF  61D,62D
02094:  MOVFF  61C,62C
02098:  CLRF   x33
0209A:  CLRF   x32
0209C:  CLRF   x31
0209E:  CLRF   x30
020A0:  MOVLB  0
020A2:  CALL   1376
020A6:  BNZ   20B4
....................     res = 0;
020A8:  MOVLB  6
020AA:  CLRF   x28
020AC:  CLRF   x27
020AE:  CLRF   x26
020B0:  CLRF   x25
020B2:  MOVLB  0
.................... 
....................  return (res);
020B4:  MOVFF  625,00
020B8:  MOVFF  626,01
020BC:  MOVFF  627,02
020C0:  MOVFF  628,03
020C4:  RETURN 0
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
*
020E4:  MOVFF  61B,61F
020E8:  MOVFF  61A,61E
020EC:  MOVFF  619,61D
020F0:  MOVFF  618,61C
020F4:  MOVLB  6
020F6:  CLRF   x20
020F8:  MOVLB  0
020FA:  RCALL  1D56
020FC:  GOTO   2208 (RETURN)
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
*
020C6:  MOVFF  61B,61F
020CA:  MOVFF  61A,61E
020CE:  MOVFF  619,61D
020D2:  MOVFF  618,61C
020D6:  MOVLW  01
020D8:  MOVLB  6
020DA:  MOVWF  x20
020DC:  MOVLB  0
020DE:  RCALL  1D56
020E0:  GOTO   21C0 (RETURN)
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
*
02100:  MOVFF  60F,62F
02104:  MOVFF  60E,62E
02108:  MOVFF  60D,62D
0210C:  MOVFF  60C,62C
02110:  MOVLB  6
02112:  CLRF   x33
02114:  CLRF   x32
02116:  CLRF   x31
02118:  CLRF   x30
0211A:  MOVLB  0
0211C:  CALL   1376
02120:  BTFSC  FD8.2
02122:  BRA    2264
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
02124:  MOVFF  60B,628
02128:  MOVFF  60A,627
0212C:  MOVFF  609,626
02130:  MOVFF  608,625
02134:  MOVFF  60F,62C
02138:  MOVFF  60E,62B
0213C:  MOVFF  60D,62A
02140:  MOVFF  60C,629
02144:  CALL   13F0
02148:  MOVFF  03,617
0214C:  MOVFF  02,616
02150:  MOVFF  01,615
02154:  MOVFF  00,614
02158:  MOVFF  03,62F
0215C:  MOVFF  02,62E
02160:  MOVFF  01,62D
02164:  MOVFF  00,62C
02168:  MOVLB  6
0216A:  CLRF   x33
0216C:  CLRF   x32
0216E:  CLRF   x31
02170:  CLRF   x30
02172:  MOVLB  0
02174:  CALL   1376
02178:  BNC   21C2
0217A:  MOVFF  60B,628
0217E:  MOVFF  60A,627
02182:  MOVFF  609,626
02186:  MOVFF  608,625
0218A:  MOVFF  60F,62C
0218E:  MOVFF  60E,62B
02192:  MOVFF  60D,62A
02196:  MOVFF  60C,629
0219A:  CALL   13F0
0219E:  MOVFF  03,617
021A2:  MOVFF  02,616
021A6:  MOVFF  01,615
021AA:  MOVFF  00,614
021AE:  MOVFF  03,61B
021B2:  MOVFF  02,61A
021B6:  MOVFF  01,619
021BA:  MOVFF  00,618
021BE:  BRA    20C6
021C0:  BRA    2208
021C2:  MOVFF  60B,628
021C6:  MOVFF  60A,627
021CA:  MOVFF  609,626
021CE:  MOVFF  608,625
021D2:  MOVFF  60F,62C
021D6:  MOVFF  60E,62B
021DA:  MOVFF  60D,62A
021DE:  MOVFF  60C,629
021E2:  CALL   13F0
021E6:  MOVFF  03,617
021EA:  MOVFF  02,616
021EE:  MOVFF  01,615
021F2:  MOVFF  00,614
021F6:  MOVFF  03,61B
021FA:  MOVFF  02,61A
021FE:  MOVFF  01,619
02202:  MOVFF  00,618
02206:  BRA    20E4
02208:  MOVFF  03,613
0220C:  MOVFF  02,612
02210:  MOVFF  01,611
02214:  MOVFF  00,610
....................       return(x-(i*y));
02218:  MOVFF  613,62F
0221C:  MOVFF  612,62E
02220:  MOVFF  611,62D
02224:  MOVFF  610,62C
02228:  MOVFF  60F,633
0222C:  MOVFF  60E,632
02230:  MOVFF  60D,631
02234:  MOVFF  60C,630
02238:  CALL   0A44
0223C:  BSF    FD8.1
0223E:  MOVFF  60B,633
02242:  MOVFF  60A,632
02246:  MOVFF  609,631
0224A:  MOVFF  608,630
0224E:  MOVFF  03,637
02252:  MOVFF  02,636
02256:  MOVFF  01,635
0225A:  MOVFF  00,634
0225E:  CALL   0B3A
02262:  BRA    2264
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
02264:  RETURN 0
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
*
02646:  MOVFF  60F,62F
0264A:  MOVFF  60E,62E
0264E:  MOVFF  60D,62D
02652:  MOVFF  60C,62C
02656:  MOVLW  3B
02658:  MOVLB  6
0265A:  MOVWF  x33
0265C:  MOVLW  AA
0265E:  MOVWF  x32
02660:  MOVLW  38
02662:  MOVWF  x31
02664:  MOVLW  7F
02666:  MOVWF  x30
02668:  MOVLB  0
0266A:  CALL   0A44
0266E:  MOVFF  03,62F
02672:  MOVFF  02,62E
02676:  MOVFF  01,62D
0267A:  MOVFF  00,62C
0267E:  CALL   1D1A
02682:  MOVFF  01,61C
....................    s = 0;
02686:  MOVLB  6
02688:  BCF    x1D.0
....................    y = x;
0268A:  MOVFF  60F,613
0268E:  MOVFF  60E,612
02692:  MOVFF  60D,611
02696:  MOVFF  60C,610
.................... 
....................    if (x < 0)
0269A:  MOVFF  60F,62F
0269E:  MOVFF  60E,62E
026A2:  MOVFF  60D,62D
026A6:  MOVFF  60C,62C
026AA:  CLRF   x33
026AC:  CLRF   x32
026AE:  CLRF   x31
026B0:  CLRF   x30
026B2:  MOVLB  0
026B4:  CALL   1376
026B8:  BNC   26C8
....................    {
....................       s = 1;
026BA:  MOVLB  6
026BC:  BSF    x1D.0
....................       n = -n;
026BE:  NEGF   x1C
....................       y = -y;
026C0:  MOVF   x11,W
026C2:  XORLW  80
026C4:  MOVWF  x11
026C6:  MOVLB  0
....................    }
.................... 
....................    res = 0.0;
026C8:  MOVLB  6
026CA:  CLRF   x17
026CC:  CLRF   x16
026CE:  CLRF   x15
026D0:  CLRF   x14
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
026D2:  MOVLW  06
026D4:  MOVWF  x1F
026D6:  MOVLW  14
026D8:  MOVFF  61F,FEA
026DC:  MOVWF  FE9
026DE:  MOVLW  7F
026E0:  ADDWF  x1C,W
026E2:  MOVWF  FEF
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
026E4:  MOVFF  613,62F
026E8:  MOVFF  612,62E
026EC:  MOVFF  611,62D
026F0:  MOVFF  610,62C
026F4:  MOVLW  3B
026F6:  MOVWF  x33
026F8:  MOVLW  AA
026FA:  MOVWF  x32
026FC:  MOVLW  38
026FE:  MOVWF  x31
02700:  MOVLW  7F
02702:  MOVWF  x30
02704:  MOVLB  0
02706:  CALL   0A44
0270A:  MOVFF  03,621
0270E:  MOVFF  02,620
02712:  MOVFF  01,61F
02716:  MOVFF  00,61E
0271A:  MOVLB  6
0271C:  CLRF   x23
0271E:  MOVFF  61C,622
02722:  BTFSC  x22.7
02724:  DECF   x23,F
02726:  MOVLB  0
02728:  RCALL  2266
0272A:  BSF    FD8.1
0272C:  MOVFF  621,633
02730:  MOVFF  620,632
02734:  MOVFF  61F,631
02738:  MOVFF  61E,630
0273C:  MOVFF  03,637
02740:  MOVFF  02,636
02744:  MOVFF  01,635
02748:  MOVFF  00,634
0274C:  CALL   0B3A
02750:  MOVFF  03,613
02754:  MOVFF  02,612
02758:  MOVFF  01,611
0275C:  MOVFF  00,610
.................... 
....................    r = pe[0]*y + pe[1];
02760:  MOVLW  7C
02762:  MOVLB  6
02764:  MOVWF  x2F
02766:  MOVLW  88
02768:  MOVWF  x2E
0276A:  MOVLW  59
0276C:  MOVWF  x2D
0276E:  MOVLW  72
02770:  MOVWF  x2C
02772:  MOVFF  613,633
02776:  MOVFF  612,632
0277A:  MOVFF  611,631
0277E:  MOVFF  610,630
02782:  MOVLB  0
02784:  CALL   0A44
02788:  MOVFF  03,621
0278C:  MOVFF  02,620
02790:  MOVFF  01,61F
02794:  MOVFF  00,61E
02798:  BCF    FD8.1
0279A:  MOVFF  03,633
0279E:  MOVFF  02,632
027A2:  MOVFF  01,631
027A6:  MOVFF  00,630
027AA:  MOVLW  E0
027AC:  MOVLB  6
027AE:  MOVWF  x37
027B0:  MOVLW  97
027B2:  MOVWF  x36
027B4:  MOVLW  26
027B6:  MOVWF  x35
027B8:  MOVLW  75
027BA:  MOVWF  x34
027BC:  MOVLB  0
027BE:  CALL   0B3A
027C2:  MOVFF  03,61B
027C6:  MOVFF  02,61A
027CA:  MOVFF  01,619
027CE:  MOVFF  00,618
....................    r = r*y + pe[2];
027D2:  MOVFF  61B,62F
027D6:  MOVFF  61A,62E
027DA:  MOVFF  619,62D
027DE:  MOVFF  618,62C
027E2:  MOVFF  613,633
027E6:  MOVFF  612,632
027EA:  MOVFF  611,631
027EE:  MOVFF  610,630
027F2:  CALL   0A44
027F6:  MOVFF  03,621
027FA:  MOVFF  02,620
027FE:  MOVFF  01,61F
02802:  MOVFF  00,61E
02806:  BCF    FD8.1
02808:  MOVFF  03,633
0280C:  MOVFF  02,632
02810:  MOVFF  01,631
02814:  MOVFF  00,630
02818:  MOVLW  C4
0281A:  MOVLB  6
0281C:  MOVWF  x37
0281E:  MOVLW  1D
02820:  MOVWF  x36
02822:  MOVLW  1E
02824:  MOVWF  x35
02826:  MOVLW  78
02828:  MOVWF  x34
0282A:  MOVLB  0
0282C:  CALL   0B3A
02830:  MOVFF  03,61B
02834:  MOVFF  02,61A
02838:  MOVFF  01,619
0283C:  MOVFF  00,618
....................    r = r*y + pe[3];
02840:  MOVFF  61B,62F
02844:  MOVFF  61A,62E
02848:  MOVFF  619,62D
0284C:  MOVFF  618,62C
02850:  MOVFF  613,633
02854:  MOVFF  612,632
02858:  MOVFF  611,631
0285C:  MOVFF  610,630
02860:  CALL   0A44
02864:  MOVFF  03,621
02868:  MOVFF  02,620
0286C:  MOVFF  01,61F
02870:  MOVFF  00,61E
02874:  BCF    FD8.1
02876:  MOVFF  03,633
0287A:  MOVFF  02,632
0287E:  MOVFF  01,631
02882:  MOVFF  00,630
02886:  MOVLW  5E
02888:  MOVLB  6
0288A:  MOVWF  x37
0288C:  MOVLW  50
0288E:  MOVWF  x36
02890:  MOVLW  63
02892:  MOVWF  x35
02894:  MOVLW  7A
02896:  MOVWF  x34
02898:  MOVLB  0
0289A:  CALL   0B3A
0289E:  MOVFF  03,61B
028A2:  MOVFF  02,61A
028A6:  MOVFF  01,619
028AA:  MOVFF  00,618
....................    r = r*y + pe[4];
028AE:  MOVFF  61B,62F
028B2:  MOVFF  61A,62E
028B6:  MOVFF  619,62D
028BA:  MOVFF  618,62C
028BE:  MOVFF  613,633
028C2:  MOVFF  612,632
028C6:  MOVFF  611,631
028CA:  MOVFF  610,630
028CE:  CALL   0A44
028D2:  MOVFF  03,621
028D6:  MOVFF  02,620
028DA:  MOVFF  01,61F
028DE:  MOVFF  00,61E
028E2:  BCF    FD8.1
028E4:  MOVFF  03,633
028E8:  MOVFF  02,632
028EC:  MOVFF  01,631
028F0:  MOVFF  00,630
028F4:  MOVLW  1A
028F6:  MOVLB  6
028F8:  MOVWF  x37
028FA:  MOVLW  FE
028FC:  MOVWF  x36
028FE:  MOVLW  75
02900:  MOVWF  x35
02902:  MOVLW  7C
02904:  MOVWF  x34
02906:  MOVLB  0
02908:  CALL   0B3A
0290C:  MOVFF  03,61B
02910:  MOVFF  02,61A
02914:  MOVFF  01,619
02918:  MOVFF  00,618
....................    r = r*y + pe[5];
0291C:  MOVFF  61B,62F
02920:  MOVFF  61A,62E
02924:  MOVFF  619,62D
02928:  MOVFF  618,62C
0292C:  MOVFF  613,633
02930:  MOVFF  612,632
02934:  MOVFF  611,631
02938:  MOVFF  610,630
0293C:  CALL   0A44
02940:  MOVFF  03,621
02944:  MOVFF  02,620
02948:  MOVFF  01,61F
0294C:  MOVFF  00,61E
02950:  BCF    FD8.1
02952:  MOVFF  03,633
02956:  MOVFF  02,632
0295A:  MOVFF  01,631
0295E:  MOVFF  00,630
02962:  MOVLW  18
02964:  MOVLB  6
02966:  MOVWF  x37
02968:  MOVLW  72
0296A:  MOVWF  x36
0296C:  MOVLW  31
0296E:  MOVWF  x35
02970:  MOVLW  7E
02972:  MOVWF  x34
02974:  MOVLB  0
02976:  CALL   0B3A
0297A:  MOVFF  03,61B
0297E:  MOVFF  02,61A
02982:  MOVFF  01,619
02986:  MOVFF  00,618
.................... 
....................    res = res*(1.0 + y*r);
0298A:  MOVFF  613,62F
0298E:  MOVFF  612,62E
02992:  MOVFF  611,62D
02996:  MOVFF  610,62C
0299A:  MOVFF  61B,633
0299E:  MOVFF  61A,632
029A2:  MOVFF  619,631
029A6:  MOVFF  618,630
029AA:  CALL   0A44
029AE:  BCF    FD8.1
029B0:  MOVLB  6
029B2:  CLRF   x33
029B4:  CLRF   x32
029B6:  CLRF   x31
029B8:  MOVLW  7F
029BA:  MOVWF  x30
029BC:  MOVFF  03,637
029C0:  MOVFF  02,636
029C4:  MOVFF  01,635
029C8:  MOVFF  00,634
029CC:  MOVLB  0
029CE:  CALL   0B3A
029D2:  MOVFF  617,62F
029D6:  MOVFF  616,62E
029DA:  MOVFF  615,62D
029DE:  MOVFF  614,62C
029E2:  MOVFF  03,633
029E6:  MOVFF  02,632
029EA:  MOVFF  01,631
029EE:  MOVFF  00,630
029F2:  CALL   0A44
029F6:  MOVFF  03,617
029FA:  MOVFF  02,616
029FE:  MOVFF  01,615
02A02:  MOVFF  00,614
.................... 
....................    if (s)
02A06:  MOVLB  6
02A08:  BTFSS  x1D.0
02A0A:  BRA    2A3E
....................       res = 1.0/res;
02A0C:  CLRF   x28
02A0E:  CLRF   x27
02A10:  CLRF   x26
02A12:  MOVLW  7F
02A14:  MOVWF  x25
02A16:  MOVFF  617,62C
02A1A:  MOVFF  616,62B
02A1E:  MOVFF  615,62A
02A22:  MOVFF  614,629
02A26:  MOVLB  0
02A28:  CALL   13F0
02A2C:  MOVFF  03,617
02A30:  MOVFF  02,616
02A34:  MOVFF  01,615
02A38:  MOVFF  00,614
02A3C:  MOVLB  6
....................    return(res);
02A3E:  MOVFF  614,00
02A42:  MOVFF  615,01
02A46:  MOVFF  616,02
02A4A:  MOVFF  617,03
02A4E:  MOVLB  0
02A50:  RETURN 0
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
*
022B6:  MOVFF  60F,613
022BA:  MOVFF  60E,612
022BE:  MOVFF  60D,611
022C2:  MOVFF  60C,610
.................... 
....................    if (y != 1.0)
022C6:  MOVFF  613,62F
022CA:  MOVFF  612,62E
022CE:  MOVFF  611,62D
022D2:  MOVFF  610,62C
022D6:  MOVLB  6
022D8:  CLRF   x33
022DA:  CLRF   x32
022DC:  CLRF   x31
022DE:  MOVLW  7F
022E0:  MOVWF  x30
022E2:  MOVLB  0
022E4:  CALL   1376
022E8:  BTFSC  FD8.2
022EA:  BRA    2628
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
022EC:  MOVLW  06
022EE:  MOVLB  6
022F0:  MOVWF  x22
022F2:  MOVLW  10
022F4:  MOVFF  622,FEA
022F8:  MOVWF  FE9
022FA:  MOVLW  7E
022FC:  MOVWF  FEF
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
022FE:  BSF    FD8.1
02300:  MOVFF  613,633
02304:  MOVFF  612,632
02308:  MOVFF  611,631
0230C:  MOVFF  610,630
02310:  CLRF   x37
02312:  CLRF   x36
02314:  CLRF   x35
02316:  MOVLW  7F
02318:  MOVWF  x34
0231A:  MOVLB  0
0231C:  CALL   0B3A
02320:  MOVFF  03,624
02324:  MOVFF  02,623
02328:  MOVFF  01,622
0232C:  MOVFF  00,621
02330:  BCF    FD8.1
02332:  MOVFF  613,633
02336:  MOVFF  612,632
0233A:  MOVFF  611,631
0233E:  MOVFF  610,630
02342:  MOVLB  6
02344:  CLRF   x37
02346:  CLRF   x36
02348:  CLRF   x35
0234A:  MOVLW  7F
0234C:  MOVWF  x34
0234E:  MOVLB  0
02350:  CALL   0B3A
02354:  MOVFF  624,628
02358:  MOVFF  623,627
0235C:  MOVFF  622,626
02360:  MOVFF  621,625
02364:  MOVFF  03,62C
02368:  MOVFF  02,62B
0236C:  MOVFF  01,62A
02370:  MOVFF  00,629
02374:  CALL   13F0
02378:  MOVFF  03,613
0237C:  MOVFF  02,612
02380:  MOVFF  01,611
02384:  MOVFF  00,610
.................... 
....................       y2=y*y;
02388:  MOVFF  613,62F
0238C:  MOVFF  612,62E
02390:  MOVFF  611,62D
02394:  MOVFF  610,62C
02398:  MOVFF  613,633
0239C:  MOVFF  612,632
023A0:  MOVFF  611,631
023A4:  MOVFF  610,630
023A8:  CALL   0A44
023AC:  MOVFF  03,61F
023B0:  MOVFF  02,61E
023B4:  MOVFF  01,61D
023B8:  MOVFF  00,61C
.................... 
....................       res = pl[0]*y2 + pl[1];
023BC:  MOVLW  99
023BE:  MOVLB  6
023C0:  MOVWF  x2F
023C2:  MOVLW  47
023C4:  MOVWF  x2E
023C6:  MOVLW  8A
023C8:  MOVWF  x2D
023CA:  MOVLW  7F
023CC:  MOVWF  x2C
023CE:  MOVFF  61F,633
023D2:  MOVFF  61E,632
023D6:  MOVFF  61D,631
023DA:  MOVFF  61C,630
023DE:  MOVLB  0
023E0:  CALL   0A44
023E4:  MOVFF  03,624
023E8:  MOVFF  02,623
023EC:  MOVFF  01,622
023F0:  MOVFF  00,621
023F4:  BCF    FD8.1
023F6:  MOVFF  03,633
023FA:  MOVFF  02,632
023FE:  MOVFF  01,631
02402:  MOVFF  00,630
02406:  MOVLB  6
02408:  CLRF   x37
0240A:  CLRF   x36
0240C:  CLRF   x35
0240E:  MOVLW  80
02410:  MOVWF  x34
02412:  MOVLB  0
02414:  CALL   0B3A
02418:  MOVFF  03,617
0241C:  MOVFF  02,616
02420:  MOVFF  01,615
02424:  MOVFF  00,614
.................... 
....................       r = ql[0]*y2 + ql[1];
02428:  MOVLW  4C
0242A:  MOVLB  6
0242C:  MOVWF  x2F
0242E:  MOVLW  F3
02430:  MOVWF  x2E
02432:  MOVLW  3A
02434:  MOVWF  x2D
02436:  MOVLW  7B
02438:  MOVWF  x2C
0243A:  MOVFF  61F,633
0243E:  MOVFF  61E,632
02442:  MOVFF  61D,631
02446:  MOVFF  61C,630
0244A:  MOVLB  0
0244C:  CALL   0A44
02450:  MOVFF  03,624
02454:  MOVFF  02,623
02458:  MOVFF  01,622
0245C:  MOVFF  00,621
02460:  BCF    FD8.1
02462:  MOVFF  03,633
02466:  MOVFF  02,632
0246A:  MOVFF  01,631
0246E:  MOVFF  00,630
02472:  MOVLW  2B
02474:  MOVLB  6
02476:  MOVWF  x37
02478:  MOVLW  9D
0247A:  MOVWF  x36
0247C:  MOVLW  DF
0247E:  MOVWF  x35
02480:  MOVLW  7E
02482:  MOVWF  x34
02484:  MOVLB  0
02486:  CALL   0B3A
0248A:  MOVFF  03,61B
0248E:  MOVFF  02,61A
02492:  MOVFF  01,619
02496:  MOVFF  00,618
....................       r = r*y2 + 1.0;
0249A:  MOVFF  61B,62F
0249E:  MOVFF  61A,62E
024A2:  MOVFF  619,62D
024A6:  MOVFF  618,62C
024AA:  MOVFF  61F,633
024AE:  MOVFF  61E,632
024B2:  MOVFF  61D,631
024B6:  MOVFF  61C,630
024BA:  CALL   0A44
024BE:  MOVFF  03,624
024C2:  MOVFF  02,623
024C6:  MOVFF  01,622
024CA:  MOVFF  00,621
024CE:  BCF    FD8.1
024D0:  MOVFF  03,633
024D4:  MOVFF  02,632
024D8:  MOVFF  01,631
024DC:  MOVFF  00,630
024E0:  MOVLB  6
024E2:  CLRF   x37
024E4:  CLRF   x36
024E6:  CLRF   x35
024E8:  MOVLW  7F
024EA:  MOVWF  x34
024EC:  MOVLB  0
024EE:  CALL   0B3A
024F2:  MOVFF  03,61B
024F6:  MOVFF  02,61A
024FA:  MOVFF  01,619
024FE:  MOVFF  00,618
.................... 
....................       res = y*res/r;
02502:  MOVFF  613,62F
02506:  MOVFF  612,62E
0250A:  MOVFF  611,62D
0250E:  MOVFF  610,62C
02512:  MOVFF  617,633
02516:  MOVFF  616,632
0251A:  MOVFF  615,631
0251E:  MOVFF  614,630
02522:  CALL   0A44
02526:  MOVFF  03,624
0252A:  MOVFF  02,623
0252E:  MOVFF  01,622
02532:  MOVFF  00,621
02536:  MOVFF  03,628
0253A:  MOVFF  02,627
0253E:  MOVFF  01,626
02542:  MOVFF  00,625
02546:  MOVFF  61B,62C
0254A:  MOVFF  61A,62B
0254E:  MOVFF  619,62A
02552:  MOVFF  618,629
02556:  CALL   13F0
0255A:  MOVFF  03,617
0255E:  MOVFF  02,616
02562:  MOVFF  01,615
02566:  MOVFF  00,614
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
0256A:  MOVLW  06
0256C:  MOVLB  6
0256E:  MOVWF  x22
02570:  MOVLW  0C
02572:  MOVFF  622,FEA
02576:  MOVWF  FE9
02578:  MOVLW  7E
0257A:  SUBWF  FEF,W
0257C:  MOVWF  x20
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
0257E:  BTFSS  x20.7
02580:  BRA    25AA
....................          r = -(float32)-n;
02582:  MOVLW  00
02584:  BSF    FD8.0
02586:  SUBFWB x20,W
02588:  CLRF   x23
0258A:  MOVWF  x22
0258C:  BTFSC  x22.7
0258E:  DECF   x23,F
02590:  MOVLB  0
02592:  RCALL  2266
02594:  MOVFF  00,618
02598:  MOVF   01,W
0259A:  XORLW  80
0259C:  MOVLB  6
0259E:  MOVWF  x19
025A0:  MOVFF  02,61A
025A4:  MOVFF  03,61B
025A8:  BRA    25CA
....................       else
....................          r = (float32)n;
025AA:  CLRF   x23
025AC:  MOVFF  620,622
025B0:  BTFSC  x22.7
025B2:  DECF   x23,F
025B4:  MOVLB  0
025B6:  RCALL  2266
025B8:  MOVFF  03,61B
025BC:  MOVFF  02,61A
025C0:  MOVFF  01,619
025C4:  MOVFF  00,618
025C8:  MOVLB  6
.................... 
....................       res += r*LN2;
025CA:  MOVFF  61B,62F
025CE:  MOVFF  61A,62E
025D2:  MOVFF  619,62D
025D6:  MOVFF  618,62C
025DA:  MOVLW  18
025DC:  MOVWF  x33
025DE:  MOVLW  72
025E0:  MOVWF  x32
025E2:  MOVLW  31
025E4:  MOVWF  x31
025E6:  MOVLW  7E
025E8:  MOVWF  x30
025EA:  MOVLB  0
025EC:  CALL   0A44
025F0:  BCF    FD8.1
025F2:  MOVFF  617,633
025F6:  MOVFF  616,632
025FA:  MOVFF  615,631
025FE:  MOVFF  614,630
02602:  MOVFF  03,637
02606:  MOVFF  02,636
0260A:  MOVFF  01,635
0260E:  MOVFF  00,634
02612:  CALL   0B3A
02616:  MOVFF  03,617
0261A:  MOVFF  02,616
0261E:  MOVFF  01,615
02622:  MOVFF  00,614
....................    }
02626:  BRA    2634
.................... 
....................    else
....................       res = 0.0;
02628:  MOVLB  6
0262A:  CLRF   x17
0262C:  CLRF   x16
0262E:  CLRF   x15
02630:  CLRF   x14
02632:  MOVLB  0
.................... 
....................    return(res);
02634:  MOVFF  614,00
02638:  MOVFF  615,01
0263C:  MOVFF  616,02
02640:  MOVFF  617,03
02644:  RETURN 0
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
*
02A52:  MOVFF  602,62F
02A56:  MOVFF  601,62E
02A5A:  MOVFF  600,62D
02A5E:  MOVFF  5FF,62C
02A62:  MOVLB  6
02A64:  CLRF   x33
02A66:  CLRF   x32
02A68:  CLRF   x31
02A6A:  CLRF   x30
02A6C:  MOVLB  0
02A6E:  CALL   1376
02A72:  BTFSS  FD8.0
02A74:  BRA    2C10
02A76:  MOVFF  606,60B
02A7A:  MOVFF  605,60A
02A7E:  MOVFF  604,609
02A82:  MOVFF  603,608
02A86:  MOVLB  6
02A88:  CLRF   x0F
02A8A:  CLRF   x0E
02A8C:  CLRF   x0D
02A8E:  MOVLW  7F
02A90:  MOVWF  x0C
02A92:  MOVLB  0
02A94:  CALL   2100
02A98:  MOVFF  03,60A
02A9C:  MOVFF  02,609
02AA0:  MOVFF  01,608
02AA4:  MOVFF  00,607
02AA8:  MOVFF  03,62F
02AAC:  MOVFF  02,62E
02AB0:  MOVFF  01,62D
02AB4:  MOVFF  00,62C
02AB8:  MOVLB  6
02ABA:  CLRF   x33
02ABC:  CLRF   x32
02ABE:  CLRF   x31
02AC0:  CLRF   x30
02AC2:  MOVLB  0
02AC4:  CALL   1376
02AC8:  BTFSS  FD8.2
02ACA:  BRA    2C10
....................       if(fmod(y, 2) == 0) {
02ACC:  MOVFF  606,60B
02AD0:  MOVFF  605,60A
02AD4:  MOVFF  604,609
02AD8:  MOVFF  603,608
02ADC:  MOVLB  6
02ADE:  CLRF   x0F
02AE0:  CLRF   x0E
02AE2:  CLRF   x0D
02AE4:  MOVLW  80
02AE6:  MOVWF  x0C
02AE8:  MOVLB  0
02AEA:  CALL   2100
02AEE:  MOVFF  03,60A
02AF2:  MOVFF  02,609
02AF6:  MOVFF  01,608
02AFA:  MOVFF  00,607
02AFE:  MOVFF  03,62F
02B02:  MOVFF  02,62E
02B06:  MOVFF  01,62D
02B0A:  MOVFF  00,62C
02B0E:  MOVLB  6
02B10:  CLRF   x33
02B12:  CLRF   x32
02B14:  CLRF   x31
02B16:  CLRF   x30
02B18:  MOVLB  0
02B1A:  CALL   1376
02B1E:  BNZ   2B96
....................          return (exp(log(-x) * y));
02B20:  MOVFF  5FF,60C
02B24:  MOVLB  6
02B26:  MOVF   x00,W
02B28:  XORLW  80
02B2A:  MOVWF  x08
02B2C:  MOVFF  602,60F
02B30:  MOVFF  601,60E
02B34:  MOVWF  x0D
02B36:  MOVLB  0
02B38:  CALL   22B6
02B3C:  MOVFF  03,60A
02B40:  MOVFF  02,609
02B44:  MOVFF  01,608
02B48:  MOVFF  00,607
02B4C:  MOVFF  03,62F
02B50:  MOVFF  02,62E
02B54:  MOVFF  01,62D
02B58:  MOVFF  00,62C
02B5C:  MOVFF  606,633
02B60:  MOVFF  605,632
02B64:  MOVFF  604,631
02B68:  MOVFF  603,630
02B6C:  CALL   0A44
02B70:  MOVFF  03,60A
02B74:  MOVFF  02,609
02B78:  MOVFF  01,608
02B7C:  MOVFF  00,607
02B80:  MOVFF  03,60F
02B84:  MOVFF  02,60E
02B88:  MOVFF  01,60D
02B8C:  MOVFF  00,60C
02B90:  RCALL  2646
02B92:  BRA    2D4E
....................       } else {
02B94:  BRA    2C0E
....................          return (-exp(log(-x) * y));
02B96:  MOVFF  5FF,60C
02B9A:  MOVLB  6
02B9C:  MOVF   x00,W
02B9E:  XORLW  80
02BA0:  MOVWF  x08
02BA2:  MOVFF  602,60F
02BA6:  MOVFF  601,60E
02BAA:  MOVWF  x0D
02BAC:  MOVLB  0
02BAE:  CALL   22B6
02BB2:  MOVFF  03,60A
02BB6:  MOVFF  02,609
02BBA:  MOVFF  01,608
02BBE:  MOVFF  00,607
02BC2:  MOVFF  03,62F
02BC6:  MOVFF  02,62E
02BCA:  MOVFF  01,62D
02BCE:  MOVFF  00,62C
02BD2:  MOVFF  606,633
02BD6:  MOVFF  605,632
02BDA:  MOVFF  604,631
02BDE:  MOVFF  603,630
02BE2:  CALL   0A44
02BE6:  MOVFF  03,60A
02BEA:  MOVFF  02,609
02BEE:  MOVFF  01,608
02BF2:  MOVFF  00,607
02BF6:  MOVFF  03,60F
02BFA:  MOVFF  02,60E
02BFE:  MOVFF  01,60D
02C02:  MOVFF  00,60C
02C06:  RCALL  2646
02C08:  MOVLW  80
02C0A:  XORWF  01,F
02C0C:  BRA    2D4E
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
02C0E:  BRA    2D4E
02C10:  MOVFF  602,62F
02C14:  MOVFF  601,62E
02C18:  MOVFF  600,62D
02C1C:  MOVFF  5FF,62C
02C20:  MOVLB  6
02C22:  CLRF   x33
02C24:  CLRF   x32
02C26:  CLRF   x31
02C28:  CLRF   x30
02C2A:  MOVLB  0
02C2C:  CALL   1376
02C30:  BNC   2C92
02C32:  MOVFF  606,60B
02C36:  MOVFF  605,60A
02C3A:  MOVFF  604,609
02C3E:  MOVFF  603,608
02C42:  MOVLB  6
02C44:  CLRF   x0F
02C46:  CLRF   x0E
02C48:  CLRF   x0D
02C4A:  MOVLW  7F
02C4C:  MOVWF  x0C
02C4E:  MOVLB  0
02C50:  CALL   2100
02C54:  MOVFF  03,60A
02C58:  MOVFF  02,609
02C5C:  MOVFF  01,608
02C60:  MOVFF  00,607
02C64:  MOVFF  03,62F
02C68:  MOVFF  02,62E
02C6C:  MOVFF  01,62D
02C70:  MOVFF  00,62C
02C74:  MOVLB  6
02C76:  CLRF   x33
02C78:  CLRF   x32
02C7A:  CLRF   x31
02C7C:  CLRF   x30
02C7E:  MOVLB  0
02C80:  CALL   1376
02C84:  BZ    2C92
....................       return 0;
02C86:  CLRF   00
02C88:  CLRF   01
02C8A:  CLRF   02
02C8C:  CLRF   03
02C8E:  BRA    2D4E
....................    } else {
02C90:  BRA    2D4E
....................       if(x != 0 || 0 >= y) {
02C92:  MOVFF  602,62F
02C96:  MOVFF  601,62E
02C9A:  MOVFF  600,62D
02C9E:  MOVFF  5FF,62C
02CA2:  MOVLB  6
02CA4:  CLRF   x33
02CA6:  CLRF   x32
02CA8:  CLRF   x31
02CAA:  CLRF   x30
02CAC:  MOVLB  0
02CAE:  CALL   1376
02CB2:  BNZ   2CD8
02CB4:  MOVFF  606,62F
02CB8:  MOVFF  605,62E
02CBC:  MOVFF  604,62D
02CC0:  MOVFF  603,62C
02CC4:  MOVLB  6
02CC6:  CLRF   x33
02CC8:  CLRF   x32
02CCA:  CLRF   x31
02CCC:  CLRF   x30
02CCE:  MOVLB  0
02CD0:  CALL   1376
02CD4:  BC    2CD8
02CD6:  BNZ   2D46
....................          return (exp(log(x) * y));
02CD8:  MOVFF  602,60F
02CDC:  MOVFF  601,60E
02CE0:  MOVFF  600,60D
02CE4:  MOVFF  5FF,60C
02CE8:  CALL   22B6
02CEC:  MOVFF  03,60A
02CF0:  MOVFF  02,609
02CF4:  MOVFF  01,608
02CF8:  MOVFF  00,607
02CFC:  MOVFF  03,62F
02D00:  MOVFF  02,62E
02D04:  MOVFF  01,62D
02D08:  MOVFF  00,62C
02D0C:  MOVFF  606,633
02D10:  MOVFF  605,632
02D14:  MOVFF  604,631
02D18:  MOVFF  603,630
02D1C:  CALL   0A44
02D20:  MOVFF  03,60A
02D24:  MOVFF  02,609
02D28:  MOVFF  01,608
02D2C:  MOVFF  00,607
02D30:  MOVFF  03,60F
02D34:  MOVFF  02,60E
02D38:  MOVFF  01,60D
02D3C:  MOVFF  00,60C
02D40:  RCALL  2646
02D42:  BRA    2D4E
....................       } else return 0;
02D44:  BRA    2D4E
02D46:  CLRF   00
02D48:  CLRF   01
02D4A:  CLRF   02
02D4C:  CLRF   03
....................    }
02D4E:  RETURN 0
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
*
0154E:  MOVLB  6
01550:  BCF    x1E.0
....................    flag = 0;
01552:  BCF    x1E.1
....................    y = x;
01554:  MOVFF  611,615
01558:  MOVFF  610,614
0155C:  MOVFF  60F,613
01560:  MOVFF  60E,612
.................... 
....................    if (x < 0)
01564:  MOVFF  611,62F
01568:  MOVFF  610,62E
0156C:  MOVFF  60F,62D
01570:  MOVFF  60E,62C
01574:  CLRF   x33
01576:  CLRF   x32
01578:  CLRF   x31
0157A:  CLRF   x30
0157C:  MOVLB  0
0157E:  RCALL  1376
01580:  BNC   158E
....................    {
....................       s = 1;
01582:  MOVLB  6
01584:  BSF    x1E.0
....................       y = -y;
01586:  MOVF   x13,W
01588:  XORLW  80
0158A:  MOVWF  x13
0158C:  MOVLB  0
....................    }
.................... 
....................    if (y > 1.0)
0158E:  MOVLB  6
01590:  CLRF   x2F
01592:  CLRF   x2E
01594:  CLRF   x2D
01596:  MOVLW  7F
01598:  MOVWF  x2C
0159A:  MOVFF  615,633
0159E:  MOVFF  614,632
015A2:  MOVFF  613,631
015A6:  MOVFF  612,630
015AA:  MOVLB  0
015AC:  RCALL  1376
015AE:  BNC   15E6
....................    {
....................       y = 1.0/y;
015B0:  MOVLB  6
015B2:  CLRF   x28
015B4:  CLRF   x27
015B6:  CLRF   x26
015B8:  MOVLW  7F
015BA:  MOVWF  x25
015BC:  MOVFF  615,62C
015C0:  MOVFF  614,62B
015C4:  MOVFF  613,62A
015C8:  MOVFF  612,629
015CC:  MOVLB  0
015CE:  RCALL  13F0
015D0:  MOVFF  03,615
015D4:  MOVFF  02,614
015D8:  MOVFF  01,613
015DC:  MOVFF  00,612
....................       flag = 1;
015E0:  MOVLB  6
015E2:  BSF    x1E.1
015E4:  MOVLB  0
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
015E6:  MOVLW  0A
015E8:  MOVLB  6
015EA:  MOVWF  x2F
015EC:  MOVLW  89
015EE:  MOVWF  x2E
015F0:  MOVLW  34
015F2:  MOVWF  x2D
015F4:  MOVLW  7C
015F6:  MOVWF  x2C
015F8:  MOVFF  615,633
015FC:  MOVFF  614,632
01600:  MOVFF  613,631
01604:  MOVFF  612,630
01608:  MOVLB  0
0160A:  CALL   0A44
0160E:  MOVFF  03,622
01612:  MOVFF  02,621
01616:  MOVFF  01,620
0161A:  MOVFF  00,61F
0161E:  MOVFF  03,62F
01622:  MOVFF  02,62E
01626:  MOVFF  01,62D
0162A:  MOVFF  00,62C
0162E:  MOVFF  615,633
01632:  MOVFF  614,632
01636:  MOVFF  613,631
0163A:  MOVFF  612,630
0163E:  CALL   0A44
01642:  MOVFF  03,622
01646:  MOVFF  02,621
0164A:  MOVFF  01,620
0164E:  MOVFF  00,61F
01652:  BCF    FD8.1
01654:  MOVFF  03,633
01658:  MOVFF  02,632
0165C:  MOVFF  01,631
01660:  MOVFF  00,630
01664:  MOVLW  7C
01666:  MOVLB  6
01668:  MOVWF  x37
0166A:  MOVLW  79
0166C:  MOVWF  x36
0166E:  MOVLW  35
01670:  MOVWF  x35
01672:  MOVLW  81
01674:  MOVWF  x34
01676:  MOVLB  0
01678:  CALL   0B3A
0167C:  MOVFF  03,619
01680:  MOVFF  02,618
01684:  MOVFF  01,617
01688:  MOVFF  00,616
....................    res = res*y*y + pat[2];
0168C:  MOVFF  619,62F
01690:  MOVFF  618,62E
01694:  MOVFF  617,62D
01698:  MOVFF  616,62C
0169C:  MOVFF  615,633
016A0:  MOVFF  614,632
016A4:  MOVFF  613,631
016A8:  MOVFF  612,630
016AC:  CALL   0A44
016B0:  MOVFF  03,622
016B4:  MOVFF  02,621
016B8:  MOVFF  01,620
016BC:  MOVFF  00,61F
016C0:  MOVFF  03,62F
016C4:  MOVFF  02,62E
016C8:  MOVFF  01,62D
016CC:  MOVFF  00,62C
016D0:  MOVFF  615,633
016D4:  MOVFF  614,632
016D8:  MOVFF  613,631
016DC:  MOVFF  612,630
016E0:  CALL   0A44
016E4:  MOVFF  03,622
016E8:  MOVFF  02,621
016EC:  MOVFF  01,620
016F0:  MOVFF  00,61F
016F4:  BCF    FD8.1
016F6:  MOVFF  03,633
016FA:  MOVFF  02,632
016FE:  MOVFF  01,631
01702:  MOVFF  00,630
01706:  MOVLW  3F
01708:  MOVLB  6
0170A:  MOVWF  x37
0170C:  MOVLW  02
0170E:  MOVWF  x36
01710:  MOVLW  33
01712:  MOVWF  x35
01714:  MOVLW  83
01716:  MOVWF  x34
01718:  MOVLB  0
0171A:  CALL   0B3A
0171E:  MOVFF  03,619
01722:  MOVFF  02,618
01726:  MOVFF  01,617
0172A:  MOVFF  00,616
....................    res = res*y*y + pat[3];
0172E:  MOVFF  619,62F
01732:  MOVFF  618,62E
01736:  MOVFF  617,62D
0173A:  MOVFF  616,62C
0173E:  MOVFF  615,633
01742:  MOVFF  614,632
01746:  MOVFF  613,631
0174A:  MOVFF  612,630
0174E:  CALL   0A44
01752:  MOVFF  03,622
01756:  MOVFF  02,621
0175A:  MOVFF  01,620
0175E:  MOVFF  00,61F
01762:  MOVFF  03,62F
01766:  MOVFF  02,62E
0176A:  MOVFF  01,62D
0176E:  MOVFF  00,62C
01772:  MOVFF  615,633
01776:  MOVFF  614,632
0177A:  MOVFF  613,631
0177E:  MOVFF  612,630
01782:  CALL   0A44
01786:  MOVFF  03,622
0178A:  MOVFF  02,621
0178E:  MOVFF  01,620
01792:  MOVFF  00,61F
01796:  BCF    FD8.1
01798:  MOVFF  03,633
0179C:  MOVFF  02,632
017A0:  MOVFF  01,631
017A4:  MOVFF  00,630
017A8:  MOVLW  33
017AA:  MOVLB  6
017AC:  MOVWF  x37
017AE:  MOVLW  8C
017B0:  MOVWF  x36
017B2:  MOVLW  1E
017B4:  MOVWF  x35
017B6:  MOVLW  83
017B8:  MOVWF  x34
017BA:  MOVLB  0
017BC:  CALL   0B3A
017C0:  MOVFF  03,619
017C4:  MOVFF  02,618
017C8:  MOVFF  01,617
017CC:  MOVFF  00,616
.................... 
....................    r = qat[0]*y*y + qat[1];
017D0:  MOVLB  6
017D2:  CLRF   x2F
017D4:  CLRF   x2E
017D6:  CLRF   x2D
017D8:  MOVLW  7F
017DA:  MOVWF  x2C
017DC:  MOVFF  615,633
017E0:  MOVFF  614,632
017E4:  MOVFF  613,631
017E8:  MOVFF  612,630
017EC:  MOVLB  0
017EE:  CALL   0A44
017F2:  MOVFF  03,622
017F6:  MOVFF  02,621
017FA:  MOVFF  01,620
017FE:  MOVFF  00,61F
01802:  MOVFF  03,62F
01806:  MOVFF  02,62E
0180A:  MOVFF  01,62D
0180E:  MOVFF  00,62C
01812:  MOVFF  615,633
01816:  MOVFF  614,632
0181A:  MOVFF  613,631
0181E:  MOVFF  612,630
01822:  CALL   0A44
01826:  MOVFF  03,622
0182A:  MOVFF  02,621
0182E:  MOVFF  01,620
01832:  MOVFF  00,61F
01836:  BCF    FD8.1
01838:  MOVFF  03,633
0183C:  MOVFF  02,632
01840:  MOVFF  01,631
01844:  MOVFF  00,630
01848:  MOVLW  1B
0184A:  MOVLB  6
0184C:  MOVWF  x37
0184E:  MOVLW  E4
01850:  MOVWF  x36
01852:  MOVLW  35
01854:  MOVWF  x35
01856:  MOVLW  82
01858:  MOVWF  x34
0185A:  MOVLB  0
0185C:  CALL   0B3A
01860:  MOVFF  03,61D
01864:  MOVFF  02,61C
01868:  MOVFF  01,61B
0186C:  MOVFF  00,61A
....................    r = r*y*y + qat[2];
01870:  MOVFF  61D,62F
01874:  MOVFF  61C,62E
01878:  MOVFF  61B,62D
0187C:  MOVFF  61A,62C
01880:  MOVFF  615,633
01884:  MOVFF  614,632
01888:  MOVFF  613,631
0188C:  MOVFF  612,630
01890:  CALL   0A44
01894:  MOVFF  03,622
01898:  MOVFF  02,621
0189C:  MOVFF  01,620
018A0:  MOVFF  00,61F
018A4:  MOVFF  03,62F
018A8:  MOVFF  02,62E
018AC:  MOVFF  01,62D
018B0:  MOVFF  00,62C
018B4:  MOVFF  615,633
018B8:  MOVFF  614,632
018BC:  MOVFF  613,631
018C0:  MOVFF  612,630
018C4:  CALL   0A44
018C8:  MOVFF  03,622
018CC:  MOVFF  02,621
018D0:  MOVFF  01,620
018D4:  MOVFF  00,61F
018D8:  BCF    FD8.1
018DA:  MOVFF  03,633
018DE:  MOVFF  02,632
018E2:  MOVFF  01,631
018E6:  MOVFF  00,630
018EA:  MOVLW  A4
018EC:  MOVLB  6
018EE:  MOVWF  x37
018F0:  MOVLW  DB
018F2:  MOVWF  x36
018F4:  MOVLW  67
018F6:  MOVWF  x35
018F8:  MOVLW  83
018FA:  MOVWF  x34
018FC:  MOVLB  0
018FE:  CALL   0B3A
01902:  MOVFF  03,61D
01906:  MOVFF  02,61C
0190A:  MOVFF  01,61B
0190E:  MOVFF  00,61A
....................    r = r*y*y + qat[3];
01912:  MOVFF  61D,62F
01916:  MOVFF  61C,62E
0191A:  MOVFF  61B,62D
0191E:  MOVFF  61A,62C
01922:  MOVFF  615,633
01926:  MOVFF  614,632
0192A:  MOVFF  613,631
0192E:  MOVFF  612,630
01932:  CALL   0A44
01936:  MOVFF  03,622
0193A:  MOVFF  02,621
0193E:  MOVFF  01,620
01942:  MOVFF  00,61F
01946:  MOVFF  03,62F
0194A:  MOVFF  02,62E
0194E:  MOVFF  01,62D
01952:  MOVFF  00,62C
01956:  MOVFF  615,633
0195A:  MOVFF  614,632
0195E:  MOVFF  613,631
01962:  MOVFF  612,630
01966:  CALL   0A44
0196A:  MOVFF  03,622
0196E:  MOVFF  02,621
01972:  MOVFF  01,620
01976:  MOVFF  00,61F
0197A:  BCF    FD8.1
0197C:  MOVFF  03,633
01980:  MOVFF  02,632
01984:  MOVFF  01,631
01988:  MOVFF  00,630
0198C:  MOVLW  33
0198E:  MOVLB  6
01990:  MOVWF  x37
01992:  MOVLW  8C
01994:  MOVWF  x36
01996:  MOVLW  1E
01998:  MOVWF  x35
0199A:  MOVLW  83
0199C:  MOVWF  x34
0199E:  MOVLB  0
019A0:  CALL   0B3A
019A4:  MOVFF  03,61D
019A8:  MOVFF  02,61C
019AC:  MOVFF  01,61B
019B0:  MOVFF  00,61A
.................... 
....................    res = y*res/r;
019B4:  MOVFF  615,62F
019B8:  MOVFF  614,62E
019BC:  MOVFF  613,62D
019C0:  MOVFF  612,62C
019C4:  MOVFF  619,633
019C8:  MOVFF  618,632
019CC:  MOVFF  617,631
019D0:  MOVFF  616,630
019D4:  CALL   0A44
019D8:  MOVFF  03,622
019DC:  MOVFF  02,621
019E0:  MOVFF  01,620
019E4:  MOVFF  00,61F
019E8:  MOVFF  03,628
019EC:  MOVFF  02,627
019F0:  MOVFF  01,626
019F4:  MOVFF  00,625
019F8:  MOVFF  61D,62C
019FC:  MOVFF  61C,62B
01A00:  MOVFF  61B,62A
01A04:  MOVFF  61A,629
01A08:  RCALL  13F0
01A0A:  MOVFF  03,619
01A0E:  MOVFF  02,618
01A12:  MOVFF  01,617
01A16:  MOVFF  00,616
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
01A1A:  MOVLB  6
01A1C:  BTFSS  x1E.1
01A1E:  BRA    1A5A
....................       res = PI_DIV_BY_TWO - res;
01A20:  BSF    FD8.1
01A22:  MOVLW  DB
01A24:  MOVWF  x33
01A26:  MOVLW  0F
01A28:  MOVWF  x32
01A2A:  MOVLW  49
01A2C:  MOVWF  x31
01A2E:  MOVLW  7F
01A30:  MOVWF  x30
01A32:  MOVFF  619,637
01A36:  MOVFF  618,636
01A3A:  MOVFF  617,635
01A3E:  MOVFF  616,634
01A42:  MOVLB  0
01A44:  CALL   0B3A
01A48:  MOVFF  03,619
01A4C:  MOVFF  02,618
01A50:  MOVFF  01,617
01A54:  MOVFF  00,616
01A58:  MOVLB  6
....................    if (s)
01A5A:  BTFSS  x1E.0
01A5C:  BRA    1A64
....................       res = -res;
01A5E:  MOVF   x17,W
01A60:  XORLW  80
01A62:  MOVWF  x17
.................... 
....................    return(res);
01A64:  MOVFF  616,00
01A68:  MOVFF  617,01
01A6C:  MOVFF  618,02
01A70:  MOVFF  619,03
01A74:  MOVLB  0
01A76:  RETURN 0
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
01A78:  MOVLB  6
01A7A:  BCF    x0B.0
....................    quad=0; //quadrant
01A7C:  CLRF   x0C
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
01A7E:  MOVFF  602,62F
01A82:  MOVFF  601,62E
01A86:  MOVFF  600,62D
01A8A:  MOVFF  5FF,62C
01A8E:  CLRF   x33
01A90:  CLRF   x32
01A92:  CLRF   x31
01A94:  CLRF   x30
01A96:  MOVLB  0
01A98:  RCALL  1376
01A9A:  BC    1A9E
01A9C:  BNZ   1AC8
01A9E:  MOVFF  606,62F
01AA2:  MOVFF  605,62E
01AA6:  MOVFF  604,62D
01AAA:  MOVFF  603,62C
01AAE:  MOVLB  6
01AB0:  CLRF   x33
01AB2:  CLRF   x32
01AB4:  CLRF   x31
01AB6:  CLRF   x30
01AB8:  MOVLB  0
01ABA:  RCALL  1376
01ABC:  BC    1AC0
01ABE:  BNZ   1AC4
01AC0:  MOVLW  03
01AC2:  BRA    1AC6
01AC4:  MOVLW  04
01AC6:  BRA    1AEE
01AC8:  MOVFF  606,62F
01ACC:  MOVFF  605,62E
01AD0:  MOVFF  604,62D
01AD4:  MOVFF  603,62C
01AD8:  MOVLB  6
01ADA:  CLRF   x33
01ADC:  CLRF   x32
01ADE:  CLRF   x31
01AE0:  CLRF   x30
01AE2:  MOVLB  0
01AE4:  RCALL  1376
01AE6:  BNC   1AEC
01AE8:  MOVLW  02
01AEA:  BRA    1AEE
01AEC:  MOVLW  01
01AEE:  MOVLB  6
01AF0:  MOVWF  x0C
....................    if(y<0.0)
01AF2:  MOVFF  602,62F
01AF6:  MOVFF  601,62E
01AFA:  MOVFF  600,62D
01AFE:  MOVFF  5FF,62C
01B02:  CLRF   x33
01B04:  CLRF   x32
01B06:  CLRF   x31
01B08:  CLRF   x30
01B0A:  MOVLB  0
01B0C:  RCALL  1376
01B0E:  BNC   1B1C
....................    {
....................       sign=1;
01B10:  MOVLB  6
01B12:  BSF    x0B.0
....................       y=-y;
01B14:  MOVF   x00,W
01B16:  XORLW  80
01B18:  MOVWF  x00
01B1A:  MOVLB  0
....................    }
....................    if(x<0.0)
01B1C:  MOVFF  606,62F
01B20:  MOVFF  605,62E
01B24:  MOVFF  604,62D
01B28:  MOVFF  603,62C
01B2C:  MOVLB  6
01B2E:  CLRF   x33
01B30:  CLRF   x32
01B32:  CLRF   x31
01B34:  CLRF   x30
01B36:  MOVLB  0
01B38:  RCALL  1376
01B3A:  BNC   1B46
....................    {
....................       x=-x;
01B3C:  MOVLB  6
01B3E:  MOVF   x04,W
01B40:  XORLW  80
01B42:  MOVWF  x04
01B44:  MOVLB  0
....................    }
....................    if (x==0.0)
01B46:  MOVFF  606,62F
01B4A:  MOVFF  605,62E
01B4E:  MOVFF  604,62D
01B52:  MOVFF  603,62C
01B56:  MOVLB  6
01B58:  CLRF   x33
01B5A:  CLRF   x32
01B5C:  CLRF   x31
01B5E:  CLRF   x30
01B60:  MOVLB  0
01B62:  RCALL  1376
01B64:  BNZ   1BBA
....................    {
....................       if(y==0.0)
01B66:  MOVFF  602,62F
01B6A:  MOVFF  601,62E
01B6E:  MOVFF  600,62D
01B72:  MOVFF  5FF,62C
01B76:  MOVLB  6
01B78:  CLRF   x33
01B7A:  CLRF   x32
01B7C:  CLRF   x31
01B7E:  CLRF   x30
01B80:  MOVLB  0
01B82:  CALL   1376
01B86:  BNZ   1B8A
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
01B88:  BRA    1BB8
....................       else
....................       {
....................          if(sign)
01B8A:  MOVLB  6
01B8C:  BTFSS  x0B.0
01B8E:  BRA    1BA4
....................          {
....................          return (-(PI_DIV_BY_TWO));
01B90:  MOVLW  7F
01B92:  MOVWF  00
01B94:  MOVLW  C9
01B96:  MOVWF  01
01B98:  MOVLW  0F
01B9A:  MOVWF  02
01B9C:  MOVLW  DB
01B9E:  MOVWF  03
01BA0:  BRA    1CF2
....................          }
01BA2:  BRA    1BB6
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
01BA4:  MOVLW  7F
01BA6:  MOVWF  00
01BA8:  MOVLW  49
01BAA:  MOVWF  01
01BAC:  MOVLW  0F
01BAE:  MOVWF  02
01BB0:  MOVLW  DB
01BB2:  MOVWF  03
01BB4:  BRA    1CF2
01BB6:  MOVLB  0
....................          }
....................       }
....................    }
01BB8:  BRA    1CF0
....................    else
....................    {
....................       z=y/x;
01BBA:  MOVFF  602,628
01BBE:  MOVFF  601,627
01BC2:  MOVFF  600,626
01BC6:  MOVFF  5FF,625
01BCA:  MOVFF  606,62C
01BCE:  MOVFF  605,62B
01BD2:  MOVFF  604,62A
01BD6:  MOVFF  603,629
01BDA:  RCALL  13F0
01BDC:  MOVFF  03,60A
01BE0:  MOVFF  02,609
01BE4:  MOVFF  01,608
01BE8:  MOVFF  00,607
....................       switch(quad)
01BEC:  MOVLW  01
01BEE:  MOVLB  6
01BF0:  SUBWF  x0C,W
01BF2:  ADDLW  FC
01BF4:  BTFSC  FD8.0
01BF6:  BRA    1CF2
01BF8:  ADDLW  04
01BFA:  MOVLB  0
01BFC:  GOTO   1CF8
....................       {
....................          case 1:
....................          {
....................             return atan(z);
01C00:  MOVFF  60A,611
01C04:  MOVFF  609,610
01C08:  MOVFF  608,60F
01C0C:  MOVFF  607,60E
01C10:  RCALL  154E
01C12:  MOVLB  6
01C14:  BRA    1CF2
....................             break;
01C16:  BRA    1CF2
01C18:  MOVLB  0
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
01C1A:  MOVFF  60A,611
01C1E:  MOVFF  609,610
01C22:  MOVFF  608,60F
01C26:  MOVFF  607,60E
01C2A:  RCALL  154E
01C2C:  MOVFF  FEA,60E
01C30:  MOVFF  FE9,60D
01C34:  BSF    FD8.1
01C36:  MOVLW  DB
01C38:  MOVLB  6
01C3A:  MOVWF  x33
01C3C:  MOVLW  0F
01C3E:  MOVWF  x32
01C40:  MOVLW  49
01C42:  MOVWF  x31
01C44:  MOVLW  80
01C46:  MOVWF  x30
01C48:  MOVFF  03,637
01C4C:  MOVFF  02,636
01C50:  MOVFF  01,635
01C54:  MOVFF  00,634
01C58:  MOVLB  0
01C5A:  CALL   0B3A
01C5E:  MOVFF  60E,FEA
01C62:  MOVFF  60D,FE9
01C66:  MOVLB  6
01C68:  BRA    1CF2
....................             break;
01C6A:  BRA    1CF2
01C6C:  MOVLB  0
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
01C6E:  MOVFF  60A,611
01C72:  MOVFF  609,610
01C76:  MOVFF  608,60F
01C7A:  MOVFF  607,60E
01C7E:  RCALL  154E
01C80:  MOVFF  03,610
01C84:  MOVFF  02,60F
01C88:  MOVFF  01,60E
01C8C:  MOVFF  00,60D
01C90:  MOVFF  FEA,612
01C94:  MOVFF  FE9,611
01C98:  BSF    FD8.1
01C9A:  MOVFF  03,633
01C9E:  MOVFF  02,632
01CA2:  MOVFF  01,631
01CA6:  MOVFF  00,630
01CAA:  MOVLW  DB
01CAC:  MOVLB  6
01CAE:  MOVWF  x37
01CB0:  MOVLW  0F
01CB2:  MOVWF  x36
01CB4:  MOVLW  49
01CB6:  MOVWF  x35
01CB8:  MOVLW  80
01CBA:  MOVWF  x34
01CBC:  MOVLB  0
01CBE:  CALL   0B3A
01CC2:  MOVFF  612,FEA
01CC6:  MOVFF  611,FE9
01CCA:  MOVLB  6
01CCC:  BRA    1CF2
....................             break;
01CCE:  BRA    1CF2
01CD0:  MOVLB  0
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
01CD2:  MOVFF  60A,611
01CD6:  MOVFF  609,610
01CDA:  MOVFF  608,60F
01CDE:  MOVFF  607,60E
01CE2:  RCALL  154E
01CE4:  MOVLW  80
01CE6:  XORWF  01,F
01CE8:  MOVLB  6
01CEA:  BRA    1CF2
....................             break;
01CEC:  BRA    1CF2
01CEE:  MOVLB  0
01CF0:  MOVLB  6
....................          }
....................       }
....................    }
01CF2:  MOVLB  0
01CF4:  GOTO   30F0 (RETURN)
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... #define sensorSampleRate 50 // 50mS delay between each sensor sample = 200ms cadence 
.................... 
.................... #define maxCount 16777216.0   // ADC max count
.................... //!#define vRef 2.048            // ADC vRef
.................... 
.................... #define sc sensorCal
.................... 
.................... // adc settings for magnetoresistive sensors
.................... #define KMXP1000reg0config IPp1n2|g16|PGAenabled // 0x3A//
.................... #define KMXP1000reg1config DRn20|MDturbo|CMsingle|TSDisable|BCSoff //0x00
.................... #define KMXP1000reg2config REFinternal|FIR60|PSWopen|Ioff //0x30
.................... #define KMXP1000reg3config I1disabled|I2disabled|drdyPin //0x00
.................... 
.................... #define KMXP2000reg0config IPp1n2|g16|PGAenabled // 0x3A//
.................... #define KMXP2000reg1config DRn20|MDturbo|CMsingle|TSDisable|BCSoff //0x00
.................... #define KMXP2000reg2config REFinternal|FIR60|PSWopen|Ioff //0x30
.................... #define KMXP2000reg3config I1disabled|I2disabled|drdyPin //0x00
.................... 
.................... #define vMonN15   6
.................... #define vMon200   16
.................... #define vMon5V6   24
.................... #define vMon5VA   25
.................... #define vMon3V6X  17
.................... #define vMon3V3A  27
.................... #define vMon3V3D  26
.................... 
.................... struct sensorMonitorData
.................... {
....................    boolean dataReady;
....................    boolean adcBusy;
....................    int8 channel; // DEFAULT: 0=chX | 1=chY
.................... } smData = {false, false, 0};
.................... 
.................... /*****************************************************************************/
.................... /* INTERNAL MONITOR task - gets voltages                                     */
.................... /* gets one value each time the task is run                                  */
.................... /*****************************************************************************/
.................... void internal_monitor_task()
.................... {
....................    static int8 state = 0;
....................    if (adc_done())
*
00DB2:  MOVLB  F
00DB4:  BTFSC  x5B.0
00DB6:  BRA    12C2
....................    {
....................       switch (state)
00DB8:  MOVLB  1
00DBA:  MOVF   x51,W
00DBC:  XORLW  00
00DBE:  MOVLB  0
00DC0:  BZ    0DE0
00DC2:  XORLW  01
00DC4:  BZ    0E92
00DC6:  XORLW  03
00DC8:  BTFSC  FD8.2
00DCA:  BRA    0F44
00DCC:  XORLW  01
00DCE:  BTFSC  FD8.2
00DD0:  BRA    0FF6
00DD2:  XORLW  07
00DD4:  BTFSC  FD8.2
00DD6:  BRA    10A8
00DD8:  XORLW  01
00DDA:  BTFSC  FD8.2
00DDC:  BRA    115A
00DDE:  BRA    120E
....................       {
....................          case 0:     // vMonN15
....................             monitorVals.vN15 = read_adc(ADC_READ_ONLY) * monCal.vN15[1] + monCal.vN15[0];
00DE0:  MOVLB  F
00DE2:  BTFSC  x5B.0
00DE4:  BRA    0DE2
00DE6:  MOVFF  F5F,02
00DEA:  MOVFF  F5E,01
00DEE:  MOVFF  02,5D8
00DF2:  MOVFF  01,5D7
00DF6:  MOVFF  02,631
00DFA:  MOVFF  01,630
00DFE:  MOVLB  0
00E00:  RCALL  0A0E
00E02:  MOVFF  03,62F
00E06:  MOVFF  02,62E
00E0A:  MOVFF  01,62D
00E0E:  MOVFF  00,62C
00E12:  MOVFF  B9,633
00E16:  MOVFF  B8,632
00E1A:  MOVFF  B7,631
00E1E:  MOVFF  B6,630
00E22:  RCALL  0A44
00E24:  MOVFF  03,5DA
00E28:  MOVFF  02,5D9
00E2C:  MOVFF  01,5D8
00E30:  MOVFF  00,5D7
00E34:  BCF    FD8.1
00E36:  MOVFF  03,633
00E3A:  MOVFF  02,632
00E3E:  MOVFF  01,631
00E42:  MOVFF  00,630
00E46:  MOVFF  B5,637
00E4A:  MOVFF  B4,636
00E4E:  MOVFF  B3,635
00E52:  MOVFF  B2,634
00E56:  RCALL  0B3A
00E58:  MOVFF  03,F6
00E5C:  MOVFF  02,F5
00E60:  MOVFF  01,F4
00E64:  MOVFF  00,F3
....................             set_adc_channel(vMon200);
00E68:  MOVLB  F
00E6A:  MOVF   x5A,W
00E6C:  ANDLW  3F
00E6E:  MOVWF  01
00E70:  MOVLW  10
00E72:  MOVWF  x5A
00E74:  BTFSS  x5B.7
00E76:  BRA    0E86
00E78:  MOVF   01,W
00E7A:  SUBLW  10
00E7C:  BZ    0E86
00E7E:  BSF    x5B.0
00E80:  NOP   
00E82:  BTFSC  x5B.0
00E84:  BRA    0E82
....................             read_adc(ADC_START_ONLY);
00E86:  BSF    x5B.0
00E88:  NOP   
....................             state = 1;
00E8A:  MOVLW  01
00E8C:  MOVLB  1
00E8E:  MOVWF  x51
....................          break;
00E90:  BRA    12C0
....................          
....................          case 1:     // vMon200
....................             monitorVals.v200 = read_adc(ADC_READ_ONLY) * monCal.v200[1] + monCal.v200[0];
00E92:  MOVLB  F
00E94:  BTFSC  x5B.0
00E96:  BRA    0E94
00E98:  MOVFF  F5F,02
00E9C:  MOVFF  F5E,01
00EA0:  MOVFF  02,5D8
00EA4:  MOVFF  01,5D7
00EA8:  MOVFF  02,631
00EAC:  MOVFF  01,630
00EB0:  MOVLB  0
00EB2:  RCALL  0A0E
00EB4:  MOVFF  03,62F
00EB8:  MOVFF  02,62E
00EBC:  MOVFF  01,62D
00EC0:  MOVFF  00,62C
00EC4:  MOVFF  C1,633
00EC8:  MOVFF  C0,632
00ECC:  MOVFF  BF,631
00ED0:  MOVFF  BE,630
00ED4:  RCALL  0A44
00ED6:  MOVFF  03,5DA
00EDA:  MOVFF  02,5D9
00EDE:  MOVFF  01,5D8
00EE2:  MOVFF  00,5D7
00EE6:  BCF    FD8.1
00EE8:  MOVFF  03,633
00EEC:  MOVFF  02,632
00EF0:  MOVFF  01,631
00EF4:  MOVFF  00,630
00EF8:  MOVFF  BD,637
00EFC:  MOVFF  BC,636
00F00:  MOVFF  BB,635
00F04:  MOVFF  BA,634
00F08:  RCALL  0B3A
00F0A:  MOVFF  03,FA
00F0E:  MOVFF  02,F9
00F12:  MOVFF  01,F8
00F16:  MOVFF  00,F7
....................             set_adc_channel(vMon5V6);
00F1A:  MOVLB  F
00F1C:  MOVF   x5A,W
00F1E:  ANDLW  3F
00F20:  MOVWF  01
00F22:  MOVLW  18
00F24:  MOVWF  x5A
00F26:  BTFSS  x5B.7
00F28:  BRA    0F38
00F2A:  MOVF   01,W
00F2C:  SUBLW  18
00F2E:  BZ    0F38
00F30:  BSF    x5B.0
00F32:  NOP   
00F34:  BTFSC  x5B.0
00F36:  BRA    0F34
....................             read_adc(ADC_START_ONLY);
00F38:  BSF    x5B.0
00F3A:  NOP   
....................             state = 2;
00F3C:  MOVLW  02
00F3E:  MOVLB  1
00F40:  MOVWF  x51
....................          break;
00F42:  BRA    12C0
....................          
....................          case 2:     // vMon5V6
....................             monitorVals.v5V6 = read_adc(ADC_READ_ONLY) * monCal.v5V6[1] + monCal.v5V6[0];
00F44:  MOVLB  F
00F46:  BTFSC  x5B.0
00F48:  BRA    0F46
00F4A:  MOVFF  F5F,02
00F4E:  MOVFF  F5E,01
00F52:  MOVFF  02,5D8
00F56:  MOVFF  01,5D7
00F5A:  MOVFF  02,631
00F5E:  MOVFF  01,630
00F62:  MOVLB  0
00F64:  RCALL  0A0E
00F66:  MOVFF  03,62F
00F6A:  MOVFF  02,62E
00F6E:  MOVFF  01,62D
00F72:  MOVFF  00,62C
00F76:  MOVFF  C9,633
00F7A:  MOVFF  C8,632
00F7E:  MOVFF  C7,631
00F82:  MOVFF  C6,630
00F86:  RCALL  0A44
00F88:  MOVFF  03,5DA
00F8C:  MOVFF  02,5D9
00F90:  MOVFF  01,5D8
00F94:  MOVFF  00,5D7
00F98:  BCF    FD8.1
00F9A:  MOVFF  03,633
00F9E:  MOVFF  02,632
00FA2:  MOVFF  01,631
00FA6:  MOVFF  00,630
00FAA:  MOVFF  C5,637
00FAE:  MOVFF  C4,636
00FB2:  MOVFF  C3,635
00FB6:  MOVFF  C2,634
00FBA:  RCALL  0B3A
00FBC:  MOVFF  03,FE
00FC0:  MOVFF  02,FD
00FC4:  MOVFF  01,FC
00FC8:  MOVFF  00,FB
....................             set_adc_channel(vMon5VA);
00FCC:  MOVLB  F
00FCE:  MOVF   x5A,W
00FD0:  ANDLW  3F
00FD2:  MOVWF  01
00FD4:  MOVLW  19
00FD6:  MOVWF  x5A
00FD8:  BTFSS  x5B.7
00FDA:  BRA    0FEA
00FDC:  MOVF   01,W
00FDE:  SUBLW  19
00FE0:  BZ    0FEA
00FE2:  BSF    x5B.0
00FE4:  NOP   
00FE6:  BTFSC  x5B.0
00FE8:  BRA    0FE6
....................             read_adc(ADC_START_ONLY);
00FEA:  BSF    x5B.0
00FEC:  NOP   
....................             state = 3;
00FEE:  MOVLW  03
00FF0:  MOVLB  1
00FF2:  MOVWF  x51
....................          break;
00FF4:  BRA    12C0
....................          
....................          case 3:     // vMon5VA
....................             monitorVals.v5VA = read_adc(ADC_READ_ONLY) * monCal.v5VA[1] + monCal.v5VA[0];
00FF6:  MOVLB  F
00FF8:  BTFSC  x5B.0
00FFA:  BRA    0FF8
00FFC:  MOVFF  F5F,02
01000:  MOVFF  F5E,01
01004:  MOVFF  02,5D8
01008:  MOVFF  01,5D7
0100C:  MOVFF  02,631
01010:  MOVFF  01,630
01014:  MOVLB  0
01016:  RCALL  0A0E
01018:  MOVFF  03,62F
0101C:  MOVFF  02,62E
01020:  MOVFF  01,62D
01024:  MOVFF  00,62C
01028:  MOVFF  D1,633
0102C:  MOVFF  D0,632
01030:  MOVFF  CF,631
01034:  MOVFF  CE,630
01038:  RCALL  0A44
0103A:  MOVFF  03,5DA
0103E:  MOVFF  02,5D9
01042:  MOVFF  01,5D8
01046:  MOVFF  00,5D7
0104A:  BCF    FD8.1
0104C:  MOVFF  03,633
01050:  MOVFF  02,632
01054:  MOVFF  01,631
01058:  MOVFF  00,630
0105C:  MOVFF  CD,637
01060:  MOVFF  CC,636
01064:  MOVFF  CB,635
01068:  MOVFF  CA,634
0106C:  RCALL  0B3A
0106E:  MOVFF  03,102
01072:  MOVFF  02,101
01076:  MOVFF  01,100
0107A:  MOVFF  00,FF
....................             set_adc_channel(vMon3V6X);
0107E:  MOVLB  F
01080:  MOVF   x5A,W
01082:  ANDLW  3F
01084:  MOVWF  01
01086:  MOVLW  11
01088:  MOVWF  x5A
0108A:  BTFSS  x5B.7
0108C:  BRA    109C
0108E:  MOVF   01,W
01090:  SUBLW  11
01092:  BZ    109C
01094:  BSF    x5B.0
01096:  NOP   
01098:  BTFSC  x5B.0
0109A:  BRA    1098
....................             read_adc(ADC_START_ONLY);
0109C:  BSF    x5B.0
0109E:  NOP   
....................             state = 4;
010A0:  MOVLW  04
010A2:  MOVLB  1
010A4:  MOVWF  x51
....................          break;
010A6:  BRA    12C0
....................          
....................          case 4:     // vMon3V6X
....................             monitorVals.v3V6X = read_adc(ADC_READ_ONLY) * monCal.v3V6X[1] + monCal.v3V6X[0];
010A8:  MOVLB  F
010AA:  BTFSC  x5B.0
010AC:  BRA    10AA
010AE:  MOVFF  F5F,02
010B2:  MOVFF  F5E,01
010B6:  MOVFF  02,5D8
010BA:  MOVFF  01,5D7
010BE:  MOVFF  02,631
010C2:  MOVFF  01,630
010C6:  MOVLB  0
010C8:  RCALL  0A0E
010CA:  MOVFF  03,62F
010CE:  MOVFF  02,62E
010D2:  MOVFF  01,62D
010D6:  MOVFF  00,62C
010DA:  MOVFF  D9,633
010DE:  MOVFF  D8,632
010E2:  MOVFF  D7,631
010E6:  MOVFF  D6,630
010EA:  RCALL  0A44
010EC:  MOVFF  03,5DA
010F0:  MOVFF  02,5D9
010F4:  MOVFF  01,5D8
010F8:  MOVFF  00,5D7
010FC:  BCF    FD8.1
010FE:  MOVFF  03,633
01102:  MOVFF  02,632
01106:  MOVFF  01,631
0110A:  MOVFF  00,630
0110E:  MOVFF  D5,637
01112:  MOVFF  D4,636
01116:  MOVFF  D3,635
0111A:  MOVFF  D2,634
0111E:  RCALL  0B3A
01120:  MOVFF  03,106
01124:  MOVFF  02,105
01128:  MOVFF  01,104
0112C:  MOVFF  00,103
....................             set_adc_channel(vMon3V3A);
01130:  MOVLB  F
01132:  MOVF   x5A,W
01134:  ANDLW  3F
01136:  MOVWF  01
01138:  MOVLW  1B
0113A:  MOVWF  x5A
0113C:  BTFSS  x5B.7
0113E:  BRA    114E
01140:  MOVF   01,W
01142:  SUBLW  1B
01144:  BZ    114E
01146:  BSF    x5B.0
01148:  NOP   
0114A:  BTFSC  x5B.0
0114C:  BRA    114A
....................             read_adc(ADC_START_ONLY);
0114E:  BSF    x5B.0
01150:  NOP   
....................             state = 5;
01152:  MOVLW  05
01154:  MOVLB  1
01156:  MOVWF  x51
....................          break;
01158:  BRA    12C0
....................          
....................          case 5:     // vMon3V3A
....................             monitorVals.v3V3A = read_adc(ADC_READ_ONLY) * monCal.v3V3A[1] + monCal.v3V3A[0];
0115A:  MOVLB  F
0115C:  BTFSC  x5B.0
0115E:  BRA    115C
01160:  MOVFF  F5F,02
01164:  MOVFF  F5E,01
01168:  MOVFF  02,5D8
0116C:  MOVFF  01,5D7
01170:  MOVFF  02,631
01174:  MOVFF  01,630
01178:  MOVLB  0
0117A:  RCALL  0A0E
0117C:  MOVFF  03,62F
01180:  MOVFF  02,62E
01184:  MOVFF  01,62D
01188:  MOVFF  00,62C
0118C:  MOVFF  E1,633
01190:  MOVFF  E0,632
01194:  MOVFF  DF,631
01198:  MOVFF  DE,630
0119C:  RCALL  0A44
0119E:  MOVFF  03,5DA
011A2:  MOVFF  02,5D9
011A6:  MOVFF  01,5D8
011AA:  MOVFF  00,5D7
011AE:  BCF    FD8.1
011B0:  MOVFF  03,633
011B4:  MOVFF  02,632
011B8:  MOVFF  01,631
011BC:  MOVFF  00,630
011C0:  MOVFF  DD,637
011C4:  MOVFF  DC,636
011C8:  MOVFF  DB,635
011CC:  MOVFF  DA,634
011D0:  RCALL  0B3A
011D2:  MOVFF  03,10A
011D6:  MOVFF  02,109
011DA:  MOVFF  01,108
011DE:  MOVFF  00,107
....................             set_adc_channel(vMon3V3D);
011E2:  MOVLB  F
011E4:  MOVF   x5A,W
011E6:  ANDLW  3F
011E8:  MOVWF  01
011EA:  MOVLW  1A
011EC:  MOVWF  x5A
011EE:  BTFSS  x5B.7
011F0:  BRA    1200
011F2:  MOVF   01,W
011F4:  SUBLW  1A
011F6:  BZ    1200
011F8:  BSF    x5B.0
011FA:  NOP   
011FC:  BTFSC  x5B.0
011FE:  BRA    11FC
....................             read_adc(ADC_START_ONLY);
01200:  BSF    x5B.0
01202:  NOP   
....................             state = 6;
01204:  MOVLW  06
01206:  MOVLB  1
01208:  MOVWF  x51
....................          break;
0120A:  BRA    12C0
0120C:  MOVLB  0
....................          
....................          default:    // vMon3V3D
....................             monitorVals.v3V3D = read_adc(ADC_READ_ONLY) * monCal.v3V3D[1] + monCal.v3V3D[0];
0120E:  MOVLB  F
01210:  BTFSC  x5B.0
01212:  BRA    1210
01214:  MOVFF  F5F,02
01218:  MOVFF  F5E,01
0121C:  MOVFF  02,5D8
01220:  MOVFF  01,5D7
01224:  MOVFF  02,631
01228:  MOVFF  01,630
0122C:  MOVLB  0
0122E:  CALL   0A0E
01232:  MOVFF  03,62F
01236:  MOVFF  02,62E
0123A:  MOVFF  01,62D
0123E:  MOVFF  00,62C
01242:  MOVFF  E9,633
01246:  MOVFF  E8,632
0124A:  MOVFF  E7,631
0124E:  MOVFF  E6,630
01252:  CALL   0A44
01256:  MOVFF  03,5DA
0125A:  MOVFF  02,5D9
0125E:  MOVFF  01,5D8
01262:  MOVFF  00,5D7
01266:  BCF    FD8.1
01268:  MOVFF  03,633
0126C:  MOVFF  02,632
01270:  MOVFF  01,631
01274:  MOVFF  00,630
01278:  MOVFF  E5,637
0127C:  MOVFF  E4,636
01280:  MOVFF  E3,635
01284:  MOVFF  E2,634
01288:  RCALL  0B3A
0128A:  MOVFF  03,10E
0128E:  MOVFF  02,10D
01292:  MOVFF  01,10C
01296:  MOVFF  00,10B
....................             set_adc_channel(vMonN15);
0129A:  MOVLB  F
0129C:  MOVF   x5A,W
0129E:  ANDLW  3F
012A0:  MOVWF  01
012A2:  MOVLW  06
012A4:  MOVWF  x5A
012A6:  BTFSS  x5B.7
012A8:  BRA    12B8
012AA:  MOVF   01,W
012AC:  SUBLW  06
012AE:  BZ    12B8
012B0:  BSF    x5B.0
012B2:  NOP   
012B4:  BTFSC  x5B.0
012B6:  BRA    12B4
....................             read_adc(ADC_START_ONLY);
012B8:  BSF    x5B.0
012BA:  NOP   
....................             state = 0;
012BC:  MOVLB  1
012BE:  CLRF   x51
....................          break;   
012C0:  MOVLB  F
....................       }
....................    }
012C2:  MOVLB  0
012C4:  GOTO   75E6 (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* PROCESS ADC SENSOR DATA                                                   */
.................... /*****************************************************************************/
.................... void sensor_process_data(int8 ch, unsigned int32 sinRawCounts, unsigned int32 cosRawCounts)
.................... {
....................    adcVals[ch].sinRaw = (float)sinRawCounts;
*
02D50:  MOVLB  5
02D52:  MOVF   xE0,W
02D54:  MULLW  19
02D56:  MOVF   FF3,W
02D58:  CLRF   xF2
02D5A:  MOVWF  xF1
02D5C:  MOVLW  0F
02D5E:  ADDWF  xF1,W
02D60:  MOVWF  FE9
02D62:  MOVLW  01
02D64:  ADDWFC xF2,W
02D66:  MOVWF  FEA
02D68:  MOVFF  5E4,5F8
02D6C:  MOVFF  5E3,5F7
02D70:  MOVFF  5E2,5F6
02D74:  MOVFF  5E1,5F5
02D78:  MOVLB  0
02D7A:  CALL   133E
02D7E:  MOVFF  00,FEF
02D82:  MOVFF  01,FEC
02D86:  MOVFF  02,FEC
02D8A:  MOVFF  03,FEC
....................    adcVals[ch].cosRaw = (float)cosRawCounts;
02D8E:  MOVLB  5
02D90:  MOVF   xE0,W
02D92:  MULLW  19
02D94:  MOVF   FF3,W
02D96:  CLRF   xF2
02D98:  MOVWF  xF1
02D9A:  MOVLW  04
02D9C:  ADDWF  xF1,W
02D9E:  MOVWF  01
02DA0:  MOVLW  00
02DA2:  ADDWFC xF2,W
02DA4:  MOVWF  03
02DA6:  MOVF   01,W
02DA8:  ADDLW  0F
02DAA:  MOVWF  FE9
02DAC:  MOVLW  01
02DAE:  ADDWFC 03,W
02DB0:  MOVWF  FEA
02DB2:  MOVFF  5E8,5F8
02DB6:  MOVFF  5E7,5F7
02DBA:  MOVFF  5E6,5F6
02DBE:  MOVFF  5E5,5F5
02DC2:  MOVLB  0
02DC4:  CALL   133E
02DC8:  MOVFF  00,FEF
02DCC:  MOVFF  01,FEC
02DD0:  MOVFF  02,FEC
02DD4:  MOVFF  03,FEC
....................    
....................    adcVals[ch].sinCounts = adcVals[ch].sinRaw * adcCal[ch].sinGain + adcCal[ch].sinOS;
02DD8:  MOVLB  5
02DDA:  MOVF   xE0,W
02DDC:  MULLW  19
02DDE:  MOVF   FF3,W
02DE0:  CLRF   xF2
02DE2:  MOVWF  xF1
02DE4:  MOVLW  08
02DE6:  ADDWF  xF1,W
02DE8:  MOVWF  01
02DEA:  MOVLW  00
02DEC:  ADDWFC xF2,W
02DEE:  MOVWF  03
02DF0:  MOVF   01,W
02DF2:  ADDLW  0F
02DF4:  MOVWF  01
02DF6:  MOVLW  01
02DF8:  ADDWFC 03,F
02DFA:  MOVFF  01,5F1
02DFE:  MOVFF  03,5F2
02E02:  MOVF   xE0,W
02E04:  MULLW  19
02E06:  MOVF   FF3,W
02E08:  CLRF   xF4
02E0A:  MOVWF  xF3
02E0C:  MOVLW  0F
02E0E:  ADDWF  xF3,W
02E10:  MOVWF  FE9
02E12:  MOVLW  01
02E14:  ADDWFC xF4,W
02E16:  MOVWF  FEA
02E18:  MOVFF  FEF,62C
02E1C:  MOVFF  FEC,62D
02E20:  MOVFF  FEC,62E
02E24:  MOVFF  FEC,62F
02E28:  MOVF   xE0,W
02E2A:  MULLW  10
02E2C:  MOVF   FF3,W
02E2E:  CLRF   xFA
02E30:  MOVWF  xF9
02E32:  MOVLW  08
02E34:  ADDWF  xF9,W
02E36:  MOVWF  01
02E38:  MOVLW  00
02E3A:  ADDWFC xFA,W
02E3C:  MOVWF  03
02E3E:  MOVF   01,W
02E40:  ADDLW  62
02E42:  MOVWF  FE9
02E44:  MOVLW  00
02E46:  ADDWFC 03,W
02E48:  MOVWF  FEA
02E4A:  MOVFF  FEF,630
02E4E:  MOVFF  FEC,01
02E52:  MOVFF  FEC,02
02E56:  MOVFF  FEC,03
02E5A:  MOVFF  03,633
02E5E:  MOVFF  02,632
02E62:  MOVFF  01,631
02E66:  MOVLB  0
02E68:  CALL   0A44
02E6C:  MOVFF  03,633
02E70:  MOVFF  02,632
02E74:  MOVFF  01,631
02E78:  MOVFF  00,630
02E7C:  MOVLB  5
02E7E:  MOVF   xE0,W
02E80:  MULLW  10
02E82:  MOVF   FF3,W
02E84:  CLRF   xFA
02E86:  MOVWF  xF9
02E88:  MOVLW  62
02E8A:  ADDWF  xF9,W
02E8C:  MOVWF  FE9
02E8E:  MOVLW  00
02E90:  ADDWFC xFA,W
02E92:  MOVWF  FEA
02E94:  MOVFF  FEF,634
02E98:  MOVFF  FEC,01
02E9C:  MOVFF  FEC,02
02EA0:  MOVFF  FEC,03
02EA4:  BCF    FD8.1
02EA6:  MOVFF  03,637
02EAA:  MOVFF  02,636
02EAE:  MOVFF  01,635
02EB2:  MOVLB  0
02EB4:  CALL   0B3A
02EB8:  MOVFF  5F2,FEA
02EBC:  MOVFF  5F1,FE9
02EC0:  MOVFF  00,FEF
02EC4:  MOVFF  01,FEC
02EC8:  MOVFF  02,FEC
02ECC:  MOVFF  03,FEC
....................    adcVals[ch].cosCounts = adcVals[ch].cosRaw * adcCal[ch].cosGain + adcCal[ch].cosOS;
02ED0:  MOVLB  5
02ED2:  MOVF   xE0,W
02ED4:  MULLW  19
02ED6:  MOVF   FF3,W
02ED8:  CLRF   xF2
02EDA:  MOVWF  xF1
02EDC:  MOVLW  0C
02EDE:  ADDWF  xF1,W
02EE0:  MOVWF  01
02EE2:  MOVLW  00
02EE4:  ADDWFC xF2,W
02EE6:  MOVWF  03
02EE8:  MOVF   01,W
02EEA:  ADDLW  0F
02EEC:  MOVWF  01
02EEE:  MOVLW  01
02EF0:  ADDWFC 03,F
02EF2:  MOVFF  01,5F1
02EF6:  MOVFF  03,5F2
02EFA:  MOVF   xE0,W
02EFC:  MULLW  19
02EFE:  MOVF   FF3,W
02F00:  CLRF   xF4
02F02:  MOVWF  xF3
02F04:  MOVLW  04
02F06:  ADDWF  xF3,W
02F08:  MOVWF  01
02F0A:  MOVLW  00
02F0C:  ADDWFC xF4,W
02F0E:  MOVWF  03
02F10:  MOVF   01,W
02F12:  ADDLW  0F
02F14:  MOVWF  FE9
02F16:  MOVLW  01
02F18:  ADDWFC 03,W
02F1A:  MOVWF  FEA
02F1C:  MOVFF  FEF,62C
02F20:  MOVFF  FEC,62D
02F24:  MOVFF  FEC,62E
02F28:  MOVFF  FEC,62F
02F2C:  MOVF   xE0,W
02F2E:  MULLW  10
02F30:  MOVF   FF3,W
02F32:  CLRF   xF8
02F34:  MOVWF  xF7
02F36:  MOVLW  0C
02F38:  ADDWF  xF7,W
02F3A:  MOVWF  01
02F3C:  MOVLW  00
02F3E:  ADDWFC xF8,W
02F40:  MOVWF  03
02F42:  MOVF   01,W
02F44:  ADDLW  62
02F46:  MOVWF  FE9
02F48:  MOVLW  00
02F4A:  ADDWFC 03,W
02F4C:  MOVWF  FEA
02F4E:  MOVFF  FEF,630
02F52:  MOVFF  FEC,01
02F56:  MOVFF  FEC,02
02F5A:  MOVFF  FEC,03
02F5E:  MOVFF  03,633
02F62:  MOVFF  02,632
02F66:  MOVFF  01,631
02F6A:  MOVLB  0
02F6C:  CALL   0A44
02F70:  MOVFF  03,633
02F74:  MOVFF  02,632
02F78:  MOVFF  01,631
02F7C:  MOVFF  00,630
02F80:  MOVLB  5
02F82:  MOVF   xE0,W
02F84:  MULLW  10
02F86:  MOVF   FF3,W
02F88:  CLRF   xF8
02F8A:  MOVWF  xF7
02F8C:  MOVLW  04
02F8E:  ADDWF  xF7,W
02F90:  MOVWF  01
02F92:  MOVLW  00
02F94:  ADDWFC xF8,W
02F96:  MOVWF  03
02F98:  MOVF   01,W
02F9A:  ADDLW  62
02F9C:  MOVWF  FE9
02F9E:  MOVLW  00
02FA0:  ADDWFC 03,W
02FA2:  MOVWF  FEA
02FA4:  MOVFF  FEF,634
02FA8:  MOVFF  FEC,01
02FAC:  MOVFF  FEC,02
02FB0:  MOVFF  FEC,03
02FB4:  BCF    FD8.1
02FB6:  MOVFF  03,637
02FBA:  MOVFF  02,636
02FBE:  MOVFF  01,635
02FC2:  MOVLB  0
02FC4:  CALL   0B3A
02FC8:  MOVFF  5F2,FEA
02FCC:  MOVFF  5F1,FE9
02FD0:  MOVFF  00,FEF
02FD4:  MOVFF  01,FEC
02FD8:  MOVFF  02,FEC
02FDC:  MOVFF  03,FEC
....................    float pTmp = 0;
....................    float polePitch = magPP;
02FE0:  MOVLB  5
02FE2:  CLRF   xEC
02FE4:  CLRF   xEB
02FE6:  CLRF   xEA
02FE8:  CLRF   xE9
02FEA:  CLRF   xF0
02FEC:  CLRF   xEF
02FEE:  CLRF   xEE
02FF0:  MOVLW  7F
02FF2:  MOVWF  xED
....................    
....................    adcVals[ch].p0 = polePitch * ( 1000 / (2*PI) ) * atan2( (float)adcVals[ch].sinCounts, (float)adcVals[ch].cosCounts );
02FF4:  MOVF   xE0,W
02FF6:  MULLW  19
02FF8:  MOVF   FF3,W
02FFA:  CLRF   xF2
02FFC:  MOVWF  xF1
02FFE:  MOVLW  10
03000:  ADDWF  xF1,W
03002:  MOVWF  01
03004:  MOVLW  00
03006:  ADDWFC xF2,W
03008:  MOVWF  03
0300A:  MOVF   01,W
0300C:  ADDLW  0F
0300E:  MOVWF  01
03010:  MOVLW  01
03012:  ADDWFC 03,F
03014:  MOVFF  01,5F1
03018:  MOVFF  03,5F2
0301C:  MOVFF  5F0,62F
03020:  MOVFF  5EF,62E
03024:  MOVFF  5EE,62D
03028:  MOVFF  5ED,62C
0302C:  MOVLW  AA
0302E:  MOVLB  6
03030:  MOVWF  x33
03032:  MOVLW  27
03034:  MOVWF  x32
03036:  MOVLW  1F
03038:  MOVWF  x31
0303A:  MOVLW  86
0303C:  MOVWF  x30
0303E:  MOVLB  0
03040:  CALL   0A44
03044:  MOVFF  03,5F6
03048:  MOVFF  02,5F5
0304C:  MOVFF  01,5F4
03050:  MOVFF  00,5F3
03054:  MOVLB  5
03056:  MOVF   xE0,W
03058:  MULLW  19
0305A:  MOVF   FF3,W
0305C:  CLRF   xF8
0305E:  MOVWF  xF7
03060:  MOVLW  08
03062:  ADDWF  xF7,W
03064:  MOVWF  01
03066:  MOVLW  00
03068:  ADDWFC xF8,W
0306A:  MOVWF  03
0306C:  MOVF   01,W
0306E:  ADDLW  0F
03070:  MOVWF  FE9
03072:  MOVLW  01
03074:  ADDWFC 03,W
03076:  MOVWF  FEA
03078:  MOVFF  FEF,5F7
0307C:  MOVFF  FEC,5F8
03080:  MOVFF  FEC,5F9
03084:  MOVFF  FEC,5FA
03088:  MOVF   xE0,W
0308A:  MULLW  19
0308C:  MOVF   FF3,W
0308E:  CLRF   xFC
03090:  MOVWF  xFB
03092:  MOVLW  0C
03094:  ADDWF  xFB,W
03096:  MOVWF  01
03098:  MOVLW  00
0309A:  ADDWFC xFC,W
0309C:  MOVWF  03
0309E:  MOVF   01,W
030A0:  ADDLW  0F
030A2:  MOVWF  FE9
030A4:  MOVLW  01
030A6:  ADDWFC 03,W
030A8:  MOVWF  FEA
030AA:  MOVFF  FEF,00
030AE:  MOVFF  FEC,01
030B2:  MOVFF  FEC,02
030B6:  MOVFF  FEC,03
030BA:  MOVFF  03,5FE
030BE:  MOVFF  02,5FD
030C2:  MOVFF  01,5FC
030C6:  MOVFF  00,5FB
030CA:  MOVFF  5FA,602
030CE:  MOVFF  5F9,601
030D2:  MOVFF  5F8,600
030D6:  MOVFF  5F7,5FF
030DA:  MOVFF  03,606
030DE:  MOVFF  02,605
030E2:  MOVFF  01,604
030E6:  MOVFF  00,603
030EA:  MOVLB  0
030EC:  GOTO   1A78
030F0:  MOVFF  5F6,62F
030F4:  MOVFF  5F5,62E
030F8:  MOVFF  5F4,62D
030FC:  MOVFF  5F3,62C
03100:  MOVFF  03,633
03104:  MOVFF  02,632
03108:  MOVFF  01,631
0310C:  MOVFF  00,630
03110:  CALL   0A44
03114:  MOVFF  5F2,FEA
03118:  MOVFF  5F1,FE9
0311C:  MOVFF  00,FEF
03120:  MOVFF  01,FEC
03124:  MOVFF  02,FEC
03128:  MOVFF  03,FEC
....................    pTmp = adcVals[ch].p0 + ( polePitch * adcVals[ch].npoles );
0312C:  MOVLB  5
0312E:  MOVF   xE0,W
03130:  MULLW  19
03132:  MOVF   FF3,W
03134:  CLRF   xF2
03136:  MOVWF  xF1
03138:  MOVLW  10
0313A:  ADDWF  xF1,W
0313C:  MOVWF  01
0313E:  MOVLW  00
03140:  ADDWFC xF2,W
03142:  MOVWF  03
03144:  MOVF   01,W
03146:  ADDLW  0F
03148:  MOVWF  FE9
0314A:  MOVLW  01
0314C:  ADDWFC 03,W
0314E:  MOVWF  FEA
03150:  MOVFF  FEF,5F1
03154:  MOVFF  FEC,5F2
03158:  MOVFF  FEC,5F3
0315C:  MOVFF  FEC,5F4
03160:  MOVF   xE0,W
03162:  MULLW  19
03164:  MOVF   FF3,W
03166:  CLRF   xF6
03168:  MOVWF  xF5
0316A:  MOVLW  14
0316C:  ADDWF  xF5,W
0316E:  MOVWF  01
03170:  MOVLW  00
03172:  ADDWFC xF6,W
03174:  MOVWF  03
03176:  MOVF   01,W
03178:  ADDLW  0F
0317A:  MOVWF  FE9
0317C:  MOVLW  01
0317E:  ADDWFC 03,W
03180:  MOVWF  FEA
03182:  MOVF   FEF,W
03184:  MOVLB  6
03186:  CLRF   x31
03188:  MOVWF  x30
0318A:  MOVLB  0
0318C:  CALL   0A0E
03190:  MOVFF  5F0,62F
03194:  MOVFF  5EF,62E
03198:  MOVFF  5EE,62D
0319C:  MOVFF  5ED,62C
031A0:  MOVFF  03,633
031A4:  MOVFF  02,632
031A8:  MOVFF  01,631
031AC:  MOVFF  00,630
031B0:  CALL   0A44
031B4:  MOVFF  FEA,5F6
031B8:  MOVFF  FE9,5F5
031BC:  BCF    FD8.1
031BE:  MOVFF  5F4,633
031C2:  MOVFF  5F3,632
031C6:  MOVFF  5F2,631
031CA:  MOVFF  5F1,630
031CE:  MOVFF  03,637
031D2:  MOVFF  02,636
031D6:  MOVFF  01,635
031DA:  MOVFF  00,634
031DE:  CALL   0B3A
031E2:  MOVFF  5F6,FEA
031E6:  MOVFF  5F5,FE9
031EA:  MOVFF  03,5EC
031EE:  MOVFF  02,5EB
031F2:  MOVFF  01,5EA
031F6:  MOVFF  00,5E9
....................    
....................    adcVals[ch].pReal = (pow(pTmp*sc[ch].c5,5) + pow(pTmp*sc[ch].c4,4) + pow(pTmp*sc[ch].c3,3) + pow(pTmp*sc[ch].c2,2) + pTmp*sc[ch].c1 + sc[ch].c0);
031FA:  MOVLB  5
031FC:  MOVF   xE0,W
031FE:  MULLW  19
03200:  MOVF   FF3,W
03202:  CLRF   xF2
03204:  MOVWF  xF1
03206:  MOVLW  15
03208:  ADDWF  xF1,W
0320A:  MOVWF  01
0320C:  MOVLW  00
0320E:  ADDWFC xF2,W
03210:  MOVWF  03
03212:  MOVF   01,W
03214:  ADDLW  0F
03216:  MOVWF  01
03218:  MOVLW  01
0321A:  ADDWFC 03,F
0321C:  MOVFF  01,5F1
03220:  MOVFF  03,5F2
03224:  MOVF   xE0,W
03226:  MULLW  18
03228:  MOVF   FF3,W
0322A:  CLRF   xF4
0322C:  MOVWF  xF3
0322E:  MOVLW  14
03230:  ADDWF  xF3,W
03232:  MOVWF  01
03234:  MOVLW  00
03236:  ADDWFC xF4,W
03238:  MOVWF  03
0323A:  MOVF   01,W
0323C:  ADDLW  82
0323E:  MOVWF  FE9
03240:  MOVLW  00
03242:  ADDWFC 03,W
03244:  MOVWF  FEA
03246:  MOVFF  FEF,630
0324A:  MOVFF  FEC,01
0324E:  MOVFF  FEC,02
03252:  MOVFF  FEC,03
03256:  MOVFF  5EC,62F
0325A:  MOVFF  5EB,62E
0325E:  MOVFF  5EA,62D
03262:  MOVFF  5E9,62C
03266:  MOVFF  03,633
0326A:  MOVFF  02,632
0326E:  MOVFF  01,631
03272:  MOVLB  0
03274:  CALL   0A44
03278:  MOVFF  03,5F6
0327C:  MOVFF  02,5F5
03280:  MOVFF  01,5F4
03284:  MOVFF  00,5F3
03288:  MOVFF  03,602
0328C:  MOVFF  02,601
03290:  MOVFF  01,600
03294:  MOVFF  00,5FF
03298:  MOVLB  6
0329A:  CLRF   x06
0329C:  CLRF   x05
0329E:  MOVLW  20
032A0:  MOVWF  x04
032A2:  MOVLW  81
032A4:  MOVWF  x03
032A6:  MOVLB  0
032A8:  CALL   2A52
032AC:  MOVFF  03,5F6
032B0:  MOVFF  02,5F5
032B4:  MOVFF  01,5F4
032B8:  MOVFF  00,5F3
032BC:  MOVLB  5
032BE:  MOVF   xE0,W
032C0:  MULLW  18
032C2:  MOVF   FF3,W
032C4:  CLRF   xF8
032C6:  MOVWF  xF7
032C8:  MOVLW  10
032CA:  ADDWF  xF7,W
032CC:  MOVWF  01
032CE:  MOVLW  00
032D0:  ADDWFC xF8,W
032D2:  MOVWF  03
032D4:  MOVF   01,W
032D6:  ADDLW  82
032D8:  MOVWF  FE9
032DA:  MOVLW  00
032DC:  ADDWFC 03,W
032DE:  MOVWF  FEA
032E0:  MOVFF  FEF,630
032E4:  MOVFF  FEC,01
032E8:  MOVFF  FEC,02
032EC:  MOVFF  FEC,03
032F0:  MOVFF  5EC,62F
032F4:  MOVFF  5EB,62E
032F8:  MOVFF  5EA,62D
032FC:  MOVFF  5E9,62C
03300:  MOVFF  03,633
03304:  MOVFF  02,632
03308:  MOVFF  01,631
0330C:  MOVLB  0
0330E:  CALL   0A44
03312:  MOVFF  03,5FA
03316:  MOVFF  02,5F9
0331A:  MOVFF  01,5F8
0331E:  MOVFF  00,5F7
03322:  MOVFF  03,602
03326:  MOVFF  02,601
0332A:  MOVFF  01,600
0332E:  MOVFF  00,5FF
03332:  MOVLB  6
03334:  CLRF   x06
03336:  CLRF   x05
03338:  CLRF   x04
0333A:  MOVLW  81
0333C:  MOVWF  x03
0333E:  MOVLB  0
03340:  CALL   2A52
03344:  MOVFF  FEA,5F8
03348:  MOVFF  FE9,5F7
0334C:  BCF    FD8.1
0334E:  MOVFF  5F6,633
03352:  MOVFF  5F5,632
03356:  MOVFF  5F4,631
0335A:  MOVFF  5F3,630
0335E:  MOVFF  03,637
03362:  MOVFF  02,636
03366:  MOVFF  01,635
0336A:  MOVFF  00,634
0336E:  CALL   0B3A
03372:  MOVFF  5F8,FEA
03376:  MOVFF  5F7,FE9
0337A:  MOVFF  03,5F6
0337E:  MOVFF  02,5F5
03382:  MOVFF  01,5F4
03386:  MOVFF  00,5F3
0338A:  MOVLB  5
0338C:  MOVF   xE0,W
0338E:  MULLW  18
03390:  MOVF   FF3,W
03392:  CLRF   xFA
03394:  MOVWF  xF9
03396:  MOVLW  0C
03398:  ADDWF  xF9,W
0339A:  MOVWF  01
0339C:  MOVLW  00
0339E:  ADDWFC xFA,W
033A0:  MOVWF  03
033A2:  MOVF   01,W
033A4:  ADDLW  82
033A6:  MOVWF  FE9
033A8:  MOVLW  00
033AA:  ADDWFC 03,W
033AC:  MOVWF  FEA
033AE:  MOVFF  FEF,630
033B2:  MOVFF  FEC,01
033B6:  MOVFF  FEC,02
033BA:  MOVFF  FEC,03
033BE:  MOVFF  5EC,62F
033C2:  MOVFF  5EB,62E
033C6:  MOVFF  5EA,62D
033CA:  MOVFF  5E9,62C
033CE:  MOVFF  03,633
033D2:  MOVFF  02,632
033D6:  MOVFF  01,631
033DA:  MOVLB  0
033DC:  CALL   0A44
033E0:  MOVFF  03,5FC
033E4:  MOVFF  02,5FB
033E8:  MOVFF  01,5FA
033EC:  MOVFF  00,5F9
033F0:  MOVFF  03,602
033F4:  MOVFF  02,601
033F8:  MOVFF  01,600
033FC:  MOVFF  00,5FF
03400:  MOVLB  6
03402:  CLRF   x06
03404:  CLRF   x05
03406:  MOVLW  40
03408:  MOVWF  x04
0340A:  MOVLW  80
0340C:  MOVWF  x03
0340E:  MOVLB  0
03410:  CALL   2A52
03414:  MOVFF  FEA,5FA
03418:  MOVFF  FE9,5F9
0341C:  BCF    FD8.1
0341E:  MOVFF  5F6,633
03422:  MOVFF  5F5,632
03426:  MOVFF  5F4,631
0342A:  MOVFF  5F3,630
0342E:  MOVFF  03,637
03432:  MOVFF  02,636
03436:  MOVFF  01,635
0343A:  MOVFF  00,634
0343E:  CALL   0B3A
03442:  MOVFF  5FA,FEA
03446:  MOVFF  5F9,FE9
0344A:  MOVFF  03,5F6
0344E:  MOVFF  02,5F5
03452:  MOVFF  01,5F4
03456:  MOVFF  00,5F3
0345A:  MOVLB  5
0345C:  MOVF   xE0,W
0345E:  MULLW  18
03460:  MOVF   FF3,W
03462:  CLRF   xFC
03464:  MOVWF  xFB
03466:  MOVLW  08
03468:  ADDWF  xFB,W
0346A:  MOVWF  01
0346C:  MOVLW  00
0346E:  ADDWFC xFC,W
03470:  MOVWF  03
03472:  MOVF   01,W
03474:  ADDLW  82
03476:  MOVWF  FE9
03478:  MOVLW  00
0347A:  ADDWFC 03,W
0347C:  MOVWF  FEA
0347E:  MOVFF  FEF,630
03482:  MOVFF  FEC,01
03486:  MOVFF  FEC,02
0348A:  MOVFF  FEC,03
0348E:  MOVFF  5EC,62F
03492:  MOVFF  5EB,62E
03496:  MOVFF  5EA,62D
0349A:  MOVFF  5E9,62C
0349E:  MOVFF  03,633
034A2:  MOVFF  02,632
034A6:  MOVFF  01,631
034AA:  MOVLB  0
034AC:  CALL   0A44
034B0:  MOVFF  03,5FE
034B4:  MOVFF  02,5FD
034B8:  MOVFF  01,5FC
034BC:  MOVFF  00,5FB
034C0:  MOVFF  03,602
034C4:  MOVFF  02,601
034C8:  MOVFF  01,600
034CC:  MOVFF  00,5FF
034D0:  MOVLB  6
034D2:  CLRF   x06
034D4:  CLRF   x05
034D6:  CLRF   x04
034D8:  MOVLW  80
034DA:  MOVWF  x03
034DC:  MOVLB  0
034DE:  CALL   2A52
034E2:  MOVFF  FEA,5FC
034E6:  MOVFF  FE9,5FB
034EA:  BCF    FD8.1
034EC:  MOVFF  5F6,633
034F0:  MOVFF  5F5,632
034F4:  MOVFF  5F4,631
034F8:  MOVFF  5F3,630
034FC:  MOVFF  03,637
03500:  MOVFF  02,636
03504:  MOVFF  01,635
03508:  MOVFF  00,634
0350C:  CALL   0B3A
03510:  MOVFF  5FC,FEA
03514:  MOVFF  5FB,FE9
03518:  MOVFF  03,5F6
0351C:  MOVFF  02,5F5
03520:  MOVFF  01,5F4
03524:  MOVFF  00,5F3
03528:  MOVLB  5
0352A:  MOVF   xE0,W
0352C:  MULLW  18
0352E:  MOVF   FF3,W
03530:  CLRF   xFE
03532:  MOVWF  xFD
03534:  MOVLW  04
03536:  ADDWF  xFD,W
03538:  MOVWF  01
0353A:  MOVLW  00
0353C:  ADDWFC xFE,W
0353E:  MOVWF  03
03540:  MOVF   01,W
03542:  ADDLW  82
03544:  MOVWF  FE9
03546:  MOVLW  00
03548:  ADDWFC 03,W
0354A:  MOVWF  FEA
0354C:  MOVFF  FEF,630
03550:  MOVFF  FEC,01
03554:  MOVFF  FEC,02
03558:  MOVFF  FEC,03
0355C:  MOVFF  5EC,62F
03560:  MOVFF  5EB,62E
03564:  MOVFF  5EA,62D
03568:  MOVFF  5E9,62C
0356C:  MOVFF  03,633
03570:  MOVFF  02,632
03574:  MOVFF  01,631
03578:  MOVLB  0
0357A:  CALL   0A44
0357E:  MOVFF  FEA,5FE
03582:  MOVFF  FE9,5FD
03586:  BCF    FD8.1
03588:  MOVFF  5F6,633
0358C:  MOVFF  5F5,632
03590:  MOVFF  5F4,631
03594:  MOVFF  5F3,630
03598:  MOVFF  03,637
0359C:  MOVFF  02,636
035A0:  MOVFF  01,635
035A4:  MOVFF  00,634
035A8:  CALL   0B3A
035AC:  MOVFF  5FE,FEA
035B0:  MOVFF  5FD,FE9
035B4:  MOVFF  03,633
035B8:  MOVFF  02,632
035BC:  MOVFF  01,631
035C0:  MOVFF  00,630
035C4:  MOVLB  5
035C6:  MOVF   xE0,W
035C8:  MULLW  18
035CA:  MOVF   FF3,W
035CC:  MOVLB  6
035CE:  CLRF   x00
035D0:  MOVLB  5
035D2:  MOVWF  xFF
035D4:  MOVLW  82
035D6:  ADDWF  xFF,W
035D8:  MOVWF  FE9
035DA:  MOVLW  00
035DC:  MOVLB  6
035DE:  ADDWFC x00,W
035E0:  MOVWF  FEA
035E2:  MOVFF  FEF,634
035E6:  MOVFF  FEC,01
035EA:  MOVFF  FEC,02
035EE:  MOVFF  FEC,03
035F2:  BCF    FD8.1
035F4:  MOVFF  03,637
035F8:  MOVFF  02,636
035FC:  MOVFF  01,635
03600:  MOVLB  0
03602:  CALL   0B3A
03606:  MOVFF  5F2,FEA
0360A:  MOVFF  5F1,FE9
0360E:  MOVFF  00,FEF
03612:  MOVFF  01,FEC
03616:  MOVFF  02,FEC
0361A:  MOVFF  03,FEC
....................    
....................    PID[ch].PVold = PID[ch].PV;
0361E:  MOVLB  5
03620:  MOVF   xE0,W
03622:  MULLW  20
03624:  MOVF   FF3,W
03626:  CLRF   xF2
03628:  MOVWF  xF1
0362A:  MOVLW  14
0362C:  ADDWF  xF1,W
0362E:  MOVWF  01
03630:  MOVLW  00
03632:  ADDWFC xF2,W
03634:  MOVWF  03
03636:  MOVF   01,W
03638:  ADDLW  20
0363A:  MOVWF  01
0363C:  MOVLW  00
0363E:  ADDWFC 03,F
03640:  MOVFF  01,5F1
03644:  MOVFF  03,5F2
03648:  MOVF   xE0,W
0364A:  MULLW  20
0364C:  MOVF   FF3,W
0364E:  CLRF   xF4
03650:  MOVWF  xF3
03652:  MOVLW  10
03654:  ADDWF  xF3,W
03656:  MOVWF  01
03658:  MOVLW  00
0365A:  ADDWFC xF4,W
0365C:  MOVWF  03
0365E:  MOVF   01,W
03660:  ADDLW  20
03662:  MOVWF  FE9
03664:  MOVLW  00
03666:  ADDWFC 03,W
03668:  MOVWF  FEA
0366A:  MOVFF  FEF,00
0366E:  MOVFF  FEC,01
03672:  MOVFF  FEC,02
03676:  MOVFF  FEC,03
0367A:  MOVFF  5F2,FEA
0367E:  MOVFF  5F1,FE9
03682:  MOVFF  00,FEF
03686:  MOVFF  01,FEC
0368A:  MOVFF  02,FEC
0368E:  MOVFF  03,FEC
....................    PID[ch].PV = adcVals[ch].pReal;
03692:  MOVF   xE0,W
03694:  MULLW  20
03696:  MOVF   FF3,W
03698:  CLRF   xF2
0369A:  MOVWF  xF1
0369C:  MOVLW  10
0369E:  ADDWF  xF1,W
036A0:  MOVWF  01
036A2:  MOVLW  00
036A4:  ADDWFC xF2,W
036A6:  MOVWF  03
036A8:  MOVF   01,W
036AA:  ADDLW  20
036AC:  MOVWF  01
036AE:  MOVLW  00
036B0:  ADDWFC 03,F
036B2:  MOVFF  01,5F1
036B6:  MOVFF  03,5F2
036BA:  MOVF   xE0,W
036BC:  MULLW  19
036BE:  MOVF   FF3,W
036C0:  CLRF   xF4
036C2:  MOVWF  xF3
036C4:  MOVLW  15
036C6:  ADDWF  xF3,W
036C8:  MOVWF  01
036CA:  MOVLW  00
036CC:  ADDWFC xF4,W
036CE:  MOVWF  03
036D0:  MOVF   01,W
036D2:  ADDLW  0F
036D4:  MOVWF  FE9
036D6:  MOVLW  01
036D8:  ADDWFC 03,W
036DA:  MOVWF  FEA
036DC:  MOVFF  FEF,00
036E0:  MOVFF  FEC,01
036E4:  MOVFF  FEC,02
036E8:  MOVFF  FEC,03
036EC:  MOVFF  5F2,FEA
036F0:  MOVFF  5F1,FE9
036F4:  MOVFF  00,FEF
036F8:  MOVFF  01,FEC
036FC:  MOVFF  02,FEC
03700:  MOVFF  03,FEC
03704:  MOVLB  0
03706:  GOTO   37E2 (RETURN)
.................... }  
.................... 
.................... /*****************************************************************************/
.................... /* SENSOR MONITOR INTERRUPT TASK                                             */
.................... /* starts conversion of the other two ADCs                                   */
.................... /*****************************************************************************/
.................... void sensor_monitor_interrupt_task()
.................... {
....................    if (!smData.adcBusy)
*
001E0:  MOVLB  1
001E2:  BTFSC  x4F.1
001E4:  BRA    0218
....................    {
....................       smData.adcBusy = true;
001E6:  BSF    x4F.1
....................       switch (smData.channel)
001E8:  MOVF   x50,W
001EA:  XORLW  00
001EC:  MOVLB  0
001EE:  BZ    01F6
001F0:  XORLW  01
001F2:  BZ    0206
001F4:  BRA    0212
....................       {
....................          case 0:
....................             ads_write_command_block(1, ADSstart);
001F6:  MOVLW  01
001F8:  MOVLB  6
001FA:  MOVWF  x40
001FC:  MOVLW  08
001FE:  MOVWF  x41
00200:  MOVLB  0
00202:  RCALL  01C8
....................          break;
00204:  BRA    0212
....................          
....................          case 1:
....................             ads_write_command_block(0, ADSstart);
00206:  MOVLB  6
00208:  CLRF   x40
0020A:  MOVLW  08
0020C:  MOVWF  x41
0020E:  MOVLB  0
00210:  RCALL  01C8
....................          break;
....................       }
....................       smData.adcBusy = false;
00212:  MOVLB  1
00214:  BCF    x4F.1
....................       smData.dataReady = true;
00216:  BSF    x4F.0
....................    }
00218:  MOVLB  0
0021A:  GOTO   02DC (RETURN)
.................... }
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* SENSOR MONITOR task - gets magnetoresistive sensor counts                 */
.................... /* gets two values each time the task is run                                  */
.................... /*****************************************************************************/
.................... void sensor_monitor_task()
.................... {
....................    if (smData.dataReady)
*
0370A:  MOVLB  1
0370C:  BTFSS  x4F.0
0370E:  BRA    37E4
....................    {
....................       unsigned int32 sinRaw=0;
....................       unsigned int32 cosRaw=0;
....................       int8 ch=0;
03710:  MOVLB  5
03712:  CLRF   xDA
03714:  CLRF   xD9
03716:  CLRF   xD8
03718:  CLRF   xD7
0371A:  CLRF   xDE
0371C:  CLRF   xDD
0371E:  CLRF   xDC
03720:  CLRF   xDB
03722:  CLRF   xDF
....................       
....................       smData.adcBusy = true;
03724:  MOVLB  1
03726:  BSF    x4F.1
....................       switch (smData.channel)
03728:  MOVF   x50,W
0372A:  XORLW  00
0372C:  MOVLB  0
0372E:  BZ    3732
03730:  BRA    3774
....................       {
....................          case 0:
....................             ch = 0;
03732:  MOVLB  5
03734:  CLRF   xDF
....................             sinRaw = ads_read_data(0);
03736:  CLRF   xE0
03738:  MOVLB  0
0373A:  CALL   12F8
0373E:  MOVFF  03,5DA
03742:  MOVFF  02,5D9
03746:  MOVFF  01,5D8
0374A:  MOVFF  00,5D7
....................             cosRaw = ads_read_data(1);
0374E:  MOVLW  01
03750:  MOVLB  5
03752:  MOVWF  xE0
03754:  MOVLB  0
03756:  CALL   12F8
0375A:  MOVFF  03,5DE
0375E:  MOVFF  02,5DD
03762:  MOVFF  01,5DC
03766:  MOVFF  00,5DB
....................             smData.channel = 1;
0376A:  MOVLW  01
0376C:  MOVLB  1
0376E:  MOVWF  x50
....................          break;
03770:  BRA    37B4
03772:  MOVLB  0
....................          
....................          default:
....................             ch = 1;
03774:  MOVLW  01
03776:  MOVLB  5
03778:  MOVWF  xDF
....................             sinRaw = ads_read_data(2);
0377A:  MOVLW  02
0377C:  MOVWF  xE0
0377E:  MOVLB  0
03780:  CALL   12F8
03784:  MOVFF  03,5DA
03788:  MOVFF  02,5D9
0378C:  MOVFF  01,5D8
03790:  MOVFF  00,5D7
....................             cosRaw = ads_read_data(3);
03794:  MOVLW  03
03796:  MOVLB  5
03798:  MOVWF  xE0
0379A:  MOVLB  0
0379C:  CALL   12F8
037A0:  MOVFF  03,5DE
037A4:  MOVFF  02,5DD
037A8:  MOVFF  01,5DC
037AC:  MOVFF  00,5DB
....................             smData.channel = 0;
037B0:  MOVLB  1
037B2:  CLRF   x50
....................          break;
....................       }
....................       smData.adcBusy = false;
037B4:  BCF    x4F.1
....................       smData.dataReady = false;
037B6:  BCF    x4F.0
....................       sensor_process_data(ch, sinRaw, cosRaw);
037B8:  MOVFF  5DF,5E0
037BC:  MOVFF  5DA,5E4
037C0:  MOVFF  5D9,5E3
037C4:  MOVFF  5D8,5E2
037C8:  MOVFF  5D7,5E1
037CC:  MOVFF  5DE,5E8
037D0:  MOVFF  5DD,5E7
037D4:  MOVFF  5DC,5E6
037D8:  MOVFF  5DB,5E5
037DC:  MOVLB  0
037DE:  GOTO   2D50
037E2:  MOVLB  1
....................    }
037E4:  MOVLB  0
037E6:  GOTO   75EA (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* INITIALIZE ADC's                                                          */
.................... /*****************************************************************************/
.................... void setup_external_ADCs()
*
00716:  MOVLB  5
00718:  CLRF   xD7
0071A:  CLRF   xD8
0071C:  CLRF   xD9
0071E:  CLRF   xDA
.................... {
....................    unsigned int8 rc0=0;
....................    unsigned int8 rc1=0;
....................    unsigned int8 rc2=0;
....................    unsigned int8 rc3=0;
....................    
....................    for(int ch = 0; ch < 4; ch++)
00720:  CLRF   xDB
00722:  MOVF   xDB,W
00724:  SUBLW  03
00726:  BNC   0754
....................    {
....................       switch (magPP)
....................       {         
....................          case 1:
....................             rc0=KMXP1000reg0config;
00728:  MOVLW  38
0072A:  MOVWF  xD7
....................             rc1=KMXP1000reg1config;
0072C:  MOVLW  10
0072E:  MOVWF  xD8
....................             rc2=KMXP1000reg2config;
00730:  MOVLW  30
00732:  MOVWF  xD9
....................             rc3=KMXP1000reg3config;
00734:  CLRF   xDA
....................          break;
....................          
....................          case 2:
....................             rc0=KMXP2000reg0config;
....................             rc1=KMXP2000reg1config;
....................             rc2=KMXP2000reg2config;
....................             rc3=KMXP2000reg3config;
....................          break;
....................          
....................          default:
....................             rc0=reg0config;
....................             rc1=reg1config;
....................             rc2=reg2config;
....................             rc3=reg3config;      
....................          break;
....................       }
....................       ADS1220init(ch, rc0, rc1, rc2, rc3);
00736:  MOVFF  5DB,5DC
0073A:  MOVFF  5D7,5DD
0073E:  MOVFF  5D8,5DE
00742:  MOVFF  5D9,5DF
00746:  MOVFF  5DA,5E0
0074A:  MOVLB  0
0074C:  BRA    06B4
0074E:  MOVLB  5
00750:  INCF   xDB,F
00752:  BRA    0722
....................    }   
00754:  MOVLB  0
00756:  GOTO   07BA (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE MONITOR -- sets up ADC channels                                */
.................... /*****************************************************************************/
.................... void monitor_init()
.................... {
....................    setup_adc_ports(sAN6 | sAN16 | sAN17 | sAN24 | sAN25 | sAN26 | sAN27, NO_ANALOGS_P2, VSS_VDD);
0075A:  MOVLW  00
0075C:  MOVLB  F
0075E:  MOVWF  x53
00760:  MOVLW  40
00762:  MOVWF  x0C
00764:  MOVLW  00
00766:  MOVWF  x14
00768:  MOVLW  03
0076A:  MOVWF  x1C
0076C:  MOVLW  0F
0076E:  MOVWF  x21
00770:  MOVLW  00
00772:  MOVWF  x29
....................    setup_adc(ADC_CLOCK_INTERNAL | ADC_TAD_MUL_255 | ADC_LEGACY_MODE | ADC_THRESHOLD_INT_DISABLED);
00774:  MOVLW  08
00776:  MOVWF  x55
00778:  CLRF   x56
0077A:  CLRF   x52
0077C:  SETF   x57
0077E:  CLRF   F61
00780:  MOVLW  94
00782:  MOVWF  x5B
....................    output_high(EN_EXC);
00784:  MOVLW  E8
00786:  MOVWF  F8B
00788:  BSF    F86.0
....................    set_adc_channel(vMonN15); // internal MUX
0078A:  MOVF   x5A,W
0078C:  ANDLW  3F
0078E:  MOVWF  01
00790:  MOVLW  06
00792:  MOVWF  x5A
00794:  BTFSS  x5B.7
00796:  BRA    07A6
00798:  MOVF   01,W
0079A:  SUBLW  06
0079C:  BZ    07A6
0079E:  BSF    x5B.0
007A0:  NOP   
007A2:  BTFSC  x5B.0
007A4:  BRA    07A2
....................    delay_ms(10);
007A6:  MOVLW  0A
007A8:  MOVLB  5
007AA:  MOVWF  xDA
007AC:  MOVLB  0
007AE:  RCALL  03A8
....................    read_adc(ADC_START_ONLY);
007B0:  MOVLB  F
007B2:  BSF    x5B.0
007B4:  NOP   
....................    setup_external_ADCs();
007B6:  MOVLB  0
007B8:  BRA    0716
....................    intTimeoutReg = sensorSampleRate;
007BA:  MOVLB  1
007BC:  CLRF   x4E
007BE:  MOVLW  32
007C0:  MOVWF  x4D
007C2:  MOVLB  0
007C4:  GOTO   75D2 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <control.h>
.................... #ifndef control
.................... #define control
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... //!typedef enum sensorType {kmxp1000, kmxp2000}; // Magsensors
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2];
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = 
.................... {
....................    {0,1}, {0,1}, {0,1}, {0,1}, {0,1}, {0,1}, {0,1}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals;
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;    // adc raw count data
....................    float cosRaw;    // adc raw count data
....................    float sinCounts; // calibrated counts
....................    float cosCounts; // calibrated counts
....................    float p0;               // position in units of pole-pitch
....................    int8  npoles;           // number of poles passed
....................    float pReal;            // real position
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0},
....................    {0,0,0,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... #pin_select SCK1=PIN_C3
.................... #pin_select SDO1=PIN_C2
.................... #use spi (MASTER, SPI1, BAUD=100000, MODE=0, STREAM=SPI_ctrl)
007C8:  CLRF   03
007CA:  MOVF   F91,W
007CC:  MOVFF  5DC,F91
007D0:  RRCF   F94,W
007D2:  BNC   07D0
007D4:  MOVF   F91,W
007D6:  MOVWF  02
007D8:  MOVFF  5DB,F91
007DC:  RRCF   F94,W
007DE:  BNC   07DC
007E0:  MOVF   F91,W
007E2:  MOVWF  01
007E4:  MOVFF  5DA,F91
007E8:  RRCF   F94,W
007EA:  BNC   07E8
007EC:  MOVFF  F91,00
007F0:  RETURN 0
.................... 
.................... #define DACfullScale 655.35 // full scale/100 because CV = %
.................... 
.................... /*****************************************************************************/
.................... /*  Inverts the output voltage ( -180V - 0V )                                */ 
.................... /*****************************************************************************/
.................... void invert_voltage(channelMap ch, BOOLEAN inv_v){
....................    if ( inv_v ) {
*
03820:  MOVLB  5
03822:  MOVF   xDB,F
03824:  BZ    3850
....................       if (chMap[0] == ch) output_low(INV_HVX);
03826:  MOVLW  00
03828:  MOVLB  0
0382A:  BTFSC  x60.0
0382C:  MOVLW  01
0382E:  MOVLB  5
03830:  SUBWF  xDA,W
03832:  BNZ   383A
03834:  MOVLW  C4
03836:  MOVWF  F88
03838:  BCF    F83.4
....................       if (chMap[1] == ch) output_low(INV_HVY);
0383A:  MOVLW  00
0383C:  MOVLB  0
0383E:  BTFSC  x60.1
03840:  MOVLW  01
03842:  MOVLB  5
03844:  SUBWF  xDA,W
03846:  BNZ   384E
03848:  MOVLW  C4
0384A:  MOVWF  F88
0384C:  BCF    F83.5
....................    }
0384E:  BRA    3878
....................    else {
....................       if (chMap[0] == ch) output_high(INV_HVX);
03850:  MOVLW  00
03852:  MOVLB  0
03854:  BTFSC  x60.0
03856:  MOVLW  01
03858:  MOVLB  5
0385A:  SUBWF  xDA,W
0385C:  BNZ   3864
0385E:  MOVLW  C4
03860:  MOVWF  F88
03862:  BSF    F83.4
....................       if (chMap[1] == ch) output_high(INV_HVY);
03864:  MOVLW  00
03866:  MOVLB  0
03868:  BTFSC  x60.1
0386A:  MOVLW  01
0386C:  MOVLB  5
0386E:  SUBWF  xDA,W
03870:  BNZ   3878
03872:  MOVLW  C4
03874:  MOVWF  F88
03876:  BSF    F83.5
....................    }
03878:  MOVLB  0
0387A:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  Nano DAC's have a 16bit serial shift register. Data is sync'ed to output */ 
.................... /*****************************************************************************/
.................... void set_nanoDAC_outputs(channelMap ch){
0387C:  MOVLB  5
0387E:  CLRF   xD9
03880:  CLRF   xD8
....................    unsigned int16 txData = 0;
....................    
....................    // use manualOutputValues if channel is manual mode
....................    // else, use PID control variable
....................    if (chMode[ch] == MANUAL){
03882:  MOVFF  5D7,5E4
03886:  CLRF   xE6
03888:  MOVLW  61
0388A:  MOVWF  xE5
0388C:  MOVLB  0
0388E:  RCALL  37EA
03890:  MOVF   01,F
03892:  BNZ   3962
....................       if ( manualOutputValues[ch] < 0) invert_voltage(ch, TRUE); 
03894:  MOVLB  5
03896:  MOVF   xD7,W
03898:  MULLW  04
0389A:  MOVF   FF3,W
0389C:  CLRF   03
0389E:  ADDLW  EA
038A0:  MOVWF  FE9
038A2:  MOVLW  00
038A4:  ADDWFC 03,W
038A6:  MOVWF  FEA
038A8:  MOVFF  FEF,62C
038AC:  MOVFF  FEC,62D
038B0:  MOVFF  FEC,62E
038B4:  MOVFF  FEC,62F
038B8:  MOVLB  6
038BA:  CLRF   x33
038BC:  CLRF   x32
038BE:  CLRF   x31
038C0:  CLRF   x30
038C2:  MOVLB  0
038C4:  CALL   1376
038C8:  BNC   38DA
038CA:  MOVFF  5D7,5DA
038CE:  MOVLW  01
038D0:  MOVLB  5
038D2:  MOVWF  xDB
038D4:  MOVLB  0
038D6:  RCALL  3820
038D8:  BRA    38E6
....................       else                             invert_voltage(ch, FALSE);
038DA:  MOVFF  5D7,5DA
038DE:  MOVLB  5
038E0:  CLRF   xDB
038E2:  MOVLB  0
038E4:  RCALL  3820
....................       
....................       txData = (unsigned int16)(abs(manualOutputValues[ch]) * DACfullScale);
038E6:  MOVLB  5
038E8:  MOVF   xD7,W
038EA:  MULLW  04
038EC:  MOVF   FF3,W
038EE:  CLRF   03
038F0:  ADDLW  EA
038F2:  MOVWF  FE9
038F4:  MOVLW  00
038F6:  ADDWFC 03,W
038F8:  MOVWF  FEA
038FA:  MOVFF  FEF,00
038FE:  MOVFF  FEC,01
03902:  MOVFF  FEC,02
03906:  MOVFF  FEC,03
0390A:  BCF    01.7
0390C:  MOVFF  03,5DD
03910:  MOVFF  02,5DC
03914:  MOVFF  01,5DB
03918:  MOVFF  00,5DA
0391C:  MOVFF  03,62F
03920:  MOVFF  02,62E
03924:  MOVFF  01,62D
03928:  MOVFF  00,62C
0392C:  MOVLW  66
0392E:  MOVLB  6
03930:  MOVWF  x33
03932:  MOVLW  D6
03934:  MOVWF  x32
03936:  MOVLW  23
03938:  MOVWF  x31
0393A:  MOVLW  88
0393C:  MOVWF  x30
0393E:  MOVLB  0
03940:  CALL   0A44
03944:  MOVFF  03,62F
03948:  MOVFF  02,62E
0394C:  MOVFF  01,62D
03950:  MOVFF  00,62C
03954:  CALL   1D1A
03958:  MOVFF  02,5D9
0395C:  MOVFF  01,5D8
....................    }
03960:  BRA    3A4E
....................    else {
....................       if ( PID[(int)ch].CV < 0) invert_voltage(ch, TRUE); 
03962:  MOVLB  5
03964:  MOVF   xD7,W
03966:  MULLW  20
03968:  MOVF   FF3,W
0396A:  CLRF   xDB
0396C:  MOVWF  xDA
0396E:  MOVLW  18
03970:  ADDWF  xDA,W
03972:  MOVWF  01
03974:  MOVLW  00
03976:  ADDWFC xDB,W
03978:  MOVWF  03
0397A:  MOVF   01,W
0397C:  ADDLW  20
0397E:  MOVWF  FE9
03980:  MOVLW  00
03982:  ADDWFC 03,W
03984:  MOVWF  FEA
03986:  MOVFF  FEF,62C
0398A:  MOVFF  FEC,62D
0398E:  MOVFF  FEC,62E
03992:  MOVFF  FEC,62F
03996:  MOVLB  6
03998:  CLRF   x33
0399A:  CLRF   x32
0399C:  CLRF   x31
0399E:  CLRF   x30
039A0:  MOVLB  0
039A2:  CALL   1376
039A6:  BNC   39B8
039A8:  MOVFF  5D7,5DA
039AC:  MOVLW  01
039AE:  MOVLB  5
039B0:  MOVWF  xDB
039B2:  MOVLB  0
039B4:  RCALL  3820
039B6:  BRA    39C4
....................       else                      invert_voltage(ch, FALSE);
039B8:  MOVFF  5D7,5DA
039BC:  MOVLB  5
039BE:  CLRF   xDB
039C0:  MOVLB  0
039C2:  RCALL  3820
....................       
....................       txData = (unsigned int16)(abs(PID[(int)ch].CV) * DACfullScale);
039C4:  MOVLB  5
039C6:  MOVF   xD7,W
039C8:  MULLW  20
039CA:  MOVF   FF3,W
039CC:  CLRF   xDB
039CE:  MOVWF  xDA
039D0:  MOVLW  18
039D2:  ADDWF  xDA,W
039D4:  MOVWF  01
039D6:  MOVLW  00
039D8:  ADDWFC xDB,W
039DA:  MOVWF  03
039DC:  MOVF   01,W
039DE:  ADDLW  20
039E0:  MOVWF  FE9
039E2:  MOVLW  00
039E4:  ADDWFC 03,W
039E6:  MOVWF  FEA
039E8:  MOVFF  FEF,00
039EC:  MOVFF  FEC,01
039F0:  MOVFF  FEC,02
039F4:  MOVFF  FEC,03
039F8:  BCF    01.7
039FA:  MOVFF  03,5DD
039FE:  MOVFF  02,5DC
03A02:  MOVFF  01,5DB
03A06:  MOVFF  00,5DA
03A0A:  MOVFF  03,62F
03A0E:  MOVFF  02,62E
03A12:  MOVFF  01,62D
03A16:  MOVFF  00,62C
03A1A:  MOVLW  66
03A1C:  MOVLB  6
03A1E:  MOVWF  x33
03A20:  MOVLW  D6
03A22:  MOVWF  x32
03A24:  MOVLW  23
03A26:  MOVWF  x31
03A28:  MOVLW  88
03A2A:  MOVWF  x30
03A2C:  MOVLB  0
03A2E:  CALL   0A44
03A32:  MOVFF  03,62F
03A36:  MOVFF  02,62E
03A3A:  MOVFF  01,62D
03A3E:  MOVFF  00,62C
03A42:  CALL   1D1A
03A46:  MOVFF  02,5D9
03A4A:  MOVFF  01,5D8
....................    }
....................       
....................    // use channel map to decide which outputs channels to update
....................    // strobe _sync low to push data to the outputs
....................    if (chMap[0] == ch) output_high(_SYNC_X);
03A4E:  MOVLW  00
03A50:  BTFSC  x60.0
03A52:  MOVLW  01
03A54:  MOVLB  5
03A56:  SUBWF  xD7,W
03A58:  BNZ   3A60
03A5A:  MOVLW  E8
03A5C:  MOVWF  F8B
03A5E:  BSF    F86.2
....................    if (chMap[1] == ch) output_high(_SYNC_Y);
03A60:  MOVLW  00
03A62:  MOVLB  0
03A64:  BTFSC  x60.1
03A66:  MOVLW  01
03A68:  MOVLB  5
03A6A:  SUBWF  xD7,W
03A6C:  BNZ   3A74
03A6E:  MOVLW  E8
03A70:  MOVWF  F8B
03A72:  BSF    F86.1
....................    
....................    delay_ms(1);
03A74:  MOVLW  01
03A76:  MOVWF  xDA
03A78:  MOVLB  0
03A7A:  CALL   03A8
....................    
....................    if (chMap[0] == ch) output_low(_SYNC_X);
03A7E:  MOVLW  00
03A80:  BTFSC  x60.0
03A82:  MOVLW  01
03A84:  MOVLB  5
03A86:  SUBWF  xD7,W
03A88:  BNZ   3A90
03A8A:  MOVLW  E8
03A8C:  MOVWF  F8B
03A8E:  BCF    F86.2
....................    if (chMap[1] == ch) output_low(_SYNC_Y);
03A90:  MOVLW  00
03A92:  MOVLB  0
03A94:  BTFSC  x60.1
03A96:  MOVLW  01
03A98:  MOVLB  5
03A9A:  SUBWF  xD7,W
03A9C:  BNZ   3AA4
03A9E:  MOVLW  E8
03AA0:  MOVWF  F8B
03AA2:  BCF    F86.1
....................    
....................    // shift 16 bits of data
....................    spi_xfer(SPI_ctrl, txData, 24);
03AA4:  CLRF   xDD
03AA6:  CLRF   xDC
03AA8:  MOVFF  5D9,5DB
03AAC:  MOVFF  5D8,5DA
03AB0:  MOVLB  0
03AB2:  CALL   07C8
....................    
....................    delay_ms(1);
03AB6:  MOVLW  01
03AB8:  MOVLB  5
03ABA:  MOVWF  xDA
03ABC:  MOVLB  0
03ABE:  CALL   03A8
....................    
....................    if (chMap[0] == ch) output_high(_SYNC_X);
03AC2:  MOVLW  00
03AC4:  BTFSC  x60.0
03AC6:  MOVLW  01
03AC8:  MOVLB  5
03ACA:  SUBWF  xD7,W
03ACC:  BNZ   3AD4
03ACE:  MOVLW  E8
03AD0:  MOVWF  F8B
03AD2:  BSF    F86.2
....................    if (chMap[1] == ch) output_high(_SYNC_Y);
03AD4:  MOVLW  00
03AD6:  MOVLB  0
03AD8:  BTFSC  x60.1
03ADA:  MOVLW  01
03ADC:  MOVLB  5
03ADE:  SUBWF  xD7,W
03AE0:  BNZ   3AE8
03AE2:  MOVLW  E8
03AE4:  MOVWF  F8B
03AE6:  BSF    F86.1
03AE8:  MOVLB  0
03AEA:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  control task sets up the outputs channels                                */ 
.................... /*****************************************************************************/
.................... void control_task(){
....................    static int state = 0;
....................    
....................    switch (state)
03AEC:  MOVLB  1
03AEE:  MOVF   x52,W
03AF0:  XORLW  00
03AF2:  MOVLB  0
03AF4:  BZ    3AF8
03AF6:  BRA    3B0A
....................    {
....................       case 0:       
....................          set_nanoDAC_outputs(chX);
03AF8:  MOVLB  5
03AFA:  CLRF   xD7
03AFC:  MOVLB  0
03AFE:  RCALL  387C
....................          state = 1;
03B00:  MOVLW  01
03B02:  MOVLB  1
03B04:  MOVWF  x52
....................       break;
03B06:  BRA    3B18
03B08:  MOVLB  0
....................       default:
....................          set_nanoDAC_outputs(chY);
03B0A:  MOVLW  01
03B0C:  MOVLB  5
03B0E:  MOVWF  xD7
03B10:  MOVLB  0
03B12:  RCALL  387C
....................          state = 0;
03B14:  MOVLB  1
03B16:  CLRF   x52
....................       break;
....................    }
03B18:  MOVLB  0
03B1A:  GOTO   75EE (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  control task sets up the outputs channels                                */ 
.................... /*****************************************************************************/
.................... void control_init(){
....................    spi_xfer(SPI_ctrl, 0, 24);
*
007F2:  MOVLB  5
007F4:  CLRF   xDD
007F6:  CLRF   xDC
007F8:  CLRF   xDB
007FA:  CLRF   xDA
007FC:  MOVLB  0
007FE:  RCALL  07C8
....................    output_low(_SYNC_X);
00800:  MOVLW  E8
00802:  MOVWF  F8B
00804:  BCF    F86.2
....................    output_low(_SYNC_Y);
00806:  MOVWF  F8B
00808:  BCF    F86.1
....................    output_high(_SYNC_X);
0080A:  MOVWF  F8B
0080C:  BSF    F86.2
....................    output_high(_SYNC_Y);
0080E:  MOVWF  F8B
00810:  BSF    F86.1
00812:  GOTO   75D6 (RETURN)
.................... }
.................... #endif
.................... 
.................... #include <serialport.h>
.................... #ifndef serialPort
.................... #define serialPort
.................... #include <cmdBuffer.h>
.................... #ifndef cmd_buffer
.................... #define cmd_buffer
.................... 
.................... /*****************************************************************************/
.................... /* DIFCS COMMAND BUFFER                                                      */
.................... /* The beginning of a message is signified by an address record. The address */
.................... /* is 4 characters. The first 2 are the hardware identifier (TC - temperature*/
.................... /* controller, DC - difics controller, etc..) The second 2 characters dev-   */
.................... /* ice ID... Valid values are 00 thru 0F. A device ID of FF writes to all    */
.................... /* boards. This might be used to feed angles data to all listeners.          */
.................... /*****************************************************************************/
.................... 
.................... // t,p0,p1,p2,p3,p4,p5,p6
.................... // t is the start character, p0 is the address, p1 is command, p2-6 are params
.................... // these characters used for storing messages
.................... 
.................... #define startChr '~' // start character. Also diagnostic command type
.................... #define diagCmdType startChr
.................... #define endChr '\n'
.................... #define delimiter ','
.................... #define ignoreChr1 '\r'
.................... #define ignoreChr2 ' '
.................... #define noRecordFound (char)0xFF
.................... 
.................... #define numRecords 4
.................... #define numParam 7
.................... #define lenParam 25
.................... 
.................... #define useSerial
.................... //#define useTCPIP
.................... 
.................... typedef enum cmdMode {tcp, ser};
.................... 
.................... // this structure holds a command. This is used by the serial routine as well
.................... // as the TCP routine to store an incoming command + parameters
.................... // in the case of TCP socket id is also passed in this structure
.................... typedef struct cmd 
.................... {
....................    BOOLEAN full;        // if full, command is ready to execute
....................    unsigned int8 chrIndex;
....................    unsigned int8 paramIndex;
....................    unsigned int8 recReadIndex;
....................    unsigned int8 recWriteIndex;
....................    #ifdef useTCPIP
....................    TCP_SOCKET s;              // socket ID for TCP commands 
....................    #endif
....................    char t;
....................    char p[numParam][lenParam];   // only used with ~ type command
.................... };
.................... 
.................... #ifdef useSerial
.................... struct cmd SERcmd[numRecords]; // holds serial command 
.................... unsigned int8 SRI = 0; //usb readindex
.................... unsigned int8 SWI = 0; //usb write index
.................... #endif
.................... 
.................... #ifdef useTCPIP
.................... struct cmd TCPcmd[numRecords]; // holds TCP command
.................... unsigned int8 TRI = 0; //usb readindex
.................... unsigned int8 TWI = 0; //usb write index
.................... #endif
.................... 
.................... char retData[100]; // this is used to hold return data 
.................... 
.................... #ifdef useSerial
.................... /*****************************************************************************/
.................... /* RESET SER COMMAND -- ready for a new command                              */
.................... /*****************************************************************************/
.................... void resetSERcmd(unsigned int8 recNum)
.................... {
....................    if (recNum < numRecords)
*
00838:  MOVLB  5
0083A:  MOVF   xD8,W
0083C:  SUBLW  03
0083E:  BTFSS  FD8.0
00840:  BRA    09AE
....................    {
....................       for (int i = 0; i <numParam; i ++)
00842:  CLRF   xD9
00844:  MOVF   xD9,W
00846:  SUBLW  06
00848:  BNC   0898
....................       {
....................          SERcmd[recNum].p[i][0] = '\0';
0084A:  CLRF   xFB
0084C:  MOVFF  5D8,5FA
00850:  CLRF   xFD
00852:  MOVLW  B5
00854:  MOVWF  xFC
00856:  MOVLB  0
00858:  RCALL  0816
0085A:  MOVFF  02,5DB
0085E:  MOVFF  01,5DA
00862:  MOVLW  06
00864:  MOVLB  5
00866:  ADDWF  xDA,F
00868:  MOVLW  00
0086A:  ADDWFC xDB,F
0086C:  CLRF   xFB
0086E:  MOVFF  5D9,5FA
00872:  CLRF   xFD
00874:  MOVLW  19
00876:  MOVWF  xFC
00878:  MOVLB  0
0087A:  RCALL  0816
0087C:  MOVF   01,W
0087E:  MOVLB  5
00880:  ADDWF  xDA,F
00882:  MOVF   02,W
00884:  ADDWFC xDB,F
00886:  MOVLW  53
00888:  ADDWF  xDA,W
0088A:  MOVWF  FE9
0088C:  MOVLW  01
0088E:  ADDWFC xDB,W
00890:  MOVWF  FEA
00892:  CLRF   FEF
00894:  INCF   xD9,F
00896:  BRA    0844
....................       }
....................       SERcmd[recNum].t = 0;
00898:  CLRF   xFB
0089A:  MOVFF  5D8,5FA
0089E:  CLRF   xFD
008A0:  MOVLW  B5
008A2:  MOVWF  xFC
008A4:  MOVLB  0
008A6:  RCALL  0816
008A8:  MOVFF  01,5DA
008AC:  MOVLW  05
008AE:  MOVLB  5
008B0:  ADDWF  01,W
008B2:  MOVWF  01
008B4:  MOVLW  00
008B6:  ADDWFC 02,W
008B8:  MOVWF  03
008BA:  MOVF   01,W
008BC:  ADDLW  53
008BE:  MOVWF  FE9
008C0:  MOVLW  01
008C2:  ADDWFC 03,W
008C4:  MOVWF  FEA
008C6:  CLRF   FEF
....................       SERcmd[recNum].chrIndex = 0;
008C8:  CLRF   xFB
008CA:  MOVFF  5D8,5FA
008CE:  CLRF   xFD
008D0:  MOVLW  B5
008D2:  MOVWF  xFC
008D4:  MOVLB  0
008D6:  RCALL  0816
008D8:  MOVFF  01,5DA
008DC:  MOVLW  01
008DE:  MOVLB  5
008E0:  ADDWF  01,W
008E2:  MOVWF  01
008E4:  MOVLW  00
008E6:  ADDWFC 02,W
008E8:  MOVWF  03
008EA:  MOVF   01,W
008EC:  ADDLW  53
008EE:  MOVWF  FE9
008F0:  MOVLW  01
008F2:  ADDWFC 03,W
008F4:  MOVWF  FEA
008F6:  CLRF   FEF
....................       SERcmd[recNum].paramIndex = 0;
008F8:  CLRF   xFB
008FA:  MOVFF  5D8,5FA
008FE:  CLRF   xFD
00900:  MOVLW  B5
00902:  MOVWF  xFC
00904:  MOVLB  0
00906:  RCALL  0816
00908:  MOVFF  01,5DA
0090C:  MOVLW  02
0090E:  MOVLB  5
00910:  ADDWF  01,W
00912:  MOVWF  01
00914:  MOVLW  00
00916:  ADDWFC 02,W
00918:  MOVWF  03
0091A:  MOVF   01,W
0091C:  ADDLW  53
0091E:  MOVWF  FE9
00920:  MOVLW  01
00922:  ADDWFC 03,W
00924:  MOVWF  FEA
00926:  CLRF   FEF
....................       SERcmd[recNum].recReadIndex = 0;
00928:  CLRF   xFB
0092A:  MOVFF  5D8,5FA
0092E:  CLRF   xFD
00930:  MOVLW  B5
00932:  MOVWF  xFC
00934:  MOVLB  0
00936:  RCALL  0816
00938:  MOVFF  01,5DA
0093C:  MOVLW  03
0093E:  MOVLB  5
00940:  ADDWF  01,W
00942:  MOVWF  01
00944:  MOVLW  00
00946:  ADDWFC 02,W
00948:  MOVWF  03
0094A:  MOVF   01,W
0094C:  ADDLW  53
0094E:  MOVWF  FE9
00950:  MOVLW  01
00952:  ADDWFC 03,W
00954:  MOVWF  FEA
00956:  CLRF   FEF
....................       SERcmd[recNum].recWriteIndex = 0;
00958:  CLRF   xFB
0095A:  MOVFF  5D8,5FA
0095E:  CLRF   xFD
00960:  MOVLW  B5
00962:  MOVWF  xFC
00964:  MOVLB  0
00966:  RCALL  0816
00968:  MOVFF  01,5DA
0096C:  MOVLW  04
0096E:  MOVLB  5
00970:  ADDWF  01,W
00972:  MOVWF  01
00974:  MOVLW  00
00976:  ADDWFC 02,W
00978:  MOVWF  03
0097A:  MOVF   01,W
0097C:  ADDLW  53
0097E:  MOVWF  FE9
00980:  MOVLW  01
00982:  ADDWFC 03,W
00984:  MOVWF  FEA
00986:  CLRF   FEF
....................       SERcmd[recNum].full = FALSE;
00988:  CLRF   xFB
0098A:  MOVFF  5D8,5FA
0098E:  CLRF   xFD
00990:  MOVLW  B5
00992:  MOVWF  xFC
00994:  MOVLB  0
00996:  RCALL  0816
00998:  MOVLW  53
0099A:  MOVLB  5
0099C:  ADDWF  01,W
0099E:  MOVWF  FE9
009A0:  MOVLW  01
009A2:  ADDWFC 02,W
009A4:  MOVWF  FEA
009A6:  BCF    FEF.0
....................       retData[0] = '\0';
009A8:  MOVLB  4
009AA:  CLRF   x29
009AC:  MOVLB  5
....................    }
009AE:  MOVLB  0
009B0:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next serial read index (SRI)                                          */
.................... /*****************************************************************************/
.................... BOOLEAN getNextSERReadIndex()
.................... {
....................    while (!SERcmd[SRI].full)
*
040A8:  MOVLB  5
040AA:  CLRF   xFB
040AC:  MOVFF  427,5FA
040B0:  CLRF   xFD
040B2:  MOVLW  B5
040B4:  MOVWF  xFC
040B6:  MOVLB  0
040B8:  CALL   0816
040BC:  MOVFF  02,5D9
040C0:  MOVFF  01,5D8
040C4:  MOVLW  53
040C6:  MOVLB  5
040C8:  ADDWF  01,W
040CA:  MOVWF  FE9
040CC:  MOVLW  01
040CE:  ADDWFC 02,W
040D0:  MOVWF  FEA
040D2:  BTFSC  FEF.0
040D4:  BRA    40F6
....................    {
....................       if (SRI == SWI) return FALSE;
040D6:  MOVLB  4
040D8:  MOVF   x28,W
040DA:  SUBWF  x27,W
040DC:  BNZ   40E4
040DE:  MOVLW  00
040E0:  MOVWF  01
040E2:  BRA    40FC
....................       SRI +=1;
040E4:  MOVLW  01
040E6:  ADDWF  x27,F
....................       if (SRI >= numRecords) SRI=0;
040E8:  MOVF   x27,W
040EA:  SUBLW  03
040EC:  BC    40F0
040EE:  CLRF   x27
040F0:  MOVLB  0
040F2:  BRA    40A8
040F4:  MOVLB  5
....................    }
....................    return TRUE;
040F6:  MOVLW  01
040F8:  MOVWF  01
040FA:  MOVLB  4
040FC:  MOVLB  0
040FE:  GOTO   7186 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next serial write index (SWI)                                         */
.................... /*****************************************************************************/
.................... void setNextSERWriteIndex()
.................... {
....................    SWI +=1;
*
03B52:  MOVLW  01
03B54:  MOVLB  4
03B56:  ADDWF  x28,F
....................    if (SWI >= numRecords) SWI=0;
03B58:  MOVF   x28,W
03B5A:  SUBLW  03
03B5C:  BC    3B60
03B5E:  CLRF   x28
03B60:  MOVLB  0
03B62:  RETURN 0
.................... }
.................... #endif
.................... 
.................... #ifdef useTCPIP
.................... /*****************************************************************************/
.................... /* RESET TCP COMMAND -- ready for a new command                              */
.................... /*****************************************************************************/
.................... void resetTCPcmd(unsigned int8 recNum)
.................... {
....................    if(recNum < numRecords)
....................    {
....................       for (int i = 0; i <numParam; i ++)
....................       {
....................          TCPcmd[recNum].p[i][0] = '\0';
....................       }
....................       TCPcmd[recNum].t = 0;
....................       TCPcmd[recNum].chrIndex = 0;
....................       TCPcmd[recNum].paramIndex = 0;
....................       TCPcmd[recNum].full = FALSE;
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next TCP read index (TRI)                                             */
.................... /*****************************************************************************/
.................... BOOLEAN getNextTCPReadIndex()
.................... {
....................    while (!TCPcmd[TRI].full)
....................    {
....................       if (TRI == TWI) return FALSE;
....................       TRI +=1;
....................       if (TRI >= numRecords) TRI=0;
....................    }
....................    return TRUE;
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next TCP write index (TWI)                                            */
.................... /*****************************************************************************/
.................... void setNextTCPWriteIndex()
.................... {
....................    TWI +=1;
....................    if (TWI >= numRecords) TWI=0;
.................... }
.................... #endif
.................... #endif
.................... 
.................... 
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
....................    output_b(portB_reset);
....................    output_c(portC_reset);
....................    output_d(portD_reset);
....................    output_e(portE_reset);
....................    
....................    port_a_pullups(portA_pullups);
....................    port_b_pullups(portB_pullups);
....................    port_c_pullups(portC_pullups);
....................    port_d_pullups(portD_pullups);
....................    port_e_pullups(portE_pullups);
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... #define use_RS485 // adds RX enable pin//
.................... 
.................... #define oneByteCmdTestValue 128
.................... #define UART_BUFFER_SIZE 60
.................... #define UART_EOT_CHAR1 0x0D //Carriage Return
.................... #define UART_EOT_CHAR2 0x0A //Line Feed
.................... #define UART_SOT_CHAR  '~' // START CHARACTER
.................... #define line_turnaround_char 0xFF
.................... 
.................... #bit UART_TXBuffer_Empty = 0x0FAC.1
.................... 
.................... char UART_BUFFER[UART_BUFFER_SIZE] = {0};
.................... unsigned int8 UART_WR_PTR = 0;
.................... unsigned int8 UART_RD_PTR = 0;
.................... boolean BYTES_AVAILABLE= FALSE;
.................... 
.................... #ifdef use_RS485
.................... #use rs232(baud=baudRate, xmit=TX_PIN, rcv=RX_PIN, enable=TX_ENABLE, stream=SERIAL, ERRORS)
*
000CA:  MOVLB  E
000CC:  BTFSS  xC8.5
000CE:  BRA    00CC
000D0:  MOVFF  F9C,4CC
000D4:  MOVLB  4
000D6:  MOVFF  F98,01
000DA:  BTFSS  xCC.1
000DC:  BRA    00E2
000DE:  BCF    F9C.4
000E0:  BSF    F9C.4
000E2:  MOVLB  0
000E4:  GOTO   010C (RETURN)
*
03B64:  MOVLW  93
03B66:  MOVWF  F89
03B68:  BSF    F84.5
03B6A:  MOVLB  E
03B6C:  BTFSS  xC8.4
03B6E:  BRA    3B6C
03B70:  MOVLW  93
03B72:  MOVWF  F89
03B74:  BSF    F84.5
03B76:  MOVLB  5
03B78:  MOVFF  5DE,F99
03B7C:  NOP   
03B7E:  BTFSS  F9D.1
03B80:  BRA    3B7E
03B82:  MOVLW  93
03B84:  MOVWF  F89
03B86:  BCF    F84.5
03B88:  MOVLB  0
03B8A:  RETURN 0
.................... #else
.................... #use rs232(baud=baudRate, xmit=TX_PIN, rcv=RX_PIN, stream=SERIAL)
.................... #endif
.................... 
.................... // Message format: [SOT]addr ,cmd, arg1, arg2, arg3[EOT]} 
.................... // arguments are optional
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* SERIAL PORT ISR                                                           */
.................... /*****************************************************************************/
.................... #INT_RDA
.................... void RX_isr()
*
000E8:  MOVLB  0
.................... {
....................    while (kbhit())
000EA:  MOVLB  E
000EC:  BTFSS  xC8.5
000EE:  BRA    012E
....................    {
....................       UART_BUFFER[UART_WR_PTR]=getch();
000F0:  CLRF   03
000F2:  MOVLB  4
000F4:  MOVF   xC9,W
000F6:  ADDLW  8D
000F8:  MOVWF  FE9
000FA:  MOVLW  04
000FC:  ADDWFC 03,W
000FE:  MOVWF  FEA
00100:  MOVFF  FEA,643
00104:  MOVFF  FE9,642
00108:  MOVLB  0
0010A:  BRA    00CA
0010C:  MOVFF  643,FEA
00110:  MOVFF  642,FE9
00114:  MOVFF  01,FEF
....................       UART_WR_PTR +=1;
00118:  MOVLW  01
0011A:  MOVLB  4
0011C:  ADDWF  xC9,F
....................       if (UART_WR_PTR>=UART_BUFFER_SIZE) UART_WR_PTR=0;
0011E:  MOVF   xC9,W
00120:  SUBLW  3B
00122:  BC    0126
00124:  CLRF   xC9
....................       BYTES_AVAILABLE=TRUE;
00126:  BSF    xCB.0
00128:  MOVLB  0
0012A:  BRA    00EA
0012C:  MOVLB  E
....................    }
0012E:  BCF    xC8.5
00130:  MOVLB  0
00132:  GOTO   006E
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get character from buffer                                                 */
.................... /*****************************************************************************/
.................... char getchFromBuffer()
*
03B1E:  CLRF   03
03B20:  MOVLB  4
03B22:  MOVF   xCA,W
03B24:  ADDLW  8D
03B26:  MOVWF  FE9
03B28:  MOVLW  04
03B2A:  ADDWFC 03,W
03B2C:  MOVWF  FEA
03B2E:  MOVFF  FEF,5D8
.................... {
....................    char data = UART_BUFFER[UART_RD_PTR];
....................    UART_RD_PTR +=1;
03B32:  MOVLW  01
03B34:  ADDWF  xCA,F
....................    if (UART_RD_PTR>=UART_BUFFER_SIZE) UART_RD_PTR=0;
03B36:  MOVF   xCA,W
03B38:  SUBLW  3B
03B3A:  BC    3B3E
03B3C:  CLRF   xCA
....................    if (UART_RD_PTR == UART_WR_PTR) BYTES_AVAILABLE=FALSE;
03B3E:  MOVF   xC9,W
03B40:  SUBWF  xCA,W
03B42:  BNZ   3B46
03B44:  BCF    xCB.0
....................    return data;
03B46:  MOVLB  5
03B48:  MOVFF  5D8,01
03B4C:  MOVLB  0
03B4E:  GOTO   3BF2 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Serial Task transfers bytes to command buffer                             */
.................... /*****************************************************************************/
.................... void serial_task()
.................... {
....................    while(BYTES_AVAILABLE && SERcmd[SWI].full==FALSE)
*
03BB0:  MOVLB  4
03BB2:  BTFSS  xCB.0
03BB4:  BRA    40A2
03BB6:  MOVLB  5
03BB8:  CLRF   xFB
03BBA:  MOVFF  428,5FA
03BBE:  CLRF   xFD
03BC0:  MOVLW  B5
03BC2:  MOVWF  xFC
03BC4:  MOVLB  0
03BC6:  CALL   0816
03BCA:  MOVFF  02,5D9
03BCE:  MOVFF  01,5D8
03BD2:  MOVLW  53
03BD4:  MOVLB  5
03BD6:  ADDWF  01,W
03BD8:  MOVWF  01
03BDA:  MOVLW  01
03BDC:  ADDWFC 02,W
03BDE:  MOVWF  03
03BE0:  MOVFF  01,FE9
03BE4:  MOVWF  FEA
03BE6:  BTFSS  FEF.0
03BE8:  BRA    3BEE
03BEA:  MOVLB  4
03BEC:  BRA    40A2
....................    {  
....................       unsigned int8 rxChar = getchFromBuffer();
03BEE:  MOVLB  0
03BF0:  BRA    3B1E
03BF2:  MOVFF  01,5D7
....................       if (rxChar == ignoreChr1 || rxChar == ignoreChr2)
03BF6:  MOVLB  5
03BF8:  MOVF   xD7,W
03BFA:  SUBLW  0D
03BFC:  BZ    3C04
03BFE:  MOVF   xD7,W
03C00:  SUBLW  20
03C02:  BNZ   3C06
....................       {
....................       }
03C04:  BRA    409C
....................       else if (rxChar == UART_SOT_CHAR)
03C06:  MOVF   xD7,W
03C08:  SUBLW  7E
03C0A:  BNZ   3C4E
....................       {
....................          resetSERcmd(SWI);
03C0C:  MOVFF  428,5D8
03C10:  MOVLB  0
03C12:  CALL   0838
....................          SERcmd[SWI].t = rxChar;
03C16:  MOVLB  5
03C18:  CLRF   xFB
03C1A:  MOVFF  428,5FA
03C1E:  CLRF   xFD
03C20:  MOVLW  B5
03C22:  MOVWF  xFC
03C24:  MOVLB  0
03C26:  CALL   0816
03C2A:  MOVFF  01,5D8
03C2E:  MOVLW  05
03C30:  MOVLB  5
03C32:  ADDWF  01,W
03C34:  MOVWF  01
03C36:  MOVLW  00
03C38:  ADDWFC 02,W
03C3A:  MOVWF  03
03C3C:  MOVF   01,W
03C3E:  ADDLW  53
03C40:  MOVWF  FE9
03C42:  MOVLW  01
03C44:  ADDWFC 03,W
03C46:  MOVWF  FEA
03C48:  MOVFF  5D7,FEF
....................       }
03C4C:  BRA    409C
....................       else if (rxChar >= oneByteCmdTestValue)
03C4E:  MOVF   xD7,W
03C50:  SUBLW  7F
03C52:  BC    3CBE
....................       {
....................          resetSERcmd(SWI);
03C54:  MOVFF  428,5D8
03C58:  MOVLB  0
03C5A:  CALL   0838
....................          SERcmd[SWI].t = rxChar;
03C5E:  MOVLB  5
03C60:  CLRF   xFB
03C62:  MOVFF  428,5FA
03C66:  CLRF   xFD
03C68:  MOVLW  B5
03C6A:  MOVWF  xFC
03C6C:  MOVLB  0
03C6E:  CALL   0816
03C72:  MOVFF  01,5D8
03C76:  MOVLW  05
03C78:  MOVLB  5
03C7A:  ADDWF  01,W
03C7C:  MOVWF  01
03C7E:  MOVLW  00
03C80:  ADDWFC 02,W
03C82:  MOVWF  03
03C84:  MOVF   01,W
03C86:  ADDLW  53
03C88:  MOVWF  FE9
03C8A:  MOVLW  01
03C8C:  ADDWFC 03,W
03C8E:  MOVWF  FEA
03C90:  MOVFF  5D7,FEF
....................          SERcmd[SWI].full = TRUE;
03C94:  CLRF   xFB
03C96:  MOVFF  428,5FA
03C9A:  CLRF   xFD
03C9C:  MOVLW  B5
03C9E:  MOVWF  xFC
03CA0:  MOVLB  0
03CA2:  CALL   0816
03CA6:  MOVLW  53
03CA8:  MOVLB  5
03CAA:  ADDWF  01,W
03CAC:  MOVWF  FE9
03CAE:  MOVLW  01
03CB0:  ADDWFC 02,W
03CB2:  MOVWF  FEA
03CB4:  BSF    FEF.0
....................          setNextSERWriteIndex();
03CB6:  MOVLB  0
03CB8:  RCALL  3B52
....................       }
03CBA:  BRA    409A
03CBC:  MOVLB  5
....................       else if (rxChar == UART_EOT_CHAR2)
03CBE:  MOVF   xD7,W
03CC0:  SUBLW  0A
03CC2:  BTFSS  FD8.2
03CC4:  BRA    3DCA
....................       {
....................          SERcmd[SWI].full = TRUE;
03CC6:  CLRF   xFB
03CC8:  MOVFF  428,5FA
03CCC:  CLRF   xFD
03CCE:  MOVLW  B5
03CD0:  MOVWF  xFC
03CD2:  MOVLB  0
03CD4:  CALL   0816
03CD8:  MOVLW  53
03CDA:  MOVLB  5
03CDC:  ADDWF  01,W
03CDE:  MOVWF  FE9
03CE0:  MOVLW  01
03CE2:  ADDWFC 02,W
03CE4:  MOVWF  FEA
03CE6:  BSF    FEF.0
....................          SERcmd[SWI].recWriteIndex = SERcmd[SWI].paramIndex;
03CE8:  CLRF   xFB
03CEA:  MOVFF  428,5FA
03CEE:  CLRF   xFD
03CF0:  MOVLW  B5
03CF2:  MOVWF  xFC
03CF4:  MOVLB  0
03CF6:  CALL   0816
03CFA:  MOVFF  01,5D8
03CFE:  MOVLW  04
03D00:  MOVLB  5
03D02:  ADDWF  01,W
03D04:  MOVWF  01
03D06:  MOVLW  00
03D08:  ADDWFC 02,W
03D0A:  MOVWF  03
03D0C:  MOVF   01,W
03D0E:  ADDLW  53
03D10:  MOVWF  01
03D12:  MOVLW  01
03D14:  ADDWFC 03,F
03D16:  MOVFF  01,5D8
03D1A:  MOVFF  03,5D9
03D1E:  CLRF   xFB
03D20:  MOVFF  428,5FA
03D24:  CLRF   xFD
03D26:  MOVLW  B5
03D28:  MOVWF  xFC
03D2A:  MOVLB  0
03D2C:  CALL   0816
03D30:  MOVFF  01,5DA
03D34:  MOVLW  02
03D36:  MOVLB  5
03D38:  ADDWF  01,W
03D3A:  MOVWF  01
03D3C:  MOVLW  00
03D3E:  ADDWFC 02,W
03D40:  MOVWF  03
03D42:  MOVF   01,W
03D44:  ADDLW  53
03D46:  MOVWF  FE9
03D48:  MOVLW  01
03D4A:  ADDWFC 03,W
03D4C:  MOVWF  FEA
03D4E:  MOVFF  FEF,5DA
03D52:  MOVFF  5D9,FEA
03D56:  MOVFF  5D8,FE9
03D5A:  MOVFF  5DA,FEF
....................          SERcmd[SWI].chrIndex = 0;
03D5E:  CLRF   xFB
03D60:  MOVFF  428,5FA
03D64:  CLRF   xFD
03D66:  MOVLW  B5
03D68:  MOVWF  xFC
03D6A:  MOVLB  0
03D6C:  CALL   0816
03D70:  MOVFF  01,5D8
03D74:  MOVLW  01
03D76:  MOVLB  5
03D78:  ADDWF  01,W
03D7A:  MOVWF  01
03D7C:  MOVLW  00
03D7E:  ADDWFC 02,W
03D80:  MOVWF  03
03D82:  MOVF   01,W
03D84:  ADDLW  53
03D86:  MOVWF  FE9
03D88:  MOVLW  01
03D8A:  ADDWFC 03,W
03D8C:  MOVWF  FEA
03D8E:  CLRF   FEF
....................          SERcmd[SWI].paramIndex = 0;
03D90:  CLRF   xFB
03D92:  MOVFF  428,5FA
03D96:  CLRF   xFD
03D98:  MOVLW  B5
03D9A:  MOVWF  xFC
03D9C:  MOVLB  0
03D9E:  CALL   0816
03DA2:  MOVFF  01,5D8
03DA6:  MOVLW  02
03DA8:  MOVLB  5
03DAA:  ADDWF  01,W
03DAC:  MOVWF  01
03DAE:  MOVLW  00
03DB0:  ADDWFC 02,W
03DB2:  MOVWF  03
03DB4:  MOVF   01,W
03DB6:  ADDLW  53
03DB8:  MOVWF  FE9
03DBA:  MOVLW  01
03DBC:  ADDWFC 03,W
03DBE:  MOVWF  FEA
03DC0:  CLRF   FEF
....................          setNextSERWriteIndex();
03DC2:  MOVLB  0
03DC4:  RCALL  3B52
....................       }
03DC6:  BRA    409A
03DC8:  MOVLB  5
....................       else if (rxChar == delimiter)
03DCA:  MOVF   xD7,W
03DCC:  SUBLW  2C
03DCE:  BNZ   3E8C
....................       {
....................          if (SERcmd[SWI].paramIndex < numParam-1)
03DD0:  CLRF   xFB
03DD2:  MOVFF  428,5FA
03DD6:  CLRF   xFD
03DD8:  MOVLW  B5
03DDA:  MOVWF  xFC
03DDC:  MOVLB  0
03DDE:  CALL   0816
03DE2:  MOVFF  02,5D9
03DE6:  MOVFF  01,5D8
03DEA:  MOVLW  02
03DEC:  MOVLB  5
03DEE:  ADDWF  01,W
03DF0:  MOVWF  01
03DF2:  MOVLW  00
03DF4:  ADDWFC 02,W
03DF6:  MOVWF  03
03DF8:  MOVF   01,W
03DFA:  ADDLW  53
03DFC:  MOVWF  FE9
03DFE:  MOVLW  01
03E00:  ADDWFC 03,W
03E02:  MOVWF  FEA
03E04:  MOVF   FEF,W
03E06:  SUBLW  05
03E08:  BNC   3E74
....................          {
....................             SERcmd[SWI].paramIndex +=1;
03E0A:  CLRF   xFB
03E0C:  MOVFF  428,5FA
03E10:  CLRF   xFD
03E12:  MOVLW  B5
03E14:  MOVWF  xFC
03E16:  MOVLB  0
03E18:  CALL   0816
03E1C:  MOVFF  01,5D8
03E20:  MOVLW  02
03E22:  MOVLB  5
03E24:  ADDWF  01,W
03E26:  MOVWF  01
03E28:  MOVLW  00
03E2A:  ADDWFC 02,W
03E2C:  MOVWF  03
03E2E:  MOVF   01,W
03E30:  ADDLW  53
03E32:  MOVWF  FE9
03E34:  MOVLW  01
03E36:  ADDWFC 03,W
03E38:  MOVWF  FEA
03E3A:  MOVLW  01
03E3C:  ADDWF  FEF,W
03E3E:  MOVWF  FEF
....................             SERcmd[SWI].chrIndex = 0;
03E40:  CLRF   xFB
03E42:  MOVFF  428,5FA
03E46:  CLRF   xFD
03E48:  MOVLW  B5
03E4A:  MOVWF  xFC
03E4C:  MOVLB  0
03E4E:  CALL   0816
03E52:  MOVFF  01,5D8
03E56:  MOVLW  01
03E58:  MOVLB  5
03E5A:  ADDWF  01,W
03E5C:  MOVWF  01
03E5E:  MOVLW  00
03E60:  ADDWFC 02,W
03E62:  MOVWF  03
03E64:  MOVF   01,W
03E66:  ADDLW  53
03E68:  MOVWF  FE9
03E6A:  MOVLW  01
03E6C:  ADDWFC 03,W
03E6E:  MOVWF  FEA
03E70:  CLRF   FEF
....................          }
03E72:  BRA    3E8A
....................          else
....................          {
....................             resetSERcmd(SWI); // exceed number of params... reset capture
03E74:  MOVFF  428,5D8
03E78:  MOVLB  0
03E7A:  CALL   0838
....................             fprintf(SERIAL, retData);
03E7E:  MOVLW  04
03E80:  MOVWF  FEA
03E82:  MOVLW  29
03E84:  MOVWF  FE9
03E86:  RCALL  3B8C
03E88:  MOVLB  5
....................          }
....................       }
03E8A:  BRA    409C
....................       
....................       else
....................       {
....................          if (SERcmd[SWI].chrIndex < lenParam)
03E8C:  CLRF   xFB
03E8E:  MOVFF  428,5FA
03E92:  CLRF   xFD
03E94:  MOVLW  B5
03E96:  MOVWF  xFC
03E98:  MOVLB  0
03E9A:  CALL   0816
03E9E:  MOVFF  02,5D9
03EA2:  MOVFF  01,5D8
03EA6:  MOVLW  01
03EA8:  MOVLB  5
03EAA:  ADDWF  01,W
03EAC:  MOVWF  01
03EAE:  MOVLW  00
03EB0:  ADDWFC 02,W
03EB2:  MOVWF  03
03EB4:  MOVF   01,W
03EB6:  ADDLW  53
03EB8:  MOVWF  FE9
03EBA:  MOVLW  01
03EBC:  ADDWFC 03,W
03EBE:  MOVWF  FEA
03EC0:  MOVF   FEF,W
03EC2:  SUBLW  18
03EC4:  BTFSS  FD8.0
03EC6:  BRA    4086
....................          {
....................             SERcmd[SWI].p[SERcmd[SWI].paramIndex][SERcmd[SWI].chrIndex] = rxChar;
03EC8:  CLRF   xFB
03ECA:  MOVFF  428,5FA
03ECE:  CLRF   xFD
03ED0:  MOVLW  B5
03ED2:  MOVWF  xFC
03ED4:  MOVLB  0
03ED6:  CALL   0816
03EDA:  MOVFF  02,5D9
03EDE:  MOVFF  01,5D8
03EE2:  MOVLW  06
03EE4:  MOVLB  5
03EE6:  ADDWF  xD8,F
03EE8:  MOVLW  00
03EEA:  ADDWFC xD9,F
03EEC:  CLRF   xFB
03EEE:  MOVFF  428,5FA
03EF2:  CLRF   xFD
03EF4:  MOVLW  B5
03EF6:  MOVWF  xFC
03EF8:  MOVLB  0
03EFA:  CALL   0816
03EFE:  MOVFF  02,5DB
03F02:  MOVFF  01,5DA
03F06:  MOVLW  02
03F08:  MOVLB  5
03F0A:  ADDWF  01,W
03F0C:  MOVWF  01
03F0E:  MOVLW  00
03F10:  ADDWFC 02,W
03F12:  MOVWF  03
03F14:  MOVF   01,W
03F16:  ADDLW  53
03F18:  MOVWF  FE9
03F1A:  MOVLW  01
03F1C:  ADDWFC 03,W
03F1E:  MOVWF  FEA
03F20:  CLRF   xFB
03F22:  MOVFF  FEF,5FA
03F26:  CLRF   xFD
03F28:  MOVLW  19
03F2A:  MOVWF  xFC
03F2C:  MOVLB  0
03F2E:  CALL   0816
03F32:  MOVFF  02,03
03F36:  MOVF   01,W
03F38:  MOVLB  5
03F3A:  ADDWF  xD8,F
03F3C:  MOVF   02,W
03F3E:  ADDWFC xD9,F
03F40:  CLRF   xFB
03F42:  MOVFF  428,5FA
03F46:  CLRF   xFD
03F48:  MOVLW  B5
03F4A:  MOVWF  xFC
03F4C:  MOVLB  0
03F4E:  CALL   0816
03F52:  MOVFF  01,5DA
03F56:  MOVLW  01
03F58:  MOVLB  5
03F5A:  ADDWF  01,W
03F5C:  MOVWF  01
03F5E:  MOVLW  00
03F60:  ADDWFC 02,W
03F62:  MOVWF  03
03F64:  MOVF   01,W
03F66:  ADDLW  53
03F68:  MOVWF  FE9
03F6A:  MOVLW  01
03F6C:  ADDWFC 03,W
03F6E:  MOVWF  FEA
03F70:  MOVF   FEF,W
03F72:  ADDWF  xD8,W
03F74:  MOVWF  01
03F76:  MOVLW  00
03F78:  ADDWFC xD9,W
03F7A:  MOVWF  03
03F7C:  MOVF   01,W
03F7E:  ADDLW  53
03F80:  MOVWF  FE9
03F82:  MOVLW  01
03F84:  ADDWFC 03,W
03F86:  MOVWF  FEA
03F88:  MOVFF  5D7,FEF
....................             SERcmd[SWI].chrIndex += 1;
03F8C:  CLRF   xFB
03F8E:  MOVFF  428,5FA
03F92:  CLRF   xFD
03F94:  MOVLW  B5
03F96:  MOVWF  xFC
03F98:  MOVLB  0
03F9A:  CALL   0816
03F9E:  MOVFF  01,5D8
03FA2:  MOVLW  01
03FA4:  MOVLB  5
03FA6:  ADDWF  01,W
03FA8:  MOVWF  01
03FAA:  MOVLW  00
03FAC:  ADDWFC 02,W
03FAE:  MOVWF  03
03FB0:  MOVF   01,W
03FB2:  ADDLW  53
03FB4:  MOVWF  FE9
03FB6:  MOVLW  01
03FB8:  ADDWFC 03,W
03FBA:  MOVWF  FEA
03FBC:  MOVLW  01
03FBE:  ADDWF  FEF,W
03FC0:  MOVWF  FEF
....................             SERcmd[SWI].p[SERcmd[SWI].paramIndex][SERcmd[SWI].chrIndex] = '\0';
03FC2:  CLRF   xFB
03FC4:  MOVFF  428,5FA
03FC8:  CLRF   xFD
03FCA:  MOVLW  B5
03FCC:  MOVWF  xFC
03FCE:  MOVLB  0
03FD0:  CALL   0816
03FD4:  MOVFF  02,5D9
03FD8:  MOVFF  01,5D8
03FDC:  MOVLW  06
03FDE:  MOVLB  5
03FE0:  ADDWF  xD8,F
03FE2:  MOVLW  00
03FE4:  ADDWFC xD9,F
03FE6:  CLRF   xFB
03FE8:  MOVFF  428,5FA
03FEC:  CLRF   xFD
03FEE:  MOVLW  B5
03FF0:  MOVWF  xFC
03FF2:  MOVLB  0
03FF4:  CALL   0816
03FF8:  MOVFF  02,5DB
03FFC:  MOVFF  01,5DA
04000:  MOVLW  02
04002:  MOVLB  5
04004:  ADDWF  01,W
04006:  MOVWF  01
04008:  MOVLW  00
0400A:  ADDWFC 02,W
0400C:  MOVWF  03
0400E:  MOVF   01,W
04010:  ADDLW  53
04012:  MOVWF  FE9
04014:  MOVLW  01
04016:  ADDWFC 03,W
04018:  MOVWF  FEA
0401A:  CLRF   xFB
0401C:  MOVFF  FEF,5FA
04020:  CLRF   xFD
04022:  MOVLW  19
04024:  MOVWF  xFC
04026:  MOVLB  0
04028:  CALL   0816
0402C:  MOVFF  02,03
04030:  MOVF   01,W
04032:  MOVLB  5
04034:  ADDWF  xD8,F
04036:  MOVF   02,W
04038:  ADDWFC xD9,F
0403A:  CLRF   xFB
0403C:  MOVFF  428,5FA
04040:  CLRF   xFD
04042:  MOVLW  B5
04044:  MOVWF  xFC
04046:  MOVLB  0
04048:  CALL   0816
0404C:  MOVFF  01,5DA
04050:  MOVLW  01
04052:  MOVLB  5
04054:  ADDWF  01,W
04056:  MOVWF  01
04058:  MOVLW  00
0405A:  ADDWFC 02,W
0405C:  MOVWF  03
0405E:  MOVF   01,W
04060:  ADDLW  53
04062:  MOVWF  FE9
04064:  MOVLW  01
04066:  ADDWFC 03,W
04068:  MOVWF  FEA
0406A:  MOVF   FEF,W
0406C:  ADDWF  xD8,W
0406E:  MOVWF  01
04070:  MOVLW  00
04072:  ADDWFC xD9,W
04074:  MOVWF  03
04076:  MOVF   01,W
04078:  ADDLW  53
0407A:  MOVWF  FE9
0407C:  MOVLW  01
0407E:  ADDWFC 03,W
04080:  MOVWF  FEA
04082:  CLRF   FEF
....................          }
04084:  BRA    409C
....................          else
....................          {
....................             resetSERcmd(SWI); // exceed number of characters... reset capture
04086:  MOVFF  428,5D8
0408A:  MOVLB  0
0408C:  CALL   0838
....................             fprintf(SERIAL, retData);
04090:  MOVLW  04
04092:  MOVWF  FEA
04094:  MOVLW  29
04096:  MOVWF  FE9
04098:  RCALL  3B8C
0409A:  MOVLB  5
....................          }
....................       }
0409C:  MOVLB  0
0409E:  BRA    3BB0
040A0:  MOVLB  4
....................    }          
040A2:  MOVLB  0
040A4:  GOTO   75F2 (RETURN)
.................... }
....................            
.................... /*****************************************************************************/
.................... /* serialInit ROUTINE  - Sets up serial port                                 */
.................... /*****************************************************************************/ 
.................... void serial_init()
.................... {
....................    for (int i = 0; i < numRecords; i++) 
*
009B2:  MOVLB  5
009B4:  CLRF   xD7
009B6:  MOVF   xD7,W
009B8:  SUBLW  03
009BA:  BNC   09CA
....................    {
....................       resetSERcmd(i);
009BC:  MOVFF  5D7,5D8
009C0:  MOVLB  0
009C2:  RCALL  0838
009C4:  MOVLB  5
009C6:  INCF   xD7,F
009C8:  BRA    09B6
....................    }
....................    enable_interrupts(INT_RDA);
009CA:  MOVLB  E
009CC:  BSF    xC0.5
009CE:  MOVLB  0
009D0:  GOTO   75DA (RETURN)
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #include <pid.h>
.................... #ifndef pidcontroller
.................... #define pidcontroller
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... //!typedef enum sensorType {kmxp1000, kmxp2000}; // Magsensors
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2];
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = 
.................... {
....................    {0,1}, {0,1}, {0,1}, {0,1}, {0,1}, {0,1}, {0,1}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals;
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;    // adc raw count data
....................    float cosRaw;    // adc raw count data
....................    float sinCounts; // calibrated counts
....................    float cosCounts; // calibrated counts
....................    float p0;               // position in units of pole-pitch
....................    int8  npoles;           // number of poles passed
....................    float pReal;            // real position
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0},
....................    {0,0,0,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float32)(unsigned int16)y;
.................... 
....................  else if (y < 10000000.0)
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
....................       res = 32768.0*(float32)l;
....................       res += (float32)(unsigned int16)y;
....................    }
.................... 
....................  else
....................   res = y;
.................... 
....................  y = y - (float32)(unsigned int16)y;
.................... 
....................  if (s)
....................   res = -res;
.................... 
....................  if (y != 0)
....................  {
....................   if (s == 1 && n == 0)
....................    res -= 1.0;
.................... 
....................   if (s == 0 && n == 1)
....................    res += 1.0;
....................  }
....................  if (x == 0)
....................     res = 0;
.................... 
....................  return (res);
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl[0]*y2 + pl[1];
.................... 
....................       r = ql[0]*y2 + ql[1];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
....................          r = -(float32)-n;
....................       else
....................          r = (float32)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* UPDATE the Control Variable (CV)                                          */
.................... /*****************************************************************************/
.................... void pid_update (channelMap ch){
....................    float err = PID[ch].SP - PID[ch].PV;   // error = set value - measured
....................    PID[ch].I += (err * PID[ch].kI);       // integral value 
....................    float P = err * PID[ch].kP;            // proportional value
....................    float D = PID[ch].kD * (PID[ch].PV - PID[ch].PVold); // derivative value
....................    PID[ch].CV = P + PID[ch].I + D;        // new control variable
....................    if (PID[ch].CV > 100) 
....................    {
....................       PID[ch].CV = 100;// limit output to 100%
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PID Task - looks for change to PV and updates CV                          */
.................... /*****************************************************************************/
.................... void pid_task(channelMap ch){
....................    static int index = 0;
....................    if (adcVals[ch].pReal != PID[ch].PV) pid_update(ch);
....................    if ((index++) >= numChannels) index = 0;
.................... }
.................... 
.................... #endif
.................... 
.................... #include <eventTimer.h>
.................... #ifndef timeout
.................... #define timeout
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... //!typedef enum sensorType {kmxp1000, kmxp2000}; // Magsensors
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2];
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = 
.................... {
....................    {0,1}, {0,1}, {0,1}, {0,1}, {0,1}, {0,1}, {0,1}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals;
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;    // adc raw count data
....................    float cosRaw;    // adc raw count data
....................    float sinCounts; // calibrated counts
....................    float cosCounts; // calibrated counts
....................    float p0;               // position in units of pole-pitch
....................    int8  npoles;           // number of poles passed
....................    float pReal;            // real position
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0},
....................    {0,0,0,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/           
.................... /* Global timers used by all routnes                                         */
.................... /* timeoutReg0-2 are used for timeouts. Other routines monitor the value of  */
.................... /* intTimeoutReg. On boot, they will be loaded from EEProm. Any              */
.................... /* configuration changes will be changed in EEprom, hence will be restored on*/
.................... /* subsequent boot.                                                          */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* Register definitions                                                      */
.................... /*****************************************************************************/
.................... //!unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... //!unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... //!unsigned int32 timeoutReg2 = 0;
.................... //!unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... unsigned int32 timeCounter = 0;
.................... 
.................... /*****************************************************************************/
.................... /* TIMEOUT_INIT initializes the timer                                        */
.................... /*****************************************************************************/
.................... void event_timer_init()
.................... {        
....................    disable_interrupts(INT_TIMER1);
009D4:  MOVLB  E
009D6:  BCF    xC1.0
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_1);
009D8:  MOVLW  01
009DA:  MOVWF  FD1
009DC:  MOVLW  07
009DE:  MOVWF  FCE
009E0:  CLRF   FCF
009E2:  CLRF   FD0
....................    timeoutReg0 = 0;  // clear all the timers
009E4:  MOVLB  1
009E6:  CLRF   x44
009E8:  CLRF   x43
009EA:  CLRF   x42
009EC:  CLRF   x41
....................    timeoutReg1 = 0;
009EE:  CLRF   x48
009F0:  CLRF   x47
009F2:  CLRF   x46
009F4:  CLRF   x45
....................    timeoutReg2 = 0;
009F6:  CLRF   x4C
009F8:  CLRF   x4B
009FA:  CLRF   x4A
009FC:  CLRF   x49
....................    intTimeoutReg = 50;
009FE:  CLRF   x4E
00A00:  MOVLW  32
00A02:  MOVWF  x4D
....................    enable_interrupts(INT_TIMER1);
00A04:  MOVLB  E
00A06:  BSF    xC1.0
00A08:  MOVLB  0
00A0A:  GOTO   75DE (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* TIMEOUT INTERRUPT decrements the timeout registers every second           */
.................... /*****************************************************************************/
.................... #INT_TIMER1
.................... void TIMER1_isr(void) 
*
0021E:  MOVLB  0
.................... {
....................    set_timer1(0x0BDB); // load timer register to allow 10 millisecond interupts
00220:  MOVLW  0B
00222:  MOVWF  FCD
00224:  MOVLW  DB
00226:  MOVWF  FCC
00228:  NOP   
....................    if (timeoutReg0 > 10) timeoutReg0 -= 10; else timeoutReg0 = 0;
0022A:  MOVLB  1
0022C:  MOVF   x44,F
0022E:  BNZ   023E
00230:  MOVF   x43,F
00232:  BNZ   023E
00234:  MOVF   x42,F
00236:  BNZ   023E
00238:  MOVF   x41,W
0023A:  SUBLW  0A
0023C:  BC    024C
0023E:  MOVLW  0A
00240:  SUBWF  x41,F
00242:  MOVLW  00
00244:  SUBWFB x42,F
00246:  SUBWFB x43,F
00248:  SUBWFB x44,F
0024A:  BRA    0254
0024C:  CLRF   x44
0024E:  CLRF   x43
00250:  CLRF   x42
00252:  CLRF   x41
....................    if (timeoutReg1 > 10) timeoutReg1 -= 10; else timeoutReg1 = 0;
00254:  MOVF   x48,F
00256:  BNZ   0266
00258:  MOVF   x47,F
0025A:  BNZ   0266
0025C:  MOVF   x46,F
0025E:  BNZ   0266
00260:  MOVF   x45,W
00262:  SUBLW  0A
00264:  BC    0274
00266:  MOVLW  0A
00268:  SUBWF  x45,F
0026A:  MOVLW  00
0026C:  SUBWFB x46,F
0026E:  SUBWFB x47,F
00270:  SUBWFB x48,F
00272:  BRA    027C
00274:  CLRF   x48
00276:  CLRF   x47
00278:  CLRF   x46
0027A:  CLRF   x45
....................    if (timeoutReg2 > 10) timeoutReg2 -= 10; else timeoutReg2 = 0;
0027C:  MOVF   x4C,F
0027E:  BNZ   028E
00280:  MOVF   x4B,F
00282:  BNZ   028E
00284:  MOVF   x4A,F
00286:  BNZ   028E
00288:  MOVF   x49,W
0028A:  SUBLW  0A
0028C:  BC    029C
0028E:  MOVLW  0A
00290:  SUBWF  x49,F
00292:  MOVLW  00
00294:  SUBWFB x4A,F
00296:  SUBWFB x4B,F
00298:  SUBWFB x4C,F
0029A:  BRA    02A4
0029C:  CLRF   x4C
0029E:  CLRF   x4B
002A0:  CLRF   x4A
002A2:  CLRF   x49
....................    if (intTimeoutReg != 0) // INTERRUPTING TIMER
002A4:  MOVF   x4D,F
002A6:  BNZ   02AC
002A8:  MOVF   x4E,F
002AA:  BZ    02E8
....................    {
....................       timeCounter+=10;
002AC:  MOVLW  0A
002AE:  MOVLB  4
002B0:  ADDWF  xD0,F
002B2:  MOVLW  00
002B4:  ADDWFC xD1,F
002B6:  ADDWFC xD2,F
002B8:  ADDWFC xD3,F
....................       if (timeCounter >= intTimeoutReg)
002BA:  MOVF   xD3,F
002BC:  BNZ   02D8
002BE:  MOVF   xD2,F
002C0:  BNZ   02D8
002C2:  MOVLB  1
002C4:  MOVF   x4E,W
002C6:  MOVLB  4
002C8:  SUBWF  xD1,W
002CA:  BNC   02E6
002CC:  BNZ   02D8
002CE:  MOVLB  1
002D0:  MOVF   x4D,W
002D2:  MOVLB  4
002D4:  SUBWF  xD0,W
002D6:  BNC   02E6
....................       {
....................          sensor_monitor_interrupt_task();
002D8:  MOVLB  0
002DA:  BRA    01E0
....................          timeCounter = 0;
002DC:  MOVLB  4
002DE:  CLRF   xD3
002E0:  CLRF   xD2
002E2:  CLRF   xD1
002E4:  CLRF   xD0
002E6:  MOVLB  1
....................       }
....................    }
.................... }
.................... 
.................... #endif
.................... 
.................... #include <commandHandler.c>
.................... #ifndef cmdHandlerC
.................... #define cmdHandlerC
.................... #include <commandHandler.h>
.................... #ifndef cmdHandler
.................... #define cmdHandler
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... //!typedef enum sensorType {kmxp1000, kmxp2000}; // Magsensors
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2];
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = 
.................... {
....................    {0,1}, {0,1}, {0,1}, {0,1}, {0,1}, {0,1}, {0,1}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals;
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;    // adc raw count data
....................    float cosRaw;    // adc raw count data
....................    float sinCounts; // calibrated counts
....................    float cosCounts; // calibrated counts
....................    float p0;               // position in units of pole-pitch
....................    int8  npoles;           // number of poles passed
....................    float pReal;            // real position
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0},
....................    {0,0,0,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... 
002E8:  MOVLB  E
002EA:  BCF    xC9.0
002EC:  MOVLB  0
002EE:  GOTO   006E
.................... #define hwID 'D'   // DiFCS
.................... 
.................... /*****************************************************************************/
.................... /* RESPONSE MESSAGES                                                         */
.................... /*****************************************************************************/
.................... typedef struct response {
....................    int8 id;
....................    char *msg;
.................... } resp;
.................... 
.................... //!#define INVALID_DATA "error - invalid data"
.................... //!#define invalidTime "error - invalid TO value"
.................... //!#define overrun "error - buffer overrun"
.................... //!#define dcVoltage "VDC:%f1"
.................... //!#define USBVoltage "VUSB:%f"
.................... //!#define USBupstream "VUSBup:%f"
.................... //!#define plus5V "5V Rail:%f"
.................... //!#define plus3V3 "3V3 Rai:%f"
.................... //!#define allVoltages "All Voltages = %f, %f, %f, %f, %f"
.................... //!#define USBdownstream "USB downstream status:\r\nPG:%s\r\nch0:%s\r\nch1:%s"
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC MESSGAGE DUMP                                                  */
.................... /*****************************************************************************/
.................... //!#define voltageMsg "V0:%f\r\nV1:%f\r\nV2:%f\r\nV3:%f\r\nV4:%f"
.................... //!#define TimerMsg "T0:%Lu\r\nT1:%Lu\r\nT2:%Lu\r\Tint:%Lu\r\nTtick:%Lu"
.................... //!#define ioStatusMsg "Inputs:%u\r\nOutputs:%u\r\nStatus:%u"
.................... //!#define diagnosticMsg "V0:%f\r\nV1:%f\r\nV2:%f\r\nV3:%f\r\nV4:%f\r\nT0:%Lu\r\nT1:%Lu\r\nT2:%Lu\r\nTint:%Lu\r\nTtick:%Lu\r\nInputs:%u\r\nOutputs:%u\r\nStatus:%u"
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC COMMAND PROTOTYPES                                             */
.................... /*****************************************************************************/
.................... int8 getRev(unsigned int8);                // gr 
.................... int8 getSN(unsigned int8);                 // gs
.................... 
.................... int8 getOPchMap(unsigned int8);            // gChMap,   {1|2}
.................... int8 setOPchMap(unsigned int8);            // sChMap,   {1|2}, {X|Y}
.................... 
.................... int8 getIPchMode(unsigned int8);           // gChMode,  {1|2}
.................... int8 setIPchMode(unsigned int8);           // sChMode,  {1|2}, {MANUAL|MAGSNS}
....................    
.................... int8 getPIDvals(unsigned int8);            // gPID,     {1|2}, {P|I|D}
.................... int8 setPIDvals(unsigned int8);            // sPID,     {1|2}, {P|I|D}, <float>
.................... 
.................... int8 getSetPoint(unsigned int8);           // gSP,      {1|2}
.................... int8 setSetPoint(unsigned int8);           // sSP,      {1|2}, <float>
.................... 
.................... int8 getAllSensorCalParams(unsigned int8); // gSCals,   {1|2}
.................... int8 getSensorCalParam(unsigned int8);     // gSCal,    {1|2}, {c0|c1|c2|c3|c4|c5}
.................... int8 setSensorCalParam(unsigned int8);     // sSCal,    {1|2}, {c0|c1|c2|c3|c4|c5}, <float>
.................... 
.................... int8 getMonitorCalParam(unsigned int8);    // gMCal,    {N15|200|5V6|5VA|3V6X|3V3A|3V3D}
.................... int8 setMonitorCalParam(unsigned int8);    // sMCal,    {N15|200|5V6|5VA|3V6X|3V3A|3V3D}, <float>, <float>
.................... int8 getMonitorValue(unsigned int8);       // gMon,     {N15|200|5V6|5VA|3V6X|3V3A|3V3D|all}
.................... 
.................... int8 getPIDdata(unsigned int8);            // gPIDdata, {1|2}
.................... 
.................... int8 getIPdata(unsigned int8);             // gIPdata,  {1|2}, {raw|calib|pos}
....................    
.................... int8 getManOPvals(unsigned int8);         // gManOP,    {1|2}  
.................... int8 setManOPvals(unsigned int8);         // sManOP,    {1|2}, <float>  
.................... 
.................... int8 invalidCmd(unsigned int8);
.................... 
.................... struct command {
....................    char *cmd_name;
....................    int8 (*cmd_func)(unsigned int8);
.................... };
.................... 
.................... BOOLEAN arg_is_float(char *);
.................... BOOLEAN is_valid_channel(char *);
.................... int8 hex_to_int(char);
.................... void echo_cmd(unsigned int8 rec);
.................... int8 command_parser(unsigned int8 rec);
.................... void command_handler_task();
.................... 
.................... #endif
.................... 
.................... 
.................... /* LIST OF DIAGNOSTIC COMMAND KEYWORDS AND THEIR FUNCTIONS */
.................... struct command cmd_list[] = {
....................    {"gr",       &getRev},
....................    {"gs",       &getSN},
....................    {"gChMap",   &getOPchMap},
....................    {"sChMap",   &setOPchMap},
....................    {"gChMode",  &getIPchMode},
....................    {"sChMode",  &setIPchMode},
....................    {"gPID",     &getPIDvals},
....................    {"sPID",     &setPIDvals},
....................    {"gSP",      &getSetPoint},
....................    {"sSP",      &setSetPoint},
....................    {"gSCals",   &getAllSensorCalParams},
....................    {"gSCal",    &getSensorCalParam},
....................    {"sSCal",    &setSensorCalParam},
....................    {"gMCal",    &getMonitorCalParam},
....................    {"sMCal",    &setMonitorCalParam},
....................    {"gMon",     &getMonitorValue},
....................    {"gPIDdata", &getPIDdata},
....................    {"gIPdata",  &getIPdata},
....................    {"gManOP",   &getManOPvals},
....................    {"sManOP",   &setManOPvals},
....................    {"\0", &invalidCmd}
.................... };
.................... 
.................... /* LIST OF RESPONSE MESSAGES */
.................... enum resp_e { 
....................    SUCCESS,
....................    INV_CMD,
....................    INV_PARAM 
.................... };
.................... 
.................... resp resp_list[] = {
....................    {SUCCESS, "SUCCESS"},
....................    {INV_CMD, "INVALID COMMAND"},
....................    {INV_PARAM, "INVALID PARAMETER"}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC COMMAND DEFINITIONS                                            */
.................... /*****************************************************************************/
....................                           
.................... int8 getRev(unsigned int8 rec){
....................    sprintf(retData+strlen(retData), "%s,", version);
*
04234:  MOVLW  04
04236:  MOVLB  5
04238:  MOVWF  xFF
0423A:  MOVLW  29
0423C:  MOVWF  xFE
0423E:  MOVLB  0
04240:  RCALL  413C
04242:  MOVFF  02,03
04246:  MOVF   01,W
04248:  ADDLW  29
0424A:  MOVLB  5
0424C:  MOVWF  xE2
0424E:  MOVLW  04
04250:  ADDWFC 02,W
04252:  MOVWF  xE3
04254:  MOVFF  FE8,4CE
04258:  MOVFF  5E2,4CD
0425C:  MOVLW  F2
0425E:  MOVWF  FF6
04260:  MOVLW  02
04262:  MOVWF  FF7
04264:  MOVLB  0
04266:  RCALL  4214
04268:  MOVLW  2C
0426A:  MOVLB  6
0426C:  MOVWF  x0D
0426E:  MOVLB  0
04270:  RCALL  41F4
....................    return SUCCESS;
04272:  MOVLW  00
04274:  MOVWF  01
04276:  RETURN 0
.................... }
.................... 
.................... int8 getSN(unsigned int8 rec){
....................    sprintf(retData+strlen(retData), "%s,", serialID);
04278:  MOVLW  04
0427A:  MOVLB  5
0427C:  MOVWF  xFF
0427E:  MOVLW  29
04280:  MOVWF  xFE
04282:  MOVLB  0
04284:  RCALL  413C
04286:  MOVFF  02,03
0428A:  MOVF   01,W
0428C:  ADDLW  29
0428E:  MOVLB  5
04290:  MOVWF  xE2
04292:  MOVLW  04
04294:  ADDWFC 02,W
04296:  MOVWF  xE3
04298:  MOVFF  FE8,4CE
0429C:  MOVFF  5E2,4CD
042A0:  MOVLW  FC
042A2:  MOVWF  FF6
042A4:  MOVLW  02
042A6:  MOVWF  FF7
042A8:  MOVLB  0
042AA:  RCALL  4214
042AC:  MOVLW  2C
042AE:  MOVLB  6
042B0:  MOVWF  x0D
042B2:  MOVLB  0
042B4:  RCALL  41F4
....................    return SUCCESS;
042B6:  MOVLW  00
042B8:  MOVWF  01
042BA:  RETURN 0
.................... }
.................... 
.................... int8 getOPchMap(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
04708:  MOVLB  5
0470A:  CLRF   xFB
0470C:  MOVFF  5D6,5FA
04710:  CLRF   xFD
04712:  MOVLW  B5
04714:  MOVWF  xFC
04716:  MOVLB  0
04718:  CALL   0816
0471C:  MOVFF  02,5E4
04720:  MOVFF  01,5E3
04724:  MOVLW  06
04726:  MOVLB  5
04728:  ADDWF  xE3,F
0472A:  MOVLW  00
0472C:  ADDWFC xE4,F
0472E:  MOVLW  32
04730:  ADDWF  xE3,W
04732:  MOVWF  01
04734:  MOVLW  00
04736:  ADDWFC xE4,W
04738:  MOVWF  03
0473A:  MOVF   01,W
0473C:  ADDLW  53
0473E:  MOVWF  01
04740:  MOVLW  01
04742:  ADDWFC 03,F
04744:  MOVFF  01,5E3
04748:  MOVFF  03,5E4
0474C:  MOVFF  03,5FD
04750:  MOVFF  01,5FC
04754:  MOVLB  0
04756:  RCALL  42BC
04758:  MOVF   01,F
0475A:  BNZ   4764
0475C:  MOVLW  02
0475E:  MOVWF  01
04760:  BRA    4878
04762:  BRA    47C2
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
04764:  MOVLB  5
04766:  CLRF   xFB
04768:  MOVFF  5D6,5FA
0476C:  CLRF   xFD
0476E:  MOVLW  B5
04770:  MOVWF  xFC
04772:  MOVLB  0
04774:  CALL   0816
04778:  MOVFF  02,5E4
0477C:  MOVFF  01,5E3
04780:  MOVLW  06
04782:  MOVLB  5
04784:  ADDWF  xE3,F
04786:  MOVLW  00
04788:  ADDWFC xE4,F
0478A:  MOVLW  32
0478C:  ADDWF  xE3,W
0478E:  MOVWF  01
04790:  MOVLW  00
04792:  ADDWFC xE4,W
04794:  MOVWF  03
04796:  MOVF   01,W
04798:  ADDLW  53
0479A:  MOVWF  01
0479C:  MOVLW  01
0479E:  ADDWFC 03,F
047A0:  MOVFF  01,5E3
047A4:  MOVFF  03,5E4
047A8:  MOVFF  03,5FD
047AC:  MOVFF  01,5FC
047B0:  CLRF   xFF
047B2:  CLRF   xFE
047B4:  MOVLW  0A
047B6:  MOVLB  6
047B8:  MOVWF  x00
047BA:  MOVLB  0
047BC:  RCALL  43AC
047BE:  MOVFF  01,5E2
....................    
....................    /*** GET CHANNEL MAP ***************/ 
....................    if      (0 == chMap[arg1-1]) sprintf(retData+strlen(retData), "%c,", 'X');
047C2:  MOVLW  01
047C4:  MOVLB  5
047C6:  SUBWF  xE2,W
047C8:  MOVWF  xE4
047CA:  CLRF   xE6
047CC:  MOVLW  60
047CE:  MOVWF  xE5
047D0:  MOVLB  0
047D2:  CALL   37EA
047D6:  BTFSC  01.0
047D8:  BRA    4818
047DA:  MOVLW  04
047DC:  MOVLB  5
047DE:  MOVWF  xFF
047E0:  MOVLW  29
047E2:  MOVWF  xFE
047E4:  MOVLB  0
047E6:  RCALL  413C
047E8:  MOVFF  02,03
047EC:  MOVF   01,W
047EE:  ADDLW  29
047F0:  MOVLB  5
047F2:  MOVWF  xE3
047F4:  MOVLW  04
047F6:  ADDWFC 02,W
047F8:  MOVWF  xE4
047FA:  MOVFF  FE8,4CE
047FE:  MOVFF  5E3,4CD
04802:  MOVLW  58
04804:  MOVLB  6
04806:  MOVWF  x0D
04808:  MOVLB  0
0480A:  RCALL  41F4
0480C:  MOVLW  2C
0480E:  MOVLB  6
04810:  MOVWF  x0D
04812:  MOVLB  0
04814:  RCALL  41F4
04816:  BRA    4874
....................    else if (1 == chMap[arg1-1]) sprintf(retData+strlen(retData), "%c,", 'Y');
04818:  MOVLW  01
0481A:  MOVLB  5
0481C:  SUBWF  xE2,W
0481E:  MOVWF  xE4
04820:  CLRF   xE6
04822:  MOVLW  60
04824:  MOVWF  xE5
04826:  MOVLB  0
04828:  CALL   37EA
0482C:  BTFSS  01.0
0482E:  BRA    486E
04830:  MOVLW  04
04832:  MOVLB  5
04834:  MOVWF  xFF
04836:  MOVLW  29
04838:  MOVWF  xFE
0483A:  MOVLB  0
0483C:  RCALL  413C
0483E:  MOVFF  02,03
04842:  MOVF   01,W
04844:  ADDLW  29
04846:  MOVLB  5
04848:  MOVWF  xE3
0484A:  MOVLW  04
0484C:  ADDWFC 02,W
0484E:  MOVWF  xE4
04850:  MOVFF  FE8,4CE
04854:  MOVFF  5E3,4CD
04858:  MOVLW  59
0485A:  MOVLB  6
0485C:  MOVWF  x0D
0485E:  MOVLB  0
04860:  RCALL  41F4
04862:  MOVLW  2C
04864:  MOVLB  6
04866:  MOVWF  x0D
04868:  MOVLB  0
0486A:  RCALL  41F4
0486C:  BRA    4874
....................    else return INV_PARAM;
0486E:  MOVLW  02
04870:  MOVWF  01
04872:  BRA    4878
....................    
....................    return SUCCESS;
04874:  MOVLW  00
04876:  MOVWF  01
04878:  RETURN 0
.................... }
.................... 
.................... int8 setOPchMap(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
048BC:  MOVLB  5
048BE:  CLRF   xFB
048C0:  MOVFF  5D6,5FA
048C4:  CLRF   xFD
048C6:  MOVLW  B5
048C8:  MOVWF  xFC
048CA:  MOVLB  0
048CC:  CALL   0816
048D0:  MOVFF  02,5E5
048D4:  MOVFF  01,5E4
048D8:  MOVLW  06
048DA:  MOVLB  5
048DC:  ADDWF  xE4,F
048DE:  MOVLW  00
048E0:  ADDWFC xE5,F
048E2:  MOVLW  32
048E4:  ADDWF  xE4,W
048E6:  MOVWF  01
048E8:  MOVLW  00
048EA:  ADDWFC xE5,W
048EC:  MOVWF  03
048EE:  MOVF   01,W
048F0:  ADDLW  53
048F2:  MOVWF  01
048F4:  MOVLW  01
048F6:  ADDWFC 03,F
048F8:  MOVFF  01,5E4
048FC:  MOVFF  03,5E5
04900:  MOVFF  03,5FD
04904:  MOVFF  01,5FC
04908:  MOVLB  0
0490A:  RCALL  42BC
0490C:  MOVF   01,F
0490E:  BNZ   4918
04910:  MOVLW  02
04912:  MOVWF  01
04914:  BRA    4A6A
04916:  BRA    4976
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
04918:  MOVLB  5
0491A:  CLRF   xFB
0491C:  MOVFF  5D6,5FA
04920:  CLRF   xFD
04922:  MOVLW  B5
04924:  MOVWF  xFC
04926:  MOVLB  0
04928:  CALL   0816
0492C:  MOVFF  02,5E5
04930:  MOVFF  01,5E4
04934:  MOVLW  06
04936:  MOVLB  5
04938:  ADDWF  xE4,F
0493A:  MOVLW  00
0493C:  ADDWFC xE5,F
0493E:  MOVLW  32
04940:  ADDWF  xE4,W
04942:  MOVWF  01
04944:  MOVLW  00
04946:  ADDWFC xE5,W
04948:  MOVWF  03
0494A:  MOVF   01,W
0494C:  ADDLW  53
0494E:  MOVWF  01
04950:  MOVLW  01
04952:  ADDWFC 03,F
04954:  MOVFF  01,5E4
04958:  MOVFF  03,5E5
0495C:  MOVFF  03,5FD
04960:  MOVFF  01,5FC
04964:  CLRF   xFF
04966:  CLRF   xFE
04968:  MOVLW  0A
0496A:  MOVLB  6
0496C:  MOVWF  x00
0496E:  MOVLB  0
04970:  RCALL  43AC
04972:  MOVFF  01,5E2
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
04976:  MOVLB  5
04978:  CLRF   xFB
0497A:  MOVFF  5D6,5FA
0497E:  CLRF   xFD
04980:  MOVLW  B5
04982:  MOVWF  xFC
04984:  MOVLB  0
04986:  CALL   0816
0498A:  MOVFF  02,5E5
0498E:  MOVFF  01,5E4
04992:  MOVLW  06
04994:  MOVLB  5
04996:  ADDWF  xE4,F
04998:  MOVLW  00
0499A:  ADDWFC xE5,F
0499C:  MOVLW  4B
0499E:  ADDWF  xE4,W
049A0:  MOVWF  01
049A2:  MOVLW  00
049A4:  ADDWFC xE5,W
049A6:  MOVWF  03
049A8:  MOVF   01,W
049AA:  ADDLW  53
049AC:  MOVWF  01
049AE:  MOVLW  01
049B0:  ADDWFC 03,F
049B2:  MOVFF  01,5E4
049B6:  MOVFF  03,5E5
049BA:  MOVFF  03,5FF
049BE:  MOVFF  01,5FE
049C2:  MOVLB  0
049C4:  CALL   413C
049C8:  MOVFF  02,03
049CC:  MOVF   01,W
049CE:  SUBLW  01
049D0:  BNZ   49D6
049D2:  MOVF   03,F
049D4:  BZ    49DE
049D6:  MOVLW  02
049D8:  MOVWF  01
049DA:  BRA    4A6A
049DC:  BRA    4A1E
....................    else arg2 = SERcmd[rec].p[3][0];
049DE:  MOVLB  5
049E0:  CLRF   xFB
049E2:  MOVFF  5D6,5FA
049E6:  CLRF   xFD
049E8:  MOVLW  B5
049EA:  MOVWF  xFC
049EC:  MOVLB  0
049EE:  CALL   0816
049F2:  MOVFF  02,5E5
049F6:  MOVFF  01,5E4
049FA:  MOVLW  06
049FC:  MOVLB  5
049FE:  ADDWF  xE4,F
04A00:  MOVLW  00
04A02:  ADDWFC xE5,F
04A04:  MOVLW  4B
04A06:  ADDWF  xE4,F
04A08:  MOVLW  00
04A0A:  ADDWFC xE5,F
04A0C:  MOVLW  53
04A0E:  ADDWF  xE4,W
04A10:  MOVWF  FE9
04A12:  MOVLW  01
04A14:  ADDWFC xE5,W
04A16:  MOVWF  FEA
04A18:  MOVFF  FEF,5E3
04A1C:  MOVLB  0
....................    
....................    /*** SET CHANNEL MAP ***************/
....................    if      ('X' == arg2) chMap[arg1-1] = chX;
04A1E:  MOVLB  5
04A20:  MOVF   xE3,W
04A22:  SUBLW  58
04A24:  BNZ   4A3E
04A26:  MOVLW  01
04A28:  SUBWF  xE2,W
04A2A:  MOVWF  xE4
04A2C:  MOVWF  xF9
04A2E:  CLRF   xFA
04A30:  CLRF   xFC
04A32:  MOVLW  60
04A34:  MOVWF  xFB
04A36:  MOVLB  0
04A38:  RCALL  487A
04A3A:  BRA    4A66
04A3C:  MOVLB  5
....................    else if ('Y' == arg2) chMap[arg1-1] = chY;
04A3E:  MOVF   xE3,W
04A40:  SUBLW  59
04A42:  BNZ   4A5E
04A44:  MOVLW  01
04A46:  SUBWF  xE2,W
04A48:  MOVWF  xE4
04A4A:  MOVWF  xF9
04A4C:  MOVLW  01
04A4E:  MOVWF  xFA
04A50:  CLRF   xFC
04A52:  MOVLW  60
04A54:  MOVWF  xFB
04A56:  MOVLB  0
04A58:  RCALL  487A
04A5A:  BRA    4A66
04A5C:  MOVLB  5
....................    else return INV_PARAM;
04A5E:  MOVLW  02
04A60:  MOVWF  01
04A62:  MOVLB  0
04A64:  BRA    4A6A
....................    
....................    return SUCCESS;
04A66:  MOVLW  00
04A68:  MOVWF  01
04A6A:  RETURN 0
.................... }
.................... 
.................... int8 getIPchMode(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
04A6C:  MOVLB  5
04A6E:  CLRF   xFB
04A70:  MOVFF  5D6,5FA
04A74:  CLRF   xFD
04A76:  MOVLW  B5
04A78:  MOVWF  xFC
04A7A:  MOVLB  0
04A7C:  CALL   0816
04A80:  MOVFF  02,5E4
04A84:  MOVFF  01,5E3
04A88:  MOVLW  06
04A8A:  MOVLB  5
04A8C:  ADDWF  xE3,F
04A8E:  MOVLW  00
04A90:  ADDWFC xE4,F
04A92:  MOVLW  32
04A94:  ADDWF  xE3,W
04A96:  MOVWF  01
04A98:  MOVLW  00
04A9A:  ADDWFC xE4,W
04A9C:  MOVWF  03
04A9E:  MOVF   01,W
04AA0:  ADDLW  53
04AA2:  MOVWF  01
04AA4:  MOVLW  01
04AA6:  ADDWFC 03,F
04AA8:  MOVFF  01,5E3
04AAC:  MOVFF  03,5E4
04AB0:  MOVFF  03,5FD
04AB4:  MOVFF  01,5FC
04AB8:  MOVLB  0
04ABA:  RCALL  42BC
04ABC:  MOVF   01,F
04ABE:  BNZ   4AC8
04AC0:  MOVLW  02
04AC2:  MOVWF  01
04AC4:  BRA    4BD4
04AC6:  BRA    4B26
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
04AC8:  MOVLB  5
04ACA:  CLRF   xFB
04ACC:  MOVFF  5D6,5FA
04AD0:  CLRF   xFD
04AD2:  MOVLW  B5
04AD4:  MOVWF  xFC
04AD6:  MOVLB  0
04AD8:  CALL   0816
04ADC:  MOVFF  02,5E4
04AE0:  MOVFF  01,5E3
04AE4:  MOVLW  06
04AE6:  MOVLB  5
04AE8:  ADDWF  xE3,F
04AEA:  MOVLW  00
04AEC:  ADDWFC xE4,F
04AEE:  MOVLW  32
04AF0:  ADDWF  xE3,W
04AF2:  MOVWF  01
04AF4:  MOVLW  00
04AF6:  ADDWFC xE4,W
04AF8:  MOVWF  03
04AFA:  MOVF   01,W
04AFC:  ADDLW  53
04AFE:  MOVWF  01
04B00:  MOVLW  01
04B02:  ADDWFC 03,F
04B04:  MOVFF  01,5E3
04B08:  MOVFF  03,5E4
04B0C:  MOVFF  03,5FD
04B10:  MOVFF  01,5FC
04B14:  CLRF   xFF
04B16:  CLRF   xFE
04B18:  MOVLW  0A
04B1A:  MOVLB  6
04B1C:  MOVWF  x00
04B1E:  MOVLB  0
04B20:  RCALL  43AC
04B22:  MOVFF  01,5E2
....................    
....................    /*** GET INPUT MAP *****************/
....................    if      (0 == chMode[arg1-1]) sprintf(retData+strlen(retData), "MANUAL,");
04B26:  MOVLW  01
04B28:  MOVLB  5
04B2A:  SUBWF  xE2,W
04B2C:  MOVWF  xE4
04B2E:  CLRF   xE6
04B30:  MOVLW  61
04B32:  MOVWF  xE5
04B34:  MOVLB  0
04B36:  CALL   37EA
04B3A:  BTFSC  01.0
04B3C:  BRA    4B78
04B3E:  MOVLW  04
04B40:  MOVLB  5
04B42:  MOVWF  xFF
04B44:  MOVLW  29
04B46:  MOVWF  xFE
04B48:  MOVLB  0
04B4A:  CALL   413C
04B4E:  MOVFF  02,03
04B52:  MOVF   01,W
04B54:  ADDLW  29
04B56:  MOVLB  5
04B58:  MOVWF  xE3
04B5A:  MOVLW  04
04B5C:  ADDWFC 02,W
04B5E:  MOVWF  xE4
04B60:  MOVFF  FE8,4CE
04B64:  MOVFF  5E3,4CD
04B68:  MOVLW  02
04B6A:  MOVWF  FF6
04B6C:  MOVLW  03
04B6E:  MOVWF  FF7
04B70:  MOVLB  0
04B72:  CALL   4214
04B76:  BRA    4BD0
....................    else if (1 == chMode[arg1-1]) sprintf(retData+strlen(retData), "MAGSNS,");
04B78:  MOVLW  01
04B7A:  MOVLB  5
04B7C:  SUBWF  xE2,W
04B7E:  MOVWF  xE4
04B80:  CLRF   xE6
04B82:  MOVLW  61
04B84:  MOVWF  xE5
04B86:  MOVLB  0
04B88:  CALL   37EA
04B8C:  BTFSS  01.0
04B8E:  BRA    4BCA
04B90:  MOVLW  04
04B92:  MOVLB  5
04B94:  MOVWF  xFF
04B96:  MOVLW  29
04B98:  MOVWF  xFE
04B9A:  MOVLB  0
04B9C:  CALL   413C
04BA0:  MOVFF  02,03
04BA4:  MOVF   01,W
04BA6:  ADDLW  29
04BA8:  MOVLB  5
04BAA:  MOVWF  xE3
04BAC:  MOVLW  04
04BAE:  ADDWFC 02,W
04BB0:  MOVWF  xE4
04BB2:  MOVFF  FE8,4CE
04BB6:  MOVFF  5E3,4CD
04BBA:  MOVLW  0A
04BBC:  MOVWF  FF6
04BBE:  MOVLW  03
04BC0:  MOVWF  FF7
04BC2:  MOVLB  0
04BC4:  CALL   4214
04BC8:  BRA    4BD0
....................    else return INV_PARAM;
04BCA:  MOVLW  02
04BCC:  MOVWF  01
04BCE:  BRA    4BD4
....................    
....................    return SUCCESS;
04BD0:  MOVLW  00
04BD2:  MOVWF  01
04BD4:  RETURN 0
.................... }
.................... 
.................... int8 setIPchMode(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char *arg2;
....................    char *s_manual = "MANUAL";
04BD6:  MOVLW  4D
04BD8:  MOVLB  5
04BDA:  MOVWF  xE7
04BDC:  MOVLW  41
04BDE:  MOVWF  xE8
04BE0:  MOVLW  4E
04BE2:  MOVWF  xE9
04BE4:  MOVLW  55
04BE6:  MOVWF  xEA
04BE8:  MOVLW  41
04BEA:  MOVWF  xEB
04BEC:  MOVLW  4C
04BEE:  MOVWF  xEC
04BF0:  CLRF   xED
04BF2:  MOVLW  05
04BF4:  MOVWF  xE6
04BF6:  MOVLW  E7
04BF8:  MOVWF  xE5
....................    char *s_magsns = "MAGSNS";
04BFA:  MOVLW  4D
04BFC:  MOVWF  xF0
04BFE:  MOVLW  41
04C00:  MOVWF  xF1
04C02:  MOVLW  47
04C04:  MOVWF  xF2
04C06:  MOVLW  53
04C08:  MOVWF  xF3
04C0A:  MOVLW  4E
04C0C:  MOVWF  xF4
04C0E:  MOVLW  53
04C10:  MOVWF  xF5
04C12:  CLRF   xF6
04C14:  MOVLW  05
04C16:  MOVWF  xEF
04C18:  MOVLW  F0
04C1A:  MOVWF  xEE
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
04C1C:  CLRF   xFB
04C1E:  MOVFF  5D6,5FA
04C22:  CLRF   xFD
04C24:  MOVLW  B5
04C26:  MOVWF  xFC
04C28:  MOVLB  0
04C2A:  CALL   0816
04C2E:  MOVFF  02,5F8
04C32:  MOVFF  01,5F7
04C36:  MOVLW  06
04C38:  MOVLB  5
04C3A:  ADDWF  xF7,F
04C3C:  MOVLW  00
04C3E:  ADDWFC xF8,F
04C40:  MOVLW  32
04C42:  ADDWF  xF7,W
04C44:  MOVWF  01
04C46:  MOVLW  00
04C48:  ADDWFC xF8,W
04C4A:  MOVWF  03
04C4C:  MOVF   01,W
04C4E:  ADDLW  53
04C50:  MOVWF  01
04C52:  MOVLW  01
04C54:  ADDWFC 03,F
04C56:  MOVFF  01,5F7
04C5A:  MOVFF  03,5F8
04C5E:  MOVFF  03,5FD
04C62:  MOVFF  01,5FC
04C66:  MOVLB  0
04C68:  CALL   42BC
04C6C:  MOVF   01,F
04C6E:  BNZ   4C78
04C70:  MOVLW  02
04C72:  MOVWF  01
04C74:  BRA    4DF0
04C76:  BRA    4CD8
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
04C78:  MOVLB  5
04C7A:  CLRF   xFB
04C7C:  MOVFF  5D6,5FA
04C80:  CLRF   xFD
04C82:  MOVLW  B5
04C84:  MOVWF  xFC
04C86:  MOVLB  0
04C88:  CALL   0816
04C8C:  MOVFF  02,5F8
04C90:  MOVFF  01,5F7
04C94:  MOVLW  06
04C96:  MOVLB  5
04C98:  ADDWF  xF7,F
04C9A:  MOVLW  00
04C9C:  ADDWFC xF8,F
04C9E:  MOVLW  32
04CA0:  ADDWF  xF7,W
04CA2:  MOVWF  01
04CA4:  MOVLW  00
04CA6:  ADDWFC xF8,W
04CA8:  MOVWF  03
04CAA:  MOVF   01,W
04CAC:  ADDLW  53
04CAE:  MOVWF  01
04CB0:  MOVLW  01
04CB2:  ADDWFC 03,F
04CB4:  MOVFF  01,5F7
04CB8:  MOVFF  03,5F8
04CBC:  MOVFF  03,5FD
04CC0:  MOVFF  01,5FC
04CC4:  CLRF   xFF
04CC6:  CLRF   xFE
04CC8:  MOVLW  0A
04CCA:  MOVLB  6
04CCC:  MOVWF  x00
04CCE:  MOVLB  0
04CD0:  CALL   43AC
04CD4:  MOVFF  01,5E2
....................    
....................    if (0 == strlen(SERcmd[rec].p[3])) return INV_PARAM;
04CD8:  MOVLB  5
04CDA:  CLRF   xFB
04CDC:  MOVFF  5D6,5FA
04CE0:  CLRF   xFD
04CE2:  MOVLW  B5
04CE4:  MOVWF  xFC
04CE6:  MOVLB  0
04CE8:  CALL   0816
04CEC:  MOVFF  02,5F8
04CF0:  MOVFF  01,5F7
04CF4:  MOVLW  06
04CF6:  MOVLB  5
04CF8:  ADDWF  xF7,F
04CFA:  MOVLW  00
04CFC:  ADDWFC xF8,F
04CFE:  MOVLW  4B
04D00:  ADDWF  xF7,W
04D02:  MOVWF  01
04D04:  MOVLW  00
04D06:  ADDWFC xF8,W
04D08:  MOVWF  03
04D0A:  MOVF   01,W
04D0C:  ADDLW  53
04D0E:  MOVWF  01
04D10:  MOVLW  01
04D12:  ADDWFC 03,F
04D14:  MOVFF  01,5F7
04D18:  MOVFF  03,5F8
04D1C:  MOVFF  03,5FF
04D20:  MOVFF  01,5FE
04D24:  MOVLB  0
04D26:  CALL   413C
04D2A:  MOVFF  02,03
04D2E:  MOVF   01,W
04D30:  BNZ   4D3E
04D32:  MOVF   03,F
04D34:  BNZ   4D3E
04D36:  MOVLW  02
04D38:  MOVWF  01
04D3A:  BRA    4DF0
04D3C:  BRA    4D84
....................    else arg2 = SERcmd[rec].p[3];
04D3E:  MOVLB  5
04D40:  CLRF   xFB
04D42:  MOVFF  5D6,5FA
04D46:  CLRF   xFD
04D48:  MOVLW  B5
04D4A:  MOVWF  xFC
04D4C:  MOVLB  0
04D4E:  CALL   0816
04D52:  MOVFF  02,5F8
04D56:  MOVFF  01,5F7
04D5A:  MOVLW  06
04D5C:  MOVLB  5
04D5E:  ADDWF  xF7,F
04D60:  MOVLW  00
04D62:  ADDWFC xF8,F
04D64:  MOVLW  4B
04D66:  ADDWF  xF7,W
04D68:  MOVWF  01
04D6A:  MOVLW  00
04D6C:  ADDWFC xF8,W
04D6E:  MOVWF  03
04D70:  MOVF   01,W
04D72:  ADDLW  53
04D74:  MOVWF  01
04D76:  MOVLW  01
04D78:  ADDWFC 03,F
04D7A:  MOVFF  01,5E3
04D7E:  MOVFF  03,5E4
04D82:  MOVLB  0
....................    
....................    /*** SET INPUT MAP *****************/
....................    if      (0 == strcmp(s_manual, arg2)) chMode[arg1-1] = MANUAL;
04D84:  MOVFF  5E6,5FB
04D88:  MOVFF  5E5,5FA
04D8C:  MOVFF  5E4,5FD
04D90:  MOVFF  5E3,5FC
04D94:  CALL   417C
04D98:  MOVF   01,F
04D9A:  BNZ   4DB4
04D9C:  MOVLW  01
04D9E:  MOVLB  5
04DA0:  SUBWF  xE2,W
04DA2:  MOVWF  xF7
04DA4:  MOVWF  xF9
04DA6:  CLRF   xFA
04DA8:  CLRF   xFC
04DAA:  MOVLW  61
04DAC:  MOVWF  xFB
04DAE:  MOVLB  0
04DB0:  RCALL  487A
04DB2:  BRA    4DEC
....................    else if (0 == strcmp(s_magsns, arg2)) chMode[arg1-1] = MAGSNS;
04DB4:  MOVFF  5EF,5FB
04DB8:  MOVFF  5EE,5FA
04DBC:  MOVFF  5E4,5FD
04DC0:  MOVFF  5E3,5FC
04DC4:  CALL   417C
04DC8:  MOVF   01,F
04DCA:  BNZ   4DE6
04DCC:  MOVLW  01
04DCE:  MOVLB  5
04DD0:  SUBWF  xE2,W
04DD2:  MOVWF  xF7
04DD4:  MOVWF  xF9
04DD6:  MOVLW  01
04DD8:  MOVWF  xFA
04DDA:  CLRF   xFC
04DDC:  MOVLW  61
04DDE:  MOVWF  xFB
04DE0:  MOVLB  0
04DE2:  RCALL  487A
04DE4:  BRA    4DEC
....................    else return INV_PARAM;
04DE6:  MOVLW  02
04DE8:  MOVWF  01
04DEA:  BRA    4DF0
....................    
....................    return SUCCESS;
04DEC:  MOVLW  00
04DEE:  MOVWF  01
04DF0:  RETURN 0
.................... }
.................... 
.................... int8 getPIDvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/ 
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
05078:  MOVLB  5
0507A:  CLRF   xFB
0507C:  MOVFF  5D6,5FA
05080:  CLRF   xFD
05082:  MOVLW  B5
05084:  MOVWF  xFC
05086:  MOVLB  0
05088:  CALL   0816
0508C:  MOVFF  02,5E5
05090:  MOVFF  01,5E4
05094:  MOVLW  06
05096:  MOVLB  5
05098:  ADDWF  xE4,F
0509A:  MOVLW  00
0509C:  ADDWFC xE5,F
0509E:  MOVLW  32
050A0:  ADDWF  xE4,W
050A2:  MOVWF  01
050A4:  MOVLW  00
050A6:  ADDWFC xE5,W
050A8:  MOVWF  03
050AA:  MOVF   01,W
050AC:  ADDLW  53
050AE:  MOVWF  01
050B0:  MOVLW  01
050B2:  ADDWFC 03,F
050B4:  MOVFF  01,5E4
050B8:  MOVFF  03,5E5
050BC:  MOVFF  03,5FD
050C0:  MOVFF  01,5FC
050C4:  MOVLB  0
050C6:  CALL   42BC
050CA:  MOVF   01,F
050CC:  BNZ   50D6
050CE:  MOVLW  02
050D0:  MOVWF  01
050D2:  BRA    5358
050D4:  BRA    5136
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
050D6:  MOVLB  5
050D8:  CLRF   xFB
050DA:  MOVFF  5D6,5FA
050DE:  CLRF   xFD
050E0:  MOVLW  B5
050E2:  MOVWF  xFC
050E4:  MOVLB  0
050E6:  CALL   0816
050EA:  MOVFF  02,5E5
050EE:  MOVFF  01,5E4
050F2:  MOVLW  06
050F4:  MOVLB  5
050F6:  ADDWF  xE4,F
050F8:  MOVLW  00
050FA:  ADDWFC xE5,F
050FC:  MOVLW  32
050FE:  ADDWF  xE4,W
05100:  MOVWF  01
05102:  MOVLW  00
05104:  ADDWFC xE5,W
05106:  MOVWF  03
05108:  MOVF   01,W
0510A:  ADDLW  53
0510C:  MOVWF  01
0510E:  MOVLW  01
05110:  ADDWFC 03,F
05112:  MOVFF  01,5E4
05116:  MOVFF  03,5E5
0511A:  MOVFF  03,5FD
0511E:  MOVFF  01,5FC
05122:  CLRF   xFF
05124:  CLRF   xFE
05126:  MOVLW  0A
05128:  MOVLB  6
0512A:  MOVWF  x00
0512C:  MOVLB  0
0512E:  CALL   43AC
05132:  MOVFF  01,5E2
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
05136:  MOVLB  5
05138:  CLRF   xFB
0513A:  MOVFF  5D6,5FA
0513E:  CLRF   xFD
05140:  MOVLW  B5
05142:  MOVWF  xFC
05144:  MOVLB  0
05146:  CALL   0816
0514A:  MOVFF  02,5E5
0514E:  MOVFF  01,5E4
05152:  MOVLW  06
05154:  MOVLB  5
05156:  ADDWF  xE4,F
05158:  MOVLW  00
0515A:  ADDWFC xE5,F
0515C:  MOVLW  4B
0515E:  ADDWF  xE4,W
05160:  MOVWF  01
05162:  MOVLW  00
05164:  ADDWFC xE5,W
05166:  MOVWF  03
05168:  MOVF   01,W
0516A:  ADDLW  53
0516C:  MOVWF  01
0516E:  MOVLW  01
05170:  ADDWFC 03,F
05172:  MOVFF  01,5E4
05176:  MOVFF  03,5E5
0517A:  MOVFF  03,5FF
0517E:  MOVFF  01,5FE
05182:  MOVLB  0
05184:  CALL   413C
05188:  MOVFF  02,03
0518C:  MOVF   01,W
0518E:  SUBLW  01
05190:  BNZ   5196
05192:  MOVF   03,F
05194:  BZ    519E
05196:  MOVLW  02
05198:  MOVWF  01
0519A:  BRA    5358
0519C:  BRA    51DE
....................    else arg2 = SERcmd[rec].p[3][0];
0519E:  MOVLB  5
051A0:  CLRF   xFB
051A2:  MOVFF  5D6,5FA
051A6:  CLRF   xFD
051A8:  MOVLW  B5
051AA:  MOVWF  xFC
051AC:  MOVLB  0
051AE:  CALL   0816
051B2:  MOVFF  02,5E5
051B6:  MOVFF  01,5E4
051BA:  MOVLW  06
051BC:  MOVLB  5
051BE:  ADDWF  xE4,F
051C0:  MOVLW  00
051C2:  ADDWFC xE5,F
051C4:  MOVLW  4B
051C6:  ADDWF  xE4,F
051C8:  MOVLW  00
051CA:  ADDWFC xE5,F
051CC:  MOVLW  53
051CE:  ADDWF  xE4,W
051D0:  MOVWF  FE9
051D2:  MOVLW  01
051D4:  ADDWFC xE5,W
051D6:  MOVWF  FEA
051D8:  MOVFF  FEF,5E3
051DC:  MOVLB  0
....................    
....................    /*** GET P, I, or D VALUE **********/
....................    if      ('P' == arg2) sprintf(retData+strlen(retData), "%f,", PID[arg1-1].kP);
051DE:  MOVLB  5
051E0:  MOVF   xE3,W
051E2:  SUBLW  50
051E4:  BNZ   5254
051E6:  MOVLW  04
051E8:  MOVWF  xFF
051EA:  MOVLW  29
051EC:  MOVWF  xFE
051EE:  MOVLB  0
051F0:  CALL   413C
051F4:  MOVFF  02,03
051F8:  MOVF   01,W
051FA:  ADDLW  29
051FC:  MOVLB  5
051FE:  MOVWF  xE4
05200:  MOVLW  04
05202:  ADDWFC 02,W
05204:  MOVWF  xE5
05206:  MOVLW  01
05208:  SUBWF  xE2,W
0520A:  MULLW  20
0520C:  MOVF   FF3,W
0520E:  CLRF   xE7
05210:  MOVWF  xE6
05212:  MOVLW  20
05214:  ADDWF  xE6,W
05216:  MOVWF  FE9
05218:  MOVLW  00
0521A:  ADDWFC xE7,W
0521C:  MOVWF  FEA
0521E:  MOVFF  FEF,600
05222:  MOVFF  FEC,601
05226:  MOVFF  FEC,602
0522A:  MOVFF  FEC,603
0522E:  MOVFF  5E5,4CE
05232:  MOVFF  5E4,4CD
05236:  MOVLW  89
05238:  MOVWF  FE9
0523A:  MOVLW  02
0523C:  MOVLB  6
0523E:  MOVWF  x04
05240:  MOVLB  0
05242:  RCALL  4ECA
05244:  MOVLW  2C
05246:  MOVLB  6
05248:  MOVWF  x0D
0524A:  MOVLB  0
0524C:  CALL   41F4
05250:  BRA    5354
05252:  MOVLB  5
....................    else if ('I' == arg2) sprintf(retData+strlen(retData), "%f,", PID[arg1-1].kI);
05254:  MOVF   xE3,W
05256:  SUBLW  49
05258:  BNZ   52D0
0525A:  MOVLW  04
0525C:  MOVWF  xFF
0525E:  MOVLW  29
05260:  MOVWF  xFE
05262:  MOVLB  0
05264:  CALL   413C
05268:  MOVF   01,W
0526A:  ADDLW  29
0526C:  MOVLB  5
0526E:  MOVWF  xE4
05270:  MOVLW  04
05272:  ADDWFC 02,W
05274:  MOVWF  xE5
05276:  MOVLW  01
05278:  SUBWF  xE2,W
0527A:  MULLW  20
0527C:  MOVF   FF3,W
0527E:  CLRF   xE7
05280:  MOVWF  xE6
05282:  MOVLW  04
05284:  ADDWF  xE6,W
05286:  MOVWF  01
05288:  MOVLW  00
0528A:  ADDWFC xE7,W
0528C:  MOVWF  03
0528E:  MOVF   01,W
05290:  ADDLW  20
05292:  MOVWF  FE9
05294:  MOVLW  00
05296:  ADDWFC 03,W
05298:  MOVWF  FEA
0529A:  MOVFF  FEF,600
0529E:  MOVFF  FEC,601
052A2:  MOVFF  FEC,602
052A6:  MOVFF  FEC,603
052AA:  MOVFF  5E5,4CE
052AE:  MOVFF  5E4,4CD
052B2:  MOVLW  89
052B4:  MOVWF  FE9
052B6:  MOVLW  02
052B8:  MOVLB  6
052BA:  MOVWF  x04
052BC:  MOVLB  0
052BE:  RCALL  4ECA
052C0:  MOVLW  2C
052C2:  MOVLB  6
052C4:  MOVWF  x0D
052C6:  MOVLB  0
052C8:  CALL   41F4
052CC:  BRA    5354
052CE:  MOVLB  5
....................    else if ('D' == arg2) sprintf(retData+strlen(retData), "%f,", PID[arg1-1].kD);
052D0:  MOVF   xE3,W
052D2:  SUBLW  44
052D4:  BNZ   534C
052D6:  MOVLW  04
052D8:  MOVWF  xFF
052DA:  MOVLW  29
052DC:  MOVWF  xFE
052DE:  MOVLB  0
052E0:  CALL   413C
052E4:  MOVF   01,W
052E6:  ADDLW  29
052E8:  MOVLB  5
052EA:  MOVWF  xE4
052EC:  MOVLW  04
052EE:  ADDWFC 02,W
052F0:  MOVWF  xE5
052F2:  MOVLW  01
052F4:  SUBWF  xE2,W
052F6:  MULLW  20
052F8:  MOVF   FF3,W
052FA:  CLRF   xE7
052FC:  MOVWF  xE6
052FE:  MOVLW  08
05300:  ADDWF  xE6,W
05302:  MOVWF  01
05304:  MOVLW  00
05306:  ADDWFC xE7,W
05308:  MOVWF  03
0530A:  MOVF   01,W
0530C:  ADDLW  20
0530E:  MOVWF  FE9
05310:  MOVLW  00
05312:  ADDWFC 03,W
05314:  MOVWF  FEA
05316:  MOVFF  FEF,600
0531A:  MOVFF  FEC,601
0531E:  MOVFF  FEC,602
05322:  MOVFF  FEC,603
05326:  MOVFF  5E5,4CE
0532A:  MOVFF  5E4,4CD
0532E:  MOVLW  89
05330:  MOVWF  FE9
05332:  MOVLW  02
05334:  MOVLB  6
05336:  MOVWF  x04
05338:  MOVLB  0
0533A:  RCALL  4ECA
0533C:  MOVLW  2C
0533E:  MOVLB  6
05340:  MOVWF  x0D
05342:  MOVLB  0
05344:  CALL   41F4
05348:  BRA    5354
0534A:  MOVLB  5
....................    else return INV_PARAM;
0534C:  MOVLW  02
0534E:  MOVWF  01
05350:  MOVLB  0
05352:  BRA    5358
....................    
....................    return SUCCESS;
05354:  MOVLW  00
05356:  MOVWF  01
05358:  RETURN 0
.................... }
.................... 
.................... int8 setPIDvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char  arg2;
....................    float arg3;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
0567C:  MOVLB  5
0567E:  CLRF   xFB
05680:  MOVFF  5D6,5FA
05684:  CLRF   xFD
05686:  MOVLW  B5
05688:  MOVWF  xFC
0568A:  MOVLB  0
0568C:  CALL   0816
05690:  MOVFF  02,5E9
05694:  MOVFF  01,5E8
05698:  MOVLW  06
0569A:  MOVLB  5
0569C:  ADDWF  xE8,F
0569E:  MOVLW  00
056A0:  ADDWFC xE9,F
056A2:  MOVLW  32
056A4:  ADDWF  xE8,W
056A6:  MOVWF  01
056A8:  MOVLW  00
056AA:  ADDWFC xE9,W
056AC:  MOVWF  03
056AE:  MOVF   01,W
056B0:  ADDLW  53
056B2:  MOVWF  01
056B4:  MOVLW  01
056B6:  ADDWFC 03,F
056B8:  MOVFF  01,5E8
056BC:  MOVFF  03,5E9
056C0:  MOVFF  03,5FD
056C4:  MOVFF  01,5FC
056C8:  MOVLB  0
056CA:  CALL   42BC
056CE:  MOVF   01,F
056D0:  BNZ   56DA
056D2:  MOVLW  02
056D4:  MOVWF  01
056D6:  BRA    5986
056D8:  BRA    573A
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
056DA:  MOVLB  5
056DC:  CLRF   xFB
056DE:  MOVFF  5D6,5FA
056E2:  CLRF   xFD
056E4:  MOVLW  B5
056E6:  MOVWF  xFC
056E8:  MOVLB  0
056EA:  CALL   0816
056EE:  MOVFF  02,5E9
056F2:  MOVFF  01,5E8
056F6:  MOVLW  06
056F8:  MOVLB  5
056FA:  ADDWF  xE8,F
056FC:  MOVLW  00
056FE:  ADDWFC xE9,F
05700:  MOVLW  32
05702:  ADDWF  xE8,W
05704:  MOVWF  01
05706:  MOVLW  00
05708:  ADDWFC xE9,W
0570A:  MOVWF  03
0570C:  MOVF   01,W
0570E:  ADDLW  53
05710:  MOVWF  01
05712:  MOVLW  01
05714:  ADDWFC 03,F
05716:  MOVFF  01,5E8
0571A:  MOVFF  03,5E9
0571E:  MOVFF  03,5FD
05722:  MOVFF  01,5FC
05726:  CLRF   xFF
05728:  CLRF   xFE
0572A:  MOVLW  0A
0572C:  MOVLB  6
0572E:  MOVWF  x00
05730:  MOVLB  0
05732:  CALL   43AC
05736:  MOVFF  01,5E2
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
0573A:  MOVLB  5
0573C:  CLRF   xFB
0573E:  MOVFF  5D6,5FA
05742:  CLRF   xFD
05744:  MOVLW  B5
05746:  MOVWF  xFC
05748:  MOVLB  0
0574A:  CALL   0816
0574E:  MOVFF  02,5E9
05752:  MOVFF  01,5E8
05756:  MOVLW  06
05758:  MOVLB  5
0575A:  ADDWF  xE8,F
0575C:  MOVLW  00
0575E:  ADDWFC xE9,F
05760:  MOVLW  4B
05762:  ADDWF  xE8,W
05764:  MOVWF  01
05766:  MOVLW  00
05768:  ADDWFC xE9,W
0576A:  MOVWF  03
0576C:  MOVF   01,W
0576E:  ADDLW  53
05770:  MOVWF  01
05772:  MOVLW  01
05774:  ADDWFC 03,F
05776:  MOVFF  01,5E8
0577A:  MOVFF  03,5E9
0577E:  MOVFF  03,5FF
05782:  MOVFF  01,5FE
05786:  MOVLB  0
05788:  CALL   413C
0578C:  MOVFF  02,03
05790:  MOVF   01,W
05792:  SUBLW  01
05794:  BNZ   579A
05796:  MOVF   03,F
05798:  BZ    57A2
0579A:  MOVLW  02
0579C:  MOVWF  01
0579E:  BRA    5986
057A0:  BRA    57E2
....................    else arg2 = SERcmd[rec].p[3][0];
057A2:  MOVLB  5
057A4:  CLRF   xFB
057A6:  MOVFF  5D6,5FA
057AA:  CLRF   xFD
057AC:  MOVLW  B5
057AE:  MOVWF  xFC
057B0:  MOVLB  0
057B2:  CALL   0816
057B6:  MOVFF  02,5E9
057BA:  MOVFF  01,5E8
057BE:  MOVLW  06
057C0:  MOVLB  5
057C2:  ADDWF  xE8,F
057C4:  MOVLW  00
057C6:  ADDWFC xE9,F
057C8:  MOVLW  4B
057CA:  ADDWF  xE8,F
057CC:  MOVLW  00
057CE:  ADDWFC xE9,F
057D0:  MOVLW  53
057D2:  ADDWF  xE8,W
057D4:  MOVWF  FE9
057D6:  MOVLW  01
057D8:  ADDWFC xE9,W
057DA:  MOVWF  FEA
057DC:  MOVFF  FEF,5E3
057E0:  MOVLB  0
....................    
....................    if (!arg_is_float(strtod(SERcmd[rec].p[4], '\0'))) return INV_PARAM;
057E2:  MOVLB  5
057E4:  CLRF   xFB
057E6:  MOVFF  5D6,5FA
057EA:  CLRF   xFD
057EC:  MOVLW  B5
057EE:  MOVWF  xFC
057F0:  MOVLB  0
057F2:  CALL   0816
057F6:  MOVFF  02,5E9
057FA:  MOVFF  01,5E8
057FE:  MOVLW  06
05800:  MOVLB  5
05802:  ADDWF  xE8,F
05804:  MOVLW  00
05806:  ADDWFC xE9,F
05808:  MOVLW  64
0580A:  ADDWF  xE8,W
0580C:  MOVWF  01
0580E:  MOVLW  00
05810:  ADDWFC xE9,W
05812:  MOVWF  03
05814:  MOVF   01,W
05816:  ADDLW  53
05818:  MOVWF  01
0581A:  MOVLW  01
0581C:  ADDWFC 03,F
0581E:  MOVFF  01,5E8
05822:  MOVFF  03,5E9
05826:  MOVFF  03,5EC
0582A:  MOVFF  01,5EB
0582E:  CLRF   xEE
05830:  CLRF   xED
05832:  MOVLB  0
05834:  RCALL  535A
05836:  MOVFF  03,62F
0583A:  MOVFF  02,62E
0583E:  MOVFF  01,62D
05842:  MOVFF  00,62C
05846:  CALL   1D1A
0584A:  MOVFF  02,5E9
0584E:  MOVFF  01,5E8
05852:  MOVFF  02,5EC
05856:  MOVFF  01,5EB
0585A:  RCALL  55BA
0585C:  MOVF   01,F
0585E:  BNZ   5868
05860:  MOVLW  02
05862:  MOVWF  01
05864:  BRA    5986
05866:  BRA    58CC
....................    else arg3 = strtod(SERcmd[rec].p[4], '\0');
05868:  MOVLB  5
0586A:  CLRF   xFB
0586C:  MOVFF  5D6,5FA
05870:  CLRF   xFD
05872:  MOVLW  B5
05874:  MOVWF  xFC
05876:  MOVLB  0
05878:  CALL   0816
0587C:  MOVFF  02,5E9
05880:  MOVFF  01,5E8
05884:  MOVLW  06
05886:  MOVLB  5
05888:  ADDWF  xE8,F
0588A:  MOVLW  00
0588C:  ADDWFC xE9,F
0588E:  MOVLW  64
05890:  ADDWF  xE8,W
05892:  MOVWF  01
05894:  MOVLW  00
05896:  ADDWFC xE9,W
05898:  MOVWF  03
0589A:  MOVF   01,W
0589C:  ADDLW  53
0589E:  MOVWF  01
058A0:  MOVLW  01
058A2:  ADDWFC 03,F
058A4:  MOVFF  01,5E8
058A8:  MOVFF  03,5E9
058AC:  MOVFF  03,5EC
058B0:  MOVFF  01,5EB
058B4:  CLRF   xEE
058B6:  CLRF   xED
058B8:  MOVLB  0
058BA:  RCALL  535A
058BC:  MOVFF  03,5E7
058C0:  MOVFF  02,5E6
058C4:  MOVFF  01,5E5
058C8:  MOVFF  00,5E4
....................    
....................    /*** SET P, I, or D VALUE **********/
....................    if      ('P' == arg2) PID[arg1-1].kP = arg3;
058CC:  MOVLB  5
058CE:  MOVF   xE3,W
058D0:  SUBLW  50
058D2:  BNZ   58FE
058D4:  MOVLW  01
058D6:  SUBWF  xE2,W
058D8:  MULLW  20
058DA:  MOVF   FF3,W
058DC:  CLRF   xE9
058DE:  MOVWF  xE8
058E0:  MOVLW  20
058E2:  ADDWF  xE8,W
058E4:  MOVWF  FE9
058E6:  MOVLW  00
058E8:  ADDWFC xE9,W
058EA:  MOVWF  FEA
058EC:  MOVFF  5E4,FEF
058F0:  MOVFF  5E5,FEC
058F4:  MOVFF  5E6,FEC
058F8:  MOVFF  5E7,FEC
058FC:  BRA    5980
....................    else if ('I' == arg2) PID[arg1-1].kI = arg3;
058FE:  MOVF   xE3,W
05900:  SUBLW  49
05902:  BNZ   593A
05904:  MOVLW  01
05906:  SUBWF  xE2,W
05908:  MULLW  20
0590A:  MOVF   FF3,W
0590C:  CLRF   xE9
0590E:  MOVWF  xE8
05910:  MOVLW  04
05912:  ADDWF  xE8,W
05914:  MOVWF  01
05916:  MOVLW  00
05918:  ADDWFC xE9,W
0591A:  MOVWF  03
0591C:  MOVF   01,W
0591E:  ADDLW  20
05920:  MOVWF  FE9
05922:  MOVLW  00
05924:  ADDWFC 03,W
05926:  MOVWF  FEA
05928:  MOVFF  5E4,FEF
0592C:  MOVFF  5E5,FEC
05930:  MOVFF  5E6,FEC
05934:  MOVFF  5E7,FEC
05938:  BRA    5980
....................    else if ('D' == arg2) PID[arg1-1].kD = arg3;
0593A:  MOVF   xE3,W
0593C:  SUBLW  44
0593E:  BNZ   5976
05940:  MOVLW  01
05942:  SUBWF  xE2,W
05944:  MULLW  20
05946:  MOVF   FF3,W
05948:  CLRF   xE9
0594A:  MOVWF  xE8
0594C:  MOVLW  08
0594E:  ADDWF  xE8,W
05950:  MOVWF  01
05952:  MOVLW  00
05954:  ADDWFC xE9,W
05956:  MOVWF  03
05958:  MOVF   01,W
0595A:  ADDLW  20
0595C:  MOVWF  FE9
0595E:  MOVLW  00
05960:  ADDWFC 03,W
05962:  MOVWF  FEA
05964:  MOVFF  5E4,FEF
05968:  MOVFF  5E5,FEC
0596C:  MOVFF  5E6,FEC
05970:  MOVFF  5E7,FEC
05974:  BRA    5980
....................    else return INV_PARAM;
05976:  MOVLW  02
05978:  MOVWF  01
0597A:  MOVLB  0
0597C:  BRA    5986
0597E:  MOVLB  5
....................    
....................    return SUCCESS;
05980:  MOVLW  00
05982:  MOVWF  01
05984:  MOVLB  0
05986:  RETURN 0
.................... }
.................... 
.................... int8 getSetPoint(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
05988:  MOVLB  5
0598A:  CLRF   xFB
0598C:  MOVFF  5D6,5FA
05990:  CLRF   xFD
05992:  MOVLW  B5
05994:  MOVWF  xFC
05996:  MOVLB  0
05998:  CALL   0816
0599C:  MOVFF  02,5E4
059A0:  MOVFF  01,5E3
059A4:  MOVLW  06
059A6:  MOVLB  5
059A8:  ADDWF  xE3,F
059AA:  MOVLW  00
059AC:  ADDWFC xE4,F
059AE:  MOVLW  32
059B0:  ADDWF  xE3,W
059B2:  MOVWF  01
059B4:  MOVLW  00
059B6:  ADDWFC xE4,W
059B8:  MOVWF  03
059BA:  MOVF   01,W
059BC:  ADDLW  53
059BE:  MOVWF  01
059C0:  MOVLW  01
059C2:  ADDWFC 03,F
059C4:  MOVFF  01,5E3
059C8:  MOVFF  03,5E4
059CC:  MOVFF  03,5FD
059D0:  MOVFF  01,5FC
059D4:  MOVLB  0
059D6:  CALL   42BC
059DA:  MOVF   01,F
059DC:  BNZ   59E6
059DE:  MOVLW  02
059E0:  MOVWF  01
059E2:  BRA    5AC0
059E4:  BRA    5A46
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
059E6:  MOVLB  5
059E8:  CLRF   xFB
059EA:  MOVFF  5D6,5FA
059EE:  CLRF   xFD
059F0:  MOVLW  B5
059F2:  MOVWF  xFC
059F4:  MOVLB  0
059F6:  CALL   0816
059FA:  MOVFF  02,5E4
059FE:  MOVFF  01,5E3
05A02:  MOVLW  06
05A04:  MOVLB  5
05A06:  ADDWF  xE3,F
05A08:  MOVLW  00
05A0A:  ADDWFC xE4,F
05A0C:  MOVLW  32
05A0E:  ADDWF  xE3,W
05A10:  MOVWF  01
05A12:  MOVLW  00
05A14:  ADDWFC xE4,W
05A16:  MOVWF  03
05A18:  MOVF   01,W
05A1A:  ADDLW  53
05A1C:  MOVWF  01
05A1E:  MOVLW  01
05A20:  ADDWFC 03,F
05A22:  MOVFF  01,5E3
05A26:  MOVFF  03,5E4
05A2A:  MOVFF  03,5FD
05A2E:  MOVFF  01,5FC
05A32:  CLRF   xFF
05A34:  CLRF   xFE
05A36:  MOVLW  0A
05A38:  MOVLB  6
05A3A:  MOVWF  x00
05A3C:  MOVLB  0
05A3E:  CALL   43AC
05A42:  MOVFF  01,5E2
....................    
....................    /*** GET SETPOINT ******************/ 
....................    sprintf(retData+strlen(retData), "%f,", PID[arg1-1].SP);
05A46:  MOVLW  04
05A48:  MOVLB  5
05A4A:  MOVWF  xFF
05A4C:  MOVLW  29
05A4E:  MOVWF  xFE
05A50:  MOVLB  0
05A52:  CALL   413C
05A56:  MOVF   01,W
05A58:  ADDLW  29
05A5A:  MOVLB  5
05A5C:  MOVWF  xE3
05A5E:  MOVLW  04
05A60:  ADDWFC 02,W
05A62:  MOVWF  xE4
05A64:  MOVLW  01
05A66:  SUBWF  xE2,W
05A68:  MULLW  20
05A6A:  MOVF   FF3,W
05A6C:  CLRF   xE6
05A6E:  MOVWF  xE5
05A70:  MOVLW  0C
05A72:  ADDWF  xE5,W
05A74:  MOVWF  01
05A76:  MOVLW  00
05A78:  ADDWFC xE6,W
05A7A:  MOVWF  03
05A7C:  MOVF   01,W
05A7E:  ADDLW  20
05A80:  MOVWF  FE9
05A82:  MOVLW  00
05A84:  ADDWFC 03,W
05A86:  MOVWF  FEA
05A88:  MOVFF  FEF,600
05A8C:  MOVFF  FEC,601
05A90:  MOVFF  FEC,602
05A94:  MOVFF  FEC,603
05A98:  MOVFF  5E4,4CE
05A9C:  MOVFF  5E3,4CD
05AA0:  MOVLW  89
05AA2:  MOVWF  FE9
05AA4:  MOVLW  02
05AA6:  MOVLB  6
05AA8:  MOVWF  x04
05AAA:  MOVLB  0
05AAC:  CALL   4ECA
05AB0:  MOVLW  2C
05AB2:  MOVLB  6
05AB4:  MOVWF  x0D
05AB6:  MOVLB  0
05AB8:  CALL   41F4
....................    return SUCCESS;
05ABC:  MOVLW  00
05ABE:  MOVWF  01
05AC0:  RETURN 0
.................... }
.................... 
.................... int8 setSetPoint(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/   
....................    int8  arg1;
....................    float arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
05AC2:  MOVLB  5
05AC4:  CLRF   xFB
05AC6:  MOVFF  5D6,5FA
05ACA:  CLRF   xFD
05ACC:  MOVLW  B5
05ACE:  MOVWF  xFC
05AD0:  MOVLB  0
05AD2:  CALL   0816
05AD6:  MOVFF  02,5E8
05ADA:  MOVFF  01,5E7
05ADE:  MOVLW  06
05AE0:  MOVLB  5
05AE2:  ADDWF  xE7,F
05AE4:  MOVLW  00
05AE6:  ADDWFC xE8,F
05AE8:  MOVLW  32
05AEA:  ADDWF  xE7,W
05AEC:  MOVWF  01
05AEE:  MOVLW  00
05AF0:  ADDWFC xE8,W
05AF2:  MOVWF  03
05AF4:  MOVF   01,W
05AF6:  ADDLW  53
05AF8:  MOVWF  01
05AFA:  MOVLW  01
05AFC:  ADDWFC 03,F
05AFE:  MOVFF  01,5E7
05B02:  MOVFF  03,5E8
05B06:  MOVFF  03,5FD
05B0A:  MOVFF  01,5FC
05B0E:  MOVLB  0
05B10:  CALL   42BC
05B14:  MOVF   01,F
05B16:  BNZ   5B20
05B18:  MOVLW  02
05B1A:  MOVWF  01
05B1C:  BRA    5CAA
05B1E:  BRA    5B80
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
05B20:  MOVLB  5
05B22:  CLRF   xFB
05B24:  MOVFF  5D6,5FA
05B28:  CLRF   xFD
05B2A:  MOVLW  B5
05B2C:  MOVWF  xFC
05B2E:  MOVLB  0
05B30:  CALL   0816
05B34:  MOVFF  02,5E8
05B38:  MOVFF  01,5E7
05B3C:  MOVLW  06
05B3E:  MOVLB  5
05B40:  ADDWF  xE7,F
05B42:  MOVLW  00
05B44:  ADDWFC xE8,F
05B46:  MOVLW  32
05B48:  ADDWF  xE7,W
05B4A:  MOVWF  01
05B4C:  MOVLW  00
05B4E:  ADDWFC xE8,W
05B50:  MOVWF  03
05B52:  MOVF   01,W
05B54:  ADDLW  53
05B56:  MOVWF  01
05B58:  MOVLW  01
05B5A:  ADDWFC 03,F
05B5C:  MOVFF  01,5E7
05B60:  MOVFF  03,5E8
05B64:  MOVFF  03,5FD
05B68:  MOVFF  01,5FC
05B6C:  CLRF   xFF
05B6E:  CLRF   xFE
05B70:  MOVLW  0A
05B72:  MOVLB  6
05B74:  MOVWF  x00
05B76:  MOVLB  0
05B78:  CALL   43AC
05B7C:  MOVFF  01,5E2
....................    
....................    if (!arg_is_float(strtod(SERcmd[rec].p[3], '\0'))) return INV_PARAM;
05B80:  MOVLB  5
05B82:  CLRF   xFB
05B84:  MOVFF  5D6,5FA
05B88:  CLRF   xFD
05B8A:  MOVLW  B5
05B8C:  MOVWF  xFC
05B8E:  MOVLB  0
05B90:  CALL   0816
05B94:  MOVFF  02,5E8
05B98:  MOVFF  01,5E7
05B9C:  MOVLW  06
05B9E:  MOVLB  5
05BA0:  ADDWF  xE7,F
05BA2:  MOVLW  00
05BA4:  ADDWFC xE8,F
05BA6:  MOVLW  4B
05BA8:  ADDWF  xE7,W
05BAA:  MOVWF  01
05BAC:  MOVLW  00
05BAE:  ADDWFC xE8,W
05BB0:  MOVWF  03
05BB2:  MOVF   01,W
05BB4:  ADDLW  53
05BB6:  MOVWF  01
05BB8:  MOVLW  01
05BBA:  ADDWFC 03,F
05BBC:  MOVFF  01,5E7
05BC0:  MOVFF  03,5E8
05BC4:  MOVFF  03,5EC
05BC8:  MOVFF  01,5EB
05BCC:  CLRF   xEE
05BCE:  CLRF   xED
05BD0:  MOVLB  0
05BD2:  CALL   535A
05BD6:  MOVFF  03,62F
05BDA:  MOVFF  02,62E
05BDE:  MOVFF  01,62D
05BE2:  MOVFF  00,62C
05BE6:  CALL   1D1A
05BEA:  MOVFF  02,5E8
05BEE:  MOVFF  01,5E7
05BF2:  MOVFF  02,5EC
05BF6:  MOVFF  01,5EB
05BFA:  RCALL  55BA
05BFC:  MOVF   01,F
05BFE:  BNZ   5C08
05C00:  MOVLW  02
05C02:  MOVWF  01
05C04:  BRA    5CAA
05C06:  BRA    5C6E
....................    else arg2 = strtod(SERcmd[rec].p[3], '\0');
05C08:  MOVLB  5
05C0A:  CLRF   xFB
05C0C:  MOVFF  5D6,5FA
05C10:  CLRF   xFD
05C12:  MOVLW  B5
05C14:  MOVWF  xFC
05C16:  MOVLB  0
05C18:  CALL   0816
05C1C:  MOVFF  02,5E8
05C20:  MOVFF  01,5E7
05C24:  MOVLW  06
05C26:  MOVLB  5
05C28:  ADDWF  xE7,F
05C2A:  MOVLW  00
05C2C:  ADDWFC xE8,F
05C2E:  MOVLW  4B
05C30:  ADDWF  xE7,W
05C32:  MOVWF  01
05C34:  MOVLW  00
05C36:  ADDWFC xE8,W
05C38:  MOVWF  03
05C3A:  MOVF   01,W
05C3C:  ADDLW  53
05C3E:  MOVWF  01
05C40:  MOVLW  01
05C42:  ADDWFC 03,F
05C44:  MOVFF  01,5E7
05C48:  MOVFF  03,5E8
05C4C:  MOVFF  03,5EC
05C50:  MOVFF  01,5EB
05C54:  CLRF   xEE
05C56:  CLRF   xED
05C58:  MOVLB  0
05C5A:  CALL   535A
05C5E:  MOVFF  03,5E6
05C62:  MOVFF  02,5E5
05C66:  MOVFF  01,5E4
05C6A:  MOVFF  00,5E3
....................    
....................    /*** SET SETPOINT ******************/ 
....................    PID[arg1-1].SP = arg2;
05C6E:  MOVLW  01
05C70:  MOVLB  5
05C72:  SUBWF  xE2,W
05C74:  MULLW  20
05C76:  MOVF   FF3,W
05C78:  CLRF   xE8
05C7A:  MOVWF  xE7
05C7C:  MOVLW  0C
05C7E:  ADDWF  xE7,W
05C80:  MOVWF  01
05C82:  MOVLW  00
05C84:  ADDWFC xE8,W
05C86:  MOVWF  03
05C88:  MOVF   01,W
05C8A:  ADDLW  20
05C8C:  MOVWF  FE9
05C8E:  MOVLW  00
05C90:  ADDWFC 03,W
05C92:  MOVWF  FEA
05C94:  MOVFF  5E3,FEF
05C98:  MOVFF  5E4,FEC
05C9C:  MOVFF  5E5,FEC
05CA0:  MOVFF  5E6,FEC
....................    
....................    return SUCCESS;
05CA4:  MOVLW  00
05CA6:  MOVWF  01
05CA8:  MOVLB  0
05CAA:  RETURN 0
.................... }
.................... 
.................... int8 getAllSensorCalParams(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
05CAC:  MOVLB  5
05CAE:  CLRF   xFB
05CB0:  MOVFF  5D6,5FA
05CB4:  CLRF   xFD
05CB6:  MOVLW  B5
05CB8:  MOVWF  xFC
05CBA:  MOVLB  0
05CBC:  CALL   0816
05CC0:  MOVFF  02,5E4
05CC4:  MOVFF  01,5E3
05CC8:  MOVLW  06
05CCA:  MOVLB  5
05CCC:  ADDWF  xE3,F
05CCE:  MOVLW  00
05CD0:  ADDWFC xE4,F
05CD2:  MOVLW  32
05CD4:  ADDWF  xE3,W
05CD6:  MOVWF  01
05CD8:  MOVLW  00
05CDA:  ADDWFC xE4,W
05CDC:  MOVWF  03
05CDE:  MOVF   01,W
05CE0:  ADDLW  53
05CE2:  MOVWF  01
05CE4:  MOVLW  01
05CE6:  ADDWFC 03,F
05CE8:  MOVFF  01,5E3
05CEC:  MOVFF  03,5E4
05CF0:  MOVFF  03,5FD
05CF4:  MOVFF  01,5FC
05CF8:  MOVLB  0
05CFA:  CALL   42BC
05CFE:  MOVF   01,F
05D00:  BNZ   5D0A
05D02:  MOVLW  02
05D04:  MOVWF  01
05D06:  BRA    602A
05D08:  BRA    5D6A
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
05D0A:  MOVLB  5
05D0C:  CLRF   xFB
05D0E:  MOVFF  5D6,5FA
05D12:  CLRF   xFD
05D14:  MOVLW  B5
05D16:  MOVWF  xFC
05D18:  MOVLB  0
05D1A:  CALL   0816
05D1E:  MOVFF  02,5E4
05D22:  MOVFF  01,5E3
05D26:  MOVLW  06
05D28:  MOVLB  5
05D2A:  ADDWF  xE3,F
05D2C:  MOVLW  00
05D2E:  ADDWFC xE4,F
05D30:  MOVLW  32
05D32:  ADDWF  xE3,W
05D34:  MOVWF  01
05D36:  MOVLW  00
05D38:  ADDWFC xE4,W
05D3A:  MOVWF  03
05D3C:  MOVF   01,W
05D3E:  ADDLW  53
05D40:  MOVWF  01
05D42:  MOVLW  01
05D44:  ADDWFC 03,F
05D46:  MOVFF  01,5E3
05D4A:  MOVFF  03,5E4
05D4E:  MOVFF  03,5FD
05D52:  MOVFF  01,5FC
05D56:  CLRF   xFF
05D58:  CLRF   xFE
05D5A:  MOVLW  0A
05D5C:  MOVLB  6
05D5E:  MOVWF  x00
05D60:  MOVLB  0
05D62:  CALL   43AC
05D66:  MOVFF  01,5E2
....................    
....................    /*** GET ALL SENSOR CAL PARAMS *****/
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c0);
05D6A:  MOVLW  04
05D6C:  MOVLB  5
05D6E:  MOVWF  xFF
05D70:  MOVLW  29
05D72:  MOVWF  xFE
05D74:  MOVLB  0
05D76:  CALL   413C
05D7A:  MOVFF  02,03
05D7E:  MOVF   01,W
05D80:  ADDLW  29
05D82:  MOVLB  5
05D84:  MOVWF  xE3
05D86:  MOVLW  04
05D88:  ADDWFC 02,W
05D8A:  MOVWF  xE4
05D8C:  MOVLW  01
05D8E:  SUBWF  xE2,W
05D90:  MULLW  18
05D92:  MOVF   FF3,W
05D94:  CLRF   xE6
05D96:  MOVWF  xE5
05D98:  MOVLW  82
05D9A:  ADDWF  xE5,W
05D9C:  MOVWF  FE9
05D9E:  MOVLW  00
05DA0:  ADDWFC xE6,W
05DA2:  MOVWF  FEA
05DA4:  MOVFF  FEF,600
05DA8:  MOVFF  FEC,601
05DAC:  MOVFF  FEC,602
05DB0:  MOVFF  FEC,603
05DB4:  MOVFF  5E4,4CE
05DB8:  MOVFF  5E3,4CD
05DBC:  MOVLW  89
05DBE:  MOVWF  FE9
05DC0:  MOVLW  02
05DC2:  MOVLB  6
05DC4:  MOVWF  x04
05DC6:  MOVLB  0
05DC8:  CALL   4ECA
05DCC:  MOVLW  2C
05DCE:  MOVLB  6
05DD0:  MOVWF  x0D
05DD2:  MOVLB  0
05DD4:  CALL   41F4
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c1);
05DD8:  MOVLW  04
05DDA:  MOVLB  5
05DDC:  MOVWF  xFF
05DDE:  MOVLW  29
05DE0:  MOVWF  xFE
05DE2:  MOVLB  0
05DE4:  CALL   413C
05DE8:  MOVF   01,W
05DEA:  ADDLW  29
05DEC:  MOVLB  5
05DEE:  MOVWF  xE3
05DF0:  MOVLW  04
05DF2:  ADDWFC 02,W
05DF4:  MOVWF  xE4
05DF6:  MOVLW  01
05DF8:  SUBWF  xE2,W
05DFA:  MULLW  18
05DFC:  MOVF   FF3,W
05DFE:  CLRF   xE6
05E00:  MOVWF  xE5
05E02:  MOVLW  04
05E04:  ADDWF  xE5,W
05E06:  MOVWF  01
05E08:  MOVLW  00
05E0A:  ADDWFC xE6,W
05E0C:  MOVWF  03
05E0E:  MOVF   01,W
05E10:  ADDLW  82
05E12:  MOVWF  FE9
05E14:  MOVLW  00
05E16:  ADDWFC 03,W
05E18:  MOVWF  FEA
05E1A:  MOVFF  FEF,600
05E1E:  MOVFF  FEC,601
05E22:  MOVFF  FEC,602
05E26:  MOVFF  FEC,603
05E2A:  MOVFF  5E4,4CE
05E2E:  MOVFF  5E3,4CD
05E32:  MOVLW  89
05E34:  MOVWF  FE9
05E36:  MOVLW  02
05E38:  MOVLB  6
05E3A:  MOVWF  x04
05E3C:  MOVLB  0
05E3E:  CALL   4ECA
05E42:  MOVLW  2C
05E44:  MOVLB  6
05E46:  MOVWF  x0D
05E48:  MOVLB  0
05E4A:  CALL   41F4
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c2);
05E4E:  MOVLW  04
05E50:  MOVLB  5
05E52:  MOVWF  xFF
05E54:  MOVLW  29
05E56:  MOVWF  xFE
05E58:  MOVLB  0
05E5A:  CALL   413C
05E5E:  MOVF   01,W
05E60:  ADDLW  29
05E62:  MOVLB  5
05E64:  MOVWF  xE3
05E66:  MOVLW  04
05E68:  ADDWFC 02,W
05E6A:  MOVWF  xE4
05E6C:  MOVLW  01
05E6E:  SUBWF  xE2,W
05E70:  MULLW  18
05E72:  MOVF   FF3,W
05E74:  CLRF   xE6
05E76:  MOVWF  xE5
05E78:  MOVLW  08
05E7A:  ADDWF  xE5,W
05E7C:  MOVWF  01
05E7E:  MOVLW  00
05E80:  ADDWFC xE6,W
05E82:  MOVWF  03
05E84:  MOVF   01,W
05E86:  ADDLW  82
05E88:  MOVWF  FE9
05E8A:  MOVLW  00
05E8C:  ADDWFC 03,W
05E8E:  MOVWF  FEA
05E90:  MOVFF  FEF,600
05E94:  MOVFF  FEC,601
05E98:  MOVFF  FEC,602
05E9C:  MOVFF  FEC,603
05EA0:  MOVFF  5E4,4CE
05EA4:  MOVFF  5E3,4CD
05EA8:  MOVLW  89
05EAA:  MOVWF  FE9
05EAC:  MOVLW  02
05EAE:  MOVLB  6
05EB0:  MOVWF  x04
05EB2:  MOVLB  0
05EB4:  CALL   4ECA
05EB8:  MOVLW  2C
05EBA:  MOVLB  6
05EBC:  MOVWF  x0D
05EBE:  MOVLB  0
05EC0:  CALL   41F4
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c3);
05EC4:  MOVLW  04
05EC6:  MOVLB  5
05EC8:  MOVWF  xFF
05ECA:  MOVLW  29
05ECC:  MOVWF  xFE
05ECE:  MOVLB  0
05ED0:  CALL   413C
05ED4:  MOVF   01,W
05ED6:  ADDLW  29
05ED8:  MOVLB  5
05EDA:  MOVWF  xE3
05EDC:  MOVLW  04
05EDE:  ADDWFC 02,W
05EE0:  MOVWF  xE4
05EE2:  MOVLW  01
05EE4:  SUBWF  xE2,W
05EE6:  MULLW  18
05EE8:  MOVF   FF3,W
05EEA:  CLRF   xE6
05EEC:  MOVWF  xE5
05EEE:  MOVLW  0C
05EF0:  ADDWF  xE5,W
05EF2:  MOVWF  01
05EF4:  MOVLW  00
05EF6:  ADDWFC xE6,W
05EF8:  MOVWF  03
05EFA:  MOVF   01,W
05EFC:  ADDLW  82
05EFE:  MOVWF  FE9
05F00:  MOVLW  00
05F02:  ADDWFC 03,W
05F04:  MOVWF  FEA
05F06:  MOVFF  FEF,600
05F0A:  MOVFF  FEC,601
05F0E:  MOVFF  FEC,602
05F12:  MOVFF  FEC,603
05F16:  MOVFF  5E4,4CE
05F1A:  MOVFF  5E3,4CD
05F1E:  MOVLW  89
05F20:  MOVWF  FE9
05F22:  MOVLW  02
05F24:  MOVLB  6
05F26:  MOVWF  x04
05F28:  MOVLB  0
05F2A:  CALL   4ECA
05F2E:  MOVLW  2C
05F30:  MOVLB  6
05F32:  MOVWF  x0D
05F34:  MOVLB  0
05F36:  CALL   41F4
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c4);
05F3A:  MOVLW  04
05F3C:  MOVLB  5
05F3E:  MOVWF  xFF
05F40:  MOVLW  29
05F42:  MOVWF  xFE
05F44:  MOVLB  0
05F46:  CALL   413C
05F4A:  MOVF   01,W
05F4C:  ADDLW  29
05F4E:  MOVLB  5
05F50:  MOVWF  xE3
05F52:  MOVLW  04
05F54:  ADDWFC 02,W
05F56:  MOVWF  xE4
05F58:  MOVLW  01
05F5A:  SUBWF  xE2,W
05F5C:  MULLW  18
05F5E:  MOVF   FF3,W
05F60:  CLRF   xE6
05F62:  MOVWF  xE5
05F64:  MOVLW  10
05F66:  ADDWF  xE5,W
05F68:  MOVWF  01
05F6A:  MOVLW  00
05F6C:  ADDWFC xE6,W
05F6E:  MOVWF  03
05F70:  MOVF   01,W
05F72:  ADDLW  82
05F74:  MOVWF  FE9
05F76:  MOVLW  00
05F78:  ADDWFC 03,W
05F7A:  MOVWF  FEA
05F7C:  MOVFF  FEF,600
05F80:  MOVFF  FEC,601
05F84:  MOVFF  FEC,602
05F88:  MOVFF  FEC,603
05F8C:  MOVFF  5E4,4CE
05F90:  MOVFF  5E3,4CD
05F94:  MOVLW  89
05F96:  MOVWF  FE9
05F98:  MOVLW  02
05F9A:  MOVLB  6
05F9C:  MOVWF  x04
05F9E:  MOVLB  0
05FA0:  CALL   4ECA
05FA4:  MOVLW  2C
05FA6:  MOVLB  6
05FA8:  MOVWF  x0D
05FAA:  MOVLB  0
05FAC:  CALL   41F4
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c5);
05FB0:  MOVLW  04
05FB2:  MOVLB  5
05FB4:  MOVWF  xFF
05FB6:  MOVLW  29
05FB8:  MOVWF  xFE
05FBA:  MOVLB  0
05FBC:  CALL   413C
05FC0:  MOVF   01,W
05FC2:  ADDLW  29
05FC4:  MOVLB  5
05FC6:  MOVWF  xE3
05FC8:  MOVLW  04
05FCA:  ADDWFC 02,W
05FCC:  MOVWF  xE4
05FCE:  MOVLW  01
05FD0:  SUBWF  xE2,W
05FD2:  MULLW  18
05FD4:  MOVF   FF3,W
05FD6:  CLRF   xE6
05FD8:  MOVWF  xE5
05FDA:  MOVLW  14
05FDC:  ADDWF  xE5,W
05FDE:  MOVWF  01
05FE0:  MOVLW  00
05FE2:  ADDWFC xE6,W
05FE4:  MOVWF  03
05FE6:  MOVF   01,W
05FE8:  ADDLW  82
05FEA:  MOVWF  FE9
05FEC:  MOVLW  00
05FEE:  ADDWFC 03,W
05FF0:  MOVWF  FEA
05FF2:  MOVFF  FEF,600
05FF6:  MOVFF  FEC,601
05FFA:  MOVFF  FEC,602
05FFE:  MOVFF  FEC,603
06002:  MOVFF  5E4,4CE
06006:  MOVFF  5E3,4CD
0600A:  MOVLW  89
0600C:  MOVWF  FE9
0600E:  MOVLW  02
06010:  MOVLB  6
06012:  MOVWF  x04
06014:  MOVLB  0
06016:  CALL   4ECA
0601A:  MOVLW  2C
0601C:  MOVLB  6
0601E:  MOVWF  x0D
06020:  MOVLB  0
06022:  CALL   41F4
....................    
....................    return SUCCESS;
06026:  MOVLW  00
06028:  MOVWF  01
0602A:  RETURN 0
.................... }
.................... 
.................... int8 getSensorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0602C:  MOVLB  5
0602E:  CLRF   xFB
06030:  MOVFF  5D6,5FA
06034:  CLRF   xFD
06036:  MOVLW  B5
06038:  MOVWF  xFC
0603A:  MOVLB  0
0603C:  CALL   0816
06040:  MOVFF  02,5E5
06044:  MOVFF  01,5E4
06048:  MOVLW  06
0604A:  MOVLB  5
0604C:  ADDWF  xE4,F
0604E:  MOVLW  00
06050:  ADDWFC xE5,F
06052:  MOVLW  32
06054:  ADDWF  xE4,W
06056:  MOVWF  01
06058:  MOVLW  00
0605A:  ADDWFC xE5,W
0605C:  MOVWF  03
0605E:  MOVF   01,W
06060:  ADDLW  53
06062:  MOVWF  01
06064:  MOVLW  01
06066:  ADDWFC 03,F
06068:  MOVFF  01,5E4
0606C:  MOVFF  03,5E5
06070:  MOVFF  03,5FD
06074:  MOVFF  01,5FC
06078:  MOVLB  0
0607A:  CALL   42BC
0607E:  MOVF   01,F
06080:  BNZ   608A
06082:  MOVLW  02
06084:  MOVWF  01
06086:  BRA    648C
06088:  BRA    60EA
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
0608A:  MOVLB  5
0608C:  CLRF   xFB
0608E:  MOVFF  5D6,5FA
06092:  CLRF   xFD
06094:  MOVLW  B5
06096:  MOVWF  xFC
06098:  MOVLB  0
0609A:  CALL   0816
0609E:  MOVFF  02,5E5
060A2:  MOVFF  01,5E4
060A6:  MOVLW  06
060A8:  MOVLB  5
060AA:  ADDWF  xE4,F
060AC:  MOVLW  00
060AE:  ADDWFC xE5,F
060B0:  MOVLW  32
060B2:  ADDWF  xE4,W
060B4:  MOVWF  01
060B6:  MOVLW  00
060B8:  ADDWFC xE5,W
060BA:  MOVWF  03
060BC:  MOVF   01,W
060BE:  ADDLW  53
060C0:  MOVWF  01
060C2:  MOVLW  01
060C4:  ADDWFC 03,F
060C6:  MOVFF  01,5E4
060CA:  MOVFF  03,5E5
060CE:  MOVFF  03,5FD
060D2:  MOVFF  01,5FC
060D6:  CLRF   xFF
060D8:  CLRF   xFE
060DA:  MOVLW  0A
060DC:  MOVLB  6
060DE:  MOVWF  x00
060E0:  MOVLB  0
060E2:  CALL   43AC
060E6:  MOVFF  01,5E2
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
060EA:  MOVLB  5
060EC:  CLRF   xFB
060EE:  MOVFF  5D6,5FA
060F2:  CLRF   xFD
060F4:  MOVLW  B5
060F6:  MOVWF  xFC
060F8:  MOVLB  0
060FA:  CALL   0816
060FE:  MOVFF  02,5E5
06102:  MOVFF  01,5E4
06106:  MOVLW  06
06108:  MOVLB  5
0610A:  ADDWF  xE4,F
0610C:  MOVLW  00
0610E:  ADDWFC xE5,F
06110:  MOVLW  4B
06112:  ADDWF  xE4,W
06114:  MOVWF  01
06116:  MOVLW  00
06118:  ADDWFC xE5,W
0611A:  MOVWF  03
0611C:  MOVF   01,W
0611E:  ADDLW  53
06120:  MOVWF  01
06122:  MOVLW  01
06124:  ADDWFC 03,F
06126:  MOVFF  01,5E4
0612A:  MOVFF  03,5E5
0612E:  MOVFF  03,5FF
06132:  MOVFF  01,5FE
06136:  MOVLB  0
06138:  CALL   413C
0613C:  MOVFF  02,03
06140:  MOVF   01,W
06142:  SUBLW  01
06144:  BNZ   614A
06146:  MOVF   03,F
06148:  BZ    6152
0614A:  MOVLW  02
0614C:  MOVWF  01
0614E:  BRA    648C
06150:  BRA    6192
....................    else arg2 = SERcmd[rec].p[3][0];
06152:  MOVLB  5
06154:  CLRF   xFB
06156:  MOVFF  5D6,5FA
0615A:  CLRF   xFD
0615C:  MOVLW  B5
0615E:  MOVWF  xFC
06160:  MOVLB  0
06162:  CALL   0816
06166:  MOVFF  02,5E5
0616A:  MOVFF  01,5E4
0616E:  MOVLW  06
06170:  MOVLB  5
06172:  ADDWF  xE4,F
06174:  MOVLW  00
06176:  ADDWFC xE5,F
06178:  MOVLW  4B
0617A:  ADDWF  xE4,F
0617C:  MOVLW  00
0617E:  ADDWFC xE5,F
06180:  MOVLW  53
06182:  ADDWF  xE4,W
06184:  MOVWF  FE9
06186:  MOVLW  01
06188:  ADDWFC xE5,W
0618A:  MOVWF  FEA
0618C:  MOVFF  FEF,5E3
06190:  MOVLB  0
....................    
....................    /*** GET SENSOR CAL PARAM **********/
....................    if      ('0' == arg2) sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c0);
06192:  MOVLB  5
06194:  MOVF   xE3,W
06196:  SUBLW  30
06198:  BNZ   620A
0619A:  MOVLW  04
0619C:  MOVWF  xFF
0619E:  MOVLW  29
061A0:  MOVWF  xFE
061A2:  MOVLB  0
061A4:  CALL   413C
061A8:  MOVFF  02,03
061AC:  MOVF   01,W
061AE:  ADDLW  29
061B0:  MOVLB  5
061B2:  MOVWF  xE4
061B4:  MOVLW  04
061B6:  ADDWFC 02,W
061B8:  MOVWF  xE5
061BA:  MOVLW  01
061BC:  SUBWF  xE2,W
061BE:  MULLW  18
061C0:  MOVF   FF3,W
061C2:  CLRF   xE7
061C4:  MOVWF  xE6
061C6:  MOVLW  82
061C8:  ADDWF  xE6,W
061CA:  MOVWF  FE9
061CC:  MOVLW  00
061CE:  ADDWFC xE7,W
061D0:  MOVWF  FEA
061D2:  MOVFF  FEF,600
061D6:  MOVFF  FEC,601
061DA:  MOVFF  FEC,602
061DE:  MOVFF  FEC,603
061E2:  MOVFF  5E5,4CE
061E6:  MOVFF  5E4,4CD
061EA:  MOVLW  89
061EC:  MOVWF  FE9
061EE:  MOVLW  02
061F0:  MOVLB  6
061F2:  MOVWF  x04
061F4:  MOVLB  0
061F6:  CALL   4ECA
061FA:  MOVLW  2C
061FC:  MOVLB  6
061FE:  MOVWF  x0D
06200:  MOVLB  0
06202:  CALL   41F4
06206:  BRA    6488
06208:  MOVLB  5
....................    else if ('1' == arg2) sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c1);
0620A:  MOVF   xE3,W
0620C:  SUBLW  31
0620E:  BNZ   6288
06210:  MOVLW  04
06212:  MOVWF  xFF
06214:  MOVLW  29
06216:  MOVWF  xFE
06218:  MOVLB  0
0621A:  CALL   413C
0621E:  MOVF   01,W
06220:  ADDLW  29
06222:  MOVLB  5
06224:  MOVWF  xE4
06226:  MOVLW  04
06228:  ADDWFC 02,W
0622A:  MOVWF  xE5
0622C:  MOVLW  01
0622E:  SUBWF  xE2,W
06230:  MULLW  18
06232:  MOVF   FF3,W
06234:  CLRF   xE7
06236:  MOVWF  xE6
06238:  MOVLW  04
0623A:  ADDWF  xE6,W
0623C:  MOVWF  01
0623E:  MOVLW  00
06240:  ADDWFC xE7,W
06242:  MOVWF  03
06244:  MOVF   01,W
06246:  ADDLW  82
06248:  MOVWF  FE9
0624A:  MOVLW  00
0624C:  ADDWFC 03,W
0624E:  MOVWF  FEA
06250:  MOVFF  FEF,600
06254:  MOVFF  FEC,601
06258:  MOVFF  FEC,602
0625C:  MOVFF  FEC,603
06260:  MOVFF  5E5,4CE
06264:  MOVFF  5E4,4CD
06268:  MOVLW  89
0626A:  MOVWF  FE9
0626C:  MOVLW  02
0626E:  MOVLB  6
06270:  MOVWF  x04
06272:  MOVLB  0
06274:  CALL   4ECA
06278:  MOVLW  2C
0627A:  MOVLB  6
0627C:  MOVWF  x0D
0627E:  MOVLB  0
06280:  CALL   41F4
06284:  BRA    6488
06286:  MOVLB  5
....................    else if ('2' == arg2) sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c2);
06288:  MOVF   xE3,W
0628A:  SUBLW  32
0628C:  BNZ   6306
0628E:  MOVLW  04
06290:  MOVWF  xFF
06292:  MOVLW  29
06294:  MOVWF  xFE
06296:  MOVLB  0
06298:  CALL   413C
0629C:  MOVF   01,W
0629E:  ADDLW  29
062A0:  MOVLB  5
062A2:  MOVWF  xE4
062A4:  MOVLW  04
062A6:  ADDWFC 02,W
062A8:  MOVWF  xE5
062AA:  MOVLW  01
062AC:  SUBWF  xE2,W
062AE:  MULLW  18
062B0:  MOVF   FF3,W
062B2:  CLRF   xE7
062B4:  MOVWF  xE6
062B6:  MOVLW  08
062B8:  ADDWF  xE6,W
062BA:  MOVWF  01
062BC:  MOVLW  00
062BE:  ADDWFC xE7,W
062C0:  MOVWF  03
062C2:  MOVF   01,W
062C4:  ADDLW  82
062C6:  MOVWF  FE9
062C8:  MOVLW  00
062CA:  ADDWFC 03,W
062CC:  MOVWF  FEA
062CE:  MOVFF  FEF,600
062D2:  MOVFF  FEC,601
062D6:  MOVFF  FEC,602
062DA:  MOVFF  FEC,603
062DE:  MOVFF  5E5,4CE
062E2:  MOVFF  5E4,4CD
062E6:  MOVLW  89
062E8:  MOVWF  FE9
062EA:  MOVLW  02
062EC:  MOVLB  6
062EE:  MOVWF  x04
062F0:  MOVLB  0
062F2:  CALL   4ECA
062F6:  MOVLW  2C
062F8:  MOVLB  6
062FA:  MOVWF  x0D
062FC:  MOVLB  0
062FE:  CALL   41F4
06302:  BRA    6488
06304:  MOVLB  5
....................    else if ('3' == arg2) sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c3);
06306:  MOVF   xE3,W
06308:  SUBLW  33
0630A:  BNZ   6384
0630C:  MOVLW  04
0630E:  MOVWF  xFF
06310:  MOVLW  29
06312:  MOVWF  xFE
06314:  MOVLB  0
06316:  CALL   413C
0631A:  MOVF   01,W
0631C:  ADDLW  29
0631E:  MOVLB  5
06320:  MOVWF  xE4
06322:  MOVLW  04
06324:  ADDWFC 02,W
06326:  MOVWF  xE5
06328:  MOVLW  01
0632A:  SUBWF  xE2,W
0632C:  MULLW  18
0632E:  MOVF   FF3,W
06330:  CLRF   xE7
06332:  MOVWF  xE6
06334:  MOVLW  0C
06336:  ADDWF  xE6,W
06338:  MOVWF  01
0633A:  MOVLW  00
0633C:  ADDWFC xE7,W
0633E:  MOVWF  03
06340:  MOVF   01,W
06342:  ADDLW  82
06344:  MOVWF  FE9
06346:  MOVLW  00
06348:  ADDWFC 03,W
0634A:  MOVWF  FEA
0634C:  MOVFF  FEF,600
06350:  MOVFF  FEC,601
06354:  MOVFF  FEC,602
06358:  MOVFF  FEC,603
0635C:  MOVFF  5E5,4CE
06360:  MOVFF  5E4,4CD
06364:  MOVLW  89
06366:  MOVWF  FE9
06368:  MOVLW  02
0636A:  MOVLB  6
0636C:  MOVWF  x04
0636E:  MOVLB  0
06370:  CALL   4ECA
06374:  MOVLW  2C
06376:  MOVLB  6
06378:  MOVWF  x0D
0637A:  MOVLB  0
0637C:  CALL   41F4
06380:  BRA    6488
06382:  MOVLB  5
....................    else if ('4' == arg2) sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c4);
06384:  MOVF   xE3,W
06386:  SUBLW  34
06388:  BNZ   6402
0638A:  MOVLW  04
0638C:  MOVWF  xFF
0638E:  MOVLW  29
06390:  MOVWF  xFE
06392:  MOVLB  0
06394:  CALL   413C
06398:  MOVF   01,W
0639A:  ADDLW  29
0639C:  MOVLB  5
0639E:  MOVWF  xE4
063A0:  MOVLW  04
063A2:  ADDWFC 02,W
063A4:  MOVWF  xE5
063A6:  MOVLW  01
063A8:  SUBWF  xE2,W
063AA:  MULLW  18
063AC:  MOVF   FF3,W
063AE:  CLRF   xE7
063B0:  MOVWF  xE6
063B2:  MOVLW  10
063B4:  ADDWF  xE6,W
063B6:  MOVWF  01
063B8:  MOVLW  00
063BA:  ADDWFC xE7,W
063BC:  MOVWF  03
063BE:  MOVF   01,W
063C0:  ADDLW  82
063C2:  MOVWF  FE9
063C4:  MOVLW  00
063C6:  ADDWFC 03,W
063C8:  MOVWF  FEA
063CA:  MOVFF  FEF,600
063CE:  MOVFF  FEC,601
063D2:  MOVFF  FEC,602
063D6:  MOVFF  FEC,603
063DA:  MOVFF  5E5,4CE
063DE:  MOVFF  5E4,4CD
063E2:  MOVLW  89
063E4:  MOVWF  FE9
063E6:  MOVLW  02
063E8:  MOVLB  6
063EA:  MOVWF  x04
063EC:  MOVLB  0
063EE:  CALL   4ECA
063F2:  MOVLW  2C
063F4:  MOVLB  6
063F6:  MOVWF  x0D
063F8:  MOVLB  0
063FA:  CALL   41F4
063FE:  BRA    6488
06400:  MOVLB  5
....................    else if ('5' == arg2) sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c5);
06402:  MOVF   xE3,W
06404:  SUBLW  35
06406:  BNZ   6480
06408:  MOVLW  04
0640A:  MOVWF  xFF
0640C:  MOVLW  29
0640E:  MOVWF  xFE
06410:  MOVLB  0
06412:  CALL   413C
06416:  MOVF   01,W
06418:  ADDLW  29
0641A:  MOVLB  5
0641C:  MOVWF  xE4
0641E:  MOVLW  04
06420:  ADDWFC 02,W
06422:  MOVWF  xE5
06424:  MOVLW  01
06426:  SUBWF  xE2,W
06428:  MULLW  18
0642A:  MOVF   FF3,W
0642C:  CLRF   xE7
0642E:  MOVWF  xE6
06430:  MOVLW  14
06432:  ADDWF  xE6,W
06434:  MOVWF  01
06436:  MOVLW  00
06438:  ADDWFC xE7,W
0643A:  MOVWF  03
0643C:  MOVF   01,W
0643E:  ADDLW  82
06440:  MOVWF  FE9
06442:  MOVLW  00
06444:  ADDWFC 03,W
06446:  MOVWF  FEA
06448:  MOVFF  FEF,600
0644C:  MOVFF  FEC,601
06450:  MOVFF  FEC,602
06454:  MOVFF  FEC,603
06458:  MOVFF  5E5,4CE
0645C:  MOVFF  5E4,4CD
06460:  MOVLW  89
06462:  MOVWF  FE9
06464:  MOVLW  02
06466:  MOVLB  6
06468:  MOVWF  x04
0646A:  MOVLB  0
0646C:  CALL   4ECA
06470:  MOVLW  2C
06472:  MOVLB  6
06474:  MOVWF  x0D
06476:  MOVLB  0
06478:  CALL   41F4
0647C:  BRA    6488
0647E:  MOVLB  5
....................    else return INV_PARAM;
06480:  MOVLW  02
06482:  MOVWF  01
06484:  MOVLB  0
06486:  BRA    648C
....................    
....................    return SUCCESS;
06488:  MOVLW  00
0648A:  MOVWF  01
0648C:  RETURN 0
.................... }
.................... 
.................... int8 setSensorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char  arg2;
....................    float arg3;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0648E:  MOVLB  5
06490:  CLRF   xFB
06492:  MOVFF  5D6,5FA
06496:  CLRF   xFD
06498:  MOVLW  B5
0649A:  MOVWF  xFC
0649C:  MOVLB  0
0649E:  CALL   0816
064A2:  MOVFF  02,5E9
064A6:  MOVFF  01,5E8
064AA:  MOVLW  06
064AC:  MOVLB  5
064AE:  ADDWF  xE8,F
064B0:  MOVLW  00
064B2:  ADDWFC xE9,F
064B4:  MOVLW  32
064B6:  ADDWF  xE8,W
064B8:  MOVWF  01
064BA:  MOVLW  00
064BC:  ADDWFC xE9,W
064BE:  MOVWF  03
064C0:  MOVF   01,W
064C2:  ADDLW  53
064C4:  MOVWF  01
064C6:  MOVLW  01
064C8:  ADDWFC 03,F
064CA:  MOVFF  01,5E8
064CE:  MOVFF  03,5E9
064D2:  MOVFF  03,5FD
064D6:  MOVFF  01,5FC
064DA:  MOVLB  0
064DC:  CALL   42BC
064E0:  MOVF   01,F
064E2:  BNZ   64EC
064E4:  MOVLW  02
064E6:  MOVWF  01
064E8:  BRA    6852
064EA:  BRA    654C
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
064EC:  MOVLB  5
064EE:  CLRF   xFB
064F0:  MOVFF  5D6,5FA
064F4:  CLRF   xFD
064F6:  MOVLW  B5
064F8:  MOVWF  xFC
064FA:  MOVLB  0
064FC:  CALL   0816
06500:  MOVFF  02,5E9
06504:  MOVFF  01,5E8
06508:  MOVLW  06
0650A:  MOVLB  5
0650C:  ADDWF  xE8,F
0650E:  MOVLW  00
06510:  ADDWFC xE9,F
06512:  MOVLW  32
06514:  ADDWF  xE8,W
06516:  MOVWF  01
06518:  MOVLW  00
0651A:  ADDWFC xE9,W
0651C:  MOVWF  03
0651E:  MOVF   01,W
06520:  ADDLW  53
06522:  MOVWF  01
06524:  MOVLW  01
06526:  ADDWFC 03,F
06528:  MOVFF  01,5E8
0652C:  MOVFF  03,5E9
06530:  MOVFF  03,5FD
06534:  MOVFF  01,5FC
06538:  CLRF   xFF
0653A:  CLRF   xFE
0653C:  MOVLW  0A
0653E:  MOVLB  6
06540:  MOVWF  x00
06542:  MOVLB  0
06544:  CALL   43AC
06548:  MOVFF  01,5E2
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
0654C:  MOVLB  5
0654E:  CLRF   xFB
06550:  MOVFF  5D6,5FA
06554:  CLRF   xFD
06556:  MOVLW  B5
06558:  MOVWF  xFC
0655A:  MOVLB  0
0655C:  CALL   0816
06560:  MOVFF  02,5E9
06564:  MOVFF  01,5E8
06568:  MOVLW  06
0656A:  MOVLB  5
0656C:  ADDWF  xE8,F
0656E:  MOVLW  00
06570:  ADDWFC xE9,F
06572:  MOVLW  4B
06574:  ADDWF  xE8,W
06576:  MOVWF  01
06578:  MOVLW  00
0657A:  ADDWFC xE9,W
0657C:  MOVWF  03
0657E:  MOVF   01,W
06580:  ADDLW  53
06582:  MOVWF  01
06584:  MOVLW  01
06586:  ADDWFC 03,F
06588:  MOVFF  01,5E8
0658C:  MOVFF  03,5E9
06590:  MOVFF  03,5FF
06594:  MOVFF  01,5FE
06598:  MOVLB  0
0659A:  CALL   413C
0659E:  MOVFF  02,03
065A2:  MOVF   01,W
065A4:  SUBLW  01
065A6:  BNZ   65AC
065A8:  MOVF   03,F
065AA:  BZ    65B4
065AC:  MOVLW  02
065AE:  MOVWF  01
065B0:  BRA    6852
065B2:  BRA    65F4
....................    else arg2 = SERcmd[rec].p[3][0];
065B4:  MOVLB  5
065B6:  CLRF   xFB
065B8:  MOVFF  5D6,5FA
065BC:  CLRF   xFD
065BE:  MOVLW  B5
065C0:  MOVWF  xFC
065C2:  MOVLB  0
065C4:  CALL   0816
065C8:  MOVFF  02,5E9
065CC:  MOVFF  01,5E8
065D0:  MOVLW  06
065D2:  MOVLB  5
065D4:  ADDWF  xE8,F
065D6:  MOVLW  00
065D8:  ADDWFC xE9,F
065DA:  MOVLW  4B
065DC:  ADDWF  xE8,F
065DE:  MOVLW  00
065E0:  ADDWFC xE9,F
065E2:  MOVLW  53
065E4:  ADDWF  xE8,W
065E6:  MOVWF  FE9
065E8:  MOVLW  01
065EA:  ADDWFC xE9,W
065EC:  MOVWF  FEA
065EE:  MOVFF  FEF,5E3
065F2:  MOVLB  0
....................    
....................    if (!arg_is_float(strtod(SERcmd[rec].p[4], '\0'))) return INV_PARAM;
065F4:  MOVLB  5
065F6:  CLRF   xFB
065F8:  MOVFF  5D6,5FA
065FC:  CLRF   xFD
065FE:  MOVLW  B5
06600:  MOVWF  xFC
06602:  MOVLB  0
06604:  CALL   0816
06608:  MOVFF  02,5E9
0660C:  MOVFF  01,5E8
06610:  MOVLW  06
06612:  MOVLB  5
06614:  ADDWF  xE8,F
06616:  MOVLW  00
06618:  ADDWFC xE9,F
0661A:  MOVLW  64
0661C:  ADDWF  xE8,W
0661E:  MOVWF  01
06620:  MOVLW  00
06622:  ADDWFC xE9,W
06624:  MOVWF  03
06626:  MOVF   01,W
06628:  ADDLW  53
0662A:  MOVWF  01
0662C:  MOVLW  01
0662E:  ADDWFC 03,F
06630:  MOVFF  01,5E8
06634:  MOVFF  03,5E9
06638:  MOVFF  03,5EC
0663C:  MOVFF  01,5EB
06640:  CLRF   xEE
06642:  CLRF   xED
06644:  MOVLB  0
06646:  CALL   535A
0664A:  MOVFF  03,62F
0664E:  MOVFF  02,62E
06652:  MOVFF  01,62D
06656:  MOVFF  00,62C
0665A:  CALL   1D1A
0665E:  MOVFF  02,5E9
06662:  MOVFF  01,5E8
06666:  MOVFF  02,5EC
0666A:  MOVFF  01,5EB
0666E:  CALL   55BA
06672:  MOVF   01,F
06674:  BNZ   667E
06676:  MOVLW  02
06678:  MOVWF  01
0667A:  BRA    6852
0667C:  BRA    66E4
....................    else arg3 = strtod(SERcmd[rec].p[4], '\0');
0667E:  MOVLB  5
06680:  CLRF   xFB
06682:  MOVFF  5D6,5FA
06686:  CLRF   xFD
06688:  MOVLW  B5
0668A:  MOVWF  xFC
0668C:  MOVLB  0
0668E:  CALL   0816
06692:  MOVFF  02,5E9
06696:  MOVFF  01,5E8
0669A:  MOVLW  06
0669C:  MOVLB  5
0669E:  ADDWF  xE8,F
066A0:  MOVLW  00
066A2:  ADDWFC xE9,F
066A4:  MOVLW  64
066A6:  ADDWF  xE8,W
066A8:  MOVWF  01
066AA:  MOVLW  00
066AC:  ADDWFC xE9,W
066AE:  MOVWF  03
066B0:  MOVF   01,W
066B2:  ADDLW  53
066B4:  MOVWF  01
066B6:  MOVLW  01
066B8:  ADDWFC 03,F
066BA:  MOVFF  01,5E8
066BE:  MOVFF  03,5E9
066C2:  MOVFF  03,5EC
066C6:  MOVFF  01,5EB
066CA:  CLRF   xEE
066CC:  CLRF   xED
066CE:  MOVLB  0
066D0:  CALL   535A
066D4:  MOVFF  03,5E7
066D8:  MOVFF  02,5E6
066DC:  MOVFF  01,5E5
066E0:  MOVFF  00,5E4
....................    
....................    /*** SET SENSOR CAL PARAM **********/
....................    if      ('0' == arg2) sensorCal[arg1-1].c0 = arg3;
066E4:  MOVLB  5
066E6:  MOVF   xE3,W
066E8:  SUBLW  30
066EA:  BNZ   6716
066EC:  MOVLW  01
066EE:  SUBWF  xE2,W
066F0:  MULLW  18
066F2:  MOVF   FF3,W
066F4:  CLRF   xE9
066F6:  MOVWF  xE8
066F8:  MOVLW  82
066FA:  ADDWF  xE8,W
066FC:  MOVWF  FE9
066FE:  MOVLW  00
06700:  ADDWFC xE9,W
06702:  MOVWF  FEA
06704:  MOVFF  5E4,FEF
06708:  MOVFF  5E5,FEC
0670C:  MOVFF  5E6,FEC
06710:  MOVFF  5E7,FEC
06714:  BRA    684C
....................    else if ('1' == arg2) sensorCal[arg1-1].c1 = arg3;
06716:  MOVF   xE3,W
06718:  SUBLW  31
0671A:  BNZ   6752
0671C:  MOVLW  01
0671E:  SUBWF  xE2,W
06720:  MULLW  18
06722:  MOVF   FF3,W
06724:  CLRF   xE9
06726:  MOVWF  xE8
06728:  MOVLW  04
0672A:  ADDWF  xE8,W
0672C:  MOVWF  01
0672E:  MOVLW  00
06730:  ADDWFC xE9,W
06732:  MOVWF  03
06734:  MOVF   01,W
06736:  ADDLW  82
06738:  MOVWF  FE9
0673A:  MOVLW  00
0673C:  ADDWFC 03,W
0673E:  MOVWF  FEA
06740:  MOVFF  5E4,FEF
06744:  MOVFF  5E5,FEC
06748:  MOVFF  5E6,FEC
0674C:  MOVFF  5E7,FEC
06750:  BRA    684C
....................    else if ('2' == arg2) sensorCal[arg1-1].c2 = arg3;
06752:  MOVF   xE3,W
06754:  SUBLW  32
06756:  BNZ   678E
06758:  MOVLW  01
0675A:  SUBWF  xE2,W
0675C:  MULLW  18
0675E:  MOVF   FF3,W
06760:  CLRF   xE9
06762:  MOVWF  xE8
06764:  MOVLW  08
06766:  ADDWF  xE8,W
06768:  MOVWF  01
0676A:  MOVLW  00
0676C:  ADDWFC xE9,W
0676E:  MOVWF  03
06770:  MOVF   01,W
06772:  ADDLW  82
06774:  MOVWF  FE9
06776:  MOVLW  00
06778:  ADDWFC 03,W
0677A:  MOVWF  FEA
0677C:  MOVFF  5E4,FEF
06780:  MOVFF  5E5,FEC
06784:  MOVFF  5E6,FEC
06788:  MOVFF  5E7,FEC
0678C:  BRA    684C
....................    else if ('3' == arg2) sensorCal[arg1-1].c3 = arg3;
0678E:  MOVF   xE3,W
06790:  SUBLW  33
06792:  BNZ   67CA
06794:  MOVLW  01
06796:  SUBWF  xE2,W
06798:  MULLW  18
0679A:  MOVF   FF3,W
0679C:  CLRF   xE9
0679E:  MOVWF  xE8
067A0:  MOVLW  0C
067A2:  ADDWF  xE8,W
067A4:  MOVWF  01
067A6:  MOVLW  00
067A8:  ADDWFC xE9,W
067AA:  MOVWF  03
067AC:  MOVF   01,W
067AE:  ADDLW  82
067B0:  MOVWF  FE9
067B2:  MOVLW  00
067B4:  ADDWFC 03,W
067B6:  MOVWF  FEA
067B8:  MOVFF  5E4,FEF
067BC:  MOVFF  5E5,FEC
067C0:  MOVFF  5E6,FEC
067C4:  MOVFF  5E7,FEC
067C8:  BRA    684C
....................    else if ('4' == arg2) sensorCal[arg1-1].c4 = arg3;
067CA:  MOVF   xE3,W
067CC:  SUBLW  34
067CE:  BNZ   6806
067D0:  MOVLW  01
067D2:  SUBWF  xE2,W
067D4:  MULLW  18
067D6:  MOVF   FF3,W
067D8:  CLRF   xE9
067DA:  MOVWF  xE8
067DC:  MOVLW  10
067DE:  ADDWF  xE8,W
067E0:  MOVWF  01
067E2:  MOVLW  00
067E4:  ADDWFC xE9,W
067E6:  MOVWF  03
067E8:  MOVF   01,W
067EA:  ADDLW  82
067EC:  MOVWF  FE9
067EE:  MOVLW  00
067F0:  ADDWFC 03,W
067F2:  MOVWF  FEA
067F4:  MOVFF  5E4,FEF
067F8:  MOVFF  5E5,FEC
067FC:  MOVFF  5E6,FEC
06800:  MOVFF  5E7,FEC
06804:  BRA    684C
....................    else if ('5' == arg2) sensorCal[arg1-1].c5 = arg3;
06806:  MOVF   xE3,W
06808:  SUBLW  35
0680A:  BNZ   6842
0680C:  MOVLW  01
0680E:  SUBWF  xE2,W
06810:  MULLW  18
06812:  MOVF   FF3,W
06814:  CLRF   xE9
06816:  MOVWF  xE8
06818:  MOVLW  14
0681A:  ADDWF  xE8,W
0681C:  MOVWF  01
0681E:  MOVLW  00
06820:  ADDWFC xE9,W
06822:  MOVWF  03
06824:  MOVF   01,W
06826:  ADDLW  82
06828:  MOVWF  FE9
0682A:  MOVLW  00
0682C:  ADDWFC 03,W
0682E:  MOVWF  FEA
06830:  MOVFF  5E4,FEF
06834:  MOVFF  5E5,FEC
06838:  MOVFF  5E6,FEC
0683C:  MOVFF  5E7,FEC
06840:  BRA    684C
....................    else return INV_PARAM;
06842:  MOVLW  02
06844:  MOVWF  01
06846:  MOVLB  0
06848:  BRA    6852
0684A:  MOVLB  5
....................    
....................    return SUCCESS;
0684C:  MOVLW  00
0684E:  MOVWF  01
06850:  MOVLB  0
06852:  RETURN 0
.................... }
.................... 
.................... int8 getMonitorCalParam(unsigned int8 rec){
....................    
....................    return SUCCESS;
06854:  MOVLW  00
06856:  MOVWF  01
06858:  RETURN 0
.................... }
.................... 
.................... int8 setMonitorCalParam(unsigned int8 rec){
.................... 
....................    return SUCCESS;
0685A:  MOVLW  00
0685C:  MOVWF  01
0685E:  RETURN 0
.................... }
.................... 
.................... int8 getMonitorValue(unsigned int8 rec){
....................    
....................    return SUCCESS;
06860:  MOVLW  00
06862:  MOVWF  01
06864:  RETURN 0
.................... }
.................... 
.................... int8 getPIDdata(unsigned int8 rec){
....................    
....................    return SUCCESS;
06866:  MOVLW  00
06868:  MOVWF  01
0686A:  RETURN 0
.................... }
.................... 
.................... int8 getIPdata(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char *arg2;
....................    char *s_raw = "raw";
*
0696C:  MOVLW  72
0696E:  MOVLB  5
06970:  MOVWF  xE7
06972:  MOVLW  61
06974:  MOVWF  xE8
06976:  MOVLW  77
06978:  MOVWF  xE9
0697A:  CLRF   xEA
0697C:  MOVLW  05
0697E:  MOVWF  xE6
06980:  MOVLW  E7
06982:  MOVWF  xE5
....................    char *s_calibrated = "calib";
06984:  MOVLW  63
06986:  MOVWF  xED
06988:  MOVLW  61
0698A:  MOVWF  xEE
0698C:  MOVLW  6C
0698E:  MOVWF  xEF
06990:  MOVLW  69
06992:  MOVWF  xF0
06994:  MOVLW  62
06996:  MOVWF  xF1
06998:  CLRF   xF2
0699A:  MOVLW  05
0699C:  MOVWF  xEC
0699E:  MOVLW  ED
069A0:  MOVWF  xEB
....................    char *s_position = "pos";
069A2:  MOVLW  70
069A4:  MOVWF  xF5
069A6:  MOVLW  6F
069A8:  MOVWF  xF6
069AA:  MOVLW  73
069AC:  MOVWF  xF7
069AE:  CLRF   xF8
069B0:  MOVLW  05
069B2:  MOVWF  xF4
069B4:  MOVLW  F5
069B6:  MOVWF  xF3
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
069B8:  CLRF   xFB
069BA:  MOVFF  5D6,5FA
069BE:  CLRF   xFD
069C0:  MOVLW  B5
069C2:  MOVWF  xFC
069C4:  MOVLB  0
069C6:  CALL   0816
069CA:  MOVFF  02,5FA
069CE:  MOVFF  01,5F9
069D2:  MOVLW  06
069D4:  MOVLB  5
069D6:  ADDWF  xF9,F
069D8:  MOVLW  00
069DA:  ADDWFC xFA,F
069DC:  MOVLW  32
069DE:  ADDWF  xF9,W
069E0:  MOVWF  01
069E2:  MOVLW  00
069E4:  ADDWFC xFA,W
069E6:  MOVWF  03
069E8:  MOVF   01,W
069EA:  ADDLW  53
069EC:  MOVWF  01
069EE:  MOVLW  01
069F0:  ADDWFC 03,F
069F2:  MOVFF  01,5F9
069F6:  MOVFF  03,5FA
069FA:  MOVFF  03,5FD
069FE:  MOVFF  01,5FC
06A02:  MOVLB  0
06A04:  CALL   42BC
06A08:  MOVF   01,F
06A0A:  BNZ   6A14
06A0C:  MOVLW  02
06A0E:  MOVWF  01
06A10:  BRA    6CF2
06A12:  BRA    6A74
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06A14:  MOVLB  5
06A16:  CLRF   xFB
06A18:  MOVFF  5D6,5FA
06A1C:  CLRF   xFD
06A1E:  MOVLW  B5
06A20:  MOVWF  xFC
06A22:  MOVLB  0
06A24:  CALL   0816
06A28:  MOVFF  02,5FA
06A2C:  MOVFF  01,5F9
06A30:  MOVLW  06
06A32:  MOVLB  5
06A34:  ADDWF  xF9,F
06A36:  MOVLW  00
06A38:  ADDWFC xFA,F
06A3A:  MOVLW  32
06A3C:  ADDWF  xF9,W
06A3E:  MOVWF  01
06A40:  MOVLW  00
06A42:  ADDWFC xFA,W
06A44:  MOVWF  03
06A46:  MOVF   01,W
06A48:  ADDLW  53
06A4A:  MOVWF  01
06A4C:  MOVLW  01
06A4E:  ADDWFC 03,F
06A50:  MOVFF  01,5F9
06A54:  MOVFF  03,5FA
06A58:  MOVFF  03,5FD
06A5C:  MOVFF  01,5FC
06A60:  CLRF   xFF
06A62:  CLRF   xFE
06A64:  MOVLW  0A
06A66:  MOVLB  6
06A68:  MOVWF  x00
06A6A:  MOVLB  0
06A6C:  CALL   43AC
06A70:  MOVFF  01,5E2
....................    
....................    /*** GET INPUT DATA ****************/
....................    if      (0 == strcmp(s_raw, arg2)) {
06A74:  MOVFF  5E6,5FB
06A78:  MOVFF  5E5,5FA
06A7C:  MOVFF  5E4,5FD
06A80:  MOVFF  5E3,5FC
06A84:  CALL   417C
06A88:  MOVF   01,F
06A8A:  BNZ   6B62
....................       sprintf(retData+strlen(retData), "%Ld,", adcVals[arg1-1].sinRaw);
06A8C:  MOVLW  04
06A8E:  MOVLB  5
06A90:  MOVWF  xFF
06A92:  MOVLW  29
06A94:  MOVWF  xFE
06A96:  MOVLB  0
06A98:  CALL   413C
06A9C:  MOVFF  02,03
06AA0:  MOVF   01,W
06AA2:  ADDLW  29
06AA4:  MOVLB  5
06AA6:  MOVWF  xF9
06AA8:  MOVLW  04
06AAA:  ADDWFC 02,W
06AAC:  MOVWF  xFA
06AAE:  MOVLW  01
06AB0:  SUBWF  xE2,W
06AB2:  MULLW  19
06AB4:  MOVF   FF3,W
06AB6:  CLRF   xFC
06AB8:  MOVWF  xFB
06ABA:  MOVLW  0F
06ABC:  ADDWF  xFB,W
06ABE:  MOVWF  FE9
06AC0:  MOVLW  01
06AC2:  ADDWFC xFC,W
06AC4:  MOVWF  FEA
06AC6:  MOVFF  FEF,602
06ACA:  MOVFF  FEC,603
06ACE:  MOVFF  FEC,5FF
06AD2:  MOVFF  FEC,600
06AD6:  MOVFF  5FA,4CE
06ADA:  MOVFF  5F9,4CD
06ADE:  MOVLW  10
06AE0:  MOVWF  FE9
06AE2:  MOVLB  0
06AE4:  RCALL  686C
06AE6:  MOVLW  2C
06AE8:  MOVLB  6
06AEA:  MOVWF  x0D
06AEC:  MOVLB  0
06AEE:  CALL   41F4
....................       sprintf(retData+strlen(retData), "%Ld,", adcVals[arg1-1].cosRaw);
06AF2:  MOVLW  04
06AF4:  MOVLB  5
06AF6:  MOVWF  xFF
06AF8:  MOVLW  29
06AFA:  MOVWF  xFE
06AFC:  MOVLB  0
06AFE:  CALL   413C
06B02:  MOVF   01,W
06B04:  ADDLW  29
06B06:  MOVLB  5
06B08:  MOVWF  xF9
06B0A:  MOVLW  04
06B0C:  ADDWFC 02,W
06B0E:  MOVWF  xFA
06B10:  MOVLW  01
06B12:  SUBWF  xE2,W
06B14:  MULLW  19
06B16:  MOVF   FF3,W
06B18:  CLRF   xFC
06B1A:  MOVWF  xFB
06B1C:  MOVLW  04
06B1E:  ADDWF  xFB,W
06B20:  MOVWF  01
06B22:  MOVLW  00
06B24:  ADDWFC xFC,W
06B26:  MOVWF  03
06B28:  MOVF   01,W
06B2A:  ADDLW  0F
06B2C:  MOVWF  FE9
06B2E:  MOVLW  01
06B30:  ADDWFC 03,W
06B32:  MOVWF  FEA
06B34:  MOVFF  FEF,602
06B38:  MOVFF  FEC,603
06B3C:  MOVFF  FEC,5FD
06B40:  MOVFF  FEC,5FE
06B44:  MOVFF  5FA,4CE
06B48:  MOVFF  5F9,4CD
06B4C:  MOVLW  10
06B4E:  MOVWF  FE9
06B50:  MOVLB  0
06B52:  RCALL  686C
06B54:  MOVLW  2C
06B56:  MOVLB  6
06B58:  MOVWF  x0D
06B5A:  MOVLB  0
06B5C:  CALL   41F4
....................    }
06B60:  BRA    6CEE
....................    else if (0 == strcmp(s_calibrated, arg2)) {
06B62:  MOVFF  5EC,5FB
06B66:  MOVFF  5EB,5FA
06B6A:  MOVFF  5E4,5FD
06B6E:  MOVFF  5E3,5FC
06B72:  CALL   417C
06B76:  MOVF   01,F
06B78:  BNZ   6C58
....................       sprintf(retData+strlen(retData), "%Ld,", adcVals[arg1-1].sinCounts);
06B7A:  MOVLW  04
06B7C:  MOVLB  5
06B7E:  MOVWF  xFF
06B80:  MOVLW  29
06B82:  MOVWF  xFE
06B84:  MOVLB  0
06B86:  CALL   413C
06B8A:  MOVF   01,W
06B8C:  ADDLW  29
06B8E:  MOVLB  5
06B90:  MOVWF  xF9
06B92:  MOVLW  04
06B94:  ADDWFC 02,W
06B96:  MOVWF  xFA
06B98:  MOVLW  01
06B9A:  SUBWF  xE2,W
06B9C:  MULLW  19
06B9E:  MOVF   FF3,W
06BA0:  CLRF   xFC
06BA2:  MOVWF  xFB
06BA4:  MOVLW  08
06BA6:  ADDWF  xFB,W
06BA8:  MOVWF  01
06BAA:  MOVLW  00
06BAC:  ADDWFC xFC,W
06BAE:  MOVWF  03
06BB0:  MOVF   01,W
06BB2:  ADDLW  0F
06BB4:  MOVWF  FE9
06BB6:  MOVLW  01
06BB8:  ADDWFC 03,W
06BBA:  MOVWF  FEA
06BBC:  MOVFF  FEF,602
06BC0:  MOVFF  FEC,603
06BC4:  MOVFF  FEC,5FD
06BC8:  MOVFF  FEC,5FE
06BCC:  MOVFF  5FA,4CE
06BD0:  MOVFF  5F9,4CD
06BD4:  MOVLW  10
06BD6:  MOVWF  FE9
06BD8:  MOVLB  0
06BDA:  RCALL  686C
06BDC:  MOVLW  2C
06BDE:  MOVLB  6
06BE0:  MOVWF  x0D
06BE2:  MOVLB  0
06BE4:  CALL   41F4
....................       sprintf(retData+strlen(retData), "%Ld,", adcVals[arg1-1].cosCounts);
06BE8:  MOVLW  04
06BEA:  MOVLB  5
06BEC:  MOVWF  xFF
06BEE:  MOVLW  29
06BF0:  MOVWF  xFE
06BF2:  MOVLB  0
06BF4:  CALL   413C
06BF8:  MOVF   01,W
06BFA:  ADDLW  29
06BFC:  MOVLB  5
06BFE:  MOVWF  xF9
06C00:  MOVLW  04
06C02:  ADDWFC 02,W
06C04:  MOVWF  xFA
06C06:  MOVLW  01
06C08:  SUBWF  xE2,W
06C0A:  MULLW  19
06C0C:  MOVF   FF3,W
06C0E:  CLRF   xFC
06C10:  MOVWF  xFB
06C12:  MOVLW  0C
06C14:  ADDWF  xFB,W
06C16:  MOVWF  01
06C18:  MOVLW  00
06C1A:  ADDWFC xFC,W
06C1C:  MOVWF  03
06C1E:  MOVF   01,W
06C20:  ADDLW  0F
06C22:  MOVWF  FE9
06C24:  MOVLW  01
06C26:  ADDWFC 03,W
06C28:  MOVWF  FEA
06C2A:  MOVFF  FEF,602
06C2E:  MOVFF  FEC,603
06C32:  MOVFF  FEC,5FD
06C36:  MOVFF  FEC,5FE
06C3A:  MOVFF  5FA,4CE
06C3E:  MOVFF  5F9,4CD
06C42:  MOVLW  10
06C44:  MOVWF  FE9
06C46:  MOVLB  0
06C48:  RCALL  686C
06C4A:  MOVLW  2C
06C4C:  MOVLB  6
06C4E:  MOVWF  x0D
06C50:  MOVLB  0
06C52:  CALL   41F4
....................    }
06C56:  BRA    6CEE
....................    else if (0 == strcmp(s_position, arg2)) {
06C58:  MOVFF  5F4,5FB
06C5C:  MOVFF  5F3,5FA
06C60:  MOVFF  5E4,5FD
06C64:  MOVFF  5E3,5FC
06C68:  CALL   417C
06C6C:  MOVF   01,F
06C6E:  BNZ   6CE8
....................       sprintf(retData+strlen(retData), "%f,", adcVals[arg1-1].pReal);
06C70:  MOVLW  04
06C72:  MOVLB  5
06C74:  MOVWF  xFF
06C76:  MOVLW  29
06C78:  MOVWF  xFE
06C7A:  MOVLB  0
06C7C:  CALL   413C
06C80:  MOVF   01,W
06C82:  ADDLW  29
06C84:  MOVLB  5
06C86:  MOVWF  xF9
06C88:  MOVLW  04
06C8A:  ADDWFC 02,W
06C8C:  MOVWF  xFA
06C8E:  MOVLW  01
06C90:  SUBWF  xE2,W
06C92:  MULLW  19
06C94:  MOVF   FF3,W
06C96:  CLRF   xFC
06C98:  MOVWF  xFB
06C9A:  MOVLW  15
06C9C:  ADDWF  xFB,W
06C9E:  MOVWF  01
06CA0:  MOVLW  00
06CA2:  ADDWFC xFC,W
06CA4:  MOVWF  03
06CA6:  MOVF   01,W
06CA8:  ADDLW  0F
06CAA:  MOVWF  FE9
06CAC:  MOVLW  01
06CAE:  ADDWFC 03,W
06CB0:  MOVWF  FEA
06CB2:  MOVFF  FEF,600
06CB6:  MOVFF  FEC,601
06CBA:  MOVFF  FEC,602
06CBE:  MOVFF  FEC,603
06CC2:  MOVFF  5FA,4CE
06CC6:  MOVFF  5F9,4CD
06CCA:  MOVLW  89
06CCC:  MOVWF  FE9
06CCE:  MOVLW  02
06CD0:  MOVLB  6
06CD2:  MOVWF  x04
06CD4:  MOVLB  0
06CD6:  CALL   4ECA
06CDA:  MOVLW  2C
06CDC:  MOVLB  6
06CDE:  MOVWF  x0D
06CE0:  MOVLB  0
06CE2:  CALL   41F4
....................    }
06CE6:  BRA    6CEE
....................    else return INV_PARAM;
06CE8:  MOVLW  02
06CEA:  MOVWF  01
06CEC:  BRA    6CF2
....................    
....................    return SUCCESS;
06CEE:  MOVLW  00
06CF0:  MOVWF  01
06CF2:  RETURN 0
.................... }
.................... 
.................... int8 getManOPvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
06CF4:  MOVLB  5
06CF6:  CLRF   xFB
06CF8:  MOVFF  5D6,5FA
06CFC:  CLRF   xFD
06CFE:  MOVLW  B5
06D00:  MOVWF  xFC
06D02:  MOVLB  0
06D04:  CALL   0816
06D08:  MOVFF  02,5E4
06D0C:  MOVFF  01,5E3
06D10:  MOVLW  06
06D12:  MOVLB  5
06D14:  ADDWF  xE3,F
06D16:  MOVLW  00
06D18:  ADDWFC xE4,F
06D1A:  MOVLW  32
06D1C:  ADDWF  xE3,W
06D1E:  MOVWF  01
06D20:  MOVLW  00
06D22:  ADDWFC xE4,W
06D24:  MOVWF  03
06D26:  MOVF   01,W
06D28:  ADDLW  53
06D2A:  MOVWF  01
06D2C:  MOVLW  01
06D2E:  ADDWFC 03,F
06D30:  MOVFF  01,5E3
06D34:  MOVFF  03,5E4
06D38:  MOVFF  03,5FD
06D3C:  MOVFF  01,5FC
06D40:  MOVLB  0
06D42:  CALL   42BC
06D46:  MOVF   01,F
06D48:  BNZ   6D52
06D4A:  MOVLW  02
06D4C:  MOVWF  01
06D4E:  BRA    6E1C
06D50:  BRA    6DB2
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06D52:  MOVLB  5
06D54:  CLRF   xFB
06D56:  MOVFF  5D6,5FA
06D5A:  CLRF   xFD
06D5C:  MOVLW  B5
06D5E:  MOVWF  xFC
06D60:  MOVLB  0
06D62:  CALL   0816
06D66:  MOVFF  02,5E4
06D6A:  MOVFF  01,5E3
06D6E:  MOVLW  06
06D70:  MOVLB  5
06D72:  ADDWF  xE3,F
06D74:  MOVLW  00
06D76:  ADDWFC xE4,F
06D78:  MOVLW  32
06D7A:  ADDWF  xE3,W
06D7C:  MOVWF  01
06D7E:  MOVLW  00
06D80:  ADDWFC xE4,W
06D82:  MOVWF  03
06D84:  MOVF   01,W
06D86:  ADDLW  53
06D88:  MOVWF  01
06D8A:  MOVLW  01
06D8C:  ADDWFC 03,F
06D8E:  MOVFF  01,5E3
06D92:  MOVFF  03,5E4
06D96:  MOVFF  03,5FD
06D9A:  MOVFF  01,5FC
06D9E:  CLRF   xFF
06DA0:  CLRF   xFE
06DA2:  MOVLW  0A
06DA4:  MOVLB  6
06DA6:  MOVWF  x00
06DA8:  MOVLB  0
06DAA:  CALL   43AC
06DAE:  MOVFF  01,5E2
....................    
....................    /*** GET MANUAL OUTPUT VALUE ***************/ 
....................    sprintf(retData+strlen(retData), "%f,", manualOutputValues[arg1-1]);
06DB2:  MOVLW  04
06DB4:  MOVLB  5
06DB6:  MOVWF  xFF
06DB8:  MOVLW  29
06DBA:  MOVWF  xFE
06DBC:  MOVLB  0
06DBE:  CALL   413C
06DC2:  MOVF   01,W
06DC4:  ADDLW  29
06DC6:  MOVLB  5
06DC8:  MOVWF  xE3
06DCA:  MOVLW  04
06DCC:  ADDWFC 02,W
06DCE:  MOVWF  xE4
06DD0:  MOVLW  01
06DD2:  SUBWF  xE2,W
06DD4:  MULLW  04
06DD6:  MOVF   FF3,W
06DD8:  CLRF   03
06DDA:  ADDLW  EA
06DDC:  MOVWF  FE9
06DDE:  MOVLW  00
06DE0:  ADDWFC 03,W
06DE2:  MOVWF  FEA
06DE4:  MOVFF  FEF,600
06DE8:  MOVFF  FEC,601
06DEC:  MOVFF  FEC,602
06DF0:  MOVFF  FEC,603
06DF4:  MOVFF  5E4,4CE
06DF8:  MOVFF  5E3,4CD
06DFC:  MOVLW  89
06DFE:  MOVWF  FE9
06E00:  MOVLW  02
06E02:  MOVLB  6
06E04:  MOVWF  x04
06E06:  MOVLB  0
06E08:  CALL   4ECA
06E0C:  MOVLW  2C
06E0E:  MOVLB  6
06E10:  MOVWF  x0D
06E12:  MOVLB  0
06E14:  CALL   41F4
....................    
....................    return SUCCESS;
06E18:  MOVLW  00
06E1A:  MOVWF  01
06E1C:  RETURN 0
.................... }
.................... 
.................... int8 setManOPvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    float arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
06E1E:  MOVLB  5
06E20:  CLRF   xFB
06E22:  MOVFF  5D6,5FA
06E26:  CLRF   xFD
06E28:  MOVLW  B5
06E2A:  MOVWF  xFC
06E2C:  MOVLB  0
06E2E:  CALL   0816
06E32:  MOVFF  02,5E8
06E36:  MOVFF  01,5E7
06E3A:  MOVLW  06
06E3C:  MOVLB  5
06E3E:  ADDWF  xE7,F
06E40:  MOVLW  00
06E42:  ADDWFC xE8,F
06E44:  MOVLW  32
06E46:  ADDWF  xE7,W
06E48:  MOVWF  01
06E4A:  MOVLW  00
06E4C:  ADDWFC xE8,W
06E4E:  MOVWF  03
06E50:  MOVF   01,W
06E52:  ADDLW  53
06E54:  MOVWF  01
06E56:  MOVLW  01
06E58:  ADDWFC 03,F
06E5A:  MOVFF  01,5E7
06E5E:  MOVFF  03,5E8
06E62:  MOVFF  03,5FD
06E66:  MOVFF  01,5FC
06E6A:  MOVLB  0
06E6C:  CALL   42BC
06E70:  MOVF   01,F
06E72:  BNZ   6E7C
06E74:  MOVLW  02
06E76:  MOVWF  01
06E78:  BRA    6FCC
06E7A:  BRA    6EDC
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06E7C:  MOVLB  5
06E7E:  CLRF   xFB
06E80:  MOVFF  5D6,5FA
06E84:  CLRF   xFD
06E86:  MOVLW  B5
06E88:  MOVWF  xFC
06E8A:  MOVLB  0
06E8C:  CALL   0816
06E90:  MOVFF  02,5E8
06E94:  MOVFF  01,5E7
06E98:  MOVLW  06
06E9A:  MOVLB  5
06E9C:  ADDWF  xE7,F
06E9E:  MOVLW  00
06EA0:  ADDWFC xE8,F
06EA2:  MOVLW  32
06EA4:  ADDWF  xE7,W
06EA6:  MOVWF  01
06EA8:  MOVLW  00
06EAA:  ADDWFC xE8,W
06EAC:  MOVWF  03
06EAE:  MOVF   01,W
06EB0:  ADDLW  53
06EB2:  MOVWF  01
06EB4:  MOVLW  01
06EB6:  ADDWFC 03,F
06EB8:  MOVFF  01,5E7
06EBC:  MOVFF  03,5E8
06EC0:  MOVFF  03,5FD
06EC4:  MOVFF  01,5FC
06EC8:  CLRF   xFF
06ECA:  CLRF   xFE
06ECC:  MOVLW  0A
06ECE:  MOVLB  6
06ED0:  MOVWF  x00
06ED2:  MOVLB  0
06ED4:  CALL   43AC
06ED8:  MOVFF  01,5E2
....................    
....................    if (!arg_is_float(SERcmd[rec].p[3])) return INV_PARAM;
06EDC:  MOVLB  5
06EDE:  CLRF   xFB
06EE0:  MOVFF  5D6,5FA
06EE4:  CLRF   xFD
06EE6:  MOVLW  B5
06EE8:  MOVWF  xFC
06EEA:  MOVLB  0
06EEC:  CALL   0816
06EF0:  MOVFF  02,5E8
06EF4:  MOVFF  01,5E7
06EF8:  MOVLW  06
06EFA:  MOVLB  5
06EFC:  ADDWF  xE7,F
06EFE:  MOVLW  00
06F00:  ADDWFC xE8,F
06F02:  MOVLW  4B
06F04:  ADDWF  xE7,W
06F06:  MOVWF  01
06F08:  MOVLW  00
06F0A:  ADDWFC xE8,W
06F0C:  MOVWF  03
06F0E:  MOVF   01,W
06F10:  ADDLW  53
06F12:  MOVWF  01
06F14:  MOVLW  01
06F16:  ADDWFC 03,F
06F18:  MOVFF  01,5E7
06F1C:  MOVFF  03,5E8
06F20:  MOVFF  03,5EC
06F24:  MOVFF  01,5EB
06F28:  MOVLB  0
06F2A:  CALL   55BA
06F2E:  MOVF   01,F
06F30:  BNZ   6F3A
06F32:  MOVLW  02
06F34:  MOVWF  01
06F36:  BRA    6FCC
06F38:  BRA    6FA0
....................    else arg2 = strtod(SERcmd[rec].p[3], '\0');
06F3A:  MOVLB  5
06F3C:  CLRF   xFB
06F3E:  MOVFF  5D6,5FA
06F42:  CLRF   xFD
06F44:  MOVLW  B5
06F46:  MOVWF  xFC
06F48:  MOVLB  0
06F4A:  CALL   0816
06F4E:  MOVFF  02,5E8
06F52:  MOVFF  01,5E7
06F56:  MOVLW  06
06F58:  MOVLB  5
06F5A:  ADDWF  xE7,F
06F5C:  MOVLW  00
06F5E:  ADDWFC xE8,F
06F60:  MOVLW  4B
06F62:  ADDWF  xE7,W
06F64:  MOVWF  01
06F66:  MOVLW  00
06F68:  ADDWFC xE8,W
06F6A:  MOVWF  03
06F6C:  MOVF   01,W
06F6E:  ADDLW  53
06F70:  MOVWF  01
06F72:  MOVLW  01
06F74:  ADDWFC 03,F
06F76:  MOVFF  01,5E7
06F7A:  MOVFF  03,5E8
06F7E:  MOVFF  03,5EC
06F82:  MOVFF  01,5EB
06F86:  CLRF   xEE
06F88:  CLRF   xED
06F8A:  MOVLB  0
06F8C:  CALL   535A
06F90:  MOVFF  03,5E6
06F94:  MOVFF  02,5E5
06F98:  MOVFF  01,5E4
06F9C:  MOVFF  00,5E3
....................    
....................    /*** SET MANUAL OUTPUT VALUE ***************/
....................    manualOutputValues[arg1-1] = arg2;
06FA0:  MOVLW  01
06FA2:  MOVLB  5
06FA4:  SUBWF  xE2,W
06FA6:  MULLW  04
06FA8:  MOVF   FF3,W
06FAA:  CLRF   03
06FAC:  ADDLW  EA
06FAE:  MOVWF  FE9
06FB0:  MOVLW  00
06FB2:  ADDWFC 03,W
06FB4:  MOVWF  FEA
06FB6:  MOVFF  5E3,FEF
06FBA:  MOVFF  5E4,FEC
06FBE:  MOVFF  5E5,FEC
06FC2:  MOVFF  5E6,FEC
....................    
....................    return SUCCESS;
06FC6:  MOVLW  00
06FC8:  MOVWF  01
06FCA:  MOVLB  0
06FCC:  RETURN 0
.................... }
.................... 
.................... int8 invalidCmd(unsigned int8 rec){
....................    return INV_CMD;
06FCE:  MOVLW  01
06FD0:  MOVWF  01
06FD2:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* ARG VALIDATION HELPER FUNCS                                               */
.................... /*****************************************************************************/
.................... BOOLEAN arg_is_float(char *arg){
*
055BA:  MOVLB  5
055BC:  BCF    xED.0
....................    BOOLEAN decimal = FALSE;
....................    for (int i=0; i<strlen(arg); i++){
055BE:  CLRF   xEE
055C0:  MOVFF  5EC,5FF
055C4:  MOVFF  5EB,5FE
055C8:  MOVLB  0
055CA:  CALL   413C
055CE:  MOVFF  02,03
055D2:  MOVF   01,W
055D4:  MOVF   03,F
055D6:  BNZ   55E2
055D8:  MOVF   01,W
055DA:  MOVLB  5
055DC:  SUBWF  xEE,W
055DE:  BC    5674
055E0:  MOVLB  0
....................       if (!isdigit(arg[i])){
055E2:  MOVLB  5
055E4:  MOVF   xEE,W
055E6:  ADDWF  xEB,W
055E8:  MOVWF  FE9
055EA:  MOVLW  00
055EC:  ADDWFC xEC,W
055EE:  MOVWF  FEA
055F0:  MOVFF  FEF,5EF
055F4:  MOVF   xEF,W
055F6:  SUBLW  2F
055F8:  BC    5600
055FA:  MOVF   xEF,W
055FC:  SUBLW  39
055FE:  BC    566C
....................          // Check for negative sign
....................          if ('-' != arg[i]){
05600:  MOVF   xEE,W
05602:  ADDWF  xEB,W
05604:  MOVWF  FE9
05606:  MOVLW  00
05608:  ADDWFC xEC,W
0560A:  MOVWF  FEA
0560C:  MOVF   FEF,W
0560E:  SUBLW  2D
05610:  BZ    563C
....................             // Check for decimal
....................             if ('.' != arg[i]) return FALSE;
05612:  MOVF   xEE,W
05614:  ADDWF  xEB,W
05616:  MOVWF  FE9
05618:  MOVLW  00
0561A:  ADDWFC xEC,W
0561C:  MOVWF  FEA
0561E:  MOVF   FEF,W
05620:  SUBLW  2E
05622:  BZ    562C
05624:  MOVLW  00
05626:  MOVWF  01
05628:  BRA    5678
0562A:  BRA    563A
....................             else if  (decimal) return FALSE;
0562C:  BTFSS  xED.0
0562E:  BRA    5638
05630:  MOVLW  00
05632:  MOVWF  01
05634:  BRA    5678
05636:  BRA    563A
....................             else decimal = TRUE;
05638:  BSF    xED.0
....................          }
0563A:  BRA    566C
....................          else if (0 != i) return FALSE;
0563C:  MOVF   xEE,F
0563E:  BZ    5648
05640:  MOVLW  00
05642:  MOVWF  01
05644:  BRA    5678
05646:  BRA    566C
....................          else if (1 == strlen(arg)) return FALSE;
05648:  MOVFF  5EC,5FF
0564C:  MOVFF  5EB,5FE
05650:  MOVLB  0
05652:  CALL   413C
05656:  MOVFF  02,03
0565A:  MOVF   01,W
0565C:  SUBLW  01
0565E:  BNZ   566E
05660:  MOVF   03,F
05662:  BNZ   566E
05664:  MOVLW  00
05666:  MOVWF  01
05668:  MOVLB  5
0566A:  BRA    5678
0566C:  MOVLB  0
....................       }
0566E:  MOVLB  5
05670:  INCF   xEE,F
05672:  BRA    55C0
....................    }
....................    return TRUE;
05674:  MOVLW  01
05676:  MOVWF  01
05678:  MOVLB  0
0567A:  RETURN 0
.................... }
.................... 
.................... BOOLEAN is_valid_channel(char *arg){
....................     if (1 != strlen(arg)) return FALSE;
*
042BC:  MOVFF  5FD,5FF
042C0:  MOVFF  5FC,5FE
042C4:  RCALL  413C
042C6:  MOVFF  02,03
042CA:  MOVF   01,W
042CC:  SUBLW  01
042CE:  BNZ   42D4
042D0:  MOVF   03,F
042D2:  BZ    42DC
042D4:  MOVLW  00
042D6:  MOVWF  01
042D8:  BRA    430A
042DA:  BRA    4302
....................     else if ('1' != arg[0] && '2' != arg[0]) return FALSE;
042DC:  MOVLB  5
042DE:  MOVFF  5FC,FE9
042E2:  MOVFF  5FD,FEA
042E6:  MOVF   FEF,W
042E8:  SUBLW  31
042EA:  BZ    4304
042EC:  MOVFF  5FC,FE9
042F0:  MOVFF  5FD,FEA
042F4:  MOVF   FEF,W
042F6:  SUBLW  32
042F8:  BZ    4304
042FA:  MOVLW  00
042FC:  MOVWF  01
042FE:  MOVLB  0
04300:  BRA    430A
04302:  MOVLB  5
....................     return TRUE;
04304:  MOVLW  01
04306:  MOVWF  01
04308:  MOVLB  0
0430A:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* ASCII HEX CHARACTER TO INT                                                */
.................... /*****************************************************************************/
.................... int8 hex_to_int(char ascii){
....................    if (ascii >= '0' && ascii <= '9') return ascii-'0';
*
04102:  MOVLB  5
04104:  MOVF   xE1,W
04106:  SUBLW  2F
04108:  BC    411A
0410A:  MOVF   xE1,W
0410C:  SUBLW  39
0410E:  BNC   411A
04110:  MOVLW  30
04112:  SUBWF  xE1,W
04114:  MOVWF  01
04116:  BRA    4136
04118:  BRA    4136
....................    else if (ascii >= 'A' && ascii <= 'F') return ascii-'A'+10;
0411A:  MOVF   xE1,W
0411C:  SUBLW  40
0411E:  BC    4132
04120:  MOVF   xE1,W
04122:  SUBLW  46
04124:  BNC   4132
04126:  MOVLW  41
04128:  SUBWF  xE1,W
0412A:  ADDLW  0A
0412C:  MOVWF  01
0412E:  BRA    4136
04130:  BRA    4136
....................    else return 0xFF;
04132:  MOVLW  FF
04134:  MOVWF  01
04136:  MOVLB  0
04138:  GOTO   7078 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* COMMAND HANDLER/PARSER FUNCS                                              */
.................... /*****************************************************************************/
.................... void echo_cmd(unsigned int8 rec){
....................    fprintf(SERIAL, "%c", SERcmd[rec].t);
....................    while (SERcmd[rec].recReadIndex <= SERcmd[rec].recWriteIndex)
....................    {
....................       if (SERcmd[rec].recReadIndex != 0) fprintf(SERIAL, "%c", delimiter);
....................       fprintf(SERIAL, "%s", SERcmd[rec].p[SERcmd[rec].recReadIndex]);
....................       SERcmd[rec].recReadIndex++;
....................    }
....................    SERcmd[rec].recReadIndex=0;
.................... }
.................... 
.................... int8 command_parser(unsigned int8 rec){
*
06FD4:  MOVLB  5
06FD6:  CLRF   xFB
06FD8:  MOVFF  5D8,5FA
06FDC:  CLRF   xFD
06FDE:  MOVLW  B5
06FE0:  MOVWF  xFC
06FE2:  MOVLB  0
06FE4:  CALL   0816
06FE8:  MOVFF  02,5E1
06FEC:  MOVFF  01,5E0
06FF0:  MOVLW  06
06FF2:  MOVLB  5
06FF4:  ADDWF  xE0,F
06FF6:  MOVLW  00
06FF8:  ADDWFC xE1,F
06FFA:  MOVLW  53
06FFC:  ADDWF  xE0,W
06FFE:  MOVWF  01
07000:  MOVLW  01
07002:  ADDWFC xE1,W
07004:  MOVWF  03
07006:  MOVFF  01,5D9
0700A:  MOVWF  xDA
0700C:  CLRF   xFB
0700E:  MOVFF  5D8,5FA
07012:  CLRF   xFD
07014:  MOVLW  B5
07016:  MOVWF  xFC
07018:  MOVLB  0
0701A:  CALL   0816
0701E:  MOVFF  02,5E3
07022:  MOVFF  01,5E2
07026:  MOVLW  06
07028:  MOVLB  5
0702A:  ADDWF  xE2,F
0702C:  MOVLW  00
0702E:  ADDWFC xE3,F
07030:  MOVLW  19
07032:  ADDWF  xE2,W
07034:  MOVWF  01
07036:  MOVLW  00
07038:  ADDWFC xE3,W
0703A:  MOVWF  03
0703C:  MOVF   01,W
0703E:  ADDLW  53
07040:  MOVWF  01
07042:  MOVLW  01
07044:  ADDWFC 03,F
07046:  MOVFF  01,5DB
0704A:  MOVFF  03,5DC
0704E:  CLRF   xDD
07050:  CLRF   xDE
....................    char *cmd_adr = SERcmd[rec].p[0];
....................    char *cmd_str = SERcmd[rec].p[1];
.................... //!   int8 devID = input_a();
....................    int8 devID = 0;
....................    int8 i = 0;
....................    
....................    if (hwID == cmd_adr[0]){
07052:  MOVFF  5D9,FE9
07056:  MOVFF  5DA,FEA
0705A:  MOVF   FEF,W
0705C:  SUBLW  44
0705E:  BTFSS  FD8.2
07060:  BRA    7150
....................       if (hex_to_int(cmd_adr[1]) == (devID & 0x0F)){
07062:  MOVLW  01
07064:  ADDWF  xD9,W
07066:  MOVWF  FE9
07068:  MOVLW  00
0706A:  ADDWFC xDA,W
0706C:  MOVWF  FEA
0706E:  MOVFF  FEF,5E1
07072:  MOVLB  0
07074:  GOTO   4102
07078:  MOVFF  01,5E0
0707C:  MOVLB  5
0707E:  MOVF   xDD,W
07080:  ANDLW  0F
07082:  SUBWF  01,W
07084:  BNZ   7148
....................          while (0 != strlen(cmd_list[i].cmd_name)){
07086:  MOVF   xDE,W
07088:  MULLW  04
0708A:  MOVF   FF3,W
0708C:  CLRF   xE1
0708E:  MOVWF  xE0
07090:  MOVLW  D4
07092:  ADDWF  xE0,W
07094:  MOVWF  FE9
07096:  MOVLW  04
07098:  ADDWFC xE1,W
0709A:  MOVWF  FEA
0709C:  MOVFF  FEC,5FF
070A0:  MOVF   FED,F
070A2:  MOVFF  FEF,5FE
070A6:  MOVLB  0
070A8:  CALL   413C
070AC:  MOVFF  02,03
070B0:  MOVF   01,W
070B2:  BNZ   70B8
070B4:  MOVF   03,F
070B6:  BZ    713E
....................             if (0 == strcmp(cmd_str, cmd_list[i].cmd_name))
070B8:  MOVLB  5
070BA:  MOVF   xDE,W
070BC:  MULLW  04
070BE:  MOVF   FF3,W
070C0:  CLRF   xE1
070C2:  MOVWF  xE0
070C4:  MOVLW  D4
070C6:  ADDWF  xE0,W
070C8:  MOVWF  FE9
070CA:  MOVLW  04
070CC:  ADDWFC xE1,W
070CE:  MOVWF  FEA
070D0:  MOVFF  FEC,5FD
070D4:  MOVF   FED,F
070D6:  MOVFF  FEF,5FC
070DA:  MOVFF  5DC,5FB
070DE:  MOVFF  5DB,5FA
070E2:  MOVLB  0
070E4:  CALL   417C
070E8:  MOVF   01,F
070EA:  BNZ   7136
....................             {
....................                int8 return_code = cmd_list[i].cmd_func(rec);
070EC:  MOVLB  5
070EE:  MOVF   xDE,W
070F0:  MULLW  04
070F2:  MOVF   FF3,W
070F4:  CLRF   xE1
070F6:  MOVWF  xE0
070F8:  MOVLW  02
070FA:  ADDWF  xE0,W
070FC:  MOVWF  01
070FE:  MOVLW  00
07100:  ADDWFC xE1,W
07102:  MOVWF  03
07104:  MOVF   01,W
07106:  ADDLW  D4
07108:  MOVWF  01
0710A:  MOVLW  04
0710C:  ADDWFC 03,F
0710E:  MOVFF  01,5E0
07112:  MOVFF  03,5E1
07116:  MOVFF  03,FEA
0711A:  MOVFF  01,FE9
0711E:  MOVFF  5D8,5D6
07122:  MOVLB  0
07124:  CALL   00BC
07128:  MOVFF  01,5DF
....................                return return_code;
0712C:  MOVLB  5
0712E:  MOVFF  5DF,01
07132:  BRA    7154
07134:  MOVLB  0
....................             }
....................             i++;
07136:  MOVLB  5
07138:  INCF   xDE,F
0713A:  BRA    7086
0713C:  MOVLB  0
....................          }
....................          return INV_CMD; // INVALID_CMD
0713E:  MOVLW  01
07140:  MOVWF  01
07142:  MOVLB  5
07144:  BRA    7154
....................       } else return 254; // NOT THIS ADDRESS
07146:  BRA    714E
07148:  MOVLW  FE
0714A:  MOVWF  01
0714C:  BRA    7154
....................    } else return 255; // NOT THIS DEVICE TYPE
0714E:  BRA    7154
07150:  MOVLW  FF
07152:  MOVWF  01
07154:  MOVLB  0
07156:  GOTO   7190 (RETURN)
.................... }
.................... 
.................... void command_handler_task(){
....................    while (getNextSERReadIndex())
*
07182:  GOTO   40A8
07186:  MOVF   01,F
07188:  BZ    7262
....................    {
....................       int8 return_code = command_parser(SRI);
0718A:  MOVFF  427,5D8
0718E:  BRA    6FD4
07190:  MOVFF  01,5D7
....................       //echo_cmd(SRI);
....................       sprintf(retData + strlen(retData), "%s", resp_list[return_code].msg);
07194:  MOVLW  04
07196:  MOVLB  5
07198:  MOVWF  xFF
0719A:  MOVLW  29
0719C:  MOVWF  xFE
0719E:  MOVLB  0
071A0:  CALL   413C
071A4:  MOVF   01,W
071A6:  ADDLW  29
071A8:  MOVLB  5
071AA:  MOVWF  xD8
071AC:  MOVLW  04
071AE:  ADDWFC 02,W
071B0:  MOVWF  xD9
071B2:  MOVF   xD7,W
071B4:  MULLW  03
071B6:  MOVF   FF3,W
071B8:  CLRF   xDB
071BA:  MOVWF  xDA
071BC:  MOVLW  01
071BE:  ADDWF  xDA,W
071C0:  MOVWF  01
071C2:  MOVLW  00
071C4:  ADDWFC xDB,W
071C6:  MOVWF  03
071C8:  MOVF   01,W
071CA:  ADDLW  A3
071CC:  MOVWF  FE9
071CE:  MOVLW  05
071D0:  ADDWFC 03,W
071D2:  MOVWF  FEA
071D4:  MOVFF  FEC,5DB
071D8:  MOVF   FED,F
071DA:  MOVFF  FEF,5DA
071DE:  MOVFF  5D9,4CE
071E2:  MOVFF  5D8,4CD
071E6:  MOVFF  4CE,FEA
071EA:  MOVFF  4CD,FE9
071EE:  CLRF   FEF
071F0:  MOVFF  5DB,FEA
071F4:  MOVFF  5DA,FE9
071F8:  MOVLB  0
071FA:  BRA    715A
....................       fprintf(SERIAL, "%s,%s", SERcmd[SRI].p[0], retData);
071FC:  MOVLB  5
071FE:  CLRF   xFB
07200:  MOVFF  427,5FA
07204:  CLRF   xFD
07206:  MOVLW  B5
07208:  MOVWF  xFC
0720A:  MOVLB  0
0720C:  CALL   0816
07210:  MOVFF  02,5D9
07214:  MOVFF  01,5D8
07218:  MOVLW  06
0721A:  MOVLB  5
0721C:  ADDWF  xD8,F
0721E:  MOVLW  00
07220:  ADDWFC xD9,F
07222:  MOVLW  53
07224:  ADDWF  xD8,W
07226:  MOVWF  01
07228:  MOVLW  01
0722A:  ADDWFC xD9,W
0722C:  MOVWF  03
0722E:  MOVFF  01,5DA
07232:  MOVWF  xDB
07234:  MOVWF  FEA
07236:  MOVFF  01,FE9
0723A:  MOVLB  0
0723C:  CALL   3B8C
07240:  MOVLW  2C
07242:  MOVLB  5
07244:  MOVWF  xDE
07246:  MOVLB  0
07248:  CALL   3B64
0724C:  MOVLW  04
0724E:  MOVWF  FEA
07250:  MOVLW  29
07252:  MOVWF  FE9
07254:  CALL   3B8C
....................       
....................       resetSERcmd(SRI);
07258:  MOVFF  427,5D8
0725C:  CALL   0838
07260:  BRA    7182
....................    }
07262:  GOTO   75F4 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... void main()
07266:  CLRF   FF8
07268:  BCF    FF2.5
0726A:  BSF    07.7
0726C:  MOVLB  E
0726E:  MOVLW  55
07270:  MOVWF  x9B
07272:  MOVLW  AA
07274:  MOVWF  x9B
07276:  BCF    x9B.0
07278:  MOVLW  17
0727A:  MOVWF  xB0
0727C:  MOVLW  13
0727E:  MOVWF  xB2
07280:  MOVLW  09
07282:  MOVWF  x8A
07284:  MOVLW  0A
07286:  MOVWF  x8B
07288:  MOVLW  11
0728A:  MOVWF  xEB
0728C:  MOVLW  12
0728E:  MOVWF  xED
07290:  MOVLW  10
07292:  MOVWF  xF4
07294:  MOVLW  0F
07296:  MOVWF  xF5
07298:  MOVLW  09
0729A:  MOVWF  xF8
0729C:  MOVLW  55
0729E:  MOVWF  x9B
072A0:  MOVLW  AA
072A2:  MOVWF  x9B
072A4:  BSF    x9B.0
072A6:  CLRF   xD8
072A8:  CLRF   xD5
072AA:  CLRF   xD7
072AC:  MOVLW  08
072AE:  MOVWF  xD9
072B0:  MOVLW  60
072B2:  MOVWF  xD3
072B4:  MOVLW  AA
072B6:  MOVLB  0
072B8:  MOVWF  xF2
072BA:  MOVLB  1
072BC:  CLRF   x44
072BE:  CLRF   x43
072C0:  CLRF   x42
072C2:  CLRF   x41
072C4:  CLRF   x48
072C6:  CLRF   x47
072C8:  CLRF   x46
072CA:  CLRF   x45
072CC:  CLRF   x4C
072CE:  CLRF   x4B
072D0:  CLRF   x4A
072D2:  CLRF   x49
072D4:  CLRF   x4E
072D6:  CLRF   x4D
072D8:  MOVLB  E
072DA:  BCF    x91.5
072DC:  MOVLW  00
072DE:  MOVWF  x90
072E0:  MOVLW  0F
072E2:  MOVWF  x8E
072E4:  MOVLW  2A
072E6:  MOVWF  x91
072E8:  MOVLW  C4
072EA:  MOVWF  F88
072EC:  MOVWF  F88
072EE:  MOVWF  F88
072F0:  BCF    F95.5
072F2:  MOVLW  40
072F4:  MOVWF  F94
072F6:  MOVLW  9F
072F8:  MOVWF  F92
072FA:  MOVLW  2A
072FC:  MOVWF  F95
072FE:  MOVLW  93
07300:  MOVWF  F89
07302:  MOVWF  F89
07304:  MOVLB  4
07306:  CLRF   x27
07308:  CLRF   x28
0730A:  CLRF   xC9
0730C:  CLRF   xCA
0730E:  BCF    xCB.0
07310:  CLRF   xCC
07312:  BSF    F9E.3
07314:  MOVLW  7C
07316:  MOVWF  F9A
07318:  MOVLW  00
0731A:  MOVWF  F9B
0731C:  MOVLW  A6
0731E:  MOVWF  F9D
07320:  MOVLW  90
07322:  MOVWF  F9C
07324:  MOVLW  93
07326:  MOVWF  F89
07328:  BCF    F84.5
0732A:  CLRF   xCE
0732C:  CLRF   xCD
0732E:  CLRF   xD3
07330:  CLRF   xD2
07332:  CLRF   xD1
07334:  CLRF   xD0
07336:  MOVLB  F
07338:  CLRF   x0C
0733A:  CLRF   x14
0733C:  CLRF   x1C
0733E:  CLRF   x21
07340:  CLRF   x29
07342:  CLRF   x35
07344:  CLRF   x36
07346:  CLRF   x37
07348:  CLRF   x34
0734A:  CLRF   x31
0734C:  CLRF   x32
0734E:  CLRF   x33
07350:  CLRF   x30
07352:  MOVLW  42
07354:  MOVLB  4
07356:  MOVWF  xD7
07358:  MOVLW  34
0735A:  MOVWF  xD6
0735C:  MOVLW  42
0735E:  MOVWF  xDB
07360:  MOVLW  78
07362:  MOVWF  xDA
07364:  MOVLW  47
07366:  MOVWF  xDF
07368:  MOVLW  08
0736A:  MOVWF  xDE
0736C:  MOVLW  48
0736E:  MOVWF  xE3
07370:  MOVLW  BC
07372:  MOVWF  xE2
07374:  MOVLW  4A
07376:  MOVWF  xE7
07378:  MOVLW  6C
0737A:  MOVWF  xE6
0737C:  MOVLW  4B
0737E:  MOVWF  xEB
07380:  MOVLW  D6
07382:  MOVWF  xEA
07384:  MOVLW  50
07386:  MOVWF  xEF
07388:  MOVLW  78
0738A:  MOVWF  xEE
0738C:  MOVLW  56
0738E:  MOVWF  xF3
07390:  MOVLW  7C
07392:  MOVWF  xF2
07394:  MOVLW  59
07396:  MOVWF  xF7
07398:  MOVLW  88
0739A:  MOVWF  xF6
0739C:  MOVLW  5A
0739E:  MOVWF  xFB
073A0:  MOVLW  C2
073A2:  MOVWF  xFA
073A4:  MOVLW  5C
073A6:  MOVWF  xFF
073A8:  MOVLW  AC
073AA:  MOVWF  xFE
073AC:  MOVLW  60
073AE:  MOVLB  5
073B0:  MOVWF  x03
073B2:  MOVLW  2C
073B4:  MOVWF  x02
073B6:  MOVLW  64
073B8:  MOVWF  x07
073BA:  MOVLW  8E
073BC:  MOVWF  x06
073BE:  MOVLW  68
073C0:  MOVWF  x0B
073C2:  MOVLW  54
073C4:  MOVWF  x0A
073C6:  MOVLW  68
073C8:  MOVWF  x0F
073CA:  MOVLW  5A
073CC:  MOVWF  x0E
073CE:  MOVLW  68
073D0:  MOVWF  x13
073D2:  MOVLW  60
073D4:  MOVWF  x12
073D6:  MOVLW  68
073D8:  MOVWF  x17
073DA:  MOVLW  66
073DC:  MOVWF  x16
073DE:  MOVLW  69
073E0:  MOVWF  x1B
073E2:  MOVLW  6C
073E4:  MOVWF  x1A
073E6:  MOVLW  6C
073E8:  MOVWF  x1F
073EA:  MOVLW  F4
073EC:  MOVWF  x1E
073EE:  MOVLW  6E
073F0:  MOVWF  x23
073F2:  MOVLW  1E
073F4:  MOVWF  x22
073F6:  MOVLW  6F
073F8:  MOVWF  x27
073FA:  MOVLW  CE
073FC:  MOVWF  x26
073FE:  BRA    7586
07400:  DATA 02,00
07402:  DATA 1A,00
07404:  DATA 00,01
07406:  DATA 00,60
07408:  DATA 02,09
0740A:  DATA C0,00
0740C:  DATA 05,80
0740E:  DATA 7F,00
07410:  DATA 00,00
07412:  DATA 7F,0B
07414:  DATA C0,00
07416:  DATA 05,80
07418:  DATA 7F,00
0741A:  DATA 00,00
0741C:  DATA 7F,07
0741E:  DATA C0,00
07420:  DATA 01,80
07422:  DATA 7F,17
07424:  DATA C0,00
07426:  DATA 01,80
07428:  DATA 7F,17
0742A:  DATA C0,00
0742C:  DATA 01,80
0742E:  DATA 7F,07
07430:  DATA C0,00
07432:  DATA 01,80
07434:  DATA 7F,07
07436:  DATA C0,00
07438:  DATA 01,80
0743A:  DATA 7F,07
0743C:  DATA C0,00
0743E:  DATA 01,80
07440:  DATA 7F,07
07442:  DATA C0,00
07444:  DATA 01,80
07446:  DATA 7F,07
07448:  DATA C0,00
0744A:  DATA 01,80
0744C:  DATA 7F,07
0744E:  DATA C0,00
07450:  DATA 01,80
07452:  DATA 7F,0B
07454:  DATA C0,00
07456:  DATA 32,41
07458:  DATA 0F,00
0745A:  DATA 04,01
0745C:  DATA 4F,00
0745E:  DATA 00,00
07460:  DATA 00,3C
07462:  DATA 44,8D
07464:  DATA 00,01
07466:  DATA 04,CF
07468:  DATA 00,02
0746A:  DATA 04,D4
0746C:  DATA 28,05
0746E:  DATA 02,04
07470:  DATA D8,2B
07472:  DATA 05,02
07474:  DATA 04,DC
07476:  DATA 2E,05
07478:  DATA 02,04
0747A:  DATA E0,35
0747C:  DATA 05,02
0747E:  DATA 04,E4
07480:  DATA 3C,05
07482:  DATA 02,04
07484:  DATA E8,44
07486:  DATA 05,02
07488:  DATA 04,EC
0748A:  DATA 4C,05
0748C:  DATA 02,04
0748E:  DATA F0,51
07490:  DATA 05,02
07492:  DATA 04,F4
07494:  DATA 56,05
07496:  DATA 02,04
07498:  DATA F8,5A
0749A:  DATA 05,02
0749C:  DATA 04,FC
0749E:  DATA 5E,05
074A0:  DATA 02,05
074A2:  DATA 00,65
074A4:  DATA 05,02
074A6:  DATA 05,04
074A8:  DATA 6B,05
074AA:  DATA 02,05
074AC:  DATA 08,71
074AE:  DATA 05,02
074B0:  DATA 05,0C
074B2:  DATA 77,05
074B4:  DATA 02,05
074B6:  DATA 10,7D
074B8:  DATA 05,02
074BA:  DATA 05,14
074BC:  DATA 82,05
074BE:  DATA 02,05
074C0:  DATA 18,8B
074C2:  DATA 05,02
074C4:  DATA 05,1C
074C6:  DATA 93,05
074C8:  DATA 02,05
074CA:  DATA 20,9A
074CC:  DATA 05,02
074CE:  DATA 05,24
074D0:  DATA A1,05
074D2:  DATA 78,05
074D4:  DATA 28,67
074D6:  DATA 72,00
074D8:  DATA 67,73
074DA:  DATA 00,67
074DC:  DATA 43,68
074DE:  DATA 4D,61
074E0:  DATA 70,00
074E2:  DATA 73,43
074E4:  DATA 68,4D
074E6:  DATA 61,70
074E8:  DATA 00,67
074EA:  DATA 43,68
074EC:  DATA 4D,6F
074EE:  DATA 64,65
074F0:  DATA 00,73
074F2:  DATA 43,68
074F4:  DATA 4D,6F
074F6:  DATA 64,65
074F8:  DATA 00,67
074FA:  DATA 50,49
074FC:  DATA 44,00
074FE:  DATA 73,50
07500:  DATA 49,44
07502:  DATA 00,67
07504:  DATA 53,50
07506:  DATA 00,73
07508:  DATA 53,50
0750A:  DATA 00,67
0750C:  DATA 53,43
0750E:  DATA 61,6C
07510:  DATA 73,00
07512:  DATA 67,53
07514:  DATA 43,61
07516:  DATA 6C,00
07518:  DATA 73,53
0751A:  DATA 43,61
0751C:  DATA 6C,00
0751E:  DATA 67,4D
07520:  DATA 43,61
07522:  DATA 6C,00
07524:  DATA 73,4D
07526:  DATA 43,61
07528:  DATA 6C,00
0752A:  DATA 67,4D
0752C:  DATA 6F,6E
0752E:  DATA 00,67
07530:  DATA 50,49
07532:  DATA 44,64
07534:  DATA 61,74
07536:  DATA 61,00
07538:  DATA 67,49
0753A:  DATA 50,64
0753C:  DATA 61,74
0753E:  DATA 61,00
07540:  DATA 67,4D
07542:  DATA 61,6E
07544:  DATA 4F,50
07546:  DATA 00,73
07548:  DATA 4D,61
0754A:  DATA 6E,4F
0754C:  DATA 50,04
0754E:  DATA C0,00
07550:  DATA 32,80
07552:  DATA AC,05
07554:  DATA 01,B4
07556:  DATA 05,02
07558:  DATA C4,05
0755A:  DATA 53,55
0755C:  DATA 43,43
0755E:  DATA 45,53
07560:  DATA 53,00
07562:  DATA 49,4E
07564:  DATA 56,41
07566:  DATA 4C,49
07568:  DATA 44,20
0756A:  DATA 43,4F
0756C:  DATA 4D,4D
0756E:  DATA 41,4E
07570:  DATA 44,00
07572:  DATA 49,4E
07574:  DATA 56,41
07576:  DATA 4C,49
07578:  DATA 44,20
0757A:  DATA 50,41
0757C:  DATA 52,41
0757E:  DATA 4D,45
07580:  DATA 54,45
07582:  DATA 52,00
07584:  DATA 00,00
07586:  MOVLW  00
07588:  MOVWF  FF8
0758A:  MOVLW  74
0758C:  MOVWF  FF7
0758E:  MOVLW  00
07590:  MOVWF  FF6
07592:  TBLRD*+
07594:  MOVF   FF5,W
07596:  MOVWF  00
07598:  XORLW  00
0759A:  BZ    75C2
0759C:  TBLRD*+
0759E:  MOVF   FF5,W
075A0:  MOVWF  01
075A2:  BTFSC  FE8.7
075A4:  BRA    75B0
075A6:  ANDLW  3F
075A8:  MOVWF  FEA
075AA:  TBLRD*+
075AC:  MOVFF  FF5,FE9
075B0:  BTFSC  01.6
075B2:  TBLRD*+
075B4:  BTFSS  01.6
075B6:  TBLRD*+
075B8:  MOVFF  FF5,FEE
075BC:  DCFSNZ 00,F
075BE:  BRA    7592
075C0:  BRA    75B4
075C2:  CLRF   FF8
.................... {
....................    IO_init();                    // set up IO 
075C4:  MOVLB  0
075C6:  GOTO   0312
....................    params_init();                // load parameters
075CA:  GOTO   05BA
....................    monitor_init();               // initialize internal ADC for voltage and current telemetry
075CE:  GOTO   075A
....................    control_init();               // initialize the output control DACs
075D2:  GOTO   07F2
....................    serial_init();                // setup the serial port
075D6:  GOTO   09B2
....................    event_timer_init();
075DA:  GOTO   09D4
.................... //!   setup_wdt(WDT_512MS);
....................    enable_interrupts(GLOBAL);
075DE:  MOVLW  C0
075E0:  IORWF  FF2,F
.................... 
....................    while(TRUE)
....................    {
.................... //!      restart_wdt();
....................       internal_monitor_task();   //Update monitored voltage and currents etc
075E2:  GOTO   0DB2
....................       sensor_monitor_task();     //get magnetoresistive sensor data
075E6:  GOTO   370A
....................       control_task();            //output control
075EA:  GOTO   3AEC
....................       serial_task();             //serial port 
075EE:  GOTO   3BB0
....................       command_handler_task();    //execute commands
075F2:  BRA    7182
....................       
....................       delay_ms(500);
075F4:  MOVLW  02
075F6:  MOVLB  5
075F8:  MOVWF  xD7
075FA:  MOVLW  FA
075FC:  MOVWF  xDA
075FE:  MOVLB  0
07600:  CALL   03A8
07604:  MOVLB  5
07606:  DECFSZ xD7,F
07608:  BRA    75FA
0760A:  MOVLB  0
0760C:  BRA    75E2
....................    }
.................... }
0760E:  BRA    760E

Configuration Fuses:
   Word  1: FF8C   NOEXTOSC RSTOSC_HFINTRC_64MHZ NOCLKOUT CKS FCMEN
   Word  2: CF3F   MCLR NOPUT NOLPBOR NOBROWNOUT BORV19 ZCDDIS PPS1WAY NOSTVREN DEBUG NOXINST
   Word  3: FF9F   WDTSW NOWDT WDTWIN_SW WDTCLK_SW
   Word  4: DFFF   NOWRT NOWRTC NOWRTB NOWRTD SCANE NOLVP
   Word  5: FFFF   NOPROTECT NOCPD
   Word  6: FFFF   NOEBTR NOEBTRB

   Some fuses have been forced to be compatible with the ICD debugger.
