CCS PCH C Compiler, Version 5.109, 62303               12-Dec-25 13:49

               Filename:   C:\Users\aidan\Documents\GitHub\DiFCS-Controller\src\main.lst

               ROM used:   43776 bytes (67%)
                           Largest free fragment is 21758
               RAM used:   1798 (50%) at main() level
                           1911 (53%) worst case
               Stack used: 6 locations (4 in main + 2 for interrupts)
               Stack size: 31

*
00000:  NOP   
00002:  GOTO   A30A
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  MOVLB  E
00056:  BTFSS  xC0.5
00058:  GOTO   0062
0005C:  BTFSC  xC8.5
0005E:  GOTO   0120
00062:  BTFSS  xC1.0
00064:  GOTO   006E
00068:  BTFSC  xC9.0
0006A:  GOTO   0292
0006E:  MOVFF  0E,00
00072:  MOVFF  0F,01
00076:  MOVFF  10,02
0007A:  MOVFF  11,03
0007E:  MOVFF  0C,FE9
00082:  MOVFF  07,FEA
00086:  BSF    07.7
00088:  MOVFF  08,FE1
0008C:  MOVFF  09,FE2
00090:  MOVFF  0A,FD9
00094:  MOVFF  0B,FDA
00098:  MOVFF  12,FF3
0009C:  MOVFF  13,FF4
000A0:  MOVFF  14,FFA
000A4:  MOVFF  15,FF5
000A8:  MOVFF  16,FF6
000AC:  MOVFF  17,FF7
000B0:  MOVF   04,W
000B2:  MOVFF  06,FE0
000B6:  MOVFF  05,FD8
000BA:  RETFIE 0
.................... #include <main.h>
.................... #include <18F46Q10.h>
.................... //////////// Standard Header file for the PIC18F46Q10 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F46Q10
000BC:  MOVFF  FEC,FFA
000C0:  MOVF   FED,F
000C2:  MOVFF  FEF,FE8
000C6:  MOVWF  FF9
000C8:  RETURN 0
*
00366:  DATA 32,30
00368:  DATA 32,35
0036A:  DATA 31,32
0036C:  DATA 30,38
0036E:  DATA 00,00
00370:  DATA 30,30
00372:  DATA 30,30
00374:  DATA 00,00
00376:  DATA 25,64
00378:  DATA 2C,4D
0037A:  DATA 41,4E
0037C:  DATA 55,41
0037E:  DATA 4C,2C
00380:  DATA 00,00
00382:  DATA 25,64
00384:  DATA 2C,4D
00386:  DATA 41,47
00388:  DATA 53,4E
0038A:  DATA 53,2C
0038C:  DATA 00,00
0038E:  DATA 43,4E
00390:  DATA 54,2C
00392:  DATA 25,75
00394:  DATA 2C,25
00396:  DATA 2E,30
00398:  DATA 66,2C
0039A:  DATA 25,2E
0039C:  DATA 30,66
0039E:  DATA 3B,00
003A0:  DATA 50,4F
003A2:  DATA 53,2C
003A4:  DATA 25,75
003A6:  DATA 2C,25
003A8:  DATA 33,2E
003AA:  DATA 33,66
003AC:  DATA 3B,00
003AE:  DATA 4F,55
003B0:  DATA 54,2C
003B2:  DATA 25,75
003B4:  DATA 2C,2D
003B6:  DATA 2C,25
003B8:  DATA 4C,75
003BA:  DATA 3B,00
003BC:  DATA 4F,55
003BE:  DATA 54,2C
003C0:  DATA 25,75
003C2:  DATA 2C,2B
003C4:  DATA 2C,25
003C6:  DATA 4C,75
003C8:  DATA 3B,00
*
0070E:  ADDWF  FE8,W
00710:  CLRF   FF7
00712:  RLCF   FF7,F
00714:  ADDLW  29
00716:  MOVWF  FF6
00718:  MOVLW  07
0071A:  ADDWFC FF7,F
0071C:  TBLRD*-
0071E:  MOVF   FF5,W
00720:  MOVWF  FFA
00722:  TBLRD*
00724:  MOVF   FF5,W
00726:  MOVWF  FF9
00728:  DATA D8,06
0072A:  DATA E2,06
0072C:  DATA EC,06
0072E:  DATA F6,06
*
008B6:  MOVLB  7
008B8:  MOVF   x41,W
008BA:  MULWF  x43
008BC:  MOVFF  FF3,01
008C0:  MOVFF  FF4,00
008C4:  MULWF  x44
008C6:  MOVF   FF3,W
008C8:  ADDWF  00,F
008CA:  MOVF   x42,W
008CC:  MULWF  x43
008CE:  MOVF   FF3,W
008D0:  ADDWFC 00,W
008D2:  MOVWF  02
008D4:  MOVLB  0
008D6:  RETURN 0
008D8:  MOVLB  7
008DA:  MOVF   x3B,W
008DC:  CLRF   01
008DE:  SUBWF  x3A,W
008E0:  BC    08E8
008E2:  MOVFF  73A,00
008E6:  BRA    0900
008E8:  CLRF   00
008EA:  MOVLW  08
008EC:  MOVWF  x3C
008EE:  RLCF   x3A,F
008F0:  RLCF   00,F
008F2:  MOVF   x3B,W
008F4:  SUBWF  00,W
008F6:  BTFSC  FD8.0
008F8:  MOVWF  00
008FA:  RLCF   01,F
008FC:  DECFSZ x3C,F
008FE:  BRA    08EE
00900:  MOVLB  0
00902:  RETURN 0
*
00D6A:  MOVLW  8E
00D6C:  MOVWF  00
00D6E:  MOVFF  74B,01
00D72:  MOVFF  74A,02
00D76:  CLRF   03
00D78:  MOVF   01,F
00D7A:  BNZ   0D8E
00D7C:  MOVFF  02,01
00D80:  CLRF   02
00D82:  MOVLW  08
00D84:  SUBWF  00,F
00D86:  MOVF   01,F
00D88:  BNZ   0D8E
00D8A:  CLRF   00
00D8C:  BRA    0D9E
00D8E:  BCF    FD8.0
00D90:  BTFSC  01.7
00D92:  BRA    0D9C
00D94:  RLCF   02,F
00D96:  RLCF   01,F
00D98:  DECF   00,F
00D9A:  BRA    0D8E
00D9C:  BCF    01.7
00D9E:  RETURN 0
00DA0:  MOVLB  7
00DA2:  MOVF   x50,W
00DA4:  BTFSC  FD8.2
00DA6:  BRA    0E8A
00DA8:  MOVWF  00
00DAA:  MOVF   x54,W
00DAC:  BTFSC  FD8.2
00DAE:  BRA    0E8A
00DB0:  ADDWF  00,F
00DB2:  BNC   0DBC
00DB4:  MOVLW  81
00DB6:  ADDWF  00,F
00DB8:  BC    0E8A
00DBA:  BRA    0DC4
00DBC:  MOVLW  7F
00DBE:  SUBWF  00,F
00DC0:  BNC   0E8A
00DC2:  BZ    0E8A
00DC4:  MOVFF  751,758
00DC8:  MOVF   x55,W
00DCA:  XORWF  x58,F
00DCC:  BSF    x51.7
00DCE:  BSF    x55.7
00DD0:  MOVF   x53,W
00DD2:  MULWF  x57
00DD4:  MOVFF  FF4,75A
00DD8:  MOVF   x52,W
00DDA:  MULWF  x56
00DDC:  MOVFF  FF4,03
00DE0:  MOVFF  FF3,759
00DE4:  MULWF  x57
00DE6:  MOVF   FF3,W
00DE8:  ADDWF  x5A,F
00DEA:  MOVF   FF4,W
00DEC:  ADDWFC x59,F
00DEE:  MOVLW  00
00DF0:  ADDWFC 03,F
00DF2:  MOVF   x53,W
00DF4:  MULWF  x56
00DF6:  MOVF   FF3,W
00DF8:  ADDWF  x5A,F
00DFA:  MOVF   FF4,W
00DFC:  ADDWFC x59,F
00DFE:  MOVLW  00
00E00:  CLRF   02
00E02:  ADDWFC 03,F
00E04:  ADDWFC 02,F
00E06:  MOVF   x51,W
00E08:  MULWF  x57
00E0A:  MOVF   FF3,W
00E0C:  ADDWF  x59,F
00E0E:  MOVF   FF4,W
00E10:  ADDWFC 03,F
00E12:  MOVLW  00
00E14:  ADDWFC 02,F
00E16:  MOVF   x51,W
00E18:  MULWF  x56
00E1A:  MOVF   FF3,W
00E1C:  ADDWF  03,F
00E1E:  MOVF   FF4,W
00E20:  ADDWFC 02,F
00E22:  MOVLW  00
00E24:  CLRF   01
00E26:  ADDWFC 01,F
00E28:  MOVF   x53,W
00E2A:  MULWF  x55
00E2C:  MOVF   FF3,W
00E2E:  ADDWF  x59,F
00E30:  MOVF   FF4,W
00E32:  ADDWFC 03,F
00E34:  MOVLW  00
00E36:  ADDWFC 02,F
00E38:  ADDWFC 01,F
00E3A:  MOVF   x52,W
00E3C:  MULWF  x55
00E3E:  MOVF   FF3,W
00E40:  ADDWF  03,F
00E42:  MOVF   FF4,W
00E44:  ADDWFC 02,F
00E46:  MOVLW  00
00E48:  ADDWFC 01,F
00E4A:  MOVF   x51,W
00E4C:  MULWF  x55
00E4E:  MOVF   FF3,W
00E50:  ADDWF  02,F
00E52:  MOVF   FF4,W
00E54:  ADDWFC 01,F
00E56:  INCF   00,F
00E58:  BTFSC  01.7
00E5A:  BRA    0E66
00E5C:  RLCF   x59,F
00E5E:  RLCF   03,F
00E60:  RLCF   02,F
00E62:  RLCF   01,F
00E64:  DECF   00,F
00E66:  MOVLW  00
00E68:  BTFSS  x59.7
00E6A:  BRA    0E80
00E6C:  INCF   03,F
00E6E:  ADDWFC 02,F
00E70:  ADDWFC 01,F
00E72:  MOVF   01,W
00E74:  BNZ   0E80
00E76:  MOVF   02,W
00E78:  BNZ   0E80
00E7A:  MOVF   03,W
00E7C:  BNZ   0E80
00E7E:  INCF   00,F
00E80:  BTFSC  x58.7
00E82:  BSF    01.7
00E84:  BTFSS  x58.7
00E86:  BCF    01.7
00E88:  BRA    0E92
00E8A:  CLRF   00
00E8C:  CLRF   01
00E8E:  CLRF   02
00E90:  CLRF   03
00E92:  MOVLB  0
00E94:  RETURN 0
00E96:  MOVLW  80
00E98:  BTFSS  FD8.1
00E9A:  BRA    0EA0
00E9C:  MOVLB  7
00E9E:  XORWF  x4F,F
00EA0:  MOVLB  7
00EA2:  CLRF   x54
00EA4:  CLRF   x55
00EA6:  MOVFF  74B,753
00EAA:  MOVF   x4F,W
00EAC:  XORWF  x53,F
00EAE:  MOVF   x4A,W
00EB0:  BTFSC  FD8.2
00EB2:  BRA    1072
00EB4:  MOVWF  x52
00EB6:  MOVWF  00
00EB8:  MOVF   x4E,W
00EBA:  BTFSC  FD8.2
00EBC:  BRA    1084
00EBE:  SUBWF  x52,F
00EC0:  BTFSC  FD8.2
00EC2:  BRA    0FCA
00EC4:  BNC   0F42
00EC6:  MOVFF  74F,758
00ECA:  BSF    x58.7
00ECC:  MOVFF  750,757
00ED0:  MOVFF  751,756
00ED4:  CLRF   x55
00ED6:  BCF    FD8.0
00ED8:  RRCF   x58,F
00EDA:  RRCF   x57,F
00EDC:  RRCF   x56,F
00EDE:  RRCF   x55,F
00EE0:  DECFSZ x52,F
00EE2:  BRA    0ED4
00EE4:  BTFSS  x53.7
00EE6:  BRA    0EEE
00EE8:  BSF    x54.0
00EEA:  BRA    10AC
00EEC:  BCF    x54.0
00EEE:  BCF    x52.0
00EF0:  BSF    x54.4
00EF2:  MOVLW  07
00EF4:  MOVWF  FEA
00EF6:  MOVLW  4D
00EF8:  MOVWF  FE9
00EFA:  BRA    10D2
00EFC:  BCF    x54.4
00EFE:  BTFSC  x53.7
00F00:  BRA    0F16
00F02:  BTFSS  x52.0
00F04:  BRA    0F2C
00F06:  RRCF   x58,F
00F08:  RRCF   x57,F
00F0A:  RRCF   x56,F
00F0C:  RRCF   x55,F
00F0E:  INCF   00,F
00F10:  BTFSC  FD8.2
00F12:  BRA    10A2
00F14:  BRA    0F2C
00F16:  BTFSC  x58.7
00F18:  BRA    0F32
00F1A:  BCF    FD8.0
00F1C:  RLCF   x55,F
00F1E:  RLCF   x56,F
00F20:  RLCF   x57,F
00F22:  RLCF   x58,F
00F24:  DECF   00,F
00F26:  BTFSC  FD8.2
00F28:  BRA    10A2
00F2A:  BRA    0F16
00F2C:  BSF    x54.6
00F2E:  BRA    100A
00F30:  BCF    x54.6
00F32:  MOVFF  74B,753
00F36:  BTFSS  x4B.7
00F38:  BRA    0F3E
00F3A:  BSF    x58.7
00F3C:  BRA    1094
00F3E:  BCF    x58.7
00F40:  BRA    1094
00F42:  MOVFF  74E,752
00F46:  MOVFF  74E,00
00F4A:  MOVF   x4A,W
00F4C:  SUBWF  x52,F
00F4E:  MOVFF  74B,758
00F52:  BSF    x58.7
00F54:  MOVFF  74C,757
00F58:  MOVFF  74D,756
00F5C:  CLRF   x55
00F5E:  BCF    FD8.0
00F60:  RRCF   x58,F
00F62:  RRCF   x57,F
00F64:  RRCF   x56,F
00F66:  RRCF   x55,F
00F68:  DECFSZ x52,F
00F6A:  BRA    0F5C
00F6C:  BTFSS  x53.7
00F6E:  BRA    0F76
00F70:  BSF    x54.1
00F72:  BRA    10AC
00F74:  BCF    x54.1
00F76:  BCF    x52.0
00F78:  BSF    x54.5
00F7A:  MOVLW  07
00F7C:  MOVWF  FEA
00F7E:  MOVLW  51
00F80:  MOVWF  FE9
00F82:  BRA    10D2
00F84:  BCF    x54.5
00F86:  BTFSC  x53.7
00F88:  BRA    0F9E
00F8A:  BTFSS  x52.0
00F8C:  BRA    0FB4
00F8E:  RRCF   x58,F
00F90:  RRCF   x57,F
00F92:  RRCF   x56,F
00F94:  RRCF   x55,F
00F96:  INCF   00,F
00F98:  BTFSC  FD8.2
00F9A:  BRA    10A2
00F9C:  BRA    0FB4
00F9E:  BTFSC  x58.7
00FA0:  BRA    0FBA
00FA2:  BCF    FD8.0
00FA4:  RLCF   x55,F
00FA6:  RLCF   x56,F
00FA8:  RLCF   x57,F
00FAA:  RLCF   x58,F
00FAC:  DECF   00,F
00FAE:  BTFSC  FD8.2
00FB0:  BRA    10A2
00FB2:  BRA    0F9E
00FB4:  BSF    x54.7
00FB6:  BRA    100A
00FB8:  BCF    x54.7
00FBA:  MOVFF  74F,753
00FBE:  BTFSS  x4F.7
00FC0:  BRA    0FC6
00FC2:  BSF    x58.7
00FC4:  BRA    1094
00FC6:  BCF    x58.7
00FC8:  BRA    1094
00FCA:  MOVFF  74F,758
00FCE:  BSF    x58.7
00FD0:  MOVFF  750,757
00FD4:  MOVFF  751,756
00FD8:  BTFSS  x53.7
00FDA:  BRA    0FE4
00FDC:  BCF    x58.7
00FDE:  BSF    x54.2
00FE0:  BRA    10AC
00FE2:  BCF    x54.2
00FE4:  CLRF   x55
00FE6:  BCF    x52.0
00FE8:  MOVLW  07
00FEA:  MOVWF  FEA
00FEC:  MOVLW  4D
00FEE:  MOVWF  FE9
00FF0:  BRA    10D2
00FF2:  BTFSC  x53.7
00FF4:  BRA    102E
00FF6:  MOVFF  74B,753
00FFA:  BTFSS  x52.0
00FFC:  BRA    100A
00FFE:  RRCF   x58,F
01000:  RRCF   x57,F
01002:  RRCF   x56,F
01004:  RRCF   x55,F
01006:  INCF   00,F
01008:  BZ    10A2
0100A:  BTFSS  x55.7
0100C:  BRA    1024
0100E:  INCF   x56,F
01010:  BNZ   1024
01012:  INCF   x57,F
01014:  BNZ   1024
01016:  INCF   x58,F
01018:  BNZ   1024
0101A:  RRCF   x58,F
0101C:  RRCF   x57,F
0101E:  RRCF   x56,F
01020:  INCF   00,F
01022:  BZ    10A2
01024:  BTFSC  x54.6
01026:  BRA    0F30
01028:  BTFSC  x54.7
0102A:  BRA    0FB8
0102C:  BRA    1066
0102E:  MOVLW  80
01030:  XORWF  x58,F
01032:  BTFSS  x58.7
01034:  BRA    103E
01036:  BRA    10AC
01038:  MOVFF  74F,753
0103C:  BRA    1052
0103E:  MOVFF  74B,753
01042:  MOVF   x58,F
01044:  BNZ   1052
01046:  MOVF   x57,F
01048:  BNZ   1052
0104A:  MOVF   x56,F
0104C:  BNZ   1052
0104E:  CLRF   00
01050:  BRA    1094
01052:  BTFSC  x58.7
01054:  BRA    1066
01056:  BCF    FD8.0
01058:  RLCF   x55,F
0105A:  RLCF   x56,F
0105C:  RLCF   x57,F
0105E:  RLCF   x58,F
01060:  DECFSZ 00,F
01062:  BRA    1052
01064:  BRA    10A2
01066:  BTFSS  x53.7
01068:  BRA    106E
0106A:  BSF    x58.7
0106C:  BRA    1094
0106E:  BCF    x58.7
01070:  BRA    1094
01072:  MOVFF  74E,00
01076:  MOVFF  74F,758
0107A:  MOVFF  750,757
0107E:  MOVFF  751,756
01082:  BRA    1094
01084:  MOVFF  74A,00
01088:  MOVFF  74B,758
0108C:  MOVFF  74C,757
01090:  MOVFF  74D,756
01094:  MOVFF  758,01
01098:  MOVFF  757,02
0109C:  MOVFF  756,03
010A0:  BRA    110A
010A2:  CLRF   00
010A4:  CLRF   01
010A6:  CLRF   02
010A8:  CLRF   03
010AA:  BRA    110A
010AC:  CLRF   x55
010AE:  COMF   x56,F
010B0:  COMF   x57,F
010B2:  COMF   x58,F
010B4:  COMF   x55,F
010B6:  INCF   x55,F
010B8:  BNZ   10C4
010BA:  INCF   x56,F
010BC:  BNZ   10C4
010BE:  INCF   x57,F
010C0:  BNZ   10C4
010C2:  INCF   x58,F
010C4:  BTFSC  x54.0
010C6:  BRA    0EEC
010C8:  BTFSC  x54.1
010CA:  BRA    0F74
010CC:  BTFSC  x54.2
010CE:  BRA    0FE2
010D0:  BRA    1038
010D2:  MOVF   FEF,W
010D4:  ADDWF  x56,F
010D6:  BNC   10E2
010D8:  INCF   x57,F
010DA:  BNZ   10E2
010DC:  INCF   x58,F
010DE:  BTFSC  FD8.2
010E0:  BSF    x52.0
010E2:  MOVF   FED,F
010E4:  MOVF   FEF,W
010E6:  ADDWF  x57,F
010E8:  BNC   10F0
010EA:  INCF   x58,F
010EC:  BTFSC  FD8.2
010EE:  BSF    x52.0
010F0:  MOVF   FED,F
010F2:  MOVF   FEF,W
010F4:  BTFSC  FEF.7
010F6:  BRA    10FA
010F8:  XORLW  80
010FA:  ADDWF  x58,F
010FC:  BTFSC  FD8.0
010FE:  BSF    x52.0
01100:  BTFSC  x54.4
01102:  BRA    0EFC
01104:  BTFSC  x54.5
01106:  BRA    0F84
01108:  BRA    0FF2
0110A:  MOVLB  0
0110C:  RETURN 0
*
01664:  ADDWF  FE8,W
01666:  CLRF   FF7
01668:  RLCF   FF7,F
0166A:  ADDLW  7F
0166C:  MOVWF  FF6
0166E:  MOVLW  16
01670:  ADDWFC FF7,F
01672:  TBLRD*-
01674:  MOVF   FF5,W
01676:  MOVWF  FFA
01678:  TBLRD*
0167A:  MOVF   FF5,W
0167C:  MOVWF  FF9
0167E:  DATA 26,11
01680:  DATA E6,11
01682:  DATA A6,12
01684:  DATA 66,13
01686:  DATA 26,14
01688:  DATA E6,14
0168A:  DATA A6,15
0168C:  BTFSC  FD8.1
0168E:  BRA    1698
01690:  MOVLW  07
01692:  MOVWF  FEA
01694:  MOVLW  39
01696:  MOVWF  FE9
01698:  MOVLB  7
0169A:  MOVF   x34,W
0169C:  XORWF  x38,W
0169E:  ANDLW  80
016A0:  MOVWF  x3E
016A2:  BTFSS  x34.7
016A4:  BRA    16BC
016A6:  COMF   x31,F
016A8:  COMF   x32,F
016AA:  COMF   x33,F
016AC:  COMF   x34,F
016AE:  INCF   x31,F
016B0:  BTFSC  FD8.2
016B2:  INCF   x32,F
016B4:  BTFSC  FD8.2
016B6:  INCF   x33,F
016B8:  BTFSC  FD8.2
016BA:  INCF   x34,F
016BC:  BTFSS  x38.7
016BE:  BRA    16D6
016C0:  COMF   x35,F
016C2:  COMF   x36,F
016C4:  COMF   x37,F
016C6:  COMF   x38,F
016C8:  INCF   x35,F
016CA:  BTFSC  FD8.2
016CC:  INCF   x36,F
016CE:  BTFSC  FD8.2
016D0:  INCF   x37,F
016D2:  BTFSC  FD8.2
016D4:  INCF   x38,F
016D6:  CLRF   00
016D8:  CLRF   01
016DA:  CLRF   02
016DC:  CLRF   03
016DE:  CLRF   x39
016E0:  CLRF   x3A
016E2:  CLRF   x3B
016E4:  CLRF   x3C
016E6:  MOVF   x38,W
016E8:  IORWF  x37,W
016EA:  IORWF  x36,W
016EC:  IORWF  x35,W
016EE:  BZ    1748
016F0:  MOVLW  20
016F2:  MOVWF  x3D
016F4:  BCF    FD8.0
016F6:  RLCF   x31,F
016F8:  RLCF   x32,F
016FA:  RLCF   x33,F
016FC:  RLCF   x34,F
016FE:  RLCF   x39,F
01700:  RLCF   x3A,F
01702:  RLCF   x3B,F
01704:  RLCF   x3C,F
01706:  MOVF   x38,W
01708:  SUBWF  x3C,W
0170A:  BNZ   171C
0170C:  MOVF   x37,W
0170E:  SUBWF  x3B,W
01710:  BNZ   171C
01712:  MOVF   x36,W
01714:  SUBWF  x3A,W
01716:  BNZ   171C
01718:  MOVF   x35,W
0171A:  SUBWF  x39,W
0171C:  BNC   173C
0171E:  MOVF   x35,W
01720:  SUBWF  x39,F
01722:  MOVF   x36,W
01724:  BTFSS  FD8.0
01726:  INCFSZ x36,W
01728:  SUBWF  x3A,F
0172A:  MOVF   x37,W
0172C:  BTFSS  FD8.0
0172E:  INCFSZ x37,W
01730:  SUBWF  x3B,F
01732:  MOVF   x38,W
01734:  BTFSS  FD8.0
01736:  INCFSZ x38,W
01738:  SUBWF  x3C,F
0173A:  BSF    FD8.0
0173C:  RLCF   00,F
0173E:  RLCF   01,F
01740:  RLCF   02,F
01742:  RLCF   03,F
01744:  DECFSZ x3D,F
01746:  BRA    16F4
01748:  BTFSS  x3E.7
0174A:  BRA    1762
0174C:  COMF   00,F
0174E:  COMF   01,F
01750:  COMF   02,F
01752:  COMF   03,F
01754:  INCF   00,F
01756:  BTFSC  FD8.2
01758:  INCF   01,F
0175A:  BTFSC  FD8.2
0175C:  INCF   02,F
0175E:  BTFSC  FD8.2
01760:  INCF   03,F
01762:  MOVFF  739,FEF
01766:  MOVFF  73A,FEC
0176A:  MOVFF  73B,FEC
0176E:  MOVFF  73C,FEC
01772:  MOVLB  0
01774:  RETURN 0
*
01CD2:  MOVLW  B6
01CD4:  MOVWF  00
01CD6:  CLRF   03
01CD8:  CLRF   02
01CDA:  CLRF   01
01CDC:  MOVLB  7
01CDE:  BCF    x14.0
01CE0:  BTFSS  x13.7
01CE2:  BRA    1CFC
01CE4:  BSF    x14.0
01CE6:  COMF   x10,F
01CE8:  COMF   x11,F
01CEA:  COMF   x12,F
01CEC:  COMF   x13,F
01CEE:  INCF   x10,F
01CF0:  BNZ   1CFC
01CF2:  INCF   x11,F
01CF4:  BNZ   1CFC
01CF6:  INCF   x12,F
01CF8:  BTFSC  FD8.2
01CFA:  INCF   x13,F
01CFC:  MOVF   x10,W
01CFE:  IORWF  x11,W
01D00:  IORWF  x12,W
01D02:  IORWF  x13,W
01D04:  BNZ   1D0A
01D06:  CLRF   00
01D08:  BRA    1D28
01D0A:  BCF    FD8.0
01D0C:  BTFSC  01.7
01D0E:  BRA    1D22
01D10:  RLCF   x10,F
01D12:  RLCF   x11,F
01D14:  RLCF   x12,F
01D16:  RLCF   x13,F
01D18:  RLCF   03,F
01D1A:  RLCF   02,F
01D1C:  RLCF   01,F
01D1E:  DECFSZ 00,F
01D20:  BRA    1D0A
01D22:  BCF    01.7
01D24:  BTFSC  x14.0
01D26:  BSF    01.7
01D28:  MOVLB  0
01D2A:  RETURN 0
01D2C:  MOVFF  747,74E
01D30:  MOVLB  7
01D32:  MOVF   x4B,W
01D34:  XORWF  x4E,F
01D36:  BTFSS  x4E.7
01D38:  BRA    1D44
01D3A:  BCF    FD8.2
01D3C:  BCF    FD8.0
01D3E:  BTFSC  x47.7
01D40:  BSF    FD8.0
01D42:  BRA    1DA2
01D44:  MOVFF  747,74E
01D48:  MOVFF  74A,74F
01D4C:  MOVF   x46,W
01D4E:  SUBWF  x4F,F
01D50:  BZ    1D5E
01D52:  BTFSS  x4E.7
01D54:  BRA    1DA2
01D56:  MOVF   FD8,W
01D58:  XORLW  01
01D5A:  MOVWF  FD8
01D5C:  BRA    1DA2
01D5E:  MOVFF  74B,74F
01D62:  MOVF   x47,W
01D64:  SUBWF  x4F,F
01D66:  BZ    1D74
01D68:  BTFSS  x4E.7
01D6A:  BRA    1DA2
01D6C:  MOVF   FD8,W
01D6E:  XORLW  01
01D70:  MOVWF  FD8
01D72:  BRA    1DA2
01D74:  MOVFF  74C,74F
01D78:  MOVF   x48,W
01D7A:  SUBWF  x4F,F
01D7C:  BZ    1D8A
01D7E:  BTFSS  x4E.7
01D80:  BRA    1DA2
01D82:  MOVF   FD8,W
01D84:  XORLW  01
01D86:  MOVWF  FD8
01D88:  BRA    1DA2
01D8A:  MOVFF  74D,74F
01D8E:  MOVF   x49,W
01D90:  SUBWF  x4F,F
01D92:  BZ    1DA0
01D94:  BTFSS  x4E.7
01D96:  BRA    1DA2
01D98:  MOVF   FD8,W
01D9A:  XORLW  01
01D9C:  MOVWF  FD8
01D9E:  BRA    1DA2
01DA0:  BCF    FD8.0
01DA2:  MOVLB  0
01DA4:  RETURN 0
01DA6:  MOVLB  7
01DA8:  MOVF   x3F,W
01DAA:  BTFSC  FD8.2
01DAC:  BRA    1EF8
01DAE:  MOVWF  x4B
01DB0:  MOVF   x43,W
01DB2:  BTFSC  FD8.2
01DB4:  BRA    1EF8
01DB6:  SUBWF  x4B,F
01DB8:  BNC   1DC4
01DBA:  MOVLW  7F
01DBC:  ADDWF  x4B,F
01DBE:  BTFSC  FD8.0
01DC0:  BRA    1EF8
01DC2:  BRA    1DD0
01DC4:  MOVLW  81
01DC6:  SUBWF  x4B,F
01DC8:  BTFSS  FD8.0
01DCA:  BRA    1EF8
01DCC:  BTFSC  FD8.2
01DCE:  BRA    1EF8
01DD0:  MOVFF  74B,00
01DD4:  CLRF   01
01DD6:  CLRF   02
01DD8:  CLRF   03
01DDA:  CLRF   x4A
01DDC:  MOVFF  740,749
01DE0:  BSF    x49.7
01DE2:  MOVFF  741,748
01DE6:  MOVFF  742,747
01DEA:  MOVLW  19
01DEC:  MOVWF  x4B
01DEE:  MOVF   x46,W
01DF0:  SUBWF  x47,F
01DF2:  BC    1E0E
01DF4:  MOVLW  01
01DF6:  SUBWF  x48,F
01DF8:  BC    1E0E
01DFA:  SUBWF  x49,F
01DFC:  BC    1E0E
01DFE:  SUBWF  x4A,F
01E00:  BC    1E0E
01E02:  INCF   x4A,F
01E04:  INCF   x49,F
01E06:  INCF   x48,F
01E08:  MOVF   x46,W
01E0A:  ADDWF  x47,F
01E0C:  BRA    1E5E
01E0E:  MOVF   x45,W
01E10:  SUBWF  x48,F
01E12:  BC    1E38
01E14:  MOVLW  01
01E16:  SUBWF  x49,F
01E18:  BC    1E38
01E1A:  SUBWF  x4A,F
01E1C:  BC    1E38
01E1E:  INCF   x4A,F
01E20:  INCF   x49,F
01E22:  MOVF   x45,W
01E24:  ADDWF  x48,F
01E26:  MOVF   x46,W
01E28:  ADDWF  x47,F
01E2A:  BNC   1E5E
01E2C:  INCF   x48,F
01E2E:  BNZ   1E5E
01E30:  INCF   x49,F
01E32:  BNZ   1E5E
01E34:  INCF   x4A,F
01E36:  BRA    1E5E
01E38:  MOVF   x44,W
01E3A:  IORLW  80
01E3C:  SUBWF  x49,F
01E3E:  BC    1E5C
01E40:  MOVLW  01
01E42:  SUBWF  x4A,F
01E44:  BC    1E5C
01E46:  INCF   x4A,F
01E48:  MOVF   x44,W
01E4A:  IORLW  80
01E4C:  ADDWF  x49,F
01E4E:  MOVF   x45,W
01E50:  ADDWF  x48,F
01E52:  BNC   1E26
01E54:  INCF   x49,F
01E56:  BNZ   1E26
01E58:  INCF   x4A,F
01E5A:  BRA    1E26
01E5C:  BSF    03.0
01E5E:  DECFSZ x4B,F
01E60:  BRA    1E64
01E62:  BRA    1E7A
01E64:  BCF    FD8.0
01E66:  RLCF   x47,F
01E68:  RLCF   x48,F
01E6A:  RLCF   x49,F
01E6C:  RLCF   x4A,F
01E6E:  BCF    FD8.0
01E70:  RLCF   03,F
01E72:  RLCF   02,F
01E74:  RLCF   01,F
01E76:  RLCF   x4C,F
01E78:  BRA    1DEE
01E7A:  BTFSS  x4C.0
01E7C:  BRA    1E8A
01E7E:  BCF    FD8.0
01E80:  RRCF   01,F
01E82:  RRCF   02,F
01E84:  RRCF   03,F
01E86:  RRCF   x4C,F
01E88:  BRA    1E8E
01E8A:  DECF   00,F
01E8C:  BZ    1EF8
01E8E:  BTFSC  x4C.7
01E90:  BRA    1ECE
01E92:  BCF    FD8.0
01E94:  RLCF   x47,F
01E96:  RLCF   x48,F
01E98:  RLCF   x49,F
01E9A:  RLCF   x4A,F
01E9C:  MOVF   x46,W
01E9E:  SUBWF  x47,F
01EA0:  BC    1EB0
01EA2:  MOVLW  01
01EA4:  SUBWF  x48,F
01EA6:  BC    1EB0
01EA8:  SUBWF  x49,F
01EAA:  BC    1EB0
01EAC:  SUBWF  x4A,F
01EAE:  BNC   1EE4
01EB0:  MOVF   x45,W
01EB2:  SUBWF  x48,F
01EB4:  BC    1EC0
01EB6:  MOVLW  01
01EB8:  SUBWF  x49,F
01EBA:  BC    1EC0
01EBC:  SUBWF  x4A,F
01EBE:  BNC   1EE4
01EC0:  MOVF   x44,W
01EC2:  IORLW  80
01EC4:  SUBWF  x49,F
01EC6:  BC    1ECE
01EC8:  MOVLW  01
01ECA:  SUBWF  x4A,F
01ECC:  BNC   1EE4
01ECE:  INCF   03,F
01ED0:  BNZ   1EE4
01ED2:  INCF   02,F
01ED4:  BNZ   1EE4
01ED6:  INCF   01,F
01ED8:  BNZ   1EE4
01EDA:  INCF   00,F
01EDC:  BZ    1EF8
01EDE:  RRCF   01,F
01EE0:  RRCF   02,F
01EE2:  RRCF   03,F
01EE4:  MOVFF  740,74B
01EE8:  MOVF   x44,W
01EEA:  XORWF  x4B,F
01EEC:  BTFSS  x4B.7
01EEE:  BRA    1EF4
01EF0:  BSF    01.7
01EF2:  BRA    1F00
01EF4:  BCF    01.7
01EF6:  BRA    1F00
01EF8:  CLRF   00
01EFA:  CLRF   01
01EFC:  CLRF   02
01EFE:  CLRF   03
01F00:  MOVLB  0
01F02:  RETURN 0
*
026AE:  ADDWF  FE8,W
026B0:  CLRF   FF7
026B2:  RLCF   FF7,F
026B4:  ADDLW  C9
026B6:  MOVWF  FF6
026B8:  MOVLW  26
026BA:  ADDWFC FF7,F
026BC:  TBLRD*-
026BE:  MOVF   FF5,W
026C0:  MOVWF  FFA
026C2:  TBLRD*
026C4:  MOVF   FF5,W
026C6:  MOVWF  FF9
026C8:  DATA B6,25
026CA:  DATA D0,25
026CC:  DATA 24,26
026CE:  DATA 88,26
026D0:  MOVLW  8E
026D2:  MOVWF  00
026D4:  MOVFF  73D,01
026D8:  MOVFF  73C,02
026DC:  CLRF   03
026DE:  BTFSS  01.7
026E0:  BRA    26EC
026E2:  COMF   01,F
026E4:  COMF   02,F
026E6:  INCF   02,F
026E8:  BNZ   26EC
026EA:  INCF   01,F
026EC:  MOVF   01,F
026EE:  BNZ   2702
026F0:  MOVFF  02,01
026F4:  CLRF   02
026F6:  MOVLW  08
026F8:  SUBWF  00,F
026FA:  MOVF   01,F
026FC:  BNZ   2702
026FE:  CLRF   00
02700:  BRA    271E
02702:  BCF    FD8.0
02704:  BTFSC  01.7
02706:  BRA    2710
02708:  RLCF   02,F
0270A:  RLCF   01,F
0270C:  DECF   00,F
0270E:  BRA    2702
02710:  MOVLB  7
02712:  BTFSS  x3D.7
02714:  BRA    271A
02716:  MOVLB  0
02718:  BRA    271E
0271A:  BCF    01.7
0271C:  MOVLB  0
0271E:  RETURN 0
02720:  MOVLW  8E
02722:  MOVWF  00
02724:  MOVLB  7
02726:  MOVF   x46,W
02728:  SUBWF  00,F
0272A:  MOVFF  747,02
0272E:  MOVFF  748,01
02732:  BSF    02.7
02734:  MOVF   00,F
02736:  BZ    274A
02738:  BCF    FD8.0
0273A:  MOVF   02,F
0273C:  BNZ   2742
0273E:  MOVF   01,F
02740:  BZ    274A
02742:  RRCF   02,F
02744:  RRCF   01,F
02746:  DECFSZ 00,F
02748:  BRA    2738
0274A:  BTFSS  x47.7
0274C:  BRA    2758
0274E:  COMF   01,F
02750:  COMF   02,F
02752:  INCF   01,F
02754:  BTFSC  FD8.2
02756:  INCF   02,F
02758:  MOVLB  0
0275A:  RETURN 0
*
04614:  MOVLB  7
04616:  MOVF   x0D,W
04618:  ANDLW  07
0461A:  MOVWF  00
0461C:  RRCF   x0D,W
0461E:  MOVWF  01
04620:  RRCF   01,F
04622:  RRCF   01,F
04624:  MOVLW  1F
04626:  ANDWF  01,F
04628:  MOVF   01,W
0462A:  ADDWF  x0E,W
0462C:  MOVWF  FE9
0462E:  MOVLW  00
04630:  ADDWFC x0F,W
04632:  MOVWF  FEA
04634:  MOVFF  FEF,01
04638:  INCF   00,F
0463A:  BRA    463E
0463C:  RRCF   01,F
0463E:  DECFSZ 00,F
04640:  BRA    463C
04642:  MOVLW  01
04644:  ANDWF  01,F
04646:  MOVLB  0
04648:  RETURN 0
*
05056:  MOVF   FEF,F
05058:  BZ    507E
0505A:  MOVFF  FEA,704
0505E:  MOVFF  FE9,703
05062:  MOVF   FEF,W
05064:  MOVLB  E
05066:  BTFSS  xC8.4
05068:  BRA    5066
0506A:  MOVWF  F99
0506C:  MOVFF  704,FEA
05070:  MOVFF  703,FE9
05074:  INCF   FE9,F
05076:  BTFSC  FD8.2
05078:  INCF   FEA,F
0507A:  MOVLB  0
0507C:  BRA    5056
0507E:  RETURN 0
*
055D0:  MOVFF  565,FEA
055D4:  MOVFF  564,FE9
055D8:  MOVFF  750,FEF
055DC:  INCF   FE9,F
055DE:  BTFSC  FD8.2
055E0:  INCF   FEA,F
055E2:  CLRF   FEF
055E4:  MOVLB  5
055E6:  INCF   x64,F
055E8:  BTFSC  FD8.2
055EA:  INCF   x65,F
055EC:  MOVLB  0
055EE:  RETURN 0
055F0:  TBLRD*+
055F2:  MOVFF  FF6,710
055F6:  MOVFF  FF7,711
055FA:  MOVFF  FF5,750
055FE:  RCALL  55D0
05600:  MOVFF  710,FF6
05604:  MOVFF  711,FF7
05608:  MOVLB  7
0560A:  DECFSZ x0F,F
0560C:  BRA    5610
0560E:  BRA    5614
05610:  MOVLB  0
05612:  BRA    55F0
05614:  MOVLB  0
05616:  RETURN 0
05618:  MOVF   01,W
0561A:  MOVFF  706,73A
0561E:  MOVLW  64
05620:  MOVLB  7
05622:  MOVWF  x3B
05624:  MOVLB  0
05626:  CALL   08D8
0562A:  MOVFF  00,706
0562E:  MOVF   01,W
05630:  MOVLW  30
05632:  BNZ   5644
05634:  MOVLB  7
05636:  BTFSS  x07.1
05638:  BRA    5658
0563A:  BTFSC  x07.3
0563C:  BRA    5658
0563E:  BTFSC  x07.4
05640:  MOVLW  20
05642:  BRA    564C
05644:  MOVLB  7
05646:  BCF    x07.3
05648:  BCF    x07.4
0564A:  BSF    x07.0
0564C:  ADDWF  01,F
0564E:  MOVFF  01,750
05652:  MOVLB  0
05654:  RCALL  55D0
05656:  MOVLB  7
05658:  MOVFF  706,73A
0565C:  MOVLW  0A
0565E:  MOVWF  x3B
05660:  MOVLB  0
05662:  CALL   08D8
05666:  MOVFF  00,706
0566A:  MOVF   01,W
0566C:  MOVLW  30
0566E:  BNZ   5680
05670:  MOVLB  7
05672:  BTFSC  x07.3
05674:  BRA    568A
05676:  BTFSS  x07.0
05678:  BRA    568A
0567A:  BTFSC  x07.4
0567C:  MOVLW  20
0567E:  MOVLB  0
05680:  ADDWF  01,F
05682:  MOVFF  01,750
05686:  RCALL  55D0
05688:  MOVLB  7
0568A:  MOVLW  30
0568C:  ADDWF  x06,F
0568E:  MOVFF  706,750
05692:  MOVLB  0
05694:  RCALL  55D0
05696:  RETURN 0
05698:  MOVLB  7
0569A:  MOVF   x50,W
0569C:  SUBLW  B6
0569E:  MOVWF  x50
056A0:  CLRF   03
056A2:  MOVFF  751,754
056A6:  BSF    x51.7
056A8:  BCF    FD8.0
056AA:  RRCF   x51,F
056AC:  RRCF   x52,F
056AE:  RRCF   x53,F
056B0:  RRCF   03,F
056B2:  RRCF   02,F
056B4:  RRCF   01,F
056B6:  RRCF   00,F
056B8:  DECFSZ x50,F
056BA:  BRA    56A8
056BC:  BTFSS  x54.7
056BE:  BRA    56D6
056C0:  COMF   00,F
056C2:  COMF   01,F
056C4:  COMF   02,F
056C6:  COMF   03,F
056C8:  INCF   00,F
056CA:  BTFSC  FD8.2
056CC:  INCF   01,F
056CE:  BTFSC  FD8.2
056D0:  INCF   02,F
056D2:  BTFSC  FD8.2
056D4:  INCF   03,F
056D6:  MOVLB  0
056D8:  RETURN 0
056DA:  BTFSC  FD8.1
056DC:  BRA    56E6
056DE:  MOVLW  07
056E0:  MOVWF  FEA
056E2:  MOVLW  58
056E4:  MOVWF  FE9
056E6:  CLRF   00
056E8:  CLRF   01
056EA:  CLRF   02
056EC:  CLRF   03
056EE:  MOVLB  7
056F0:  CLRF   x58
056F2:  CLRF   x59
056F4:  CLRF   x5A
056F6:  CLRF   x5B
056F8:  MOVF   x57,W
056FA:  IORWF  x56,W
056FC:  IORWF  x55,W
056FE:  IORWF  x54,W
05700:  BZ    575A
05702:  MOVLW  20
05704:  MOVWF  x5C
05706:  BCF    FD8.0
05708:  RLCF   x50,F
0570A:  RLCF   x51,F
0570C:  RLCF   x52,F
0570E:  RLCF   x53,F
05710:  RLCF   x58,F
05712:  RLCF   x59,F
05714:  RLCF   x5A,F
05716:  RLCF   x5B,F
05718:  MOVF   x57,W
0571A:  SUBWF  x5B,W
0571C:  BNZ   572E
0571E:  MOVF   x56,W
05720:  SUBWF  x5A,W
05722:  BNZ   572E
05724:  MOVF   x55,W
05726:  SUBWF  x59,W
05728:  BNZ   572E
0572A:  MOVF   x54,W
0572C:  SUBWF  x58,W
0572E:  BNC   574E
05730:  MOVF   x54,W
05732:  SUBWF  x58,F
05734:  MOVF   x55,W
05736:  BTFSS  FD8.0
05738:  INCFSZ x55,W
0573A:  SUBWF  x59,F
0573C:  MOVF   x56,W
0573E:  BTFSS  FD8.0
05740:  INCFSZ x56,W
05742:  SUBWF  x5A,F
05744:  MOVF   x57,W
05746:  BTFSS  FD8.0
05748:  INCFSZ x57,W
0574A:  SUBWF  x5B,F
0574C:  BSF    FD8.0
0574E:  RLCF   00,F
05750:  RLCF   01,F
05752:  RLCF   02,F
05754:  RLCF   03,F
05756:  DECFSZ x5C,F
05758:  BRA    5706
0575A:  MOVFF  758,FEF
0575E:  MOVFF  759,FEC
05762:  MOVFF  75A,FEC
05766:  MOVFF  75B,FEC
0576A:  MOVLB  0
0576C:  RETURN 0
0576E:  MOVF   FE9,W
05770:  MOVLB  7
05772:  MOVWF  x48
05774:  MOVF   x47,W
05776:  MOVWF  x4A
05778:  BZ    57B2
0577A:  MOVFF  746,753
0577E:  MOVFF  745,752
05782:  MOVFF  744,751
05786:  MOVFF  743,750
0578A:  CLRF   x57
0578C:  CLRF   x56
0578E:  MOVLW  20
05790:  MOVWF  x55
05792:  MOVLW  82
05794:  MOVWF  x54
05796:  MOVLB  0
05798:  CALL   0DA0
0579C:  MOVFF  03,746
057A0:  MOVFF  02,745
057A4:  MOVFF  01,744
057A8:  MOVFF  00,743
057AC:  MOVLB  7
057AE:  DECFSZ x4A,F
057B0:  BRA    577A
057B2:  MOVFF  746,753
057B6:  MOVFF  745,752
057BA:  MOVFF  744,751
057BE:  MOVFF  743,750
057C2:  MOVLB  0
057C4:  RCALL  5698
057C6:  MOVFF  03,746
057CA:  MOVFF  02,745
057CE:  MOVFF  01,744
057D2:  MOVFF  00,743
057D6:  MOVLB  7
057D8:  BTFSS  x46.7
057DA:  BRA    57F6
057DC:  DECF   x48,F
057DE:  BSF    x48.5
057E0:  COMF   x43,F
057E2:  COMF   x44,F
057E4:  COMF   x45,F
057E6:  COMF   x46,F
057E8:  INCF   x43,F
057EA:  BTFSC  FD8.2
057EC:  INCF   x44,F
057EE:  BTFSC  FD8.2
057F0:  INCF   x45,F
057F2:  BTFSC  FD8.2
057F4:  INCF   x46,F
057F6:  MOVLW  3B
057F8:  MOVWF  x4F
057FA:  MOVLW  9A
057FC:  MOVWF  x4E
057FE:  MOVLW  CA
05800:  MOVWF  x4D
05802:  CLRF   x4C
05804:  MOVLW  0A
05806:  MOVWF  x4A
05808:  MOVF   x47,W
0580A:  BTFSC  FD8.2
0580C:  INCF   x48,F
0580E:  BSF    FD8.1
05810:  MOVLW  07
05812:  MOVWF  FEA
05814:  MOVLW  43
05816:  MOVWF  FE9
05818:  MOVFF  746,753
0581C:  MOVFF  745,752
05820:  MOVFF  744,751
05824:  MOVFF  743,750
05828:  MOVFF  74F,757
0582C:  MOVFF  74E,756
05830:  MOVFF  74D,755
05834:  MOVFF  74C,754
05838:  MOVLB  0
0583A:  RCALL  56DA
0583C:  MOVF   01,W
0583E:  MOVF   00,F
05840:  BNZ   5868
05842:  MOVLB  7
05844:  INCF   x47,W
05846:  SUBWF  x4A,W
05848:  BTFSS  FD8.2
0584A:  BRA    5850
0584C:  MOVLB  0
0584E:  BRA    5868
05850:  MOVF   x48,W
05852:  BZ    586E
05854:  ANDLW  0F
05856:  SUBWF  x4A,W
05858:  BZ    585C
0585A:  BC    58DC
0585C:  BTFSC  x48.7
0585E:  BRA    58DC
05860:  BTFSC  x48.6
05862:  BRA    586E
05864:  MOVLW  20
05866:  BRA    58D0
05868:  MOVLW  20
0586A:  MOVLB  7
0586C:  ANDWF  x48,F
0586E:  BTFSS  x48.5
05870:  BRA    588E
05872:  BCF    x48.5
05874:  MOVF   x47,W
05876:  BTFSS  FD8.2
05878:  DECF   x48,F
0587A:  MOVF   00,W
0587C:  MOVWF  x48
0587E:  MOVLW  2D
05880:  MOVWF  x50
05882:  MOVLB  0
05884:  RCALL  55D0
05886:  MOVLB  7
05888:  MOVF   x48,W
0588A:  MOVWF  00
0588C:  CLRF   x48
0588E:  MOVF   x47,W
05890:  SUBWF  x4A,W
05892:  BNZ   58AC
05894:  MOVF   00,W
05896:  MOVWF  x48
05898:  MOVLW  2E
0589A:  MOVWF  x50
0589C:  MOVLB  0
0589E:  RCALL  55D0
058A0:  MOVLB  7
058A2:  MOVF   x48,W
058A4:  MOVWF  00
058A6:  MOVLW  20
058A8:  ANDWF  x48,F
058AA:  MOVLW  00
058AC:  MOVLW  30
058AE:  BTFSS  x48.5
058B0:  BRA    58D0
058B2:  BCF    x48.5
058B4:  MOVF   x47,W
058B6:  BTFSS  FD8.2
058B8:  DECF   x48,F
058BA:  MOVF   00,W
058BC:  MOVWF  x48
058BE:  MOVLW  2D
058C0:  MOVWF  x50
058C2:  MOVLB  0
058C4:  RCALL  55D0
058C6:  MOVLB  7
058C8:  MOVF   x48,W
058CA:  MOVWF  00
058CC:  CLRF   x48
058CE:  MOVLW  30
058D0:  ADDWF  00,F
058D2:  MOVFF  00,750
058D6:  MOVLB  0
058D8:  RCALL  55D0
058DA:  MOVLB  7
058DC:  BCF    FD8.1
058DE:  MOVFF  74F,753
058E2:  MOVFF  74E,752
058E6:  MOVFF  74D,751
058EA:  MOVFF  74C,750
058EE:  CLRF   x57
058F0:  CLRF   x56
058F2:  CLRF   x55
058F4:  MOVLW  0A
058F6:  MOVWF  x54
058F8:  MOVLB  0
058FA:  RCALL  56DA
058FC:  MOVFF  03,74F
05900:  MOVFF  02,74E
05904:  MOVFF  01,74D
05908:  MOVFF  00,74C
0590C:  MOVLB  7
0590E:  DECFSZ x4A,F
05910:  BRA    580E
05912:  MOVLB  0
05914:  RETURN 0
05916:  MOVFF  FEA,708
0591A:  MOVFF  FE9,707
0591E:  MOVLB  7
05920:  SWAPF  x01,W
05922:  IORLW  F0
05924:  MOVWF  x03
05926:  ADDWF  x03,F
05928:  ADDLW  E2
0592A:  MOVWF  x04
0592C:  ADDLW  32
0592E:  MOVWF  x06
05930:  MOVF   x01,W
05932:  ANDLW  0F
05934:  ADDWF  x04,F
05936:  ADDWF  x04,F
05938:  ADDWF  x06,F
0593A:  ADDLW  E9
0593C:  MOVWF  x05
0593E:  ADDWF  x05,F
05940:  ADDWF  x05,F
05942:  SWAPF  x00,W
05944:  ANDLW  0F
05946:  ADDWF  x05,F
05948:  ADDWF  x06,F
0594A:  RLCF   x05,F
0594C:  RLCF   x06,F
0594E:  COMF   x06,F
05950:  RLCF   x06,F
05952:  MOVF   x00,W
05954:  ANDLW  0F
05956:  ADDWF  x06,F
05958:  RLCF   x03,F
0595A:  MOVLW  07
0595C:  MOVWF  x02
0595E:  MOVLW  0A
05960:  DECF   x05,F
05962:  ADDWF  x06,F
05964:  BNC   5960
05966:  DECF   x04,F
05968:  ADDWF  x05,F
0596A:  BNC   5966
0596C:  DECF   x03,F
0596E:  ADDWF  x04,F
05970:  BNC   596C
05972:  DECF   x02,F
05974:  ADDWF  x03,F
05976:  BNC   5972
05978:  MOVLW  07
0597A:  MOVWF  FEA
0597C:  MOVLW  02
0597E:  MOVWF  FE9
05980:  MOVLW  07
05982:  ANDWF  x07,W
05984:  BCF    x07.6
05986:  ADDWF  FE9,F
05988:  MOVLW  00
0598A:  ADDWFC FEA,F
0598C:  MOVF   FE9,W
0598E:  SUBLW  06
05990:  BNZ   599A
05992:  MOVF   FEA,W
05994:  SUBLW  07
05996:  BNZ   599A
05998:  BSF    x07.6
0599A:  MOVF   FEF,W
0599C:  MOVWF  00
0599E:  BNZ   59B0
059A0:  BTFSC  x07.6
059A2:  BRA    59B0
059A4:  BTFSC  x07.4
059A6:  BRA    59D2
059A8:  BTFSC  x07.3
059AA:  BRA    59B0
059AC:  MOVLW  20
059AE:  BRA    59B6
059B0:  BSF    x07.3
059B2:  BCF    x07.4
059B4:  MOVLW  30
059B6:  ADDWF  00,F
059B8:  MOVFF  FEA,701
059BC:  MOVFF  FE9,700
059C0:  MOVFF  00,750
059C4:  MOVLB  0
059C6:  RCALL  55D0
059C8:  MOVFF  701,FEA
059CC:  MOVFF  700,FE9
059D0:  MOVLB  7
059D2:  MOVF   FEE,W
059D4:  BTFSS  x07.6
059D6:  BRA    598C
059D8:  MOVLB  0
059DA:  RETURN 0
*
05A2C:  MOVF   FEF,F
05A2E:  BZ    5A4E
05A30:  MOVFF  FEA,6FC
05A34:  MOVFF  FE9,6FB
05A38:  MOVFF  FEF,6FD
05A3C:  RCALL  59DC
05A3E:  MOVFF  6FC,FEA
05A42:  MOVFF  6FB,FE9
05A46:  INCF   FE9,F
05A48:  BTFSC  FD8.2
05A4A:  INCF   FEA,F
05A4C:  BRA    5A2C
05A4E:  GOTO   AAC8 (RETURN)
*
05AAC:  MOVF   FEF,F
05AAE:  BZ    5ACE
05AB0:  MOVFF  FEA,708
05AB4:  MOVFF  FE9,707
05AB8:  MOVFF  FEF,750
05ABC:  RCALL  55D0
05ABE:  MOVFF  708,FEA
05AC2:  MOVFF  707,FE9
05AC6:  INCF   FE9,F
05AC8:  BTFSC  FD8.2
05ACA:  INCF   FEA,F
05ACC:  BRA    5AAC
05ACE:  RETURN 0
*
05B82:  TBLRD*+
05B84:  MOVF   FF5,F
05B86:  BZ    5BA0
05B88:  MOVFF  FF6,70E
05B8C:  MOVFF  FF7,70F
05B90:  MOVFF  FF5,750
05B94:  RCALL  55D0
05B96:  MOVFF  70E,FF6
05B9A:  MOVFF  70F,FF7
05B9E:  BRA    5B82
05BA0:  RETURN 0
*
05CC4:  MOVLB  7
05CC6:  MOVF   x68,W
05CC8:  XORWF  x6A,W
05CCA:  ANDLW  80
05CCC:  MOVWF  x6C
05CCE:  BTFSS  x68.7
05CD0:  BRA    5CDC
05CD2:  COMF   x67,F
05CD4:  COMF   x68,F
05CD6:  INCF   x67,F
05CD8:  BTFSC  FD8.2
05CDA:  INCF   x68,F
05CDC:  BTFSS  x6A.7
05CDE:  BRA    5CEA
05CE0:  COMF   x69,F
05CE2:  COMF   x6A,F
05CE4:  INCF   x69,F
05CE6:  BTFSC  FD8.2
05CE8:  INCF   x6A,F
05CEA:  MOVF   x67,W
05CEC:  MULWF  x69
05CEE:  MOVFF  FF3,01
05CF2:  MOVFF  FF4,00
05CF6:  MULWF  x6A
05CF8:  MOVF   FF3,W
05CFA:  ADDWF  00,F
05CFC:  MOVF   x68,W
05CFE:  MULWF  x69
05D00:  MOVF   FF3,W
05D02:  ADDWFC 00,W
05D04:  MOVWF  02
05D06:  BTFSS  x6C.7
05D08:  BRA    5D14
05D0A:  COMF   01,F
05D0C:  COMF   02,F
05D0E:  INCF   01,F
05D10:  BTFSC  FD8.2
05D12:  INCF   02,F
05D14:  MOVLB  0
05D16:  GOTO   5FAA (RETURN)
*
0606E:  MOVLW  20
06070:  MOVLB  7
06072:  BTFSS  x35.4
06074:  MOVLW  30
06076:  MOVWF  x36
06078:  MOVFF  734,00
0607C:  BTFSS  00.7
0607E:  BRA    6090
06080:  COMF   00,F
06082:  INCF   00,F
06084:  MOVFF  00,734
06088:  MOVLW  2D
0608A:  MOVWF  x36
0608C:  BSF    x35.7
0608E:  BSF    x35.0
06090:  MOVF   01,W
06092:  MOVFF  734,73A
06096:  MOVLW  64
06098:  MOVWF  x3B
0609A:  MOVLB  0
0609C:  CALL   08D8
060A0:  MOVFF  00,734
060A4:  MOVLW  30
060A6:  ADDWF  01,W
060A8:  MOVLB  7
060AA:  MOVWF  x37
060AC:  MOVFF  734,73A
060B0:  MOVLW  0A
060B2:  MOVWF  x3B
060B4:  MOVLB  0
060B6:  CALL   08D8
060BA:  MOVLW  30
060BC:  ADDWF  00,W
060BE:  MOVLB  7
060C0:  MOVWF  x39
060C2:  MOVLW  30
060C4:  ADDWF  01,W
060C6:  MOVWF  x38
060C8:  MOVFF  736,00
060CC:  MOVLW  30
060CE:  SUBWF  x37,W
060D0:  BZ    60DA
060D2:  BSF    x35.1
060D4:  BTFSC  x35.7
060D6:  BSF    x35.2
060D8:  BRA    60FE
060DA:  MOVFF  736,737
060DE:  MOVLW  20
060E0:  MOVWF  x36
060E2:  MOVLW  30
060E4:  SUBWF  x38,W
060E6:  BZ    60F0
060E8:  BSF    x35.0
060EA:  BTFSC  x35.7
060EC:  BSF    x35.1
060EE:  BRA    60FE
060F0:  BTFSS  FD8.2
060F2:  BSF    x35.0
060F4:  BNZ   60FE
060F6:  MOVFF  737,738
060FA:  MOVLW  20
060FC:  MOVWF  x37
060FE:  BTFSC  x35.2
06100:  BRA    610C
06102:  BTFSC  x35.1
06104:  BRA    6116
06106:  BTFSC  x35.0
06108:  BRA    6120
0610A:  BRA    612A
0610C:  MOVFF  736,750
06110:  MOVLB  0
06112:  CALL   55D0
06116:  MOVFF  737,750
0611A:  MOVLB  0
0611C:  CALL   55D0
06120:  MOVFF  738,750
06124:  MOVLB  0
06126:  CALL   55D0
0612A:  MOVFF  739,750
0612E:  MOVLB  0
06130:  CALL   55D0
06134:  RETURN 0
*
062E2:  MOVLB  7
062E4:  MOVF   x22,W
062E6:  ANDLW  07
062E8:  MOVWF  00
062EA:  RRCF   x22,W
062EC:  MOVWF  01
062EE:  RRCF   01,F
062F0:  RRCF   01,F
062F2:  MOVLW  1F
062F4:  ANDWF  01,F
062F6:  MOVF   01,W
062F8:  ADDWF  x24,W
062FA:  MOVWF  FE9
062FC:  MOVLW  00
062FE:  ADDWFC x25,W
06300:  MOVWF  FEA
06302:  CLRF   01
06304:  INCF   01,F
06306:  INCF   00,F
06308:  BRA    630C
0630A:  RLCF   01,F
0630C:  DECFSZ 00,F
0630E:  BRA    630A
06310:  MOVF   x23,F
06312:  BZ    631A
06314:  MOVF   01,W
06316:  IORWF  FEF,F
06318:  BRA    6320
0631A:  COMF   01,F
0631C:  MOVF   01,W
0631E:  ANDWF  FEF,F
06320:  MOVLB  0
06322:  RETURN 0
*
092F0:  MOVF   FE9,W
092F2:  MOVLB  7
092F4:  MOVWF  x3D
092F6:  BTFSS  x3C.7
092F8:  BRA    9314
092FA:  DECF   x3D,F
092FC:  BSF    x3D.5
092FE:  COMF   x39,F
09300:  COMF   x3A,F
09302:  COMF   x3B,F
09304:  COMF   x3C,F
09306:  INCF   x39,F
09308:  BTFSC  FD8.2
0930A:  INCF   x3A,F
0930C:  BTFSC  FD8.2
0930E:  INCF   x3B,F
09310:  BTFSC  FD8.2
09312:  INCF   x3C,F
09314:  MOVLW  3B
09316:  MOVWF  x44
09318:  MOVLW  9A
0931A:  MOVWF  x43
0931C:  MOVLW  CA
0931E:  MOVWF  x42
09320:  CLRF   x41
09322:  MOVLW  0A
09324:  MOVWF  x3F
09326:  BSF    FD8.1
09328:  MOVLW  07
0932A:  MOVWF  FEA
0932C:  MOVLW  39
0932E:  MOVWF  FE9
09330:  MOVFF  73C,753
09334:  MOVFF  73B,752
09338:  MOVFF  73A,751
0933C:  MOVFF  739,750
09340:  MOVFF  744,757
09344:  MOVFF  743,756
09348:  MOVFF  742,755
0934C:  MOVFF  741,754
09350:  MOVLB  0
09352:  CALL   56DA
09356:  MOVF   01,W
09358:  MOVF   00,F
0935A:  BNZ   9382
0935C:  MOVLB  7
0935E:  MOVF   x3F,W
09360:  XORLW  01
09362:  BTFSS  FD8.2
09364:  BRA    936A
09366:  MOVLB  0
09368:  BRA    9382
0936A:  MOVF   x3D,W
0936C:  BZ    9388
0936E:  ANDLW  0F
09370:  SUBWF  x3F,W
09372:  BZ    9376
09374:  BC    93D2
09376:  BTFSC  x3D.7
09378:  BRA    93D2
0937A:  BTFSC  x3D.6
0937C:  BRA    9388
0937E:  MOVLW  20
09380:  BRA    93C4
09382:  MOVLW  20
09384:  MOVLB  7
09386:  ANDWF  x3D,F
09388:  BTFSS  x3D.5
0938A:  BRA    93A4
0938C:  BCF    x3D.5
0938E:  MOVFF  00,73D
09392:  MOVLW  2D
09394:  MOVWF  x50
09396:  MOVLB  0
09398:  CALL   55D0
0939C:  MOVLB  7
0939E:  MOVFF  73D,00
093A2:  CLRF   x3D
093A4:  MOVLW  30
093A6:  BTFSS  x3D.5
093A8:  BRA    93C4
093AA:  BCF    x3D.5
093AC:  MOVFF  00,73D
093B0:  MOVLW  2D
093B2:  MOVWF  x50
093B4:  MOVLB  0
093B6:  CALL   55D0
093BA:  MOVLB  7
093BC:  MOVFF  73D,00
093C0:  CLRF   x3D
093C2:  MOVLW  30
093C4:  ADDWF  00,F
093C6:  MOVFF  00,750
093CA:  MOVLB  0
093CC:  CALL   55D0
093D0:  MOVLB  7
093D2:  BCF    FD8.1
093D4:  MOVFF  744,753
093D8:  MOVFF  743,752
093DC:  MOVFF  742,751
093E0:  MOVFF  741,750
093E4:  CLRF   x57
093E6:  CLRF   x56
093E8:  CLRF   x55
093EA:  MOVLW  0A
093EC:  MOVWF  x54
093EE:  MOVLB  0
093F0:  CALL   56DA
093F4:  MOVFF  03,744
093F8:  MOVFF  02,743
093FC:  MOVFF  01,742
09400:  MOVFF  00,741
09404:  MOVLB  7
09406:  DECFSZ x3F,F
09408:  BRA    9326
0940A:  MOVLB  0
0940C:  RETURN 0
.................... 
.................... #list
.................... 
.................... 
.................... #device ADC=10
.................... 
.................... //!#FUSES WDT                      //Watch Dog Timer
.................... //!#FUSES WDT4096                  //Watch Dog Timer uses 1:4096 Postscale
.................... 
.................... #use delay(internal=64000000)
*
003CA:  MOVLW  07
003CC:  MOVWF  FEA
003CE:  MOVLW  01
003D0:  MOVWF  FE9
003D2:  MOVF   FEF,W
003D4:  BZ    03F2
003D6:  MOVLW  14
003D8:  MOVWF  01
003DA:  CLRF   00
003DC:  DECFSZ 00,F
003DE:  BRA    03DC
003E0:  DECFSZ 01,F
003E2:  BRA    03DA
003E4:  MOVLW  BF
003E6:  MOVWF  00
003E8:  DECFSZ 00,F
003EA:  BRA    03E8
003EC:  BRA    03EE
003EE:  DECFSZ FEF,F
003F0:  BRA    03D6
003F2:  RETURN 0
*
00746:  MOVLW  01
00748:  MOVLB  7
0074A:  SUBWF  x07,F
0074C:  BNC   0764
0074E:  MOVLW  07
00750:  MOVWF  FEA
00752:  MOVWF  FE9
00754:  MOVF   FEF,W
00756:  BZ    0764
00758:  MOVLW  04
0075A:  MOVWF  00
0075C:  DECFSZ 00,F
0075E:  BRA    075C
00760:  DECFSZ FEF,F
00762:  BRA    0758
00764:  MOVLB  0
00766:  RETURN 0
.................... #define baudRate 128000
.................... #define numChannels 2
.................... 
.................... #use rs232(ICD, DISABLE_INTS, stream=ICD_STREAM)
*
000CA:  BSF    F88.6
000CC:  BTFSC  F8D.6
000CE:  BRA    00CC
000D0:  MOVLW  08
000D2:  MOVWF  00
000D4:  MOVLB  7
000D6:  CLRF   x75
000D8:  MOVFF  FF2,776
000DC:  BCF    FF2.7
000DE:  BSF    00.7
000E0:  BRA    00FE
000E2:  BCF    00.7
000E4:  BRA    00FE
000E6:  BCF    FD8.0
000E8:  BTFSC  F8D.6
000EA:  BSF    FD8.0
000EC:  RRCF   x75,F
000EE:  BSF    00.6
000F0:  BRA    00FE
000F2:  BCF    00.6
000F4:  DECFSZ 00,F
000F6:  BRA    00E6
000F8:  MOVFF  775,01
000FC:  BRA    0116
000FE:  MOVLW  84
00100:  BTFSC  00.7
00102:  MOVLW  24
00104:  MOVWF  01
00106:  DECFSZ 01,F
00108:  BRA    0106
0010A:  BRA    010C
0010C:  BTFSC  00.7
0010E:  BRA    00E2
00110:  BTFSC  00.6
00112:  BRA    00F2
00114:  BRA    00E6
00116:  BTFSC  x76.7
00118:  BSF    FF2.7
0011A:  MOVLB  0
0011C:  GOTO   0142 (RETURN)
*
059DC:  MOVFF  FF2,03
059E0:  BCF    FF2.7
059E2:  BCF    F88.7
059E4:  BCF    F83.7
059E6:  MOVLW  08
059E8:  MOVWF  01
059EA:  BRA    59EC
059EC:  NOP   
059EE:  BSF    01.7
059F0:  BRA    5A12
059F2:  BCF    01.7
059F4:  MOVLB  6
059F6:  RRCF   xFD,F
059F8:  MOVLB  0
059FA:  BTFSC  FD8.0
059FC:  BSF    F83.7
059FE:  BTFSS  FD8.0
05A00:  BCF    F83.7
05A02:  BSF    01.6
05A04:  BRA    5A12
05A06:  BCF    01.6
05A08:  DECFSZ 01,F
05A0A:  BRA    59F4
05A0C:  BRA    5A0E
05A0E:  NOP   
05A10:  BSF    F83.7
05A12:  MOVLW  84
05A14:  MOVWF  FE9
05A16:  DECFSZ FE9,F
05A18:  BRA    5A16
05A1A:  BRA    5A1C
05A1C:  NOP   
05A1E:  BTFSC  01.7
05A20:  BRA    59F2
05A22:  BTFSC  01.6
05A24:  BRA    5A06
05A26:  BTFSC  03.7
05A28:  BSF    FF2.7
05A2A:  RETURN 0
.................... 
.................... #define version  "20251208" // SW Version
.................... #define serialID "0000"     // Unique Serial ID
.................... #define magPP 1             // Magnetoresistive Sensor Pole Pitch in mm   
.................... #define gainLvl 16          // 1, 2, 4, 8, 16, 32, 64, 128
.................... 
.................... 
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B7,PIN_B6,PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
*
003F4:  MOVLW  CF
003F6:  MOVWF  F87
003F8:  CLRF   F82
....................    output_b(portB_reset);
003FA:  MOVLW  04
003FC:  MOVWF  F88
003FE:  CLRF   F83
....................    output_c(portC_reset);
00400:  MOVLW  93
00402:  MOVWF  F89
00404:  CLRF   F84
....................    output_d(portD_reset);
00406:  MOVLW  1F
00408:  MOVWF  F8A
0040A:  CLRF   F85
....................    output_e(portE_reset);
0040C:  BCF    F8B.0
0040E:  BCF    F8B.1
00410:  BCF    F8B.2
00412:  BCF    F8B.3
00414:  CLRF   F86
....................    
....................    port_a_pullups(portA_pullups);
00416:  MOVLB  F
00418:  SETF   x0B
....................    port_b_pullups(portB_pullups);
0041A:  CLRF   x13
....................    port_c_pullups(portC_pullups);
0041C:  CLRF   x1B
....................    port_d_pullups(portD_pullups);
0041E:  SETF   x20
....................    port_e_pullups(portE_pullups);
00420:  CLRF   x28
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
00422:  MOVLW  40
00424:  MOVWF  x0C
00426:  CLRF   x14
00428:  MOVLW  03
0042A:  MOVWF  x1C
0042C:  MOVLW  0F
0042E:  MOVWF  x21
00430:  CLRF   x29
00432:  MOVLB  0
00434:  GOTO   A716 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
*
05B0A:  MOVFF  742,FEA
05B0E:  MOVLB  7
05B10:  MOVFF  741,FE9
05B14:  MOVFF  FEF,745
05B18:  MOVFF  744,FEA
05B1C:  MOVFF  743,FE9
05B20:  MOVF   FEF,W
05B22:  SUBWF  x45,W
05B24:  BNZ   5B54
....................       if (*s1 == '\0')
05B26:  MOVFF  742,03
05B2A:  MOVFF  741,FE9
05B2E:  MOVFF  03,FEA
05B32:  MOVF   FEF,F
05B34:  BNZ   5B3C
....................          return(0);
05B36:  MOVLW  00
05B38:  MOVWF  01
05B3A:  BRA    5B7E
05B3C:  MOVFF  742,03
05B40:  MOVF   x41,W
05B42:  INCF   x41,F
05B44:  BTFSC  FD8.2
05B46:  INCF   x42,F
05B48:  INCF   x43,F
05B4A:  BTFSC  FD8.2
05B4C:  INCF   x44,F
05B4E:  MOVLB  0
05B50:  BRA    5B0A
05B52:  MOVLB  7
....................    return((*s1 < *s2) ? -1: 1);
05B54:  MOVFF  742,03
05B58:  MOVFF  741,FE9
05B5C:  MOVFF  03,FEA
05B60:  MOVFF  FEF,745
05B64:  MOVFF  744,03
05B68:  MOVFF  743,FE9
05B6C:  MOVFF  03,FEA
05B70:  MOVF   FEF,W
05B72:  SUBWF  x45,W
05B74:  BC    5B7A
05B76:  MOVLW  FF
05B78:  BRA    5B7C
05B7A:  MOVLW  01
05B7C:  MOVWF  01
05B7E:  MOVLB  0
05B80:  RETURN 0
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
*
05C7A:  MOVFF  768,76B
....................    for(su=s;0<n;++su,--n)
05C7E:  MOVFF  767,76D
05C82:  MOVFF  766,76C
05C86:  MOVLB  7
05C88:  MOVF   x6A,F
05C8A:  BNZ   5C92
05C8C:  MOVF   x69,W
05C8E:  SUBLW  00
05C90:  BC    5CBA
....................       if(*su==uc)
05C92:  MOVFF  76D,FEA
05C96:  MOVFF  76C,FE9
05C9A:  MOVF   x6B,W
05C9C:  SUBWF  FEF,W
05C9E:  BNZ   5CAA
....................       return su;
05CA0:  MOVFF  76C,01
05CA4:  MOVFF  76D,02
05CA8:  BRA    5CC0
05CAA:  INCF   x6C,F
05CAC:  BTFSC  FD8.2
05CAE:  INCF   x6D,F
05CB0:  MOVF   x69,W
05CB2:  BTFSC  FD8.2
05CB4:  DECF   x6A,F
05CB6:  DECF   x69,F
05CB8:  BRA    5C88
....................    return NULL;
05CBA:  MOVLW  00
05CBC:  MOVWF  01
05CBE:  MOVWF  02
05CC0:  MOVLB  0
05CC2:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
*
05598:  MOVFF  742,744
0559C:  MOVFF  741,743
055A0:  MOVFF  744,FEA
055A4:  MOVLB  7
055A6:  MOVFF  743,FE9
055AA:  MOVF   FEF,F
055AC:  BZ    55BA
055AE:  INCF   x43,F
055B0:  BTFSC  FD8.2
055B2:  INCF   x44,F
055B4:  MOVLB  0
055B6:  BRA    55A0
055B8:  MOVLB  7
....................    return(sc - s);
055BA:  MOVF   x41,W
055BC:  SUBWF  x43,W
055BE:  MOVWF  00
055C0:  MOVF   x42,W
055C2:  SUBWFB x44,W
055C4:  MOVWF  03
055C6:  MOVFF  00,01
055CA:  MOVWF  02
055CC:  MOVLB  0
055CE:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
*
06E00:  MOVLB  7
06E02:  CLRF   x1B
06E04:  CLRF   x1A
06E06:  CLRF   x19
06E08:  MOVLW  7F
06E0A:  MOVWF  x18
06E0C:  CLRF   x1F
06E0E:  CLRF   x1E
06E10:  CLRF   x1D
06E12:  CLRF   x1C
06E14:  BSF    x20.0
06E16:  BCF    x20.1
06E18:  BCF    x20.2
06E1A:  CLRF   x22
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
06E1C:  MOVF   x14,W
06E1E:  IORWF  x15,W
06E20:  BNZ   6E2C
....................       return 0;
06E22:  CLRF   00
06E24:  CLRF   01
06E26:  CLRF   02
06E28:  CLRF   03
06E2A:  BRA    7056
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
06E2C:  MOVF   x22,W
06E2E:  INCF   x22,F
06E30:  ADDWF  x14,W
06E32:  MOVWF  FE9
06E34:  MOVLW  00
06E36:  ADDWFC x15,W
06E38:  MOVWF  FEA
06E3A:  MOVFF  FEF,721
06E3E:  MOVF   x21,F
06E40:  BTFSC  FD8.2
06E42:  BRA    6FDA
....................    {
....................       if (skip && !isspace(c))
06E44:  BTFSS  x20.0
06E46:  BRA    6E66
06E48:  MOVF   x21,W
06E4A:  SUBLW  20
06E4C:  BZ    6E66
....................       {
....................          skip = 0;
06E4E:  BCF    x20.0
....................          if (c == '+')
06E50:  MOVF   x21,W
06E52:  SUBLW  2B
06E54:  BNZ   6E5C
....................          {
....................             sign = 0;
06E56:  BCF    x20.1
....................             continue;
06E58:  BRA    6FC2
....................          }            
06E5A:  BRA    6E66
....................          else if (c == '-')
06E5C:  MOVF   x21,W
06E5E:  SUBLW  2D
06E60:  BNZ   6E66
....................          {
....................             sign = 1;
06E62:  BSF    x20.1
....................             continue;
06E64:  BRA    6FC2
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
06E66:  BTFSC  x20.0
06E68:  BRA    6E78
06E6A:  MOVF   x21,W
06E6C:  SUBLW  2E
06E6E:  BNZ   6E78
06E70:  BTFSC  x20.2
06E72:  BRA    6E78
....................          point = 1;
06E74:  BSF    x20.2
06E76:  BRA    6FC2
....................       else if (!skip && isdigit(c))
06E78:  BTFSC  x20.0
06E7A:  BRA    6FBC
06E7C:  MOVF   x21,W
06E7E:  SUBLW  2F
06E80:  BTFSC  FD8.0
06E82:  BRA    6FBC
06E84:  MOVF   x21,W
06E86:  SUBLW  39
06E88:  BTFSS  FD8.0
06E8A:  BRA    6FBC
....................       {
....................          c -= '0';
06E8C:  MOVLW  30
06E8E:  SUBWF  x21,F
....................          if (point)
06E90:  BTFSS  x20.2
06E92:  BRA    6F42
....................          {
....................             pow10 = pow10 * 10.0;
06E94:  MOVFF  71B,753
06E98:  MOVFF  71A,752
06E9C:  MOVFF  719,751
06EA0:  MOVFF  718,750
06EA4:  CLRF   x57
06EA6:  CLRF   x56
06EA8:  MOVLW  20
06EAA:  MOVWF  x55
06EAC:  MOVLW  82
06EAE:  MOVWF  x54
06EB0:  MOVLB  0
06EB2:  CALL   0DA0
06EB6:  MOVFF  03,71B
06EBA:  MOVFF  02,71A
06EBE:  MOVFF  01,719
06EC2:  MOVFF  00,718
....................             result += (float)c / pow10;   
06EC6:  MOVLB  7
06EC8:  CLRF   x4B
06ECA:  MOVFF  721,74A
06ECE:  MOVLB  0
06ED0:  CALL   0D6A
06ED4:  MOVFF  03,726
06ED8:  MOVFF  02,725
06EDC:  MOVFF  01,724
06EE0:  MOVFF  00,723
06EE4:  MOVFF  03,742
06EE8:  MOVFF  02,741
06EEC:  MOVFF  01,740
06EF0:  MOVFF  00,73F
06EF4:  MOVFF  71B,746
06EF8:  MOVFF  71A,745
06EFC:  MOVFF  719,744
06F00:  MOVFF  718,743
06F04:  CALL   1DA6
06F08:  BCF    FD8.1
06F0A:  MOVFF  71F,74D
06F0E:  MOVFF  71E,74C
06F12:  MOVFF  71D,74B
06F16:  MOVFF  71C,74A
06F1A:  MOVFF  03,751
06F1E:  MOVFF  02,750
06F22:  MOVFF  01,74F
06F26:  MOVFF  00,74E
06F2A:  CALL   0E96
06F2E:  MOVFF  03,71F
06F32:  MOVFF  02,71E
06F36:  MOVFF  01,71D
06F3A:  MOVFF  00,71C
....................          }
06F3E:  BRA    6FB8
06F40:  MOVLB  7
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
06F42:  CLRF   x53
06F44:  CLRF   x52
06F46:  MOVLW  20
06F48:  MOVWF  x51
06F4A:  MOVLW  82
06F4C:  MOVWF  x50
06F4E:  MOVFF  71F,757
06F52:  MOVFF  71E,756
06F56:  MOVFF  71D,755
06F5A:  MOVFF  71C,754
06F5E:  MOVLB  0
06F60:  CALL   0DA0
06F64:  MOVFF  03,726
06F68:  MOVFF  02,725
06F6C:  MOVFF  01,724
06F70:  MOVFF  00,723
06F74:  MOVLB  7
06F76:  CLRF   x4B
06F78:  MOVFF  721,74A
06F7C:  MOVLB  0
06F7E:  CALL   0D6A
06F82:  BCF    FD8.1
06F84:  MOVFF  726,74D
06F88:  MOVFF  725,74C
06F8C:  MOVFF  724,74B
06F90:  MOVFF  723,74A
06F94:  MOVFF  03,751
06F98:  MOVFF  02,750
06F9C:  MOVFF  01,74F
06FA0:  MOVFF  00,74E
06FA4:  CALL   0E96
06FA8:  MOVFF  03,71F
06FAC:  MOVFF  02,71E
06FB0:  MOVFF  01,71D
06FB4:  MOVFF  00,71C
....................          }
....................       }
06FB8:  BRA    6FC4
06FBA:  MOVLB  7
....................       else if (!skip)
06FBC:  BTFSC  x20.0
06FBE:  BRA    6FC2
....................          break;
06FC0:  BRA    6FDA
06FC2:  MOVLB  0
06FC4:  MOVLB  7
06FC6:  MOVF   x22,W
06FC8:  INCF   x22,F
06FCA:  ADDWF  x14,W
06FCC:  MOVWF  FE9
06FCE:  MOVLW  00
06FD0:  ADDWFC x15,W
06FD2:  MOVWF  FEA
06FD4:  MOVFF  FEF,721
06FD8:  BRA    6E3E
....................    }
.................... 
....................    if (sign)
06FDA:  BTFSS  x20.1
06FDC:  BRA    7012
....................       result = -1*result;
06FDE:  CLRF   x53
06FE0:  CLRF   x52
06FE2:  MOVLW  80
06FE4:  MOVWF  x51
06FE6:  MOVLW  7F
06FE8:  MOVWF  x50
06FEA:  MOVFF  71F,757
06FEE:  MOVFF  71E,756
06FF2:  MOVFF  71D,755
06FF6:  MOVFF  71C,754
06FFA:  MOVLB  0
06FFC:  CALL   0DA0
07000:  MOVFF  03,71F
07004:  MOVFF  02,71E
07008:  MOVFF  01,71D
0700C:  MOVFF  00,71C
07010:  MOVLB  7
....................       
....................    if(endptr)
07012:  MOVF   x16,W
07014:  IORWF  x17,W
07016:  BZ    7046
....................    {
....................       if (ptr) {
07018:  MOVF   x22,F
0701A:  BZ    7034
....................          ptr--;
0701C:  DECF   x22,F
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
0701E:  MOVFF  717,FEA
07022:  MOVFF  716,FE9
07026:  MOVF   x22,W
07028:  ADDWF  x14,W
0702A:  MOVWF  FEF
0702C:  MOVLW  00
0702E:  ADDWFC x15,W
07030:  MOVWF  FEC
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
07032:  BRA    7046
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
07034:  MOVFF  717,FEA
07038:  MOVFF  716,FE9
0703C:  MOVFF  715,FEC
07040:  MOVF   FED,F
07042:  MOVFF  714,FEF
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
07046:  MOVFF  71C,00
0704A:  MOVFF  71D,01
0704E:  MOVFF  71E,02
07052:  MOVFF  71F,03
07056:  MOVLB  0
07058:  RETURN 0
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
*
05D1A:  MOVLB  7
05D1C:  CLRF   x3F
05D1E:  CLRF   x3E
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
05D20:  MOVLW  30
05D22:  MOVWF  x41
05D24:  MOVLW  31
05D26:  MOVWF  x42
05D28:  MOVLW  32
05D2A:  MOVWF  x43
05D2C:  MOVLW  33
05D2E:  MOVWF  x44
05D30:  MOVLW  34
05D32:  MOVWF  x45
05D34:  MOVLW  35
05D36:  MOVWF  x46
05D38:  MOVLW  36
05D3A:  MOVWF  x47
05D3C:  MOVLW  37
05D3E:  MOVWF  x48
05D40:  MOVLW  38
05D42:  MOVWF  x49
05D44:  MOVLW  39
05D46:  MOVWF  x4A
05D48:  MOVLW  61
05D4A:  MOVWF  x4B
05D4C:  MOVLW  62
05D4E:  MOVWF  x4C
05D50:  MOVLW  63
05D52:  MOVWF  x4D
05D54:  MOVLW  64
05D56:  MOVWF  x4E
05D58:  MOVLW  65
05D5A:  MOVWF  x4F
05D5C:  MOVLW  66
05D5E:  MOVWF  x50
05D60:  MOVLW  67
05D62:  MOVWF  x51
05D64:  MOVLW  68
05D66:  MOVWF  x52
05D68:  MOVLW  69
05D6A:  MOVWF  x53
05D6C:  MOVLW  6A
05D6E:  MOVWF  x54
05D70:  MOVLW  6B
05D72:  MOVWF  x55
05D74:  MOVLW  6C
05D76:  MOVWF  x56
05D78:  MOVLW  6D
05D7A:  MOVWF  x57
05D7C:  MOVLW  6E
05D7E:  MOVWF  x58
05D80:  MOVLW  6F
05D82:  MOVWF  x59
05D84:  MOVLW  70
05D86:  MOVWF  x5A
05D88:  MOVLW  71
05D8A:  MOVWF  x5B
05D8C:  MOVLW  73
05D8E:  MOVWF  x5C
05D90:  MOVLW  74
05D92:  MOVWF  x5D
05D94:  MOVLW  75
05D96:  MOVWF  x5E
05D98:  MOVLW  76
05D9A:  MOVWF  x5F
05D9C:  MOVLW  77
05D9E:  MOVWF  x60
05DA0:  MOVLW  78
05DA2:  MOVWF  x61
05DA4:  MOVLW  79
05DA6:  MOVWF  x62
05DA8:  MOVLW  7A
05DAA:  MOVWF  x63
05DAC:  CLRF   x64
....................    for(sc=s;isspace(*sc);++sc);
05DAE:  MOVFF  734,739
05DB2:  MOVFF  733,738
05DB6:  MOVFF  739,FEA
05DBA:  MOVFF  738,FE9
05DBE:  MOVF   FEF,W
05DC0:  SUBLW  20
05DC2:  BNZ   5DCC
05DC4:  INCF   x38,F
05DC6:  BTFSC  FD8.2
05DC8:  INCF   x39,F
05DCA:  BRA    5DB6
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
05DCC:  MOVFF  739,03
05DD0:  MOVFF  738,FE9
05DD4:  MOVFF  03,FEA
05DD8:  MOVF   FEF,W
05DDA:  SUBLW  2D
05DDC:  BZ    5DEC
05DDE:  MOVFF  739,FEA
05DE2:  MOVFF  738,FE9
05DE6:  MOVF   FEF,W
05DE8:  SUBLW  2B
05DEA:  BNZ   5DFE
05DEC:  MOVFF  739,FEA
05DF0:  MOVF   x38,W
05DF2:  INCF   x38,F
05DF4:  BTFSC  FD8.2
05DF6:  INCF   x39,F
05DF8:  MOVWF  FE9
05DFA:  MOVF   FEF,W
05DFC:  BRA    5E00
05DFE:  MOVLW  2B
05E00:  MOVWF  x40
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
05E02:  MOVF   x40,W
05E04:  SUBLW  2D
05E06:  BZ    5E1C
05E08:  BTFSC  x37.7
05E0A:  BRA    5E1C
05E0C:  DECFSZ x37,W
05E0E:  BRA    5E12
05E10:  BRA    5E1C
05E12:  BTFSC  x37.7
05E14:  BRA    5E20
05E16:  MOVF   x37,W
05E18:  SUBLW  24
05E1A:  BC    5E20
....................    goto StrtoulGO;
05E1C:  BRA    6028
05E1E:  BRA    5F18
.................... 
....................    else if (base)
05E20:  MOVF   x37,F
05E22:  BZ    5EB0
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
05E24:  MOVF   x37,W
05E26:  SUBLW  10
05E28:  BNZ   5E64
05E2A:  MOVFF  739,FEA
05E2E:  MOVFF  738,FE9
05E32:  MOVF   FEF,W
05E34:  SUBLW  30
05E36:  BNZ   5E64
05E38:  MOVLW  01
05E3A:  ADDWF  x38,W
05E3C:  MOVWF  FE9
05E3E:  MOVLW  00
05E40:  ADDWFC x39,W
05E42:  MOVWF  FEA
05E44:  MOVF   FEF,W
05E46:  SUBLW  78
05E48:  BZ    5E5C
05E4A:  MOVLW  01
05E4C:  ADDWF  x38,W
05E4E:  MOVWF  FE9
05E50:  MOVLW  00
05E52:  ADDWFC x39,W
05E54:  MOVWF  FEA
05E56:  MOVF   FEF,W
05E58:  SUBLW  58
05E5A:  BNZ   5E64
....................          sc+=2;
05E5C:  MOVLW  02
05E5E:  ADDWF  x38,F
05E60:  MOVLW  00
05E62:  ADDWFC x39,F
....................       if(base==8 && *sc =='0')
05E64:  MOVF   x37,W
05E66:  SUBLW  08
05E68:  BNZ   5E80
05E6A:  MOVFF  739,FEA
05E6E:  MOVFF  738,FE9
05E72:  MOVF   FEF,W
05E74:  SUBLW  30
05E76:  BNZ   5E80
....................          sc+=1;
05E78:  MOVLW  01
05E7A:  ADDWF  x38,F
05E7C:  MOVLW  00
05E7E:  ADDWFC x39,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
05E80:  MOVF   x37,W
05E82:  SUBLW  02
05E84:  BNZ   5EAE
05E86:  MOVFF  739,FEA
05E8A:  MOVFF  738,FE9
05E8E:  MOVF   FEF,W
05E90:  SUBLW  30
05E92:  BNZ   5EAE
05E94:  MOVLW  01
05E96:  ADDWF  x38,W
05E98:  MOVWF  FE9
05E9A:  MOVLW  00
05E9C:  ADDWFC x39,W
05E9E:  MOVWF  FEA
05EA0:  MOVF   FEF,W
05EA2:  SUBLW  62
05EA4:  BNZ   5EAE
....................          sc+=2;
05EA6:  MOVLW  02
05EA8:  ADDWF  x38,F
05EAA:  MOVLW  00
05EAC:  ADDWFC x39,F
.................... 
....................    }
05EAE:  BRA    5F18
....................    else if(*sc!='0') // base is 0, find base
05EB0:  MOVFF  739,FEA
05EB4:  MOVFF  738,FE9
05EB8:  MOVF   FEF,W
05EBA:  SUBLW  30
05EBC:  BZ    5EC4
....................       base=10;
05EBE:  MOVLW  0A
05EC0:  MOVWF  x37
05EC2:  BRA    5F18
....................    else if (sc[1]=='x' || sc[1]=='X')
05EC4:  MOVLW  01
05EC6:  ADDWF  x38,W
05EC8:  MOVWF  FE9
05ECA:  MOVLW  00
05ECC:  ADDWFC x39,W
05ECE:  MOVWF  FEA
05ED0:  MOVF   FEF,W
05ED2:  SUBLW  78
05ED4:  BZ    5EE8
05ED6:  MOVLW  01
05ED8:  ADDWF  x38,W
05EDA:  MOVWF  FE9
05EDC:  MOVLW  00
05EDE:  ADDWFC x39,W
05EE0:  MOVWF  FEA
05EE2:  MOVF   FEF,W
05EE4:  SUBLW  58
05EE6:  BNZ   5EF6
....................       base =16,sc+=2;
05EE8:  MOVLW  10
05EEA:  MOVWF  x37
05EEC:  MOVLW  02
05EEE:  ADDWF  x38,F
05EF0:  MOVLW  00
05EF2:  ADDWFC x39,F
05EF4:  BRA    5F18
....................    else if(sc[1]=='b')
05EF6:  MOVLW  01
05EF8:  ADDWF  x38,W
05EFA:  MOVWF  FE9
05EFC:  MOVLW  00
05EFE:  ADDWFC x39,W
05F00:  MOVWF  FEA
05F02:  MOVF   FEF,W
05F04:  SUBLW  62
05F06:  BNZ   5F14
....................       base=2,sc+=2;
05F08:  MOVLW  02
05F0A:  MOVWF  x37
05F0C:  ADDWF  x38,F
05F0E:  MOVLW  00
05F10:  ADDWFC x39,F
05F12:  BRA    5F18
....................    else
....................       base=8;
05F14:  MOVLW  08
05F16:  MOVWF  x37
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
05F18:  MOVFF  739,73B
05F1C:  MOVFF  738,73A
05F20:  MOVFF  739,FEA
05F24:  MOVFF  738,FE9
05F28:  MOVF   FEF,W
05F2A:  SUBLW  30
05F2C:  BNZ   5F36
05F2E:  INCF   x38,F
05F30:  BTFSC  FD8.2
05F32:  INCF   x39,F
05F34:  BRA    5F20
....................    sd=memchr(digits,tolower(*sc),base);
05F36:  MOVFF  739,03
05F3A:  MOVFF  738,FE9
05F3E:  MOVFF  03,FEA
05F42:  MOVFF  FEF,765
05F46:  MOVF   x65,W
05F48:  SUBLW  40
05F4A:  BC    5F58
05F4C:  MOVF   x65,W
05F4E:  SUBLW  5A
05F50:  BNC   5F58
05F52:  MOVF   x65,W
05F54:  IORLW  20
05F56:  BRA    5F5A
05F58:  MOVF   x65,W
05F5A:  MOVWF  x65
05F5C:  MOVLW  07
05F5E:  MOVWF  x67
05F60:  MOVLW  41
05F62:  MOVWF  x66
05F64:  MOVFF  765,768
05F68:  CLRF   x6A
05F6A:  MOVFF  737,769
05F6E:  BTFSC  x69.7
05F70:  DECF   x6A,F
05F72:  MOVLB  0
05F74:  RCALL  5C7A
05F76:  MOVFF  02,73D
05F7A:  MOVFF  01,73C
....................    for(; sd!=0; )
05F7E:  MOVLB  7
05F80:  MOVF   x3C,F
05F82:  BNZ   5F88
05F84:  MOVF   x3D,F
05F86:  BZ    601C
....................    {
....................       x=x*base+(int16)(sd-digits);
05F88:  CLRF   03
05F8A:  MOVF   x37,W
05F8C:  MOVWF  00
05F8E:  BTFSC  FE8.7
05F90:  DECF   03,F
05F92:  MOVWF  x65
05F94:  MOVFF  03,766
05F98:  MOVFF  73F,768
05F9C:  MOVFF  73E,767
05FA0:  MOVFF  03,76A
05FA4:  MOVWF  x69
05FA6:  MOVLB  0
05FA8:  BRA    5CC4
05FAA:  MOVFF  01,765
05FAE:  MOVLW  41
05FB0:  MOVLB  7
05FB2:  SUBWF  x3C,W
05FB4:  MOVWF  00
05FB6:  MOVLW  07
05FB8:  SUBWFB x3D,W
05FBA:  MOVWF  03
05FBC:  MOVF   00,W
05FBE:  ADDWF  01,W
05FC0:  MOVWF  01
05FC2:  MOVF   02,W
05FC4:  ADDWFC 03,F
05FC6:  MOVFF  01,73E
05FCA:  MOVFF  03,73F
....................       ++sc;
05FCE:  INCF   x38,F
05FD0:  BTFSC  FD8.2
05FD2:  INCF   x39,F
....................       sd=memchr(digits,tolower(*sc),base);
05FD4:  MOVFF  739,FEA
05FD8:  MOVFF  738,FE9
05FDC:  MOVFF  FEF,765
05FE0:  MOVF   x65,W
05FE2:  SUBLW  40
05FE4:  BC    5FF2
05FE6:  MOVF   x65,W
05FE8:  SUBLW  5A
05FEA:  BNC   5FF2
05FEC:  MOVF   x65,W
05FEE:  IORLW  20
05FF0:  BRA    5FF4
05FF2:  MOVF   x65,W
05FF4:  MOVWF  x65
05FF6:  MOVLW  07
05FF8:  MOVWF  x67
05FFA:  MOVLW  41
05FFC:  MOVWF  x66
05FFE:  MOVFF  765,768
06002:  CLRF   x6A
06004:  MOVFF  737,769
06008:  BTFSC  x69.7
0600A:  DECF   x6A,F
0600C:  MOVLB  0
0600E:  RCALL  5C7A
06010:  MOVFF  02,73D
06014:  MOVFF  01,73C
06018:  BRA    5F7E
0601A:  MOVLB  7
....................    }
....................    if(s1==sc)
0601C:  MOVF   x38,W
0601E:  SUBWF  x3A,W
06020:  BNZ   604A
06022:  MOVF   x39,W
06024:  SUBWF  x3B,W
06026:  BNZ   604A
....................    {
....................    StrtoulGO:
....................       if (endptr)
06028:  MOVLB  7
0602A:  MOVF   x35,W
0602C:  IORWF  x36,W
0602E:  BZ    6042
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
06030:  MOVFF  736,FEA
06034:  MOVFF  735,FE9
06038:  MOVFF  734,FEC
0603C:  MOVF   FED,F
0603E:  MOVFF  733,FEF
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
06042:  MOVLW  00
06044:  MOVWF  01
06046:  MOVWF  02
06048:  BRA    606A
....................    }
....................    if (endptr)
0604A:  MOVF   x35,W
0604C:  IORWF  x36,W
0604E:  BZ    6062
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
06050:  MOVFF  736,FEA
06054:  MOVFF  735,FE9
06058:  MOVFF  739,FEC
0605C:  MOVF   FED,F
0605E:  MOVFF  738,FEF
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
06062:  MOVFF  73E,01
06066:  MOVFF  73F,02
0606A:  MOVLB  0
0606C:  RETURN 0
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................     float kP;      // proportional gain
....................     float kI;      // integral gain
....................     float kD;      // derivative gain
....................     float SP;      // set point-- desired output
....................     float PV;      // process variable-- measured output
....................     float PVold;   // oldPV value  
....................     float CV;      // control variable-- output -- 0 to 100%
....................     float I;       // integral value
....................     float maxSP;   // Max setpoint in microns
....................     float minSP;   // Min setpoint in microns
.................... }PID[2] = {
....................    //  P     I     D
....................    //0.01    0.3   0.1
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}, 
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}
....................     };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... //!#define op_upper_bound 63  // CRYO
.................... //!#define op_lower_bound -63 // CRYO
.................... 
.................... #define op_upper_bound 63  // AMBIENT 
.................... #define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    BOOLEAN homeFlag;       // Flag to trigger the homing routine
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,FALSE},
....................    {0,0,0,0,0,0,0,0,0,0,FALSE}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................     BOOLEAN invV;
....................     unsigned int16 ipVal;
....................     float opPcnt;
....................    
.................... }dacVals[2] = 
.................... {
....................     {FALSE,0,0},
....................     {FALSE,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
*
0049A:  MOVLB  7
0049C:  CLRF   x00
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
0049E:  CLRF   x00
004A0:  MOVLB  6
004A2:  MOVF   xFF,W
004A4:  MOVLB  7
004A6:  SUBWF  x00,W
004A8:  BC    050A
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
004AA:  MOVF   x00,W
004AC:  MOVLB  6
004AE:  ADDWF  xFD,W
004B0:  MOVLB  7
004B2:  MOVWF  x01
004B4:  MOVLW  00
004B6:  MOVLB  6
004B8:  ADDWFC xFE,W
004BA:  MOVLB  7
004BC:  MOVWF  x02
004BE:  MOVF   x00,W
004C0:  MOVLB  6
004C2:  ADDWF  xFB,W
004C4:  MOVWF  01
004C6:  MOVLW  00
004C8:  ADDWFC xFC,W
004CA:  MOVWF  03
004CC:  MOVF   01,W
004CE:  MOVWF  FE9
004D0:  MOVFF  03,FEA
004D4:  MOVFF  FEF,703
004D8:  BSF    F7F.7
004DA:  MOVF   FF2,W
004DC:  MOVWF  00
004DE:  BCF    FF2.7
004E0:  MOVFF  702,F7A
004E4:  MOVFF  701,F79
004E8:  MOVLW  31
004EA:  MOVWF  F7B
004EC:  MOVFF  703,F7C
004F0:  MOVLB  F
004F2:  MOVLW  55
004F4:  MOVWF  F81
004F6:  MOVLW  AA
004F8:  MOVWF  F81
004FA:  BSF    F80.4
004FC:  BTFSC  F80.4
004FE:  BRA    04FC
00500:  MOVF   00,W
00502:  IORWF  FF2,F
00504:  MOVLB  7
00506:  INCF   x00,F
00508:  BRA    04A0
....................    }
0050A:  MOVLB  0
0050C:  RETURN 0
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
*
00438:  MOVLB  7
0043A:  CLRF   x00
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
0043C:  CLRF   x00
0043E:  MOVLB  6
00440:  MOVF   xFF,W
00442:  MOVLB  7
00444:  SUBWF  x00,W
00446:  BC    0496
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
00448:  MOVF   x00,W
0044A:  MOVLB  6
0044C:  ADDWF  xFB,W
0044E:  MOVWF  01
00450:  MOVLW  00
00452:  ADDWFC xFC,W
00454:  MOVWF  03
00456:  MOVF   01,W
00458:  MOVWF  FE9
0045A:  MOVFF  03,FEA
0045E:  MOVLB  7
00460:  MOVF   x00,W
00462:  MOVLB  6
00464:  ADDWF  xFD,W
00466:  MOVLB  7
00468:  MOVWF  x03
0046A:  MOVLW  00
0046C:  MOVLB  6
0046E:  ADDWFC xFE,W
00470:  MOVLB  7
00472:  MOVWF  x04
00474:  BSF    F7F.7
00476:  MOVFF  FF2,705
0047A:  BCF    FF2.7
0047C:  MOVFF  704,F7A
00480:  MOVFF  703,F79
00484:  MOVLW  31
00486:  MOVWF  F7B
00488:  BSF    F80.0
0048A:  MOVF   F7C,W
0048C:  BTFSC  x05.7
0048E:  BSF    FF2.7
00490:  MOVWF  FEF
00492:  INCF   x00,F
00494:  BRA    043E
....................    }
00496:  MOVLB  0
00498:  RETURN 0
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
*
0050E:  MOVLB  6
00510:  CLRF   xFC
00512:  MOVLW  20
00514:  MOVWF  xFB
00516:  CLRF   xFE
00518:  CLRF   xFD
0051A:  MOVLW  80
0051C:  MOVWF  xFF
0051E:  MOVLB  0
00520:  RCALL  049A
....................    delay_ms(1);
00522:  MOVLW  01
00524:  MOVLB  7
00526:  MOVWF  x01
00528:  MOVLB  0
0052A:  RCALL  03CA
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
0052C:  MOVLB  6
0052E:  CLRF   xFC
00530:  MOVLW  70
00532:  MOVWF  xFB
00534:  CLRF   xFE
00536:  MOVLW  80
00538:  MOVWF  xFD
0053A:  MOVLW  02
0053C:  MOVWF  xFF
0053E:  MOVLB  0
00540:  RCALL  049A
....................    delay_ms(1);
00542:  MOVLW  01
00544:  MOVLB  7
00546:  MOVWF  x01
00548:  MOVLB  0
0054A:  RCALL  03CA
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
0054C:  MOVLB  6
0054E:  CLRF   xFC
00550:  MOVLW  71
00552:  MOVWF  xFB
00554:  CLRF   xFE
00556:  MOVLW  90
00558:  MOVWF  xFD
0055A:  MOVLW  02
0055C:  MOVWF  xFF
0055E:  MOVLB  0
00560:  RCALL  049A
....................    delay_ms(1);
00562:  MOVLW  01
00564:  MOVLB  7
00566:  MOVWF  x01
00568:  MOVLB  0
0056A:  RCALL  03CA
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
0056C:  MOVLB  6
0056E:  CLRF   xFC
00570:  MOVLW  72
00572:  MOVWF  xFB
00574:  CLRF   xFE
00576:  MOVLW  A0
00578:  MOVWF  xFD
0057A:  MOVLW  20
0057C:  MOVWF  xFF
0057E:  MOVLB  0
00580:  RCALL  049A
....................    delay_ms(1);
00582:  MOVLW  01
00584:  MOVLB  7
00586:  MOVWF  x01
00588:  MOVLB  0
0058A:  RCALL  03CA
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
0058C:  MOVLB  6
0058E:  CLRF   xFC
00590:  MOVLW  92
00592:  MOVWF  xFB
00594:  CLRF   xFE
00596:  MOVLW  C0
00598:  MOVWF  xFD
0059A:  MOVLW  30
0059C:  MOVWF  xFF
0059E:  MOVLB  0
005A0:  RCALL  049A
....................    delay_ms(1);
005A2:  MOVLW  01
005A4:  MOVLB  7
005A6:  MOVWF  x01
005A8:  MOVLB  0
005AA:  RCALL  03CA
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
005AC:  MOVLB  6
005AE:  CLRF   xFC
005B0:  MOVLW  C2
005B2:  MOVWF  xFB
005B4:  CLRF   xFE
005B6:  MOVLW  F0
005B8:  MOVWF  xFD
005BA:  MOVLW  38
005BC:  MOVWF  xFF
005BE:  MOVLB  0
005C0:  RCALL  049A
....................    delay_ms(1);
005C2:  MOVLW  01
005C4:  MOVLB  7
005C6:  MOVWF  x01
005C8:  MOVLB  0
005CA:  RCALL  03CA
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
005CC:  MOVLB  6
005CE:  CLRF   xFC
005D0:  MOVLW  FA
005D2:  MOVWF  xFB
005D4:  MOVLW  01
005D6:  MOVWF  xFE
005D8:  MOVLW  40
005DA:  MOVWF  xFD
005DC:  MOVLW  01
005DE:  MOVWF  xFF
005E0:  MOVLB  0
005E2:  RCALL  049A
....................    delay_ms(1);
005E4:  MOVLW  01
005E6:  MOVLB  7
005E8:  MOVWF  x01
005EA:  MOVLB  0
005EC:  RCALL  03CA
005EE:  GOTO   06BE (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
005F2:  MOVLB  6
005F4:  CLRF   xFC
005F6:  MOVLW  20
005F8:  MOVWF  xFB
005FA:  CLRF   xFE
005FC:  CLRF   xFD
005FE:  MOVLW  80
00600:  MOVWF  xFF
00602:  MOVLB  0
00604:  RCALL  0438
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
00606:  MOVLB  6
00608:  CLRF   xFC
0060A:  MOVLW  70
0060C:  MOVWF  xFB
0060E:  CLRF   xFE
00610:  MOVLW  80
00612:  MOVWF  xFD
00614:  MOVLW  02
00616:  MOVWF  xFF
00618:  MOVLB  0
0061A:  RCALL  0438
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
0061C:  MOVLB  6
0061E:  CLRF   xFC
00620:  MOVLW  71
00622:  MOVWF  xFB
00624:  CLRF   xFE
00626:  MOVLW  90
00628:  MOVWF  xFD
0062A:  MOVLW  02
0062C:  MOVWF  xFF
0062E:  MOVLB  0
00630:  RCALL  0438
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
00632:  MOVLB  6
00634:  CLRF   xFC
00636:  MOVLW  72
00638:  MOVWF  xFB
0063A:  CLRF   xFE
0063C:  MOVLW  A0
0063E:  MOVWF  xFD
00640:  MOVLW  20
00642:  MOVWF  xFF
00644:  MOVLB  0
00646:  RCALL  0438
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
00648:  MOVLB  6
0064A:  CLRF   xFC
0064C:  MOVLW  92
0064E:  MOVWF  xFB
00650:  CLRF   xFE
00652:  MOVLW  C0
00654:  MOVWF  xFD
00656:  MOVLW  30
00658:  MOVWF  xFF
0065A:  MOVLB  0
0065C:  RCALL  0438
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
0065E:  MOVLB  6
00660:  CLRF   xFC
00662:  MOVLW  C2
00664:  MOVWF  xFB
00666:  CLRF   xFE
00668:  MOVLW  F0
0066A:  MOVWF  xFD
0066C:  MOVLW  38
0066E:  MOVWF  xFF
00670:  MOVLB  0
00672:  RCALL  0438
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
00674:  MOVLB  6
00676:  CLRF   xFC
00678:  MOVLW  FA
0067A:  MOVWF  xFB
0067C:  MOVLW  01
0067E:  MOVWF  xFE
00680:  MOVLW  40
00682:  MOVWF  xFD
00684:  MOVLW  01
00686:  MOVWF  xFF
00688:  MOVLB  0
0068A:  RCALL  0438
0068C:  GOTO   06C2 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
00690:  MOVLB  6
00692:  CLRF   xFC
00694:  MOVLW  FA
00696:  MOVWF  xFB
00698:  MOVLW  01
0069A:  MOVWF  xFE
0069C:  MOVLW  40
0069E:  MOVWF  xFD
006A0:  MOVLW  01
006A2:  MOVWF  xFF
006A4:  MOVLB  0
006A6:  RCALL  0438
....................    delay_ms(1);
006A8:  MOVLW  01
006AA:  MOVLB  7
006AC:  MOVWF  x01
006AE:  MOVLB  0
006B0:  RCALL  03CA
....................    if (paramsValid != isValid)
006B2:  MOVF   xFA,W
006B4:  SUBLW  AA
006B6:  BZ    06C0
....................    {
....................       paramsValid = isValid;
006B8:  MOVLW  AA
006BA:  MOVWF  xFA
....................       params_save_to_ee(); // saves the base parameters on first boot
006BC:  BRA    050E
....................    }
006BE:  BRA    06C2
....................    else
....................    {
....................       params_load_from_ee();
006C0:  BRA    05F2
....................    }
006C2:  GOTO   A71A (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <monitor.h>
.................... #ifndef monitor
.................... #define monitor
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B7,PIN_B6,PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
....................    output_b(portB_reset);
....................    output_c(portC_reset);
....................    output_d(portD_reset);
....................    output_e(portE_reset);
....................    
....................    port_a_pullups(portA_pullups);
....................    port_b_pullups(portB_pullups);
....................    port_c_pullups(portC_pullups);
....................    port_d_pullups(portD_pullups);
....................    port_e_pullups(portE_pullups);
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................     float kP;      // proportional gain
....................     float kI;      // integral gain
....................     float kD;      // derivative gain
....................     float SP;      // set point-- desired output
....................     float PV;      // process variable-- measured output
....................     float PVold;   // oldPV value  
....................     float CV;      // control variable-- output -- 0 to 100%
....................     float I;       // integral value
....................     float maxSP;   // Max setpoint in microns
....................     float minSP;   // Min setpoint in microns
.................... }PID[2] = {
....................    //  P     I     D
....................    //0.01    0.3   0.1
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}, 
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}
....................     };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... //!#define op_upper_bound 63  // CRYO
.................... //!#define op_lower_bound -63 // CRYO
.................... 
.................... #define op_upper_bound 63  // AMBIENT 
.................... #define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    BOOLEAN homeFlag;       // Flag to trigger the homing routine
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,FALSE},
....................    {0,0,0,0,0,0,0,0,0,0,FALSE}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................     BOOLEAN invV;
....................     unsigned int16 ipVal;
....................     float opPcnt;
....................    
.................... }dacVals[2] = 
.................... {
....................     {FALSE,0,0},
....................     {FALSE,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <ADS1220.h>
.................... #ifndef ADS1220
.................... #define ADS1220
.................... 
.................... /*****************************************************************************/
.................... /* SET UP PORTS FOR USE WITH DRIVER                                          */
.................... /*****************************************************************************/
.................... #define _CS0  PIN_D5 // chip select pins 
.................... #define _CS1  PIN_D6
.................... #define _CS2  PIN_D7
.................... #define _CS3  PIN_B0
.................... 
.................... #pin_select SCK2=PIN_B1
.................... #pin_select SDI2=PIN_B2
.................... #pin_select SDO2=PIN_B3
.................... #use spi(MASTER, SPI2, BAUD=4096000, MODE=1, STREAM=SPI_mon)
.................... //!setup_spi2(SPI_MASTER | SPI_SCK_IDLE_LOW | SPI_XMIT_H_TO_L | SPI_CLK_DIV_64);
.................... 
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* REGISTER DEFINITIONS                                                      */
.................... /*****************************************************************************/
.................... typedef enum {reg0 = 0x00,reg1 = 0x04 ,reg2 = 0x08, reg3 = 0x0C}adsReg;
.................... 
.................... //REGISTER 0 OPTIONS
.................... 
.................... #define IPp0n1 0x00
.................... #define IPp0n2 0x10
.................... #define IPp0n3 0x20
.................... #define IPp1n2 0x30
.................... #define IPp1n3 0x40
.................... #define IPp2n3 0x50
.................... #define IPp1n0 0x60
.................... #define IPp3n2 0x70
.................... #define IPp0nVss 0x80
.................... #define IPp1nVss 0x90
.................... #define IPp2nVss 0xA0
.................... #define IPp3nVss 0xB0
.................... #define IPVrpVrn 0xC0
.................... #define IPVddVss 0xD0
.................... #define IPhalfRail 0xE0
.................... 
.................... #define g1 0x00
.................... #define g2 0x02
.................... #define g4 0x04
.................... #define g8 0x06
.................... #define g16 0x08
.................... #define g32 0x0A
.................... #define g64 0x0C
.................... #define g128 0x0E
.................... 
.................... #define PGAenabled 0x00
.................... #define PGAbypass 0x01
.................... 
.................... //REGISTER 1 OPTIONS
.................... 
.................... #define DRn20 0x00
.................... #define DRn45 0x20
.................... #define DRn90 0x40
.................... #define DRn175 0x60
.................... #define DRn330 0x80
.................... #define DRn600 0xA0
.................... #define DRn1000 0xC0
.................... 
.................... #define MDnormal 0x00
.................... #define MDduty 0x80
.................... #define MDturbo 0x10
.................... 
.................... #define CMsingle 0x00
.................... #define CMcont 0x40
.................... 
.................... #define TSdisable 0x00
.................... #define TSenable 0x20
.................... 
.................... #define BCSoff 0x00
.................... #define BCSon 0x01
.................... 
.................... //REGISTER 2 OPTIONS
.................... 
.................... #define REFinternal 0x00
.................... #define REFp0n0 0x40
.................... #define REFp1n1 0x80
.................... #define REFVddVss 0xC0
.................... 
.................... #define FIRoff 0x00
.................... #define FIR5060 0x10
.................... #define FIR50 0x20
.................... #define FIR60 0x30
.................... 
.................... #define PSWopen 0x00
.................... #define PSWstart 0x08
.................... 
.................... #define Ioff 0x00
.................... #define Iu10 0x01
.................... #define Iu50 0x02
.................... #define Iu100 0x03
.................... #define Iu250 0x04
.................... #define Iu500 0x05
.................... #define Iu1000 0x06
.................... #define Iu1500 0x07  
.................... 
.................... //REGISTER 3 OPTIONS
.................... 
.................... #define I1disabled 0x00
.................... #define I1a0p1 0x20
.................... #define I1a1 0x40
.................... #define I1a2 0x60
.................... #define I1a3n1 0x80
.................... #define I1p0 0xA0
.................... #define I1n0 0xC0
.................... 
.................... #define I2disabled 0x00
.................... #define I2a0p1 0x04
.................... #define I2a1 0x08
.................... #define I2a2 0x0A
.................... #define I2a3n1 0x10
.................... #define I2p0 0x14
.................... #define I2n0 0x18
.................... 
.................... #define drdyPin 0x00
.................... #define doutPin 0x20
.................... 
.................... // REGISTER CONGIGURATIONS FOR THIS APP
.................... #define reg0config IPp1n2|g1|PGAenabled // 0x30//
.................... #define reg1config DRn20|MDturbo|CMsingle|TSDisable|BCSoff //0x10
.................... #define reg2config REFinternal|FIRoff|PSWopen|Ioff //0x30
.................... #define reg3config I1disabled|I2disabled|drdyPin //0x00
.................... 
.................... //COMMANDS
.................... #define ADSreset 0x06
.................... #define ADSstart 0x08
.................... #define ADSpowerDn 0x02
.................... #define ADSreadData 0x10
.................... #define ADSreadReg 0x20
.................... #define ADSwriteReg 0x40
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* DESELECT ALL ADCs                                                         */
.................... /*****************************************************************************/
.................... void ads_deselect_all()
.................... {   
....................    output_high(_CS0); // deselect all chip select pins
*
0016E:  MOVLW  1F
00170:  MOVWF  F8A
00172:  BSF    F85.5
....................    output_high(_CS1);
00174:  MOVWF  F8A
00176:  BSF    F85.6
....................    output_high(_CS2);
00178:  MOVWF  F8A
0017A:  BSF    F85.7
....................    output_high(_CS3); 
0017C:  MOVLW  04
0017E:  MOVWF  F88
00180:  BSF    F83.0
....................    delay_us(10);
00182:  MOVLW  35
00184:  MOVWF  00
00186:  DECFSZ 00,F
00188:  BRA    0186
0018A:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT DESIRED ADC                                                        */
.................... /*****************************************************************************/
.................... void ads_select_ch(int8 ch)
.................... {
....................    ads_deselect_all();
*
006C6:  RCALL  016E
....................    switch(ch)
006C8:  MOVLB  7
006CA:  MOVF   x0C,W
006CC:  ADDLW  FC
006CE:  BC    0702
006D0:  ADDLW  04
006D2:  MOVLB  0
006D4:  GOTO   070E
....................    {
....................       case 0:
....................          output_low(_CS0);
006D8:  MOVLW  1F
006DA:  MOVWF  F8A
006DC:  BCF    F85.5
....................       break; 
006DE:  MOVLB  7
006E0:  BRA    0702
....................       case 1:
....................          output_low(_CS1);
006E2:  MOVLW  1F
006E4:  MOVWF  F8A
006E6:  BCF    F85.6
....................       break;   
006E8:  MOVLB  7
006EA:  BRA    0702
....................       case 2:
....................          output_low(_CS2);
006EC:  MOVLW  1F
006EE:  MOVWF  F8A
006F0:  BCF    F85.7
....................       break;
006F2:  MOVLB  7
006F4:  BRA    0702
....................       case 3:
....................          output_low(_CS3);
006F6:  MOVLW  04
006F8:  MOVWF  F88
006FA:  BCF    F83.0
....................       break;              
006FC:  MOVLB  7
006FE:  BRA    0702
00700:  MOVLB  7
....................    }
....................    delay_us(10);
00702:  MOVLW  35
00704:  MOVWF  00
00706:  DECFSZ 00,F
00708:  BRA    0706
0070A:  MOVLB  0
0070C:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT ADC BLOCK (2 ADCs/BLOCK)                                           */
.................... /*****************************************************************************/
.................... void ads_select_block(int8 block)
.................... {
....................    ads_deselect_all();
*
0018C:  RCALL  016E
....................    switch(block)
0018E:  MOVLB  7
00190:  MOVF   x74,W
00192:  XORLW  00
00194:  MOVLB  0
00196:  BZ    019E
00198:  XORLW  01
0019A:  BZ    01AA
0019C:  BRA    01B6
....................    {
....................       case 0:
....................          output_low(_CS0);
0019E:  MOVLW  1F
001A0:  MOVWF  F8A
001A2:  BCF    F85.5
....................          output_low(_CS1);
001A4:  MOVWF  F8A
001A6:  BCF    F85.6
....................       break; 
001A8:  BRA    01B6
....................       case 1:         
....................          output_low(_CS2);
001AA:  MOVLW  1F
001AC:  MOVWF  F8A
001AE:  BCF    F85.7
....................          output_low(_CS3);
001B0:  MOVLW  04
001B2:  MOVWF  F88
001B4:  BCF    F83.0
....................       break;         
....................    }
....................    delay_us(10);
001B6:  MOVLW  35
001B8:  MOVWF  00
001BA:  DECFSZ 00,F
001BC:  BRA    01BA
001BE:  GOTO   01C8 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT ALL ADCs                                                           */
.................... /*****************************************************************************/
.................... void ads_select_all()
.................... {
....................    output_low(_CS0);
*
007F8:  MOVLW  1F
007FA:  MOVWF  F8A
007FC:  BCF    F85.5
....................    output_low(_CS1);
007FE:  MOVWF  F8A
00800:  BCF    F85.6
....................    output_low(_CS2);
00802:  MOVWF  F8A
00804:  BCF    F85.7
....................    output_low(_CS3);
00806:  MOVLW  04
00808:  MOVWF  F88
0080A:  BCF    F83.0
....................    delay_us(10);
0080C:  MOVLW  35
0080E:  MOVWF  00
00810:  DECFSZ 00,F
00812:  BRA    0810
00814:  GOTO   081A (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO AN ADC                                          */
.................... /*****************************************************************************/
.................... void ads_write_command(int8 ch, unsigned int8 command)
.................... {
....................    ads_select_ch(ch);
*
00730:  MOVFF  70A,70C
00734:  RCALL  06C6
....................    spi_write2(command);
00736:  MOVLB  E
00738:  MOVF   x8D,W
0073A:  MOVFF  70B,E8D
0073E:  RRCF   x90,W
00740:  BNC   073E
00742:  MOVLB  0
00744:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO A BLOCK OF ADCs                                 */
.................... /*****************************************************************************/
.................... void ads_write_command_block(int8 block, unsigned int8 command)
.................... {
....................    ads_select_block(block);
*
001C2:  MOVFF  772,774
001C6:  BRA    018C
....................    spi_write2(command);
001C8:  MOVLB  E
001CA:  MOVF   x8D,W
001CC:  MOVFF  773,E8D
001D0:  RRCF   x90,W
001D2:  BNC   01D0
001D4:  MOVLB  0
001D6:  GOTO   01E8 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO ALL ADCs                                        */
.................... /*****************************************************************************/
.................... void ads_write_command_all(unsigned int8 command)
.................... {
....................    ads_select_all();
*
00818:  BRA    07F8
....................    spi_write2(command);
0081A:  MOVLB  E
0081C:  MOVF   x8D,W
0081E:  MOVFF  701,E8D
00822:  RRCF   x90,W
00824:  BNC   0822
00826:  MOVLB  0
00828:  GOTO   0836 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PREPARE TO READ FROM AN ADC                                               */
.................... /*****************************************************************************/
.................... void ads_read_command(int8 ch, unsigned int8 command)
.................... {
....................    ads_select_ch(ch);
*
00844:  MOVFF  709,70C
00848:  RCALL  06C6
....................    spi_read2(command);
0084A:  MOVLB  E
0084C:  MOVF   x8D,W
0084E:  MOVFF  70A,E8D
00852:  RRCF   x90,W
00854:  BNC   0852
00856:  MOVLB  0
00858:  GOTO   086A (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE TO THE CONFIGURATION REGISTERS                                      */
.................... /*****************************************************************************/
.................... void ads_write_reg(int8 ch, adsReg regID, int8 data)
*
00768:  MOVLB  7
0076A:  MOVF   x07,W
0076C:  IORLW  40
0076E:  MOVWF  x09
.................... {
....................    unsigned int8 command = ADSwriteReg | regID | 0; // 0 is numbytes to write-1
....................    ads_write_command(ch, command);
00770:  MOVFF  706,70A
00774:  MOVFF  709,70B
00778:  MOVLB  0
0077A:  RCALL  0730
....................    spi_write2(data);
0077C:  MOVLB  E
0077E:  MOVF   x8D,W
00780:  MOVFF  708,E8D
00784:  RRCF   x90,W
00786:  BNC   0784
....................    ads_deselect_all();
00788:  MOVLB  0
0078A:  RCALL  016E
0078C:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* READ FROM THE CONFIGURATION REGISTERS                                     */
.................... /*****************************************************************************/
.................... unsigned int8 ads_read_reg(int8 ch, adsReg regID)
.................... {
....................    unsigned int8 command = ADSreadReg | regID | 0;
....................    ads_read_command(ch, command);
....................    unsigned int8 data = spi_read2(0);
....................    ads_deselect_all();
....................    return data;
.................... }
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* START BLOCK CONVERSION                                                    */
.................... /*****************************************************************************/
.................... void ads_start_conv_block(int8 block)
.................... {
....................    ads_write_command_block(block, ADSstart);
*
001DA:  MOVFF  771,772
001DE:  MOVLW  08
001E0:  MOVLB  7
001E2:  MOVWF  x73
001E4:  MOVLB  0
001E6:  BRA    01C2
....................    delay_us(10);
001E8:  MOVLW  35
001EA:  MOVWF  00
001EC:  DECFSZ 00,F
001EE:  BRA    01EC
....................    ads_deselect_all();
001F0:  RCALL  016E
001F2:  GOTO   0238 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* START ALL CONVERSION                                                      */
.................... /*****************************************************************************/
.................... void ads_start_conv_all()
.................... {
....................    ads_write_command_all(ADSstart);
*
0082C:  MOVLW  08
0082E:  MOVLB  7
00830:  MOVWF  x01
00832:  MOVLB  0
00834:  BRA    0818
....................    delay_us(10);
00836:  MOVLW  35
00838:  MOVWF  00
0083A:  DECFSZ 00,F
0083C:  BRA    083A
....................    ads_deselect_all();
0083E:  RCALL  016E
00840:  GOTO   09C6 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* READ THE MOST RECENT CONVERSION                                           */
.................... /*****************************************************************************/
.................... signed int32 ads_read_data(int8 ch)
.................... {
....................    union Data
....................    {
....................       unsigned int8 dBytes[4];
....................       signed int32 dWord;
....................    }data;
....................    
....................    ads_read_command(ch, ADSreadData);
*
0085C:  MOVFF  704,709
00860:  MOVLW  10
00862:  MOVLB  7
00864:  MOVWF  x0A
00866:  MOVLB  0
00868:  BRA    0844
....................    data.dBytes[3] = 0;
0086A:  MOVLB  7
0086C:  CLRF   x08
....................    data.dBytes[2] = spi_read2(0);
0086E:  MOVLB  E
00870:  MOVF   x8D,W
00872:  CLRF   x8D
00874:  RRCF   x90,W
00876:  BNC   0874
00878:  MOVFF  E8D,707
....................    data.dBytes[1] = spi_read2(0);
0087C:  MOVF   x8D,W
0087E:  CLRF   x8D
00880:  RRCF   x90,W
00882:  BNC   0880
00884:  MOVFF  E8D,706
....................    data.dBytes[0] = spi_read2(0);
00888:  MOVF   x8D,W
0088A:  CLRF   x8D
0088C:  RRCF   x90,W
0088E:  BNC   088C
00890:  MOVFF  E8D,705
....................    
....................    //convert 24-bit 2's complement to 32-bit 2's complement
....................    if (0x80 & data.dBytes[2]) data.dBytes[3] |= 0xFF;
00894:  MOVLB  7
00896:  MOVF   x07,W
00898:  ANDLW  80
0089A:  BZ    08A0
0089C:  MOVLW  FF
0089E:  IORWF  x08,F
....................    
....................    ads_deselect_all();
008A0:  MOVLB  0
008A2:  RCALL  016E
....................    return data.dWord;
008A4:  MOVFF  705,00
008A8:  MOVFF  706,01
008AC:  MOVFF  707,02
008B0:  MOVFF  708,03
008B4:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE A CHANNEL                                                      */
.................... /*****************************************************************************/
.................... 
.................... void ADS1220init(int8 ch, rc0=reg0config, rc1=reg1config, rc2=reg2config, rc3=reg3config)
.................... {
....................    ads_write_command(ch, ADSreset);   //reset the device
*
0078E:  MOVFF  701,70A
00792:  MOVLW  06
00794:  MOVLB  7
00796:  MOVWF  x0B
00798:  MOVLB  0
0079A:  RCALL  0730
....................    delay_us(300);                    
0079C:  MOVLW  02
0079E:  MOVLB  7
007A0:  MOVWF  x06
007A2:  MOVLW  96
007A4:  MOVWF  x07
007A6:  MOVLB  0
007A8:  RCALL  0746
007AA:  MOVLB  7
007AC:  DECFSZ x06,F
007AE:  BRA    07A2
....................    ads_write_reg(ch, reg0, rc0);   //send default configurations
007B0:  MOVFF  701,706
007B4:  CLRF   x07
007B6:  MOVFF  702,708
007BA:  MOVLB  0
007BC:  RCALL  0768
....................    ads_write_reg(ch, reg1, rc1);
007BE:  MOVFF  701,706
007C2:  MOVLW  04
007C4:  MOVLB  7
007C6:  MOVWF  x07
007C8:  MOVFF  703,708
007CC:  MOVLB  0
007CE:  RCALL  0768
....................    ads_write_reg(ch, reg2, rc2);
007D0:  MOVFF  701,706
007D4:  MOVLW  08
007D6:  MOVLB  7
007D8:  MOVWF  x07
007DA:  MOVFF  704,708
007DE:  MOVLB  0
007E0:  RCALL  0768
....................    ads_write_reg(ch, reg3, rc3);  
007E2:  MOVFF  701,706
007E6:  MOVLW  0C
007E8:  MOVLB  7
007EA:  MOVWF  x07
007EC:  MOVFF  705,708
007F0:  MOVLB  0
007F2:  RCALL  0768
007F4:  GOTO   09A0 (RETURN)
.................... }
.................... #endif 
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
*
0275C:  MOVLB  7
0275E:  BCF    x45.0
....................    y = x;
02760:  MOVFF  739,73E
02764:  MOVFF  738,73D
02768:  MOVFF  737,73C
0276C:  MOVFF  736,73B
.................... 
....................    if (x < 0)
02770:  MOVFF  739,749
02774:  MOVFF  738,748
02778:  MOVFF  737,747
0277C:  MOVFF  736,746
02780:  CLRF   x4D
02782:  CLRF   x4C
02784:  CLRF   x4B
02786:  CLRF   x4A
02788:  MOVLB  0
0278A:  CALL   1D2C
0278E:  BNC   279C
....................    {
....................       s = 1;
02790:  MOVLB  7
02792:  BSF    x45.0
....................       y = -y;
02794:  MOVF   x3C,W
02796:  XORLW  80
02798:  MOVWF  x3C
0279A:  MOVLB  0
....................    }
.................... 
....................    if (y <= 32768.0)
0279C:  MOVFF  73E,749
027A0:  MOVFF  73D,748
027A4:  MOVFF  73C,747
027A8:  MOVFF  73B,746
027AC:  MOVLB  7
027AE:  CLRF   x4D
027B0:  CLRF   x4C
027B2:  CLRF   x4B
027B4:  MOVLW  8E
027B6:  MOVWF  x4A
027B8:  MOVLB  0
027BA:  CALL   1D2C
027BE:  BC    27C2
027C0:  BNZ   27F2
....................       res = (float32)(unsigned int16)y;
027C2:  MOVFF  73E,749
027C6:  MOVFF  73D,748
027CA:  MOVFF  73C,747
027CE:  MOVFF  73B,746
027D2:  RCALL  2720
027D4:  MOVFF  02,74B
027D8:  MOVFF  01,74A
027DC:  CALL   0D6A
027E0:  MOVFF  03,742
027E4:  MOVFF  02,741
027E8:  MOVFF  01,740
027EC:  MOVFF  00,73F
027F0:  BRA    2994
.................... 
....................  else if (y < 10000000.0)
027F2:  MOVFF  73E,749
027F6:  MOVFF  73D,748
027FA:  MOVFF  73C,747
027FE:  MOVFF  73B,746
02802:  MOVLW  80
02804:  MOVLB  7
02806:  MOVWF  x4D
02808:  MOVLW  96
0280A:  MOVWF  x4C
0280C:  MOVLW  18
0280E:  MOVWF  x4B
02810:  MOVLW  96
02812:  MOVWF  x4A
02814:  MOVLB  0
02816:  CALL   1D2C
0281A:  BTFSS  FD8.0
0281C:  BRA    2984
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
0281E:  MOVFF  73E,753
02822:  MOVFF  73D,752
02826:  MOVFF  73C,751
0282A:  MOVFF  73B,750
0282E:  MOVLB  7
02830:  CLRF   x57
02832:  CLRF   x56
02834:  CLRF   x55
02836:  MOVLW  70
02838:  MOVWF  x54
0283A:  MOVLB  0
0283C:  CALL   0DA0
02840:  MOVFF  03,749
02844:  MOVFF  02,748
02848:  MOVFF  01,747
0284C:  MOVFF  00,746
02850:  RCALL  2720
02852:  MOVFF  02,744
02856:  MOVFF  01,743
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
0285A:  MOVFF  73E,753
0285E:  MOVFF  73D,752
02862:  MOVFF  73C,751
02866:  MOVFF  73B,750
0286A:  MOVLB  7
0286C:  CLRF   x57
0286E:  CLRF   x56
02870:  CLRF   x55
02872:  MOVLW  70
02874:  MOVWF  x54
02876:  MOVLB  0
02878:  CALL   0DA0
0287C:  MOVFF  03,749
02880:  MOVFF  02,748
02884:  MOVFF  01,747
02888:  MOVFF  00,746
0288C:  MOVFF  744,74B
02890:  MOVFF  743,74A
02894:  CALL   0D6A
02898:  BSF    FD8.1
0289A:  MOVFF  749,74D
0289E:  MOVFF  748,74C
028A2:  MOVFF  747,74B
028A6:  MOVFF  746,74A
028AA:  MOVFF  03,751
028AE:  MOVFF  02,750
028B2:  MOVFF  01,74F
028B6:  MOVFF  00,74E
028BA:  CALL   0E96
028BE:  MOVLB  7
028C0:  CLRF   x53
028C2:  CLRF   x52
028C4:  CLRF   x51
028C6:  MOVLW  8E
028C8:  MOVWF  x50
028CA:  MOVFF  03,757
028CE:  MOVFF  02,756
028D2:  MOVFF  01,755
028D6:  MOVFF  00,754
028DA:  MOVLB  0
028DC:  CALL   0DA0
028E0:  MOVFF  03,73E
028E4:  MOVFF  02,73D
028E8:  MOVFF  01,73C
028EC:  MOVFF  00,73B
....................       res = 32768.0*(float32)l;
028F0:  MOVFF  744,74B
028F4:  MOVFF  743,74A
028F8:  CALL   0D6A
028FC:  MOVLB  7
028FE:  CLRF   x53
02900:  CLRF   x52
02902:  CLRF   x51
02904:  MOVLW  8E
02906:  MOVWF  x50
02908:  MOVFF  03,757
0290C:  MOVFF  02,756
02910:  MOVFF  01,755
02914:  MOVFF  00,754
02918:  MOVLB  0
0291A:  CALL   0DA0
0291E:  MOVFF  03,742
02922:  MOVFF  02,741
02926:  MOVFF  01,740
0292A:  MOVFF  00,73F
....................       res += (float32)(unsigned int16)y;
0292E:  MOVFF  73E,749
02932:  MOVFF  73D,748
02936:  MOVFF  73C,747
0293A:  MOVFF  73B,746
0293E:  RCALL  2720
02940:  MOVFF  02,74B
02944:  MOVFF  01,74A
02948:  CALL   0D6A
0294C:  BCF    FD8.1
0294E:  MOVFF  742,74D
02952:  MOVFF  741,74C
02956:  MOVFF  740,74B
0295A:  MOVFF  73F,74A
0295E:  MOVFF  03,751
02962:  MOVFF  02,750
02966:  MOVFF  01,74F
0296A:  MOVFF  00,74E
0296E:  CALL   0E96
02972:  MOVFF  03,742
02976:  MOVFF  02,741
0297A:  MOVFF  01,740
0297E:  MOVFF  00,73F
....................    }
02982:  BRA    2994
.................... 
....................  else
....................   res = y;
02984:  MOVFF  73E,742
02988:  MOVFF  73D,741
0298C:  MOVFF  73C,740
02990:  MOVFF  73B,73F
.................... 
....................  y = y - (float32)(unsigned int16)y;
02994:  MOVFF  73E,749
02998:  MOVFF  73D,748
0299C:  MOVFF  73C,747
029A0:  MOVFF  73B,746
029A4:  RCALL  2720
029A6:  MOVFF  02,74B
029AA:  MOVFF  01,74A
029AE:  CALL   0D6A
029B2:  BSF    FD8.1
029B4:  MOVFF  73E,74D
029B8:  MOVFF  73D,74C
029BC:  MOVFF  73C,74B
029C0:  MOVFF  73B,74A
029C4:  MOVFF  03,751
029C8:  MOVFF  02,750
029CC:  MOVFF  01,74F
029D0:  MOVFF  00,74E
029D4:  CALL   0E96
029D8:  MOVFF  03,73E
029DC:  MOVFF  02,73D
029E0:  MOVFF  01,73C
029E4:  MOVFF  00,73B
.................... 
....................  if (s)
029E8:  MOVLB  7
029EA:  BTFSS  x45.0
029EC:  BRA    29F4
....................   res = -res;
029EE:  MOVF   x40,W
029F0:  XORLW  80
029F2:  MOVWF  x40
.................... 
....................  if (y != 0)
029F4:  MOVFF  73E,749
029F8:  MOVFF  73D,748
029FC:  MOVFF  73C,747
02A00:  MOVFF  73B,746
02A04:  CLRF   x4D
02A06:  CLRF   x4C
02A08:  CLRF   x4B
02A0A:  CLRF   x4A
02A0C:  MOVLB  0
02A0E:  CALL   1D2C
02A12:  BZ    2A8C
....................  {
....................   if (s == 1 && n == 0)
02A14:  MOVLB  7
02A16:  BTFSS  x45.0
02A18:  BRA    2A52
02A1A:  MOVF   x3A,F
02A1C:  BNZ   2A52
....................    res -= 1.0;
02A1E:  BSF    FD8.1
02A20:  MOVFF  742,74D
02A24:  MOVFF  741,74C
02A28:  MOVFF  740,74B
02A2C:  MOVFF  73F,74A
02A30:  CLRF   x51
02A32:  CLRF   x50
02A34:  CLRF   x4F
02A36:  MOVLW  7F
02A38:  MOVWF  x4E
02A3A:  MOVLB  0
02A3C:  CALL   0E96
02A40:  MOVFF  03,742
02A44:  MOVFF  02,741
02A48:  MOVFF  01,740
02A4C:  MOVFF  00,73F
02A50:  MOVLB  7
.................... 
....................   if (s == 0 && n == 1)
02A52:  BTFSC  x45.0
02A54:  BRA    2A8E
02A56:  DECFSZ x3A,W
02A58:  BRA    2A8E
....................    res += 1.0;
02A5A:  BCF    FD8.1
02A5C:  MOVFF  742,74D
02A60:  MOVFF  741,74C
02A64:  MOVFF  740,74B
02A68:  MOVFF  73F,74A
02A6C:  CLRF   x51
02A6E:  CLRF   x50
02A70:  CLRF   x4F
02A72:  MOVLW  7F
02A74:  MOVWF  x4E
02A76:  MOVLB  0
02A78:  CALL   0E96
02A7C:  MOVFF  03,742
02A80:  MOVFF  02,741
02A84:  MOVFF  01,740
02A88:  MOVFF  00,73F
02A8C:  MOVLB  7
....................  }
....................  if (x == 0)
02A8E:  MOVFF  739,749
02A92:  MOVFF  738,748
02A96:  MOVFF  737,747
02A9A:  MOVFF  736,746
02A9E:  CLRF   x4D
02AA0:  CLRF   x4C
02AA2:  CLRF   x4B
02AA4:  CLRF   x4A
02AA6:  MOVLB  0
02AA8:  CALL   1D2C
02AAC:  BNZ   2ABA
....................     res = 0;
02AAE:  MOVLB  7
02AB0:  CLRF   x42
02AB2:  CLRF   x41
02AB4:  CLRF   x40
02AB6:  CLRF   x3F
02AB8:  MOVLB  0
.................... 
....................  return (res);
02ABA:  MOVFF  73F,00
02ABE:  MOVFF  740,01
02AC2:  MOVFF  741,02
02AC6:  MOVFF  742,03
02ACA:  RETURN 0
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
*
02AEA:  MOVFF  735,739
02AEE:  MOVFF  734,738
02AF2:  MOVFF  733,737
02AF6:  MOVFF  732,736
02AFA:  MOVLB  7
02AFC:  CLRF   x3A
02AFE:  MOVLB  0
02B00:  RCALL  275C
02B02:  GOTO   2C0E (RETURN)
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
*
02ACC:  MOVFF  735,739
02AD0:  MOVFF  734,738
02AD4:  MOVFF  733,737
02AD8:  MOVFF  732,736
02ADC:  MOVLW  01
02ADE:  MOVLB  7
02AE0:  MOVWF  x3A
02AE2:  MOVLB  0
02AE4:  RCALL  275C
02AE6:  GOTO   2BC6 (RETURN)
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
*
02B06:  MOVFF  729,749
02B0A:  MOVFF  728,748
02B0E:  MOVFF  727,747
02B12:  MOVFF  726,746
02B16:  MOVLB  7
02B18:  CLRF   x4D
02B1A:  CLRF   x4C
02B1C:  CLRF   x4B
02B1E:  CLRF   x4A
02B20:  MOVLB  0
02B22:  CALL   1D2C
02B26:  BTFSC  FD8.2
02B28:  BRA    2C6A
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
02B2A:  MOVFF  725,742
02B2E:  MOVFF  724,741
02B32:  MOVFF  723,740
02B36:  MOVFF  722,73F
02B3A:  MOVFF  729,746
02B3E:  MOVFF  728,745
02B42:  MOVFF  727,744
02B46:  MOVFF  726,743
02B4A:  CALL   1DA6
02B4E:  MOVFF  03,731
02B52:  MOVFF  02,730
02B56:  MOVFF  01,72F
02B5A:  MOVFF  00,72E
02B5E:  MOVFF  03,749
02B62:  MOVFF  02,748
02B66:  MOVFF  01,747
02B6A:  MOVFF  00,746
02B6E:  MOVLB  7
02B70:  CLRF   x4D
02B72:  CLRF   x4C
02B74:  CLRF   x4B
02B76:  CLRF   x4A
02B78:  MOVLB  0
02B7A:  CALL   1D2C
02B7E:  BNC   2BC8
02B80:  MOVFF  725,742
02B84:  MOVFF  724,741
02B88:  MOVFF  723,740
02B8C:  MOVFF  722,73F
02B90:  MOVFF  729,746
02B94:  MOVFF  728,745
02B98:  MOVFF  727,744
02B9C:  MOVFF  726,743
02BA0:  CALL   1DA6
02BA4:  MOVFF  03,731
02BA8:  MOVFF  02,730
02BAC:  MOVFF  01,72F
02BB0:  MOVFF  00,72E
02BB4:  MOVFF  03,735
02BB8:  MOVFF  02,734
02BBC:  MOVFF  01,733
02BC0:  MOVFF  00,732
02BC4:  BRA    2ACC
02BC6:  BRA    2C0E
02BC8:  MOVFF  725,742
02BCC:  MOVFF  724,741
02BD0:  MOVFF  723,740
02BD4:  MOVFF  722,73F
02BD8:  MOVFF  729,746
02BDC:  MOVFF  728,745
02BE0:  MOVFF  727,744
02BE4:  MOVFF  726,743
02BE8:  CALL   1DA6
02BEC:  MOVFF  03,731
02BF0:  MOVFF  02,730
02BF4:  MOVFF  01,72F
02BF8:  MOVFF  00,72E
02BFC:  MOVFF  03,735
02C00:  MOVFF  02,734
02C04:  MOVFF  01,733
02C08:  MOVFF  00,732
02C0C:  BRA    2AEA
02C0E:  MOVFF  03,72D
02C12:  MOVFF  02,72C
02C16:  MOVFF  01,72B
02C1A:  MOVFF  00,72A
....................       return(x-(i*y));
02C1E:  MOVFF  72D,753
02C22:  MOVFF  72C,752
02C26:  MOVFF  72B,751
02C2A:  MOVFF  72A,750
02C2E:  MOVFF  729,757
02C32:  MOVFF  728,756
02C36:  MOVFF  727,755
02C3A:  MOVFF  726,754
02C3E:  CALL   0DA0
02C42:  BSF    FD8.1
02C44:  MOVFF  725,74D
02C48:  MOVFF  724,74C
02C4C:  MOVFF  723,74B
02C50:  MOVFF  722,74A
02C54:  MOVFF  03,751
02C58:  MOVFF  02,750
02C5C:  MOVFF  01,74F
02C60:  MOVFF  00,74E
02C64:  CALL   0E96
02C68:  BRA    2C6A
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
02C6A:  RETURN 0
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
*
03000:  MOVFF  729,753
03004:  MOVFF  728,752
03008:  MOVFF  727,751
0300C:  MOVFF  726,750
03010:  MOVLW  3B
03012:  MOVLB  7
03014:  MOVWF  x57
03016:  MOVLW  AA
03018:  MOVWF  x56
0301A:  MOVLW  38
0301C:  MOVWF  x55
0301E:  MOVLW  7F
03020:  MOVWF  x54
03022:  MOVLB  0
03024:  CALL   0DA0
03028:  MOVFF  03,749
0302C:  MOVFF  02,748
03030:  MOVFF  01,747
03034:  MOVFF  00,746
03038:  CALL   2720
0303C:  MOVFF  01,736
....................    s = 0;
03040:  MOVLB  7
03042:  BCF    x37.0
....................    y = x;
03044:  MOVFF  729,72D
03048:  MOVFF  728,72C
0304C:  MOVFF  727,72B
03050:  MOVFF  726,72A
.................... 
....................    if (x < 0)
03054:  MOVFF  729,749
03058:  MOVFF  728,748
0305C:  MOVFF  727,747
03060:  MOVFF  726,746
03064:  CLRF   x4D
03066:  CLRF   x4C
03068:  CLRF   x4B
0306A:  CLRF   x4A
0306C:  MOVLB  0
0306E:  CALL   1D2C
03072:  BNC   3082
....................    {
....................       s = 1;
03074:  MOVLB  7
03076:  BSF    x37.0
....................       n = -n;
03078:  NEGF   x36
....................       y = -y;
0307A:  MOVF   x2B,W
0307C:  XORLW  80
0307E:  MOVWF  x2B
03080:  MOVLB  0
....................    }
.................... 
....................    res = 0.0;
03082:  MOVLB  7
03084:  CLRF   x31
03086:  CLRF   x30
03088:  CLRF   x2F
0308A:  CLRF   x2E
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
0308C:  MOVLW  07
0308E:  MOVWF  x39
03090:  MOVLW  2E
03092:  MOVFF  739,FEA
03096:  MOVWF  FE9
03098:  MOVLW  7F
0309A:  ADDWF  x36,W
0309C:  MOVWF  FEF
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
0309E:  MOVFF  72D,753
030A2:  MOVFF  72C,752
030A6:  MOVFF  72B,751
030AA:  MOVFF  72A,750
030AE:  MOVLW  3B
030B0:  MOVWF  x57
030B2:  MOVLW  AA
030B4:  MOVWF  x56
030B6:  MOVLW  38
030B8:  MOVWF  x55
030BA:  MOVLW  7F
030BC:  MOVWF  x54
030BE:  MOVLB  0
030C0:  CALL   0DA0
030C4:  MOVFF  03,73B
030C8:  MOVFF  02,73A
030CC:  MOVFF  01,739
030D0:  MOVFF  00,738
030D4:  MOVLB  7
030D6:  CLRF   x3D
030D8:  MOVFF  736,73C
030DC:  BTFSC  x3C.7
030DE:  DECF   x3D,F
030E0:  MOVLB  0
030E2:  CALL   26D0
030E6:  BSF    FD8.1
030E8:  MOVFF  73B,74D
030EC:  MOVFF  73A,74C
030F0:  MOVFF  739,74B
030F4:  MOVFF  738,74A
030F8:  MOVFF  03,751
030FC:  MOVFF  02,750
03100:  MOVFF  01,74F
03104:  MOVFF  00,74E
03108:  CALL   0E96
0310C:  MOVFF  03,72D
03110:  MOVFF  02,72C
03114:  MOVFF  01,72B
03118:  MOVFF  00,72A
.................... 
....................    r = pe[0]*y + pe[1];
0311C:  MOVLW  7C
0311E:  MOVLB  7
03120:  MOVWF  x53
03122:  MOVLW  88
03124:  MOVWF  x52
03126:  MOVLW  59
03128:  MOVWF  x51
0312A:  MOVLW  72
0312C:  MOVWF  x50
0312E:  MOVFF  72D,757
03132:  MOVFF  72C,756
03136:  MOVFF  72B,755
0313A:  MOVFF  72A,754
0313E:  MOVLB  0
03140:  CALL   0DA0
03144:  MOVFF  03,73B
03148:  MOVFF  02,73A
0314C:  MOVFF  01,739
03150:  MOVFF  00,738
03154:  BCF    FD8.1
03156:  MOVFF  03,74D
0315A:  MOVFF  02,74C
0315E:  MOVFF  01,74B
03162:  MOVFF  00,74A
03166:  MOVLW  E0
03168:  MOVLB  7
0316A:  MOVWF  x51
0316C:  MOVLW  97
0316E:  MOVWF  x50
03170:  MOVLW  26
03172:  MOVWF  x4F
03174:  MOVLW  75
03176:  MOVWF  x4E
03178:  MOVLB  0
0317A:  CALL   0E96
0317E:  MOVFF  03,735
03182:  MOVFF  02,734
03186:  MOVFF  01,733
0318A:  MOVFF  00,732
....................    r = r*y + pe[2];
0318E:  MOVFF  735,753
03192:  MOVFF  734,752
03196:  MOVFF  733,751
0319A:  MOVFF  732,750
0319E:  MOVFF  72D,757
031A2:  MOVFF  72C,756
031A6:  MOVFF  72B,755
031AA:  MOVFF  72A,754
031AE:  CALL   0DA0
031B2:  MOVFF  03,73B
031B6:  MOVFF  02,73A
031BA:  MOVFF  01,739
031BE:  MOVFF  00,738
031C2:  BCF    FD8.1
031C4:  MOVFF  03,74D
031C8:  MOVFF  02,74C
031CC:  MOVFF  01,74B
031D0:  MOVFF  00,74A
031D4:  MOVLW  C4
031D6:  MOVLB  7
031D8:  MOVWF  x51
031DA:  MOVLW  1D
031DC:  MOVWF  x50
031DE:  MOVLW  1E
031E0:  MOVWF  x4F
031E2:  MOVLW  78
031E4:  MOVWF  x4E
031E6:  MOVLB  0
031E8:  CALL   0E96
031EC:  MOVFF  03,735
031F0:  MOVFF  02,734
031F4:  MOVFF  01,733
031F8:  MOVFF  00,732
....................    r = r*y + pe[3];
031FC:  MOVFF  735,753
03200:  MOVFF  734,752
03204:  MOVFF  733,751
03208:  MOVFF  732,750
0320C:  MOVFF  72D,757
03210:  MOVFF  72C,756
03214:  MOVFF  72B,755
03218:  MOVFF  72A,754
0321C:  CALL   0DA0
03220:  MOVFF  03,73B
03224:  MOVFF  02,73A
03228:  MOVFF  01,739
0322C:  MOVFF  00,738
03230:  BCF    FD8.1
03232:  MOVFF  03,74D
03236:  MOVFF  02,74C
0323A:  MOVFF  01,74B
0323E:  MOVFF  00,74A
03242:  MOVLW  5E
03244:  MOVLB  7
03246:  MOVWF  x51
03248:  MOVLW  50
0324A:  MOVWF  x50
0324C:  MOVLW  63
0324E:  MOVWF  x4F
03250:  MOVLW  7A
03252:  MOVWF  x4E
03254:  MOVLB  0
03256:  CALL   0E96
0325A:  MOVFF  03,735
0325E:  MOVFF  02,734
03262:  MOVFF  01,733
03266:  MOVFF  00,732
....................    r = r*y + pe[4];
0326A:  MOVFF  735,753
0326E:  MOVFF  734,752
03272:  MOVFF  733,751
03276:  MOVFF  732,750
0327A:  MOVFF  72D,757
0327E:  MOVFF  72C,756
03282:  MOVFF  72B,755
03286:  MOVFF  72A,754
0328A:  CALL   0DA0
0328E:  MOVFF  03,73B
03292:  MOVFF  02,73A
03296:  MOVFF  01,739
0329A:  MOVFF  00,738
0329E:  BCF    FD8.1
032A0:  MOVFF  03,74D
032A4:  MOVFF  02,74C
032A8:  MOVFF  01,74B
032AC:  MOVFF  00,74A
032B0:  MOVLW  1A
032B2:  MOVLB  7
032B4:  MOVWF  x51
032B6:  MOVLW  FE
032B8:  MOVWF  x50
032BA:  MOVLW  75
032BC:  MOVWF  x4F
032BE:  MOVLW  7C
032C0:  MOVWF  x4E
032C2:  MOVLB  0
032C4:  CALL   0E96
032C8:  MOVFF  03,735
032CC:  MOVFF  02,734
032D0:  MOVFF  01,733
032D4:  MOVFF  00,732
....................    r = r*y + pe[5];
032D8:  MOVFF  735,753
032DC:  MOVFF  734,752
032E0:  MOVFF  733,751
032E4:  MOVFF  732,750
032E8:  MOVFF  72D,757
032EC:  MOVFF  72C,756
032F0:  MOVFF  72B,755
032F4:  MOVFF  72A,754
032F8:  CALL   0DA0
032FC:  MOVFF  03,73B
03300:  MOVFF  02,73A
03304:  MOVFF  01,739
03308:  MOVFF  00,738
0330C:  BCF    FD8.1
0330E:  MOVFF  03,74D
03312:  MOVFF  02,74C
03316:  MOVFF  01,74B
0331A:  MOVFF  00,74A
0331E:  MOVLW  18
03320:  MOVLB  7
03322:  MOVWF  x51
03324:  MOVLW  72
03326:  MOVWF  x50
03328:  MOVLW  31
0332A:  MOVWF  x4F
0332C:  MOVLW  7E
0332E:  MOVWF  x4E
03330:  MOVLB  0
03332:  CALL   0E96
03336:  MOVFF  03,735
0333A:  MOVFF  02,734
0333E:  MOVFF  01,733
03342:  MOVFF  00,732
.................... 
....................    res = res*(1.0 + y*r);
03346:  MOVFF  72D,753
0334A:  MOVFF  72C,752
0334E:  MOVFF  72B,751
03352:  MOVFF  72A,750
03356:  MOVFF  735,757
0335A:  MOVFF  734,756
0335E:  MOVFF  733,755
03362:  MOVFF  732,754
03366:  CALL   0DA0
0336A:  BCF    FD8.1
0336C:  MOVLB  7
0336E:  CLRF   x4D
03370:  CLRF   x4C
03372:  CLRF   x4B
03374:  MOVLW  7F
03376:  MOVWF  x4A
03378:  MOVFF  03,751
0337C:  MOVFF  02,750
03380:  MOVFF  01,74F
03384:  MOVFF  00,74E
03388:  MOVLB  0
0338A:  CALL   0E96
0338E:  MOVFF  731,753
03392:  MOVFF  730,752
03396:  MOVFF  72F,751
0339A:  MOVFF  72E,750
0339E:  MOVFF  03,757
033A2:  MOVFF  02,756
033A6:  MOVFF  01,755
033AA:  MOVFF  00,754
033AE:  CALL   0DA0
033B2:  MOVFF  03,731
033B6:  MOVFF  02,730
033BA:  MOVFF  01,72F
033BE:  MOVFF  00,72E
.................... 
....................    if (s)
033C2:  MOVLB  7
033C4:  BTFSS  x37.0
033C6:  BRA    33FA
....................       res = 1.0/res;
033C8:  CLRF   x42
033CA:  CLRF   x41
033CC:  CLRF   x40
033CE:  MOVLW  7F
033D0:  MOVWF  x3F
033D2:  MOVFF  731,746
033D6:  MOVFF  730,745
033DA:  MOVFF  72F,744
033DE:  MOVFF  72E,743
033E2:  MOVLB  0
033E4:  CALL   1DA6
033E8:  MOVFF  03,731
033EC:  MOVFF  02,730
033F0:  MOVFF  01,72F
033F4:  MOVFF  00,72E
033F8:  MOVLB  7
....................    return(res);
033FA:  MOVFF  72E,00
033FE:  MOVFF  72F,01
03402:  MOVFF  730,02
03406:  MOVFF  731,03
0340A:  MOVLB  0
0340C:  RETURN 0
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
*
02C6C:  MOVFF  729,72D
02C70:  MOVFF  728,72C
02C74:  MOVFF  727,72B
02C78:  MOVFF  726,72A
.................... 
....................    if (y != 1.0)
02C7C:  MOVFF  72D,749
02C80:  MOVFF  72C,748
02C84:  MOVFF  72B,747
02C88:  MOVFF  72A,746
02C8C:  MOVLB  7
02C8E:  CLRF   x4D
02C90:  CLRF   x4C
02C92:  CLRF   x4B
02C94:  MOVLW  7F
02C96:  MOVWF  x4A
02C98:  MOVLB  0
02C9A:  CALL   1D2C
02C9E:  BTFSC  FD8.2
02CA0:  BRA    2FE2
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
02CA2:  MOVLW  07
02CA4:  MOVLB  7
02CA6:  MOVWF  x3C
02CA8:  MOVLW  2A
02CAA:  MOVFF  73C,FEA
02CAE:  MOVWF  FE9
02CB0:  MOVLW  7E
02CB2:  MOVWF  FEF
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
02CB4:  BSF    FD8.1
02CB6:  MOVFF  72D,74D
02CBA:  MOVFF  72C,74C
02CBE:  MOVFF  72B,74B
02CC2:  MOVFF  72A,74A
02CC6:  CLRF   x51
02CC8:  CLRF   x50
02CCA:  CLRF   x4F
02CCC:  MOVLW  7F
02CCE:  MOVWF  x4E
02CD0:  MOVLB  0
02CD2:  CALL   0E96
02CD6:  MOVFF  03,73E
02CDA:  MOVFF  02,73D
02CDE:  MOVFF  01,73C
02CE2:  MOVFF  00,73B
02CE6:  BCF    FD8.1
02CE8:  MOVFF  72D,74D
02CEC:  MOVFF  72C,74C
02CF0:  MOVFF  72B,74B
02CF4:  MOVFF  72A,74A
02CF8:  MOVLB  7
02CFA:  CLRF   x51
02CFC:  CLRF   x50
02CFE:  CLRF   x4F
02D00:  MOVLW  7F
02D02:  MOVWF  x4E
02D04:  MOVLB  0
02D06:  CALL   0E96
02D0A:  MOVFF  73E,742
02D0E:  MOVFF  73D,741
02D12:  MOVFF  73C,740
02D16:  MOVFF  73B,73F
02D1A:  MOVFF  03,746
02D1E:  MOVFF  02,745
02D22:  MOVFF  01,744
02D26:  MOVFF  00,743
02D2A:  CALL   1DA6
02D2E:  MOVFF  03,72D
02D32:  MOVFF  02,72C
02D36:  MOVFF  01,72B
02D3A:  MOVFF  00,72A
.................... 
....................       y2=y*y;
02D3E:  MOVFF  72D,753
02D42:  MOVFF  72C,752
02D46:  MOVFF  72B,751
02D4A:  MOVFF  72A,750
02D4E:  MOVFF  72D,757
02D52:  MOVFF  72C,756
02D56:  MOVFF  72B,755
02D5A:  MOVFF  72A,754
02D5E:  CALL   0DA0
02D62:  MOVFF  03,739
02D66:  MOVFF  02,738
02D6A:  MOVFF  01,737
02D6E:  MOVFF  00,736
.................... 
....................       res = pl[0]*y2 + pl[1];
02D72:  MOVLW  99
02D74:  MOVLB  7
02D76:  MOVWF  x53
02D78:  MOVLW  47
02D7A:  MOVWF  x52
02D7C:  MOVLW  8A
02D7E:  MOVWF  x51
02D80:  MOVLW  7F
02D82:  MOVWF  x50
02D84:  MOVFF  739,757
02D88:  MOVFF  738,756
02D8C:  MOVFF  737,755
02D90:  MOVFF  736,754
02D94:  MOVLB  0
02D96:  CALL   0DA0
02D9A:  MOVFF  03,73E
02D9E:  MOVFF  02,73D
02DA2:  MOVFF  01,73C
02DA6:  MOVFF  00,73B
02DAA:  BCF    FD8.1
02DAC:  MOVFF  03,74D
02DB0:  MOVFF  02,74C
02DB4:  MOVFF  01,74B
02DB8:  MOVFF  00,74A
02DBC:  MOVLB  7
02DBE:  CLRF   x51
02DC0:  CLRF   x50
02DC2:  CLRF   x4F
02DC4:  MOVLW  80
02DC6:  MOVWF  x4E
02DC8:  MOVLB  0
02DCA:  CALL   0E96
02DCE:  MOVFF  03,731
02DD2:  MOVFF  02,730
02DD6:  MOVFF  01,72F
02DDA:  MOVFF  00,72E
.................... 
....................       r = ql[0]*y2 + ql[1];
02DDE:  MOVLW  4C
02DE0:  MOVLB  7
02DE2:  MOVWF  x53
02DE4:  MOVLW  F3
02DE6:  MOVWF  x52
02DE8:  MOVLW  3A
02DEA:  MOVWF  x51
02DEC:  MOVLW  7B
02DEE:  MOVWF  x50
02DF0:  MOVFF  739,757
02DF4:  MOVFF  738,756
02DF8:  MOVFF  737,755
02DFC:  MOVFF  736,754
02E00:  MOVLB  0
02E02:  CALL   0DA0
02E06:  MOVFF  03,73E
02E0A:  MOVFF  02,73D
02E0E:  MOVFF  01,73C
02E12:  MOVFF  00,73B
02E16:  BCF    FD8.1
02E18:  MOVFF  03,74D
02E1C:  MOVFF  02,74C
02E20:  MOVFF  01,74B
02E24:  MOVFF  00,74A
02E28:  MOVLW  2B
02E2A:  MOVLB  7
02E2C:  MOVWF  x51
02E2E:  MOVLW  9D
02E30:  MOVWF  x50
02E32:  MOVLW  DF
02E34:  MOVWF  x4F
02E36:  MOVLW  7E
02E38:  MOVWF  x4E
02E3A:  MOVLB  0
02E3C:  CALL   0E96
02E40:  MOVFF  03,735
02E44:  MOVFF  02,734
02E48:  MOVFF  01,733
02E4C:  MOVFF  00,732
....................       r = r*y2 + 1.0;
02E50:  MOVFF  735,753
02E54:  MOVFF  734,752
02E58:  MOVFF  733,751
02E5C:  MOVFF  732,750
02E60:  MOVFF  739,757
02E64:  MOVFF  738,756
02E68:  MOVFF  737,755
02E6C:  MOVFF  736,754
02E70:  CALL   0DA0
02E74:  MOVFF  03,73E
02E78:  MOVFF  02,73D
02E7C:  MOVFF  01,73C
02E80:  MOVFF  00,73B
02E84:  BCF    FD8.1
02E86:  MOVFF  03,74D
02E8A:  MOVFF  02,74C
02E8E:  MOVFF  01,74B
02E92:  MOVFF  00,74A
02E96:  MOVLB  7
02E98:  CLRF   x51
02E9A:  CLRF   x50
02E9C:  CLRF   x4F
02E9E:  MOVLW  7F
02EA0:  MOVWF  x4E
02EA2:  MOVLB  0
02EA4:  CALL   0E96
02EA8:  MOVFF  03,735
02EAC:  MOVFF  02,734
02EB0:  MOVFF  01,733
02EB4:  MOVFF  00,732
.................... 
....................       res = y*res/r;
02EB8:  MOVFF  72D,753
02EBC:  MOVFF  72C,752
02EC0:  MOVFF  72B,751
02EC4:  MOVFF  72A,750
02EC8:  MOVFF  731,757
02ECC:  MOVFF  730,756
02ED0:  MOVFF  72F,755
02ED4:  MOVFF  72E,754
02ED8:  CALL   0DA0
02EDC:  MOVFF  03,73E
02EE0:  MOVFF  02,73D
02EE4:  MOVFF  01,73C
02EE8:  MOVFF  00,73B
02EEC:  MOVFF  03,742
02EF0:  MOVFF  02,741
02EF4:  MOVFF  01,740
02EF8:  MOVFF  00,73F
02EFC:  MOVFF  735,746
02F00:  MOVFF  734,745
02F04:  MOVFF  733,744
02F08:  MOVFF  732,743
02F0C:  CALL   1DA6
02F10:  MOVFF  03,731
02F14:  MOVFF  02,730
02F18:  MOVFF  01,72F
02F1C:  MOVFF  00,72E
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
02F20:  MOVLW  07
02F22:  MOVLB  7
02F24:  MOVWF  x3C
02F26:  MOVLW  26
02F28:  MOVFF  73C,FEA
02F2C:  MOVWF  FE9
02F2E:  MOVLW  7E
02F30:  SUBWF  FEF,W
02F32:  MOVWF  x3A
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
02F34:  BTFSS  x3A.7
02F36:  BRA    2F62
....................          r = -(float32)-n;
02F38:  MOVLW  00
02F3A:  BSF    FD8.0
02F3C:  SUBFWB x3A,W
02F3E:  CLRF   x3D
02F40:  MOVWF  x3C
02F42:  BTFSC  x3C.7
02F44:  DECF   x3D,F
02F46:  MOVLB  0
02F48:  CALL   26D0
02F4C:  MOVFF  00,732
02F50:  MOVF   01,W
02F52:  XORLW  80
02F54:  MOVLB  7
02F56:  MOVWF  x33
02F58:  MOVFF  02,734
02F5C:  MOVFF  03,735
02F60:  BRA    2F84
....................       else
....................          r = (float32)n;
02F62:  CLRF   x3D
02F64:  MOVFF  73A,73C
02F68:  BTFSC  x3C.7
02F6A:  DECF   x3D,F
02F6C:  MOVLB  0
02F6E:  CALL   26D0
02F72:  MOVFF  03,735
02F76:  MOVFF  02,734
02F7A:  MOVFF  01,733
02F7E:  MOVFF  00,732
02F82:  MOVLB  7
.................... 
....................       res += r*LN2;
02F84:  MOVFF  735,753
02F88:  MOVFF  734,752
02F8C:  MOVFF  733,751
02F90:  MOVFF  732,750
02F94:  MOVLW  18
02F96:  MOVWF  x57
02F98:  MOVLW  72
02F9A:  MOVWF  x56
02F9C:  MOVLW  31
02F9E:  MOVWF  x55
02FA0:  MOVLW  7E
02FA2:  MOVWF  x54
02FA4:  MOVLB  0
02FA6:  CALL   0DA0
02FAA:  BCF    FD8.1
02FAC:  MOVFF  731,74D
02FB0:  MOVFF  730,74C
02FB4:  MOVFF  72F,74B
02FB8:  MOVFF  72E,74A
02FBC:  MOVFF  03,751
02FC0:  MOVFF  02,750
02FC4:  MOVFF  01,74F
02FC8:  MOVFF  00,74E
02FCC:  CALL   0E96
02FD0:  MOVFF  03,731
02FD4:  MOVFF  02,730
02FD8:  MOVFF  01,72F
02FDC:  MOVFF  00,72E
....................    }
02FE0:  BRA    2FEE
.................... 
....................    else
....................       res = 0.0;
02FE2:  MOVLB  7
02FE4:  CLRF   x31
02FE6:  CLRF   x30
02FE8:  CLRF   x2F
02FEA:  CLRF   x2E
02FEC:  MOVLB  0
.................... 
....................    return(res);
02FEE:  MOVFF  72E,00
02FF2:  MOVFF  72F,01
02FF6:  MOVFF  730,02
02FFA:  MOVFF  731,03
02FFE:  RETURN 0
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
*
0340E:  MOVFF  71D,749
03412:  MOVFF  71C,748
03416:  MOVFF  71B,747
0341A:  MOVFF  71A,746
0341E:  MOVLB  7
03420:  CLRF   x4D
03422:  CLRF   x4C
03424:  CLRF   x4B
03426:  CLRF   x4A
03428:  MOVLB  0
0342A:  CALL   1D2C
0342E:  BTFSS  FD8.0
03430:  BRA    35CC
03432:  MOVFF  721,725
03436:  MOVFF  720,724
0343A:  MOVFF  71F,723
0343E:  MOVFF  71E,722
03442:  MOVLB  7
03444:  CLRF   x29
03446:  CLRF   x28
03448:  CLRF   x27
0344A:  MOVLW  7F
0344C:  MOVWF  x26
0344E:  MOVLB  0
03450:  CALL   2B06
03454:  MOVFF  03,725
03458:  MOVFF  02,724
0345C:  MOVFF  01,723
03460:  MOVFF  00,722
03464:  MOVFF  03,749
03468:  MOVFF  02,748
0346C:  MOVFF  01,747
03470:  MOVFF  00,746
03474:  MOVLB  7
03476:  CLRF   x4D
03478:  CLRF   x4C
0347A:  CLRF   x4B
0347C:  CLRF   x4A
0347E:  MOVLB  0
03480:  CALL   1D2C
03484:  BTFSS  FD8.2
03486:  BRA    35CC
....................       if(fmod(y, 2) == 0) {
03488:  MOVFF  721,725
0348C:  MOVFF  720,724
03490:  MOVFF  71F,723
03494:  MOVFF  71E,722
03498:  MOVLB  7
0349A:  CLRF   x29
0349C:  CLRF   x28
0349E:  CLRF   x27
034A0:  MOVLW  80
034A2:  MOVWF  x26
034A4:  MOVLB  0
034A6:  CALL   2B06
034AA:  MOVFF  03,725
034AE:  MOVFF  02,724
034B2:  MOVFF  01,723
034B6:  MOVFF  00,722
034BA:  MOVFF  03,749
034BE:  MOVFF  02,748
034C2:  MOVFF  01,747
034C6:  MOVFF  00,746
034CA:  MOVLB  7
034CC:  CLRF   x4D
034CE:  CLRF   x4C
034D0:  CLRF   x4B
034D2:  CLRF   x4A
034D4:  MOVLB  0
034D6:  CALL   1D2C
034DA:  BNZ   3552
....................          return (exp(log(-x) * y));
034DC:  MOVLB  7
034DE:  MOVF   x1B,W
034E0:  XORLW  80
034E2:  MOVWF  x23
034E4:  MOVFF  71D,729
034E8:  MOVFF  71C,728
034EC:  MOVWF  x27
034EE:  MOVFF  71A,726
034F2:  MOVLB  0
034F4:  CALL   2C6C
034F8:  MOVFF  03,725
034FC:  MOVFF  02,724
03500:  MOVFF  01,723
03504:  MOVFF  00,722
03508:  MOVFF  03,753
0350C:  MOVFF  02,752
03510:  MOVFF  01,751
03514:  MOVFF  00,750
03518:  MOVFF  721,757
0351C:  MOVFF  720,756
03520:  MOVFF  71F,755
03524:  MOVFF  71E,754
03528:  CALL   0DA0
0352C:  MOVFF  03,725
03530:  MOVFF  02,724
03534:  MOVFF  01,723
03538:  MOVFF  00,722
0353C:  MOVFF  03,729
03540:  MOVFF  02,728
03544:  MOVFF  01,727
03548:  MOVFF  00,726
0354C:  RCALL  3000
0354E:  BRA    370A
....................       } else {
03550:  BRA    35CA
....................          return (-exp(log(-x) * y));
03552:  MOVLB  7
03554:  MOVF   x1B,W
03556:  XORLW  80
03558:  MOVWF  x23
0355A:  MOVFF  71D,729
0355E:  MOVFF  71C,728
03562:  MOVWF  x27
03564:  MOVFF  71A,726
03568:  MOVLB  0
0356A:  CALL   2C6C
0356E:  MOVFF  03,725
03572:  MOVFF  02,724
03576:  MOVFF  01,723
0357A:  MOVFF  00,722
0357E:  MOVFF  03,753
03582:  MOVFF  02,752
03586:  MOVFF  01,751
0358A:  MOVFF  00,750
0358E:  MOVFF  721,757
03592:  MOVFF  720,756
03596:  MOVFF  71F,755
0359A:  MOVFF  71E,754
0359E:  CALL   0DA0
035A2:  MOVFF  03,725
035A6:  MOVFF  02,724
035AA:  MOVFF  01,723
035AE:  MOVFF  00,722
035B2:  MOVFF  03,729
035B6:  MOVFF  02,728
035BA:  MOVFF  01,727
035BE:  MOVFF  00,726
035C2:  RCALL  3000
035C4:  MOVLW  80
035C6:  XORWF  01,F
035C8:  BRA    370A
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
035CA:  BRA    370A
035CC:  MOVFF  71D,749
035D0:  MOVFF  71C,748
035D4:  MOVFF  71B,747
035D8:  MOVFF  71A,746
035DC:  MOVLB  7
035DE:  CLRF   x4D
035E0:  CLRF   x4C
035E2:  CLRF   x4B
035E4:  CLRF   x4A
035E6:  MOVLB  0
035E8:  CALL   1D2C
035EC:  BNC   364E
035EE:  MOVFF  721,725
035F2:  MOVFF  720,724
035F6:  MOVFF  71F,723
035FA:  MOVFF  71E,722
035FE:  MOVLB  7
03600:  CLRF   x29
03602:  CLRF   x28
03604:  CLRF   x27
03606:  MOVLW  7F
03608:  MOVWF  x26
0360A:  MOVLB  0
0360C:  CALL   2B06
03610:  MOVFF  03,725
03614:  MOVFF  02,724
03618:  MOVFF  01,723
0361C:  MOVFF  00,722
03620:  MOVFF  03,749
03624:  MOVFF  02,748
03628:  MOVFF  01,747
0362C:  MOVFF  00,746
03630:  MOVLB  7
03632:  CLRF   x4D
03634:  CLRF   x4C
03636:  CLRF   x4B
03638:  CLRF   x4A
0363A:  MOVLB  0
0363C:  CALL   1D2C
03640:  BZ    364E
....................       return 0;
03642:  CLRF   00
03644:  CLRF   01
03646:  CLRF   02
03648:  CLRF   03
0364A:  BRA    370A
....................    } else {
0364C:  BRA    370A
....................       if(x != 0 || 0 >= y) {
0364E:  MOVFF  71D,749
03652:  MOVFF  71C,748
03656:  MOVFF  71B,747
0365A:  MOVFF  71A,746
0365E:  MOVLB  7
03660:  CLRF   x4D
03662:  CLRF   x4C
03664:  CLRF   x4B
03666:  CLRF   x4A
03668:  MOVLB  0
0366A:  CALL   1D2C
0366E:  BNZ   3694
03670:  MOVFF  721,749
03674:  MOVFF  720,748
03678:  MOVFF  71F,747
0367C:  MOVFF  71E,746
03680:  MOVLB  7
03682:  CLRF   x4D
03684:  CLRF   x4C
03686:  CLRF   x4B
03688:  CLRF   x4A
0368A:  MOVLB  0
0368C:  CALL   1D2C
03690:  BC    3694
03692:  BNZ   3702
....................          return (exp(log(x) * y));
03694:  MOVFF  71D,729
03698:  MOVFF  71C,728
0369C:  MOVFF  71B,727
036A0:  MOVFF  71A,726
036A4:  CALL   2C6C
036A8:  MOVFF  03,725
036AC:  MOVFF  02,724
036B0:  MOVFF  01,723
036B4:  MOVFF  00,722
036B8:  MOVFF  03,753
036BC:  MOVFF  02,752
036C0:  MOVFF  01,751
036C4:  MOVFF  00,750
036C8:  MOVFF  721,757
036CC:  MOVFF  720,756
036D0:  MOVFF  71F,755
036D4:  MOVFF  71E,754
036D8:  CALL   0DA0
036DC:  MOVFF  03,725
036E0:  MOVFF  02,724
036E4:  MOVFF  01,723
036E8:  MOVFF  00,722
036EC:  MOVFF  03,729
036F0:  MOVFF  02,728
036F4:  MOVFF  01,727
036F8:  MOVFF  00,726
036FC:  RCALL  3000
036FE:  BRA    370A
....................       } else return 0;
03700:  BRA    370A
03702:  CLRF   00
03704:  CLRF   01
03706:  CLRF   02
03708:  CLRF   03
....................    }
0370A:  RETURN 0
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
*
01F04:  MOVLB  7
01F06:  BCF    x38.0
....................    flag = 0;
01F08:  BCF    x38.1
....................    y = x;
01F0A:  MOVFF  72B,72F
01F0E:  MOVFF  72A,72E
01F12:  MOVFF  729,72D
01F16:  MOVFF  728,72C
.................... 
....................    if (x < 0)
01F1A:  MOVFF  72B,749
01F1E:  MOVFF  72A,748
01F22:  MOVFF  729,747
01F26:  MOVFF  728,746
01F2A:  CLRF   x4D
01F2C:  CLRF   x4C
01F2E:  CLRF   x4B
01F30:  CLRF   x4A
01F32:  MOVLB  0
01F34:  RCALL  1D2C
01F36:  BNC   1F44
....................    {
....................       s = 1;
01F38:  MOVLB  7
01F3A:  BSF    x38.0
....................       y = -y;
01F3C:  MOVF   x2D,W
01F3E:  XORLW  80
01F40:  MOVWF  x2D
01F42:  MOVLB  0
....................    }
.................... 
....................    if (y > 1.0)
01F44:  MOVLB  7
01F46:  CLRF   x49
01F48:  CLRF   x48
01F4A:  CLRF   x47
01F4C:  MOVLW  7F
01F4E:  MOVWF  x46
01F50:  MOVFF  72F,74D
01F54:  MOVFF  72E,74C
01F58:  MOVFF  72D,74B
01F5C:  MOVFF  72C,74A
01F60:  MOVLB  0
01F62:  RCALL  1D2C
01F64:  BNC   1F9C
....................    {
....................       y = 1.0/y;
01F66:  MOVLB  7
01F68:  CLRF   x42
01F6A:  CLRF   x41
01F6C:  CLRF   x40
01F6E:  MOVLW  7F
01F70:  MOVWF  x3F
01F72:  MOVFF  72F,746
01F76:  MOVFF  72E,745
01F7A:  MOVFF  72D,744
01F7E:  MOVFF  72C,743
01F82:  MOVLB  0
01F84:  RCALL  1DA6
01F86:  MOVFF  03,72F
01F8A:  MOVFF  02,72E
01F8E:  MOVFF  01,72D
01F92:  MOVFF  00,72C
....................       flag = 1;
01F96:  MOVLB  7
01F98:  BSF    x38.1
01F9A:  MOVLB  0
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
01F9C:  MOVLW  0A
01F9E:  MOVLB  7
01FA0:  MOVWF  x53
01FA2:  MOVLW  89
01FA4:  MOVWF  x52
01FA6:  MOVLW  34
01FA8:  MOVWF  x51
01FAA:  MOVLW  7C
01FAC:  MOVWF  x50
01FAE:  MOVFF  72F,757
01FB2:  MOVFF  72E,756
01FB6:  MOVFF  72D,755
01FBA:  MOVFF  72C,754
01FBE:  MOVLB  0
01FC0:  CALL   0DA0
01FC4:  MOVFF  03,73C
01FC8:  MOVFF  02,73B
01FCC:  MOVFF  01,73A
01FD0:  MOVFF  00,739
01FD4:  MOVFF  03,753
01FD8:  MOVFF  02,752
01FDC:  MOVFF  01,751
01FE0:  MOVFF  00,750
01FE4:  MOVFF  72F,757
01FE8:  MOVFF  72E,756
01FEC:  MOVFF  72D,755
01FF0:  MOVFF  72C,754
01FF4:  CALL   0DA0
01FF8:  MOVFF  03,73C
01FFC:  MOVFF  02,73B
02000:  MOVFF  01,73A
02004:  MOVFF  00,739
02008:  BCF    FD8.1
0200A:  MOVFF  03,74D
0200E:  MOVFF  02,74C
02012:  MOVFF  01,74B
02016:  MOVFF  00,74A
0201A:  MOVLW  7C
0201C:  MOVLB  7
0201E:  MOVWF  x51
02020:  MOVLW  79
02022:  MOVWF  x50
02024:  MOVLW  35
02026:  MOVWF  x4F
02028:  MOVLW  81
0202A:  MOVWF  x4E
0202C:  MOVLB  0
0202E:  CALL   0E96
02032:  MOVFF  03,733
02036:  MOVFF  02,732
0203A:  MOVFF  01,731
0203E:  MOVFF  00,730
....................    res = res*y*y + pat[2];
02042:  MOVFF  733,753
02046:  MOVFF  732,752
0204A:  MOVFF  731,751
0204E:  MOVFF  730,750
02052:  MOVFF  72F,757
02056:  MOVFF  72E,756
0205A:  MOVFF  72D,755
0205E:  MOVFF  72C,754
02062:  CALL   0DA0
02066:  MOVFF  03,73C
0206A:  MOVFF  02,73B
0206E:  MOVFF  01,73A
02072:  MOVFF  00,739
02076:  MOVFF  03,753
0207A:  MOVFF  02,752
0207E:  MOVFF  01,751
02082:  MOVFF  00,750
02086:  MOVFF  72F,757
0208A:  MOVFF  72E,756
0208E:  MOVFF  72D,755
02092:  MOVFF  72C,754
02096:  CALL   0DA0
0209A:  MOVFF  03,73C
0209E:  MOVFF  02,73B
020A2:  MOVFF  01,73A
020A6:  MOVFF  00,739
020AA:  BCF    FD8.1
020AC:  MOVFF  03,74D
020B0:  MOVFF  02,74C
020B4:  MOVFF  01,74B
020B8:  MOVFF  00,74A
020BC:  MOVLW  3F
020BE:  MOVLB  7
020C0:  MOVWF  x51
020C2:  MOVLW  02
020C4:  MOVWF  x50
020C6:  MOVLW  33
020C8:  MOVWF  x4F
020CA:  MOVLW  83
020CC:  MOVWF  x4E
020CE:  MOVLB  0
020D0:  CALL   0E96
020D4:  MOVFF  03,733
020D8:  MOVFF  02,732
020DC:  MOVFF  01,731
020E0:  MOVFF  00,730
....................    res = res*y*y + pat[3];
020E4:  MOVFF  733,753
020E8:  MOVFF  732,752
020EC:  MOVFF  731,751
020F0:  MOVFF  730,750
020F4:  MOVFF  72F,757
020F8:  MOVFF  72E,756
020FC:  MOVFF  72D,755
02100:  MOVFF  72C,754
02104:  CALL   0DA0
02108:  MOVFF  03,73C
0210C:  MOVFF  02,73B
02110:  MOVFF  01,73A
02114:  MOVFF  00,739
02118:  MOVFF  03,753
0211C:  MOVFF  02,752
02120:  MOVFF  01,751
02124:  MOVFF  00,750
02128:  MOVFF  72F,757
0212C:  MOVFF  72E,756
02130:  MOVFF  72D,755
02134:  MOVFF  72C,754
02138:  CALL   0DA0
0213C:  MOVFF  03,73C
02140:  MOVFF  02,73B
02144:  MOVFF  01,73A
02148:  MOVFF  00,739
0214C:  BCF    FD8.1
0214E:  MOVFF  03,74D
02152:  MOVFF  02,74C
02156:  MOVFF  01,74B
0215A:  MOVFF  00,74A
0215E:  MOVLW  33
02160:  MOVLB  7
02162:  MOVWF  x51
02164:  MOVLW  8C
02166:  MOVWF  x50
02168:  MOVLW  1E
0216A:  MOVWF  x4F
0216C:  MOVLW  83
0216E:  MOVWF  x4E
02170:  MOVLB  0
02172:  CALL   0E96
02176:  MOVFF  03,733
0217A:  MOVFF  02,732
0217E:  MOVFF  01,731
02182:  MOVFF  00,730
.................... 
....................    r = qat[0]*y*y + qat[1];
02186:  MOVLB  7
02188:  CLRF   x53
0218A:  CLRF   x52
0218C:  CLRF   x51
0218E:  MOVLW  7F
02190:  MOVWF  x50
02192:  MOVFF  72F,757
02196:  MOVFF  72E,756
0219A:  MOVFF  72D,755
0219E:  MOVFF  72C,754
021A2:  MOVLB  0
021A4:  CALL   0DA0
021A8:  MOVFF  03,73C
021AC:  MOVFF  02,73B
021B0:  MOVFF  01,73A
021B4:  MOVFF  00,739
021B8:  MOVFF  03,753
021BC:  MOVFF  02,752
021C0:  MOVFF  01,751
021C4:  MOVFF  00,750
021C8:  MOVFF  72F,757
021CC:  MOVFF  72E,756
021D0:  MOVFF  72D,755
021D4:  MOVFF  72C,754
021D8:  CALL   0DA0
021DC:  MOVFF  03,73C
021E0:  MOVFF  02,73B
021E4:  MOVFF  01,73A
021E8:  MOVFF  00,739
021EC:  BCF    FD8.1
021EE:  MOVFF  03,74D
021F2:  MOVFF  02,74C
021F6:  MOVFF  01,74B
021FA:  MOVFF  00,74A
021FE:  MOVLW  1B
02200:  MOVLB  7
02202:  MOVWF  x51
02204:  MOVLW  E4
02206:  MOVWF  x50
02208:  MOVLW  35
0220A:  MOVWF  x4F
0220C:  MOVLW  82
0220E:  MOVWF  x4E
02210:  MOVLB  0
02212:  CALL   0E96
02216:  MOVFF  03,737
0221A:  MOVFF  02,736
0221E:  MOVFF  01,735
02222:  MOVFF  00,734
....................    r = r*y*y + qat[2];
02226:  MOVFF  737,753
0222A:  MOVFF  736,752
0222E:  MOVFF  735,751
02232:  MOVFF  734,750
02236:  MOVFF  72F,757
0223A:  MOVFF  72E,756
0223E:  MOVFF  72D,755
02242:  MOVFF  72C,754
02246:  CALL   0DA0
0224A:  MOVFF  03,73C
0224E:  MOVFF  02,73B
02252:  MOVFF  01,73A
02256:  MOVFF  00,739
0225A:  MOVFF  03,753
0225E:  MOVFF  02,752
02262:  MOVFF  01,751
02266:  MOVFF  00,750
0226A:  MOVFF  72F,757
0226E:  MOVFF  72E,756
02272:  MOVFF  72D,755
02276:  MOVFF  72C,754
0227A:  CALL   0DA0
0227E:  MOVFF  03,73C
02282:  MOVFF  02,73B
02286:  MOVFF  01,73A
0228A:  MOVFF  00,739
0228E:  BCF    FD8.1
02290:  MOVFF  03,74D
02294:  MOVFF  02,74C
02298:  MOVFF  01,74B
0229C:  MOVFF  00,74A
022A0:  MOVLW  A4
022A2:  MOVLB  7
022A4:  MOVWF  x51
022A6:  MOVLW  DB
022A8:  MOVWF  x50
022AA:  MOVLW  67
022AC:  MOVWF  x4F
022AE:  MOVLW  83
022B0:  MOVWF  x4E
022B2:  MOVLB  0
022B4:  CALL   0E96
022B8:  MOVFF  03,737
022BC:  MOVFF  02,736
022C0:  MOVFF  01,735
022C4:  MOVFF  00,734
....................    r = r*y*y + qat[3];
022C8:  MOVFF  737,753
022CC:  MOVFF  736,752
022D0:  MOVFF  735,751
022D4:  MOVFF  734,750
022D8:  MOVFF  72F,757
022DC:  MOVFF  72E,756
022E0:  MOVFF  72D,755
022E4:  MOVFF  72C,754
022E8:  CALL   0DA0
022EC:  MOVFF  03,73C
022F0:  MOVFF  02,73B
022F4:  MOVFF  01,73A
022F8:  MOVFF  00,739
022FC:  MOVFF  03,753
02300:  MOVFF  02,752
02304:  MOVFF  01,751
02308:  MOVFF  00,750
0230C:  MOVFF  72F,757
02310:  MOVFF  72E,756
02314:  MOVFF  72D,755
02318:  MOVFF  72C,754
0231C:  CALL   0DA0
02320:  MOVFF  03,73C
02324:  MOVFF  02,73B
02328:  MOVFF  01,73A
0232C:  MOVFF  00,739
02330:  BCF    FD8.1
02332:  MOVFF  03,74D
02336:  MOVFF  02,74C
0233A:  MOVFF  01,74B
0233E:  MOVFF  00,74A
02342:  MOVLW  33
02344:  MOVLB  7
02346:  MOVWF  x51
02348:  MOVLW  8C
0234A:  MOVWF  x50
0234C:  MOVLW  1E
0234E:  MOVWF  x4F
02350:  MOVLW  83
02352:  MOVWF  x4E
02354:  MOVLB  0
02356:  CALL   0E96
0235A:  MOVFF  03,737
0235E:  MOVFF  02,736
02362:  MOVFF  01,735
02366:  MOVFF  00,734
.................... 
....................    res = y*res/r;
0236A:  MOVFF  72F,753
0236E:  MOVFF  72E,752
02372:  MOVFF  72D,751
02376:  MOVFF  72C,750
0237A:  MOVFF  733,757
0237E:  MOVFF  732,756
02382:  MOVFF  731,755
02386:  MOVFF  730,754
0238A:  CALL   0DA0
0238E:  MOVFF  03,73C
02392:  MOVFF  02,73B
02396:  MOVFF  01,73A
0239A:  MOVFF  00,739
0239E:  MOVFF  03,742
023A2:  MOVFF  02,741
023A6:  MOVFF  01,740
023AA:  MOVFF  00,73F
023AE:  MOVFF  737,746
023B2:  MOVFF  736,745
023B6:  MOVFF  735,744
023BA:  MOVFF  734,743
023BE:  RCALL  1DA6
023C0:  MOVFF  03,733
023C4:  MOVFF  02,732
023C8:  MOVFF  01,731
023CC:  MOVFF  00,730
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
023D0:  MOVLB  7
023D2:  BTFSS  x38.1
023D4:  BRA    2410
....................       res = PI_DIV_BY_TWO - res;
023D6:  BSF    FD8.1
023D8:  MOVLW  DB
023DA:  MOVWF  x4D
023DC:  MOVLW  0F
023DE:  MOVWF  x4C
023E0:  MOVLW  49
023E2:  MOVWF  x4B
023E4:  MOVLW  7F
023E6:  MOVWF  x4A
023E8:  MOVFF  733,751
023EC:  MOVFF  732,750
023F0:  MOVFF  731,74F
023F4:  MOVFF  730,74E
023F8:  MOVLB  0
023FA:  CALL   0E96
023FE:  MOVFF  03,733
02402:  MOVFF  02,732
02406:  MOVFF  01,731
0240A:  MOVFF  00,730
0240E:  MOVLB  7
....................    if (s)
02410:  BTFSS  x38.0
02412:  BRA    241A
....................       res = -res;
02414:  MOVF   x31,W
02416:  XORLW  80
02418:  MOVWF  x31
.................... 
....................    return(res);
0241A:  MOVFF  730,00
0241E:  MOVFF  731,01
02422:  MOVFF  732,02
02426:  MOVFF  733,03
0242A:  MOVLB  0
0242C:  RETURN 0
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
0242E:  MOVLB  7
02430:  BCF    x26.0
....................    quad=0; //quadrant
02432:  CLRF   x27
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
02434:  MOVFF  71D,749
02438:  MOVFF  71C,748
0243C:  MOVFF  71B,747
02440:  MOVFF  71A,746
02444:  CLRF   x4D
02446:  CLRF   x4C
02448:  CLRF   x4B
0244A:  CLRF   x4A
0244C:  MOVLB  0
0244E:  RCALL  1D2C
02450:  BC    2454
02452:  BNZ   247E
02454:  MOVFF  721,749
02458:  MOVFF  720,748
0245C:  MOVFF  71F,747
02460:  MOVFF  71E,746
02464:  MOVLB  7
02466:  CLRF   x4D
02468:  CLRF   x4C
0246A:  CLRF   x4B
0246C:  CLRF   x4A
0246E:  MOVLB  0
02470:  RCALL  1D2C
02472:  BC    2476
02474:  BNZ   247A
02476:  MOVLW  03
02478:  BRA    247C
0247A:  MOVLW  04
0247C:  BRA    24A4
0247E:  MOVFF  721,749
02482:  MOVFF  720,748
02486:  MOVFF  71F,747
0248A:  MOVFF  71E,746
0248E:  MOVLB  7
02490:  CLRF   x4D
02492:  CLRF   x4C
02494:  CLRF   x4B
02496:  CLRF   x4A
02498:  MOVLB  0
0249A:  RCALL  1D2C
0249C:  BNC   24A2
0249E:  MOVLW  02
024A0:  BRA    24A4
024A2:  MOVLW  01
024A4:  MOVLB  7
024A6:  MOVWF  x27
....................    if(y<0.0)
024A8:  MOVFF  71D,749
024AC:  MOVFF  71C,748
024B0:  MOVFF  71B,747
024B4:  MOVFF  71A,746
024B8:  CLRF   x4D
024BA:  CLRF   x4C
024BC:  CLRF   x4B
024BE:  CLRF   x4A
024C0:  MOVLB  0
024C2:  RCALL  1D2C
024C4:  BNC   24D2
....................    {
....................       sign=1;
024C6:  MOVLB  7
024C8:  BSF    x26.0
....................       y=-y;
024CA:  MOVF   x1B,W
024CC:  XORLW  80
024CE:  MOVWF  x1B
024D0:  MOVLB  0
....................    }
....................    if(x<0.0)
024D2:  MOVFF  721,749
024D6:  MOVFF  720,748
024DA:  MOVFF  71F,747
024DE:  MOVFF  71E,746
024E2:  MOVLB  7
024E4:  CLRF   x4D
024E6:  CLRF   x4C
024E8:  CLRF   x4B
024EA:  CLRF   x4A
024EC:  MOVLB  0
024EE:  RCALL  1D2C
024F0:  BNC   24FC
....................    {
....................       x=-x;
024F2:  MOVLB  7
024F4:  MOVF   x1F,W
024F6:  XORLW  80
024F8:  MOVWF  x1F
024FA:  MOVLB  0
....................    }
....................    if (x==0.0)
024FC:  MOVFF  721,749
02500:  MOVFF  720,748
02504:  MOVFF  71F,747
02508:  MOVFF  71E,746
0250C:  MOVLB  7
0250E:  CLRF   x4D
02510:  CLRF   x4C
02512:  CLRF   x4B
02514:  CLRF   x4A
02516:  MOVLB  0
02518:  RCALL  1D2C
0251A:  BNZ   2570
....................    {
....................       if(y==0.0)
0251C:  MOVFF  71D,749
02520:  MOVFF  71C,748
02524:  MOVFF  71B,747
02528:  MOVFF  71A,746
0252C:  MOVLB  7
0252E:  CLRF   x4D
02530:  CLRF   x4C
02532:  CLRF   x4B
02534:  CLRF   x4A
02536:  MOVLB  0
02538:  CALL   1D2C
0253C:  BNZ   2540
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
0253E:  BRA    256E
....................       else
....................       {
....................          if(sign)
02540:  MOVLB  7
02542:  BTFSS  x26.0
02544:  BRA    255A
....................          {
....................          return (-(PI_DIV_BY_TWO));
02546:  MOVLW  7F
02548:  MOVWF  00
0254A:  MOVLW  C9
0254C:  MOVWF  01
0254E:  MOVLW  0F
02550:  MOVWF  02
02552:  MOVLW  DB
02554:  MOVWF  03
02556:  BRA    26A8
....................          }
02558:  BRA    256C
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
0255A:  MOVLW  7F
0255C:  MOVWF  00
0255E:  MOVLW  49
02560:  MOVWF  01
02562:  MOVLW  0F
02564:  MOVWF  02
02566:  MOVLW  DB
02568:  MOVWF  03
0256A:  BRA    26A8
0256C:  MOVLB  0
....................          }
....................       }
....................    }
0256E:  BRA    26A6
....................    else
....................    {
....................       z=y/x;
02570:  MOVFF  71D,742
02574:  MOVFF  71C,741
02578:  MOVFF  71B,740
0257C:  MOVFF  71A,73F
02580:  MOVFF  721,746
02584:  MOVFF  720,745
02588:  MOVFF  71F,744
0258C:  MOVFF  71E,743
02590:  RCALL  1DA6
02592:  MOVFF  03,725
02596:  MOVFF  02,724
0259A:  MOVFF  01,723
0259E:  MOVFF  00,722
....................       switch(quad)
025A2:  MOVLW  01
025A4:  MOVLB  7
025A6:  SUBWF  x27,W
025A8:  ADDLW  FC
025AA:  BTFSC  FD8.0
025AC:  BRA    26A8
025AE:  ADDLW  04
025B0:  MOVLB  0
025B2:  GOTO   26AE
....................       {
....................          case 1:
....................          {
....................             return atan(z);
025B6:  MOVFF  725,72B
025BA:  MOVFF  724,72A
025BE:  MOVFF  723,729
025C2:  MOVFF  722,728
025C6:  RCALL  1F04
025C8:  MOVLB  7
025CA:  BRA    26A8
....................             break;
025CC:  BRA    26A8
025CE:  MOVLB  0
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
025D0:  MOVFF  725,72B
025D4:  MOVFF  724,72A
025D8:  MOVFF  723,729
025DC:  MOVFF  722,728
025E0:  RCALL  1F04
025E2:  MOVFF  FEA,729
025E6:  MOVFF  FE9,728
025EA:  BSF    FD8.1
025EC:  MOVLW  DB
025EE:  MOVLB  7
025F0:  MOVWF  x4D
025F2:  MOVLW  0F
025F4:  MOVWF  x4C
025F6:  MOVLW  49
025F8:  MOVWF  x4B
025FA:  MOVLW  80
025FC:  MOVWF  x4A
025FE:  MOVFF  03,751
02602:  MOVFF  02,750
02606:  MOVFF  01,74F
0260A:  MOVFF  00,74E
0260E:  MOVLB  0
02610:  CALL   0E96
02614:  MOVFF  729,FEA
02618:  MOVFF  728,FE9
0261C:  MOVLB  7
0261E:  BRA    26A8
....................             break;
02620:  BRA    26A8
02622:  MOVLB  0
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
02624:  MOVFF  725,72B
02628:  MOVFF  724,72A
0262C:  MOVFF  723,729
02630:  MOVFF  722,728
02634:  RCALL  1F04
02636:  MOVFF  03,72B
0263A:  MOVFF  02,72A
0263E:  MOVFF  01,729
02642:  MOVFF  00,728
02646:  MOVFF  FEA,72D
0264A:  MOVFF  FE9,72C
0264E:  BSF    FD8.1
02650:  MOVFF  03,74D
02654:  MOVFF  02,74C
02658:  MOVFF  01,74B
0265C:  MOVFF  00,74A
02660:  MOVLW  DB
02662:  MOVLB  7
02664:  MOVWF  x51
02666:  MOVLW  0F
02668:  MOVWF  x50
0266A:  MOVLW  49
0266C:  MOVWF  x4F
0266E:  MOVLW  80
02670:  MOVWF  x4E
02672:  MOVLB  0
02674:  CALL   0E96
02678:  MOVFF  72D,FEA
0267C:  MOVFF  72C,FE9
02680:  MOVLB  7
02682:  BRA    26A8
....................             break;
02684:  BRA    26A8
02686:  MOVLB  0
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
02688:  MOVFF  725,72B
0268C:  MOVFF  724,72A
02690:  MOVFF  723,729
02694:  MOVFF  722,728
02698:  RCALL  1F04
0269A:  MOVLW  80
0269C:  XORWF  01,F
0269E:  MOVLB  7
026A0:  BRA    26A8
....................             break;
026A2:  BRA    26A8
026A4:  MOVLB  0
026A6:  MOVLB  7
....................          }
....................       }
....................    }
026A8:  MOVLB  0
026AA:  GOTO   3DB4 (RETURN)
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... #define sensorSampleRate 50 // 50mS delay between each sensor sample = 100ms cadence 
.................... 
.................... #define maxCount 16777216.0   // ADC max count
.................... #define vRef 2.048            // ADC vRef
.................... 
.................... #define sc sensorCal
.................... 
.................... #define vMonN15   6
.................... #define vMon200   16
.................... #define vMon5V6   24
.................... #define vMon5VA   25
.................... #define vMon3V6X  17
.................... #define vMon3V3A  27
.................... #define vMon3V3D  26
.................... 
.................... #define BUFFER_SIZE 5
.................... 
.................... signed int32 sQ_x[BUFFER_SIZE];
.................... signed int32 cQ_x[BUFFER_SIZE];
.................... signed int32 sQ_y[BUFFER_SIZE];
.................... signed int32 cQ_y[BUFFER_SIZE];
.................... int sIn_x=0;
.................... int cIn_x=0;
.................... int sIn_y=0;
.................... int cIn_y=0;
.................... 
.................... struct sensorMonitorData
.................... {
....................    boolean dataReady;
....................    boolean adcBusy;
....................    signed int32 avgSin;
....................    signed int32 avgCos;
.................... } smData[2] = 
.................... {
....................    {false, false, 0, 0},
....................    {false, false, 0, 0}
.................... };
.................... 
.................... void push(signed int32* buff, int* idx, signed int32 newData) {
....................    buff[*idx]=newData;
*
00904:  MOVFF  730,FEA
00908:  MOVLB  7
0090A:  MOVFF  72F,FE9
0090E:  CLRF   x42
00910:  MOVFF  FEF,741
00914:  CLRF   x44
00916:  MOVLW  04
00918:  MOVWF  x43
0091A:  MOVLB  0
0091C:  RCALL  08B6
0091E:  MOVF   01,W
00920:  MOVLB  7
00922:  ADDWF  x2D,W
00924:  MOVWF  FE9
00926:  MOVF   x2E,W
00928:  ADDWFC 02,W
0092A:  MOVWF  FEA
0092C:  MOVFF  731,FEF
00930:  MOVFF  732,FEC
00934:  MOVFF  733,FEC
00938:  MOVFF  734,FEC
....................    *idx=(*idx+1) % BUFFER_SIZE;
0093C:  MOVFF  730,736
00940:  MOVFF  730,FEA
00944:  MOVFF  72F,FE9
00948:  MOVLW  01
0094A:  ADDWF  FEF,W
0094C:  MOVWF  x38
0094E:  MOVWF  x3A
00950:  MOVLW  05
00952:  MOVWF  x3B
00954:  MOVLB  0
00956:  RCALL  08D8
00958:  MOVLB  7
0095A:  MOVFF  736,FEA
0095E:  MOVFF  72F,FE9
00962:  MOVFF  00,FEF
00966:  MOVLB  0
00968:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INTERNAL MONITOR task - gets voltages                                     */
.................... /* gets one value each time the task is run                                  */
.................... /*****************************************************************************/
.................... void internal_monitor_task(){
....................    static int8 state = 0;
....................    if (adc_done()){
*
0110E:  MOVLB  F
01110:  BTFSC  x5B.0
01112:  BRA    165E
....................       switch (state)
01114:  MOVLB  1
01116:  MOVF   xE6,W
01118:  ADDLW  F9
0111A:  BTFSC  FD8.0
0111C:  BRA    165C
0111E:  ADDLW  07
01120:  MOVLB  0
01122:  GOTO   1664
....................       {
....................          case 0:     // vMonN15
....................             monitorVals.vN15 = read_adc(ADC_READ_ONLY) * monCal.vN15[1] + monCal.vN15[0];
01126:  MOVLB  F
01128:  BTFSC  x5B.0
0112A:  BRA    1128
0112C:  MOVFF  F5F,02
01130:  MOVFF  F5E,01
01134:  MOVFF  02,6FC
01138:  MOVFF  01,6FB
0113C:  MOVFF  02,74B
01140:  MOVFF  01,74A
01144:  MOVLB  0
01146:  RCALL  0D6A
01148:  MOVFF  03,753
0114C:  MOVFF  02,752
01150:  MOVFF  01,751
01154:  MOVFF  00,750
01158:  MOVFF  C9,757
0115C:  MOVFF  C8,756
01160:  MOVFF  C7,755
01164:  MOVFF  C6,754
01168:  RCALL  0DA0
0116A:  MOVFF  03,6FE
0116E:  MOVFF  02,6FD
01172:  MOVFF  01,6FC
01176:  MOVFF  00,6FB
0117A:  BCF    FD8.1
0117C:  MOVFF  03,74D
01180:  MOVFF  02,74C
01184:  MOVFF  01,74B
01188:  MOVFF  00,74A
0118C:  MOVFF  C5,751
01190:  MOVFF  C4,750
01194:  MOVFF  C3,74F
01198:  MOVFF  C2,74E
0119C:  RCALL  0E96
0119E:  MOVFF  03,FE
011A2:  MOVFF  02,FD
011A6:  MOVFF  01,FC
011AA:  MOVFF  00,FB
....................             set_adc_channel(vMon200);
011AE:  MOVLB  F
011B0:  MOVF   x5A,W
011B2:  ANDLW  3F
011B4:  MOVWF  01
011B6:  MOVLW  10
011B8:  MOVWF  x5A
011BA:  BTFSS  x5B.7
011BC:  BRA    11CC
011BE:  MOVF   01,W
011C0:  SUBLW  10
011C2:  BZ    11CC
011C4:  BSF    x5B.0
011C6:  NOP   
011C8:  BTFSC  x5B.0
011CA:  BRA    11C8
....................             delay_ms(10);
011CC:  MOVLW  0A
011CE:  MOVLB  7
011D0:  MOVWF  x01
011D2:  MOVLB  0
011D4:  CALL   03CA
....................             read_adc(ADC_START_ONLY);
011D8:  MOVLB  F
011DA:  BSF    x5B.0
011DC:  NOP   
....................             state = 1;
011DE:  MOVLW  01
011E0:  MOVLB  1
011E2:  MOVWF  xE6
....................          break;
011E4:  BRA    165C
....................          
....................          case 1:     // vMon200
....................             monitorVals.v200 = read_adc(ADC_READ_ONLY) * monCal.v200[1] + monCal.v200[0];
011E6:  MOVLB  F
011E8:  BTFSC  x5B.0
011EA:  BRA    11E8
011EC:  MOVFF  F5F,02
011F0:  MOVFF  F5E,01
011F4:  MOVFF  02,6FC
011F8:  MOVFF  01,6FB
011FC:  MOVFF  02,74B
01200:  MOVFF  01,74A
01204:  MOVLB  0
01206:  RCALL  0D6A
01208:  MOVFF  03,753
0120C:  MOVFF  02,752
01210:  MOVFF  01,751
01214:  MOVFF  00,750
01218:  MOVFF  D1,757
0121C:  MOVFF  D0,756
01220:  MOVFF  CF,755
01224:  MOVFF  CE,754
01228:  RCALL  0DA0
0122A:  MOVFF  03,6FE
0122E:  MOVFF  02,6FD
01232:  MOVFF  01,6FC
01236:  MOVFF  00,6FB
0123A:  BCF    FD8.1
0123C:  MOVFF  03,74D
01240:  MOVFF  02,74C
01244:  MOVFF  01,74B
01248:  MOVFF  00,74A
0124C:  MOVFF  CD,751
01250:  MOVFF  CC,750
01254:  MOVFF  CB,74F
01258:  MOVFF  CA,74E
0125C:  RCALL  0E96
0125E:  MOVFF  03,102
01262:  MOVFF  02,101
01266:  MOVFF  01,100
0126A:  MOVFF  00,FF
....................             set_adc_channel(vMon5V6);
0126E:  MOVLB  F
01270:  MOVF   x5A,W
01272:  ANDLW  3F
01274:  MOVWF  01
01276:  MOVLW  18
01278:  MOVWF  x5A
0127A:  BTFSS  x5B.7
0127C:  BRA    128C
0127E:  MOVF   01,W
01280:  SUBLW  18
01282:  BZ    128C
01284:  BSF    x5B.0
01286:  NOP   
01288:  BTFSC  x5B.0
0128A:  BRA    1288
....................             delay_ms(10);
0128C:  MOVLW  0A
0128E:  MOVLB  7
01290:  MOVWF  x01
01292:  MOVLB  0
01294:  CALL   03CA
....................             read_adc(ADC_START_ONLY);
01298:  MOVLB  F
0129A:  BSF    x5B.0
0129C:  NOP   
....................             state = 2;
0129E:  MOVLW  02
012A0:  MOVLB  1
012A2:  MOVWF  xE6
....................          break;
012A4:  BRA    165C
....................          
....................          case 2:     // vMon5V6
....................             monitorVals.v5V6 = read_adc(ADC_READ_ONLY) * monCal.v5V6[1] + monCal.v5V6[0];
012A6:  MOVLB  F
012A8:  BTFSC  x5B.0
012AA:  BRA    12A8
012AC:  MOVFF  F5F,02
012B0:  MOVFF  F5E,01
012B4:  MOVFF  02,6FC
012B8:  MOVFF  01,6FB
012BC:  MOVFF  02,74B
012C0:  MOVFF  01,74A
012C4:  MOVLB  0
012C6:  RCALL  0D6A
012C8:  MOVFF  03,753
012CC:  MOVFF  02,752
012D0:  MOVFF  01,751
012D4:  MOVFF  00,750
012D8:  MOVFF  D9,757
012DC:  MOVFF  D8,756
012E0:  MOVFF  D7,755
012E4:  MOVFF  D6,754
012E8:  RCALL  0DA0
012EA:  MOVFF  03,6FE
012EE:  MOVFF  02,6FD
012F2:  MOVFF  01,6FC
012F6:  MOVFF  00,6FB
012FA:  BCF    FD8.1
012FC:  MOVFF  03,74D
01300:  MOVFF  02,74C
01304:  MOVFF  01,74B
01308:  MOVFF  00,74A
0130C:  MOVFF  D5,751
01310:  MOVFF  D4,750
01314:  MOVFF  D3,74F
01318:  MOVFF  D2,74E
0131C:  RCALL  0E96
0131E:  MOVFF  03,106
01322:  MOVFF  02,105
01326:  MOVFF  01,104
0132A:  MOVFF  00,103
....................             set_adc_channel(vMon5VA);
0132E:  MOVLB  F
01330:  MOVF   x5A,W
01332:  ANDLW  3F
01334:  MOVWF  01
01336:  MOVLW  19
01338:  MOVWF  x5A
0133A:  BTFSS  x5B.7
0133C:  BRA    134C
0133E:  MOVF   01,W
01340:  SUBLW  19
01342:  BZ    134C
01344:  BSF    x5B.0
01346:  NOP   
01348:  BTFSC  x5B.0
0134A:  BRA    1348
....................             delay_ms(10);
0134C:  MOVLW  0A
0134E:  MOVLB  7
01350:  MOVWF  x01
01352:  MOVLB  0
01354:  CALL   03CA
....................             read_adc(ADC_START_ONLY);
01358:  MOVLB  F
0135A:  BSF    x5B.0
0135C:  NOP   
....................             state = 3;
0135E:  MOVLW  03
01360:  MOVLB  1
01362:  MOVWF  xE6
....................          break;
01364:  BRA    165C
....................          
....................          case 3:     // vMon5VA
....................             monitorVals.v5VA = read_adc(ADC_READ_ONLY) * monCal.v5VA[1] + monCal.v5VA[0];
01366:  MOVLB  F
01368:  BTFSC  x5B.0
0136A:  BRA    1368
0136C:  MOVFF  F5F,02
01370:  MOVFF  F5E,01
01374:  MOVFF  02,6FC
01378:  MOVFF  01,6FB
0137C:  MOVFF  02,74B
01380:  MOVFF  01,74A
01384:  MOVLB  0
01386:  RCALL  0D6A
01388:  MOVFF  03,753
0138C:  MOVFF  02,752
01390:  MOVFF  01,751
01394:  MOVFF  00,750
01398:  MOVFF  E1,757
0139C:  MOVFF  E0,756
013A0:  MOVFF  DF,755
013A4:  MOVFF  DE,754
013A8:  RCALL  0DA0
013AA:  MOVFF  03,6FE
013AE:  MOVFF  02,6FD
013B2:  MOVFF  01,6FC
013B6:  MOVFF  00,6FB
013BA:  BCF    FD8.1
013BC:  MOVFF  03,74D
013C0:  MOVFF  02,74C
013C4:  MOVFF  01,74B
013C8:  MOVFF  00,74A
013CC:  MOVFF  DD,751
013D0:  MOVFF  DC,750
013D4:  MOVFF  DB,74F
013D8:  MOVFF  DA,74E
013DC:  RCALL  0E96
013DE:  MOVFF  03,10A
013E2:  MOVFF  02,109
013E6:  MOVFF  01,108
013EA:  MOVFF  00,107
....................             set_adc_channel(vMon3V6X);
013EE:  MOVLB  F
013F0:  MOVF   x5A,W
013F2:  ANDLW  3F
013F4:  MOVWF  01
013F6:  MOVLW  11
013F8:  MOVWF  x5A
013FA:  BTFSS  x5B.7
013FC:  BRA    140C
013FE:  MOVF   01,W
01400:  SUBLW  11
01402:  BZ    140C
01404:  BSF    x5B.0
01406:  NOP   
01408:  BTFSC  x5B.0
0140A:  BRA    1408
....................             delay_ms(10);
0140C:  MOVLW  0A
0140E:  MOVLB  7
01410:  MOVWF  x01
01412:  MOVLB  0
01414:  CALL   03CA
....................             read_adc(ADC_START_ONLY);
01418:  MOVLB  F
0141A:  BSF    x5B.0
0141C:  NOP   
....................             state = 4;
0141E:  MOVLW  04
01420:  MOVLB  1
01422:  MOVWF  xE6
....................          break;
01424:  BRA    165C
....................          
....................          case 4:     // vMon3V6X
....................             monitorVals.v3V6X = read_adc(ADC_READ_ONLY) * monCal.v3V6X[1] + monCal.v3V6X[0];
01426:  MOVLB  F
01428:  BTFSC  x5B.0
0142A:  BRA    1428
0142C:  MOVFF  F5F,02
01430:  MOVFF  F5E,01
01434:  MOVFF  02,6FC
01438:  MOVFF  01,6FB
0143C:  MOVFF  02,74B
01440:  MOVFF  01,74A
01444:  MOVLB  0
01446:  RCALL  0D6A
01448:  MOVFF  03,753
0144C:  MOVFF  02,752
01450:  MOVFF  01,751
01454:  MOVFF  00,750
01458:  MOVFF  E9,757
0145C:  MOVFF  E8,756
01460:  MOVFF  E7,755
01464:  MOVFF  E6,754
01468:  RCALL  0DA0
0146A:  MOVFF  03,6FE
0146E:  MOVFF  02,6FD
01472:  MOVFF  01,6FC
01476:  MOVFF  00,6FB
0147A:  BCF    FD8.1
0147C:  MOVFF  03,74D
01480:  MOVFF  02,74C
01484:  MOVFF  01,74B
01488:  MOVFF  00,74A
0148C:  MOVFF  E5,751
01490:  MOVFF  E4,750
01494:  MOVFF  E3,74F
01498:  MOVFF  E2,74E
0149C:  RCALL  0E96
0149E:  MOVFF  03,10E
014A2:  MOVFF  02,10D
014A6:  MOVFF  01,10C
014AA:  MOVFF  00,10B
....................             set_adc_channel(vMon3V3A);
014AE:  MOVLB  F
014B0:  MOVF   x5A,W
014B2:  ANDLW  3F
014B4:  MOVWF  01
014B6:  MOVLW  1B
014B8:  MOVWF  x5A
014BA:  BTFSS  x5B.7
014BC:  BRA    14CC
014BE:  MOVF   01,W
014C0:  SUBLW  1B
014C2:  BZ    14CC
014C4:  BSF    x5B.0
014C6:  NOP   
014C8:  BTFSC  x5B.0
014CA:  BRA    14C8
....................             delay_ms(10);
014CC:  MOVLW  0A
014CE:  MOVLB  7
014D0:  MOVWF  x01
014D2:  MOVLB  0
014D4:  CALL   03CA
....................             read_adc(ADC_START_ONLY);
014D8:  MOVLB  F
014DA:  BSF    x5B.0
014DC:  NOP   
....................             state = 5;
014DE:  MOVLW  05
014E0:  MOVLB  1
014E2:  MOVWF  xE6
....................          break;
014E4:  BRA    165C
....................          
....................          case 5:     // vMon3V3A
....................             monitorVals.v3V3A = read_adc(ADC_READ_ONLY) * monCal.v3V3A[1] + monCal.v3V3A[0];
014E6:  MOVLB  F
014E8:  BTFSC  x5B.0
014EA:  BRA    14E8
014EC:  MOVFF  F5F,02
014F0:  MOVFF  F5E,01
014F4:  MOVFF  02,6FC
014F8:  MOVFF  01,6FB
014FC:  MOVFF  02,74B
01500:  MOVFF  01,74A
01504:  MOVLB  0
01506:  RCALL  0D6A
01508:  MOVFF  03,753
0150C:  MOVFF  02,752
01510:  MOVFF  01,751
01514:  MOVFF  00,750
01518:  MOVFF  F1,757
0151C:  MOVFF  F0,756
01520:  MOVFF  EF,755
01524:  MOVFF  EE,754
01528:  RCALL  0DA0
0152A:  MOVFF  03,6FE
0152E:  MOVFF  02,6FD
01532:  MOVFF  01,6FC
01536:  MOVFF  00,6FB
0153A:  BCF    FD8.1
0153C:  MOVFF  03,74D
01540:  MOVFF  02,74C
01544:  MOVFF  01,74B
01548:  MOVFF  00,74A
0154C:  MOVFF  ED,751
01550:  MOVFF  EC,750
01554:  MOVFF  EB,74F
01558:  MOVFF  EA,74E
0155C:  RCALL  0E96
0155E:  MOVFF  03,112
01562:  MOVFF  02,111
01566:  MOVFF  01,110
0156A:  MOVFF  00,10F
....................             set_adc_channel(vMon3V3D);
0156E:  MOVLB  F
01570:  MOVF   x5A,W
01572:  ANDLW  3F
01574:  MOVWF  01
01576:  MOVLW  1A
01578:  MOVWF  x5A
0157A:  BTFSS  x5B.7
0157C:  BRA    158C
0157E:  MOVF   01,W
01580:  SUBLW  1A
01582:  BZ    158C
01584:  BSF    x5B.0
01586:  NOP   
01588:  BTFSC  x5B.0
0158A:  BRA    1588
....................             delay_ms(10);
0158C:  MOVLW  0A
0158E:  MOVLB  7
01590:  MOVWF  x01
01592:  MOVLB  0
01594:  CALL   03CA
....................             read_adc(ADC_START_ONLY);
01598:  MOVLB  F
0159A:  BSF    x5B.0
0159C:  NOP   
....................             state = 6;
0159E:  MOVLW  06
015A0:  MOVLB  1
015A2:  MOVWF  xE6
....................          break;
015A4:  BRA    165C
....................          
....................          case 6:    // vMon3V3D
....................             monitorVals.v3V3D = read_adc(ADC_READ_ONLY) * monCal.v3V3D[1] + monCal.v3V3D[0];
015A6:  MOVLB  F
015A8:  BTFSC  x5B.0
015AA:  BRA    15A8
015AC:  MOVFF  F5F,02
015B0:  MOVFF  F5E,01
015B4:  MOVFF  02,6FC
015B8:  MOVFF  01,6FB
015BC:  MOVFF  02,74B
015C0:  MOVFF  01,74A
015C4:  MOVLB  0
015C6:  CALL   0D6A
015CA:  MOVFF  03,753
015CE:  MOVFF  02,752
015D2:  MOVFF  01,751
015D6:  MOVFF  00,750
015DA:  MOVFF  F9,757
015DE:  MOVFF  F8,756
015E2:  MOVFF  F7,755
015E6:  MOVFF  F6,754
015EA:  CALL   0DA0
015EE:  MOVFF  03,6FE
015F2:  MOVFF  02,6FD
015F6:  MOVFF  01,6FC
015FA:  MOVFF  00,6FB
015FE:  BCF    FD8.1
01600:  MOVFF  03,74D
01604:  MOVFF  02,74C
01608:  MOVFF  01,74B
0160C:  MOVFF  00,74A
01610:  MOVFF  F5,751
01614:  MOVFF  F4,750
01618:  MOVFF  F3,74F
0161C:  MOVFF  F2,74E
01620:  RCALL  0E96
01622:  MOVFF  03,116
01626:  MOVFF  02,115
0162A:  MOVFF  01,114
0162E:  MOVFF  00,113
....................             set_adc_channel(vMonN15);
01632:  MOVLB  F
01634:  MOVF   x5A,W
01636:  ANDLW  3F
01638:  MOVWF  01
0163A:  MOVLW  06
0163C:  MOVWF  x5A
0163E:  BTFSS  x5B.7
01640:  BRA    1650
01642:  MOVF   01,W
01644:  SUBLW  06
01646:  BZ    1650
01648:  BSF    x5B.0
0164A:  NOP   
0164C:  BTFSC  x5B.0
0164E:  BRA    164C
....................             read_adc(ADC_START_ONLY);
01650:  BSF    x5B.0
01652:  NOP   
....................             state = 0;
01654:  MOVLB  1
01656:  CLRF   xE6
....................          break;   
01658:  BRA    165C
0165A:  MOVLB  1
0165C:  MOVLB  F
....................       }
....................    }
0165E:  MOVLB  0
01660:  GOTO   A738 (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* PROCESS ADC SENSOR DATA                                                   */
.................... /*****************************************************************************/
.................... void sensor_process_data(int8 ch){
....................    adcVals[ch].sinLast = adcVals[ch].sinCounts;
*
0370C:  MOVLB  7
0370E:  MOVF   x03,W
03710:  MULLW  26
03712:  MOVF   FF3,W
03714:  CLRF   x0D
03716:  MOVWF  x0C
03718:  MOVLW  10
0371A:  ADDWF  x0C,W
0371C:  MOVWF  01
0371E:  MOVLW  00
03720:  ADDWFC x0D,W
03722:  MOVWF  03
03724:  MOVF   01,W
03726:  ADDLW  17
03728:  MOVWF  01
0372A:  MOVLW  01
0372C:  ADDWFC 03,F
0372E:  MOVFF  01,70C
03732:  MOVFF  03,70D
03736:  MOVF   x03,W
03738:  MULLW  26
0373A:  MOVF   FF3,W
0373C:  CLRF   x0F
0373E:  MOVWF  x0E
03740:  MOVLW  08
03742:  ADDWF  x0E,W
03744:  MOVWF  01
03746:  MOVLW  00
03748:  ADDWFC x0F,W
0374A:  MOVWF  03
0374C:  MOVF   01,W
0374E:  ADDLW  17
03750:  MOVWF  FE9
03752:  MOVLW  01
03754:  ADDWFC 03,W
03756:  MOVWF  FEA
03758:  MOVFF  FEF,00
0375C:  MOVFF  FEC,01
03760:  MOVFF  FEC,02
03764:  MOVFF  FEC,03
03768:  MOVFF  70D,FEA
0376C:  MOVFF  70C,FE9
03770:  MOVFF  00,FEF
03774:  MOVFF  01,FEC
03778:  MOVFF  02,FEC
0377C:  MOVFF  03,FEC
....................    adcVals[ch].cosLast = adcVals[ch].cosCounts;
03780:  MOVF   x03,W
03782:  MULLW  26
03784:  MOVF   FF3,W
03786:  CLRF   x0D
03788:  MOVWF  x0C
0378A:  MOVLW  14
0378C:  ADDWF  x0C,W
0378E:  MOVWF  01
03790:  MOVLW  00
03792:  ADDWFC x0D,W
03794:  MOVWF  03
03796:  MOVF   01,W
03798:  ADDLW  17
0379A:  MOVWF  01
0379C:  MOVLW  01
0379E:  ADDWFC 03,F
037A0:  MOVFF  01,70C
037A4:  MOVFF  03,70D
037A8:  MOVF   x03,W
037AA:  MULLW  26
037AC:  MOVF   FF3,W
037AE:  CLRF   x0F
037B0:  MOVWF  x0E
037B2:  MOVLW  0C
037B4:  ADDWF  x0E,W
037B6:  MOVWF  01
037B8:  MOVLW  00
037BA:  ADDWFC x0F,W
037BC:  MOVWF  03
037BE:  MOVF   01,W
037C0:  ADDLW  17
037C2:  MOVWF  FE9
037C4:  MOVLW  01
037C6:  ADDWFC 03,W
037C8:  MOVWF  FEA
037CA:  MOVFF  FEF,00
037CE:  MOVFF  FEC,01
037D2:  MOVFF  FEC,02
037D6:  MOVFF  FEC,03
037DA:  MOVFF  70D,FEA
037DE:  MOVFF  70C,FE9
037E2:  MOVFF  00,FEF
037E6:  MOVFF  01,FEC
037EA:  MOVFF  02,FEC
037EE:  MOVFF  03,FEC
....................    
....................    adcVals[ch].sinRaw = (float)smData[ch].avgSin;
037F2:  MOVF   x03,W
037F4:  MULLW  26
037F6:  MOVF   FF3,W
037F8:  CLRF   x0D
037FA:  MOVWF  x0C
037FC:  MOVLW  17
037FE:  ADDWF  x0C,W
03800:  MOVWF  01
03802:  MOVLW  01
03804:  ADDWFC x0D,W
03806:  MOVWF  03
03808:  MOVFF  01,70E
0380C:  MOVWF  x0F
0380E:  MOVF   x03,W
03810:  MULLW  09
03812:  MOVF   FF3,W
03814:  CLRF   x11
03816:  MOVWF  x10
03818:  MOVLW  01
0381A:  ADDWF  x10,W
0381C:  MOVWF  01
0381E:  MOVLW  00
03820:  ADDWFC x11,W
03822:  MOVWF  03
03824:  MOVF   01,W
03826:  ADDLW  D4
03828:  MOVWF  FE9
0382A:  MOVLW  01
0382C:  ADDWFC 03,W
0382E:  MOVWF  FEA
03830:  MOVFF  FEF,710
03834:  MOVFF  FEC,01
03838:  MOVFF  FEC,02
0383C:  MOVFF  FEC,03
03840:  MOVFF  03,713
03844:  MOVFF  02,712
03848:  MOVFF  01,711
0384C:  MOVLB  0
0384E:  CALL   1CD2
03852:  MOVFF  70F,FEA
03856:  MOVFF  70E,FE9
0385A:  MOVFF  00,FEF
0385E:  MOVFF  01,FEC
03862:  MOVFF  02,FEC
03866:  MOVFF  03,FEC
....................    adcVals[ch].cosRaw = (float)smData[ch].avgCos;
0386A:  MOVLB  7
0386C:  MOVF   x03,W
0386E:  MULLW  26
03870:  MOVF   FF3,W
03872:  CLRF   x0D
03874:  MOVWF  x0C
03876:  MOVLW  04
03878:  ADDWF  x0C,W
0387A:  MOVWF  01
0387C:  MOVLW  00
0387E:  ADDWFC x0D,W
03880:  MOVWF  03
03882:  MOVF   01,W
03884:  ADDLW  17
03886:  MOVWF  01
03888:  MOVLW  01
0388A:  ADDWFC 03,F
0388C:  MOVFF  01,70C
03890:  MOVFF  03,70D
03894:  MOVF   x03,W
03896:  MULLW  09
03898:  MOVF   FF3,W
0389A:  CLRF   x0F
0389C:  MOVWF  x0E
0389E:  MOVLW  05
038A0:  ADDWF  x0E,W
038A2:  MOVWF  01
038A4:  MOVLW  00
038A6:  ADDWFC x0F,W
038A8:  MOVWF  03
038AA:  MOVF   01,W
038AC:  ADDLW  D4
038AE:  MOVWF  FE9
038B0:  MOVLW  01
038B2:  ADDWFC 03,W
038B4:  MOVWF  FEA
038B6:  MOVFF  FEF,710
038BA:  MOVFF  FEC,01
038BE:  MOVFF  FEC,02
038C2:  MOVFF  FEC,03
038C6:  MOVFF  03,713
038CA:  MOVFF  02,712
038CE:  MOVFF  01,711
038D2:  MOVLB  0
038D4:  CALL   1CD2
038D8:  MOVFF  70D,FEA
038DC:  MOVFF  70C,FE9
038E0:  MOVFF  00,FEF
038E4:  MOVFF  01,FEC
038E8:  MOVFF  02,FEC
038EC:  MOVFF  03,FEC
....................    
....................    adcVals[ch].sinCounts = adcVals[ch].sinRaw * adcCal[ch].sinGain + adcCal[ch].sinOS;
038F0:  MOVLB  7
038F2:  MOVF   x03,W
038F4:  MULLW  26
038F6:  MOVF   FF3,W
038F8:  CLRF   x0D
038FA:  MOVWF  x0C
038FC:  MOVLW  08
038FE:  ADDWF  x0C,W
03900:  MOVWF  01
03902:  MOVLW  00
03904:  ADDWFC x0D,W
03906:  MOVWF  03
03908:  MOVF   01,W
0390A:  ADDLW  17
0390C:  MOVWF  01
0390E:  MOVLW  01
03910:  ADDWFC 03,F
03912:  MOVFF  01,70C
03916:  MOVFF  03,70D
0391A:  MOVF   x03,W
0391C:  MULLW  26
0391E:  MOVF   FF3,W
03920:  CLRF   x0F
03922:  MOVWF  x0E
03924:  MOVLW  17
03926:  ADDWF  x0E,W
03928:  MOVWF  FE9
0392A:  MOVLW  01
0392C:  ADDWFC x0F,W
0392E:  MOVWF  FEA
03930:  MOVFF  FEF,750
03934:  MOVFF  FEC,751
03938:  MOVFF  FEC,752
0393C:  MOVFF  FEC,753
03940:  MOVF   x03,W
03942:  MULLW  10
03944:  MOVF   FF3,W
03946:  CLRF   x15
03948:  MOVWF  x14
0394A:  MOVLW  08
0394C:  ADDWF  x14,W
0394E:  MOVWF  01
03950:  MOVLW  00
03952:  ADDWFC x15,W
03954:  MOVWF  03
03956:  MOVF   01,W
03958:  ADDLW  72
0395A:  MOVWF  FE9
0395C:  MOVLW  00
0395E:  ADDWFC 03,W
03960:  MOVWF  FEA
03962:  MOVFF  FEF,754
03966:  MOVFF  FEC,01
0396A:  MOVFF  FEC,02
0396E:  MOVFF  FEC,03
03972:  MOVFF  03,757
03976:  MOVFF  02,756
0397A:  MOVFF  01,755
0397E:  MOVLB  0
03980:  CALL   0DA0
03984:  MOVFF  03,74D
03988:  MOVFF  02,74C
0398C:  MOVFF  01,74B
03990:  MOVFF  00,74A
03994:  MOVLB  7
03996:  MOVF   x03,W
03998:  MULLW  10
0399A:  MOVF   FF3,W
0399C:  CLRF   x15
0399E:  MOVWF  x14
039A0:  MOVLW  72
039A2:  ADDWF  x14,W
039A4:  MOVWF  FE9
039A6:  MOVLW  00
039A8:  ADDWFC x15,W
039AA:  MOVWF  FEA
039AC:  MOVFF  FEF,74E
039B0:  MOVFF  FEC,01
039B4:  MOVFF  FEC,02
039B8:  MOVFF  FEC,03
039BC:  BCF    FD8.1
039BE:  MOVFF  03,751
039C2:  MOVFF  02,750
039C6:  MOVFF  01,74F
039CA:  MOVLB  0
039CC:  CALL   0E96
039D0:  MOVFF  70D,FEA
039D4:  MOVFF  70C,FE9
039D8:  MOVFF  00,FEF
039DC:  MOVFF  01,FEC
039E0:  MOVFF  02,FEC
039E4:  MOVFF  03,FEC
....................    adcVals[ch].cosCounts = adcVals[ch].cosRaw * adcCal[ch].cosGain + adcCal[ch].cosOS;
039E8:  MOVLB  7
039EA:  MOVF   x03,W
039EC:  MULLW  26
039EE:  MOVF   FF3,W
039F0:  CLRF   x0D
039F2:  MOVWF  x0C
039F4:  MOVLW  0C
039F6:  ADDWF  x0C,W
039F8:  MOVWF  01
039FA:  MOVLW  00
039FC:  ADDWFC x0D,W
039FE:  MOVWF  03
03A00:  MOVF   01,W
03A02:  ADDLW  17
03A04:  MOVWF  01
03A06:  MOVLW  01
03A08:  ADDWFC 03,F
03A0A:  MOVFF  01,70C
03A0E:  MOVFF  03,70D
03A12:  MOVF   x03,W
03A14:  MULLW  26
03A16:  MOVF   FF3,W
03A18:  CLRF   x0F
03A1A:  MOVWF  x0E
03A1C:  MOVLW  04
03A1E:  ADDWF  x0E,W
03A20:  MOVWF  01
03A22:  MOVLW  00
03A24:  ADDWFC x0F,W
03A26:  MOVWF  03
03A28:  MOVF   01,W
03A2A:  ADDLW  17
03A2C:  MOVWF  FE9
03A2E:  MOVLW  01
03A30:  ADDWFC 03,W
03A32:  MOVWF  FEA
03A34:  MOVFF  FEF,750
03A38:  MOVFF  FEC,751
03A3C:  MOVFF  FEC,752
03A40:  MOVFF  FEC,753
03A44:  MOVF   x03,W
03A46:  MULLW  10
03A48:  MOVF   FF3,W
03A4A:  CLRF   x13
03A4C:  MOVWF  x12
03A4E:  MOVLW  0C
03A50:  ADDWF  x12,W
03A52:  MOVWF  01
03A54:  MOVLW  00
03A56:  ADDWFC x13,W
03A58:  MOVWF  03
03A5A:  MOVF   01,W
03A5C:  ADDLW  72
03A5E:  MOVWF  FE9
03A60:  MOVLW  00
03A62:  ADDWFC 03,W
03A64:  MOVWF  FEA
03A66:  MOVFF  FEF,754
03A6A:  MOVFF  FEC,01
03A6E:  MOVFF  FEC,02
03A72:  MOVFF  FEC,03
03A76:  MOVFF  03,757
03A7A:  MOVFF  02,756
03A7E:  MOVFF  01,755
03A82:  MOVLB  0
03A84:  CALL   0DA0
03A88:  MOVFF  03,74D
03A8C:  MOVFF  02,74C
03A90:  MOVFF  01,74B
03A94:  MOVFF  00,74A
03A98:  MOVLB  7
03A9A:  MOVF   x03,W
03A9C:  MULLW  10
03A9E:  MOVF   FF3,W
03AA0:  CLRF   x13
03AA2:  MOVWF  x12
03AA4:  MOVLW  04
03AA6:  ADDWF  x12,W
03AA8:  MOVWF  01
03AAA:  MOVLW  00
03AAC:  ADDWFC x13,W
03AAE:  MOVWF  03
03AB0:  MOVF   01,W
03AB2:  ADDLW  72
03AB4:  MOVWF  FE9
03AB6:  MOVLW  00
03AB8:  ADDWFC 03,W
03ABA:  MOVWF  FEA
03ABC:  MOVFF  FEF,74E
03AC0:  MOVFF  FEC,01
03AC4:  MOVFF  FEC,02
03AC8:  MOVFF  FEC,03
03ACC:  BCF    FD8.1
03ACE:  MOVFF  03,751
03AD2:  MOVFF  02,750
03AD6:  MOVFF  01,74F
03ADA:  MOVLB  0
03ADC:  CALL   0E96
03AE0:  MOVFF  70D,FEA
03AE4:  MOVFF  70C,FE9
03AE8:  MOVFF  00,FEF
03AEC:  MOVFF  01,FEC
03AF0:  MOVFF  02,FEC
03AF4:  MOVFF  03,FEC
....................    float pTmp = 0;
....................    float polePitch = magPP;
03AF8:  MOVLB  7
03AFA:  CLRF   x07
03AFC:  CLRF   x06
03AFE:  CLRF   x05
03B00:  CLRF   x04
03B02:  CLRF   x0B
03B04:  CLRF   x0A
03B06:  CLRF   x09
03B08:  MOVLW  7F
03B0A:  MOVWF  x08
....................    
....................    if (adcVals[ch].cosCounts < 0){
03B0C:  MOVF   x03,W
03B0E:  MULLW  26
03B10:  MOVF   FF3,W
03B12:  CLRF   x0D
03B14:  MOVWF  x0C
03B16:  MOVLW  0C
03B18:  ADDWF  x0C,W
03B1A:  MOVWF  01
03B1C:  MOVLW  00
03B1E:  ADDWFC x0D,W
03B20:  MOVWF  03
03B22:  MOVF   01,W
03B24:  ADDLW  17
03B26:  MOVWF  FE9
03B28:  MOVLW  01
03B2A:  ADDWFC 03,W
03B2C:  MOVWF  FEA
03B2E:  MOVFF  FEF,746
03B32:  MOVFF  FEC,747
03B36:  MOVFF  FEC,748
03B3A:  MOVFF  FEC,749
03B3E:  CLRF   x4D
03B40:  CLRF   x4C
03B42:  CLRF   x4B
03B44:  CLRF   x4A
03B46:  MOVLB  0
03B48:  CALL   1D2C
03B4C:  BTFSS  FD8.0
03B4E:  BRA    3CB8
....................       if ((adcVals[ch].sinCounts > 0) && (adcVals[ch].sinLast < 0)){
03B50:  MOVLB  7
03B52:  MOVF   x03,W
03B54:  MULLW  26
03B56:  MOVF   FF3,W
03B58:  CLRF   x0D
03B5A:  MOVWF  x0C
03B5C:  MOVLW  08
03B5E:  ADDWF  x0C,W
03B60:  MOVWF  01
03B62:  MOVLW  00
03B64:  ADDWFC x0D,W
03B66:  MOVWF  03
03B68:  MOVF   01,W
03B6A:  ADDLW  17
03B6C:  MOVWF  FE9
03B6E:  MOVLW  01
03B70:  ADDWFC 03,W
03B72:  MOVWF  FEA
03B74:  MOVFF  FEF,74A
03B78:  MOVFF  FEC,70D
03B7C:  MOVFF  FEC,74C
03B80:  MOVFF  FEC,74D
03B84:  CLRF   x49
03B86:  CLRF   x48
03B88:  CLRF   x47
03B8A:  CLRF   x46
03B8C:  MOVFF  70D,74B
03B90:  MOVLB  0
03B92:  CALL   1D2C
03B96:  BNC   3C04
03B98:  MOVLB  7
03B9A:  MOVF   x03,W
03B9C:  MULLW  26
03B9E:  MOVF   FF3,W
03BA0:  CLRF   x0D
03BA2:  MOVWF  x0C
03BA4:  MOVLW  10
03BA6:  ADDWF  x0C,W
03BA8:  MOVWF  01
03BAA:  MOVLW  00
03BAC:  ADDWFC x0D,W
03BAE:  MOVWF  03
03BB0:  MOVF   01,W
03BB2:  ADDLW  17
03BB4:  MOVWF  FE9
03BB6:  MOVLW  01
03BB8:  ADDWFC 03,W
03BBA:  MOVWF  FEA
03BBC:  MOVFF  FEF,746
03BC0:  MOVFF  FEC,747
03BC4:  MOVFF  FEC,748
03BC8:  MOVFF  FEC,749
03BCC:  CLRF   x4D
03BCE:  CLRF   x4C
03BD0:  CLRF   x4B
03BD2:  CLRF   x4A
03BD4:  MOVLB  0
03BD6:  CALL   1D2C
03BDA:  BNC   3C04
....................          adcVals[ch].npoles--;
03BDC:  MOVLB  7
03BDE:  MOVF   x03,W
03BE0:  MULLW  26
03BE2:  MOVF   FF3,W
03BE4:  CLRF   x0D
03BE6:  MOVWF  x0C
03BE8:  MOVLW  1C
03BEA:  ADDWF  x0C,W
03BEC:  MOVWF  01
03BEE:  MOVLW  00
03BF0:  ADDWFC x0D,W
03BF2:  MOVWF  03
03BF4:  MOVF   01,W
03BF6:  ADDLW  17
03BF8:  MOVWF  FE9
03BFA:  MOVLW  01
03BFC:  ADDWFC 03,W
03BFE:  MOVWF  FEA
03C00:  DECF   FEF,F
....................       }
03C02:  BRA    3CB6
....................       else if ((adcVals[ch].sinCounts < 0) && (adcVals[ch].sinLast > 0)){
03C04:  MOVLB  7
03C06:  MOVF   x03,W
03C08:  MULLW  26
03C0A:  MOVF   FF3,W
03C0C:  CLRF   x0D
03C0E:  MOVWF  x0C
03C10:  MOVLW  08
03C12:  ADDWF  x0C,W
03C14:  MOVWF  01
03C16:  MOVLW  00
03C18:  ADDWFC x0D,W
03C1A:  MOVWF  03
03C1C:  MOVF   01,W
03C1E:  ADDLW  17
03C20:  MOVWF  FE9
03C22:  MOVLW  01
03C24:  ADDWFC 03,W
03C26:  MOVWF  FEA
03C28:  MOVFF  FEF,746
03C2C:  MOVFF  FEC,70D
03C30:  MOVFF  FEC,748
03C34:  MOVFF  FEC,749
03C38:  MOVFF  70D,747
03C3C:  CLRF   x4D
03C3E:  CLRF   x4C
03C40:  CLRF   x4B
03C42:  CLRF   x4A
03C44:  MOVLB  0
03C46:  CALL   1D2C
03C4A:  BNC   3CB8
03C4C:  MOVLB  7
03C4E:  MOVF   x03,W
03C50:  MULLW  26
03C52:  MOVF   FF3,W
03C54:  CLRF   x0D
03C56:  MOVWF  x0C
03C58:  MOVLW  10
03C5A:  ADDWF  x0C,W
03C5C:  MOVWF  01
03C5E:  MOVLW  00
03C60:  ADDWFC x0D,W
03C62:  MOVWF  03
03C64:  MOVF   01,W
03C66:  ADDLW  17
03C68:  MOVWF  FE9
03C6A:  MOVLW  01
03C6C:  ADDWFC 03,W
03C6E:  MOVWF  FEA
03C70:  MOVFF  FEF,74A
03C74:  MOVFF  FEC,74B
03C78:  MOVFF  FEC,74C
03C7C:  MOVFF  FEC,74D
03C80:  CLRF   x49
03C82:  CLRF   x48
03C84:  CLRF   x47
03C86:  CLRF   x46
03C88:  MOVLB  0
03C8A:  CALL   1D2C
03C8E:  BNC   3CB8
....................          adcVals[ch].npoles++;
03C90:  MOVLB  7
03C92:  MOVF   x03,W
03C94:  MULLW  26
03C96:  MOVF   FF3,W
03C98:  CLRF   x0D
03C9A:  MOVWF  x0C
03C9C:  MOVLW  1C
03C9E:  ADDWF  x0C,W
03CA0:  MOVWF  01
03CA2:  MOVLW  00
03CA4:  ADDWFC x0D,W
03CA6:  MOVWF  03
03CA8:  MOVF   01,W
03CAA:  ADDLW  17
03CAC:  MOVWF  FE9
03CAE:  MOVLW  01
03CB0:  ADDWFC 03,W
03CB2:  MOVWF  FEA
03CB4:  INCF   FEF,F
03CB6:  MOVLB  0
....................       }
....................    }
....................    
....................    adcVals[ch].p0 = polePitch * ( 1000 / (2*PI) ) * atan2( (float)adcVals[ch].sinCounts, (float)adcVals[ch].cosCounts );
03CB8:  MOVLB  7
03CBA:  MOVF   x03,W
03CBC:  MULLW  26
03CBE:  MOVF   FF3,W
03CC0:  CLRF   x0D
03CC2:  MOVWF  x0C
03CC4:  MOVLW  18
03CC6:  ADDWF  x0C,W
03CC8:  MOVWF  01
03CCA:  MOVLW  00
03CCC:  ADDWFC x0D,W
03CCE:  MOVWF  03
03CD0:  MOVF   01,W
03CD2:  ADDLW  17
03CD4:  MOVWF  01
03CD6:  MOVLW  01
03CD8:  ADDWFC 03,F
03CDA:  MOVFF  01,70C
03CDE:  MOVFF  03,70D
03CE2:  MOVFF  70B,753
03CE6:  MOVFF  70A,752
03CEA:  MOVFF  709,751
03CEE:  MOVFF  708,750
03CF2:  MOVLW  AA
03CF4:  MOVWF  x57
03CF6:  MOVLW  27
03CF8:  MOVWF  x56
03CFA:  MOVLW  1F
03CFC:  MOVWF  x55
03CFE:  MOVLW  86
03D00:  MOVWF  x54
03D02:  MOVLB  0
03D04:  CALL   0DA0
03D08:  MOVFF  03,711
03D0C:  MOVFF  02,710
03D10:  MOVFF  01,70F
03D14:  MOVFF  00,70E
03D18:  MOVLB  7
03D1A:  MOVF   x03,W
03D1C:  MULLW  26
03D1E:  MOVF   FF3,W
03D20:  CLRF   x13
03D22:  MOVWF  x12
03D24:  MOVLW  08
03D26:  ADDWF  x12,W
03D28:  MOVWF  01
03D2A:  MOVLW  00
03D2C:  ADDWFC x13,W
03D2E:  MOVWF  03
03D30:  MOVF   01,W
03D32:  ADDLW  17
03D34:  MOVWF  FE9
03D36:  MOVLW  01
03D38:  ADDWFC 03,W
03D3A:  MOVWF  FEA
03D3C:  MOVFF  FEF,712
03D40:  MOVFF  FEC,713
03D44:  MOVFF  FEC,714
03D48:  MOVFF  FEC,715
03D4C:  MOVF   x03,W
03D4E:  MULLW  26
03D50:  MOVF   FF3,W
03D52:  CLRF   x17
03D54:  MOVWF  x16
03D56:  MOVLW  0C
03D58:  ADDWF  x16,W
03D5A:  MOVWF  01
03D5C:  MOVLW  00
03D5E:  ADDWFC x17,W
03D60:  MOVWF  03
03D62:  MOVF   01,W
03D64:  ADDLW  17
03D66:  MOVWF  FE9
03D68:  MOVLW  01
03D6A:  ADDWFC 03,W
03D6C:  MOVWF  FEA
03D6E:  MOVFF  FEF,00
03D72:  MOVFF  FEC,01
03D76:  MOVFF  FEC,02
03D7A:  MOVFF  FEC,03
03D7E:  MOVFF  03,719
03D82:  MOVFF  02,718
03D86:  MOVFF  01,717
03D8A:  MOVFF  00,716
03D8E:  MOVFF  715,71D
03D92:  MOVFF  714,71C
03D96:  MOVFF  713,71B
03D9A:  MOVFF  712,71A
03D9E:  MOVFF  03,721
03DA2:  MOVFF  02,720
03DA6:  MOVFF  01,71F
03DAA:  MOVFF  00,71E
03DAE:  MOVLB  0
03DB0:  GOTO   242E
03DB4:  MOVFF  711,753
03DB8:  MOVFF  710,752
03DBC:  MOVFF  70F,751
03DC0:  MOVFF  70E,750
03DC4:  MOVFF  03,757
03DC8:  MOVFF  02,756
03DCC:  MOVFF  01,755
03DD0:  MOVFF  00,754
03DD4:  CALL   0DA0
03DD8:  MOVFF  70D,FEA
03DDC:  MOVFF  70C,FE9
03DE0:  MOVFF  00,FEF
03DE4:  MOVFF  01,FEC
03DE8:  MOVFF  02,FEC
03DEC:  MOVFF  03,FEC
....................    pTmp = adcVals[ch].p0 + ( 1000 * polePitch * (float)adcVals[ch].npoles );
03DF0:  MOVLB  7
03DF2:  MOVF   x03,W
03DF4:  MULLW  26
03DF6:  MOVF   FF3,W
03DF8:  CLRF   x0D
03DFA:  MOVWF  x0C
03DFC:  MOVLW  18
03DFE:  ADDWF  x0C,W
03E00:  MOVWF  01
03E02:  MOVLW  00
03E04:  ADDWFC x0D,W
03E06:  MOVWF  03
03E08:  MOVF   01,W
03E0A:  ADDLW  17
03E0C:  MOVWF  FE9
03E0E:  MOVLW  01
03E10:  ADDWFC 03,W
03E12:  MOVWF  FEA
03E14:  MOVFF  FEF,70C
03E18:  MOVFF  FEC,70D
03E1C:  MOVFF  FEC,70E
03E20:  MOVFF  FEC,70F
03E24:  CLRF   x53
03E26:  CLRF   x52
03E28:  MOVLW  7A
03E2A:  MOVWF  x51
03E2C:  MOVLW  88
03E2E:  MOVWF  x50
03E30:  MOVFF  70B,757
03E34:  MOVFF  70A,756
03E38:  MOVFF  709,755
03E3C:  MOVFF  708,754
03E40:  MOVLB  0
03E42:  CALL   0DA0
03E46:  MOVFF  03,713
03E4A:  MOVFF  02,712
03E4E:  MOVFF  01,711
03E52:  MOVFF  00,710
03E56:  MOVLB  7
03E58:  MOVF   x03,W
03E5A:  MULLW  26
03E5C:  MOVF   FF3,W
03E5E:  CLRF   x15
03E60:  MOVWF  x14
03E62:  MOVLW  1C
03E64:  ADDWF  x14,W
03E66:  MOVWF  01
03E68:  MOVLW  00
03E6A:  ADDWFC x15,W
03E6C:  MOVWF  03
03E6E:  MOVF   01,W
03E70:  ADDLW  17
03E72:  MOVWF  FE9
03E74:  MOVLW  01
03E76:  ADDWFC 03,W
03E78:  MOVWF  FEA
03E7A:  MOVF   FEF,W
03E7C:  CLRF   x3D
03E7E:  MOVWF  x3C
03E80:  BTFSC  x3C.7
03E82:  DECF   x3D,F
03E84:  MOVLB  0
03E86:  CALL   26D0
03E8A:  MOVFF  713,753
03E8E:  MOVFF  712,752
03E92:  MOVFF  711,751
03E96:  MOVFF  710,750
03E9A:  MOVFF  03,757
03E9E:  MOVFF  02,756
03EA2:  MOVFF  01,755
03EA6:  MOVFF  00,754
03EAA:  CALL   0DA0
03EAE:  MOVFF  FEA,711
03EB2:  MOVFF  FE9,710
03EB6:  BCF    FD8.1
03EB8:  MOVFF  70F,74D
03EBC:  MOVFF  70E,74C
03EC0:  MOVFF  70D,74B
03EC4:  MOVFF  70C,74A
03EC8:  MOVFF  03,751
03ECC:  MOVFF  02,750
03ED0:  MOVFF  01,74F
03ED4:  MOVFF  00,74E
03ED8:  CALL   0E96
03EDC:  MOVFF  711,FEA
03EE0:  MOVFF  710,FE9
03EE4:  MOVFF  03,707
03EE8:  MOVFF  02,706
03EEC:  MOVFF  01,705
03EF0:  MOVFF  00,704
....................    
....................    adcVals[ch].pReal = (pow(pTmp*sc[ch].c5,5) + pow(pTmp*sc[ch].c4,4) + pow(pTmp*sc[ch].c3,3) + pow(pTmp*sc[ch].c2,2) + pTmp*sc[ch].c1 + sc[ch].c0);
03EF4:  MOVLB  7
03EF6:  MOVF   x03,W
03EF8:  MULLW  26
03EFA:  MOVF   FF3,W
03EFC:  CLRF   x0D
03EFE:  MOVWF  x0C
03F00:  MOVLW  1D
03F02:  ADDWF  x0C,W
03F04:  MOVWF  01
03F06:  MOVLW  00
03F08:  ADDWFC x0D,W
03F0A:  MOVWF  03
03F0C:  MOVF   01,W
03F0E:  ADDLW  17
03F10:  MOVWF  01
03F12:  MOVLW  01
03F14:  ADDWFC 03,F
03F16:  MOVFF  01,70C
03F1A:  MOVFF  03,70D
03F1E:  MOVF   x03,W
03F20:  MULLW  18
03F22:  MOVF   FF3,W
03F24:  CLRF   x0F
03F26:  MOVWF  x0E
03F28:  MOVLW  14
03F2A:  ADDWF  x0E,W
03F2C:  MOVWF  01
03F2E:  MOVLW  00
03F30:  ADDWFC x0F,W
03F32:  MOVWF  03
03F34:  MOVF   01,W
03F36:  ADDLW  92
03F38:  MOVWF  FE9
03F3A:  MOVLW  00
03F3C:  ADDWFC 03,W
03F3E:  MOVWF  FEA
03F40:  MOVFF  FEF,754
03F44:  MOVFF  FEC,01
03F48:  MOVFF  FEC,02
03F4C:  MOVFF  FEC,03
03F50:  MOVFF  707,753
03F54:  MOVFF  706,752
03F58:  MOVFF  705,751
03F5C:  MOVFF  704,750
03F60:  MOVFF  03,757
03F64:  MOVFF  02,756
03F68:  MOVFF  01,755
03F6C:  MOVLB  0
03F6E:  CALL   0DA0
03F72:  MOVFF  03,711
03F76:  MOVFF  02,710
03F7A:  MOVFF  01,70F
03F7E:  MOVFF  00,70E
03F82:  MOVFF  03,71D
03F86:  MOVFF  02,71C
03F8A:  MOVFF  01,71B
03F8E:  MOVFF  00,71A
03F92:  MOVLB  7
03F94:  CLRF   x21
03F96:  CLRF   x20
03F98:  MOVLW  20
03F9A:  MOVWF  x1F
03F9C:  MOVLW  81
03F9E:  MOVWF  x1E
03FA0:  MOVLB  0
03FA2:  CALL   340E
03FA6:  MOVFF  03,711
03FAA:  MOVFF  02,710
03FAE:  MOVFF  01,70F
03FB2:  MOVFF  00,70E
03FB6:  MOVLB  7
03FB8:  MOVF   x03,W
03FBA:  MULLW  18
03FBC:  MOVF   FF3,W
03FBE:  CLRF   x13
03FC0:  MOVWF  x12
03FC2:  MOVLW  10
03FC4:  ADDWF  x12,W
03FC6:  MOVWF  01
03FC8:  MOVLW  00
03FCA:  ADDWFC x13,W
03FCC:  MOVWF  03
03FCE:  MOVF   01,W
03FD0:  ADDLW  92
03FD2:  MOVWF  FE9
03FD4:  MOVLW  00
03FD6:  ADDWFC 03,W
03FD8:  MOVWF  FEA
03FDA:  MOVFF  FEF,754
03FDE:  MOVFF  FEC,01
03FE2:  MOVFF  FEC,02
03FE6:  MOVFF  FEC,03
03FEA:  MOVFF  707,753
03FEE:  MOVFF  706,752
03FF2:  MOVFF  705,751
03FF6:  MOVFF  704,750
03FFA:  MOVFF  03,757
03FFE:  MOVFF  02,756
04002:  MOVFF  01,755
04006:  MOVLB  0
04008:  CALL   0DA0
0400C:  MOVFF  03,715
04010:  MOVFF  02,714
04014:  MOVFF  01,713
04018:  MOVFF  00,712
0401C:  MOVFF  03,71D
04020:  MOVFF  02,71C
04024:  MOVFF  01,71B
04028:  MOVFF  00,71A
0402C:  MOVLB  7
0402E:  CLRF   x21
04030:  CLRF   x20
04032:  CLRF   x1F
04034:  MOVLW  81
04036:  MOVWF  x1E
04038:  MOVLB  0
0403A:  CALL   340E
0403E:  MOVFF  FEA,713
04042:  MOVFF  FE9,712
04046:  BCF    FD8.1
04048:  MOVFF  711,74D
0404C:  MOVFF  710,74C
04050:  MOVFF  70F,74B
04054:  MOVFF  70E,74A
04058:  MOVFF  03,751
0405C:  MOVFF  02,750
04060:  MOVFF  01,74F
04064:  MOVFF  00,74E
04068:  CALL   0E96
0406C:  MOVFF  713,FEA
04070:  MOVFF  712,FE9
04074:  MOVFF  03,711
04078:  MOVFF  02,710
0407C:  MOVFF  01,70F
04080:  MOVFF  00,70E
04084:  MOVLB  7
04086:  MOVF   x03,W
04088:  MULLW  18
0408A:  MOVF   FF3,W
0408C:  CLRF   x15
0408E:  MOVWF  x14
04090:  MOVLW  0C
04092:  ADDWF  x14,W
04094:  MOVWF  01
04096:  MOVLW  00
04098:  ADDWFC x15,W
0409A:  MOVWF  03
0409C:  MOVF   01,W
0409E:  ADDLW  92
040A0:  MOVWF  FE9
040A2:  MOVLW  00
040A4:  ADDWFC 03,W
040A6:  MOVWF  FEA
040A8:  MOVFF  FEF,754
040AC:  MOVFF  FEC,01
040B0:  MOVFF  FEC,02
040B4:  MOVFF  FEC,03
040B8:  MOVFF  707,753
040BC:  MOVFF  706,752
040C0:  MOVFF  705,751
040C4:  MOVFF  704,750
040C8:  MOVFF  03,757
040CC:  MOVFF  02,756
040D0:  MOVFF  01,755
040D4:  MOVLB  0
040D6:  CALL   0DA0
040DA:  MOVFF  03,717
040DE:  MOVFF  02,716
040E2:  MOVFF  01,715
040E6:  MOVFF  00,714
040EA:  MOVFF  03,71D
040EE:  MOVFF  02,71C
040F2:  MOVFF  01,71B
040F6:  MOVFF  00,71A
040FA:  MOVLB  7
040FC:  CLRF   x21
040FE:  CLRF   x20
04100:  MOVLW  40
04102:  MOVWF  x1F
04104:  MOVLW  80
04106:  MOVWF  x1E
04108:  MOVLB  0
0410A:  CALL   340E
0410E:  MOVFF  FEA,715
04112:  MOVFF  FE9,714
04116:  BCF    FD8.1
04118:  MOVFF  711,74D
0411C:  MOVFF  710,74C
04120:  MOVFF  70F,74B
04124:  MOVFF  70E,74A
04128:  MOVFF  03,751
0412C:  MOVFF  02,750
04130:  MOVFF  01,74F
04134:  MOVFF  00,74E
04138:  CALL   0E96
0413C:  MOVFF  715,FEA
04140:  MOVFF  714,FE9
04144:  MOVFF  03,711
04148:  MOVFF  02,710
0414C:  MOVFF  01,70F
04150:  MOVFF  00,70E
04154:  MOVLB  7
04156:  MOVF   x03,W
04158:  MULLW  18
0415A:  MOVF   FF3,W
0415C:  CLRF   x17
0415E:  MOVWF  x16
04160:  MOVLW  08
04162:  ADDWF  x16,W
04164:  MOVWF  01
04166:  MOVLW  00
04168:  ADDWFC x17,W
0416A:  MOVWF  03
0416C:  MOVF   01,W
0416E:  ADDLW  92
04170:  MOVWF  FE9
04172:  MOVLW  00
04174:  ADDWFC 03,W
04176:  MOVWF  FEA
04178:  MOVFF  FEF,754
0417C:  MOVFF  FEC,01
04180:  MOVFF  FEC,02
04184:  MOVFF  FEC,03
04188:  MOVFF  707,753
0418C:  MOVFF  706,752
04190:  MOVFF  705,751
04194:  MOVFF  704,750
04198:  MOVFF  03,757
0419C:  MOVFF  02,756
041A0:  MOVFF  01,755
041A4:  MOVLB  0
041A6:  CALL   0DA0
041AA:  MOVFF  03,719
041AE:  MOVFF  02,718
041B2:  MOVFF  01,717
041B6:  MOVFF  00,716
041BA:  MOVFF  03,71D
041BE:  MOVFF  02,71C
041C2:  MOVFF  01,71B
041C6:  MOVFF  00,71A
041CA:  MOVLB  7
041CC:  CLRF   x21
041CE:  CLRF   x20
041D0:  CLRF   x1F
041D2:  MOVLW  80
041D4:  MOVWF  x1E
041D6:  MOVLB  0
041D8:  CALL   340E
041DC:  MOVFF  FEA,717
041E0:  MOVFF  FE9,716
041E4:  BCF    FD8.1
041E6:  MOVFF  711,74D
041EA:  MOVFF  710,74C
041EE:  MOVFF  70F,74B
041F2:  MOVFF  70E,74A
041F6:  MOVFF  03,751
041FA:  MOVFF  02,750
041FE:  MOVFF  01,74F
04202:  MOVFF  00,74E
04206:  CALL   0E96
0420A:  MOVFF  717,FEA
0420E:  MOVFF  716,FE9
04212:  MOVFF  03,711
04216:  MOVFF  02,710
0421A:  MOVFF  01,70F
0421E:  MOVFF  00,70E
04222:  MOVLB  7
04224:  MOVF   x03,W
04226:  MULLW  18
04228:  MOVF   FF3,W
0422A:  CLRF   x19
0422C:  MOVWF  x18
0422E:  MOVLW  04
04230:  ADDWF  x18,W
04232:  MOVWF  01
04234:  MOVLW  00
04236:  ADDWFC x19,W
04238:  MOVWF  03
0423A:  MOVF   01,W
0423C:  ADDLW  92
0423E:  MOVWF  FE9
04240:  MOVLW  00
04242:  ADDWFC 03,W
04244:  MOVWF  FEA
04246:  MOVFF  FEF,754
0424A:  MOVFF  FEC,01
0424E:  MOVFF  FEC,02
04252:  MOVFF  FEC,03
04256:  MOVFF  707,753
0425A:  MOVFF  706,752
0425E:  MOVFF  705,751
04262:  MOVFF  704,750
04266:  MOVFF  03,757
0426A:  MOVFF  02,756
0426E:  MOVFF  01,755
04272:  MOVLB  0
04274:  CALL   0DA0
04278:  MOVFF  FEA,719
0427C:  MOVFF  FE9,718
04280:  BCF    FD8.1
04282:  MOVFF  711,74D
04286:  MOVFF  710,74C
0428A:  MOVFF  70F,74B
0428E:  MOVFF  70E,74A
04292:  MOVFF  03,751
04296:  MOVFF  02,750
0429A:  MOVFF  01,74F
0429E:  MOVFF  00,74E
042A2:  CALL   0E96
042A6:  MOVFF  719,FEA
042AA:  MOVFF  718,FE9
042AE:  MOVFF  03,74D
042B2:  MOVFF  02,74C
042B6:  MOVFF  01,74B
042BA:  MOVFF  00,74A
042BE:  MOVLB  7
042C0:  MOVF   x03,W
042C2:  MULLW  18
042C4:  MOVF   FF3,W
042C6:  CLRF   x1B
042C8:  MOVWF  x1A
042CA:  MOVLW  92
042CC:  ADDWF  x1A,W
042CE:  MOVWF  FE9
042D0:  MOVLW  00
042D2:  ADDWFC x1B,W
042D4:  MOVWF  FEA
042D6:  MOVFF  FEF,74E
042DA:  MOVFF  FEC,01
042DE:  MOVFF  FEC,02
042E2:  MOVFF  FEC,03
042E6:  BCF    FD8.1
042E8:  MOVFF  03,751
042EC:  MOVFF  02,750
042F0:  MOVFF  01,74F
042F4:  MOVLB  0
042F6:  CALL   0E96
042FA:  MOVFF  70D,FEA
042FE:  MOVFF  70C,FE9
04302:  MOVFF  00,FEF
04306:  MOVFF  01,FEC
0430A:  MOVFF  02,FEC
0430E:  MOVFF  03,FEC
....................    if (ch == chX) adcVals[ch].pReal *= -1;
04312:  MOVLB  7
04314:  MOVF   x03,F
04316:  BNZ   4374
04318:  MOVF   x03,W
0431A:  MULLW  26
0431C:  MOVF   FF3,W
0431E:  CLRF   x0D
04320:  MOVWF  x0C
04322:  MOVLW  1D
04324:  ADDWF  x0C,W
04326:  MOVWF  01
04328:  MOVLW  00
0432A:  ADDWFC x0D,W
0432C:  MOVWF  03
0432E:  MOVF   01,W
04330:  ADDLW  17
04332:  MOVWF  FE9
04334:  MOVLW  01
04336:  ADDWFC 03,W
04338:  MOVWF  FEA
0433A:  MOVFF  FEF,750
0433E:  MOVFF  FEC,751
04342:  MOVFF  FEC,752
04346:  MOVFF  FEC,753
0434A:  MOVF   FED,F
0434C:  MOVF   FED,F
0434E:  MOVF   FED,F
04350:  CLRF   x57
04352:  CLRF   x56
04354:  MOVLW  80
04356:  MOVWF  x55
04358:  MOVLW  7F
0435A:  MOVWF  x54
0435C:  MOVLB  0
0435E:  CALL   0DA0
04362:  MOVFF  00,FEF
04366:  MOVFF  01,FEC
0436A:  MOVFF  02,FEC
0436E:  MOVFF  03,FEC
04372:  MOVLB  7
....................    PID[ch].PVold = PID[ch].PV;
04374:  MOVF   x03,W
04376:  MULLW  28
04378:  MOVF   FF3,W
0437A:  CLRF   x0D
0437C:  MOVWF  x0C
0437E:  MOVLW  14
04380:  ADDWF  x0C,W
04382:  MOVWF  01
04384:  MOVLW  00
04386:  ADDWFC x0D,W
04388:  MOVWF  03
0438A:  MOVF   01,W
0438C:  ADDLW  20
0438E:  MOVWF  01
04390:  MOVLW  00
04392:  ADDWFC 03,F
04394:  MOVFF  01,70C
04398:  MOVFF  03,70D
0439C:  MOVF   x03,W
0439E:  MULLW  28
043A0:  MOVF   FF3,W
043A2:  CLRF   x0F
043A4:  MOVWF  x0E
043A6:  MOVLW  10
043A8:  ADDWF  x0E,W
043AA:  MOVWF  01
043AC:  MOVLW  00
043AE:  ADDWFC x0F,W
043B0:  MOVWF  03
043B2:  MOVF   01,W
043B4:  ADDLW  20
043B6:  MOVWF  FE9
043B8:  MOVLW  00
043BA:  ADDWFC 03,W
043BC:  MOVWF  FEA
043BE:  MOVFF  FEF,00
043C2:  MOVFF  FEC,01
043C6:  MOVFF  FEC,02
043CA:  MOVFF  FEC,03
043CE:  MOVFF  70D,FEA
043D2:  MOVFF  70C,FE9
043D6:  MOVFF  00,FEF
043DA:  MOVFF  01,FEC
043DE:  MOVFF  02,FEC
043E2:  MOVFF  03,FEC
....................    PID[ch].PV = adcVals[ch].pReal;
043E6:  MOVF   x03,W
043E8:  MULLW  28
043EA:  MOVF   FF3,W
043EC:  CLRF   x0D
043EE:  MOVWF  x0C
043F0:  MOVLW  10
043F2:  ADDWF  x0C,W
043F4:  MOVWF  01
043F6:  MOVLW  00
043F8:  ADDWFC x0D,W
043FA:  MOVWF  03
043FC:  MOVF   01,W
043FE:  ADDLW  20
04400:  MOVWF  01
04402:  MOVLW  00
04404:  ADDWFC 03,F
04406:  MOVFF  01,70C
0440A:  MOVFF  03,70D
0440E:  MOVF   x03,W
04410:  MULLW  26
04412:  MOVF   FF3,W
04414:  CLRF   x0F
04416:  MOVWF  x0E
04418:  MOVLW  1D
0441A:  ADDWF  x0E,W
0441C:  MOVWF  01
0441E:  MOVLW  00
04420:  ADDWFC x0F,W
04422:  MOVWF  03
04424:  MOVF   01,W
04426:  ADDLW  17
04428:  MOVWF  FE9
0442A:  MOVLW  01
0442C:  ADDWFC 03,W
0442E:  MOVWF  FEA
04430:  MOVFF  FEF,00
04434:  MOVFF  FEC,01
04438:  MOVFF  FEC,02
0443C:  MOVFF  FEC,03
04440:  MOVFF  70D,FEA
04444:  MOVFF  70C,FE9
04448:  MOVFF  00,FEF
0444C:  MOVFF  01,FEC
04450:  MOVFF  02,FEC
04454:  MOVFF  03,FEC
04458:  MOVLB  0
0445A:  GOTO   45BA (RETURN)
.................... }  
.................... 
.................... /*****************************************************************************/
.................... /* SENSOR MONITOR INTERRUPT TASK                                             */
.................... /* starts conversion of the other two ADCs                                   */
.................... /*****************************************************************************/
.................... void sensor_monitor_interrupt_task(){
....................    static int8 ch = 0;
....................    
....................    if (!smData[ch].adcBusy){
*
001F6:  MOVLB  1
001F8:  MOVF   xE7,W
001FA:  MULLW  09
001FC:  MOVF   FF3,W
001FE:  MOVLB  7
00200:  CLRF   x72
00202:  MOVWF  x71
00204:  MOVLW  D4
00206:  ADDWF  x71,W
00208:  MOVWF  FE9
0020A:  MOVLW  01
0020C:  ADDWFC x72,W
0020E:  MOVWF  FEA
00210:  BTFSC  FEF.1
00212:  BRA    028C
....................       smData[ch].adcBusy = true;
00214:  MOVLB  1
00216:  MOVF   xE7,W
00218:  MULLW  09
0021A:  MOVF   FF3,W
0021C:  MOVLB  7
0021E:  CLRF   x72
00220:  MOVWF  x71
00222:  MOVLW  D4
00224:  ADDWF  x71,W
00226:  MOVWF  FE9
00228:  MOVLW  01
0022A:  ADDWFC x72,W
0022C:  MOVWF  FEA
0022E:  BSF    FEF.1
....................          
....................       ads_start_conv_block(ch);
00230:  MOVFF  1E7,771
00234:  MOVLB  0
00236:  BRA    01DA
....................       ch = !ch;
00238:  MOVLB  1
0023A:  MOVF   xE7,F
0023C:  BZ    0242
0023E:  MOVLW  00
00240:  BRA    0244
00242:  MOVLW  01
00244:  MOVWF  xE7
....................          
....................       smData[!ch].dataReady = true;
00246:  MOVF   xE7,F
00248:  BZ    024E
0024A:  MOVLW  00
0024C:  BRA    0250
0024E:  MOVLW  01
00250:  MULLW  09
00252:  MOVF   FF3,W
00254:  MOVLB  7
00256:  CLRF   x72
00258:  MOVWF  x71
0025A:  MOVLW  D4
0025C:  ADDWF  x71,W
0025E:  MOVWF  FE9
00260:  MOVLW  01
00262:  ADDWFC x72,W
00264:  MOVWF  FEA
00266:  BSF    FEF.0
....................       smData[!ch].adcBusy = false;
00268:  MOVLB  1
0026A:  MOVF   xE7,F
0026C:  BZ    0272
0026E:  MOVLW  00
00270:  BRA    0274
00272:  MOVLW  01
00274:  MULLW  09
00276:  MOVF   FF3,W
00278:  MOVLB  7
0027A:  CLRF   x72
0027C:  MOVWF  x71
0027E:  MOVLW  D4
00280:  ADDWF  x71,W
00282:  MOVWF  FE9
00284:  MOVLW  01
00286:  ADDWFC x72,W
00288:  MOVWF  FEA
0028A:  BCF    FEF.1
....................    }
0028C:  MOVLB  0
0028E:  GOTO   0350 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Interquartile Mean Ring Buffer                                            */
.................... /* Filters the ADC data to remove spurious readings                          */
.................... /*****************************************************************************/
.................... void iqm_ring_buffer(int8 ch, signed int32 sinCnts, signed int32 cosCnts){
*
01776:  MOVLB  7
01778:  CLRF   x17
0177A:  CLRF   x16
0177C:  CLRF   x15
0177E:  CLRF   x14
01780:  CLRF   x1B
01782:  CLRF   x1A
01784:  CLRF   x19
01786:  CLRF   x18
01788:  CLRF   x1F
0178A:  CLRF   x1E
0178C:  CLRF   x1D
0178E:  CLRF   x1C
01790:  CLRF   x23
01792:  CLRF   x22
01794:  CLRF   x21
01796:  CLRF   x20
01798:  CLRF   x27
0179A:  CLRF   x26
0179C:  CLRF   x25
0179E:  CLRF   x24
017A0:  CLRF   x2B
017A2:  CLRF   x2A
017A4:  CLRF   x29
017A6:  CLRF   x28
....................    signed int32* sQ_ch;
....................    signed int32* cQ_ch;
....................    int* sIn_ch;
....................    int* cIn_ch;
.................... 
....................    signed int32 sumSin=0;
....................    signed int32 sumCos=0;
....................    
....................    signed int32 sinMax=0;
....................    signed int32 sinMin=0;
....................    signed int32 cosMax=0;
....................    signed int32 cosMin=0;
....................    
....................    if (ch==0){
017A8:  MOVF   x03,F
017AA:  BNZ   17CE
....................       sQ_ch = sQ_x;
017AC:  MOVLW  01
017AE:  MOVWF  x0D
017B0:  MOVLW  80
017B2:  MOVWF  x0C
....................       cQ_ch = cQ_x;
017B4:  MOVLW  01
017B6:  MOVWF  x0F
017B8:  MOVLW  94
017BA:  MOVWF  x0E
....................       sIn_ch = &sIn_x;
017BC:  MOVLW  01
017BE:  MOVWF  x11
017C0:  MOVLW  D0
017C2:  MOVWF  x10
....................       cIn_ch = &cIn_x;
017C4:  MOVLW  01
017C6:  MOVWF  x13
017C8:  MOVLW  D1
017CA:  MOVWF  x12
....................    }
017CC:  BRA    17F2
....................    else if (ch==1){
017CE:  DECFSZ x03,W
017D0:  BRA    17F2
....................       sQ_ch = sQ_y;
017D2:  MOVLW  01
017D4:  MOVWF  x0D
017D6:  MOVLW  A8
017D8:  MOVWF  x0C
....................       cQ_ch = cQ_y;
017DA:  MOVLW  01
017DC:  MOVWF  x0F
017DE:  MOVLW  BC
017E0:  MOVWF  x0E
....................       sIn_ch = &sIn_y;
017E2:  MOVLW  01
017E4:  MOVWF  x11
017E6:  MOVLW  D2
017E8:  MOVWF  x10
....................       cIn_ch = &cIn_y;
017EA:  MOVLW  01
017EC:  MOVWF  x13
017EE:  MOVLW  D3
017F0:  MOVWF  x12
....................    }
.................... 
....................    push(sQ_ch, sIn_ch, sinCnts); // push new data into queues
017F2:  MOVFF  70D,72E
017F6:  MOVFF  70C,72D
017FA:  MOVFF  711,730
017FE:  MOVFF  710,72F
01802:  MOVFF  707,734
01806:  MOVFF  706,733
0180A:  MOVFF  705,732
0180E:  MOVFF  704,731
01812:  MOVLB  0
01814:  CALL   0904
....................    push(cQ_ch, cIn_ch, cosCnts);
01818:  MOVFF  70F,72E
0181C:  MOVFF  70E,72D
01820:  MOVFF  713,730
01824:  MOVFF  712,72F
01828:  MOVFF  70B,734
0182C:  MOVFF  70A,733
01830:  MOVFF  709,732
01834:  MOVFF  708,731
01838:  CALL   0904
....................    
....................    // MAX and MIN of the rolling buffer initial vals
....................    sinMax=sQ_ch[0];
0183C:  MOVLB  7
0183E:  MOVFF  70C,FE9
01842:  MOVFF  70D,FEA
01846:  MOVFF  FEF,71C
0184A:  MOVFF  FEC,71D
0184E:  MOVFF  FEC,71E
01852:  MOVFF  FEC,71F
....................    sinMin=sQ_ch[0];
01856:  MOVFF  70C,FE9
0185A:  MOVFF  70D,FEA
0185E:  MOVFF  FEF,720
01862:  MOVFF  FEC,721
01866:  MOVFF  FEC,722
0186A:  MOVFF  FEC,723
....................    cosMax=cQ_ch[0];
0186E:  MOVFF  70E,FE9
01872:  MOVFF  70F,FEA
01876:  MOVFF  FEF,724
0187A:  MOVFF  FEC,725
0187E:  MOVFF  FEC,726
01882:  MOVFF  FEC,727
....................    cosMin=cQ_ch[0];
01886:  MOVFF  70E,FE9
0188A:  MOVFF  70F,FEA
0188E:  MOVFF  FEF,728
01892:  MOVFF  FEC,729
01896:  MOVFF  FEC,72A
0189A:  MOVFF  FEC,72B
....................    
....................    // step thru buffer, adding up all vals and finding MAX and MIN
....................    for (int i=1; i<BUFFER_SIZE; i++){
0189E:  MOVLW  01
018A0:  MOVWF  x2C
018A2:  MOVF   x2C,W
018A4:  SUBLW  04
018A6:  BTFSS  FD8.0
018A8:  BRA    1BB8
....................       (sinMax < sQ_ch[i]) ? (sinMax=sQ_ch[i]) : (0);
018AA:  CLRF   x42
018AC:  MOVFF  72C,741
018B0:  CLRF   x44
018B2:  MOVLW  04
018B4:  MOVWF  x43
018B6:  MOVLB  0
018B8:  CALL   08B6
018BC:  MOVFF  02,03
018C0:  MOVF   01,W
018C2:  MOVLB  7
018C4:  ADDWF  x0C,W
018C6:  MOVWF  FE9
018C8:  MOVF   x0D,W
018CA:  ADDWFC 02,W
018CC:  MOVWF  FEA
018CE:  MOVFF  FEF,00
018D2:  MOVFF  FEC,01
018D6:  MOVFF  FEC,02
018DA:  MOVFF  FEC,03
018DE:  BTFSS  x1F.7
018E0:  BRA    18E8
018E2:  BTFSS  03.7
018E4:  BRA    190A
018E6:  BRA    18EC
018E8:  BTFSC  03.7
018EA:  BRA    1940
018EC:  MOVF   x1F,W
018EE:  SUBWF  03,W
018F0:  BNC   1940
018F2:  BNZ   190A
018F4:  MOVF   x1E,W
018F6:  SUBWF  02,W
018F8:  BNC   1940
018FA:  BNZ   190A
018FC:  MOVF   x1D,W
018FE:  SUBWF  01,W
01900:  BNC   1940
01902:  BNZ   190A
01904:  MOVF   00,W
01906:  SUBWF  x1C,W
01908:  BC    1940
0190A:  CLRF   x42
0190C:  MOVFF  72C,741
01910:  CLRF   x44
01912:  MOVLW  04
01914:  MOVWF  x43
01916:  MOVLB  0
01918:  CALL   08B6
0191C:  MOVFF  02,03
01920:  MOVF   01,W
01922:  MOVLB  7
01924:  ADDWF  x0C,W
01926:  MOVWF  FE9
01928:  MOVF   x0D,W
0192A:  ADDWFC 02,W
0192C:  MOVWF  FEA
0192E:  MOVFF  FEF,71C
01932:  MOVFF  FEC,71D
01936:  MOVFF  FEC,71E
0193A:  MOVFF  FEC,71F
0193E:  MOVF   x1C,W
....................       (sinMin > sQ_ch[i]) ? (sinMin=sQ_ch[i]) : (0);
01940:  CLRF   x42
01942:  MOVFF  72C,741
01946:  CLRF   x44
01948:  MOVLW  04
0194A:  MOVWF  x43
0194C:  MOVLB  0
0194E:  CALL   08B6
01952:  MOVFF  02,03
01956:  MOVF   01,W
01958:  MOVLB  7
0195A:  ADDWF  x0C,W
0195C:  MOVWF  FE9
0195E:  MOVF   x0D,W
01960:  ADDWFC 02,W
01962:  MOVWF  FEA
01964:  MOVFF  FEF,00
01968:  MOVFF  FEC,01
0196C:  MOVFF  FEC,02
01970:  MOVFF  FEC,03
01974:  BTFSS  03.7
01976:  BRA    197E
01978:  BTFSS  x23.7
0197A:  BRA    19A0
0197C:  BRA    1982
0197E:  BTFSC  x23.7
01980:  BRA    19E4
01982:  MOVF   03,W
01984:  SUBWF  x23,W
01986:  BNC   19E4
01988:  BNZ   19A0
0198A:  MOVF   02,W
0198C:  SUBWF  x22,W
0198E:  BNC   19E4
01990:  BNZ   19A0
01992:  MOVF   01,W
01994:  SUBWF  x21,W
01996:  BNC   19E4
01998:  BNZ   19A0
0199A:  MOVF   x20,W
0199C:  SUBWF  00,W
0199E:  BC    19E4
019A0:  CLRF   x42
019A2:  MOVFF  72C,741
019A6:  CLRF   x44
019A8:  MOVLW  04
019AA:  MOVWF  x43
019AC:  MOVLB  0
019AE:  CALL   08B6
019B2:  MOVFF  02,03
019B6:  MOVF   01,W
019B8:  MOVLB  7
019BA:  ADDWF  x0C,W
019BC:  MOVWF  FE9
019BE:  MOVF   x0D,W
019C0:  ADDWFC 02,W
019C2:  MOVWF  FEA
019C4:  MOVFF  FEF,720
019C8:  MOVFF  FEC,721
019CC:  MOVFF  FEC,722
019D0:  MOVFF  FEC,723
019D4:  MOVFF  720,00
019D8:  MOVFF  721,01
019DC:  MOVFF  722,02
019E0:  MOVFF  723,03
....................       (cosMax < cQ_ch[i]) ? (cosMax=cQ_ch[i]) : (0);
019E4:  CLRF   x42
019E6:  MOVFF  72C,741
019EA:  CLRF   x44
019EC:  MOVLW  04
019EE:  MOVWF  x43
019F0:  MOVLB  0
019F2:  CALL   08B6
019F6:  MOVFF  02,03
019FA:  MOVF   01,W
019FC:  MOVLB  7
019FE:  ADDWF  x0E,W
01A00:  MOVWF  FE9
01A02:  MOVF   x0F,W
01A04:  ADDWFC 02,W
01A06:  MOVWF  FEA
01A08:  MOVFF  FEF,00
01A0C:  MOVFF  FEC,01
01A10:  MOVFF  FEC,02
01A14:  MOVFF  FEC,03
01A18:  BTFSS  x27.7
01A1A:  BRA    1A22
01A1C:  BTFSS  03.7
01A1E:  BRA    1A44
01A20:  BRA    1A26
01A22:  BTFSC  03.7
01A24:  BRA    1A88
01A26:  MOVF   x27,W
01A28:  SUBWF  03,W
01A2A:  BNC   1A88
01A2C:  BNZ   1A44
01A2E:  MOVF   x26,W
01A30:  SUBWF  02,W
01A32:  BNC   1A88
01A34:  BNZ   1A44
01A36:  MOVF   x25,W
01A38:  SUBWF  01,W
01A3A:  BNC   1A88
01A3C:  BNZ   1A44
01A3E:  MOVF   00,W
01A40:  SUBWF  x24,W
01A42:  BC    1A88
01A44:  CLRF   x42
01A46:  MOVFF  72C,741
01A4A:  CLRF   x44
01A4C:  MOVLW  04
01A4E:  MOVWF  x43
01A50:  MOVLB  0
01A52:  CALL   08B6
01A56:  MOVFF  02,03
01A5A:  MOVF   01,W
01A5C:  MOVLB  7
01A5E:  ADDWF  x0E,W
01A60:  MOVWF  FE9
01A62:  MOVF   x0F,W
01A64:  ADDWFC 02,W
01A66:  MOVWF  FEA
01A68:  MOVFF  FEF,724
01A6C:  MOVFF  FEC,725
01A70:  MOVFF  FEC,726
01A74:  MOVFF  FEC,727
01A78:  MOVFF  724,00
01A7C:  MOVFF  725,01
01A80:  MOVFF  726,02
01A84:  MOVFF  727,03
....................       (cosMin > cQ_ch[i]) ? (cosMin=cQ_ch[i]) : (0);
01A88:  CLRF   x42
01A8A:  MOVFF  72C,741
01A8E:  CLRF   x44
01A90:  MOVLW  04
01A92:  MOVWF  x43
01A94:  MOVLB  0
01A96:  CALL   08B6
01A9A:  MOVFF  02,03
01A9E:  MOVF   01,W
01AA0:  MOVLB  7
01AA2:  ADDWF  x0E,W
01AA4:  MOVWF  FE9
01AA6:  MOVF   x0F,W
01AA8:  ADDWFC 02,W
01AAA:  MOVWF  FEA
01AAC:  MOVFF  FEF,00
01AB0:  MOVFF  FEC,01
01AB4:  MOVFF  FEC,02
01AB8:  MOVFF  FEC,03
01ABC:  BTFSS  03.7
01ABE:  BRA    1AC6
01AC0:  BTFSS  x2B.7
01AC2:  BRA    1AE8
01AC4:  BRA    1ACA
01AC6:  BTFSC  x2B.7
01AC8:  BRA    1B2C
01ACA:  MOVF   03,W
01ACC:  SUBWF  x2B,W
01ACE:  BNC   1B2C
01AD0:  BNZ   1AE8
01AD2:  MOVF   02,W
01AD4:  SUBWF  x2A,W
01AD6:  BNC   1B2C
01AD8:  BNZ   1AE8
01ADA:  MOVF   01,W
01ADC:  SUBWF  x29,W
01ADE:  BNC   1B2C
01AE0:  BNZ   1AE8
01AE2:  MOVF   x28,W
01AE4:  SUBWF  00,W
01AE6:  BC    1B2C
01AE8:  CLRF   x42
01AEA:  MOVFF  72C,741
01AEE:  CLRF   x44
01AF0:  MOVLW  04
01AF2:  MOVWF  x43
01AF4:  MOVLB  0
01AF6:  CALL   08B6
01AFA:  MOVFF  02,03
01AFE:  MOVF   01,W
01B00:  MOVLB  7
01B02:  ADDWF  x0E,W
01B04:  MOVWF  FE9
01B06:  MOVF   x0F,W
01B08:  ADDWFC 02,W
01B0A:  MOVWF  FEA
01B0C:  MOVFF  FEF,728
01B10:  MOVFF  FEC,729
01B14:  MOVFF  FEC,72A
01B18:  MOVFF  FEC,72B
01B1C:  MOVFF  728,00
01B20:  MOVFF  729,01
01B24:  MOVFF  72A,02
01B28:  MOVFF  72B,03
....................       sumSin+=sQ_ch[i];
01B2C:  CLRF   x42
01B2E:  MOVFF  72C,741
01B32:  CLRF   x44
01B34:  MOVLW  04
01B36:  MOVWF  x43
01B38:  MOVLB  0
01B3A:  CALL   08B6
01B3E:  MOVFF  02,03
01B42:  MOVF   01,W
01B44:  MOVLB  7
01B46:  ADDWF  x0C,W
01B48:  MOVWF  FE9
01B4A:  MOVF   x0D,W
01B4C:  ADDWFC 02,W
01B4E:  MOVWF  FEA
01B50:  MOVFF  FEF,00
01B54:  MOVFF  FEC,01
01B58:  MOVFF  FEC,02
01B5C:  MOVFF  FEC,03
01B60:  MOVF   00,W
01B62:  ADDWF  x14,F
01B64:  MOVF   01,W
01B66:  ADDWFC x15,F
01B68:  MOVF   02,W
01B6A:  ADDWFC x16,F
01B6C:  MOVF   03,W
01B6E:  ADDWFC x17,F
....................       sumCos+=cQ_ch[i];
01B70:  CLRF   x42
01B72:  MOVFF  72C,741
01B76:  CLRF   x44
01B78:  MOVLW  04
01B7A:  MOVWF  x43
01B7C:  MOVLB  0
01B7E:  CALL   08B6
01B82:  MOVFF  02,03
01B86:  MOVF   01,W
01B88:  MOVLB  7
01B8A:  ADDWF  x0E,W
01B8C:  MOVWF  FE9
01B8E:  MOVF   x0F,W
01B90:  ADDWFC 02,W
01B92:  MOVWF  FEA
01B94:  MOVFF  FEF,00
01B98:  MOVFF  FEC,01
01B9C:  MOVFF  FEC,02
01BA0:  MOVFF  FEC,03
01BA4:  MOVF   00,W
01BA6:  ADDWF  x18,F
01BA8:  MOVF   01,W
01BAA:  ADDWFC x19,F
01BAC:  MOVF   02,W
01BAE:  ADDWFC x1A,F
01BB0:  MOVF   03,W
01BB2:  ADDWFC x1B,F
01BB4:  INCF   x2C,F
01BB6:  BRA    18A2
....................    }
....................    
....................    // subtract MAX and MIN from sum
....................    sumSin-=(sinMax+sinMin);
01BB8:  MOVF   x20,W
01BBA:  ADDWF  x1C,W
01BBC:  MOVWF  00
01BBE:  MOVF   x21,W
01BC0:  ADDWFC x1D,W
01BC2:  MOVWF  01
01BC4:  MOVF   x22,W
01BC6:  ADDWFC x1E,W
01BC8:  MOVWF  02
01BCA:  MOVF   x23,W
01BCC:  ADDWFC x1F,W
01BCE:  MOVWF  03
01BD0:  MOVF   00,W
01BD2:  SUBWF  x14,F
01BD4:  MOVF   01,W
01BD6:  SUBWFB x15,F
01BD8:  MOVF   02,W
01BDA:  SUBWFB x16,F
01BDC:  MOVF   03,W
01BDE:  SUBWFB x17,F
....................    sumCos-=(cosMax+cosMin);
01BE0:  MOVF   x28,W
01BE2:  ADDWF  x24,W
01BE4:  MOVWF  00
01BE6:  MOVF   x29,W
01BE8:  ADDWFC x25,W
01BEA:  MOVWF  01
01BEC:  MOVF   x2A,W
01BEE:  ADDWFC x26,W
01BF0:  MOVWF  02
01BF2:  MOVF   x2B,W
01BF4:  ADDWFC x27,W
01BF6:  MOVWF  03
01BF8:  MOVF   00,W
01BFA:  SUBWF  x18,F
01BFC:  MOVF   01,W
01BFE:  SUBWFB x19,F
01C00:  MOVF   02,W
01C02:  SUBWFB x1A,F
01C04:  MOVF   03,W
01C06:  SUBWFB x1B,F
....................    
....................    // calc AVG
....................    smData[ch].avgSin = sumSin / (BUFFER_SIZE-2);
01C08:  MOVF   x03,W
01C0A:  MULLW  09
01C0C:  MOVF   FF3,W
01C0E:  CLRF   x2E
01C10:  MOVWF  x2D
01C12:  MOVLW  01
01C14:  ADDWF  x2D,W
01C16:  MOVWF  01
01C18:  MOVLW  00
01C1A:  ADDWFC x2E,W
01C1C:  MOVWF  03
01C1E:  MOVF   01,W
01C20:  ADDLW  D4
01C22:  MOVWF  FE9
01C24:  MOVLW  01
01C26:  ADDWFC 03,W
01C28:  MOVWF  FEA
01C2A:  MOVFF  FEA,730
01C2E:  MOVFF  FE9,72F
01C32:  BCF    FD8.1
01C34:  MOVFF  717,734
01C38:  MOVFF  716,733
01C3C:  MOVFF  715,732
01C40:  MOVFF  714,731
01C44:  CLRF   x38
01C46:  CLRF   x37
01C48:  CLRF   x36
01C4A:  MOVLW  03
01C4C:  MOVWF  x35
01C4E:  MOVLB  0
01C50:  RCALL  168C
01C52:  MOVFF  730,FEA
01C56:  MOVFF  72F,FE9
01C5A:  MOVFF  00,FEF
01C5E:  MOVFF  01,FEC
01C62:  MOVFF  02,FEC
01C66:  MOVFF  03,FEC
....................    smData[ch].avgCos = sumCos / (BUFFER_SIZE-2);
01C6A:  MOVLB  7
01C6C:  MOVF   x03,W
01C6E:  MULLW  09
01C70:  MOVF   FF3,W
01C72:  CLRF   x2E
01C74:  MOVWF  x2D
01C76:  MOVLW  05
01C78:  ADDWF  x2D,W
01C7A:  MOVWF  01
01C7C:  MOVLW  00
01C7E:  ADDWFC x2E,W
01C80:  MOVWF  03
01C82:  MOVF   01,W
01C84:  ADDLW  D4
01C86:  MOVWF  FE9
01C88:  MOVLW  01
01C8A:  ADDWFC 03,W
01C8C:  MOVWF  FEA
01C8E:  MOVFF  FEA,730
01C92:  MOVFF  FE9,72F
01C96:  BCF    FD8.1
01C98:  MOVFF  71B,734
01C9C:  MOVFF  71A,733
01CA0:  MOVFF  719,732
01CA4:  MOVFF  718,731
01CA8:  CLRF   x38
01CAA:  CLRF   x37
01CAC:  CLRF   x36
01CAE:  MOVLW  03
01CB0:  MOVWF  x35
01CB2:  MOVLB  0
01CB4:  RCALL  168C
01CB6:  MOVFF  730,FEA
01CBA:  MOVFF  72F,FE9
01CBE:  MOVFF  00,FEF
01CC2:  MOVFF  01,FEC
01CC6:  MOVFF  02,FEC
01CCA:  MOVFF  03,FEC
01CCE:  GOTO   4542 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SENSOR MONITOR task - gets magnetoresistive sensor counts                 */
.................... /* gets two values each time the task is run                                 */
.................... /*****************************************************************************/
.................... void sensor_monitor_task(){
*
0445E:  MOVLB  6
04460:  CLRF   xFE
04462:  CLRF   xFD
04464:  CLRF   xFC
04466:  CLRF   xFB
04468:  MOVLB  7
0446A:  CLRF   x02
0446C:  CLRF   x01
0446E:  CLRF   x00
04470:  MOVLB  6
04472:  CLRF   xFF
....................    static int8 ch = 0;
....................    signed int32 sinNew = 0;
....................    signed int32 cosNew = 0;
....................    
....................    if ( (!smData[ch].adcBusy) && smData[ch].dataReady ){
04474:  MOVLB  1
04476:  MOVF   xE8,W
04478:  MULLW  09
0447A:  MOVF   FF3,W
0447C:  MOVLB  7
0447E:  CLRF   x04
04480:  MOVWF  x03
04482:  MOVLW  D4
04484:  ADDWF  x03,W
04486:  MOVWF  FE9
04488:  MOVLW  01
0448A:  ADDWFC x04,W
0448C:  MOVWF  FEA
0448E:  BTFSC  FEF.1
04490:  BRA    460E
04492:  MOVLB  1
04494:  MOVF   xE8,W
04496:  MULLW  09
04498:  MOVF   FF3,W
0449A:  MOVLB  7
0449C:  CLRF   x06
0449E:  MOVWF  x05
044A0:  MOVLW  D4
044A2:  ADDWF  x05,W
044A4:  MOVWF  FE9
044A6:  MOVLW  01
044A8:  ADDWFC x06,W
044AA:  MOVWF  FEA
044AC:  BTFSS  FEF.0
044AE:  BRA    460E
....................       smData[ch].adcBusy = true;
044B0:  MOVLB  1
044B2:  MOVF   xE8,W
044B4:  MULLW  09
044B6:  MOVF   FF3,W
044B8:  MOVLB  7
044BA:  CLRF   x04
044BC:  MOVWF  x03
044BE:  MOVLW  D4
044C0:  ADDWF  x03,W
044C2:  MOVWF  FE9
044C4:  MOVLW  01
044C6:  ADDWFC x04,W
044C8:  MOVWF  FEA
044CA:  BSF    FEF.1
....................       
....................       sinNew = ads_read_data(ch*2);
044CC:  BCF    FD8.0
044CE:  MOVLB  1
044D0:  RLCF   xE8,W
044D2:  MOVLB  7
044D4:  MOVWF  x03
044D6:  MOVWF  x04
044D8:  MOVLB  0
044DA:  CALL   085C
044DE:  MOVFF  03,6FE
044E2:  MOVFF  02,6FD
044E6:  MOVFF  01,6FC
044EA:  MOVFF  00,6FB
....................       cosNew = ads_read_data(ch*2+1);      
044EE:  BCF    FD8.0
044F0:  MOVLB  1
044F2:  RLCF   xE8,W
044F4:  ADDLW  01
044F6:  MOVLB  7
044F8:  MOVWF  x03
044FA:  MOVWF  x04
044FC:  MOVLB  0
044FE:  CALL   085C
04502:  MOVFF  03,702
04506:  MOVFF  02,701
0450A:  MOVFF  01,700
0450E:  MOVFF  00,6FF
....................       
....................       if (adcFilter){
04512:  MOVLB  1
04514:  BTFSS  x63.0
04516:  BRA    4546
....................          iqm_ring_buffer(ch, sinNew, cosNew);
04518:  MOVFF  1E8,703
0451C:  MOVFF  6FE,707
04520:  MOVFF  6FD,706
04524:  MOVFF  6FC,705
04528:  MOVFF  6FB,704
0452C:  MOVFF  702,70B
04530:  MOVFF  701,70A
04534:  MOVFF  700,709
04538:  MOVFF  6FF,708
0453C:  MOVLB  0
0453E:  GOTO   1776
....................       }
04542:  BRA    45B2
04544:  MOVLB  1
....................       else{
....................          smData[ch].avgSin = sinNew;
04546:  MOVF   xE8,W
04548:  MULLW  09
0454A:  MOVF   FF3,W
0454C:  MOVLB  7
0454E:  CLRF   x04
04550:  MOVWF  x03
04552:  MOVLW  01
04554:  ADDWF  x03,W
04556:  MOVWF  01
04558:  MOVLW  00
0455A:  ADDWFC x04,W
0455C:  MOVWF  03
0455E:  MOVF   01,W
04560:  ADDLW  D4
04562:  MOVWF  FE9
04564:  MOVLW  01
04566:  ADDWFC 03,W
04568:  MOVWF  FEA
0456A:  MOVFF  6FB,FEF
0456E:  MOVFF  6FC,FEC
04572:  MOVFF  6FD,FEC
04576:  MOVFF  6FE,FEC
....................          smData[ch].avgCos = cosNew;
0457A:  MOVLB  1
0457C:  MOVF   xE8,W
0457E:  MULLW  09
04580:  MOVF   FF3,W
04582:  MOVLB  7
04584:  CLRF   x04
04586:  MOVWF  x03
04588:  MOVLW  05
0458A:  ADDWF  x03,W
0458C:  MOVWF  01
0458E:  MOVLW  00
04590:  ADDWFC x04,W
04592:  MOVWF  03
04594:  MOVF   01,W
04596:  ADDLW  D4
04598:  MOVWF  FE9
0459A:  MOVLW  01
0459C:  ADDWFC 03,W
0459E:  MOVWF  FEA
045A0:  MOVFF  6FF,FEF
045A4:  MOVFF  700,FEC
045A8:  MOVFF  701,FEC
045AC:  MOVFF  702,FEC
045B0:  MOVLB  0
....................       }
....................       
....................       sensor_process_data(ch);
045B2:  MOVFF  1E8,703
045B6:  GOTO   370C
....................       ch = !ch;
045BA:  MOVLB  1
045BC:  MOVF   xE8,F
045BE:  BZ    45C4
045C0:  MOVLW  00
045C2:  BRA    45C6
045C4:  MOVLW  01
045C6:  MOVWF  xE8
....................       
....................       smData[!ch].dataReady = false;
045C8:  MOVF   xE8,F
045CA:  BZ    45D0
045CC:  MOVLW  00
045CE:  BRA    45D2
045D0:  MOVLW  01
045D2:  MULLW  09
045D4:  MOVF   FF3,W
045D6:  MOVLB  7
045D8:  CLRF   x04
045DA:  MOVWF  x03
045DC:  MOVLW  D4
045DE:  ADDWF  x03,W
045E0:  MOVWF  FE9
045E2:  MOVLW  01
045E4:  ADDWFC x04,W
045E6:  MOVWF  FEA
045E8:  BCF    FEF.0
....................       smData[!ch].adcBusy = false;
045EA:  MOVLB  1
045EC:  MOVF   xE8,F
045EE:  BZ    45F4
045F0:  MOVLW  00
045F2:  BRA    45F6
045F4:  MOVLW  01
045F6:  MULLW  09
045F8:  MOVF   FF3,W
045FA:  MOVLB  7
045FC:  CLRF   x04
045FE:  MOVWF  x03
04600:  MOVLW  D4
04602:  ADDWF  x03,W
04604:  MOVWF  FE9
04606:  MOVLW  01
04608:  ADDWFC x04,W
0460A:  MOVWF  FEA
0460C:  BCF    FEF.1
....................    }
0460E:  MOVLB  0
04610:  GOTO   A73C (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* INITIALIZE ADC's                                                          */
.................... /*****************************************************************************/
.................... void setup_external_ADCs(){
*
0096A:  MOVLB  6
0096C:  CLRF   xFB
0096E:  CLRF   xFC
00970:  CLRF   xFD
00972:  CLRF   xFE
....................    unsigned int8 rc0=0;
....................    unsigned int8 rc1=0;
....................    unsigned int8 rc2=0;
....................    unsigned int8 rc3=0;
....................    
....................    for (int ch = 0; ch < 4; ch++){
00974:  CLRF   xFF
00976:  MOVF   xFF,W
00978:  SUBLW  03
0097A:  BNC   09B0
....................       rc0=reg0config;
0097C:  MOVLW  30
0097E:  MOVWF  xFB
....................       rc1=reg1config;
00980:  MOVLW  10
00982:  MOVWF  xFC
....................       rc2=reg2config;
00984:  CLRF   xFD
....................       rc3=reg3config;
00986:  CLRF   xFE
....................       
....................       ADS1220init(ch, rc0, rc1, rc2, rc3);
00988:  MOVFF  6FF,701
0098C:  MOVFF  6FB,702
00990:  MOVFF  6FC,703
00994:  MOVFF  6FD,704
00998:  MOVFF  6FE,705
0099C:  MOVLB  0
0099E:  BRA    078E
....................       delay_ms(100);
009A0:  MOVLW  64
009A2:  MOVLB  7
009A4:  MOVWF  x01
009A6:  MOVLB  0
009A8:  RCALL  03CA
009AA:  MOVLB  6
009AC:  INCF   xFF,F
009AE:  BRA    0976
....................    }
....................    
....................    if (adcFilter){
009B0:  MOVLB  1
009B2:  BTFSS  x63.0
009B4:  BRA    0AD6
....................       for (int i = 0; i < BUFFER_SIZE; i++){
009B6:  MOVLB  7
009B8:  CLRF   x00
009BA:  MOVF   x00,W
009BC:  SUBLW  04
009BE:  BTFSS  FD8.0
009C0:  BRA    0AD4
....................          ads_start_conv_all();
009C2:  MOVLB  0
009C4:  BRA    082C
....................          delay_ms(50);
009C6:  MOVLW  32
009C8:  MOVLB  7
009CA:  MOVWF  x01
009CC:  MOVLB  0
009CE:  RCALL  03CA
....................          push(sQ_x, &sIn_x, ads_read_data(0));
009D0:  MOVLB  7
009D2:  CLRF   x04
009D4:  MOVLB  0
009D6:  RCALL  085C
009D8:  MOVFF  03,704
009DC:  MOVFF  02,703
009E0:  MOVFF  01,702
009E4:  MOVFF  00,701
009E8:  MOVLW  01
009EA:  MOVLB  7
009EC:  MOVWF  x2E
009EE:  MOVLW  80
009F0:  MOVWF  x2D
009F2:  MOVLW  01
009F4:  MOVWF  x30
009F6:  MOVLW  D0
009F8:  MOVWF  x2F
009FA:  MOVFF  03,734
009FE:  MOVFF  02,733
00A02:  MOVFF  01,732
00A06:  MOVFF  00,731
00A0A:  MOVLB  0
00A0C:  RCALL  0904
....................          push(cQ_x, &cIn_x, ads_read_data(1));      
00A0E:  MOVLW  01
00A10:  MOVLB  7
00A12:  MOVWF  x04
00A14:  MOVLB  0
00A16:  RCALL  085C
00A18:  MOVFF  03,704
00A1C:  MOVFF  02,703
00A20:  MOVFF  01,702
00A24:  MOVFF  00,701
00A28:  MOVLW  01
00A2A:  MOVLB  7
00A2C:  MOVWF  x2E
00A2E:  MOVLW  94
00A30:  MOVWF  x2D
00A32:  MOVLW  01
00A34:  MOVWF  x30
00A36:  MOVLW  D1
00A38:  MOVWF  x2F
00A3A:  MOVFF  03,734
00A3E:  MOVFF  02,733
00A42:  MOVFF  01,732
00A46:  MOVFF  00,731
00A4A:  MOVLB  0
00A4C:  RCALL  0904
....................          push(sQ_y, &sIn_y, ads_read_data(2));
00A4E:  MOVLW  02
00A50:  MOVLB  7
00A52:  MOVWF  x04
00A54:  MOVLB  0
00A56:  RCALL  085C
00A58:  MOVFF  03,704
00A5C:  MOVFF  02,703
00A60:  MOVFF  01,702
00A64:  MOVFF  00,701
00A68:  MOVLW  01
00A6A:  MOVLB  7
00A6C:  MOVWF  x2E
00A6E:  MOVLW  A8
00A70:  MOVWF  x2D
00A72:  MOVLW  01
00A74:  MOVWF  x30
00A76:  MOVLW  D2
00A78:  MOVWF  x2F
00A7A:  MOVFF  03,734
00A7E:  MOVFF  02,733
00A82:  MOVFF  01,732
00A86:  MOVFF  00,731
00A8A:  MOVLB  0
00A8C:  RCALL  0904
....................          push(cQ_y, &cIn_y, ads_read_data(3));      
00A8E:  MOVLW  03
00A90:  MOVLB  7
00A92:  MOVWF  x04
00A94:  MOVLB  0
00A96:  RCALL  085C
00A98:  MOVFF  03,704
00A9C:  MOVFF  02,703
00AA0:  MOVFF  01,702
00AA4:  MOVFF  00,701
00AA8:  MOVLW  01
00AAA:  MOVLB  7
00AAC:  MOVWF  x2E
00AAE:  MOVLW  BC
00AB0:  MOVWF  x2D
00AB2:  MOVLW  01
00AB4:  MOVWF  x30
00AB6:  MOVLW  D3
00AB8:  MOVWF  x2F
00ABA:  MOVFF  03,734
00ABE:  MOVFF  02,733
00AC2:  MOVFF  01,732
00AC6:  MOVFF  00,731
00ACA:  MOVLB  0
00ACC:  RCALL  0904
00ACE:  MOVLB  7
00AD0:  INCF   x00,F
00AD2:  BRA    09BA
00AD4:  MOVLB  1
....................       }
....................    }
00AD6:  MOVLB  0
00AD8:  GOTO   0B3C (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE MONITOR -- sets up ADC channels                                */
.................... /*****************************************************************************/
.................... void monitor_init(){
....................    setup_adc_ports(sAN6 | sAN16 | sAN17 | sAN24 | sAN25 | sAN26 | sAN27, NO_ANALOGS_P2, VSS_VDD);
00ADC:  MOVLW  00
00ADE:  MOVLB  F
00AE0:  MOVWF  x53
00AE2:  MOVLW  40
00AE4:  MOVWF  x0C
00AE6:  MOVLW  00
00AE8:  MOVWF  x14
00AEA:  MOVLW  03
00AEC:  MOVWF  x1C
00AEE:  MOVLW  0F
00AF0:  MOVWF  x21
00AF2:  MOVLW  00
00AF4:  MOVWF  x29
....................    setup_adc(ADC_CLOCK_INTERNAL | ADC_TAD_MUL_255 | ADC_LEGACY_MODE | ADC_THRESHOLD_INT_DISABLED);
00AF6:  MOVLW  08
00AF8:  MOVWF  x55
00AFA:  CLRF   x56
00AFC:  CLRF   x52
00AFE:  SETF   x57
00B00:  CLRF   F61
00B02:  MOVLW  94
00B04:  MOVWF  x5B
....................    output_high(EN_EXC);
00B06:  MOVLW  E8
00B08:  MOVWF  F8B
00B0A:  BSF    F86.0
....................    set_adc_channel(vMonN15); // internal MUX
00B0C:  MOVF   x5A,W
00B0E:  ANDLW  3F
00B10:  MOVWF  01
00B12:  MOVLW  06
00B14:  MOVWF  x5A
00B16:  BTFSS  x5B.7
00B18:  BRA    0B28
00B1A:  MOVF   01,W
00B1C:  SUBLW  06
00B1E:  BZ    0B28
00B20:  BSF    x5B.0
00B22:  NOP   
00B24:  BTFSC  x5B.0
00B26:  BRA    0B24
....................    delay_ms(10);
00B28:  MOVLW  0A
00B2A:  MOVLB  7
00B2C:  MOVWF  x01
00B2E:  MOVLB  0
00B30:  RCALL  03CA
....................    read_adc(ADC_START_ONLY);
00B32:  MOVLB  F
00B34:  BSF    x5B.0
00B36:  NOP   
....................    setup_external_ADCs();
00B38:  MOVLB  0
00B3A:  BRA    096A
....................    intTimeoutReg = sensorSampleRate;
00B3C:  MOVLB  1
00B3E:  CLRF   x7F
00B40:  MOVLW  32
00B42:  MOVWF  x7E
00B44:  MOVLB  0
00B46:  GOTO   A71E (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <control.h>
.................... #ifndef control
.................... #define control
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................     float kP;      // proportional gain
....................     float kI;      // integral gain
....................     float kD;      // derivative gain
....................     float SP;      // set point-- desired output
....................     float PV;      // process variable-- measured output
....................     float PVold;   // oldPV value  
....................     float CV;      // control variable-- output -- 0 to 100%
....................     float I;       // integral value
....................     float maxSP;   // Max setpoint in microns
....................     float minSP;   // Min setpoint in microns
.................... }PID[2] = {
....................    //  P     I     D
....................    //0.01    0.3   0.1
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}, 
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}
....................     };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... //!#define op_upper_bound 63  // CRYO
.................... //!#define op_lower_bound -63 // CRYO
.................... 
.................... #define op_upper_bound 63  // AMBIENT 
.................... #define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    BOOLEAN homeFlag;       // Flag to trigger the homing routine
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,FALSE},
....................    {0,0,0,0,0,0,0,0,0,0,FALSE}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................     BOOLEAN invV;
....................     unsigned int16 ipVal;
....................     float opPcnt;
....................    
.................... }dacVals[2] = 
.................... {
....................     {FALSE,0,0},
....................     {FALSE,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <pid.h>
.................... #ifndef pidcontroller
.................... #define pidcontroller
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................     float kP;      // proportional gain
....................     float kI;      // integral gain
....................     float kD;      // derivative gain
....................     float SP;      // set point-- desired output
....................     float PV;      // process variable-- measured output
....................     float PVold;   // oldPV value  
....................     float CV;      // control variable-- output -- 0 to 100%
....................     float I;       // integral value
....................     float maxSP;   // Max setpoint in microns
....................     float minSP;   // Min setpoint in microns
.................... }PID[2] = {
....................    //  P     I     D
....................    //0.01    0.3   0.1
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}, 
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}
....................     };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... //!#define op_upper_bound 63  // CRYO
.................... //!#define op_lower_bound -63 // CRYO
.................... 
.................... #define op_upper_bound 63  // AMBIENT 
.................... #define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    BOOLEAN homeFlag;       // Flag to trigger the homing routine
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,FALSE},
....................    {0,0,0,0,0,0,0,0,0,0,FALSE}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................     BOOLEAN invV;
....................     unsigned int16 ipVal;
....................     float opPcnt;
....................    
.................... }dacVals[2] = 
.................... {
....................     {FALSE,0,0},
....................     {FALSE,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float32)(unsigned int16)y;
.................... 
....................  else if (y < 10000000.0)
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
....................       res = 32768.0*(float32)l;
....................       res += (float32)(unsigned int16)y;
....................    }
.................... 
....................  else
....................   res = y;
.................... 
....................  y = y - (float32)(unsigned int16)y;
.................... 
....................  if (s)
....................   res = -res;
.................... 
....................  if (y != 0)
....................  {
....................   if (s == 1 && n == 0)
....................    res -= 1.0;
.................... 
....................   if (s == 0 && n == 1)
....................    res += 1.0;
....................  }
....................  if (x == 0)
....................     res = 0;
.................... 
....................  return (res);
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl[0]*y2 + pl[1];
.................... 
....................       r = ql[0]*y2 + ql[1];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
....................          r = -(float32)-n;
....................       else
....................          r = (float32)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* UPDATE the Control Variable (CV)                                          */
.................... /*****************************************************************************/
.................... void pid_update (channelMap ch){
*
046DC:  MOVLB  7
046DE:  MOVF   x01,W
046E0:  MULLW  28
046E2:  MOVF   FF3,W
046E4:  CLRF   x0F
046E6:  MOVWF  x0E
046E8:  MOVLW  0C
046EA:  ADDWF  x0E,W
046EC:  MOVWF  01
046EE:  MOVLW  00
046F0:  ADDWFC x0F,W
046F2:  MOVWF  03
046F4:  MOVF   01,W
046F6:  ADDLW  20
046F8:  MOVWF  FE9
046FA:  MOVLW  00
046FC:  ADDWFC 03,W
046FE:  MOVWF  FEA
04700:  MOVFF  FEF,74A
04704:  MOVFF  FEC,74B
04708:  MOVFF  FEC,74C
0470C:  MOVFF  FEC,74D
04710:  MOVF   x01,W
04712:  MULLW  28
04714:  MOVF   FF3,W
04716:  CLRF   x13
04718:  MOVWF  x12
0471A:  MOVLW  10
0471C:  ADDWF  x12,W
0471E:  MOVWF  01
04720:  MOVLW  00
04722:  ADDWFC x13,W
04724:  MOVWF  03
04726:  MOVF   01,W
04728:  ADDLW  20
0472A:  MOVWF  FE9
0472C:  MOVLW  00
0472E:  ADDWFC 03,W
04730:  MOVWF  FEA
04732:  MOVFF  FEF,74E
04736:  MOVFF  FEC,01
0473A:  MOVFF  FEC,02
0473E:  MOVFF  FEC,03
04742:  MOVFF  FEA,713
04746:  MOVFF  FE9,712
0474A:  BSF    FD8.1
0474C:  MOVFF  03,751
04750:  MOVFF  02,750
04754:  MOVFF  01,74F
04758:  MOVLB  0
0475A:  CALL   0E96
0475E:  MOVFF  713,FEA
04762:  MOVFF  712,FE9
04766:  MOVFF  03,705
0476A:  MOVFF  02,704
0476E:  MOVFF  01,703
04772:  MOVFF  00,702
....................    float err = PID[ch].SP - PID[ch].PV;  // error = set value - measured
....................    
....................    PID[ch].I += err*PID[ch].kI;
04776:  MOVLB  7
04778:  MOVF   x01,W
0477A:  MULLW  28
0477C:  MOVF   FF3,W
0477E:  CLRF   x0F
04780:  MOVWF  x0E
04782:  MOVLW  1C
04784:  ADDWF  x0E,W
04786:  MOVWF  01
04788:  MOVLW  00
0478A:  ADDWFC x0F,W
0478C:  MOVWF  03
0478E:  MOVF   01,W
04790:  ADDLW  20
04792:  MOVWF  01
04794:  MOVLW  00
04796:  ADDWFC 03,F
04798:  MOVFF  01,70E
0479C:  MOVFF  03,70F
047A0:  MOVFF  03,FEA
047A4:  MOVFF  01,FE9
047A8:  MOVFF  FEF,710
047AC:  MOVFF  FEC,711
047B0:  MOVFF  FEC,712
047B4:  MOVFF  FEC,713
047B8:  MOVF   x01,W
047BA:  MULLW  28
047BC:  MOVF   FF3,W
047BE:  CLRF   x15
047C0:  MOVWF  x14
047C2:  MOVLW  04
047C4:  ADDWF  x14,W
047C6:  MOVWF  01
047C8:  MOVLW  00
047CA:  ADDWFC x15,W
047CC:  MOVWF  03
047CE:  MOVF   01,W
047D0:  ADDLW  20
047D2:  MOVWF  FE9
047D4:  MOVLW  00
047D6:  ADDWFC 03,W
047D8:  MOVWF  FEA
047DA:  MOVFF  FEF,754
047DE:  MOVFF  FEC,01
047E2:  MOVFF  FEC,02
047E6:  MOVFF  FEC,03
047EA:  MOVFF  705,753
047EE:  MOVFF  704,752
047F2:  MOVFF  703,751
047F6:  MOVFF  702,750
047FA:  MOVFF  03,757
047FE:  MOVFF  02,756
04802:  MOVFF  01,755
04806:  MOVLB  0
04808:  CALL   0DA0
0480C:  BCF    FD8.1
0480E:  MOVFF  713,74D
04812:  MOVFF  712,74C
04816:  MOVFF  711,74B
0481A:  MOVFF  710,74A
0481E:  MOVFF  03,751
04822:  MOVFF  02,750
04826:  MOVFF  01,74F
0482A:  MOVFF  00,74E
0482E:  CALL   0E96
04832:  MOVFF  70F,FEA
04836:  MOVFF  70E,FE9
0483A:  MOVFF  00,FEF
0483E:  MOVFF  01,FEC
04842:  MOVFF  02,FEC
04846:  MOVFF  03,FEC
....................    if (PID[ch].I > op_upper_bound) PID[ch].I = op_upper_bound; // anti-windup
0484A:  MOVLB  7
0484C:  MOVF   x01,W
0484E:  MULLW  28
04850:  MOVF   FF3,W
04852:  CLRF   x0F
04854:  MOVWF  x0E
04856:  MOVLW  1C
04858:  ADDWF  x0E,W
0485A:  MOVWF  01
0485C:  MOVLW  00
0485E:  ADDWFC x0F,W
04860:  MOVWF  03
04862:  MOVF   01,W
04864:  ADDLW  20
04866:  MOVWF  FE9
04868:  MOVLW  00
0486A:  ADDWFC 03,W
0486C:  MOVWF  FEA
0486E:  MOVFF  FEF,74A
04872:  MOVFF  FEC,70F
04876:  MOVFF  FEC,74C
0487A:  MOVFF  FEC,74D
0487E:  CLRF   x49
04880:  CLRF   x48
04882:  MOVLW  7C
04884:  MOVWF  x47
04886:  MOVLW  84
04888:  MOVWF  x46
0488A:  MOVFF  70F,74B
0488E:  MOVLB  0
04890:  CALL   1D2C
04894:  BNC   48C8
04896:  MOVLB  7
04898:  MOVF   x01,W
0489A:  MULLW  28
0489C:  MOVF   FF3,W
0489E:  CLRF   x0F
048A0:  MOVWF  x0E
048A2:  MOVLW  1C
048A4:  ADDWF  x0E,W
048A6:  MOVWF  01
048A8:  MOVLW  00
048AA:  ADDWFC x0F,W
048AC:  MOVWF  03
048AE:  MOVF   01,W
048B0:  ADDLW  20
048B2:  MOVWF  FE9
048B4:  MOVLW  00
048B6:  ADDWFC 03,W
048B8:  MOVWF  FEA
048BA:  MOVLW  84
048BC:  MOVWF  FEF
048BE:  MOVLW  7C
048C0:  MOVWF  FEC
048C2:  CLRF   FEC
048C4:  CLRF   FEC
048C6:  BRA    4944
....................    else if (PID[ch].I < op_lower_bound) PID[ch].I = op_lower_bound;
048C8:  MOVLB  7
048CA:  MOVF   x01,W
048CC:  MULLW  28
048CE:  MOVF   FF3,W
048D0:  CLRF   x0F
048D2:  MOVWF  x0E
048D4:  MOVLW  1C
048D6:  ADDWF  x0E,W
048D8:  MOVWF  01
048DA:  MOVLW  00
048DC:  ADDWFC x0F,W
048DE:  MOVWF  03
048E0:  MOVF   01,W
048E2:  ADDLW  20
048E4:  MOVWF  FE9
048E6:  MOVLW  00
048E8:  ADDWFC 03,W
048EA:  MOVWF  FEA
048EC:  MOVFF  FEF,746
048F0:  MOVFF  FEC,70F
048F4:  MOVFF  FEC,748
048F8:  MOVFF  FEC,749
048FC:  MOVFF  70F,747
04900:  CLRF   x4D
04902:  CLRF   x4C
04904:  MOVLW  C0
04906:  MOVWF  x4B
04908:  MOVLW  82
0490A:  MOVWF  x4A
0490C:  MOVLB  0
0490E:  CALL   1D2C
04912:  BNC   4946
04914:  MOVLB  7
04916:  MOVF   x01,W
04918:  MULLW  28
0491A:  MOVF   FF3,W
0491C:  CLRF   x0F
0491E:  MOVWF  x0E
04920:  MOVLW  1C
04922:  ADDWF  x0E,W
04924:  MOVWF  01
04926:  MOVLW  00
04928:  ADDWFC x0F,W
0492A:  MOVWF  03
0492C:  MOVF   01,W
0492E:  ADDLW  20
04930:  MOVWF  FE9
04932:  MOVLW  00
04934:  ADDWFC 03,W
04936:  MOVWF  FEA
04938:  MOVLW  82
0493A:  MOVWF  FEF
0493C:  MOVLW  C0
0493E:  MOVWF  FEC
04940:  CLRF   FEC
04942:  CLRF   FEC
04944:  MOVLB  0
....................    
....................    float P = err * PID[ch].kP;  // proportional value
....................    
....................    float D = PID[ch].kD * (PID[ch].PV - PID[ch].PVold);  // derivative value
04946:  MOVLB  7
04948:  MOVF   x01,W
0494A:  MULLW  28
0494C:  MOVF   FF3,W
0494E:  CLRF   x0F
04950:  MOVWF  x0E
04952:  MOVLW  20
04954:  ADDWF  x0E,W
04956:  MOVWF  FE9
04958:  MOVLW  00
0495A:  ADDWFC x0F,W
0495C:  MOVWF  FEA
0495E:  MOVFF  FEF,754
04962:  MOVFF  FEC,01
04966:  MOVFF  FEC,02
0496A:  MOVFF  FEC,03
0496E:  MOVFF  705,753
04972:  MOVFF  704,752
04976:  MOVFF  703,751
0497A:  MOVFF  702,750
0497E:  MOVFF  03,757
04982:  MOVFF  02,756
04986:  MOVFF  01,755
0498A:  MOVLB  0
0498C:  CALL   0DA0
04990:  MOVFF  03,709
04994:  MOVFF  02,708
04998:  MOVFF  01,707
0499C:  MOVFF  00,706
049A0:  MOVLB  7
049A2:  MOVF   x01,W
049A4:  MULLW  28
049A6:  MOVF   FF3,W
049A8:  CLRF   x11
049AA:  MOVWF  x10
049AC:  MOVLW  08
049AE:  ADDWF  x10,W
049B0:  MOVWF  01
049B2:  MOVLW  00
049B4:  ADDWFC x11,W
049B6:  MOVWF  03
049B8:  MOVF   01,W
049BA:  ADDLW  20
049BC:  MOVWF  FE9
049BE:  MOVLW  00
049C0:  ADDWFC 03,W
049C2:  MOVWF  FEA
049C4:  MOVFF  FEF,710
049C8:  MOVFF  FEC,711
049CC:  MOVFF  FEC,712
049D0:  MOVFF  FEC,713
049D4:  MOVF   x01,W
049D6:  MULLW  28
049D8:  MOVF   FF3,W
049DA:  CLRF   x15
049DC:  MOVWF  x14
049DE:  MOVLW  10
049E0:  ADDWF  x14,W
049E2:  MOVWF  01
049E4:  MOVLW  00
049E6:  ADDWFC x15,W
049E8:  MOVWF  03
049EA:  MOVF   01,W
049EC:  ADDLW  20
049EE:  MOVWF  FE9
049F0:  MOVLW  00
049F2:  ADDWFC 03,W
049F4:  MOVWF  FEA
049F6:  MOVFF  FEF,74A
049FA:  MOVFF  FEC,74B
049FE:  MOVFF  FEC,74C
04A02:  MOVFF  FEC,74D
04A06:  MOVF   x01,W
04A08:  MULLW  28
04A0A:  MOVF   FF3,W
04A0C:  CLRF   x19
04A0E:  MOVWF  x18
04A10:  MOVLW  14
04A12:  ADDWF  x18,W
04A14:  MOVWF  01
04A16:  MOVLW  00
04A18:  ADDWFC x19,W
04A1A:  MOVWF  03
04A1C:  MOVF   01,W
04A1E:  ADDLW  20
04A20:  MOVWF  FE9
04A22:  MOVLW  00
04A24:  ADDWFC 03,W
04A26:  MOVWF  FEA
04A28:  MOVFF  FEF,74E
04A2C:  MOVFF  FEC,01
04A30:  MOVFF  FEC,02
04A34:  MOVFF  FEC,03
04A38:  MOVFF  FEA,719
04A3C:  MOVFF  FE9,718
04A40:  BSF    FD8.1
04A42:  MOVFF  03,751
04A46:  MOVFF  02,750
04A4A:  MOVFF  01,74F
04A4E:  MOVLB  0
04A50:  CALL   0E96
04A54:  MOVFF  719,FEA
04A58:  MOVFF  718,FE9
04A5C:  MOVFF  713,753
04A60:  MOVFF  712,752
04A64:  MOVFF  711,751
04A68:  MOVFF  710,750
04A6C:  MOVFF  03,757
04A70:  MOVFF  02,756
04A74:  MOVFF  01,755
04A78:  MOVFF  00,754
04A7C:  CALL   0DA0
04A80:  MOVFF  03,70D
04A84:  MOVFF  02,70C
04A88:  MOVFF  01,70B
04A8C:  MOVFF  00,70A
....................    
....................    PID[ch].CV = P + PID[ch].I + D;  // new control variable
04A90:  MOVLB  7
04A92:  MOVF   x01,W
04A94:  MULLW  28
04A96:  MOVF   FF3,W
04A98:  CLRF   x0F
04A9A:  MOVWF  x0E
04A9C:  MOVLW  18
04A9E:  ADDWF  x0E,W
04AA0:  MOVWF  01
04AA2:  MOVLW  00
04AA4:  ADDWFC x0F,W
04AA6:  MOVWF  03
04AA8:  MOVF   01,W
04AAA:  ADDLW  20
04AAC:  MOVWF  01
04AAE:  MOVLW  00
04AB0:  ADDWFC 03,F
04AB2:  MOVFF  01,70E
04AB6:  MOVFF  03,70F
04ABA:  MOVF   x01,W
04ABC:  MULLW  28
04ABE:  MOVF   FF3,W
04AC0:  CLRF   x11
04AC2:  MOVWF  x10
04AC4:  MOVLW  1C
04AC6:  ADDWF  x10,W
04AC8:  MOVWF  01
04ACA:  MOVLW  00
04ACC:  ADDWFC x11,W
04ACE:  MOVWF  03
04AD0:  MOVF   01,W
04AD2:  ADDLW  20
04AD4:  MOVWF  FE9
04AD6:  MOVLW  00
04AD8:  ADDWFC 03,W
04ADA:  MOVWF  FEA
04ADC:  MOVFF  FEF,74E
04AE0:  MOVFF  FEC,01
04AE4:  MOVFF  FEC,02
04AE8:  MOVFF  FEC,03
04AEC:  MOVFF  FEA,711
04AF0:  MOVFF  FE9,710
04AF4:  BCF    FD8.1
04AF6:  MOVFF  709,74D
04AFA:  MOVFF  708,74C
04AFE:  MOVFF  707,74B
04B02:  MOVFF  706,74A
04B06:  MOVFF  03,751
04B0A:  MOVFF  02,750
04B0E:  MOVFF  01,74F
04B12:  MOVLB  0
04B14:  CALL   0E96
04B18:  MOVFF  711,FEA
04B1C:  MOVFF  710,FE9
04B20:  MOVFF  03,715
04B24:  MOVFF  02,714
04B28:  MOVFF  01,713
04B2C:  MOVFF  00,712
04B30:  BCF    FD8.1
04B32:  MOVFF  03,74D
04B36:  MOVFF  02,74C
04B3A:  MOVFF  01,74B
04B3E:  MOVFF  00,74A
04B42:  MOVFF  70D,751
04B46:  MOVFF  70C,750
04B4A:  MOVFF  70B,74F
04B4E:  MOVFF  70A,74E
04B52:  CALL   0E96
04B56:  MOVFF  70F,FEA
04B5A:  MOVFF  70E,FE9
04B5E:  MOVFF  00,FEF
04B62:  MOVFF  01,FEC
04B66:  MOVFF  02,FEC
04B6A:  MOVFF  03,FEC
....................    if (PID[ch].CV > op_upper_bound) PID[ch].CV = op_upper_bound; // limit positive output
04B6E:  MOVLB  7
04B70:  MOVF   x01,W
04B72:  MULLW  28
04B74:  MOVF   FF3,W
04B76:  CLRF   x0F
04B78:  MOVWF  x0E
04B7A:  MOVLW  18
04B7C:  ADDWF  x0E,W
04B7E:  MOVWF  01
04B80:  MOVLW  00
04B82:  ADDWFC x0F,W
04B84:  MOVWF  03
04B86:  MOVF   01,W
04B88:  ADDLW  20
04B8A:  MOVWF  FE9
04B8C:  MOVLW  00
04B8E:  ADDWFC 03,W
04B90:  MOVWF  FEA
04B92:  MOVFF  FEF,74A
04B96:  MOVFF  FEC,70F
04B9A:  MOVFF  FEC,74C
04B9E:  MOVFF  FEC,74D
04BA2:  CLRF   x49
04BA4:  CLRF   x48
04BA6:  MOVLW  7C
04BA8:  MOVWF  x47
04BAA:  MOVLW  84
04BAC:  MOVWF  x46
04BAE:  MOVFF  70F,74B
04BB2:  MOVLB  0
04BB4:  CALL   1D2C
04BB8:  BNC   4BEC
04BBA:  MOVLB  7
04BBC:  MOVF   x01,W
04BBE:  MULLW  28
04BC0:  MOVF   FF3,W
04BC2:  CLRF   x0F
04BC4:  MOVWF  x0E
04BC6:  MOVLW  18
04BC8:  ADDWF  x0E,W
04BCA:  MOVWF  01
04BCC:  MOVLW  00
04BCE:  ADDWFC x0F,W
04BD0:  MOVWF  03
04BD2:  MOVF   01,W
04BD4:  ADDLW  20
04BD6:  MOVWF  FE9
04BD8:  MOVLW  00
04BDA:  ADDWFC 03,W
04BDC:  MOVWF  FEA
04BDE:  MOVLW  84
04BE0:  MOVWF  FEF
04BE2:  MOVLW  7C
04BE4:  MOVWF  FEC
04BE6:  CLRF   FEC
04BE8:  CLRF   FEC
04BEA:  BRA    4C68
....................    else if (PID[ch].CV < op_lower_bound) PID[ch].CV = op_lower_bound; // limit negative output
04BEC:  MOVLB  7
04BEE:  MOVF   x01,W
04BF0:  MULLW  28
04BF2:  MOVF   FF3,W
04BF4:  CLRF   x0F
04BF6:  MOVWF  x0E
04BF8:  MOVLW  18
04BFA:  ADDWF  x0E,W
04BFC:  MOVWF  01
04BFE:  MOVLW  00
04C00:  ADDWFC x0F,W
04C02:  MOVWF  03
04C04:  MOVF   01,W
04C06:  ADDLW  20
04C08:  MOVWF  FE9
04C0A:  MOVLW  00
04C0C:  ADDWFC 03,W
04C0E:  MOVWF  FEA
04C10:  MOVFF  FEF,746
04C14:  MOVFF  FEC,70F
04C18:  MOVFF  FEC,748
04C1C:  MOVFF  FEC,749
04C20:  MOVFF  70F,747
04C24:  CLRF   x4D
04C26:  CLRF   x4C
04C28:  MOVLW  C0
04C2A:  MOVWF  x4B
04C2C:  MOVLW  82
04C2E:  MOVWF  x4A
04C30:  MOVLB  0
04C32:  CALL   1D2C
04C36:  BNC   4C68
04C38:  MOVLB  7
04C3A:  MOVF   x01,W
04C3C:  MULLW  28
04C3E:  MOVF   FF3,W
04C40:  CLRF   x0F
04C42:  MOVWF  x0E
04C44:  MOVLW  18
04C46:  ADDWF  x0E,W
04C48:  MOVWF  01
04C4A:  MOVLW  00
04C4C:  ADDWFC x0F,W
04C4E:  MOVWF  03
04C50:  MOVF   01,W
04C52:  ADDLW  20
04C54:  MOVWF  FE9
04C56:  MOVLW  00
04C58:  ADDWFC 03,W
04C5A:  MOVWF  FEA
04C5C:  MOVLW  82
04C5E:  MOVWF  FEF
04C60:  MOVLW  C0
04C62:  MOVWF  FEC
04C64:  CLRF   FEC
04C66:  CLRF   FEC
04C68:  MOVLB  0
04C6A:  GOTO   4CE8 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PID Task - looks for change to PV and updates CV                          */
.................... /*****************************************************************************/
.................... void pid_task(channelMap ch){
....................    static int index = 0;
....................    if (PID[ch].SP != PID[ch].PV) pid_update(ch);
04C6E:  MOVLB  6
04C70:  MOVF   xFE,W
04C72:  MULLW  28
04C74:  MOVF   FF3,W
04C76:  MOVLB  7
04C78:  CLRF   x01
04C7A:  MOVWF  x00
04C7C:  MOVLW  0C
04C7E:  ADDWF  x00,W
04C80:  MOVWF  01
04C82:  MOVLW  00
04C84:  ADDWFC x01,W
04C86:  MOVWF  03
04C88:  MOVF   01,W
04C8A:  ADDLW  20
04C8C:  MOVWF  FE9
04C8E:  MOVLW  00
04C90:  ADDWFC 03,W
04C92:  MOVWF  FEA
04C94:  MOVFF  FEF,746
04C98:  MOVFF  FEC,747
04C9C:  MOVFF  FEC,748
04CA0:  MOVFF  FEC,749
04CA4:  MOVLB  6
04CA6:  MOVF   xFE,W
04CA8:  MULLW  28
04CAA:  MOVF   FF3,W
04CAC:  MOVLB  7
04CAE:  CLRF   x05
04CB0:  MOVWF  x04
04CB2:  MOVLW  10
04CB4:  ADDWF  x04,W
04CB6:  MOVWF  01
04CB8:  MOVLW  00
04CBA:  ADDWFC x05,W
04CBC:  MOVWF  03
04CBE:  MOVF   01,W
04CC0:  ADDLW  20
04CC2:  MOVWF  FE9
04CC4:  MOVLW  00
04CC6:  ADDWFC 03,W
04CC8:  MOVWF  FEA
04CCA:  MOVFF  FEF,74A
04CCE:  MOVFF  FEC,74B
04CD2:  MOVFF  FEC,74C
04CD6:  MOVFF  FEC,74D
04CDA:  MOVLB  0
04CDC:  CALL   1D2C
04CE0:  BZ    4CE8
04CE2:  MOVFF  6FE,701
04CE6:  BRA    46DC
....................    if ((index++) >= numChannels) index = 0;
04CE8:  MOVLB  1
04CEA:  MOVF   xE9,W
04CEC:  INCF   xE9,F
04CEE:  SUBLW  01
04CF0:  BC    4CF4
04CF2:  CLRF   xE9
04CF4:  MOVLB  0
04CF6:  GOTO   4E08 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... #pin_select SCK1=PIN_C3
.................... #pin_select SDO1=PIN_C2
.................... #use spi (MASTER, SPI1, BAUD=100000, MODE=2, STREAM=SPI_ctrl)
*
00B4A:  CLRF   03
00B4C:  MOVF   F91,W
00B4E:  MOVFF  700,F91
00B52:  RRCF   F94,W
00B54:  BNC   0B52
00B56:  MOVF   F91,W
00B58:  MOVWF  02
00B5A:  MOVFF  6FF,F91
00B5E:  RRCF   F94,W
00B60:  BNC   0B5E
00B62:  MOVF   F91,W
00B64:  MOVWF  01
00B66:  MOVFF  6FE,F91
00B6A:  RRCF   F94,W
00B6C:  BNC   0B6A
00B6E:  MOVFF  F91,00
00B72:  RETURN 0
.................... 
.................... #define DACfullScale 655.35 // full scale/100 because CV = %
.................... 
.................... /*****************************************************************************/
.................... /*  Inverts the output voltage ( -180V - 0V )                                */ 
.................... /*****************************************************************************/
.................... void invert_voltage(channelMap ch, BOOLEAN inv_v){
....................    if ( inv_v ) {
*
0464A:  MOVLB  6
0464C:  MOVF   xFF,F
0464E:  BZ    4696
....................       if (chMap[0] == ch) output_low(INV_HVX);
04650:  MOVLW  00
04652:  MOVLB  0
04654:  BTFSC  x70.0
04656:  MOVLW  01
04658:  MOVLB  6
0465A:  SUBWF  xFE,W
0465C:  BNZ   4664
0465E:  MOVLW  04
04660:  MOVWF  F88
04662:  BCF    F83.4
....................       if (chMap[1] == ch) output_low(INV_HVY);
04664:  MOVLW  00
04666:  MOVLB  0
04668:  BTFSC  x70.1
0466A:  MOVLW  01
0466C:  MOVLB  6
0466E:  SUBWF  xFE,W
04670:  BNZ   4678
04672:  MOVLW  04
04674:  MOVWF  F88
04676:  BCF    F83.5
....................       dacVals[ch].invV = TRUE;
04678:  MOVF   xFE,W
0467A:  MULLW  07
0467C:  MOVF   FF3,W
0467E:  MOVLB  7
04680:  CLRF   x01
04682:  MOVWF  x00
04684:  MOVLW  64
04686:  ADDWF  x00,W
04688:  MOVWF  FE9
0468A:  MOVLW  01
0468C:  ADDWFC x01,W
0468E:  MOVWF  FEA
04690:  BSF    FEF.0
....................    }
04692:  BRA    46D8
04694:  MOVLB  6
....................    else {
....................       if (chMap[0] == ch) output_high(INV_HVX);
04696:  MOVLW  00
04698:  MOVLB  0
0469A:  BTFSC  x70.0
0469C:  MOVLW  01
0469E:  MOVLB  6
046A0:  SUBWF  xFE,W
046A2:  BNZ   46AA
046A4:  MOVLW  04
046A6:  MOVWF  F88
046A8:  BSF    F83.4
....................       if (chMap[1] == ch) output_high(INV_HVY);
046AA:  MOVLW  00
046AC:  MOVLB  0
046AE:  BTFSC  x70.1
046B0:  MOVLW  01
046B2:  MOVLB  6
046B4:  SUBWF  xFE,W
046B6:  BNZ   46BE
046B8:  MOVLW  04
046BA:  MOVWF  F88
046BC:  BSF    F83.5
....................       dacVals[ch].invV = FALSE;
046BE:  MOVF   xFE,W
046C0:  MULLW  07
046C2:  MOVF   FF3,W
046C4:  MOVLB  7
046C6:  CLRF   x01
046C8:  MOVWF  x00
046CA:  MOVLW  64
046CC:  ADDWF  x00,W
046CE:  MOVWF  FE9
046D0:  MOVLW  01
046D2:  ADDWFC x01,W
046D4:  MOVWF  FEA
046D6:  BCF    FEF.0
....................    }
046D8:  MOVLB  0
046DA:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  Nano DAC's have a 16bit serial shift register. Data is sync'ed to output */ 
.................... /*****************************************************************************/
.................... void set_nanoDAC_outputs(channelMap ch){
*
04CFA:  MOVLB  6
04CFC:  CLRF   xFD
04CFE:  CLRF   xFC
....................     unsigned int16 txData = 0;
....................    
....................     // use dacVals.opPcnt values if channel is manual mode
....................     // else, use PID control variable
....................     if (chMode[ch] == MANUAL){
04D00:  MOVFF  6FB,70D
04D04:  MOVLB  7
04D06:  CLRF   x0F
04D08:  MOVLW  71
04D0A:  MOVWF  x0E
04D0C:  MOVLB  0
04D0E:  RCALL  4614
04D10:  MOVF   01,F
04D12:  BNZ   4E02
....................         if ( dacVals[ch].opPcnt < 0) invert_voltage(ch, TRUE); 
04D14:  MOVLB  6
04D16:  MOVF   xFB,W
04D18:  MULLW  07
04D1A:  MOVF   FF3,W
04D1C:  CLRF   xFF
04D1E:  MOVWF  xFE
04D20:  MOVLW  03
04D22:  ADDWF  xFE,W
04D24:  MOVWF  01
04D26:  MOVLW  00
04D28:  ADDWFC xFF,W
04D2A:  MOVWF  03
04D2C:  MOVF   01,W
04D2E:  ADDLW  64
04D30:  MOVWF  FE9
04D32:  MOVLW  01
04D34:  ADDWFC 03,W
04D36:  MOVWF  FEA
04D38:  MOVFF  FEF,746
04D3C:  MOVFF  FEC,747
04D40:  MOVFF  FEC,748
04D44:  MOVFF  FEC,749
04D48:  MOVLB  7
04D4A:  CLRF   x4D
04D4C:  CLRF   x4C
04D4E:  CLRF   x4B
04D50:  CLRF   x4A
04D52:  MOVLB  0
04D54:  CALL   1D2C
04D58:  BNC   4D6A
04D5A:  MOVFF  6FB,6FE
04D5E:  MOVLW  01
04D60:  MOVLB  6
04D62:  MOVWF  xFF
04D64:  MOVLB  0
04D66:  RCALL  464A
04D68:  BRA    4D76
....................         else                         invert_voltage(ch, FALSE);
04D6A:  MOVFF  6FB,6FE
04D6E:  MOVLB  6
04D70:  CLRF   xFF
04D72:  MOVLB  0
04D74:  RCALL  464A
....................       
....................         txData = (unsigned int16)(abs(dacVals[ch].opPcnt) * DACfullScale);
04D76:  MOVLB  6
04D78:  MOVF   xFB,W
04D7A:  MULLW  07
04D7C:  MOVF   FF3,W
04D7E:  CLRF   xFF
04D80:  MOVWF  xFE
04D82:  MOVLW  03
04D84:  ADDWF  xFE,W
04D86:  MOVWF  01
04D88:  MOVLW  00
04D8A:  ADDWFC xFF,W
04D8C:  MOVWF  03
04D8E:  MOVF   01,W
04D90:  ADDLW  64
04D92:  MOVWF  FE9
04D94:  MOVLW  01
04D96:  ADDWFC 03,W
04D98:  MOVWF  FEA
04D9A:  MOVFF  FEF,00
04D9E:  MOVFF  FEC,01
04DA2:  MOVFF  FEC,02
04DA6:  MOVFF  FEC,03
04DAA:  BCF    01.7
04DAC:  MOVFF  03,701
04DB0:  MOVFF  02,700
04DB4:  MOVFF  01,6FF
04DB8:  MOVFF  00,6FE
04DBC:  MOVFF  03,753
04DC0:  MOVFF  02,752
04DC4:  MOVFF  01,751
04DC8:  MOVFF  00,750
04DCC:  MOVLW  66
04DCE:  MOVLB  7
04DD0:  MOVWF  x57
04DD2:  MOVLW  D6
04DD4:  MOVWF  x56
04DD6:  MOVLW  23
04DD8:  MOVWF  x55
04DDA:  MOVLW  88
04DDC:  MOVWF  x54
04DDE:  MOVLB  0
04DE0:  CALL   0DA0
04DE4:  MOVFF  03,749
04DE8:  MOVFF  02,748
04DEC:  MOVFF  01,747
04DF0:  MOVFF  00,746
04DF4:  CALL   2720
04DF8:  MOVFF  02,6FD
04DFC:  MOVFF  01,6FC
....................     }
04E00:  BRA    4EF8
....................     else {
....................         pid_task(ch);
04E02:  MOVFF  6FB,6FE
04E06:  BRA    4C6E
....................         if ( PID[(int)ch].CV < 0 ) invert_voltage(ch, TRUE); 
04E08:  MOVLB  6
04E0A:  MOVF   xFB,W
04E0C:  MULLW  28
04E0E:  MOVF   FF3,W
04E10:  CLRF   xFF
04E12:  MOVWF  xFE
04E14:  MOVLW  18
04E16:  ADDWF  xFE,W
04E18:  MOVWF  01
04E1A:  MOVLW  00
04E1C:  ADDWFC xFF,W
04E1E:  MOVWF  03
04E20:  MOVF   01,W
04E22:  ADDLW  20
04E24:  MOVWF  FE9
04E26:  MOVLW  00
04E28:  ADDWFC 03,W
04E2A:  MOVWF  FEA
04E2C:  MOVFF  FEF,746
04E30:  MOVFF  FEC,747
04E34:  MOVFF  FEC,748
04E38:  MOVFF  FEC,749
04E3C:  MOVLB  7
04E3E:  CLRF   x4D
04E40:  CLRF   x4C
04E42:  CLRF   x4B
04E44:  CLRF   x4A
04E46:  MOVLB  0
04E48:  CALL   1D2C
04E4C:  BNC   4E60
04E4E:  MOVFF  6FB,6FE
04E52:  MOVLW  01
04E54:  MOVLB  6
04E56:  MOVWF  xFF
04E58:  MOVLB  0
04E5A:  CALL   464A
04E5E:  BRA    4E6E
....................         else                       invert_voltage(ch, FALSE);
04E60:  MOVFF  6FB,6FE
04E64:  MOVLB  6
04E66:  CLRF   xFF
04E68:  MOVLB  0
04E6A:  CALL   464A
....................       
....................         txData = (unsigned int16)(abs(PID[(int)ch].CV) * DACfullScale);
04E6E:  MOVLB  6
04E70:  MOVF   xFB,W
04E72:  MULLW  28
04E74:  MOVF   FF3,W
04E76:  CLRF   xFF
04E78:  MOVWF  xFE
04E7A:  MOVLW  18
04E7C:  ADDWF  xFE,W
04E7E:  MOVWF  01
04E80:  MOVLW  00
04E82:  ADDWFC xFF,W
04E84:  MOVWF  03
04E86:  MOVF   01,W
04E88:  ADDLW  20
04E8A:  MOVWF  FE9
04E8C:  MOVLW  00
04E8E:  ADDWFC 03,W
04E90:  MOVWF  FEA
04E92:  MOVFF  FEF,00
04E96:  MOVFF  FEC,01
04E9A:  MOVFF  FEC,02
04E9E:  MOVFF  FEC,03
04EA2:  BCF    01.7
04EA4:  MOVFF  03,701
04EA8:  MOVFF  02,700
04EAC:  MOVFF  01,6FF
04EB0:  MOVFF  00,6FE
04EB4:  MOVFF  03,753
04EB8:  MOVFF  02,752
04EBC:  MOVFF  01,751
04EC0:  MOVFF  00,750
04EC4:  MOVLW  66
04EC6:  MOVLB  7
04EC8:  MOVWF  x57
04ECA:  MOVLW  D6
04ECC:  MOVWF  x56
04ECE:  MOVLW  23
04ED0:  MOVWF  x55
04ED2:  MOVLW  88
04ED4:  MOVWF  x54
04ED6:  MOVLB  0
04ED8:  CALL   0DA0
04EDC:  MOVFF  03,749
04EE0:  MOVFF  02,748
04EE4:  MOVFF  01,747
04EE8:  MOVFF  00,746
04EEC:  CALL   2720
04EF0:  MOVFF  02,6FD
04EF4:  MOVFF  01,6FC
....................     }
....................    
....................     dacVals[ch].ipVal = txData;
04EF8:  MOVLB  6
04EFA:  MOVF   xFB,W
04EFC:  MULLW  07
04EFE:  MOVF   FF3,W
04F00:  CLRF   xFF
04F02:  MOVWF  xFE
04F04:  MOVLW  01
04F06:  ADDWF  xFE,W
04F08:  MOVWF  01
04F0A:  MOVLW  00
04F0C:  ADDWFC xFF,W
04F0E:  MOVWF  03
04F10:  MOVF   01,W
04F12:  ADDLW  64
04F14:  MOVWF  FE9
04F16:  MOVLW  01
04F18:  ADDWFC 03,W
04F1A:  MOVWF  FEA
04F1C:  MOVFF  6FD,FEC
04F20:  MOVF   FED,F
04F22:  MOVFF  6FC,FEF
....................    
....................     // use channel map to decide which outputs channels to update
....................     // strobe _sync low to push data to the outputs
....................     if (chMap[0] == ch) output_high(_SYNC_X);
04F26:  MOVLW  00
04F28:  MOVLB  0
04F2A:  BTFSC  x70.0
04F2C:  MOVLW  01
04F2E:  MOVLB  6
04F30:  SUBWF  xFB,W
04F32:  BNZ   4F3A
04F34:  MOVLW  E8
04F36:  MOVWF  F8B
04F38:  BSF    F86.2
....................     if (chMap[1] == ch) output_high(_SYNC_Y);
04F3A:  MOVLW  00
04F3C:  MOVLB  0
04F3E:  BTFSC  x70.1
04F40:  MOVLW  01
04F42:  MOVLB  6
04F44:  SUBWF  xFB,W
04F46:  BNZ   4F4E
04F48:  MOVLW  E8
04F4A:  MOVWF  F8B
04F4C:  BSF    F86.1
....................    
....................     delay_ms(1);
04F4E:  MOVLW  01
04F50:  MOVLB  7
04F52:  MOVWF  x01
04F54:  MOVLB  0
04F56:  CALL   03CA
....................    
....................     if (chMap[0] == ch) output_low(_SYNC_X);
04F5A:  MOVLW  00
04F5C:  BTFSC  x70.0
04F5E:  MOVLW  01
04F60:  MOVLB  6
04F62:  SUBWF  xFB,W
04F64:  BNZ   4F6C
04F66:  MOVLW  E8
04F68:  MOVWF  F8B
04F6A:  BCF    F86.2
....................     if (chMap[1] == ch) output_low(_SYNC_Y);
04F6C:  MOVLW  00
04F6E:  MOVLB  0
04F70:  BTFSC  x70.1
04F72:  MOVLW  01
04F74:  MOVLB  6
04F76:  SUBWF  xFB,W
04F78:  BNZ   4F80
04F7A:  MOVLW  E8
04F7C:  MOVWF  F8B
04F7E:  BCF    F86.1
....................     delay_ms(1);
04F80:  MOVLW  01
04F82:  MOVLB  7
04F84:  MOVWF  x01
04F86:  MOVLB  0
04F88:  CALL   03CA
....................    
....................     // shift 16 bits of data
....................     spi_xfer(SPI_ctrl, txData, 24);
04F8C:  MOVLB  7
04F8E:  CLRF   x01
04F90:  CLRF   x00
04F92:  MOVFF  6FD,6FF
04F96:  MOVFF  6FC,6FE
04F9A:  MOVLB  0
04F9C:  CALL   0B4A
....................     delay_ms(1);
04FA0:  MOVLW  01
04FA2:  MOVLB  7
04FA4:  MOVWF  x01
04FA6:  MOVLB  0
04FA8:  CALL   03CA
....................    
....................     if (chMap[0] == ch) output_high(_SYNC_X);
04FAC:  MOVLW  00
04FAE:  BTFSC  x70.0
04FB0:  MOVLW  01
04FB2:  MOVLB  6
04FB4:  SUBWF  xFB,W
04FB6:  BNZ   4FBE
04FB8:  MOVLW  E8
04FBA:  MOVWF  F8B
04FBC:  BSF    F86.2
....................     if (chMap[1] == ch) output_high(_SYNC_Y);
04FBE:  MOVLW  00
04FC0:  MOVLB  0
04FC2:  BTFSC  x70.1
04FC4:  MOVLW  01
04FC6:  MOVLB  6
04FC8:  SUBWF  xFB,W
04FCA:  BNZ   4FD2
04FCC:  MOVLW  E8
04FCE:  MOVWF  F8B
04FD0:  BSF    F86.1
04FD2:  MOVLB  0
04FD4:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  Axis homing routines and helper functions                                */ 
.................... /*****************************************************************************/
.................... void slew_to_upper_bound(channelMap ch){
....................     chMode[ch] = MANUAL;        // set channel to manual
....................     
....................     while (dacVals[ch].opPcnt < op_upper_bound){
....................         dacVals[ch].opPcnt += 10;   // increase output by 10%
....................         set_nanoDAC_outputs(ch);
....................         delay_ms(500);
....................     }
....................     dacVals[ch].opPcnt = op_upper_bound;    // set output to upper bound
....................     set_nanoDAC_outputs(ch);
....................     delay_ms(500);
.................... }
.................... 
.................... void slew_to_lower_bound(channelMap ch){
....................     chMode[ch] = MANUAL;        // set channel to manual
....................     
....................     while (dacVals[ch].opPcnt > op_lower_bound){
....................         dacVals[ch].opPcnt -= 10;   // decrease output by 10%
....................         set_nanoDAC_outputs(ch);
....................         delay_ms(500);
....................     }
....................     dacVals[ch].opPcnt = op_lower_bound;    // set output to lower bound
....................     set_nanoDAC_outputs(ch);
....................     delay_ms(500);
.................... }
.................... 
.................... void home_axis(channelMap ch){
....................     float maxSP = 0;
....................     float minSP = 0;
....................     int loops = 3;
....................     
....................     // Slew up and down a couple times then set output to 0 to settle the piezo
....................     slew_to_upper_bound(ch);
....................     slew_to_lower_bound(ch);
....................     slew_to_upper_bound(ch);
....................     slew_to_lower_bound(ch);
....................     dacVals[ch].opPcnt = 0;
....................     set_nanoDAC_outputs(ch);
....................     delay_ms(500);
....................     
....................     for (int i=0; i<loops; i++){
....................         slew_to_upper_bound(ch);
....................         sensor_monitor_task();
....................         maxSP+=adcVals[ch].pReal;
....................         
....................         slew_to_lower_bound(ch);
....................         sensor_monitor_task();
....................         minSP+=adcVals[ch].pReal;
....................     }
....................     
....................     PID[ch].maxSP = maxSP / (float)loops;
....................     PID[ch].minSP = minSP / (float)loops;
....................     adcVals[ch].pHome = (maxSP+minSP) / ((float)loops*2);
....................     adcVals[ch].homeFlag = False;
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  control task sets up the outputs channels                                */ 
.................... /*****************************************************************************/
.................... void control_task(){
....................    static int state = 0;
....................    
....................    switch (state)
04FD6:  MOVLB  1
04FD8:  MOVF   xEA,W
04FDA:  XORLW  00
04FDC:  MOVLB  0
04FDE:  BZ    4FE6
04FE0:  XORLW  01
04FE2:  BZ    4FF8
04FE4:  BRA    5008
....................    {
....................       case 0:
....................          set_nanoDAC_outputs(chX);
04FE6:  MOVLB  6
04FE8:  CLRF   xFB
04FEA:  MOVLB  0
04FEC:  RCALL  4CFA
....................          state = 1;
04FEE:  MOVLW  01
04FF0:  MOVLB  1
04FF2:  MOVWF  xEA
....................       break;
04FF4:  MOVLB  0
04FF6:  BRA    5008
....................       case 1:
....................          set_nanoDAC_outputs(chY);
04FF8:  MOVLW  01
04FFA:  MOVLB  6
04FFC:  MOVWF  xFB
04FFE:  MOVLB  0
05000:  RCALL  4CFA
....................          state = 0;
05002:  MOVLB  1
05004:  CLRF   xEA
....................       break;
05006:  MOVLB  0
....................    }
05008:  GOTO   A74E (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  control task sets up the outputs channels                                */ 
.................... /*****************************************************************************/
.................... void control_init(){
....................    spi_xfer(SPI_ctrl, 0, 24);
*
00B74:  MOVLB  7
00B76:  CLRF   x01
00B78:  CLRF   x00
00B7A:  MOVLB  6
00B7C:  CLRF   xFF
00B7E:  CLRF   xFE
00B80:  MOVLB  0
00B82:  RCALL  0B4A
....................    output_low(_SYNC_X);
00B84:  MOVLW  E8
00B86:  MOVWF  F8B
00B88:  BCF    F86.2
....................    output_low(_SYNC_Y);
00B8A:  MOVWF  F8B
00B8C:  BCF    F86.1
....................    output_high(_SYNC_X);
00B8E:  MOVWF  F8B
00B90:  BSF    F86.2
....................    output_high(_SYNC_Y);
00B92:  MOVWF  F8B
00B94:  BSF    F86.1
00B96:  GOTO   A722 (RETURN)
.................... }
.................... #endif
.................... 
.................... #include <serialport.h>
.................... #ifndef serialPort
.................... #define serialPort
.................... #include <cmdBuffer.h>
.................... #ifndef cmd_buffer
.................... #define cmd_buffer
.................... 
.................... /*****************************************************************************/
.................... /* DIFCS COMMAND BUFFER                                                      */
.................... /* The beginning of a message is signified by an address record. The address */
.................... /* is 4 characters. The first 2 are the hardware identifier (TC - temperature*/
.................... /* controller, DC - difics controller, etc..) The second 2 characters dev-   */
.................... /* ice ID... Valid values are 00 thru 0F. A device ID of FF writes to all    */
.................... /* boards. This might be used to feed angles data to all listeners.          */
.................... /*****************************************************************************/
.................... 
.................... // t,p0,p1,p2,p3,p4,p5,p6
.................... // t is the start character, p0 is the address, p1 is command, p2-6 are params
.................... // these characters used for storing messages
.................... 
.................... #define startChr '~' // start character. Also diagnostic command type
.................... #define diagCmdType startChr
.................... #define endChr '\n'
.................... #define delimiter ','
.................... #define ignoreChr1 '\r'
.................... #define ignoreChr2 ' '
.................... #define noRecordFound (char)0xFF
.................... 
.................... #define numRecords 4
.................... #define numParam 7
.................... #define lenParam 25
.................... 
.................... #define useSerial
.................... //#define useTCPIP
.................... 
.................... typedef enum cmdMode {tcp, ser};
.................... 
.................... // this structure holds a command. This is used by the serial routine as well
.................... // as the TCP routine to store an incoming command + parameters
.................... // in the case of TCP socket id is also passed in this structure
.................... typedef struct cmd 
.................... {
....................    BOOLEAN full;        // if full, command is ready to execute
....................    unsigned int8 chrIndex;
....................    unsigned int8 paramIndex;
....................    unsigned int8 recReadIndex;
....................    unsigned int8 recWriteIndex;
....................    #ifdef useTCPIP
....................    TCP_SOCKET s;              // socket ID for TCP commands 
....................    #endif
....................    char t;
....................    char p[numParam][lenParam];   // only used with ~ type command
.................... };
.................... 
.................... #ifdef useSerial
.................... struct cmd SERcmd[numRecords]; // holds serial command 
.................... unsigned int8 SRI = 0; //usb readindex
.................... unsigned int8 SWI = 0; //usb write index
.................... #endif
.................... 
.................... #ifdef useTCPIP
.................... struct cmd TCPcmd[numRecords]; // holds TCP command
.................... unsigned int8 TRI = 0; //usb readindex
.................... unsigned int8 TWI = 0; //usb write index
.................... #endif
.................... 
.................... char retData[100]; // this is used to hold return data 
.................... 
.................... #ifdef useSerial
.................... /*****************************************************************************/
.................... /* RESET SER COMMAND -- ready for a new command                              */
.................... /*****************************************************************************/
.................... void resetSERcmd(unsigned int8 recNum)
.................... {
....................    if (recNum < numRecords)
00B9A:  MOVLB  7
00B9C:  MOVF   x01,W
00B9E:  SUBLW  03
00BA0:  BTFSS  FD8.0
00BA2:  BRA    0D10
....................    {
....................       for (int i = 0; i <numParam; i ++)
00BA4:  CLRF   x02
00BA6:  MOVF   x02,W
00BA8:  SUBLW  06
00BAA:  BNC   0BFA
....................       {
....................          SERcmd[recNum].p[i][0] = '\0';
00BAC:  CLRF   x42
00BAE:  MOVFF  701,741
00BB2:  CLRF   x44
00BB4:  MOVLW  B5
00BB6:  MOVWF  x43
00BB8:  MOVLB  0
00BBA:  RCALL  08B6
00BBC:  MOVFF  02,704
00BC0:  MOVFF  01,703
00BC4:  MOVLW  06
00BC6:  MOVLB  7
00BC8:  ADDWF  x03,F
00BCA:  MOVLW  00
00BCC:  ADDWFC x04,F
00BCE:  CLRF   x42
00BD0:  MOVFF  702,741
00BD4:  CLRF   x44
00BD6:  MOVLW  19
00BD8:  MOVWF  x43
00BDA:  MOVLB  0
00BDC:  RCALL  08B6
00BDE:  MOVF   01,W
00BE0:  MOVLB  7
00BE2:  ADDWF  x03,F
00BE4:  MOVF   02,W
00BE6:  ADDWFC x04,F
00BE8:  MOVLW  EB
00BEA:  ADDWF  x03,W
00BEC:  MOVWF  FE9
00BEE:  MOVLW  01
00BF0:  ADDWFC x04,W
00BF2:  MOVWF  FEA
00BF4:  CLRF   FEF
00BF6:  INCF   x02,F
00BF8:  BRA    0BA6
....................       }
....................       SERcmd[recNum].t = 0;
00BFA:  CLRF   x42
00BFC:  MOVFF  701,741
00C00:  CLRF   x44
00C02:  MOVLW  B5
00C04:  MOVWF  x43
00C06:  MOVLB  0
00C08:  RCALL  08B6
00C0A:  MOVFF  01,703
00C0E:  MOVLW  05
00C10:  MOVLB  7
00C12:  ADDWF  01,W
00C14:  MOVWF  01
00C16:  MOVLW  00
00C18:  ADDWFC 02,W
00C1A:  MOVWF  03
00C1C:  MOVF   01,W
00C1E:  ADDLW  EB
00C20:  MOVWF  FE9
00C22:  MOVLW  01
00C24:  ADDWFC 03,W
00C26:  MOVWF  FEA
00C28:  CLRF   FEF
....................       SERcmd[recNum].chrIndex = 0;
00C2A:  CLRF   x42
00C2C:  MOVFF  701,741
00C30:  CLRF   x44
00C32:  MOVLW  B5
00C34:  MOVWF  x43
00C36:  MOVLB  0
00C38:  RCALL  08B6
00C3A:  MOVFF  01,703
00C3E:  MOVLW  01
00C40:  MOVLB  7
00C42:  ADDWF  01,W
00C44:  MOVWF  01
00C46:  MOVLW  00
00C48:  ADDWFC 02,W
00C4A:  MOVWF  03
00C4C:  MOVF   01,W
00C4E:  ADDLW  EB
00C50:  MOVWF  FE9
00C52:  MOVLW  01
00C54:  ADDWFC 03,W
00C56:  MOVWF  FEA
00C58:  CLRF   FEF
....................       SERcmd[recNum].paramIndex = 0;
00C5A:  CLRF   x42
00C5C:  MOVFF  701,741
00C60:  CLRF   x44
00C62:  MOVLW  B5
00C64:  MOVWF  x43
00C66:  MOVLB  0
00C68:  RCALL  08B6
00C6A:  MOVFF  01,703
00C6E:  MOVLW  02
00C70:  MOVLB  7
00C72:  ADDWF  01,W
00C74:  MOVWF  01
00C76:  MOVLW  00
00C78:  ADDWFC 02,W
00C7A:  MOVWF  03
00C7C:  MOVF   01,W
00C7E:  ADDLW  EB
00C80:  MOVWF  FE9
00C82:  MOVLW  01
00C84:  ADDWFC 03,W
00C86:  MOVWF  FEA
00C88:  CLRF   FEF
....................       SERcmd[recNum].recReadIndex = 0;
00C8A:  CLRF   x42
00C8C:  MOVFF  701,741
00C90:  CLRF   x44
00C92:  MOVLW  B5
00C94:  MOVWF  x43
00C96:  MOVLB  0
00C98:  RCALL  08B6
00C9A:  MOVFF  01,703
00C9E:  MOVLW  03
00CA0:  MOVLB  7
00CA2:  ADDWF  01,W
00CA4:  MOVWF  01
00CA6:  MOVLW  00
00CA8:  ADDWFC 02,W
00CAA:  MOVWF  03
00CAC:  MOVF   01,W
00CAE:  ADDLW  EB
00CB0:  MOVWF  FE9
00CB2:  MOVLW  01
00CB4:  ADDWFC 03,W
00CB6:  MOVWF  FEA
00CB8:  CLRF   FEF
....................       SERcmd[recNum].recWriteIndex = 0;
00CBA:  CLRF   x42
00CBC:  MOVFF  701,741
00CC0:  CLRF   x44
00CC2:  MOVLW  B5
00CC4:  MOVWF  x43
00CC6:  MOVLB  0
00CC8:  RCALL  08B6
00CCA:  MOVFF  01,703
00CCE:  MOVLW  04
00CD0:  MOVLB  7
00CD2:  ADDWF  01,W
00CD4:  MOVWF  01
00CD6:  MOVLW  00
00CD8:  ADDWFC 02,W
00CDA:  MOVWF  03
00CDC:  MOVF   01,W
00CDE:  ADDLW  EB
00CE0:  MOVWF  FE9
00CE2:  MOVLW  01
00CE4:  ADDWFC 03,W
00CE6:  MOVWF  FEA
00CE8:  CLRF   FEF
....................       SERcmd[recNum].full = FALSE;
00CEA:  CLRF   x42
00CEC:  MOVFF  701,741
00CF0:  CLRF   x44
00CF2:  MOVLW  B5
00CF4:  MOVWF  x43
00CF6:  MOVLB  0
00CF8:  RCALL  08B6
00CFA:  MOVLW  EB
00CFC:  MOVLB  7
00CFE:  ADDWF  01,W
00D00:  MOVWF  FE9
00D02:  MOVLW  01
00D04:  ADDWFC 02,W
00D06:  MOVWF  FEA
00D08:  BCF    FEF.0
....................       retData[0] = '\0';
00D0A:  MOVLB  4
00D0C:  CLRF   xC1
00D0E:  MOVLB  7
....................    }
00D10:  MOVLB  0
00D12:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next serial read index (SRI)                                          */
.................... /*****************************************************************************/
.................... BOOLEAN getNextSERReadIndex()
.................... {
....................    while (!SERcmd[SRI].full)
*
05A52:  MOVLB  7
05A54:  CLRF   x42
05A56:  MOVFF  4BF,741
05A5A:  CLRF   x44
05A5C:  MOVLW  B5
05A5E:  MOVWF  x43
05A60:  MOVLB  0
05A62:  CALL   08B6
05A66:  MOVFF  02,702
05A6A:  MOVFF  01,701
05A6E:  MOVLW  EB
05A70:  MOVLB  7
05A72:  ADDWF  01,W
05A74:  MOVWF  FE9
05A76:  MOVLW  01
05A78:  ADDWFC 02,W
05A7A:  MOVWF  FEA
05A7C:  BTFSC  FEF.0
05A7E:  BRA    5AA0
....................    {
....................       if (SRI == SWI) return FALSE;
05A80:  MOVLB  4
05A82:  MOVF   xC0,W
05A84:  SUBWF  xBF,W
05A86:  BNZ   5A8E
05A88:  MOVLW  00
05A8A:  MOVWF  01
05A8C:  BRA    5AA6
....................       SRI +=1;
05A8E:  MOVLW  01
05A90:  ADDWF  xBF,F
....................       if (SRI >= numRecords) SRI=0;
05A92:  MOVF   xBF,W
05A94:  SUBLW  03
05A96:  BC    5A9A
05A98:  CLRF   xBF
05A9A:  MOVLB  0
05A9C:  BRA    5A52
05A9E:  MOVLB  7
....................    }
....................    return TRUE;
05AA0:  MOVLW  01
05AA2:  MOVWF  01
05AA4:  MOVLB  4
05AA6:  MOVLB  0
05AA8:  GOTO   A1E4 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next serial write index (SWI)                                         */
.................... /*****************************************************************************/
.................... void setNextSERWriteIndex()
.................... {
....................    SWI +=1;
*
05044:  MOVLW  01
05046:  MOVLB  4
05048:  ADDWF  xC0,F
....................    if (SWI >= numRecords) SWI=0;
0504A:  MOVF   xC0,W
0504C:  SUBLW  03
0504E:  BC    5052
05050:  CLRF   xC0
05052:  MOVLB  0
05054:  RETURN 0
.................... }
.................... #endif
.................... 
.................... #ifdef useTCPIP
.................... /*****************************************************************************/
.................... /* RESET TCP COMMAND -- ready for a new command                              */
.................... /*****************************************************************************/
.................... void resetTCPcmd(unsigned int8 recNum)
.................... {
....................    if(recNum < numRecords)
....................    {
....................       for (int i = 0; i <numParam; i ++)
....................       {
....................          TCPcmd[recNum].p[i][0] = '\0';
....................       }
....................       TCPcmd[recNum].t = 0;
....................       TCPcmd[recNum].chrIndex = 0;
....................       TCPcmd[recNum].paramIndex = 0;
....................       TCPcmd[recNum].full = FALSE;
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next TCP read index (TRI)                                             */
.................... /*****************************************************************************/
.................... BOOLEAN getNextTCPReadIndex()
.................... {
....................    while (!TCPcmd[TRI].full)
....................    {
....................       if (TRI == TWI) return FALSE;
....................       TRI +=1;
....................       if (TRI >= numRecords) TRI=0;
....................    }
....................    return TRUE;
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next TCP write index (TWI)                                            */
.................... /*****************************************************************************/
.................... void setNextTCPWriteIndex()
.................... {
....................    TWI +=1;
....................    if (TWI >= numRecords) TWI=0;
.................... }
.................... #endif
.................... #endif
.................... 
.................... 
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B7,PIN_B6,PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
....................    output_b(portB_reset);
....................    output_c(portC_reset);
....................    output_d(portD_reset);
....................    output_e(portE_reset);
....................    
....................    port_a_pullups(portA_pullups);
....................    port_b_pullups(portB_pullups);
....................    port_c_pullups(portC_pullups);
....................    port_d_pullups(portD_pullups);
....................    port_e_pullups(portE_pullups);
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... #define use_RS485 // adds RX enable pin//
.................... 
.................... #define oneByteCmdTestValue 128
.................... #define UART_BUFFER_SIZE 60
.................... #define UART_EOT_CHAR1 0x0D //Carriage Return
.................... #define UART_EOT_CHAR2 0x0A //Line Feed
.................... #define UART_SOT_CHAR  '~' // START CHARACTER
.................... #define line_turnaround_char 0xFF
.................... 
.................... #bit UART_TXBuffer_Empty = 0x0FAC.1
.................... 
.................... char UART_BUFFER[UART_BUFFER_SIZE] = {0};
.................... unsigned int8 UART_WR_PTR = 0;
.................... unsigned int8 UART_RD_PTR = 0;
.................... boolean BYTES_AVAILABLE= FALSE;
.................... 
.................... #ifdef use_RS485
.................... #use rs232(baud=baudRate, xmit=TX_PIN, rcv=RX_PIN, stream=SERIAL, ERRORS)
.................... #else
.................... #use rs232(baud=baudRate, xmit=TX_PIN, rcv=RX_PIN, stream=SERIAL)
.................... #endif
.................... 
.................... // Message format: [SOT]addr ,cmd, arg1, arg2, arg3[EOT]} 
.................... // arguments are optional
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* SERIAL PRINTOUT                                                           */
.................... /*****************************************************************************/
.................... void serial_out(char* pBuff){
....................     output_high(TX_ENABLE);
*
0A194:  MOVLW  93
0A196:  MOVWF  F89
0A198:  BSF    F84.5
....................     delay_us(500);
0A19A:  MOVLW  02
0A19C:  MOVLB  7
0A19E:  MOVWF  x03
0A1A0:  MOVLW  FA
0A1A2:  MOVWF  x07
0A1A4:  MOVLB  0
0A1A6:  CALL   0746
0A1AA:  MOVLB  7
0A1AC:  DECFSZ x03,F
0A1AE:  BRA    A1A0
....................     
....................     fprintf(SERIAL, "%s", pBuff);
0A1B0:  MOVFF  702,FEA
0A1B4:  MOVFF  701,FE9
0A1B8:  MOVLB  0
0A1BA:  CALL   5056
....................     delay_us(500);
0A1BE:  MOVLW  02
0A1C0:  MOVLB  7
0A1C2:  MOVWF  x03
0A1C4:  MOVLW  FA
0A1C6:  MOVWF  x07
0A1C8:  MOVLB  0
0A1CA:  CALL   0746
0A1CE:  MOVLB  7
0A1D0:  DECFSZ x03,F
0A1D2:  BRA    A1C4
....................     
....................     output_low(TX_ENABLE);
0A1D4:  MOVLW  93
0A1D6:  MOVWF  F89
0A1D8:  BCF    F84.5
0A1DA:  MOVLB  0
0A1DC:  GOTO   A2FC (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SERIAL PORT ISR                                                           */
.................... /*****************************************************************************/
.................... #INT_RDA
.................... void RX_isr()
*
00120:  MOVLB  0
.................... {
....................    while (kbhit())
00122:  BTFSC  F8D.6
00124:  BRA    0164
....................    {
....................       UART_BUFFER[UART_WR_PTR]=getch();
00126:  CLRF   03
00128:  MOVLB  5
0012A:  MOVF   x61,W
0012C:  ADDLW  25
0012E:  MOVWF  FE9
00130:  MOVLW  05
00132:  ADDWFC 03,W
00134:  MOVWF  FEA
00136:  MOVFF  FEA,774
0013A:  MOVFF  FE9,773
0013E:  MOVLB  0
00140:  BRA    00CA
00142:  MOVFF  774,FEA
00146:  MOVFF  773,FE9
0014A:  MOVFF  01,FEF
....................       UART_WR_PTR +=1;
0014E:  MOVLW  01
00150:  MOVLB  5
00152:  ADDWF  x61,F
....................       if (UART_WR_PTR>=UART_BUFFER_SIZE) UART_WR_PTR=0;
00154:  MOVF   x61,W
00156:  SUBLW  3B
00158:  BC    015C
0015A:  CLRF   x61
....................       BYTES_AVAILABLE=TRUE;
0015C:  MOVLB  1
0015E:  BSF    x63.1
00160:  MOVLB  0
00162:  BRA    0122
....................    }
00164:  MOVLB  E
00166:  BCF    xC8.5
00168:  MOVLB  0
0016A:  GOTO   006E
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get character from buffer                                                 */
.................... /*****************************************************************************/
.................... char getchFromBuffer()
*
0500C:  CLRF   03
0500E:  MOVLB  5
05010:  MOVF   x62,W
05012:  ADDLW  25
05014:  MOVWF  FE9
05016:  MOVLW  05
05018:  ADDWFC 03,W
0501A:  MOVWF  FEA
0501C:  MOVFF  FEF,6FC
.................... {
....................    char data = UART_BUFFER[UART_RD_PTR];
....................    UART_RD_PTR +=1;
05020:  MOVLW  01
05022:  ADDWF  x62,F
....................    if (UART_RD_PTR>=UART_BUFFER_SIZE) UART_RD_PTR=0;
05024:  MOVF   x62,W
05026:  SUBLW  3B
05028:  BC    502C
0502A:  CLRF   x62
....................    if (UART_RD_PTR == UART_WR_PTR) BYTES_AVAILABLE=FALSE;
0502C:  MOVF   x61,W
0502E:  SUBWF  x62,W
05030:  BNZ   5038
05032:  MOVLB  1
05034:  BCF    x63.1
05036:  MOVLB  5
....................    return data;
05038:  MOVLB  6
0503A:  MOVFF  6FC,01
0503E:  MOVLB  0
05040:  GOTO   50C2 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Serial Task transfers bytes to command buffer                             */
.................... /*****************************************************************************/
.................... void serial_task()
.................... {
....................    while(BYTES_AVAILABLE && SERcmd[SWI].full==FALSE)
*
05080:  MOVLB  1
05082:  BTFSS  x63.1
05084:  BRA    5592
05086:  MOVLB  7
05088:  CLRF   x42
0508A:  MOVFF  4C0,741
0508E:  CLRF   x44
05090:  MOVLW  B5
05092:  MOVWF  x43
05094:  MOVLB  0
05096:  CALL   08B6
0509A:  MOVFF  02,6FD
0509E:  MOVFF  01,6FC
050A2:  MOVLW  EB
050A4:  MOVLB  6
050A6:  ADDWF  01,W
050A8:  MOVWF  01
050AA:  MOVLW  01
050AC:  ADDWFC 02,W
050AE:  MOVWF  03
050B0:  MOVFF  01,FE9
050B4:  MOVWF  FEA
050B6:  BTFSS  FEF.0
050B8:  BRA    50BE
050BA:  MOVLB  1
050BC:  BRA    5592
....................    {  
....................       unsigned int8 rxChar = getchFromBuffer();
050BE:  MOVLB  0
050C0:  BRA    500C
050C2:  MOVFF  01,6FB
....................       if (rxChar == ignoreChr1 || rxChar == ignoreChr2)
050C6:  MOVLB  6
050C8:  MOVF   xFB,W
050CA:  SUBLW  0D
050CC:  BZ    50D4
050CE:  MOVF   xFB,W
050D0:  SUBLW  20
050D2:  BNZ   50D6
....................       {
....................       }
050D4:  BRA    558C
....................       else if (rxChar == UART_SOT_CHAR)
050D6:  MOVF   xFB,W
050D8:  SUBLW  7E
050DA:  BNZ   511E
....................       {
....................          resetSERcmd(SWI);
050DC:  MOVFF  4C0,701
050E0:  MOVLB  0
050E2:  CALL   0B9A
....................          SERcmd[SWI].t = rxChar;
050E6:  MOVLB  7
050E8:  CLRF   x42
050EA:  MOVFF  4C0,741
050EE:  CLRF   x44
050F0:  MOVLW  B5
050F2:  MOVWF  x43
050F4:  MOVLB  0
050F6:  CALL   08B6
050FA:  MOVFF  01,6FC
050FE:  MOVLW  05
05100:  MOVLB  6
05102:  ADDWF  01,W
05104:  MOVWF  01
05106:  MOVLW  00
05108:  ADDWFC 02,W
0510A:  MOVWF  03
0510C:  MOVF   01,W
0510E:  ADDLW  EB
05110:  MOVWF  FE9
05112:  MOVLW  01
05114:  ADDWFC 03,W
05116:  MOVWF  FEA
05118:  MOVFF  6FB,FEF
....................       }
0511C:  BRA    558C
....................       else if (rxChar >= oneByteCmdTestValue)
0511E:  MOVF   xFB,W
05120:  SUBLW  7F
05122:  BC    5190
....................       {
....................          resetSERcmd(SWI);
05124:  MOVFF  4C0,701
05128:  MOVLB  0
0512A:  CALL   0B9A
....................          SERcmd[SWI].t = rxChar;
0512E:  MOVLB  7
05130:  CLRF   x42
05132:  MOVFF  4C0,741
05136:  CLRF   x44
05138:  MOVLW  B5
0513A:  MOVWF  x43
0513C:  MOVLB  0
0513E:  CALL   08B6
05142:  MOVFF  01,6FC
05146:  MOVLW  05
05148:  MOVLB  6
0514A:  ADDWF  01,W
0514C:  MOVWF  01
0514E:  MOVLW  00
05150:  ADDWFC 02,W
05152:  MOVWF  03
05154:  MOVF   01,W
05156:  ADDLW  EB
05158:  MOVWF  FE9
0515A:  MOVLW  01
0515C:  ADDWFC 03,W
0515E:  MOVWF  FEA
05160:  MOVFF  6FB,FEF
....................          SERcmd[SWI].full = TRUE;
05164:  MOVLB  7
05166:  CLRF   x42
05168:  MOVFF  4C0,741
0516C:  CLRF   x44
0516E:  MOVLW  B5
05170:  MOVWF  x43
05172:  MOVLB  0
05174:  CALL   08B6
05178:  MOVLW  EB
0517A:  MOVLB  6
0517C:  ADDWF  01,W
0517E:  MOVWF  FE9
05180:  MOVLW  01
05182:  ADDWFC 02,W
05184:  MOVWF  FEA
05186:  BSF    FEF.0
....................          setNextSERWriteIndex();
05188:  MOVLB  0
0518A:  RCALL  5044
....................       }
0518C:  BRA    558A
0518E:  MOVLB  6
....................       else if (rxChar == UART_EOT_CHAR2)
05190:  MOVF   xFB,W
05192:  SUBLW  0A
05194:  BTFSS  FD8.2
05196:  BRA    52A4
....................       {
....................          SERcmd[SWI].full = TRUE;
05198:  MOVLB  7
0519A:  CLRF   x42
0519C:  MOVFF  4C0,741
051A0:  CLRF   x44
051A2:  MOVLW  B5
051A4:  MOVWF  x43
051A6:  MOVLB  0
051A8:  CALL   08B6
051AC:  MOVLW  EB
051AE:  MOVLB  6
051B0:  ADDWF  01,W
051B2:  MOVWF  FE9
051B4:  MOVLW  01
051B6:  ADDWFC 02,W
051B8:  MOVWF  FEA
051BA:  BSF    FEF.0
....................          SERcmd[SWI].recWriteIndex = SERcmd[SWI].paramIndex;
051BC:  MOVLB  7
051BE:  CLRF   x42
051C0:  MOVFF  4C0,741
051C4:  CLRF   x44
051C6:  MOVLW  B5
051C8:  MOVWF  x43
051CA:  MOVLB  0
051CC:  CALL   08B6
051D0:  MOVFF  01,6FC
051D4:  MOVLW  04
051D6:  ADDWF  01,W
051D8:  MOVWF  01
051DA:  MOVLW  00
051DC:  ADDWFC 02,W
051DE:  MOVWF  03
051E0:  MOVF   01,W
051E2:  ADDLW  EB
051E4:  MOVWF  01
051E6:  MOVLW  01
051E8:  ADDWFC 03,F
051EA:  MOVFF  01,6FC
051EE:  MOVFF  03,6FD
051F2:  MOVLB  7
051F4:  CLRF   x42
051F6:  MOVFF  4C0,741
051FA:  CLRF   x44
051FC:  MOVLW  B5
051FE:  MOVWF  x43
05200:  MOVLB  0
05202:  CALL   08B6
05206:  MOVFF  01,6FE
0520A:  MOVLW  02
0520C:  MOVLB  6
0520E:  ADDWF  01,W
05210:  MOVWF  01
05212:  MOVLW  00
05214:  ADDWFC 02,W
05216:  MOVWF  03
05218:  MOVF   01,W
0521A:  ADDLW  EB
0521C:  MOVWF  FE9
0521E:  MOVLW  01
05220:  ADDWFC 03,W
05222:  MOVWF  FEA
05224:  MOVFF  FEF,6FE
05228:  MOVFF  6FD,FEA
0522C:  MOVFF  6FC,FE9
05230:  MOVFF  6FE,FEF
....................          SERcmd[SWI].chrIndex = 0;
05234:  MOVLB  7
05236:  CLRF   x42
05238:  MOVFF  4C0,741
0523C:  CLRF   x44
0523E:  MOVLW  B5
05240:  MOVWF  x43
05242:  MOVLB  0
05244:  CALL   08B6
05248:  MOVFF  01,6FC
0524C:  MOVLW  01
0524E:  MOVLB  6
05250:  ADDWF  01,W
05252:  MOVWF  01
05254:  MOVLW  00
05256:  ADDWFC 02,W
05258:  MOVWF  03
0525A:  MOVF   01,W
0525C:  ADDLW  EB
0525E:  MOVWF  FE9
05260:  MOVLW  01
05262:  ADDWFC 03,W
05264:  MOVWF  FEA
05266:  CLRF   FEF
....................          SERcmd[SWI].paramIndex = 0;
05268:  MOVLB  7
0526A:  CLRF   x42
0526C:  MOVFF  4C0,741
05270:  CLRF   x44
05272:  MOVLW  B5
05274:  MOVWF  x43
05276:  MOVLB  0
05278:  CALL   08B6
0527C:  MOVFF  01,6FC
05280:  MOVLW  02
05282:  MOVLB  6
05284:  ADDWF  01,W
05286:  MOVWF  01
05288:  MOVLW  00
0528A:  ADDWFC 02,W
0528C:  MOVWF  03
0528E:  MOVF   01,W
05290:  ADDLW  EB
05292:  MOVWF  FE9
05294:  MOVLW  01
05296:  ADDWFC 03,W
05298:  MOVWF  FEA
0529A:  CLRF   FEF
....................          setNextSERWriteIndex();
0529C:  MOVLB  0
0529E:  RCALL  5044
....................       }
052A0:  BRA    558A
052A2:  MOVLB  6
....................       else if (rxChar == delimiter)
052A4:  MOVF   xFB,W
052A6:  SUBLW  2C
052A8:  BNZ   536C
....................       {
....................          if (SERcmd[SWI].paramIndex < numParam-1)
052AA:  MOVLB  7
052AC:  CLRF   x42
052AE:  MOVFF  4C0,741
052B2:  CLRF   x44
052B4:  MOVLW  B5
052B6:  MOVWF  x43
052B8:  MOVLB  0
052BA:  CALL   08B6
052BE:  MOVFF  02,6FD
052C2:  MOVFF  01,6FC
052C6:  MOVLW  02
052C8:  MOVLB  6
052CA:  ADDWF  01,W
052CC:  MOVWF  01
052CE:  MOVLW  00
052D0:  ADDWFC 02,W
052D2:  MOVWF  03
052D4:  MOVF   01,W
052D6:  ADDLW  EB
052D8:  MOVWF  FE9
052DA:  MOVLW  01
052DC:  ADDWFC 03,W
052DE:  MOVWF  FEA
052E0:  MOVF   FEF,W
052E2:  SUBLW  05
052E4:  BNC   5354
....................          {
....................             SERcmd[SWI].paramIndex +=1;
052E6:  MOVLB  7
052E8:  CLRF   x42
052EA:  MOVFF  4C0,741
052EE:  CLRF   x44
052F0:  MOVLW  B5
052F2:  MOVWF  x43
052F4:  MOVLB  0
052F6:  CALL   08B6
052FA:  MOVFF  01,6FC
052FE:  MOVLW  02
05300:  MOVLB  6
05302:  ADDWF  01,W
05304:  MOVWF  01
05306:  MOVLW  00
05308:  ADDWFC 02,W
0530A:  MOVWF  03
0530C:  MOVF   01,W
0530E:  ADDLW  EB
05310:  MOVWF  FE9
05312:  MOVLW  01
05314:  ADDWFC 03,W
05316:  MOVWF  FEA
05318:  MOVLW  01
0531A:  ADDWF  FEF,W
0531C:  MOVWF  FEF
....................             SERcmd[SWI].chrIndex = 0;
0531E:  MOVLB  7
05320:  CLRF   x42
05322:  MOVFF  4C0,741
05326:  CLRF   x44
05328:  MOVLW  B5
0532A:  MOVWF  x43
0532C:  MOVLB  0
0532E:  CALL   08B6
05332:  MOVFF  01,6FC
05336:  MOVLW  01
05338:  MOVLB  6
0533A:  ADDWF  01,W
0533C:  MOVWF  01
0533E:  MOVLW  00
05340:  ADDWFC 02,W
05342:  MOVWF  03
05344:  MOVF   01,W
05346:  ADDLW  EB
05348:  MOVWF  FE9
0534A:  MOVLW  01
0534C:  ADDWFC 03,W
0534E:  MOVWF  FEA
05350:  CLRF   FEF
....................          }
05352:  BRA    536A
....................          else
....................          {
....................             resetSERcmd(SWI); // exceed number of params... reset capture
05354:  MOVFF  4C0,701
05358:  MOVLB  0
0535A:  CALL   0B9A
....................             fprintf(SERIAL, retData);
0535E:  MOVLW  04
05360:  MOVWF  FEA
05362:  MOVLW  C1
05364:  MOVWF  FE9
05366:  RCALL  5056
05368:  MOVLB  6
....................          }
....................       }
0536A:  BRA    558C
....................       
....................       else
....................       {
....................          if (SERcmd[SWI].chrIndex < lenParam)
0536C:  MOVLB  7
0536E:  CLRF   x42
05370:  MOVFF  4C0,741
05374:  CLRF   x44
05376:  MOVLW  B5
05378:  MOVWF  x43
0537A:  MOVLB  0
0537C:  CALL   08B6
05380:  MOVFF  02,6FD
05384:  MOVFF  01,6FC
05388:  MOVLW  01
0538A:  MOVLB  6
0538C:  ADDWF  01,W
0538E:  MOVWF  01
05390:  MOVLW  00
05392:  ADDWFC 02,W
05394:  MOVWF  03
05396:  MOVF   01,W
05398:  ADDLW  EB
0539A:  MOVWF  FE9
0539C:  MOVLW  01
0539E:  ADDWFC 03,W
053A0:  MOVWF  FEA
053A2:  MOVF   FEF,W
053A4:  SUBLW  18
053A6:  BTFSS  FD8.0
053A8:  BRA    5576
....................          {
....................             SERcmd[SWI].p[SERcmd[SWI].paramIndex][SERcmd[SWI].chrIndex] = rxChar;
053AA:  MOVLB  7
053AC:  CLRF   x42
053AE:  MOVFF  4C0,741
053B2:  CLRF   x44
053B4:  MOVLW  B5
053B6:  MOVWF  x43
053B8:  MOVLB  0
053BA:  CALL   08B6
053BE:  MOVFF  02,6FD
053C2:  MOVFF  01,6FC
053C6:  MOVLW  06
053C8:  MOVLB  6
053CA:  ADDWF  xFC,F
053CC:  MOVLW  00
053CE:  ADDWFC xFD,F
053D0:  MOVLB  7
053D2:  CLRF   x42
053D4:  MOVFF  4C0,741
053D8:  CLRF   x44
053DA:  MOVLW  B5
053DC:  MOVWF  x43
053DE:  MOVLB  0
053E0:  CALL   08B6
053E4:  MOVFF  02,6FF
053E8:  MOVFF  01,6FE
053EC:  MOVLW  02
053EE:  ADDWF  01,W
053F0:  MOVWF  01
053F2:  MOVLW  00
053F4:  ADDWFC 02,W
053F6:  MOVWF  03
053F8:  MOVF   01,W
053FA:  ADDLW  EB
053FC:  MOVWF  FE9
053FE:  MOVLW  01
05400:  ADDWFC 03,W
05402:  MOVWF  FEA
05404:  MOVLB  7
05406:  CLRF   x42
05408:  MOVFF  FEF,741
0540C:  CLRF   x44
0540E:  MOVLW  19
05410:  MOVWF  x43
05412:  MOVLB  0
05414:  CALL   08B6
05418:  MOVFF  02,03
0541C:  MOVF   01,W
0541E:  MOVLB  6
05420:  ADDWF  xFC,F
05422:  MOVF   02,W
05424:  ADDWFC xFD,F
05426:  MOVLB  7
05428:  CLRF   x42
0542A:  MOVFF  4C0,741
0542E:  CLRF   x44
05430:  MOVLW  B5
05432:  MOVWF  x43
05434:  MOVLB  0
05436:  CALL   08B6
0543A:  MOVFF  01,6FE
0543E:  MOVLW  01
05440:  MOVLB  6
05442:  ADDWF  01,W
05444:  MOVWF  01
05446:  MOVLW  00
05448:  ADDWFC 02,W
0544A:  MOVWF  03
0544C:  MOVF   01,W
0544E:  ADDLW  EB
05450:  MOVWF  FE9
05452:  MOVLW  01
05454:  ADDWFC 03,W
05456:  MOVWF  FEA
05458:  MOVF   FEF,W
0545A:  ADDWF  xFC,W
0545C:  MOVWF  01
0545E:  MOVLW  00
05460:  ADDWFC xFD,W
05462:  MOVWF  03
05464:  MOVF   01,W
05466:  ADDLW  EB
05468:  MOVWF  FE9
0546A:  MOVLW  01
0546C:  ADDWFC 03,W
0546E:  MOVWF  FEA
05470:  MOVFF  6FB,FEF
....................             SERcmd[SWI].chrIndex += 1;
05474:  MOVLB  7
05476:  CLRF   x42
05478:  MOVFF  4C0,741
0547C:  CLRF   x44
0547E:  MOVLW  B5
05480:  MOVWF  x43
05482:  MOVLB  0
05484:  CALL   08B6
05488:  MOVFF  01,6FC
0548C:  MOVLW  01
0548E:  MOVLB  6
05490:  ADDWF  01,W
05492:  MOVWF  01
05494:  MOVLW  00
05496:  ADDWFC 02,W
05498:  MOVWF  03
0549A:  MOVF   01,W
0549C:  ADDLW  EB
0549E:  MOVWF  FE9
054A0:  MOVLW  01
054A2:  ADDWFC 03,W
054A4:  MOVWF  FEA
054A6:  MOVLW  01
054A8:  ADDWF  FEF,W
054AA:  MOVWF  FEF
....................             SERcmd[SWI].p[SERcmd[SWI].paramIndex][SERcmd[SWI].chrIndex] = '\0';
054AC:  MOVLB  7
054AE:  CLRF   x42
054B0:  MOVFF  4C0,741
054B4:  CLRF   x44
054B6:  MOVLW  B5
054B8:  MOVWF  x43
054BA:  MOVLB  0
054BC:  CALL   08B6
054C0:  MOVFF  02,6FD
054C4:  MOVFF  01,6FC
054C8:  MOVLW  06
054CA:  MOVLB  6
054CC:  ADDWF  xFC,F
054CE:  MOVLW  00
054D0:  ADDWFC xFD,F
054D2:  MOVLB  7
054D4:  CLRF   x42
054D6:  MOVFF  4C0,741
054DA:  CLRF   x44
054DC:  MOVLW  B5
054DE:  MOVWF  x43
054E0:  MOVLB  0
054E2:  CALL   08B6
054E6:  MOVFF  02,6FF
054EA:  MOVFF  01,6FE
054EE:  MOVLW  02
054F0:  ADDWF  01,W
054F2:  MOVWF  01
054F4:  MOVLW  00
054F6:  ADDWFC 02,W
054F8:  MOVWF  03
054FA:  MOVF   01,W
054FC:  ADDLW  EB
054FE:  MOVWF  FE9
05500:  MOVLW  01
05502:  ADDWFC 03,W
05504:  MOVWF  FEA
05506:  MOVLB  7
05508:  CLRF   x42
0550A:  MOVFF  FEF,741
0550E:  CLRF   x44
05510:  MOVLW  19
05512:  MOVWF  x43
05514:  MOVLB  0
05516:  CALL   08B6
0551A:  MOVFF  02,03
0551E:  MOVF   01,W
05520:  MOVLB  6
05522:  ADDWF  xFC,F
05524:  MOVF   02,W
05526:  ADDWFC xFD,F
05528:  MOVLB  7
0552A:  CLRF   x42
0552C:  MOVFF  4C0,741
05530:  CLRF   x44
05532:  MOVLW  B5
05534:  MOVWF  x43
05536:  MOVLB  0
05538:  CALL   08B6
0553C:  MOVFF  01,6FE
05540:  MOVLW  01
05542:  MOVLB  6
05544:  ADDWF  01,W
05546:  MOVWF  01
05548:  MOVLW  00
0554A:  ADDWFC 02,W
0554C:  MOVWF  03
0554E:  MOVF   01,W
05550:  ADDLW  EB
05552:  MOVWF  FE9
05554:  MOVLW  01
05556:  ADDWFC 03,W
05558:  MOVWF  FEA
0555A:  MOVF   FEF,W
0555C:  ADDWF  xFC,W
0555E:  MOVWF  01
05560:  MOVLW  00
05562:  ADDWFC xFD,W
05564:  MOVWF  03
05566:  MOVF   01,W
05568:  ADDLW  EB
0556A:  MOVWF  FE9
0556C:  MOVLW  01
0556E:  ADDWFC 03,W
05570:  MOVWF  FEA
05572:  CLRF   FEF
....................          }
05574:  BRA    558C
....................          else
....................          {
....................             resetSERcmd(SWI); // exceed number of characters... reset capture
05576:  MOVFF  4C0,701
0557A:  MOVLB  0
0557C:  CALL   0B9A
....................             fprintf(SERIAL, retData);
05580:  MOVLW  04
05582:  MOVWF  FEA
05584:  MOVLW  C1
05586:  MOVWF  FE9
05588:  RCALL  5056
0558A:  MOVLB  6
....................          }
....................       }
0558C:  MOVLB  0
0558E:  BRA    5080
05590:  MOVLB  1
....................    }          
05592:  MOVLB  0
05594:  GOTO   A762 (RETURN)
.................... }
....................            
.................... /*****************************************************************************/
.................... /* serialInit ROUTINE  - Sets up serial port                                 */
.................... /*****************************************************************************/ 
.................... void serial_init()
.................... {
....................    for (int i = 0; i < numRecords; i++) 
*
00D14:  MOVLB  6
00D16:  CLRF   xFB
00D18:  MOVF   xFB,W
00D1A:  SUBLW  03
00D1C:  BNC   0D2C
....................    {
....................       resetSERcmd(i);
00D1E:  MOVFF  6FB,701
00D22:  MOVLB  0
00D24:  RCALL  0B9A
00D26:  MOVLB  6
00D28:  INCF   xFB,F
00D2A:  BRA    0D18
....................    }
....................    enable_interrupts(INT_RDA);
00D2C:  MOVLB  E
00D2E:  BSF    xC0.5
00D30:  MOVLB  0
00D32:  GOTO   A726 (RETURN)
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #include <pid.h>
.................... #ifndef pidcontroller
.................... #define pidcontroller
.................... #include <parameters.h>
.................... #include <math.h>
.................... 
.................... /*****************************************************************************/
.................... /* UPDATE the Control Variable (CV)                                          */
.................... /*****************************************************************************/
.................... void pid_update (channelMap ch){
....................    float err = PID[ch].SP - PID[ch].PV;  // error = set value - measured
....................    
....................    PID[ch].I += err*PID[ch].kI;
....................    if (PID[ch].I > op_upper_bound) PID[ch].I = op_upper_bound; // anti-windup
....................    else if (PID[ch].I < op_lower_bound) PID[ch].I = op_lower_bound;
....................    
....................    float P = err * PID[ch].kP;  // proportional value
....................    
....................    float D = PID[ch].kD * (PID[ch].PV - PID[ch].PVold);  // derivative value
....................    
....................    PID[ch].CV = P + PID[ch].I + D;  // new control variable
....................    if (PID[ch].CV > op_upper_bound) PID[ch].CV = op_upper_bound; // limit positive output
....................    else if (PID[ch].CV < op_lower_bound) PID[ch].CV = op_lower_bound; // limit negative output
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PID Task - looks for change to PV and updates CV                          */
.................... /*****************************************************************************/
.................... void pid_task(channelMap ch){
....................    static int index = 0;
....................    if (PID[ch].SP != PID[ch].PV) pid_update(ch);
....................    if ((index++) >= numChannels) index = 0;
.................... }
.................... 
.................... #endif
.................... 
.................... #include <eventTimer.h>
.................... #ifndef timeout
.................... #define timeout
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................     float kP;      // proportional gain
....................     float kI;      // integral gain
....................     float kD;      // derivative gain
....................     float SP;      // set point-- desired output
....................     float PV;      // process variable-- measured output
....................     float PVold;   // oldPV value  
....................     float CV;      // control variable-- output -- 0 to 100%
....................     float I;       // integral value
....................     float maxSP;   // Max setpoint in microns
....................     float minSP;   // Min setpoint in microns
.................... }PID[2] = {
....................    //  P     I     D
....................    //0.01    0.3   0.1
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}, 
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}
....................     };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... //!#define op_upper_bound 63  // CRYO
.................... //!#define op_lower_bound -63 // CRYO
.................... 
.................... #define op_upper_bound 63  // AMBIENT 
.................... #define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    BOOLEAN homeFlag;       // Flag to trigger the homing routine
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,FALSE},
....................    {0,0,0,0,0,0,0,0,0,0,FALSE}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................     BOOLEAN invV;
....................     unsigned int16 ipVal;
....................     float opPcnt;
....................    
.................... }dacVals[2] = 
.................... {
....................     {FALSE,0,0},
....................     {FALSE,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/           
.................... /* Global timers used by all routnes                                         */
.................... /* timeoutReg0-2 are used for timeouts. Other routines monitor the value of  */
.................... /* intTimeoutReg. On boot, they will be loaded from EEProm. Any              */
.................... /* configuration changes will be changed in EEprom, hence will be restored on*/
.................... /* subsequent boot.                                                          */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* Register definitions                                                      */
.................... /*****************************************************************************/
.................... //!unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... //!unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... //!unsigned int32 timeoutReg2 = 0;
.................... //!unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... unsigned int32 timeCounter = 0;
.................... 
.................... /*****************************************************************************/
.................... /* TIMEOUT_INIT initializes the timer                                        */
.................... /*****************************************************************************/
.................... void event_timer_init()
.................... {        
....................    disable_interrupts(INT_TIMER1);
00D36:  MOVLB  E
00D38:  BCF    xC1.0
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_1);
00D3A:  MOVLW  01
00D3C:  MOVWF  FD1
00D3E:  MOVLW  07
00D40:  MOVWF  FCE
00D42:  CLRF   FCF
00D44:  CLRF   FD0
....................    timeoutReg0 = 0;  // clear all the timers
00D46:  MOVLB  1
00D48:  CLRF   x75
00D4A:  CLRF   x74
00D4C:  CLRF   x73
00D4E:  CLRF   x72
....................    timeoutReg1 = 0;
00D50:  CLRF   x79
00D52:  CLRF   x78
00D54:  CLRF   x77
00D56:  CLRF   x76
....................    timeoutReg2 = 0;
00D58:  CLRF   x7D
00D5A:  CLRF   x7C
00D5C:  CLRF   x7B
00D5E:  CLRF   x7A
.................... //!   intTimeoutReg = 50;
....................    enable_interrupts(INT_TIMER1);
00D60:  MOVLB  E
00D62:  BSF    xC1.0
00D64:  MOVLB  0
00D66:  GOTO   A72A (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* TIMEOUT INTERRUPT decrements the timeout registers every second           */
.................... /*****************************************************************************/
.................... #INT_TIMER1
.................... void TIMER1_isr(void) 
*
00292:  MOVLB  0
.................... {
....................    set_timer1(0x0BDB); // load timer register to allow 10 millisecond interupts
00294:  MOVLW  0B
00296:  MOVWF  FCD
00298:  MOVLW  DB
0029A:  MOVWF  FCC
0029C:  NOP   
....................    if (timeoutReg0 > 10) timeoutReg0 -= 10; else timeoutReg0 = 0;
0029E:  MOVLB  1
002A0:  MOVF   x75,F
002A2:  BNZ   02B2
002A4:  MOVF   x74,F
002A6:  BNZ   02B2
002A8:  MOVF   x73,F
002AA:  BNZ   02B2
002AC:  MOVF   x72,W
002AE:  SUBLW  0A
002B0:  BC    02C0
002B2:  MOVLW  0A
002B4:  SUBWF  x72,F
002B6:  MOVLW  00
002B8:  SUBWFB x73,F
002BA:  SUBWFB x74,F
002BC:  SUBWFB x75,F
002BE:  BRA    02C8
002C0:  CLRF   x75
002C2:  CLRF   x74
002C4:  CLRF   x73
002C6:  CLRF   x72
....................    if (timeoutReg1 > 10) timeoutReg1 -= 10; else timeoutReg1 = 0;
002C8:  MOVF   x79,F
002CA:  BNZ   02DA
002CC:  MOVF   x78,F
002CE:  BNZ   02DA
002D0:  MOVF   x77,F
002D2:  BNZ   02DA
002D4:  MOVF   x76,W
002D6:  SUBLW  0A
002D8:  BC    02E8
002DA:  MOVLW  0A
002DC:  SUBWF  x76,F
002DE:  MOVLW  00
002E0:  SUBWFB x77,F
002E2:  SUBWFB x78,F
002E4:  SUBWFB x79,F
002E6:  BRA    02F0
002E8:  CLRF   x79
002EA:  CLRF   x78
002EC:  CLRF   x77
002EE:  CLRF   x76
....................    if (timeoutReg2 > 10) timeoutReg2 -= 10; else timeoutReg2 = 0;
002F0:  MOVF   x7D,F
002F2:  BNZ   0302
002F4:  MOVF   x7C,F
002F6:  BNZ   0302
002F8:  MOVF   x7B,F
002FA:  BNZ   0302
002FC:  MOVF   x7A,W
002FE:  SUBLW  0A
00300:  BC    0310
00302:  MOVLW  0A
00304:  SUBWF  x7A,F
00306:  MOVLW  00
00308:  SUBWFB x7B,F
0030A:  SUBWFB x7C,F
0030C:  SUBWFB x7D,F
0030E:  BRA    0318
00310:  CLRF   x7D
00312:  CLRF   x7C
00314:  CLRF   x7B
00316:  CLRF   x7A
....................    if (intTimeoutReg != 0) // INTERRUPTING TIMER
00318:  MOVF   x7E,F
0031A:  BNZ   0320
0031C:  MOVF   x7F,F
0031E:  BZ    035C
....................    {
....................       timeCounter+=10;
00320:  MOVLW  0A
00322:  MOVLB  5
00324:  ADDWF  x66,F
00326:  MOVLW  00
00328:  ADDWFC x67,F
0032A:  ADDWFC x68,F
0032C:  ADDWFC x69,F
....................       if (timeCounter >= intTimeoutReg)
0032E:  MOVF   x69,F
00330:  BNZ   034C
00332:  MOVF   x68,F
00334:  BNZ   034C
00336:  MOVLB  1
00338:  MOVF   x7F,W
0033A:  MOVLB  5
0033C:  SUBWF  x67,W
0033E:  BNC   035A
00340:  BNZ   034C
00342:  MOVLB  1
00344:  MOVF   x7E,W
00346:  MOVLB  5
00348:  SUBWF  x66,W
0034A:  BNC   035A
....................       {
....................          sensor_monitor_interrupt_task();
0034C:  MOVLB  0
0034E:  BRA    01F6
....................          timeCounter = 0;
00350:  MOVLB  5
00352:  CLRF   x69
00354:  CLRF   x68
00356:  CLRF   x67
00358:  CLRF   x66
0035A:  MOVLB  1
....................       }
....................    }
.................... }
.................... 
.................... #endif
.................... 
.................... #include <commandHandler.c>
.................... #ifndef cmdHandlerC
.................... #define cmdHandlerC
.................... #include <commandHandler.h>
.................... #ifndef cmdHandler
.................... #define cmdHandler
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................     float kP;      // proportional gain
....................     float kI;      // integral gain
....................     float kD;      // derivative gain
....................     float SP;      // set point-- desired output
....................     float PV;      // process variable-- measured output
....................     float PVold;   // oldPV value  
....................     float CV;      // control variable-- output -- 0 to 100%
....................     float I;       // integral value
....................     float maxSP;   // Max setpoint in microns
....................     float minSP;   // Min setpoint in microns
.................... }PID[2] = {
....................    //  P     I     D
....................    //0.01    0.3   0.1
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}, 
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}
....................     };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... //!#define op_upper_bound 63  // CRYO
.................... //!#define op_lower_bound -63 // CRYO
.................... 
.................... #define op_upper_bound 63  // AMBIENT 
.................... #define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    BOOLEAN homeFlag;       // Flag to trigger the homing routine
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,FALSE},
....................    {0,0,0,0,0,0,0,0,0,0,FALSE}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................     BOOLEAN invV;
....................     unsigned int16 ipVal;
....................     float opPcnt;
....................    
.................... }dacVals[2] = 
.................... {
....................     {FALSE,0,0},
....................     {FALSE,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... 
0035C:  MOVLB  E
0035E:  BCF    xC9.0
00360:  MOVLB  0
00362:  GOTO   006E
.................... #define hwID 'D'   // DiFCS
.................... 
.................... /*****************************************************************************/
.................... /* RESPONSE MESSAGES                                                         */
.................... /*****************************************************************************/
.................... typedef struct response {
....................     int8 id;
....................     char *msg;
.................... } resp;
.................... 
.................... //!#define INVALID_DATA "error - invalid data"
.................... //!#define invalidTime "error - invalid TO value"
.................... //!#define overrun "error - buffer overrun"
.................... //!#define dcVoltage "VDC:%f1"
.................... //!#define USBVoltage "VUSB:%f"
.................... //!#define USBupstream "VUSBup:%f"
.................... //!#define plus5V "5V Rail:%f"
.................... //!#define plus3V3 "3V3 Rai:%f"
.................... //!#define allVoltages "All Voltages = %f, %f, %f, %f, %f"
.................... //!#define USBdownstream "USB downstream status:\r\nPG:%s\r\nch0:%s\r\nch1:%s"
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC MESSGAGE DUMP                                                  */
.................... /*****************************************************************************/
.................... //!#define voltageMsg "V0:%f\r\nV1:%f\r\nV2:%f\r\nV3:%f\r\nV4:%f"
.................... //!#define TimerMsg "T0:%Lu\r\nT1:%Lu\r\nT2:%Lu\r\Tint:%Lu\r\nTtick:%Lu"
.................... //!#define ioStatusMsg "Inputs:%u\r\nOutputs:%u\r\nStatus:%u"
.................... //!#define diagnosticMsg "V0:%f\r\nV1:%f\r\nV2:%f\r\nV3:%f\r\nV4:%f\r\nT0:%Lu\r\nT1:%Lu\r\nT2:%Lu\r\nTint:%Lu\r\nTtick:%Lu\r\nInputs:%u\r\nOutputs:%u\r\nStatus:%u"
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC COMMAND PROTOTYPES                                             */
.................... /*****************************************************************************/
.................... int8 getRev(unsigned int8);                 // gr 
.................... int8 getSN(unsigned int8);                  // gs
.................... 
.................... int8 getOPchMap(unsigned int8);             // gChMap,   {1|2}
.................... int8 setOPchMap(unsigned int8);             // sChMap,   {1|2}, {X|Y}
.................... 
.................... int8 getIPchMode(unsigned int8);            // gChMode,  {1|2}
.................... int8 setIPchMode(unsigned int8);            // sChMode,  {1|2}, {MANUAL|MAGSNS}
....................    
.................... int8 getPIDvals(unsigned int8);             // gPID,     {1|2}, {P|I|D}
.................... int8 setPIDvals(unsigned int8);             // sPID,     {1|2}, {P|I|D}, <float>
.................... 
.................... int8 enablePID(unsigned int8);              // enaPID,   {1|2}
.................... int8 disablePID(unsigned int8);             // disPID,   {1|2}
.................... 
.................... int8 getSetPoint(unsigned int8);            // gSP,      {1|2}
.................... int8 setSetPoint(unsigned int8);            // sSP,      {1|2}, <float>
.................... 
.................... int8 getAllSensorCalParams(unsigned int8);  // gSCals,   {1|2}
.................... int8 getSensorCalParam(unsigned int8);      // gSCal,    {1|2}, {0|1|2|3|4|5}
.................... int8 setSensorCalParam(unsigned int8);      // sSCal,    {1|2}, {0|1|2|3|4|5}, <float>
.................... 
.................... int8 getMonitorCalParam(unsigned int8);     // gMCal,    {N15|200|5V6|5VA|3V6X|3V3A|3V3D}
.................... int8 setMonitorCalParam(unsigned int8);     // sMCal,    {N15|200|5V6|5VA|3V6X|3V3A|3V3D}, <float>, <float>
.................... int8 getMonitorValue(unsigned int8);        // gMon,     {N15|200|5V6|5VA|3V6X|3V3A|3V3D|all}
.................... 
.................... int8 getPIDdata(unsigned int8);             // gPIDdata, {1|2}, {PV|CV|PVold|I}
.................... 
.................... int8 getIPdata(unsigned int8);              // gIPdata,  {1|2}, {raw|calib|p0|poles|real}
....................    
.................... int8 getManOPvals(unsigned int8);           // gManOP,   {1|2}  
.................... int8 setManOPvals(unsigned int8);           // sManOP,   {1|2}, <float>  
.................... 
.................... int8 setFilterOn(unsigned int8);            // sFiltOn
.................... int8 setFilterOff(unsigned int8);           // sFiltOff
.................... 
.................... int8 setHomeAxis(unsigned int8);            // sHome,    {1|2}      
....................                                                        
.................... int8 invalidCmd(unsigned int8);
.................... 
.................... struct command {
....................     char *cmd_name;
....................     int8 (*cmd_func)(unsigned int8);
.................... };
.................... 
.................... BOOLEAN arg_is_float(char *);
.................... BOOLEAN is_valid_channel(char *);
.................... int8 hex_to_int(char);
.................... void echo_cmd(unsigned int8 rec);
.................... int8 command_parser(unsigned int8 rec);
.................... void command_handler_task();
.................... 
.................... #endif
.................... 
.................... 
.................... /* LIST OF DIAGNOSTIC COMMAND KEYWORDS AND THEIR FUNCTIONS */
.................... struct command cmd_list[] = {
....................     {"gr",       &getRev},
....................     {"gs",       &getSN},
....................     {"gChMap",   &getOPchMap},
....................     {"sChMap",   &setOPchMap},
....................     {"gChMode",  &getIPchMode},
....................     {"sChMode",  &setIPchMode},
....................     {"gPID",     &getPIDvals},
....................     {"sPID",     &setPIDvals},
....................     {"gSP",      &getSetPoint},
....................     {"sSP",      &setSetPoint},
....................     {"gSCals",   &getAllSensorCalParams},
....................     {"gSCal",    &getSensorCalParam},
....................     {"sSCal",    &setSensorCalParam},
....................     {"gMCal",    &getMonitorCalParam},
....................     {"sMCal",    &setMonitorCalParam},
....................     {"gMon",     &getMonitorValue},
....................     {"gPIDdata", &getPIDdata},
....................     {"gIPdata",  &getIPdata},
....................     {"gManOP",   &getManOPvals},
....................     {"sManOP",   &setManOPvals},
....................     {"sFiltOn",  &setFilterOn},
....................     {"sFiltOff", &setFilterOff},
....................     {"sHome",    &setHomeAxis},
....................     {"\0", &invalidCmd}
.................... };
.................... 
.................... /* LIST OF RESPONSE MESSAGES */
.................... enum resp_e { 
....................    SUCCESS,
....................    INV_CMD,
....................    INV_PARAM 
.................... };
.................... 
.................... resp resp_list[] = {
....................    {SUCCESS, "SUCCESS"},
....................    {INV_CMD, "INVALID COMMAND"},
....................    {INV_PARAM, "INVALID PARAMETER"}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC COMMAND DEFINITIONS                                            */
.................... /*****************************************************************************/
....................                           
.................... int8 getRev(unsigned int8 rec){
....................    sprintf(retData+strlen(retData), "%s,", version);
*
05BA2:  MOVLW  04
05BA4:  MOVLB  7
05BA6:  MOVWF  x42
05BA8:  MOVLW  C1
05BAA:  MOVWF  x41
05BAC:  MOVLB  0
05BAE:  RCALL  5598
05BB0:  MOVFF  02,03
05BB4:  MOVF   01,W
05BB6:  ADDLW  C1
05BB8:  MOVLB  7
05BBA:  MOVWF  x0B
05BBC:  MOVLW  04
05BBE:  ADDWFC 02,W
05BC0:  MOVWF  x0C
05BC2:  MOVFF  FE8,565
05BC6:  MOVFF  70B,564
05BCA:  MOVLW  66
05BCC:  MOVWF  FF6
05BCE:  MOVLW  03
05BD0:  MOVWF  FF7
05BD2:  MOVLB  0
05BD4:  RCALL  5B82
05BD6:  MOVLW  2C
05BD8:  MOVLB  7
05BDA:  MOVWF  x50
05BDC:  MOVLB  0
05BDE:  RCALL  55D0
....................    return SUCCESS;
05BE0:  MOVLW  00
05BE2:  MOVWF  01
05BE4:  RETURN 0
.................... }
.................... 
.................... int8 getSN(unsigned int8 rec){
....................    sprintf(retData+strlen(retData), "%s,", serialID);
05BE6:  MOVLW  04
05BE8:  MOVLB  7
05BEA:  MOVWF  x42
05BEC:  MOVLW  C1
05BEE:  MOVWF  x41
05BF0:  MOVLB  0
05BF2:  RCALL  5598
05BF4:  MOVFF  02,03
05BF8:  MOVF   01,W
05BFA:  ADDLW  C1
05BFC:  MOVLB  7
05BFE:  MOVWF  x0B
05C00:  MOVLW  04
05C02:  ADDWFC 02,W
05C04:  MOVWF  x0C
05C06:  MOVFF  FE8,565
05C0A:  MOVFF  70B,564
05C0E:  MOVLW  70
05C10:  MOVWF  FF6
05C12:  MOVLW  03
05C14:  MOVWF  FF7
05C16:  MOVLB  0
05C18:  RCALL  5B82
05C1A:  MOVLW  2C
05C1C:  MOVLB  7
05C1E:  MOVWF  x50
05C20:  MOVLB  0
05C22:  RCALL  55D0
....................    return SUCCESS;
05C24:  MOVLW  00
05C26:  MOVWF  01
05C28:  RETURN 0
.................... }
.................... 
.................... int8 getOPchMap(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
06136:  MOVLB  7
06138:  CLRF   x42
0613A:  MOVFF  690,741
0613E:  CLRF   x44
06140:  MOVLW  B5
06142:  MOVWF  x43
06144:  MOVLB  0
06146:  CALL   08B6
0614A:  MOVFF  02,70D
0614E:  MOVFF  01,70C
06152:  MOVLW  06
06154:  MOVLB  7
06156:  ADDWF  x0C,F
06158:  MOVLW  00
0615A:  ADDWFC x0D,F
0615C:  MOVLW  32
0615E:  ADDWF  x0C,W
06160:  MOVWF  01
06162:  MOVLW  00
06164:  ADDWFC x0D,W
06166:  MOVWF  03
06168:  MOVF   01,W
0616A:  ADDLW  EB
0616C:  MOVWF  01
0616E:  MOVLW  01
06170:  ADDWFC 03,F
06172:  MOVFF  01,70C
06176:  MOVFF  03,70D
0617A:  MOVFF  03,734
0617E:  MOVFF  01,733
06182:  MOVLB  0
06184:  RCALL  5C2A
06186:  MOVF   01,F
06188:  BNZ   6192
0618A:  MOVLW  02
0618C:  MOVWF  01
0618E:  BRA    62E0
06190:  BRA    61EE
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06192:  MOVLB  7
06194:  CLRF   x42
06196:  MOVFF  690,741
0619A:  CLRF   x44
0619C:  MOVLW  B5
0619E:  MOVWF  x43
061A0:  MOVLB  0
061A2:  CALL   08B6
061A6:  MOVFF  02,70D
061AA:  MOVFF  01,70C
061AE:  MOVLW  06
061B0:  MOVLB  7
061B2:  ADDWF  x0C,F
061B4:  MOVLW  00
061B6:  ADDWFC x0D,F
061B8:  MOVLW  32
061BA:  ADDWF  x0C,W
061BC:  MOVWF  01
061BE:  MOVLW  00
061C0:  ADDWFC x0D,W
061C2:  MOVWF  03
061C4:  MOVF   01,W
061C6:  ADDLW  EB
061C8:  MOVWF  01
061CA:  MOVLW  01
061CC:  ADDWFC 03,F
061CE:  MOVFF  01,70C
061D2:  MOVFF  03,70D
061D6:  MOVFF  03,734
061DA:  MOVFF  01,733
061DE:  CLRF   x36
061E0:  CLRF   x35
061E2:  MOVLW  0A
061E4:  MOVWF  x37
061E6:  MOVLB  0
061E8:  RCALL  5D1A
061EA:  MOVFF  01,70B
....................    
....................    /*** GET CHANNEL MAP ***************/ 
....................    if      (0 == chMap[arg1-1]) sprintf(retData+strlen(retData), "%d,%c,", arg1, 'X');
061EE:  MOVLW  01
061F0:  MOVLB  7
061F2:  SUBWF  x0B,W
061F4:  MOVWF  x0D
061F6:  CLRF   x0F
061F8:  MOVLW  70
061FA:  MOVWF  x0E
061FC:  MOVLB  0
061FE:  CALL   4614
06202:  BTFSC  01.0
06204:  BRA    6262
06206:  MOVLW  04
06208:  MOVLB  7
0620A:  MOVWF  x42
0620C:  MOVLW  C1
0620E:  MOVWF  x41
06210:  MOVLB  0
06212:  CALL   5598
06216:  MOVFF  02,03
0621A:  MOVF   01,W
0621C:  ADDLW  C1
0621E:  MOVLB  7
06220:  MOVWF  x0C
06222:  MOVLW  04
06224:  ADDWFC 02,W
06226:  MOVWF  x0D
06228:  MOVFF  FE8,565
0622C:  MOVFF  70C,564
06230:  MOVFF  70B,734
06234:  MOVLW  18
06236:  MOVWF  x35
06238:  MOVLB  0
0623A:  RCALL  606E
0623C:  MOVLW  2C
0623E:  MOVLB  7
06240:  MOVWF  x50
06242:  MOVLB  0
06244:  CALL   55D0
06248:  MOVLW  58
0624A:  MOVLB  7
0624C:  MOVWF  x50
0624E:  MOVLB  0
06250:  CALL   55D0
06254:  MOVLW  2C
06256:  MOVLB  7
06258:  MOVWF  x50
0625A:  MOVLB  0
0625C:  CALL   55D0
06260:  BRA    62DC
....................    else if (1 == chMap[arg1-1]) sprintf(retData+strlen(retData), "%d,%c,", arg1, 'Y');
06262:  MOVLW  01
06264:  MOVLB  7
06266:  SUBWF  x0B,W
06268:  MOVWF  x0D
0626A:  CLRF   x0F
0626C:  MOVLW  70
0626E:  MOVWF  x0E
06270:  MOVLB  0
06272:  CALL   4614
06276:  BTFSS  01.0
06278:  BRA    62D6
0627A:  MOVLW  04
0627C:  MOVLB  7
0627E:  MOVWF  x42
06280:  MOVLW  C1
06282:  MOVWF  x41
06284:  MOVLB  0
06286:  CALL   5598
0628A:  MOVFF  02,03
0628E:  MOVF   01,W
06290:  ADDLW  C1
06292:  MOVLB  7
06294:  MOVWF  x0C
06296:  MOVLW  04
06298:  ADDWFC 02,W
0629A:  MOVWF  x0D
0629C:  MOVFF  FE8,565
062A0:  MOVFF  70C,564
062A4:  MOVFF  70B,734
062A8:  MOVLW  18
062AA:  MOVWF  x35
062AC:  MOVLB  0
062AE:  RCALL  606E
062B0:  MOVLW  2C
062B2:  MOVLB  7
062B4:  MOVWF  x50
062B6:  MOVLB  0
062B8:  CALL   55D0
062BC:  MOVLW  59
062BE:  MOVLB  7
062C0:  MOVWF  x50
062C2:  MOVLB  0
062C4:  CALL   55D0
062C8:  MOVLW  2C
062CA:  MOVLB  7
062CC:  MOVWF  x50
062CE:  MOVLB  0
062D0:  CALL   55D0
062D4:  BRA    62DC
....................    else return INV_PARAM;
062D6:  MOVLW  02
062D8:  MOVWF  01
062DA:  BRA    62E0
....................    
....................    return SUCCESS;
062DC:  MOVLW  00
062DE:  MOVWF  01
062E0:  RETURN 0
.................... }
.................... 
.................... int8 setOPchMap(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
06324:  MOVLB  7
06326:  CLRF   x42
06328:  MOVFF  690,741
0632C:  CLRF   x44
0632E:  MOVLW  B5
06330:  MOVWF  x43
06332:  MOVLB  0
06334:  CALL   08B6
06338:  MOVFF  02,70E
0633C:  MOVFF  01,70D
06340:  MOVLW  06
06342:  MOVLB  7
06344:  ADDWF  x0D,F
06346:  MOVLW  00
06348:  ADDWFC x0E,F
0634A:  MOVLW  32
0634C:  ADDWF  x0D,W
0634E:  MOVWF  01
06350:  MOVLW  00
06352:  ADDWFC x0E,W
06354:  MOVWF  03
06356:  MOVF   01,W
06358:  ADDLW  EB
0635A:  MOVWF  01
0635C:  MOVLW  01
0635E:  ADDWFC 03,F
06360:  MOVFF  01,70D
06364:  MOVFF  03,70E
06368:  MOVFF  03,734
0636C:  MOVFF  01,733
06370:  MOVLB  0
06372:  RCALL  5C2A
06374:  MOVF   01,F
06376:  BNZ   6380
06378:  MOVLW  02
0637A:  MOVWF  01
0637C:  BRA    64D0
0637E:  BRA    63DC
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06380:  MOVLB  7
06382:  CLRF   x42
06384:  MOVFF  690,741
06388:  CLRF   x44
0638A:  MOVLW  B5
0638C:  MOVWF  x43
0638E:  MOVLB  0
06390:  CALL   08B6
06394:  MOVFF  02,70E
06398:  MOVFF  01,70D
0639C:  MOVLW  06
0639E:  MOVLB  7
063A0:  ADDWF  x0D,F
063A2:  MOVLW  00
063A4:  ADDWFC x0E,F
063A6:  MOVLW  32
063A8:  ADDWF  x0D,W
063AA:  MOVWF  01
063AC:  MOVLW  00
063AE:  ADDWFC x0E,W
063B0:  MOVWF  03
063B2:  MOVF   01,W
063B4:  ADDLW  EB
063B6:  MOVWF  01
063B8:  MOVLW  01
063BA:  ADDWFC 03,F
063BC:  MOVFF  01,70D
063C0:  MOVFF  03,70E
063C4:  MOVFF  03,734
063C8:  MOVFF  01,733
063CC:  CLRF   x36
063CE:  CLRF   x35
063D0:  MOVLW  0A
063D2:  MOVWF  x37
063D4:  MOVLB  0
063D6:  RCALL  5D1A
063D8:  MOVFF  01,70B
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
063DC:  MOVLB  7
063DE:  CLRF   x42
063E0:  MOVFF  690,741
063E4:  CLRF   x44
063E6:  MOVLW  B5
063E8:  MOVWF  x43
063EA:  MOVLB  0
063EC:  CALL   08B6
063F0:  MOVFF  02,70E
063F4:  MOVFF  01,70D
063F8:  MOVLW  06
063FA:  MOVLB  7
063FC:  ADDWF  x0D,F
063FE:  MOVLW  00
06400:  ADDWFC x0E,F
06402:  MOVLW  4B
06404:  ADDWF  x0D,W
06406:  MOVWF  01
06408:  MOVLW  00
0640A:  ADDWFC x0E,W
0640C:  MOVWF  03
0640E:  MOVF   01,W
06410:  ADDLW  EB
06412:  MOVWF  01
06414:  MOVLW  01
06416:  ADDWFC 03,F
06418:  MOVFF  01,70D
0641C:  MOVFF  03,70E
06420:  MOVFF  03,742
06424:  MOVFF  01,741
06428:  MOVLB  0
0642A:  CALL   5598
0642E:  MOVFF  02,03
06432:  MOVF   01,W
06434:  SUBLW  01
06436:  BNZ   643C
06438:  MOVF   03,F
0643A:  BZ    6444
0643C:  MOVLW  02
0643E:  MOVWF  01
06440:  BRA    64D0
06442:  BRA    6484
....................    else arg2 = SERcmd[rec].p[3][0];
06444:  MOVLB  7
06446:  CLRF   x42
06448:  MOVFF  690,741
0644C:  CLRF   x44
0644E:  MOVLW  B5
06450:  MOVWF  x43
06452:  MOVLB  0
06454:  CALL   08B6
06458:  MOVFF  02,70E
0645C:  MOVFF  01,70D
06460:  MOVLW  06
06462:  MOVLB  7
06464:  ADDWF  x0D,F
06466:  MOVLW  00
06468:  ADDWFC x0E,F
0646A:  MOVLW  4B
0646C:  ADDWF  x0D,F
0646E:  MOVLW  00
06470:  ADDWFC x0E,F
06472:  MOVLW  EB
06474:  ADDWF  x0D,W
06476:  MOVWF  FE9
06478:  MOVLW  01
0647A:  ADDWFC x0E,W
0647C:  MOVWF  FEA
0647E:  MOVFF  FEF,70C
06482:  MOVLB  0
....................    
....................    /*** SET CHANNEL MAP ***************/
....................    if      ('X' == arg2) chMap[arg1-1] = chX;
06484:  MOVLB  7
06486:  MOVF   x0C,W
06488:  SUBLW  58
0648A:  BNZ   64A4
0648C:  MOVLW  01
0648E:  SUBWF  x0B,W
06490:  MOVWF  x0D
06492:  MOVWF  x22
06494:  CLRF   x23
06496:  CLRF   x25
06498:  MOVLW  70
0649A:  MOVWF  x24
0649C:  MOVLB  0
0649E:  RCALL  62E2
064A0:  BRA    64CC
064A2:  MOVLB  7
....................    else if ('Y' == arg2) chMap[arg1-1] = chY;
064A4:  MOVF   x0C,W
064A6:  SUBLW  59
064A8:  BNZ   64C4
064AA:  MOVLW  01
064AC:  SUBWF  x0B,W
064AE:  MOVWF  x0D
064B0:  MOVWF  x22
064B2:  MOVLW  01
064B4:  MOVWF  x23
064B6:  CLRF   x25
064B8:  MOVLW  70
064BA:  MOVWF  x24
064BC:  MOVLB  0
064BE:  RCALL  62E2
064C0:  BRA    64CC
064C2:  MOVLB  7
....................    else return INV_PARAM;
064C4:  MOVLW  02
064C6:  MOVWF  01
064C8:  MOVLB  0
064CA:  BRA    64D0
....................    
....................    return SUCCESS;
064CC:  MOVLW  00
064CE:  MOVWF  01
064D0:  RETURN 0
.................... }
.................... 
.................... int8 getIPchMode(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
064D2:  MOVLB  7
064D4:  CLRF   x42
064D6:  MOVFF  690,741
064DA:  CLRF   x44
064DC:  MOVLW  B5
064DE:  MOVWF  x43
064E0:  MOVLB  0
064E2:  CALL   08B6
064E6:  MOVFF  02,70D
064EA:  MOVFF  01,70C
064EE:  MOVLW  06
064F0:  MOVLB  7
064F2:  ADDWF  x0C,F
064F4:  MOVLW  00
064F6:  ADDWFC x0D,F
064F8:  MOVLW  32
064FA:  ADDWF  x0C,W
064FC:  MOVWF  01
064FE:  MOVLW  00
06500:  ADDWFC x0D,W
06502:  MOVWF  03
06504:  MOVF   01,W
06506:  ADDLW  EB
06508:  MOVWF  01
0650A:  MOVLW  01
0650C:  ADDWFC 03,F
0650E:  MOVFF  01,70C
06512:  MOVFF  03,70D
06516:  MOVFF  03,734
0651A:  MOVFF  01,733
0651E:  MOVLB  0
06520:  CALL   5C2A
06524:  MOVF   01,F
06526:  BNZ   6530
06528:  MOVLW  02
0652A:  MOVWF  01
0652C:  BRA    6660
0652E:  BRA    658E
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06530:  MOVLB  7
06532:  CLRF   x42
06534:  MOVFF  690,741
06538:  CLRF   x44
0653A:  MOVLW  B5
0653C:  MOVWF  x43
0653E:  MOVLB  0
06540:  CALL   08B6
06544:  MOVFF  02,70D
06548:  MOVFF  01,70C
0654C:  MOVLW  06
0654E:  MOVLB  7
06550:  ADDWF  x0C,F
06552:  MOVLW  00
06554:  ADDWFC x0D,F
06556:  MOVLW  32
06558:  ADDWF  x0C,W
0655A:  MOVWF  01
0655C:  MOVLW  00
0655E:  ADDWFC x0D,W
06560:  MOVWF  03
06562:  MOVF   01,W
06564:  ADDLW  EB
06566:  MOVWF  01
06568:  MOVLW  01
0656A:  ADDWFC 03,F
0656C:  MOVFF  01,70C
06570:  MOVFF  03,70D
06574:  MOVFF  03,734
06578:  MOVFF  01,733
0657C:  CLRF   x36
0657E:  CLRF   x35
06580:  MOVLW  0A
06582:  MOVWF  x37
06584:  MOVLB  0
06586:  CALL   5D1A
0658A:  MOVFF  01,70B
....................    
....................    /*** GET INPUT MAP *****************/
....................    if      (0 == chMode[arg1-1]) sprintf(retData+strlen(retData), "%d,MANUAL,", arg1);
0658E:  MOVLW  01
06590:  MOVLB  7
06592:  SUBWF  x0B,W
06594:  MOVWF  x0D
06596:  CLRF   x0F
06598:  MOVLW  71
0659A:  MOVWF  x0E
0659C:  MOVLB  0
0659E:  CALL   4614
065A2:  BTFSC  01.0
065A4:  BRA    65F2
065A6:  MOVLW  04
065A8:  MOVLB  7
065AA:  MOVWF  x42
065AC:  MOVLW  C1
065AE:  MOVWF  x41
065B0:  MOVLB  0
065B2:  CALL   5598
065B6:  MOVFF  02,03
065BA:  MOVF   01,W
065BC:  ADDLW  C1
065BE:  MOVLB  7
065C0:  MOVWF  x0C
065C2:  MOVLW  04
065C4:  ADDWFC 02,W
065C6:  MOVWF  x0D
065C8:  MOVFF  FE8,565
065CC:  MOVFF  70C,564
065D0:  MOVFF  70B,734
065D4:  MOVLW  18
065D6:  MOVWF  x35
065D8:  MOVLB  0
065DA:  RCALL  606E
065DC:  MOVLW  78
065DE:  MOVWF  FF6
065E0:  MOVLW  03
065E2:  MOVWF  FF7
065E4:  MOVLW  08
065E6:  MOVLB  7
065E8:  MOVWF  x0F
065EA:  MOVLB  0
065EC:  CALL   55F0
065F0:  BRA    665C
....................    else if (1 == chMode[arg1-1]) sprintf(retData+strlen(retData), "%d,MAGSNS,", arg1);
065F2:  MOVLW  01
065F4:  MOVLB  7
065F6:  SUBWF  x0B,W
065F8:  MOVWF  x0D
065FA:  CLRF   x0F
065FC:  MOVLW  71
065FE:  MOVWF  x0E
06600:  MOVLB  0
06602:  CALL   4614
06606:  BTFSS  01.0
06608:  BRA    6656
0660A:  MOVLW  04
0660C:  MOVLB  7
0660E:  MOVWF  x42
06610:  MOVLW  C1
06612:  MOVWF  x41
06614:  MOVLB  0
06616:  CALL   5598
0661A:  MOVFF  02,03
0661E:  MOVF   01,W
06620:  ADDLW  C1
06622:  MOVLB  7
06624:  MOVWF  x0C
06626:  MOVLW  04
06628:  ADDWFC 02,W
0662A:  MOVWF  x0D
0662C:  MOVFF  FE8,565
06630:  MOVFF  70C,564
06634:  MOVFF  70B,734
06638:  MOVLW  18
0663A:  MOVWF  x35
0663C:  MOVLB  0
0663E:  RCALL  606E
06640:  MOVLW  84
06642:  MOVWF  FF6
06644:  MOVLW  03
06646:  MOVWF  FF7
06648:  MOVLW  08
0664A:  MOVLB  7
0664C:  MOVWF  x0F
0664E:  MOVLB  0
06650:  CALL   55F0
06654:  BRA    665C
....................    else return INV_PARAM;
06656:  MOVLW  02
06658:  MOVWF  01
0665A:  BRA    6660
....................    
....................    return SUCCESS;
0665C:  MOVLW  00
0665E:  MOVWF  01
06660:  RETURN 0
.................... }
.................... 
.................... int8 setIPchMode(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char *arg2;
....................    char *s_manual = "MANUAL";
06662:  MOVLW  4D
06664:  MOVLB  7
06666:  MOVWF  x10
06668:  MOVLW  41
0666A:  MOVWF  x11
0666C:  MOVLW  4E
0666E:  MOVWF  x12
06670:  MOVLW  55
06672:  MOVWF  x13
06674:  MOVLW  41
06676:  MOVWF  x14
06678:  MOVLW  4C
0667A:  MOVWF  x15
0667C:  CLRF   x16
0667E:  MOVLW  07
06680:  MOVWF  x0F
06682:  MOVLW  10
06684:  MOVWF  x0E
....................    char *s_magsns = "MAGSNS";
06686:  MOVLW  4D
06688:  MOVWF  x19
0668A:  MOVLW  41
0668C:  MOVWF  x1A
0668E:  MOVLW  47
06690:  MOVWF  x1B
06692:  MOVLW  53
06694:  MOVWF  x1C
06696:  MOVLW  4E
06698:  MOVWF  x1D
0669A:  MOVLW  53
0669C:  MOVWF  x1E
0669E:  CLRF   x1F
066A0:  MOVLW  07
066A2:  MOVWF  x18
066A4:  MOVLW  19
066A6:  MOVWF  x17
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
066A8:  CLRF   x42
066AA:  MOVFF  690,741
066AE:  CLRF   x44
066B0:  MOVLW  B5
066B2:  MOVWF  x43
066B4:  MOVLB  0
066B6:  CALL   08B6
066BA:  MOVFF  02,721
066BE:  MOVFF  01,720
066C2:  MOVLW  06
066C4:  MOVLB  7
066C6:  ADDWF  x20,F
066C8:  MOVLW  00
066CA:  ADDWFC x21,F
066CC:  MOVLW  32
066CE:  ADDWF  x20,W
066D0:  MOVWF  01
066D2:  MOVLW  00
066D4:  ADDWFC x21,W
066D6:  MOVWF  03
066D8:  MOVF   01,W
066DA:  ADDLW  EB
066DC:  MOVWF  01
066DE:  MOVLW  01
066E0:  ADDWFC 03,F
066E2:  MOVFF  01,720
066E6:  MOVFF  03,721
066EA:  MOVFF  03,734
066EE:  MOVFF  01,733
066F2:  MOVLB  0
066F4:  CALL   5C2A
066F8:  MOVF   01,F
066FA:  BNZ   6704
066FC:  MOVLW  02
066FE:  MOVWF  01
06700:  BRA    687A
06702:  BRA    6762
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06704:  MOVLB  7
06706:  CLRF   x42
06708:  MOVFF  690,741
0670C:  CLRF   x44
0670E:  MOVLW  B5
06710:  MOVWF  x43
06712:  MOVLB  0
06714:  CALL   08B6
06718:  MOVFF  02,721
0671C:  MOVFF  01,720
06720:  MOVLW  06
06722:  MOVLB  7
06724:  ADDWF  x20,F
06726:  MOVLW  00
06728:  ADDWFC x21,F
0672A:  MOVLW  32
0672C:  ADDWF  x20,W
0672E:  MOVWF  01
06730:  MOVLW  00
06732:  ADDWFC x21,W
06734:  MOVWF  03
06736:  MOVF   01,W
06738:  ADDLW  EB
0673A:  MOVWF  01
0673C:  MOVLW  01
0673E:  ADDWFC 03,F
06740:  MOVFF  01,720
06744:  MOVFF  03,721
06748:  MOVFF  03,734
0674C:  MOVFF  01,733
06750:  CLRF   x36
06752:  CLRF   x35
06754:  MOVLW  0A
06756:  MOVWF  x37
06758:  MOVLB  0
0675A:  CALL   5D1A
0675E:  MOVFF  01,70B
....................    
....................    if (0 == strlen(SERcmd[rec].p[3])) return INV_PARAM;
06762:  MOVLB  7
06764:  CLRF   x42
06766:  MOVFF  690,741
0676A:  CLRF   x44
0676C:  MOVLW  B5
0676E:  MOVWF  x43
06770:  MOVLB  0
06772:  CALL   08B6
06776:  MOVFF  02,721
0677A:  MOVFF  01,720
0677E:  MOVLW  06
06780:  MOVLB  7
06782:  ADDWF  x20,F
06784:  MOVLW  00
06786:  ADDWFC x21,F
06788:  MOVLW  4B
0678A:  ADDWF  x20,W
0678C:  MOVWF  01
0678E:  MOVLW  00
06790:  ADDWFC x21,W
06792:  MOVWF  03
06794:  MOVF   01,W
06796:  ADDLW  EB
06798:  MOVWF  01
0679A:  MOVLW  01
0679C:  ADDWFC 03,F
0679E:  MOVFF  01,720
067A2:  MOVFF  03,721
067A6:  MOVFF  03,742
067AA:  MOVFF  01,741
067AE:  MOVLB  0
067B0:  CALL   5598
067B4:  MOVFF  02,03
067B8:  MOVF   01,W
067BA:  BNZ   67C8
067BC:  MOVF   03,F
067BE:  BNZ   67C8
067C0:  MOVLW  02
067C2:  MOVWF  01
067C4:  BRA    687A
067C6:  BRA    680E
....................    else arg2 = SERcmd[rec].p[3];
067C8:  MOVLB  7
067CA:  CLRF   x42
067CC:  MOVFF  690,741
067D0:  CLRF   x44
067D2:  MOVLW  B5
067D4:  MOVWF  x43
067D6:  MOVLB  0
067D8:  CALL   08B6
067DC:  MOVFF  02,721
067E0:  MOVFF  01,720
067E4:  MOVLW  06
067E6:  MOVLB  7
067E8:  ADDWF  x20,F
067EA:  MOVLW  00
067EC:  ADDWFC x21,F
067EE:  MOVLW  4B
067F0:  ADDWF  x20,W
067F2:  MOVWF  01
067F4:  MOVLW  00
067F6:  ADDWFC x21,W
067F8:  MOVWF  03
067FA:  MOVF   01,W
067FC:  ADDLW  EB
067FE:  MOVWF  01
06800:  MOVLW  01
06802:  ADDWFC 03,F
06804:  MOVFF  01,70C
06808:  MOVFF  03,70D
0680C:  MOVLB  0
....................    
....................    /*** SET INPUT MAP *****************/
....................    if      (0 == strcmp(s_manual, arg2)) chMode[arg1-1] = MANUAL;
0680E:  MOVFF  70F,742
06812:  MOVFF  70E,741
06816:  MOVFF  70D,744
0681A:  MOVFF  70C,743
0681E:  CALL   5B0A
06822:  MOVF   01,F
06824:  BNZ   683E
06826:  MOVLW  01
06828:  MOVLB  7
0682A:  SUBWF  x0B,W
0682C:  MOVWF  x20
0682E:  MOVWF  x22
06830:  CLRF   x23
06832:  CLRF   x25
06834:  MOVLW  71
06836:  MOVWF  x24
06838:  MOVLB  0
0683A:  RCALL  62E2
0683C:  BRA    6876
....................    else if (0 == strcmp(s_magsns, arg2)) chMode[arg1-1] = MAGSNS;
0683E:  MOVFF  718,742
06842:  MOVFF  717,741
06846:  MOVFF  70D,744
0684A:  MOVFF  70C,743
0684E:  CALL   5B0A
06852:  MOVF   01,F
06854:  BNZ   6870
06856:  MOVLW  01
06858:  MOVLB  7
0685A:  SUBWF  x0B,W
0685C:  MOVWF  x20
0685E:  MOVWF  x22
06860:  MOVLW  01
06862:  MOVWF  x23
06864:  CLRF   x25
06866:  MOVLW  71
06868:  MOVWF  x24
0686A:  MOVLB  0
0686C:  RCALL  62E2
0686E:  BRA    6876
....................    else return INV_PARAM;
06870:  MOVLW  02
06872:  MOVWF  01
06874:  BRA    687A
....................    
....................    return SUCCESS;
06876:  MOVLW  00
06878:  MOVWF  01
0687A:  RETURN 0
.................... }
.................... 
.................... int8 getPIDvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/ 
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0687C:  MOVLB  7
0687E:  CLRF   x42
06880:  MOVFF  690,741
06884:  CLRF   x44
06886:  MOVLW  B5
06888:  MOVWF  x43
0688A:  MOVLB  0
0688C:  CALL   08B6
06890:  MOVFF  02,70E
06894:  MOVFF  01,70D
06898:  MOVLW  06
0689A:  MOVLB  7
0689C:  ADDWF  x0D,F
0689E:  MOVLW  00
068A0:  ADDWFC x0E,F
068A2:  MOVLW  32
068A4:  ADDWF  x0D,W
068A6:  MOVWF  01
068A8:  MOVLW  00
068AA:  ADDWFC x0E,W
068AC:  MOVWF  03
068AE:  MOVF   01,W
068B0:  ADDLW  EB
068B2:  MOVWF  01
068B4:  MOVLW  01
068B6:  ADDWFC 03,F
068B8:  MOVFF  01,70D
068BC:  MOVFF  03,70E
068C0:  MOVFF  03,734
068C4:  MOVFF  01,733
068C8:  MOVLB  0
068CA:  CALL   5C2A
068CE:  MOVF   01,F
068D0:  BNZ   68DA
068D2:  MOVLW  02
068D4:  MOVWF  01
068D6:  BRA    6D3C
068D8:  BRA    6938
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
068DA:  MOVLB  7
068DC:  CLRF   x42
068DE:  MOVFF  690,741
068E2:  CLRF   x44
068E4:  MOVLW  B5
068E6:  MOVWF  x43
068E8:  MOVLB  0
068EA:  CALL   08B6
068EE:  MOVFF  02,70E
068F2:  MOVFF  01,70D
068F6:  MOVLW  06
068F8:  MOVLB  7
068FA:  ADDWF  x0D,F
068FC:  MOVLW  00
068FE:  ADDWFC x0E,F
06900:  MOVLW  32
06902:  ADDWF  x0D,W
06904:  MOVWF  01
06906:  MOVLW  00
06908:  ADDWFC x0E,W
0690A:  MOVWF  03
0690C:  MOVF   01,W
0690E:  ADDLW  EB
06910:  MOVWF  01
06912:  MOVLW  01
06914:  ADDWFC 03,F
06916:  MOVFF  01,70D
0691A:  MOVFF  03,70E
0691E:  MOVFF  03,734
06922:  MOVFF  01,733
06926:  CLRF   x36
06928:  CLRF   x35
0692A:  MOVLW  0A
0692C:  MOVWF  x37
0692E:  MOVLB  0
06930:  CALL   5D1A
06934:  MOVFF  01,70B
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
06938:  MOVLB  7
0693A:  CLRF   x42
0693C:  MOVFF  690,741
06940:  CLRF   x44
06942:  MOVLW  B5
06944:  MOVWF  x43
06946:  MOVLB  0
06948:  CALL   08B6
0694C:  MOVFF  02,70E
06950:  MOVFF  01,70D
06954:  MOVLW  06
06956:  MOVLB  7
06958:  ADDWF  x0D,F
0695A:  MOVLW  00
0695C:  ADDWFC x0E,F
0695E:  MOVLW  4B
06960:  ADDWF  x0D,W
06962:  MOVWF  01
06964:  MOVLW  00
06966:  ADDWFC x0E,W
06968:  MOVWF  03
0696A:  MOVF   01,W
0696C:  ADDLW  EB
0696E:  MOVWF  01
06970:  MOVLW  01
06972:  ADDWFC 03,F
06974:  MOVFF  01,70D
06978:  MOVFF  03,70E
0697C:  MOVFF  03,742
06980:  MOVFF  01,741
06984:  MOVLB  0
06986:  CALL   5598
0698A:  MOVFF  02,03
0698E:  MOVF   01,W
06990:  SUBLW  01
06992:  BNZ   6998
06994:  MOVF   03,F
06996:  BZ    69A0
06998:  MOVLW  02
0699A:  MOVWF  01
0699C:  BRA    6D3C
0699E:  BRA    69E0
....................    else arg2 = SERcmd[rec].p[3][0];
069A0:  MOVLB  7
069A2:  CLRF   x42
069A4:  MOVFF  690,741
069A8:  CLRF   x44
069AA:  MOVLW  B5
069AC:  MOVWF  x43
069AE:  MOVLB  0
069B0:  CALL   08B6
069B4:  MOVFF  02,70E
069B8:  MOVFF  01,70D
069BC:  MOVLW  06
069BE:  MOVLB  7
069C0:  ADDWF  x0D,F
069C2:  MOVLW  00
069C4:  ADDWFC x0E,F
069C6:  MOVLW  4B
069C8:  ADDWF  x0D,F
069CA:  MOVLW  00
069CC:  ADDWFC x0E,F
069CE:  MOVLW  EB
069D0:  ADDWF  x0D,W
069D2:  MOVWF  FE9
069D4:  MOVLW  01
069D6:  ADDWFC x0E,W
069D8:  MOVWF  FEA
069DA:  MOVFF  FEF,70C
069DE:  MOVLB  0
....................    
....................    /*** GET P, I, D, or A(LL) VALUE **********/
....................    if      ('P' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kP);
069E0:  MOVLB  7
069E2:  MOVF   x0C,W
069E4:  SUBLW  50
069E6:  BNZ   6A82
069E8:  MOVLW  04
069EA:  MOVWF  x42
069EC:  MOVLW  C1
069EE:  MOVWF  x41
069F0:  MOVLB  0
069F2:  CALL   5598
069F6:  MOVFF  02,03
069FA:  MOVF   01,W
069FC:  ADDLW  C1
069FE:  MOVLB  7
06A00:  MOVWF  x0D
06A02:  MOVLW  04
06A04:  ADDWFC 02,W
06A06:  MOVWF  x0E
06A08:  MOVLW  01
06A0A:  SUBWF  x0B,W
06A0C:  MULLW  28
06A0E:  MOVF   FF3,W
06A10:  CLRF   x10
06A12:  MOVWF  x0F
06A14:  MOVLW  20
06A16:  ADDWF  x0F,W
06A18:  MOVWF  FE9
06A1A:  MOVLW  00
06A1C:  ADDWFC x10,W
06A1E:  MOVWF  FEA
06A20:  MOVFF  FEF,711
06A24:  MOVFF  FEC,712
06A28:  MOVFF  FEC,713
06A2C:  MOVFF  FEC,714
06A30:  MOVFF  70E,565
06A34:  MOVFF  70D,564
06A38:  MOVFF  70B,734
06A3C:  MOVLW  18
06A3E:  MOVWF  x35
06A40:  MOVLB  0
06A42:  CALL   606E
06A46:  MOVLW  2C
06A48:  MOVLB  7
06A4A:  MOVWF  x50
06A4C:  MOVLB  0
06A4E:  CALL   55D0
06A52:  MOVLW  89
06A54:  MOVWF  FE9
06A56:  MOVFF  714,746
06A5A:  MOVFF  713,745
06A5E:  MOVFF  712,744
06A62:  MOVFF  711,743
06A66:  MOVLW  02
06A68:  MOVLB  7
06A6A:  MOVWF  x47
06A6C:  MOVLB  0
06A6E:  CALL   576E
06A72:  MOVLW  2C
06A74:  MOVLB  7
06A76:  MOVWF  x50
06A78:  MOVLB  0
06A7A:  CALL   55D0
06A7E:  BRA    6D38
06A80:  MOVLB  7
....................    else if ('I' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kI);
06A82:  MOVF   x0C,W
06A84:  SUBLW  49
06A86:  BNZ   6B2A
06A88:  MOVLW  04
06A8A:  MOVWF  x42
06A8C:  MOVLW  C1
06A8E:  MOVWF  x41
06A90:  MOVLB  0
06A92:  CALL   5598
06A96:  MOVF   01,W
06A98:  ADDLW  C1
06A9A:  MOVLB  7
06A9C:  MOVWF  x0D
06A9E:  MOVLW  04
06AA0:  ADDWFC 02,W
06AA2:  MOVWF  x0E
06AA4:  MOVLW  01
06AA6:  SUBWF  x0B,W
06AA8:  MULLW  28
06AAA:  MOVF   FF3,W
06AAC:  CLRF   x10
06AAE:  MOVWF  x0F
06AB0:  MOVLW  04
06AB2:  ADDWF  x0F,W
06AB4:  MOVWF  01
06AB6:  MOVLW  00
06AB8:  ADDWFC x10,W
06ABA:  MOVWF  03
06ABC:  MOVF   01,W
06ABE:  ADDLW  20
06AC0:  MOVWF  FE9
06AC2:  MOVLW  00
06AC4:  ADDWFC 03,W
06AC6:  MOVWF  FEA
06AC8:  MOVFF  FEF,70F
06ACC:  MOVFF  FEC,710
06AD0:  MOVFF  FEC,711
06AD4:  MOVFF  FEC,712
06AD8:  MOVFF  70E,565
06ADC:  MOVFF  70D,564
06AE0:  MOVFF  70B,734
06AE4:  MOVLW  18
06AE6:  MOVWF  x35
06AE8:  MOVLB  0
06AEA:  CALL   606E
06AEE:  MOVLW  2C
06AF0:  MOVLB  7
06AF2:  MOVWF  x50
06AF4:  MOVLB  0
06AF6:  CALL   55D0
06AFA:  MOVLW  89
06AFC:  MOVWF  FE9
06AFE:  MOVFF  712,746
06B02:  MOVFF  711,745
06B06:  MOVFF  710,744
06B0A:  MOVFF  70F,743
06B0E:  MOVLW  02
06B10:  MOVLB  7
06B12:  MOVWF  x47
06B14:  MOVLB  0
06B16:  CALL   576E
06B1A:  MOVLW  2C
06B1C:  MOVLB  7
06B1E:  MOVWF  x50
06B20:  MOVLB  0
06B22:  CALL   55D0
06B26:  BRA    6D38
06B28:  MOVLB  7
....................    else if ('D' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kD);
06B2A:  MOVF   x0C,W
06B2C:  SUBLW  44
06B2E:  BNZ   6BD2
06B30:  MOVLW  04
06B32:  MOVWF  x42
06B34:  MOVLW  C1
06B36:  MOVWF  x41
06B38:  MOVLB  0
06B3A:  CALL   5598
06B3E:  MOVF   01,W
06B40:  ADDLW  C1
06B42:  MOVLB  7
06B44:  MOVWF  x0D
06B46:  MOVLW  04
06B48:  ADDWFC 02,W
06B4A:  MOVWF  x0E
06B4C:  MOVLW  01
06B4E:  SUBWF  x0B,W
06B50:  MULLW  28
06B52:  MOVF   FF3,W
06B54:  CLRF   x10
06B56:  MOVWF  x0F
06B58:  MOVLW  08
06B5A:  ADDWF  x0F,W
06B5C:  MOVWF  01
06B5E:  MOVLW  00
06B60:  ADDWFC x10,W
06B62:  MOVWF  03
06B64:  MOVF   01,W
06B66:  ADDLW  20
06B68:  MOVWF  FE9
06B6A:  MOVLW  00
06B6C:  ADDWFC 03,W
06B6E:  MOVWF  FEA
06B70:  MOVFF  FEF,70F
06B74:  MOVFF  FEC,710
06B78:  MOVFF  FEC,711
06B7C:  MOVFF  FEC,712
06B80:  MOVFF  70E,565
06B84:  MOVFF  70D,564
06B88:  MOVFF  70B,734
06B8C:  MOVLW  18
06B8E:  MOVWF  x35
06B90:  MOVLB  0
06B92:  CALL   606E
06B96:  MOVLW  2C
06B98:  MOVLB  7
06B9A:  MOVWF  x50
06B9C:  MOVLB  0
06B9E:  CALL   55D0
06BA2:  MOVLW  89
06BA4:  MOVWF  FE9
06BA6:  MOVFF  712,746
06BAA:  MOVFF  711,745
06BAE:  MOVFF  710,744
06BB2:  MOVFF  70F,743
06BB6:  MOVLW  02
06BB8:  MOVLB  7
06BBA:  MOVWF  x47
06BBC:  MOVLB  0
06BBE:  CALL   576E
06BC2:  MOVLW  2C
06BC4:  MOVLB  7
06BC6:  MOVWF  x50
06BC8:  MOVLB  0
06BCA:  CALL   55D0
06BCE:  BRA    6D38
06BD0:  MOVLB  7
....................    else if ('A' == arg2) sprintf(retData+strlen(retData), "%d,%f,%f,%f,", arg1, PID[arg1-1].kP, PID[arg1-1].kI, PID[arg1-1].kD);
06BD2:  MOVF   x0C,W
06BD4:  SUBLW  41
06BD6:  BTFSS  FD8.2
06BD8:  BRA    6D30
06BDA:  MOVLW  04
06BDC:  MOVWF  x42
06BDE:  MOVLW  C1
06BE0:  MOVWF  x41
06BE2:  MOVLB  0
06BE4:  CALL   5598
06BE8:  MOVF   01,W
06BEA:  ADDLW  C1
06BEC:  MOVLB  7
06BEE:  MOVWF  x0D
06BF0:  MOVLW  04
06BF2:  ADDWFC 02,W
06BF4:  MOVWF  x0E
06BF6:  MOVLW  01
06BF8:  SUBWF  x0B,W
06BFA:  MULLW  28
06BFC:  MOVF   FF3,W
06BFE:  CLRF   x10
06C00:  MOVWF  x0F
06C02:  MOVLW  20
06C04:  ADDWF  x0F,W
06C06:  MOVWF  FE9
06C08:  MOVLW  00
06C0A:  ADDWFC x10,W
06C0C:  MOVWF  FEA
06C0E:  MOVFF  FEF,711
06C12:  MOVFF  FEC,712
06C16:  MOVFF  FEC,713
06C1A:  MOVFF  FEC,714
06C1E:  MOVLW  01
06C20:  SUBWF  x0B,W
06C22:  MULLW  28
06C24:  MOVF   FF3,W
06C26:  CLRF   x16
06C28:  MOVWF  x15
06C2A:  MOVLW  04
06C2C:  ADDWF  x15,W
06C2E:  MOVWF  01
06C30:  MOVLW  00
06C32:  ADDWFC x16,W
06C34:  MOVWF  03
06C36:  MOVF   01,W
06C38:  ADDLW  20
06C3A:  MOVWF  FE9
06C3C:  MOVLW  00
06C3E:  ADDWFC 03,W
06C40:  MOVWF  FEA
06C42:  MOVFF  FEF,715
06C46:  MOVFF  FEC,716
06C4A:  MOVFF  FEC,717
06C4E:  MOVFF  FEC,718
06C52:  MOVLW  01
06C54:  SUBWF  x0B,W
06C56:  MULLW  28
06C58:  MOVF   FF3,W
06C5A:  CLRF   x1A
06C5C:  MOVWF  x19
06C5E:  MOVLW  08
06C60:  ADDWF  x19,W
06C62:  MOVWF  01
06C64:  MOVLW  00
06C66:  ADDWFC x1A,W
06C68:  MOVWF  03
06C6A:  MOVF   01,W
06C6C:  ADDLW  20
06C6E:  MOVWF  FE9
06C70:  MOVLW  00
06C72:  ADDWFC 03,W
06C74:  MOVWF  FEA
06C76:  MOVFF  FEF,719
06C7A:  MOVFF  FEC,71A
06C7E:  MOVFF  FEC,71B
06C82:  MOVFF  FEC,71C
06C86:  MOVFF  70E,565
06C8A:  MOVFF  70D,564
06C8E:  MOVFF  70B,734
06C92:  MOVLW  18
06C94:  MOVWF  x35
06C96:  MOVLB  0
06C98:  CALL   606E
06C9C:  MOVLW  2C
06C9E:  MOVLB  7
06CA0:  MOVWF  x50
06CA2:  MOVLB  0
06CA4:  CALL   55D0
06CA8:  MOVLW  89
06CAA:  MOVWF  FE9
06CAC:  MOVFF  714,746
06CB0:  MOVFF  713,745
06CB4:  MOVFF  712,744
06CB8:  MOVFF  711,743
06CBC:  MOVLW  02
06CBE:  MOVLB  7
06CC0:  MOVWF  x47
06CC2:  MOVLB  0
06CC4:  CALL   576E
06CC8:  MOVLW  2C
06CCA:  MOVLB  7
06CCC:  MOVWF  x50
06CCE:  MOVLB  0
06CD0:  CALL   55D0
06CD4:  MOVLW  89
06CD6:  MOVWF  FE9
06CD8:  MOVFF  718,746
06CDC:  MOVFF  717,745
06CE0:  MOVFF  716,744
06CE4:  MOVFF  715,743
06CE8:  MOVLW  02
06CEA:  MOVLB  7
06CEC:  MOVWF  x47
06CEE:  MOVLB  0
06CF0:  CALL   576E
06CF4:  MOVLW  2C
06CF6:  MOVLB  7
06CF8:  MOVWF  x50
06CFA:  MOVLB  0
06CFC:  CALL   55D0
06D00:  MOVLW  89
06D02:  MOVWF  FE9
06D04:  MOVFF  71C,746
06D08:  MOVFF  71B,745
06D0C:  MOVFF  71A,744
06D10:  MOVFF  719,743
06D14:  MOVLW  02
06D16:  MOVLB  7
06D18:  MOVWF  x47
06D1A:  MOVLB  0
06D1C:  CALL   576E
06D20:  MOVLW  2C
06D22:  MOVLB  7
06D24:  MOVWF  x50
06D26:  MOVLB  0
06D28:  CALL   55D0
06D2C:  BRA    6D38
06D2E:  MOVLB  7
....................    else return INV_PARAM;
06D30:  MOVLW  02
06D32:  MOVWF  01
06D34:  MOVLB  0
06D36:  BRA    6D3C
....................    
....................    return SUCCESS;
06D38:  MOVLW  00
06D3A:  MOVWF  01
06D3C:  RETURN 0
.................... }
.................... 
.................... int8 setPIDvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char  arg2;
....................    float arg3;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
0705A:  MOVLB  7
0705C:  CLRF   x42
0705E:  MOVFF  690,741
07062:  CLRF   x44
07064:  MOVLW  B5
07066:  MOVWF  x43
07068:  MOVLB  0
0706A:  CALL   08B6
0706E:  MOVFF  02,712
07072:  MOVFF  01,711
07076:  MOVLW  06
07078:  MOVLB  7
0707A:  ADDWF  x11,F
0707C:  MOVLW  00
0707E:  ADDWFC x12,F
07080:  MOVLW  32
07082:  ADDWF  x11,W
07084:  MOVWF  01
07086:  MOVLW  00
07088:  ADDWFC x12,W
0708A:  MOVWF  03
0708C:  MOVF   01,W
0708E:  ADDLW  EB
07090:  MOVWF  01
07092:  MOVLW  01
07094:  ADDWFC 03,F
07096:  MOVFF  01,711
0709A:  MOVFF  03,712
0709E:  MOVFF  03,734
070A2:  MOVFF  01,733
070A6:  MOVLB  0
070A8:  CALL   5C2A
070AC:  MOVF   01,F
070AE:  BNZ   70B8
070B0:  MOVLW  02
070B2:  MOVWF  01
070B4:  BRA    7338
070B6:  BRA    7116
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
070B8:  MOVLB  7
070BA:  CLRF   x42
070BC:  MOVFF  690,741
070C0:  CLRF   x44
070C2:  MOVLW  B5
070C4:  MOVWF  x43
070C6:  MOVLB  0
070C8:  CALL   08B6
070CC:  MOVFF  02,712
070D0:  MOVFF  01,711
070D4:  MOVLW  06
070D6:  MOVLB  7
070D8:  ADDWF  x11,F
070DA:  MOVLW  00
070DC:  ADDWFC x12,F
070DE:  MOVLW  32
070E0:  ADDWF  x11,W
070E2:  MOVWF  01
070E4:  MOVLW  00
070E6:  ADDWFC x12,W
070E8:  MOVWF  03
070EA:  MOVF   01,W
070EC:  ADDLW  EB
070EE:  MOVWF  01
070F0:  MOVLW  01
070F2:  ADDWFC 03,F
070F4:  MOVFF  01,711
070F8:  MOVFF  03,712
070FC:  MOVFF  03,734
07100:  MOVFF  01,733
07104:  CLRF   x36
07106:  CLRF   x35
07108:  MOVLW  0A
0710A:  MOVWF  x37
0710C:  MOVLB  0
0710E:  CALL   5D1A
07112:  MOVFF  01,70B
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
07116:  MOVLB  7
07118:  CLRF   x42
0711A:  MOVFF  690,741
0711E:  CLRF   x44
07120:  MOVLW  B5
07122:  MOVWF  x43
07124:  MOVLB  0
07126:  CALL   08B6
0712A:  MOVFF  02,712
0712E:  MOVFF  01,711
07132:  MOVLW  06
07134:  MOVLB  7
07136:  ADDWF  x11,F
07138:  MOVLW  00
0713A:  ADDWFC x12,F
0713C:  MOVLW  4B
0713E:  ADDWF  x11,W
07140:  MOVWF  01
07142:  MOVLW  00
07144:  ADDWFC x12,W
07146:  MOVWF  03
07148:  MOVF   01,W
0714A:  ADDLW  EB
0714C:  MOVWF  01
0714E:  MOVLW  01
07150:  ADDWFC 03,F
07152:  MOVFF  01,711
07156:  MOVFF  03,712
0715A:  MOVFF  03,742
0715E:  MOVFF  01,741
07162:  MOVLB  0
07164:  CALL   5598
07168:  MOVFF  02,03
0716C:  MOVF   01,W
0716E:  SUBLW  01
07170:  BNZ   7176
07172:  MOVF   03,F
07174:  BZ    717E
07176:  MOVLW  02
07178:  MOVWF  01
0717A:  BRA    7338
0717C:  BRA    71BE
....................    else arg2 = SERcmd[rec].p[3][0];
0717E:  MOVLB  7
07180:  CLRF   x42
07182:  MOVFF  690,741
07186:  CLRF   x44
07188:  MOVLW  B5
0718A:  MOVWF  x43
0718C:  MOVLB  0
0718E:  CALL   08B6
07192:  MOVFF  02,712
07196:  MOVFF  01,711
0719A:  MOVLW  06
0719C:  MOVLB  7
0719E:  ADDWF  x11,F
071A0:  MOVLW  00
071A2:  ADDWFC x12,F
071A4:  MOVLW  4B
071A6:  ADDWF  x11,F
071A8:  MOVLW  00
071AA:  ADDWFC x12,F
071AC:  MOVLW  EB
071AE:  ADDWF  x11,W
071B0:  MOVWF  FE9
071B2:  MOVLW  01
071B4:  ADDWFC x12,W
071B6:  MOVWF  FEA
071B8:  MOVFF  FEF,70C
071BC:  MOVLB  0
....................    
....................    if (!arg_is_float(SERcmd[rec].p[4])) return INV_PARAM;
071BE:  MOVLB  7
071C0:  CLRF   x42
071C2:  MOVFF  690,741
071C6:  CLRF   x44
071C8:  MOVLW  B5
071CA:  MOVWF  x43
071CC:  MOVLB  0
071CE:  CALL   08B6
071D2:  MOVFF  02,712
071D6:  MOVFF  01,711
071DA:  MOVLW  06
071DC:  MOVLB  7
071DE:  ADDWF  x11,F
071E0:  MOVLW  00
071E2:  ADDWFC x12,F
071E4:  MOVLW  64
071E6:  ADDWF  x11,W
071E8:  MOVWF  01
071EA:  MOVLW  00
071EC:  ADDWFC x12,W
071EE:  MOVWF  03
071F0:  MOVF   01,W
071F2:  ADDLW  EB
071F4:  MOVWF  01
071F6:  MOVLW  01
071F8:  ADDWFC 03,F
071FA:  MOVFF  01,711
071FE:  MOVFF  03,712
07202:  MOVFF  03,715
07206:  MOVFF  01,714
0720A:  MOVLB  0
0720C:  RCALL  6D3E
0720E:  MOVF   01,F
07210:  BNZ   721A
07212:  MOVLW  02
07214:  MOVWF  01
07216:  BRA    7338
07218:  BRA    727E
....................    else arg3 = strtod(SERcmd[rec].p[4], '\0');
0721A:  MOVLB  7
0721C:  CLRF   x42
0721E:  MOVFF  690,741
07222:  CLRF   x44
07224:  MOVLW  B5
07226:  MOVWF  x43
07228:  MOVLB  0
0722A:  CALL   08B6
0722E:  MOVFF  02,712
07232:  MOVFF  01,711
07236:  MOVLW  06
07238:  MOVLB  7
0723A:  ADDWF  x11,F
0723C:  MOVLW  00
0723E:  ADDWFC x12,F
07240:  MOVLW  64
07242:  ADDWF  x11,W
07244:  MOVWF  01
07246:  MOVLW  00
07248:  ADDWFC x12,W
0724A:  MOVWF  03
0724C:  MOVF   01,W
0724E:  ADDLW  EB
07250:  MOVWF  01
07252:  MOVLW  01
07254:  ADDWFC 03,F
07256:  MOVFF  01,711
0725A:  MOVFF  03,712
0725E:  MOVFF  03,715
07262:  MOVFF  01,714
07266:  CLRF   x17
07268:  CLRF   x16
0726A:  MOVLB  0
0726C:  RCALL  6E00
0726E:  MOVFF  03,710
07272:  MOVFF  02,70F
07276:  MOVFF  01,70E
0727A:  MOVFF  00,70D
....................    
....................    /*** SET P, I, or D VALUE **********/
....................    if      ('P' == arg2) PID[arg1-1].kP = arg3;
0727E:  MOVLB  7
07280:  MOVF   x0C,W
07282:  SUBLW  50
07284:  BNZ   72B0
07286:  MOVLW  01
07288:  SUBWF  x0B,W
0728A:  MULLW  28
0728C:  MOVF   FF3,W
0728E:  CLRF   x12
07290:  MOVWF  x11
07292:  MOVLW  20
07294:  ADDWF  x11,W
07296:  MOVWF  FE9
07298:  MOVLW  00
0729A:  ADDWFC x12,W
0729C:  MOVWF  FEA
0729E:  MOVFF  70D,FEF
072A2:  MOVFF  70E,FEC
072A6:  MOVFF  70F,FEC
072AA:  MOVFF  710,FEC
072AE:  BRA    7332
....................    else if ('I' == arg2) PID[arg1-1].kI = arg3;
072B0:  MOVF   x0C,W
072B2:  SUBLW  49
072B4:  BNZ   72EC
072B6:  MOVLW  01
072B8:  SUBWF  x0B,W
072BA:  MULLW  28
072BC:  MOVF   FF3,W
072BE:  CLRF   x12
072C0:  MOVWF  x11
072C2:  MOVLW  04
072C4:  ADDWF  x11,W
072C6:  MOVWF  01
072C8:  MOVLW  00
072CA:  ADDWFC x12,W
072CC:  MOVWF  03
072CE:  MOVF   01,W
072D0:  ADDLW  20
072D2:  MOVWF  FE9
072D4:  MOVLW  00
072D6:  ADDWFC 03,W
072D8:  MOVWF  FEA
072DA:  MOVFF  70D,FEF
072DE:  MOVFF  70E,FEC
072E2:  MOVFF  70F,FEC
072E6:  MOVFF  710,FEC
072EA:  BRA    7332
....................    else if ('D' == arg2) PID[arg1-1].kD = arg3;
072EC:  MOVF   x0C,W
072EE:  SUBLW  44
072F0:  BNZ   7328
072F2:  MOVLW  01
072F4:  SUBWF  x0B,W
072F6:  MULLW  28
072F8:  MOVF   FF3,W
072FA:  CLRF   x12
072FC:  MOVWF  x11
072FE:  MOVLW  08
07300:  ADDWF  x11,W
07302:  MOVWF  01
07304:  MOVLW  00
07306:  ADDWFC x12,W
07308:  MOVWF  03
0730A:  MOVF   01,W
0730C:  ADDLW  20
0730E:  MOVWF  FE9
07310:  MOVLW  00
07312:  ADDWFC 03,W
07314:  MOVWF  FEA
07316:  MOVFF  70D,FEF
0731A:  MOVFF  70E,FEC
0731E:  MOVFF  70F,FEC
07322:  MOVFF  710,FEC
07326:  BRA    7332
....................    else return INV_PARAM;
07328:  MOVLW  02
0732A:  MOVWF  01
0732C:  MOVLB  0
0732E:  BRA    7338
07330:  MOVLB  7
....................    
....................    return SUCCESS;
07332:  MOVLW  00
07334:  MOVWF  01
07336:  MOVLB  0
07338:  RETURN 0
.................... }
.................... 
.................... int8 getSetPoint(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0733A:  MOVLB  7
0733C:  CLRF   x42
0733E:  MOVFF  690,741
07342:  CLRF   x44
07344:  MOVLW  B5
07346:  MOVWF  x43
07348:  MOVLB  0
0734A:  CALL   08B6
0734E:  MOVFF  02,70D
07352:  MOVFF  01,70C
07356:  MOVLW  06
07358:  MOVLB  7
0735A:  ADDWF  x0C,F
0735C:  MOVLW  00
0735E:  ADDWFC x0D,F
07360:  MOVLW  32
07362:  ADDWF  x0C,W
07364:  MOVWF  01
07366:  MOVLW  00
07368:  ADDWFC x0D,W
0736A:  MOVWF  03
0736C:  MOVF   01,W
0736E:  ADDLW  EB
07370:  MOVWF  01
07372:  MOVLW  01
07374:  ADDWFC 03,F
07376:  MOVFF  01,70C
0737A:  MOVFF  03,70D
0737E:  MOVFF  03,734
07382:  MOVFF  01,733
07386:  MOVLB  0
07388:  CALL   5C2A
0738C:  MOVF   01,F
0738E:  BNZ   7398
07390:  MOVLW  02
07392:  MOVWF  01
07394:  BRA    749A
07396:  BRA    73F6
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07398:  MOVLB  7
0739A:  CLRF   x42
0739C:  MOVFF  690,741
073A0:  CLRF   x44
073A2:  MOVLW  B5
073A4:  MOVWF  x43
073A6:  MOVLB  0
073A8:  CALL   08B6
073AC:  MOVFF  02,70D
073B0:  MOVFF  01,70C
073B4:  MOVLW  06
073B6:  MOVLB  7
073B8:  ADDWF  x0C,F
073BA:  MOVLW  00
073BC:  ADDWFC x0D,F
073BE:  MOVLW  32
073C0:  ADDWF  x0C,W
073C2:  MOVWF  01
073C4:  MOVLW  00
073C6:  ADDWFC x0D,W
073C8:  MOVWF  03
073CA:  MOVF   01,W
073CC:  ADDLW  EB
073CE:  MOVWF  01
073D0:  MOVLW  01
073D2:  ADDWFC 03,F
073D4:  MOVFF  01,70C
073D8:  MOVFF  03,70D
073DC:  MOVFF  03,734
073E0:  MOVFF  01,733
073E4:  CLRF   x36
073E6:  CLRF   x35
073E8:  MOVLW  0A
073EA:  MOVWF  x37
073EC:  MOVLB  0
073EE:  CALL   5D1A
073F2:  MOVFF  01,70B
....................    
....................    /*** GET SETPOINT ******************/ 
....................    sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].SP);
073F6:  MOVLW  04
073F8:  MOVLB  7
073FA:  MOVWF  x42
073FC:  MOVLW  C1
073FE:  MOVWF  x41
07400:  MOVLB  0
07402:  CALL   5598
07406:  MOVF   01,W
07408:  ADDLW  C1
0740A:  MOVLB  7
0740C:  MOVWF  x0C
0740E:  MOVLW  04
07410:  ADDWFC 02,W
07412:  MOVWF  x0D
07414:  MOVLW  01
07416:  SUBWF  x0B,W
07418:  MULLW  28
0741A:  MOVF   FF3,W
0741C:  CLRF   x0F
0741E:  MOVWF  x0E
07420:  MOVLW  0C
07422:  ADDWF  x0E,W
07424:  MOVWF  01
07426:  MOVLW  00
07428:  ADDWFC x0F,W
0742A:  MOVWF  03
0742C:  MOVF   01,W
0742E:  ADDLW  20
07430:  MOVWF  FE9
07432:  MOVLW  00
07434:  ADDWFC 03,W
07436:  MOVWF  FEA
07438:  MOVFF  FEF,70E
0743C:  MOVFF  FEC,70F
07440:  MOVFF  FEC,710
07444:  MOVFF  FEC,711
07448:  MOVFF  70D,565
0744C:  MOVFF  70C,564
07450:  MOVFF  70B,734
07454:  MOVLW  18
07456:  MOVWF  x35
07458:  MOVLB  0
0745A:  CALL   606E
0745E:  MOVLW  2C
07460:  MOVLB  7
07462:  MOVWF  x50
07464:  MOVLB  0
07466:  CALL   55D0
0746A:  MOVLW  89
0746C:  MOVWF  FE9
0746E:  MOVFF  711,746
07472:  MOVFF  710,745
07476:  MOVFF  70F,744
0747A:  MOVFF  70E,743
0747E:  MOVLW  02
07480:  MOVLB  7
07482:  MOVWF  x47
07484:  MOVLB  0
07486:  CALL   576E
0748A:  MOVLW  2C
0748C:  MOVLB  7
0748E:  MOVWF  x50
07490:  MOVLB  0
07492:  CALL   55D0
....................    return SUCCESS;
07496:  MOVLW  00
07498:  MOVWF  01
0749A:  RETURN 0
.................... }
.................... 
.................... int8 setSetPoint(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/   
....................    int8  arg1;
....................    float arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0749C:  MOVLB  7
0749E:  CLRF   x42
074A0:  MOVFF  690,741
074A4:  CLRF   x44
074A6:  MOVLW  B5
074A8:  MOVWF  x43
074AA:  MOVLB  0
074AC:  CALL   08B6
074B0:  MOVFF  02,711
074B4:  MOVFF  01,710
074B8:  MOVLW  06
074BA:  MOVLB  7
074BC:  ADDWF  x10,F
074BE:  MOVLW  00
074C0:  ADDWFC x11,F
074C2:  MOVLW  32
074C4:  ADDWF  x10,W
074C6:  MOVWF  01
074C8:  MOVLW  00
074CA:  ADDWFC x11,W
074CC:  MOVWF  03
074CE:  MOVF   01,W
074D0:  ADDLW  EB
074D2:  MOVWF  01
074D4:  MOVLW  01
074D6:  ADDWFC 03,F
074D8:  MOVFF  01,710
074DC:  MOVFF  03,711
074E0:  MOVFF  03,734
074E4:  MOVFF  01,733
074E8:  MOVLB  0
074EA:  CALL   5C2A
074EE:  MOVF   01,F
074F0:  BNZ   74FA
074F2:  MOVLW  02
074F4:  MOVWF  01
074F6:  BRA    7658
074F8:  BRA    7558
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
074FA:  MOVLB  7
074FC:  CLRF   x42
074FE:  MOVFF  690,741
07502:  CLRF   x44
07504:  MOVLW  B5
07506:  MOVWF  x43
07508:  MOVLB  0
0750A:  CALL   08B6
0750E:  MOVFF  02,711
07512:  MOVFF  01,710
07516:  MOVLW  06
07518:  MOVLB  7
0751A:  ADDWF  x10,F
0751C:  MOVLW  00
0751E:  ADDWFC x11,F
07520:  MOVLW  32
07522:  ADDWF  x10,W
07524:  MOVWF  01
07526:  MOVLW  00
07528:  ADDWFC x11,W
0752A:  MOVWF  03
0752C:  MOVF   01,W
0752E:  ADDLW  EB
07530:  MOVWF  01
07532:  MOVLW  01
07534:  ADDWFC 03,F
07536:  MOVFF  01,710
0753A:  MOVFF  03,711
0753E:  MOVFF  03,734
07542:  MOVFF  01,733
07546:  CLRF   x36
07548:  CLRF   x35
0754A:  MOVLW  0A
0754C:  MOVWF  x37
0754E:  MOVLB  0
07550:  CALL   5D1A
07554:  MOVFF  01,70B
....................    
....................    if (!arg_is_float(SERcmd[rec].p[3])) return INV_PARAM;
07558:  MOVLB  7
0755A:  CLRF   x42
0755C:  MOVFF  690,741
07560:  CLRF   x44
07562:  MOVLW  B5
07564:  MOVWF  x43
07566:  MOVLB  0
07568:  CALL   08B6
0756C:  MOVFF  02,711
07570:  MOVFF  01,710
07574:  MOVLW  06
07576:  MOVLB  7
07578:  ADDWF  x10,F
0757A:  MOVLW  00
0757C:  ADDWFC x11,F
0757E:  MOVLW  4B
07580:  ADDWF  x10,W
07582:  MOVWF  01
07584:  MOVLW  00
07586:  ADDWFC x11,W
07588:  MOVWF  03
0758A:  MOVF   01,W
0758C:  ADDLW  EB
0758E:  MOVWF  01
07590:  MOVLW  01
07592:  ADDWFC 03,F
07594:  MOVFF  01,710
07598:  MOVFF  03,711
0759C:  MOVFF  03,715
075A0:  MOVFF  01,714
075A4:  MOVLB  0
075A6:  CALL   6D3E
075AA:  MOVF   01,F
075AC:  BNZ   75B6
075AE:  MOVLW  02
075B0:  MOVWF  01
075B2:  BRA    7658
075B4:  BRA    761C
....................    else arg2 = strtod(SERcmd[rec].p[3], '\0');
075B6:  MOVLB  7
075B8:  CLRF   x42
075BA:  MOVFF  690,741
075BE:  CLRF   x44
075C0:  MOVLW  B5
075C2:  MOVWF  x43
075C4:  MOVLB  0
075C6:  CALL   08B6
075CA:  MOVFF  02,711
075CE:  MOVFF  01,710
075D2:  MOVLW  06
075D4:  MOVLB  7
075D6:  ADDWF  x10,F
075D8:  MOVLW  00
075DA:  ADDWFC x11,F
075DC:  MOVLW  4B
075DE:  ADDWF  x10,W
075E0:  MOVWF  01
075E2:  MOVLW  00
075E4:  ADDWFC x11,W
075E6:  MOVWF  03
075E8:  MOVF   01,W
075EA:  ADDLW  EB
075EC:  MOVWF  01
075EE:  MOVLW  01
075F0:  ADDWFC 03,F
075F2:  MOVFF  01,710
075F6:  MOVFF  03,711
075FA:  MOVFF  03,715
075FE:  MOVFF  01,714
07602:  CLRF   x17
07604:  CLRF   x16
07606:  MOVLB  0
07608:  CALL   6E00
0760C:  MOVFF  03,70F
07610:  MOVFF  02,70E
07614:  MOVFF  01,70D
07618:  MOVFF  00,70C
....................    
....................    /*** SET SETPOINT ******************/ 
....................    PID[arg1-1].SP = arg2;
0761C:  MOVLW  01
0761E:  MOVLB  7
07620:  SUBWF  x0B,W
07622:  MULLW  28
07624:  MOVF   FF3,W
07626:  CLRF   x11
07628:  MOVWF  x10
0762A:  MOVLW  0C
0762C:  ADDWF  x10,W
0762E:  MOVWF  01
07630:  MOVLW  00
07632:  ADDWFC x11,W
07634:  MOVWF  03
07636:  MOVF   01,W
07638:  ADDLW  20
0763A:  MOVWF  FE9
0763C:  MOVLW  00
0763E:  ADDWFC 03,W
07640:  MOVWF  FEA
07642:  MOVFF  70C,FEF
07646:  MOVFF  70D,FEC
0764A:  MOVFF  70E,FEC
0764E:  MOVFF  70F,FEC
....................    
....................    return SUCCESS;
07652:  MOVLW  00
07654:  MOVWF  01
07656:  MOVLB  0
07658:  RETURN 0
.................... }
.................... 
.................... int8 getAllSensorCalParams(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0765A:  MOVLB  7
0765C:  CLRF   x42
0765E:  MOVFF  690,741
07662:  CLRF   x44
07664:  MOVLW  B5
07666:  MOVWF  x43
07668:  MOVLB  0
0766A:  CALL   08B6
0766E:  MOVFF  02,70D
07672:  MOVFF  01,70C
07676:  MOVLW  06
07678:  MOVLB  7
0767A:  ADDWF  x0C,F
0767C:  MOVLW  00
0767E:  ADDWFC x0D,F
07680:  MOVLW  32
07682:  ADDWF  x0C,W
07684:  MOVWF  01
07686:  MOVLW  00
07688:  ADDWFC x0D,W
0768A:  MOVWF  03
0768C:  MOVF   01,W
0768E:  ADDLW  EB
07690:  MOVWF  01
07692:  MOVLW  01
07694:  ADDWFC 03,F
07696:  MOVFF  01,70C
0769A:  MOVFF  03,70D
0769E:  MOVFF  03,734
076A2:  MOVFF  01,733
076A6:  MOVLB  0
076A8:  CALL   5C2A
076AC:  MOVF   01,F
076AE:  BNZ   76B8
076B0:  MOVLW  02
076B2:  MOVWF  01
076B4:  BRA    7A0E
076B6:  BRA    7716
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
076B8:  MOVLB  7
076BA:  CLRF   x42
076BC:  MOVFF  690,741
076C0:  CLRF   x44
076C2:  MOVLW  B5
076C4:  MOVWF  x43
076C6:  MOVLB  0
076C8:  CALL   08B6
076CC:  MOVFF  02,70D
076D0:  MOVFF  01,70C
076D4:  MOVLW  06
076D6:  MOVLB  7
076D8:  ADDWF  x0C,F
076DA:  MOVLW  00
076DC:  ADDWFC x0D,F
076DE:  MOVLW  32
076E0:  ADDWF  x0C,W
076E2:  MOVWF  01
076E4:  MOVLW  00
076E6:  ADDWFC x0D,W
076E8:  MOVWF  03
076EA:  MOVF   01,W
076EC:  ADDLW  EB
076EE:  MOVWF  01
076F0:  MOVLW  01
076F2:  ADDWFC 03,F
076F4:  MOVFF  01,70C
076F8:  MOVFF  03,70D
076FC:  MOVFF  03,734
07700:  MOVFF  01,733
07704:  CLRF   x36
07706:  CLRF   x35
07708:  MOVLW  0A
0770A:  MOVWF  x37
0770C:  MOVLB  0
0770E:  CALL   5D1A
07712:  MOVFF  01,70B
....................    
....................    /*** GET ALL SENSOR CAL PARAMS *****/
....................    sprintf(retData+strlen(retData), "%d,", arg1);
07716:  MOVLW  04
07718:  MOVLB  7
0771A:  MOVWF  x42
0771C:  MOVLW  C1
0771E:  MOVWF  x41
07720:  MOVLB  0
07722:  CALL   5598
07726:  MOVFF  02,03
0772A:  MOVF   01,W
0772C:  ADDLW  C1
0772E:  MOVLB  7
07730:  MOVWF  x0C
07732:  MOVLW  04
07734:  ADDWFC 02,W
07736:  MOVWF  x0D
07738:  MOVFF  FE8,565
0773C:  MOVFF  70C,564
07740:  MOVFF  70B,734
07744:  MOVLW  18
07746:  MOVWF  x35
07748:  MOVLB  0
0774A:  CALL   606E
0774E:  MOVLW  2C
07750:  MOVLB  7
07752:  MOVWF  x50
07754:  MOVLB  0
07756:  CALL   55D0
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c0);
0775A:  MOVLW  04
0775C:  MOVLB  7
0775E:  MOVWF  x42
07760:  MOVLW  C1
07762:  MOVWF  x41
07764:  MOVLB  0
07766:  CALL   5598
0776A:  MOVFF  02,03
0776E:  MOVF   01,W
07770:  ADDLW  C1
07772:  MOVLB  7
07774:  MOVWF  x0C
07776:  MOVLW  04
07778:  ADDWFC 02,W
0777A:  MOVWF  x0D
0777C:  MOVLW  01
0777E:  SUBWF  x0B,W
07780:  MULLW  18
07782:  MOVF   FF3,W
07784:  CLRF   x0F
07786:  MOVWF  x0E
07788:  MOVLW  92
0778A:  ADDWF  x0E,W
0778C:  MOVWF  FE9
0778E:  MOVLW  00
07790:  ADDWFC x0F,W
07792:  MOVWF  FEA
07794:  MOVFF  FEF,743
07798:  MOVFF  FEC,744
0779C:  MOVFF  FEC,745
077A0:  MOVFF  FEC,746
077A4:  MOVFF  70D,565
077A8:  MOVFF  70C,564
077AC:  MOVLW  89
077AE:  MOVWF  FE9
077B0:  MOVLW  02
077B2:  MOVWF  x47
077B4:  MOVLB  0
077B6:  CALL   576E
077BA:  MOVLW  2C
077BC:  MOVLB  7
077BE:  MOVWF  x50
077C0:  MOVLB  0
077C2:  CALL   55D0
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c1);
077C6:  MOVLW  04
077C8:  MOVLB  7
077CA:  MOVWF  x42
077CC:  MOVLW  C1
077CE:  MOVWF  x41
077D0:  MOVLB  0
077D2:  CALL   5598
077D6:  MOVF   01,W
077D8:  ADDLW  C1
077DA:  MOVLB  7
077DC:  MOVWF  x0C
077DE:  MOVLW  04
077E0:  ADDWFC 02,W
077E2:  MOVWF  x0D
077E4:  MOVLW  01
077E6:  SUBWF  x0B,W
077E8:  MULLW  18
077EA:  MOVF   FF3,W
077EC:  CLRF   x0F
077EE:  MOVWF  x0E
077F0:  MOVLW  04
077F2:  ADDWF  x0E,W
077F4:  MOVWF  01
077F6:  MOVLW  00
077F8:  ADDWFC x0F,W
077FA:  MOVWF  03
077FC:  MOVF   01,W
077FE:  ADDLW  92
07800:  MOVWF  FE9
07802:  MOVLW  00
07804:  ADDWFC 03,W
07806:  MOVWF  FEA
07808:  MOVFF  FEF,743
0780C:  MOVFF  FEC,744
07810:  MOVFF  FEC,745
07814:  MOVFF  FEC,746
07818:  MOVFF  70D,565
0781C:  MOVFF  70C,564
07820:  MOVLW  89
07822:  MOVWF  FE9
07824:  MOVLW  02
07826:  MOVWF  x47
07828:  MOVLB  0
0782A:  CALL   576E
0782E:  MOVLW  2C
07830:  MOVLB  7
07832:  MOVWF  x50
07834:  MOVLB  0
07836:  CALL   55D0
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c2);
0783A:  MOVLW  04
0783C:  MOVLB  7
0783E:  MOVWF  x42
07840:  MOVLW  C1
07842:  MOVWF  x41
07844:  MOVLB  0
07846:  CALL   5598
0784A:  MOVF   01,W
0784C:  ADDLW  C1
0784E:  MOVLB  7
07850:  MOVWF  x0C
07852:  MOVLW  04
07854:  ADDWFC 02,W
07856:  MOVWF  x0D
07858:  MOVLW  01
0785A:  SUBWF  x0B,W
0785C:  MULLW  18
0785E:  MOVF   FF3,W
07860:  CLRF   x0F
07862:  MOVWF  x0E
07864:  MOVLW  08
07866:  ADDWF  x0E,W
07868:  MOVWF  01
0786A:  MOVLW  00
0786C:  ADDWFC x0F,W
0786E:  MOVWF  03
07870:  MOVF   01,W
07872:  ADDLW  92
07874:  MOVWF  FE9
07876:  MOVLW  00
07878:  ADDWFC 03,W
0787A:  MOVWF  FEA
0787C:  MOVFF  FEF,743
07880:  MOVFF  FEC,744
07884:  MOVFF  FEC,745
07888:  MOVFF  FEC,746
0788C:  MOVFF  70D,565
07890:  MOVFF  70C,564
07894:  MOVLW  89
07896:  MOVWF  FE9
07898:  MOVLW  02
0789A:  MOVWF  x47
0789C:  MOVLB  0
0789E:  CALL   576E
078A2:  MOVLW  2C
078A4:  MOVLB  7
078A6:  MOVWF  x50
078A8:  MOVLB  0
078AA:  CALL   55D0
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c3);
078AE:  MOVLW  04
078B0:  MOVLB  7
078B2:  MOVWF  x42
078B4:  MOVLW  C1
078B6:  MOVWF  x41
078B8:  MOVLB  0
078BA:  CALL   5598
078BE:  MOVF   01,W
078C0:  ADDLW  C1
078C2:  MOVLB  7
078C4:  MOVWF  x0C
078C6:  MOVLW  04
078C8:  ADDWFC 02,W
078CA:  MOVWF  x0D
078CC:  MOVLW  01
078CE:  SUBWF  x0B,W
078D0:  MULLW  18
078D2:  MOVF   FF3,W
078D4:  CLRF   x0F
078D6:  MOVWF  x0E
078D8:  MOVLW  0C
078DA:  ADDWF  x0E,W
078DC:  MOVWF  01
078DE:  MOVLW  00
078E0:  ADDWFC x0F,W
078E2:  MOVWF  03
078E4:  MOVF   01,W
078E6:  ADDLW  92
078E8:  MOVWF  FE9
078EA:  MOVLW  00
078EC:  ADDWFC 03,W
078EE:  MOVWF  FEA
078F0:  MOVFF  FEF,743
078F4:  MOVFF  FEC,744
078F8:  MOVFF  FEC,745
078FC:  MOVFF  FEC,746
07900:  MOVFF  70D,565
07904:  MOVFF  70C,564
07908:  MOVLW  89
0790A:  MOVWF  FE9
0790C:  MOVLW  02
0790E:  MOVWF  x47
07910:  MOVLB  0
07912:  CALL   576E
07916:  MOVLW  2C
07918:  MOVLB  7
0791A:  MOVWF  x50
0791C:  MOVLB  0
0791E:  CALL   55D0
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c4);
07922:  MOVLW  04
07924:  MOVLB  7
07926:  MOVWF  x42
07928:  MOVLW  C1
0792A:  MOVWF  x41
0792C:  MOVLB  0
0792E:  CALL   5598
07932:  MOVF   01,W
07934:  ADDLW  C1
07936:  MOVLB  7
07938:  MOVWF  x0C
0793A:  MOVLW  04
0793C:  ADDWFC 02,W
0793E:  MOVWF  x0D
07940:  MOVLW  01
07942:  SUBWF  x0B,W
07944:  MULLW  18
07946:  MOVF   FF3,W
07948:  CLRF   x0F
0794A:  MOVWF  x0E
0794C:  MOVLW  10
0794E:  ADDWF  x0E,W
07950:  MOVWF  01
07952:  MOVLW  00
07954:  ADDWFC x0F,W
07956:  MOVWF  03
07958:  MOVF   01,W
0795A:  ADDLW  92
0795C:  MOVWF  FE9
0795E:  MOVLW  00
07960:  ADDWFC 03,W
07962:  MOVWF  FEA
07964:  MOVFF  FEF,743
07968:  MOVFF  FEC,744
0796C:  MOVFF  FEC,745
07970:  MOVFF  FEC,746
07974:  MOVFF  70D,565
07978:  MOVFF  70C,564
0797C:  MOVLW  89
0797E:  MOVWF  FE9
07980:  MOVLW  02
07982:  MOVWF  x47
07984:  MOVLB  0
07986:  CALL   576E
0798A:  MOVLW  2C
0798C:  MOVLB  7
0798E:  MOVWF  x50
07990:  MOVLB  0
07992:  CALL   55D0
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c5);
07996:  MOVLW  04
07998:  MOVLB  7
0799A:  MOVWF  x42
0799C:  MOVLW  C1
0799E:  MOVWF  x41
079A0:  MOVLB  0
079A2:  CALL   5598
079A6:  MOVF   01,W
079A8:  ADDLW  C1
079AA:  MOVLB  7
079AC:  MOVWF  x0C
079AE:  MOVLW  04
079B0:  ADDWFC 02,W
079B2:  MOVWF  x0D
079B4:  MOVLW  01
079B6:  SUBWF  x0B,W
079B8:  MULLW  18
079BA:  MOVF   FF3,W
079BC:  CLRF   x0F
079BE:  MOVWF  x0E
079C0:  MOVLW  14
079C2:  ADDWF  x0E,W
079C4:  MOVWF  01
079C6:  MOVLW  00
079C8:  ADDWFC x0F,W
079CA:  MOVWF  03
079CC:  MOVF   01,W
079CE:  ADDLW  92
079D0:  MOVWF  FE9
079D2:  MOVLW  00
079D4:  ADDWFC 03,W
079D6:  MOVWF  FEA
079D8:  MOVFF  FEF,743
079DC:  MOVFF  FEC,744
079E0:  MOVFF  FEC,745
079E4:  MOVFF  FEC,746
079E8:  MOVFF  70D,565
079EC:  MOVFF  70C,564
079F0:  MOVLW  89
079F2:  MOVWF  FE9
079F4:  MOVLW  02
079F6:  MOVWF  x47
079F8:  MOVLB  0
079FA:  CALL   576E
079FE:  MOVLW  2C
07A00:  MOVLB  7
07A02:  MOVWF  x50
07A04:  MOVLB  0
07A06:  CALL   55D0
....................    
....................    return SUCCESS;
07A0A:  MOVLW  00
07A0C:  MOVWF  01
07A0E:  RETURN 0
.................... }
.................... 
.................... int8 getSensorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
07A10:  MOVLB  7
07A12:  CLRF   x42
07A14:  MOVFF  690,741
07A18:  CLRF   x44
07A1A:  MOVLW  B5
07A1C:  MOVWF  x43
07A1E:  MOVLB  0
07A20:  CALL   08B6
07A24:  MOVFF  02,70E
07A28:  MOVFF  01,70D
07A2C:  MOVLW  06
07A2E:  MOVLB  7
07A30:  ADDWF  x0D,F
07A32:  MOVLW  00
07A34:  ADDWFC x0E,F
07A36:  MOVLW  32
07A38:  ADDWF  x0D,W
07A3A:  MOVWF  01
07A3C:  MOVLW  00
07A3E:  ADDWFC x0E,W
07A40:  MOVWF  03
07A42:  MOVF   01,W
07A44:  ADDLW  EB
07A46:  MOVWF  01
07A48:  MOVLW  01
07A4A:  ADDWFC 03,F
07A4C:  MOVFF  01,70D
07A50:  MOVFF  03,70E
07A54:  MOVFF  03,734
07A58:  MOVFF  01,733
07A5C:  MOVLB  0
07A5E:  CALL   5C2A
07A62:  MOVF   01,F
07A64:  BNZ   7A6E
07A66:  MOVLW  02
07A68:  MOVWF  01
07A6A:  BRA    7F6A
07A6C:  BRA    7ACC
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07A6E:  MOVLB  7
07A70:  CLRF   x42
07A72:  MOVFF  690,741
07A76:  CLRF   x44
07A78:  MOVLW  B5
07A7A:  MOVWF  x43
07A7C:  MOVLB  0
07A7E:  CALL   08B6
07A82:  MOVFF  02,70E
07A86:  MOVFF  01,70D
07A8A:  MOVLW  06
07A8C:  MOVLB  7
07A8E:  ADDWF  x0D,F
07A90:  MOVLW  00
07A92:  ADDWFC x0E,F
07A94:  MOVLW  32
07A96:  ADDWF  x0D,W
07A98:  MOVWF  01
07A9A:  MOVLW  00
07A9C:  ADDWFC x0E,W
07A9E:  MOVWF  03
07AA0:  MOVF   01,W
07AA2:  ADDLW  EB
07AA4:  MOVWF  01
07AA6:  MOVLW  01
07AA8:  ADDWFC 03,F
07AAA:  MOVFF  01,70D
07AAE:  MOVFF  03,70E
07AB2:  MOVFF  03,734
07AB6:  MOVFF  01,733
07ABA:  CLRF   x36
07ABC:  CLRF   x35
07ABE:  MOVLW  0A
07AC0:  MOVWF  x37
07AC2:  MOVLB  0
07AC4:  CALL   5D1A
07AC8:  MOVFF  01,70B
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
07ACC:  MOVLB  7
07ACE:  CLRF   x42
07AD0:  MOVFF  690,741
07AD4:  CLRF   x44
07AD6:  MOVLW  B5
07AD8:  MOVWF  x43
07ADA:  MOVLB  0
07ADC:  CALL   08B6
07AE0:  MOVFF  02,70E
07AE4:  MOVFF  01,70D
07AE8:  MOVLW  06
07AEA:  MOVLB  7
07AEC:  ADDWF  x0D,F
07AEE:  MOVLW  00
07AF0:  ADDWFC x0E,F
07AF2:  MOVLW  4B
07AF4:  ADDWF  x0D,W
07AF6:  MOVWF  01
07AF8:  MOVLW  00
07AFA:  ADDWFC x0E,W
07AFC:  MOVWF  03
07AFE:  MOVF   01,W
07B00:  ADDLW  EB
07B02:  MOVWF  01
07B04:  MOVLW  01
07B06:  ADDWFC 03,F
07B08:  MOVFF  01,70D
07B0C:  MOVFF  03,70E
07B10:  MOVFF  03,742
07B14:  MOVFF  01,741
07B18:  MOVLB  0
07B1A:  CALL   5598
07B1E:  MOVFF  02,03
07B22:  MOVF   01,W
07B24:  SUBLW  01
07B26:  BNZ   7B2C
07B28:  MOVF   03,F
07B2A:  BZ    7B34
07B2C:  MOVLW  02
07B2E:  MOVWF  01
07B30:  BRA    7F6A
07B32:  BRA    7B74
....................    else arg2 = SERcmd[rec].p[3][0];
07B34:  MOVLB  7
07B36:  CLRF   x42
07B38:  MOVFF  690,741
07B3C:  CLRF   x44
07B3E:  MOVLW  B5
07B40:  MOVWF  x43
07B42:  MOVLB  0
07B44:  CALL   08B6
07B48:  MOVFF  02,70E
07B4C:  MOVFF  01,70D
07B50:  MOVLW  06
07B52:  MOVLB  7
07B54:  ADDWF  x0D,F
07B56:  MOVLW  00
07B58:  ADDWFC x0E,F
07B5A:  MOVLW  4B
07B5C:  ADDWF  x0D,F
07B5E:  MOVLW  00
07B60:  ADDWFC x0E,F
07B62:  MOVLW  EB
07B64:  ADDWF  x0D,W
07B66:  MOVWF  FE9
07B68:  MOVLW  01
07B6A:  ADDWFC x0E,W
07B6C:  MOVWF  FEA
07B6E:  MOVFF  FEF,70C
07B72:  MOVLB  0
....................    
....................    /*** GET SENSOR CAL PARAM **********/
....................    if      ('0' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c0);
07B74:  MOVLB  7
07B76:  MOVF   x0C,W
07B78:  SUBLW  30
07B7A:  BNZ   7C16
07B7C:  MOVLW  04
07B7E:  MOVWF  x42
07B80:  MOVLW  C1
07B82:  MOVWF  x41
07B84:  MOVLB  0
07B86:  CALL   5598
07B8A:  MOVFF  02,03
07B8E:  MOVF   01,W
07B90:  ADDLW  C1
07B92:  MOVLB  7
07B94:  MOVWF  x0D
07B96:  MOVLW  04
07B98:  ADDWFC 02,W
07B9A:  MOVWF  x0E
07B9C:  MOVLW  01
07B9E:  SUBWF  x0B,W
07BA0:  MULLW  18
07BA2:  MOVF   FF3,W
07BA4:  CLRF   x10
07BA6:  MOVWF  x0F
07BA8:  MOVLW  92
07BAA:  ADDWF  x0F,W
07BAC:  MOVWF  FE9
07BAE:  MOVLW  00
07BB0:  ADDWFC x10,W
07BB2:  MOVWF  FEA
07BB4:  MOVFF  FEF,711
07BB8:  MOVFF  FEC,712
07BBC:  MOVFF  FEC,713
07BC0:  MOVFF  FEC,714
07BC4:  MOVFF  70E,565
07BC8:  MOVFF  70D,564
07BCC:  MOVFF  70B,734
07BD0:  MOVLW  18
07BD2:  MOVWF  x35
07BD4:  MOVLB  0
07BD6:  CALL   606E
07BDA:  MOVLW  2C
07BDC:  MOVLB  7
07BDE:  MOVWF  x50
07BE0:  MOVLB  0
07BE2:  CALL   55D0
07BE6:  MOVLW  89
07BE8:  MOVWF  FE9
07BEA:  MOVFF  714,746
07BEE:  MOVFF  713,745
07BF2:  MOVFF  712,744
07BF6:  MOVFF  711,743
07BFA:  MOVLW  02
07BFC:  MOVLB  7
07BFE:  MOVWF  x47
07C00:  MOVLB  0
07C02:  CALL   576E
07C06:  MOVLW  2C
07C08:  MOVLB  7
07C0A:  MOVWF  x50
07C0C:  MOVLB  0
07C0E:  CALL   55D0
07C12:  BRA    7F66
07C14:  MOVLB  7
....................    else if ('1' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c1);
07C16:  MOVF   x0C,W
07C18:  SUBLW  31
07C1A:  BNZ   7CBE
07C1C:  MOVLW  04
07C1E:  MOVWF  x42
07C20:  MOVLW  C1
07C22:  MOVWF  x41
07C24:  MOVLB  0
07C26:  CALL   5598
07C2A:  MOVF   01,W
07C2C:  ADDLW  C1
07C2E:  MOVLB  7
07C30:  MOVWF  x0D
07C32:  MOVLW  04
07C34:  ADDWFC 02,W
07C36:  MOVWF  x0E
07C38:  MOVLW  01
07C3A:  SUBWF  x0B,W
07C3C:  MULLW  18
07C3E:  MOVF   FF3,W
07C40:  CLRF   x10
07C42:  MOVWF  x0F
07C44:  MOVLW  04
07C46:  ADDWF  x0F,W
07C48:  MOVWF  01
07C4A:  MOVLW  00
07C4C:  ADDWFC x10,W
07C4E:  MOVWF  03
07C50:  MOVF   01,W
07C52:  ADDLW  92
07C54:  MOVWF  FE9
07C56:  MOVLW  00
07C58:  ADDWFC 03,W
07C5A:  MOVWF  FEA
07C5C:  MOVFF  FEF,70F
07C60:  MOVFF  FEC,710
07C64:  MOVFF  FEC,711
07C68:  MOVFF  FEC,712
07C6C:  MOVFF  70E,565
07C70:  MOVFF  70D,564
07C74:  MOVFF  70B,734
07C78:  MOVLW  18
07C7A:  MOVWF  x35
07C7C:  MOVLB  0
07C7E:  CALL   606E
07C82:  MOVLW  2C
07C84:  MOVLB  7
07C86:  MOVWF  x50
07C88:  MOVLB  0
07C8A:  CALL   55D0
07C8E:  MOVLW  89
07C90:  MOVWF  FE9
07C92:  MOVFF  712,746
07C96:  MOVFF  711,745
07C9A:  MOVFF  710,744
07C9E:  MOVFF  70F,743
07CA2:  MOVLW  02
07CA4:  MOVLB  7
07CA6:  MOVWF  x47
07CA8:  MOVLB  0
07CAA:  CALL   576E
07CAE:  MOVLW  2C
07CB0:  MOVLB  7
07CB2:  MOVWF  x50
07CB4:  MOVLB  0
07CB6:  CALL   55D0
07CBA:  BRA    7F66
07CBC:  MOVLB  7
....................    else if ('2' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c2);
07CBE:  MOVF   x0C,W
07CC0:  SUBLW  32
07CC2:  BNZ   7D66
07CC4:  MOVLW  04
07CC6:  MOVWF  x42
07CC8:  MOVLW  C1
07CCA:  MOVWF  x41
07CCC:  MOVLB  0
07CCE:  CALL   5598
07CD2:  MOVF   01,W
07CD4:  ADDLW  C1
07CD6:  MOVLB  7
07CD8:  MOVWF  x0D
07CDA:  MOVLW  04
07CDC:  ADDWFC 02,W
07CDE:  MOVWF  x0E
07CE0:  MOVLW  01
07CE2:  SUBWF  x0B,W
07CE4:  MULLW  18
07CE6:  MOVF   FF3,W
07CE8:  CLRF   x10
07CEA:  MOVWF  x0F
07CEC:  MOVLW  08
07CEE:  ADDWF  x0F,W
07CF0:  MOVWF  01
07CF2:  MOVLW  00
07CF4:  ADDWFC x10,W
07CF6:  MOVWF  03
07CF8:  MOVF   01,W
07CFA:  ADDLW  92
07CFC:  MOVWF  FE9
07CFE:  MOVLW  00
07D00:  ADDWFC 03,W
07D02:  MOVWF  FEA
07D04:  MOVFF  FEF,70F
07D08:  MOVFF  FEC,710
07D0C:  MOVFF  FEC,711
07D10:  MOVFF  FEC,712
07D14:  MOVFF  70E,565
07D18:  MOVFF  70D,564
07D1C:  MOVFF  70B,734
07D20:  MOVLW  18
07D22:  MOVWF  x35
07D24:  MOVLB  0
07D26:  CALL   606E
07D2A:  MOVLW  2C
07D2C:  MOVLB  7
07D2E:  MOVWF  x50
07D30:  MOVLB  0
07D32:  CALL   55D0
07D36:  MOVLW  89
07D38:  MOVWF  FE9
07D3A:  MOVFF  712,746
07D3E:  MOVFF  711,745
07D42:  MOVFF  710,744
07D46:  MOVFF  70F,743
07D4A:  MOVLW  02
07D4C:  MOVLB  7
07D4E:  MOVWF  x47
07D50:  MOVLB  0
07D52:  CALL   576E
07D56:  MOVLW  2C
07D58:  MOVLB  7
07D5A:  MOVWF  x50
07D5C:  MOVLB  0
07D5E:  CALL   55D0
07D62:  BRA    7F66
07D64:  MOVLB  7
....................    else if ('3' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c3);
07D66:  MOVF   x0C,W
07D68:  SUBLW  33
07D6A:  BNZ   7E0E
07D6C:  MOVLW  04
07D6E:  MOVWF  x42
07D70:  MOVLW  C1
07D72:  MOVWF  x41
07D74:  MOVLB  0
07D76:  CALL   5598
07D7A:  MOVF   01,W
07D7C:  ADDLW  C1
07D7E:  MOVLB  7
07D80:  MOVWF  x0D
07D82:  MOVLW  04
07D84:  ADDWFC 02,W
07D86:  MOVWF  x0E
07D88:  MOVLW  01
07D8A:  SUBWF  x0B,W
07D8C:  MULLW  18
07D8E:  MOVF   FF3,W
07D90:  CLRF   x10
07D92:  MOVWF  x0F
07D94:  MOVLW  0C
07D96:  ADDWF  x0F,W
07D98:  MOVWF  01
07D9A:  MOVLW  00
07D9C:  ADDWFC x10,W
07D9E:  MOVWF  03
07DA0:  MOVF   01,W
07DA2:  ADDLW  92
07DA4:  MOVWF  FE9
07DA6:  MOVLW  00
07DA8:  ADDWFC 03,W
07DAA:  MOVWF  FEA
07DAC:  MOVFF  FEF,70F
07DB0:  MOVFF  FEC,710
07DB4:  MOVFF  FEC,711
07DB8:  MOVFF  FEC,712
07DBC:  MOVFF  70E,565
07DC0:  MOVFF  70D,564
07DC4:  MOVFF  70B,734
07DC8:  MOVLW  18
07DCA:  MOVWF  x35
07DCC:  MOVLB  0
07DCE:  CALL   606E
07DD2:  MOVLW  2C
07DD4:  MOVLB  7
07DD6:  MOVWF  x50
07DD8:  MOVLB  0
07DDA:  CALL   55D0
07DDE:  MOVLW  89
07DE0:  MOVWF  FE9
07DE2:  MOVFF  712,746
07DE6:  MOVFF  711,745
07DEA:  MOVFF  710,744
07DEE:  MOVFF  70F,743
07DF2:  MOVLW  02
07DF4:  MOVLB  7
07DF6:  MOVWF  x47
07DF8:  MOVLB  0
07DFA:  CALL   576E
07DFE:  MOVLW  2C
07E00:  MOVLB  7
07E02:  MOVWF  x50
07E04:  MOVLB  0
07E06:  CALL   55D0
07E0A:  BRA    7F66
07E0C:  MOVLB  7
....................    else if ('4' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c4);
07E0E:  MOVF   x0C,W
07E10:  SUBLW  34
07E12:  BNZ   7EB6
07E14:  MOVLW  04
07E16:  MOVWF  x42
07E18:  MOVLW  C1
07E1A:  MOVWF  x41
07E1C:  MOVLB  0
07E1E:  CALL   5598
07E22:  MOVF   01,W
07E24:  ADDLW  C1
07E26:  MOVLB  7
07E28:  MOVWF  x0D
07E2A:  MOVLW  04
07E2C:  ADDWFC 02,W
07E2E:  MOVWF  x0E
07E30:  MOVLW  01
07E32:  SUBWF  x0B,W
07E34:  MULLW  18
07E36:  MOVF   FF3,W
07E38:  CLRF   x10
07E3A:  MOVWF  x0F
07E3C:  MOVLW  10
07E3E:  ADDWF  x0F,W
07E40:  MOVWF  01
07E42:  MOVLW  00
07E44:  ADDWFC x10,W
07E46:  MOVWF  03
07E48:  MOVF   01,W
07E4A:  ADDLW  92
07E4C:  MOVWF  FE9
07E4E:  MOVLW  00
07E50:  ADDWFC 03,W
07E52:  MOVWF  FEA
07E54:  MOVFF  FEF,70F
07E58:  MOVFF  FEC,710
07E5C:  MOVFF  FEC,711
07E60:  MOVFF  FEC,712
07E64:  MOVFF  70E,565
07E68:  MOVFF  70D,564
07E6C:  MOVFF  70B,734
07E70:  MOVLW  18
07E72:  MOVWF  x35
07E74:  MOVLB  0
07E76:  CALL   606E
07E7A:  MOVLW  2C
07E7C:  MOVLB  7
07E7E:  MOVWF  x50
07E80:  MOVLB  0
07E82:  CALL   55D0
07E86:  MOVLW  89
07E88:  MOVWF  FE9
07E8A:  MOVFF  712,746
07E8E:  MOVFF  711,745
07E92:  MOVFF  710,744
07E96:  MOVFF  70F,743
07E9A:  MOVLW  02
07E9C:  MOVLB  7
07E9E:  MOVWF  x47
07EA0:  MOVLB  0
07EA2:  CALL   576E
07EA6:  MOVLW  2C
07EA8:  MOVLB  7
07EAA:  MOVWF  x50
07EAC:  MOVLB  0
07EAE:  CALL   55D0
07EB2:  BRA    7F66
07EB4:  MOVLB  7
....................    else if ('5' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c5);
07EB6:  MOVF   x0C,W
07EB8:  SUBLW  35
07EBA:  BNZ   7F5E
07EBC:  MOVLW  04
07EBE:  MOVWF  x42
07EC0:  MOVLW  C1
07EC2:  MOVWF  x41
07EC4:  MOVLB  0
07EC6:  CALL   5598
07ECA:  MOVF   01,W
07ECC:  ADDLW  C1
07ECE:  MOVLB  7
07ED0:  MOVWF  x0D
07ED2:  MOVLW  04
07ED4:  ADDWFC 02,W
07ED6:  MOVWF  x0E
07ED8:  MOVLW  01
07EDA:  SUBWF  x0B,W
07EDC:  MULLW  18
07EDE:  MOVF   FF3,W
07EE0:  CLRF   x10
07EE2:  MOVWF  x0F
07EE4:  MOVLW  14
07EE6:  ADDWF  x0F,W
07EE8:  MOVWF  01
07EEA:  MOVLW  00
07EEC:  ADDWFC x10,W
07EEE:  MOVWF  03
07EF0:  MOVF   01,W
07EF2:  ADDLW  92
07EF4:  MOVWF  FE9
07EF6:  MOVLW  00
07EF8:  ADDWFC 03,W
07EFA:  MOVWF  FEA
07EFC:  MOVFF  FEF,70F
07F00:  MOVFF  FEC,710
07F04:  MOVFF  FEC,711
07F08:  MOVFF  FEC,712
07F0C:  MOVFF  70E,565
07F10:  MOVFF  70D,564
07F14:  MOVFF  70B,734
07F18:  MOVLW  18
07F1A:  MOVWF  x35
07F1C:  MOVLB  0
07F1E:  CALL   606E
07F22:  MOVLW  2C
07F24:  MOVLB  7
07F26:  MOVWF  x50
07F28:  MOVLB  0
07F2A:  CALL   55D0
07F2E:  MOVLW  89
07F30:  MOVWF  FE9
07F32:  MOVFF  712,746
07F36:  MOVFF  711,745
07F3A:  MOVFF  710,744
07F3E:  MOVFF  70F,743
07F42:  MOVLW  02
07F44:  MOVLB  7
07F46:  MOVWF  x47
07F48:  MOVLB  0
07F4A:  CALL   576E
07F4E:  MOVLW  2C
07F50:  MOVLB  7
07F52:  MOVWF  x50
07F54:  MOVLB  0
07F56:  CALL   55D0
07F5A:  BRA    7F66
07F5C:  MOVLB  7
....................    else return INV_PARAM;
07F5E:  MOVLW  02
07F60:  MOVWF  01
07F62:  MOVLB  0
07F64:  BRA    7F6A
....................    
....................    return SUCCESS;
07F66:  MOVLW  00
07F68:  MOVWF  01
07F6A:  RETURN 0
.................... }
.................... 
.................... int8 setSensorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char  arg2;
....................    float arg3;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
07F6C:  MOVLB  7
07F6E:  CLRF   x42
07F70:  MOVFF  690,741
07F74:  CLRF   x44
07F76:  MOVLW  B5
07F78:  MOVWF  x43
07F7A:  MOVLB  0
07F7C:  CALL   08B6
07F80:  MOVFF  02,712
07F84:  MOVFF  01,711
07F88:  MOVLW  06
07F8A:  MOVLB  7
07F8C:  ADDWF  x11,F
07F8E:  MOVLW  00
07F90:  ADDWFC x12,F
07F92:  MOVLW  32
07F94:  ADDWF  x11,W
07F96:  MOVWF  01
07F98:  MOVLW  00
07F9A:  ADDWFC x12,W
07F9C:  MOVWF  03
07F9E:  MOVF   01,W
07FA0:  ADDLW  EB
07FA2:  MOVWF  01
07FA4:  MOVLW  01
07FA6:  ADDWFC 03,F
07FA8:  MOVFF  01,711
07FAC:  MOVFF  03,712
07FB0:  MOVFF  03,734
07FB4:  MOVFF  01,733
07FB8:  MOVLB  0
07FBA:  CALL   5C2A
07FBE:  MOVF   01,F
07FC0:  BNZ   7FCA
07FC2:  MOVLW  02
07FC4:  MOVWF  01
07FC6:  BRA    8302
07FC8:  BRA    8028
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07FCA:  MOVLB  7
07FCC:  CLRF   x42
07FCE:  MOVFF  690,741
07FD2:  CLRF   x44
07FD4:  MOVLW  B5
07FD6:  MOVWF  x43
07FD8:  MOVLB  0
07FDA:  CALL   08B6
07FDE:  MOVFF  02,712
07FE2:  MOVFF  01,711
07FE6:  MOVLW  06
07FE8:  MOVLB  7
07FEA:  ADDWF  x11,F
07FEC:  MOVLW  00
07FEE:  ADDWFC x12,F
07FF0:  MOVLW  32
07FF2:  ADDWF  x11,W
07FF4:  MOVWF  01
07FF6:  MOVLW  00
07FF8:  ADDWFC x12,W
07FFA:  MOVWF  03
07FFC:  MOVF   01,W
07FFE:  ADDLW  EB
08000:  MOVWF  01
08002:  MOVLW  01
08004:  ADDWFC 03,F
08006:  MOVFF  01,711
0800A:  MOVFF  03,712
0800E:  MOVFF  03,734
08012:  MOVFF  01,733
08016:  CLRF   x36
08018:  CLRF   x35
0801A:  MOVLW  0A
0801C:  MOVWF  x37
0801E:  MOVLB  0
08020:  CALL   5D1A
08024:  MOVFF  01,70B
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
08028:  MOVLB  7
0802A:  CLRF   x42
0802C:  MOVFF  690,741
08030:  CLRF   x44
08032:  MOVLW  B5
08034:  MOVWF  x43
08036:  MOVLB  0
08038:  CALL   08B6
0803C:  MOVFF  02,712
08040:  MOVFF  01,711
08044:  MOVLW  06
08046:  MOVLB  7
08048:  ADDWF  x11,F
0804A:  MOVLW  00
0804C:  ADDWFC x12,F
0804E:  MOVLW  4B
08050:  ADDWF  x11,W
08052:  MOVWF  01
08054:  MOVLW  00
08056:  ADDWFC x12,W
08058:  MOVWF  03
0805A:  MOVF   01,W
0805C:  ADDLW  EB
0805E:  MOVWF  01
08060:  MOVLW  01
08062:  ADDWFC 03,F
08064:  MOVFF  01,711
08068:  MOVFF  03,712
0806C:  MOVFF  03,742
08070:  MOVFF  01,741
08074:  MOVLB  0
08076:  CALL   5598
0807A:  MOVFF  02,03
0807E:  MOVF   01,W
08080:  SUBLW  01
08082:  BNZ   8088
08084:  MOVF   03,F
08086:  BZ    8090
08088:  MOVLW  02
0808A:  MOVWF  01
0808C:  BRA    8302
0808E:  BRA    80D0
....................    else arg2 = SERcmd[rec].p[3][0];
08090:  MOVLB  7
08092:  CLRF   x42
08094:  MOVFF  690,741
08098:  CLRF   x44
0809A:  MOVLW  B5
0809C:  MOVWF  x43
0809E:  MOVLB  0
080A0:  CALL   08B6
080A4:  MOVFF  02,712
080A8:  MOVFF  01,711
080AC:  MOVLW  06
080AE:  MOVLB  7
080B0:  ADDWF  x11,F
080B2:  MOVLW  00
080B4:  ADDWFC x12,F
080B6:  MOVLW  4B
080B8:  ADDWF  x11,F
080BA:  MOVLW  00
080BC:  ADDWFC x12,F
080BE:  MOVLW  EB
080C0:  ADDWF  x11,W
080C2:  MOVWF  FE9
080C4:  MOVLW  01
080C6:  ADDWFC x12,W
080C8:  MOVWF  FEA
080CA:  MOVFF  FEF,70C
080CE:  MOVLB  0
....................    
....................    if (!arg_is_float(SERcmd[rec].p[4])) return INV_PARAM;
080D0:  MOVLB  7
080D2:  CLRF   x42
080D4:  MOVFF  690,741
080D8:  CLRF   x44
080DA:  MOVLW  B5
080DC:  MOVWF  x43
080DE:  MOVLB  0
080E0:  CALL   08B6
080E4:  MOVFF  02,712
080E8:  MOVFF  01,711
080EC:  MOVLW  06
080EE:  MOVLB  7
080F0:  ADDWF  x11,F
080F2:  MOVLW  00
080F4:  ADDWFC x12,F
080F6:  MOVLW  64
080F8:  ADDWF  x11,W
080FA:  MOVWF  01
080FC:  MOVLW  00
080FE:  ADDWFC x12,W
08100:  MOVWF  03
08102:  MOVF   01,W
08104:  ADDLW  EB
08106:  MOVWF  01
08108:  MOVLW  01
0810A:  ADDWFC 03,F
0810C:  MOVFF  01,711
08110:  MOVFF  03,712
08114:  MOVFF  03,715
08118:  MOVFF  01,714
0811C:  MOVLB  0
0811E:  CALL   6D3E
08122:  MOVF   01,F
08124:  BNZ   812E
08126:  MOVLW  02
08128:  MOVWF  01
0812A:  BRA    8302
0812C:  BRA    8194
....................    else arg3 = strtod(SERcmd[rec].p[4], '\0');
0812E:  MOVLB  7
08130:  CLRF   x42
08132:  MOVFF  690,741
08136:  CLRF   x44
08138:  MOVLW  B5
0813A:  MOVWF  x43
0813C:  MOVLB  0
0813E:  CALL   08B6
08142:  MOVFF  02,712
08146:  MOVFF  01,711
0814A:  MOVLW  06
0814C:  MOVLB  7
0814E:  ADDWF  x11,F
08150:  MOVLW  00
08152:  ADDWFC x12,F
08154:  MOVLW  64
08156:  ADDWF  x11,W
08158:  MOVWF  01
0815A:  MOVLW  00
0815C:  ADDWFC x12,W
0815E:  MOVWF  03
08160:  MOVF   01,W
08162:  ADDLW  EB
08164:  MOVWF  01
08166:  MOVLW  01
08168:  ADDWFC 03,F
0816A:  MOVFF  01,711
0816E:  MOVFF  03,712
08172:  MOVFF  03,715
08176:  MOVFF  01,714
0817A:  CLRF   x17
0817C:  CLRF   x16
0817E:  MOVLB  0
08180:  CALL   6E00
08184:  MOVFF  03,710
08188:  MOVFF  02,70F
0818C:  MOVFF  01,70E
08190:  MOVFF  00,70D
....................    
....................    /*** SET SENSOR CAL PARAM **********/
....................    if      ('0' == arg2) sensorCal[arg1-1].c0 = arg3;
08194:  MOVLB  7
08196:  MOVF   x0C,W
08198:  SUBLW  30
0819A:  BNZ   81C6
0819C:  MOVLW  01
0819E:  SUBWF  x0B,W
081A0:  MULLW  18
081A2:  MOVF   FF3,W
081A4:  CLRF   x12
081A6:  MOVWF  x11
081A8:  MOVLW  92
081AA:  ADDWF  x11,W
081AC:  MOVWF  FE9
081AE:  MOVLW  00
081B0:  ADDWFC x12,W
081B2:  MOVWF  FEA
081B4:  MOVFF  70D,FEF
081B8:  MOVFF  70E,FEC
081BC:  MOVFF  70F,FEC
081C0:  MOVFF  710,FEC
081C4:  BRA    82FC
....................    else if ('1' == arg2) sensorCal[arg1-1].c1 = arg3;
081C6:  MOVF   x0C,W
081C8:  SUBLW  31
081CA:  BNZ   8202
081CC:  MOVLW  01
081CE:  SUBWF  x0B,W
081D0:  MULLW  18
081D2:  MOVF   FF3,W
081D4:  CLRF   x12
081D6:  MOVWF  x11
081D8:  MOVLW  04
081DA:  ADDWF  x11,W
081DC:  MOVWF  01
081DE:  MOVLW  00
081E0:  ADDWFC x12,W
081E2:  MOVWF  03
081E4:  MOVF   01,W
081E6:  ADDLW  92
081E8:  MOVWF  FE9
081EA:  MOVLW  00
081EC:  ADDWFC 03,W
081EE:  MOVWF  FEA
081F0:  MOVFF  70D,FEF
081F4:  MOVFF  70E,FEC
081F8:  MOVFF  70F,FEC
081FC:  MOVFF  710,FEC
08200:  BRA    82FC
....................    else if ('2' == arg2) sensorCal[arg1-1].c2 = arg3;
08202:  MOVF   x0C,W
08204:  SUBLW  32
08206:  BNZ   823E
08208:  MOVLW  01
0820A:  SUBWF  x0B,W
0820C:  MULLW  18
0820E:  MOVF   FF3,W
08210:  CLRF   x12
08212:  MOVWF  x11
08214:  MOVLW  08
08216:  ADDWF  x11,W
08218:  MOVWF  01
0821A:  MOVLW  00
0821C:  ADDWFC x12,W
0821E:  MOVWF  03
08220:  MOVF   01,W
08222:  ADDLW  92
08224:  MOVWF  FE9
08226:  MOVLW  00
08228:  ADDWFC 03,W
0822A:  MOVWF  FEA
0822C:  MOVFF  70D,FEF
08230:  MOVFF  70E,FEC
08234:  MOVFF  70F,FEC
08238:  MOVFF  710,FEC
0823C:  BRA    82FC
....................    else if ('3' == arg2) sensorCal[arg1-1].c3 = arg3;
0823E:  MOVF   x0C,W
08240:  SUBLW  33
08242:  BNZ   827A
08244:  MOVLW  01
08246:  SUBWF  x0B,W
08248:  MULLW  18
0824A:  MOVF   FF3,W
0824C:  CLRF   x12
0824E:  MOVWF  x11
08250:  MOVLW  0C
08252:  ADDWF  x11,W
08254:  MOVWF  01
08256:  MOVLW  00
08258:  ADDWFC x12,W
0825A:  MOVWF  03
0825C:  MOVF   01,W
0825E:  ADDLW  92
08260:  MOVWF  FE9
08262:  MOVLW  00
08264:  ADDWFC 03,W
08266:  MOVWF  FEA
08268:  MOVFF  70D,FEF
0826C:  MOVFF  70E,FEC
08270:  MOVFF  70F,FEC
08274:  MOVFF  710,FEC
08278:  BRA    82FC
....................    else if ('4' == arg2) sensorCal[arg1-1].c4 = arg3;
0827A:  MOVF   x0C,W
0827C:  SUBLW  34
0827E:  BNZ   82B6
08280:  MOVLW  01
08282:  SUBWF  x0B,W
08284:  MULLW  18
08286:  MOVF   FF3,W
08288:  CLRF   x12
0828A:  MOVWF  x11
0828C:  MOVLW  10
0828E:  ADDWF  x11,W
08290:  MOVWF  01
08292:  MOVLW  00
08294:  ADDWFC x12,W
08296:  MOVWF  03
08298:  MOVF   01,W
0829A:  ADDLW  92
0829C:  MOVWF  FE9
0829E:  MOVLW  00
082A0:  ADDWFC 03,W
082A2:  MOVWF  FEA
082A4:  MOVFF  70D,FEF
082A8:  MOVFF  70E,FEC
082AC:  MOVFF  70F,FEC
082B0:  MOVFF  710,FEC
082B4:  BRA    82FC
....................    else if ('5' == arg2) sensorCal[arg1-1].c5 = arg3;
082B6:  MOVF   x0C,W
082B8:  SUBLW  35
082BA:  BNZ   82F2
082BC:  MOVLW  01
082BE:  SUBWF  x0B,W
082C0:  MULLW  18
082C2:  MOVF   FF3,W
082C4:  CLRF   x12
082C6:  MOVWF  x11
082C8:  MOVLW  14
082CA:  ADDWF  x11,W
082CC:  MOVWF  01
082CE:  MOVLW  00
082D0:  ADDWFC x12,W
082D2:  MOVWF  03
082D4:  MOVF   01,W
082D6:  ADDLW  92
082D8:  MOVWF  FE9
082DA:  MOVLW  00
082DC:  ADDWFC 03,W
082DE:  MOVWF  FEA
082E0:  MOVFF  70D,FEF
082E4:  MOVFF  70E,FEC
082E8:  MOVFF  70F,FEC
082EC:  MOVFF  710,FEC
082F0:  BRA    82FC
....................    else return INV_PARAM;
082F2:  MOVLW  02
082F4:  MOVWF  01
082F6:  MOVLB  0
082F8:  BRA    8302
082FA:  MOVLB  7
....................    
....................    return SUCCESS;
082FC:  MOVLW  00
082FE:  MOVWF  01
08300:  MOVLB  0
08302:  RETURN 0
.................... }
.................... 
.................... int8 getMonitorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    char *arg1;
....................    char *s_N15 = "N15";
08304:  MOVLW  4E
08306:  MOVLB  7
08308:  MOVWF  x0F
0830A:  MOVLW  31
0830C:  MOVWF  x10
0830E:  MOVLW  35
08310:  MOVWF  x11
08312:  CLRF   x12
08314:  MOVLW  07
08316:  MOVWF  x0E
08318:  MOVLW  0F
0831A:  MOVWF  x0D
....................    char *s_200 = "200";
0831C:  MOVLW  32
0831E:  MOVWF  x15
08320:  MOVLW  30
08322:  MOVWF  x16
08324:  MOVWF  x17
08326:  CLRF   x18
08328:  MOVLW  07
0832A:  MOVWF  x14
0832C:  MOVLW  15
0832E:  MOVWF  x13
....................    char *s_5V6 = "5V6";
08330:  MOVLW  35
08332:  MOVWF  x1B
08334:  MOVLW  56
08336:  MOVWF  x1C
08338:  MOVLW  36
0833A:  MOVWF  x1D
0833C:  CLRF   x1E
0833E:  MOVLW  07
08340:  MOVWF  x1A
08342:  MOVLW  1B
08344:  MOVWF  x19
....................    char *s_5VA = "5VA";
08346:  MOVLW  35
08348:  MOVWF  x21
0834A:  MOVLW  56
0834C:  MOVWF  x22
0834E:  MOVLW  41
08350:  MOVWF  x23
08352:  CLRF   x24
08354:  MOVLW  07
08356:  MOVWF  x20
08358:  MOVLW  21
0835A:  MOVWF  x1F
....................    char *s_3V6X = "3V6X";
0835C:  MOVLW  33
0835E:  MOVWF  x27
08360:  MOVLW  56
08362:  MOVWF  x28
08364:  MOVLW  36
08366:  MOVWF  x29
08368:  MOVLW  58
0836A:  MOVWF  x2A
0836C:  CLRF   x2B
0836E:  MOVLW  07
08370:  MOVWF  x26
08372:  MOVLW  27
08374:  MOVWF  x25
....................    char *s_3V3A = "3V3A";
08376:  MOVLW  33
08378:  MOVWF  x2E
0837A:  MOVLW  56
0837C:  MOVWF  x2F
0837E:  MOVLW  33
08380:  MOVWF  x30
08382:  MOVLW  41
08384:  MOVWF  x31
08386:  CLRF   x32
08388:  MOVLW  07
0838A:  MOVWF  x2D
0838C:  MOVLW  2E
0838E:  MOVWF  x2C
....................    char *s_3V3D = "3V3D";
08390:  MOVLW  33
08392:  MOVWF  x35
08394:  MOVLW  56
08396:  MOVWF  x36
08398:  MOVLW  33
0839A:  MOVWF  x37
0839C:  MOVLW  44
0839E:  MOVWF  x38
083A0:  CLRF   x39
083A2:  MOVLW  07
083A4:  MOVWF  x34
083A6:  MOVLW  35
083A8:  MOVWF  x33
.................... //!   char *s_all = "all";
....................    
....................    arg1 = SERcmd[rec].p[2];
083AA:  CLRF   x42
083AC:  MOVFF  690,741
083B0:  CLRF   x44
083B2:  MOVLW  B5
083B4:  MOVWF  x43
083B6:  MOVLB  0
083B8:  CALL   08B6
083BC:  MOVFF  02,73B
083C0:  MOVFF  01,73A
083C4:  MOVLW  06
083C6:  MOVLB  7
083C8:  ADDWF  x3A,F
083CA:  MOVLW  00
083CC:  ADDWFC x3B,F
083CE:  MOVLW  32
083D0:  ADDWF  x3A,W
083D2:  MOVWF  01
083D4:  MOVLW  00
083D6:  ADDWFC x3B,W
083D8:  MOVWF  03
083DA:  MOVF   01,W
083DC:  ADDLW  EB
083DE:  MOVWF  01
083E0:  MOVLW  01
083E2:  ADDWFC 03,F
083E4:  MOVFF  01,70B
083E8:  MOVFF  03,70C
....................    
....................    /*** GET MONITOR VALUES ************/
....................    if      (0 == strcmp(s_N15, arg1)) {
083EC:  MOVFF  70E,742
083F0:  MOVFF  70D,741
083F4:  MOVFF  70C,744
083F8:  MOVFF  70B,743
083FC:  MOVLB  0
083FE:  CALL   5B0A
08402:  MOVF   01,F
08404:  BNZ   8488
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.vN15[0],monCal.vN15[1]);
08406:  MOVLW  04
08408:  MOVLB  7
0840A:  MOVWF  x42
0840C:  MOVLW  C1
0840E:  MOVWF  x41
08410:  MOVLB  0
08412:  CALL   5598
08416:  MOVFF  02,03
0841A:  MOVF   01,W
0841C:  ADDLW  C1
0841E:  MOVLB  7
08420:  MOVWF  x3A
08422:  MOVLW  04
08424:  ADDWFC 02,W
08426:  MOVWF  x3B
08428:  MOVFF  FE8,565
0842C:  MOVFF  73A,564
08430:  MOVLW  89
08432:  MOVWF  FE9
08434:  MOVFF  C5,746
08438:  MOVFF  C4,745
0843C:  MOVFF  C3,744
08440:  MOVFF  C2,743
08444:  MOVLW  02
08446:  MOVWF  x47
08448:  MOVLB  0
0844A:  CALL   576E
0844E:  MOVLW  2C
08450:  MOVLB  7
08452:  MOVWF  x50
08454:  MOVLB  0
08456:  CALL   55D0
0845A:  MOVLW  89
0845C:  MOVWF  FE9
0845E:  MOVFF  C9,746
08462:  MOVFF  C8,745
08466:  MOVFF  C7,744
0846A:  MOVFF  C6,743
0846E:  MOVLW  02
08470:  MOVLB  7
08472:  MOVWF  x47
08474:  MOVLB  0
08476:  CALL   576E
0847A:  MOVLW  2C
0847C:  MOVLB  7
0847E:  MOVWF  x50
08480:  MOVLB  0
08482:  CALL   55D0
....................    }
08486:  BRA    882A
....................    else if (0 == strcmp(s_200, arg1)) {
08488:  MOVFF  714,742
0848C:  MOVFF  713,741
08490:  MOVFF  70C,744
08494:  MOVFF  70B,743
08498:  CALL   5B0A
0849C:  MOVF   01,F
0849E:  BNZ   8522
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v200[0],monCal.v200[1]);
084A0:  MOVLW  04
084A2:  MOVLB  7
084A4:  MOVWF  x42
084A6:  MOVLW  C1
084A8:  MOVWF  x41
084AA:  MOVLB  0
084AC:  CALL   5598
084B0:  MOVFF  02,03
084B4:  MOVF   01,W
084B6:  ADDLW  C1
084B8:  MOVLB  7
084BA:  MOVWF  x3A
084BC:  MOVLW  04
084BE:  ADDWFC 02,W
084C0:  MOVWF  x3B
084C2:  MOVFF  FE8,565
084C6:  MOVFF  73A,564
084CA:  MOVLW  89
084CC:  MOVWF  FE9
084CE:  MOVFF  CD,746
084D2:  MOVFF  CC,745
084D6:  MOVFF  CB,744
084DA:  MOVFF  CA,743
084DE:  MOVLW  02
084E0:  MOVWF  x47
084E2:  MOVLB  0
084E4:  CALL   576E
084E8:  MOVLW  2C
084EA:  MOVLB  7
084EC:  MOVWF  x50
084EE:  MOVLB  0
084F0:  CALL   55D0
084F4:  MOVLW  89
084F6:  MOVWF  FE9
084F8:  MOVFF  D1,746
084FC:  MOVFF  D0,745
08500:  MOVFF  CF,744
08504:  MOVFF  CE,743
08508:  MOVLW  02
0850A:  MOVLB  7
0850C:  MOVWF  x47
0850E:  MOVLB  0
08510:  CALL   576E
08514:  MOVLW  2C
08516:  MOVLB  7
08518:  MOVWF  x50
0851A:  MOVLB  0
0851C:  CALL   55D0
....................    }
08520:  BRA    882A
....................    else if (0 == strcmp(s_5V6, arg1)) {
08522:  MOVFF  71A,742
08526:  MOVFF  719,741
0852A:  MOVFF  70C,744
0852E:  MOVFF  70B,743
08532:  CALL   5B0A
08536:  MOVF   01,F
08538:  BNZ   85BC
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v5V6[0],monCal.v5V6[1]);
0853A:  MOVLW  04
0853C:  MOVLB  7
0853E:  MOVWF  x42
08540:  MOVLW  C1
08542:  MOVWF  x41
08544:  MOVLB  0
08546:  CALL   5598
0854A:  MOVFF  02,03
0854E:  MOVF   01,W
08550:  ADDLW  C1
08552:  MOVLB  7
08554:  MOVWF  x3A
08556:  MOVLW  04
08558:  ADDWFC 02,W
0855A:  MOVWF  x3B
0855C:  MOVFF  FE8,565
08560:  MOVFF  73A,564
08564:  MOVLW  89
08566:  MOVWF  FE9
08568:  MOVFF  D5,746
0856C:  MOVFF  D4,745
08570:  MOVFF  D3,744
08574:  MOVFF  D2,743
08578:  MOVLW  02
0857A:  MOVWF  x47
0857C:  MOVLB  0
0857E:  CALL   576E
08582:  MOVLW  2C
08584:  MOVLB  7
08586:  MOVWF  x50
08588:  MOVLB  0
0858A:  CALL   55D0
0858E:  MOVLW  89
08590:  MOVWF  FE9
08592:  MOVFF  D9,746
08596:  MOVFF  D8,745
0859A:  MOVFF  D7,744
0859E:  MOVFF  D6,743
085A2:  MOVLW  02
085A4:  MOVLB  7
085A6:  MOVWF  x47
085A8:  MOVLB  0
085AA:  CALL   576E
085AE:  MOVLW  2C
085B0:  MOVLB  7
085B2:  MOVWF  x50
085B4:  MOVLB  0
085B6:  CALL   55D0
....................    }
085BA:  BRA    882A
....................    else if (0 == strcmp(s_5VA, arg1)) {
085BC:  MOVFF  720,742
085C0:  MOVFF  71F,741
085C4:  MOVFF  70C,744
085C8:  MOVFF  70B,743
085CC:  CALL   5B0A
085D0:  MOVF   01,F
085D2:  BNZ   8656
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v5VA[0],monCal.v5VA[1]);
085D4:  MOVLW  04
085D6:  MOVLB  7
085D8:  MOVWF  x42
085DA:  MOVLW  C1
085DC:  MOVWF  x41
085DE:  MOVLB  0
085E0:  CALL   5598
085E4:  MOVFF  02,03
085E8:  MOVF   01,W
085EA:  ADDLW  C1
085EC:  MOVLB  7
085EE:  MOVWF  x3A
085F0:  MOVLW  04
085F2:  ADDWFC 02,W
085F4:  MOVWF  x3B
085F6:  MOVFF  FE8,565
085FA:  MOVFF  73A,564
085FE:  MOVLW  89
08600:  MOVWF  FE9
08602:  MOVFF  DD,746
08606:  MOVFF  DC,745
0860A:  MOVFF  DB,744
0860E:  MOVFF  DA,743
08612:  MOVLW  02
08614:  MOVWF  x47
08616:  MOVLB  0
08618:  CALL   576E
0861C:  MOVLW  2C
0861E:  MOVLB  7
08620:  MOVWF  x50
08622:  MOVLB  0
08624:  CALL   55D0
08628:  MOVLW  89
0862A:  MOVWF  FE9
0862C:  MOVFF  E1,746
08630:  MOVFF  E0,745
08634:  MOVFF  DF,744
08638:  MOVFF  DE,743
0863C:  MOVLW  02
0863E:  MOVLB  7
08640:  MOVWF  x47
08642:  MOVLB  0
08644:  CALL   576E
08648:  MOVLW  2C
0864A:  MOVLB  7
0864C:  MOVWF  x50
0864E:  MOVLB  0
08650:  CALL   55D0
....................    }
08654:  BRA    882A
....................    else if (0 == strcmp(s_3V6X, arg1)) {
08656:  MOVFF  726,742
0865A:  MOVFF  725,741
0865E:  MOVFF  70C,744
08662:  MOVFF  70B,743
08666:  CALL   5B0A
0866A:  MOVF   01,F
0866C:  BNZ   86F0
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V6X[0],monCal.v3V6X[1]);
0866E:  MOVLW  04
08670:  MOVLB  7
08672:  MOVWF  x42
08674:  MOVLW  C1
08676:  MOVWF  x41
08678:  MOVLB  0
0867A:  CALL   5598
0867E:  MOVFF  02,03
08682:  MOVF   01,W
08684:  ADDLW  C1
08686:  MOVLB  7
08688:  MOVWF  x3A
0868A:  MOVLW  04
0868C:  ADDWFC 02,W
0868E:  MOVWF  x3B
08690:  MOVFF  FE8,565
08694:  MOVFF  73A,564
08698:  MOVLW  89
0869A:  MOVWF  FE9
0869C:  MOVFF  E5,746
086A0:  MOVFF  E4,745
086A4:  MOVFF  E3,744
086A8:  MOVFF  E2,743
086AC:  MOVLW  02
086AE:  MOVWF  x47
086B0:  MOVLB  0
086B2:  CALL   576E
086B6:  MOVLW  2C
086B8:  MOVLB  7
086BA:  MOVWF  x50
086BC:  MOVLB  0
086BE:  CALL   55D0
086C2:  MOVLW  89
086C4:  MOVWF  FE9
086C6:  MOVFF  E9,746
086CA:  MOVFF  E8,745
086CE:  MOVFF  E7,744
086D2:  MOVFF  E6,743
086D6:  MOVLW  02
086D8:  MOVLB  7
086DA:  MOVWF  x47
086DC:  MOVLB  0
086DE:  CALL   576E
086E2:  MOVLW  2C
086E4:  MOVLB  7
086E6:  MOVWF  x50
086E8:  MOVLB  0
086EA:  CALL   55D0
....................    }
086EE:  BRA    882A
....................    else if (0 == strcmp(s_3V3A, arg1)) {
086F0:  MOVFF  72D,742
086F4:  MOVFF  72C,741
086F8:  MOVFF  70C,744
086FC:  MOVFF  70B,743
08700:  CALL   5B0A
08704:  MOVF   01,F
08706:  BNZ   878A
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3A[0],monCal.v3V3A[1]);
08708:  MOVLW  04
0870A:  MOVLB  7
0870C:  MOVWF  x42
0870E:  MOVLW  C1
08710:  MOVWF  x41
08712:  MOVLB  0
08714:  CALL   5598
08718:  MOVFF  02,03
0871C:  MOVF   01,W
0871E:  ADDLW  C1
08720:  MOVLB  7
08722:  MOVWF  x3A
08724:  MOVLW  04
08726:  ADDWFC 02,W
08728:  MOVWF  x3B
0872A:  MOVFF  FE8,565
0872E:  MOVFF  73A,564
08732:  MOVLW  89
08734:  MOVWF  FE9
08736:  MOVFF  ED,746
0873A:  MOVFF  EC,745
0873E:  MOVFF  EB,744
08742:  MOVFF  EA,743
08746:  MOVLW  02
08748:  MOVWF  x47
0874A:  MOVLB  0
0874C:  CALL   576E
08750:  MOVLW  2C
08752:  MOVLB  7
08754:  MOVWF  x50
08756:  MOVLB  0
08758:  CALL   55D0
0875C:  MOVLW  89
0875E:  MOVWF  FE9
08760:  MOVFF  F1,746
08764:  MOVFF  F0,745
08768:  MOVFF  EF,744
0876C:  MOVFF  EE,743
08770:  MOVLW  02
08772:  MOVLB  7
08774:  MOVWF  x47
08776:  MOVLB  0
08778:  CALL   576E
0877C:  MOVLW  2C
0877E:  MOVLB  7
08780:  MOVWF  x50
08782:  MOVLB  0
08784:  CALL   55D0
....................    }
08788:  BRA    882A
....................    else if (0 == strcmp(s_3V3D, arg1)) {
0878A:  MOVFF  734,742
0878E:  MOVFF  733,741
08792:  MOVFF  70C,744
08796:  MOVFF  70B,743
0879A:  CALL   5B0A
0879E:  MOVF   01,F
087A0:  BNZ   8824
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3D[0],monCal.v3V3D[1]);
087A2:  MOVLW  04
087A4:  MOVLB  7
087A6:  MOVWF  x42
087A8:  MOVLW  C1
087AA:  MOVWF  x41
087AC:  MOVLB  0
087AE:  CALL   5598
087B2:  MOVFF  02,03
087B6:  MOVF   01,W
087B8:  ADDLW  C1
087BA:  MOVLB  7
087BC:  MOVWF  x3A
087BE:  MOVLW  04
087C0:  ADDWFC 02,W
087C2:  MOVWF  x3B
087C4:  MOVFF  FE8,565
087C8:  MOVFF  73A,564
087CC:  MOVLW  89
087CE:  MOVWF  FE9
087D0:  MOVFF  F5,746
087D4:  MOVFF  F4,745
087D8:  MOVFF  F3,744
087DC:  MOVFF  F2,743
087E0:  MOVLW  02
087E2:  MOVWF  x47
087E4:  MOVLB  0
087E6:  CALL   576E
087EA:  MOVLW  2C
087EC:  MOVLB  7
087EE:  MOVWF  x50
087F0:  MOVLB  0
087F2:  CALL   55D0
087F6:  MOVLW  89
087F8:  MOVWF  FE9
087FA:  MOVFF  F9,746
087FE:  MOVFF  F8,745
08802:  MOVFF  F7,744
08806:  MOVFF  F6,743
0880A:  MOVLW  02
0880C:  MOVLB  7
0880E:  MOVWF  x47
08810:  MOVLB  0
08812:  CALL   576E
08816:  MOVLW  2C
08818:  MOVLB  7
0881A:  MOVWF  x50
0881C:  MOVLB  0
0881E:  CALL   55D0
....................    }
08822:  BRA    882A
....................    else return INV_PARAM;
08824:  MOVLW  02
08826:  MOVWF  01
08828:  BRA    882E
....................    
....................    return SUCCESS;
0882A:  MOVLW  00
0882C:  MOVWF  01
0882E:  RETURN 0
.................... }
.................... 
.................... int8 setMonitorCalParam(unsigned int8 rec){
....................    return SUCCESS;
08830:  MOVLW  00
08832:  MOVWF  01
08834:  RETURN 0
.................... }
.................... 
.................... int8 getMonitorValue(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    char *arg1;
....................    char *s_N15 = "N15";
08836:  MOVLW  4E
08838:  MOVLB  7
0883A:  MOVWF  x0F
0883C:  MOVLW  31
0883E:  MOVWF  x10
08840:  MOVLW  35
08842:  MOVWF  x11
08844:  CLRF   x12
08846:  MOVLW  07
08848:  MOVWF  x0E
0884A:  MOVLW  0F
0884C:  MOVWF  x0D
....................    char *s_200 = "200";
0884E:  MOVLW  32
08850:  MOVWF  x15
08852:  MOVLW  30
08854:  MOVWF  x16
08856:  MOVWF  x17
08858:  CLRF   x18
0885A:  MOVLW  07
0885C:  MOVWF  x14
0885E:  MOVLW  15
08860:  MOVWF  x13
....................    char *s_5V6 = "5V6";
08862:  MOVLW  35
08864:  MOVWF  x1B
08866:  MOVLW  56
08868:  MOVWF  x1C
0886A:  MOVLW  36
0886C:  MOVWF  x1D
0886E:  CLRF   x1E
08870:  MOVLW  07
08872:  MOVWF  x1A
08874:  MOVLW  1B
08876:  MOVWF  x19
....................    char *s_5VA = "5VA";
08878:  MOVLW  35
0887A:  MOVWF  x21
0887C:  MOVLW  56
0887E:  MOVWF  x22
08880:  MOVLW  41
08882:  MOVWF  x23
08884:  CLRF   x24
08886:  MOVLW  07
08888:  MOVWF  x20
0888A:  MOVLW  21
0888C:  MOVWF  x1F
....................    char *s_3V6X = "3V6X";
0888E:  MOVLW  33
08890:  MOVWF  x27
08892:  MOVLW  56
08894:  MOVWF  x28
08896:  MOVLW  36
08898:  MOVWF  x29
0889A:  MOVLW  58
0889C:  MOVWF  x2A
0889E:  CLRF   x2B
088A0:  MOVLW  07
088A2:  MOVWF  x26
088A4:  MOVLW  27
088A6:  MOVWF  x25
....................    char *s_3V3A = "3V3A";
088A8:  MOVLW  33
088AA:  MOVWF  x2E
088AC:  MOVLW  56
088AE:  MOVWF  x2F
088B0:  MOVLW  33
088B2:  MOVWF  x30
088B4:  MOVLW  41
088B6:  MOVWF  x31
088B8:  CLRF   x32
088BA:  MOVLW  07
088BC:  MOVWF  x2D
088BE:  MOVLW  2E
088C0:  MOVWF  x2C
....................    char *s_3V3D = "3V3D";
088C2:  MOVLW  33
088C4:  MOVWF  x35
088C6:  MOVLW  56
088C8:  MOVWF  x36
088CA:  MOVLW  33
088CC:  MOVWF  x37
088CE:  MOVLW  44
088D0:  MOVWF  x38
088D2:  CLRF   x39
088D4:  MOVLW  07
088D6:  MOVWF  x34
088D8:  MOVLW  35
088DA:  MOVWF  x33
....................    char *s_all = "all";
088DC:  MOVLW  61
088DE:  MOVWF  x3C
088E0:  MOVLW  6C
088E2:  MOVWF  x3D
088E4:  MOVWF  x3E
088E6:  CLRF   x3F
088E8:  MOVLW  07
088EA:  MOVWF  x3B
088EC:  MOVLW  3C
088EE:  MOVWF  x3A
....................    
....................    arg1 = SERcmd[rec].p[2];
088F0:  CLRF   x42
088F2:  MOVFF  690,741
088F6:  CLRF   x44
088F8:  MOVLW  B5
088FA:  MOVWF  x43
088FC:  MOVLB  0
088FE:  CALL   08B6
08902:  MOVFF  02,741
08906:  MOVFF  01,740
0890A:  MOVLW  06
0890C:  MOVLB  7
0890E:  ADDWF  x40,F
08910:  MOVLW  00
08912:  ADDWFC x41,F
08914:  MOVLW  32
08916:  ADDWF  x40,W
08918:  MOVWF  01
0891A:  MOVLW  00
0891C:  ADDWFC x41,W
0891E:  MOVWF  03
08920:  MOVF   01,W
08922:  ADDLW  EB
08924:  MOVWF  01
08926:  MOVLW  01
08928:  ADDWFC 03,F
0892A:  MOVFF  01,70B
0892E:  MOVFF  03,70C
....................    
....................    /*** GET MONITOR VALUES ************/
....................    if      (0 == strcmp(s_N15, arg1)) {
08932:  MOVFF  70E,742
08936:  MOVFF  70D,741
0893A:  MOVFF  70C,744
0893E:  MOVFF  70B,743
08942:  MOVLB  0
08944:  CALL   5B0A
08948:  MOVF   01,F
0894A:  BNZ   89A2
....................       sprintf(retData+strlen(retData), "%.2f,", monitorVals.vN15);
0894C:  MOVLW  04
0894E:  MOVLB  7
08950:  MOVWF  x42
08952:  MOVLW  C1
08954:  MOVWF  x41
08956:  MOVLB  0
08958:  CALL   5598
0895C:  MOVFF  02,03
08960:  MOVF   01,W
08962:  ADDLW  C1
08964:  MOVLB  7
08966:  MOVWF  x40
08968:  MOVLW  04
0896A:  ADDWFC 02,W
0896C:  MOVWF  x41
0896E:  MOVFF  FE8,565
08972:  MOVFF  740,564
08976:  MOVLW  89
08978:  MOVWF  FE9
0897A:  MOVFF  FE,746
0897E:  MOVFF  FD,745
08982:  MOVFF  FC,744
08986:  MOVFF  FB,743
0898A:  MOVLW  02
0898C:  MOVWF  x47
0898E:  MOVLB  0
08990:  CALL   576E
08994:  MOVLW  2C
08996:  MOVLB  7
08998:  MOVWF  x50
0899A:  MOVLB  0
0899C:  CALL   55D0
....................    }
089A0:  BRA    8EA4
....................    else if (0 == strcmp(s_200, arg1)) {
089A2:  MOVFF  714,742
089A6:  MOVFF  713,741
089AA:  MOVFF  70C,744
089AE:  MOVFF  70B,743
089B2:  CALL   5B0A
089B6:  MOVF   01,F
089B8:  BNZ   8A10
....................       sprintf(retData+strlen(retData), "%.1f,", monitorVals.v200);
089BA:  MOVLW  04
089BC:  MOVLB  7
089BE:  MOVWF  x42
089C0:  MOVLW  C1
089C2:  MOVWF  x41
089C4:  MOVLB  0
089C6:  CALL   5598
089CA:  MOVFF  02,03
089CE:  MOVF   01,W
089D0:  ADDLW  C1
089D2:  MOVLB  7
089D4:  MOVWF  x40
089D6:  MOVLW  04
089D8:  ADDWFC 02,W
089DA:  MOVWF  x41
089DC:  MOVFF  FE8,565
089E0:  MOVFF  740,564
089E4:  MOVLW  89
089E6:  MOVWF  FE9
089E8:  MOVFF  102,746
089EC:  MOVFF  101,745
089F0:  MOVFF  100,744
089F4:  MOVFF  FF,743
089F8:  MOVLW  01
089FA:  MOVWF  x47
089FC:  MOVLB  0
089FE:  CALL   576E
08A02:  MOVLW  2C
08A04:  MOVLB  7
08A06:  MOVWF  x50
08A08:  MOVLB  0
08A0A:  CALL   55D0
....................    }
08A0E:  BRA    8EA4
....................    else if (0 == strcmp(s_5V6, arg1)) {
08A10:  MOVFF  71A,742
08A14:  MOVFF  719,741
08A18:  MOVFF  70C,744
08A1C:  MOVFF  70B,743
08A20:  CALL   5B0A
08A24:  MOVF   01,F
08A26:  BNZ   8A7E
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5V6);
08A28:  MOVLW  04
08A2A:  MOVLB  7
08A2C:  MOVWF  x42
08A2E:  MOVLW  C1
08A30:  MOVWF  x41
08A32:  MOVLB  0
08A34:  CALL   5598
08A38:  MOVFF  02,03
08A3C:  MOVF   01,W
08A3E:  ADDLW  C1
08A40:  MOVLB  7
08A42:  MOVWF  x40
08A44:  MOVLW  04
08A46:  ADDWFC 02,W
08A48:  MOVWF  x41
08A4A:  MOVFF  FE8,565
08A4E:  MOVFF  740,564
08A52:  MOVLW  89
08A54:  MOVWF  FE9
08A56:  MOVFF  106,746
08A5A:  MOVFF  105,745
08A5E:  MOVFF  104,744
08A62:  MOVFF  103,743
08A66:  MOVLW  03
08A68:  MOVWF  x47
08A6A:  MOVLB  0
08A6C:  CALL   576E
08A70:  MOVLW  2C
08A72:  MOVLB  7
08A74:  MOVWF  x50
08A76:  MOVLB  0
08A78:  CALL   55D0
....................    }
08A7C:  BRA    8EA4
....................    else if (0 == strcmp(s_5VA, arg1)) {
08A7E:  MOVFF  720,742
08A82:  MOVFF  71F,741
08A86:  MOVFF  70C,744
08A8A:  MOVFF  70B,743
08A8E:  CALL   5B0A
08A92:  MOVF   01,F
08A94:  BNZ   8AEC
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5VA);
08A96:  MOVLW  04
08A98:  MOVLB  7
08A9A:  MOVWF  x42
08A9C:  MOVLW  C1
08A9E:  MOVWF  x41
08AA0:  MOVLB  0
08AA2:  CALL   5598
08AA6:  MOVFF  02,03
08AAA:  MOVF   01,W
08AAC:  ADDLW  C1
08AAE:  MOVLB  7
08AB0:  MOVWF  x40
08AB2:  MOVLW  04
08AB4:  ADDWFC 02,W
08AB6:  MOVWF  x41
08AB8:  MOVFF  FE8,565
08ABC:  MOVFF  740,564
08AC0:  MOVLW  89
08AC2:  MOVWF  FE9
08AC4:  MOVFF  10A,746
08AC8:  MOVFF  109,745
08ACC:  MOVFF  108,744
08AD0:  MOVFF  107,743
08AD4:  MOVLW  03
08AD6:  MOVWF  x47
08AD8:  MOVLB  0
08ADA:  CALL   576E
08ADE:  MOVLW  2C
08AE0:  MOVLB  7
08AE2:  MOVWF  x50
08AE4:  MOVLB  0
08AE6:  CALL   55D0
....................    }
08AEA:  BRA    8EA4
....................    else if (0 == strcmp(s_3V6X, arg1)) {
08AEC:  MOVFF  726,742
08AF0:  MOVFF  725,741
08AF4:  MOVFF  70C,744
08AF8:  MOVFF  70B,743
08AFC:  CALL   5B0A
08B00:  MOVF   01,F
08B02:  BNZ   8B5A
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V6X);
08B04:  MOVLW  04
08B06:  MOVLB  7
08B08:  MOVWF  x42
08B0A:  MOVLW  C1
08B0C:  MOVWF  x41
08B0E:  MOVLB  0
08B10:  CALL   5598
08B14:  MOVFF  02,03
08B18:  MOVF   01,W
08B1A:  ADDLW  C1
08B1C:  MOVLB  7
08B1E:  MOVWF  x40
08B20:  MOVLW  04
08B22:  ADDWFC 02,W
08B24:  MOVWF  x41
08B26:  MOVFF  FE8,565
08B2A:  MOVFF  740,564
08B2E:  MOVLW  89
08B30:  MOVWF  FE9
08B32:  MOVFF  10E,746
08B36:  MOVFF  10D,745
08B3A:  MOVFF  10C,744
08B3E:  MOVFF  10B,743
08B42:  MOVLW  03
08B44:  MOVWF  x47
08B46:  MOVLB  0
08B48:  CALL   576E
08B4C:  MOVLW  2C
08B4E:  MOVLB  7
08B50:  MOVWF  x50
08B52:  MOVLB  0
08B54:  CALL   55D0
....................    }
08B58:  BRA    8EA4
....................    else if (0 == strcmp(s_3V3A, arg1)) {
08B5A:  MOVFF  72D,742
08B5E:  MOVFF  72C,741
08B62:  MOVFF  70C,744
08B66:  MOVFF  70B,743
08B6A:  CALL   5B0A
08B6E:  MOVF   01,F
08B70:  BNZ   8BC8
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3A);
08B72:  MOVLW  04
08B74:  MOVLB  7
08B76:  MOVWF  x42
08B78:  MOVLW  C1
08B7A:  MOVWF  x41
08B7C:  MOVLB  0
08B7E:  CALL   5598
08B82:  MOVFF  02,03
08B86:  MOVF   01,W
08B88:  ADDLW  C1
08B8A:  MOVLB  7
08B8C:  MOVWF  x40
08B8E:  MOVLW  04
08B90:  ADDWFC 02,W
08B92:  MOVWF  x41
08B94:  MOVFF  FE8,565
08B98:  MOVFF  740,564
08B9C:  MOVLW  89
08B9E:  MOVWF  FE9
08BA0:  MOVFF  112,746
08BA4:  MOVFF  111,745
08BA8:  MOVFF  110,744
08BAC:  MOVFF  10F,743
08BB0:  MOVLW  03
08BB2:  MOVWF  x47
08BB4:  MOVLB  0
08BB6:  CALL   576E
08BBA:  MOVLW  2C
08BBC:  MOVLB  7
08BBE:  MOVWF  x50
08BC0:  MOVLB  0
08BC2:  CALL   55D0
....................    }
08BC6:  BRA    8EA4
....................    else if (0 == strcmp(s_3V3D, arg1)) {
08BC8:  MOVFF  734,742
08BCC:  MOVFF  733,741
08BD0:  MOVFF  70C,744
08BD4:  MOVFF  70B,743
08BD8:  CALL   5B0A
08BDC:  MOVF   01,F
08BDE:  BNZ   8C36
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3D);
08BE0:  MOVLW  04
08BE2:  MOVLB  7
08BE4:  MOVWF  x42
08BE6:  MOVLW  C1
08BE8:  MOVWF  x41
08BEA:  MOVLB  0
08BEC:  CALL   5598
08BF0:  MOVFF  02,03
08BF4:  MOVF   01,W
08BF6:  ADDLW  C1
08BF8:  MOVLB  7
08BFA:  MOVWF  x40
08BFC:  MOVLW  04
08BFE:  ADDWFC 02,W
08C00:  MOVWF  x41
08C02:  MOVFF  FE8,565
08C06:  MOVFF  740,564
08C0A:  MOVLW  89
08C0C:  MOVWF  FE9
08C0E:  MOVFF  116,746
08C12:  MOVFF  115,745
08C16:  MOVFF  114,744
08C1A:  MOVFF  113,743
08C1E:  MOVLW  03
08C20:  MOVWF  x47
08C22:  MOVLB  0
08C24:  CALL   576E
08C28:  MOVLW  2C
08C2A:  MOVLB  7
08C2C:  MOVWF  x50
08C2E:  MOVLB  0
08C30:  CALL   55D0
....................    }
08C34:  BRA    8EA4
....................    else if (0 == strcmp(s_all, arg1)) {
08C36:  MOVFF  73B,742
08C3A:  MOVFF  73A,741
08C3E:  MOVFF  70C,744
08C42:  MOVFF  70B,743
08C46:  CALL   5B0A
08C4A:  MOVF   01,F
08C4C:  BTFSS  FD8.2
08C4E:  BRA    8E9E
....................       sprintf(retData+strlen(retData), "%.2f,", monitorVals.vN15);
08C50:  MOVLW  04
08C52:  MOVLB  7
08C54:  MOVWF  x42
08C56:  MOVLW  C1
08C58:  MOVWF  x41
08C5A:  MOVLB  0
08C5C:  CALL   5598
08C60:  MOVFF  02,03
08C64:  MOVF   01,W
08C66:  ADDLW  C1
08C68:  MOVLB  7
08C6A:  MOVWF  x40
08C6C:  MOVLW  04
08C6E:  ADDWFC 02,W
08C70:  MOVWF  x41
08C72:  MOVFF  FE8,565
08C76:  MOVFF  740,564
08C7A:  MOVLW  89
08C7C:  MOVWF  FE9
08C7E:  MOVFF  FE,746
08C82:  MOVFF  FD,745
08C86:  MOVFF  FC,744
08C8A:  MOVFF  FB,743
08C8E:  MOVLW  02
08C90:  MOVWF  x47
08C92:  MOVLB  0
08C94:  CALL   576E
08C98:  MOVLW  2C
08C9A:  MOVLB  7
08C9C:  MOVWF  x50
08C9E:  MOVLB  0
08CA0:  CALL   55D0
....................       sprintf(retData+strlen(retData), "%.1f,", monitorVals.v200);
08CA4:  MOVLW  04
08CA6:  MOVLB  7
08CA8:  MOVWF  x42
08CAA:  MOVLW  C1
08CAC:  MOVWF  x41
08CAE:  MOVLB  0
08CB0:  CALL   5598
08CB4:  MOVFF  02,03
08CB8:  MOVF   01,W
08CBA:  ADDLW  C1
08CBC:  MOVLB  7
08CBE:  MOVWF  x40
08CC0:  MOVLW  04
08CC2:  ADDWFC 02,W
08CC4:  MOVWF  x41
08CC6:  MOVFF  FE8,565
08CCA:  MOVFF  740,564
08CCE:  MOVLW  89
08CD0:  MOVWF  FE9
08CD2:  MOVFF  102,746
08CD6:  MOVFF  101,745
08CDA:  MOVFF  100,744
08CDE:  MOVFF  FF,743
08CE2:  MOVLW  01
08CE4:  MOVWF  x47
08CE6:  MOVLB  0
08CE8:  CALL   576E
08CEC:  MOVLW  2C
08CEE:  MOVLB  7
08CF0:  MOVWF  x50
08CF2:  MOVLB  0
08CF4:  CALL   55D0
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5V6);
08CF8:  MOVLW  04
08CFA:  MOVLB  7
08CFC:  MOVWF  x42
08CFE:  MOVLW  C1
08D00:  MOVWF  x41
08D02:  MOVLB  0
08D04:  CALL   5598
08D08:  MOVFF  02,03
08D0C:  MOVF   01,W
08D0E:  ADDLW  C1
08D10:  MOVLB  7
08D12:  MOVWF  x40
08D14:  MOVLW  04
08D16:  ADDWFC 02,W
08D18:  MOVWF  x41
08D1A:  MOVFF  FE8,565
08D1E:  MOVFF  740,564
08D22:  MOVLW  89
08D24:  MOVWF  FE9
08D26:  MOVFF  106,746
08D2A:  MOVFF  105,745
08D2E:  MOVFF  104,744
08D32:  MOVFF  103,743
08D36:  MOVLW  03
08D38:  MOVWF  x47
08D3A:  MOVLB  0
08D3C:  CALL   576E
08D40:  MOVLW  2C
08D42:  MOVLB  7
08D44:  MOVWF  x50
08D46:  MOVLB  0
08D48:  CALL   55D0
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5VA);
08D4C:  MOVLW  04
08D4E:  MOVLB  7
08D50:  MOVWF  x42
08D52:  MOVLW  C1
08D54:  MOVWF  x41
08D56:  MOVLB  0
08D58:  CALL   5598
08D5C:  MOVFF  02,03
08D60:  MOVF   01,W
08D62:  ADDLW  C1
08D64:  MOVLB  7
08D66:  MOVWF  x40
08D68:  MOVLW  04
08D6A:  ADDWFC 02,W
08D6C:  MOVWF  x41
08D6E:  MOVFF  FE8,565
08D72:  MOVFF  740,564
08D76:  MOVLW  89
08D78:  MOVWF  FE9
08D7A:  MOVFF  10A,746
08D7E:  MOVFF  109,745
08D82:  MOVFF  108,744
08D86:  MOVFF  107,743
08D8A:  MOVLW  03
08D8C:  MOVWF  x47
08D8E:  MOVLB  0
08D90:  CALL   576E
08D94:  MOVLW  2C
08D96:  MOVLB  7
08D98:  MOVWF  x50
08D9A:  MOVLB  0
08D9C:  CALL   55D0
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V6X);
08DA0:  MOVLW  04
08DA2:  MOVLB  7
08DA4:  MOVWF  x42
08DA6:  MOVLW  C1
08DA8:  MOVWF  x41
08DAA:  MOVLB  0
08DAC:  CALL   5598
08DB0:  MOVFF  02,03
08DB4:  MOVF   01,W
08DB6:  ADDLW  C1
08DB8:  MOVLB  7
08DBA:  MOVWF  x40
08DBC:  MOVLW  04
08DBE:  ADDWFC 02,W
08DC0:  MOVWF  x41
08DC2:  MOVFF  FE8,565
08DC6:  MOVFF  740,564
08DCA:  MOVLW  89
08DCC:  MOVWF  FE9
08DCE:  MOVFF  10E,746
08DD2:  MOVFF  10D,745
08DD6:  MOVFF  10C,744
08DDA:  MOVFF  10B,743
08DDE:  MOVLW  03
08DE0:  MOVWF  x47
08DE2:  MOVLB  0
08DE4:  CALL   576E
08DE8:  MOVLW  2C
08DEA:  MOVLB  7
08DEC:  MOVWF  x50
08DEE:  MOVLB  0
08DF0:  CALL   55D0
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3A);
08DF4:  MOVLW  04
08DF6:  MOVLB  7
08DF8:  MOVWF  x42
08DFA:  MOVLW  C1
08DFC:  MOVWF  x41
08DFE:  MOVLB  0
08E00:  CALL   5598
08E04:  MOVFF  02,03
08E08:  MOVF   01,W
08E0A:  ADDLW  C1
08E0C:  MOVLB  7
08E0E:  MOVWF  x40
08E10:  MOVLW  04
08E12:  ADDWFC 02,W
08E14:  MOVWF  x41
08E16:  MOVFF  FE8,565
08E1A:  MOVFF  740,564
08E1E:  MOVLW  89
08E20:  MOVWF  FE9
08E22:  MOVFF  112,746
08E26:  MOVFF  111,745
08E2A:  MOVFF  110,744
08E2E:  MOVFF  10F,743
08E32:  MOVLW  03
08E34:  MOVWF  x47
08E36:  MOVLB  0
08E38:  CALL   576E
08E3C:  MOVLW  2C
08E3E:  MOVLB  7
08E40:  MOVWF  x50
08E42:  MOVLB  0
08E44:  CALL   55D0
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3D);
08E48:  MOVLW  04
08E4A:  MOVLB  7
08E4C:  MOVWF  x42
08E4E:  MOVLW  C1
08E50:  MOVWF  x41
08E52:  MOVLB  0
08E54:  CALL   5598
08E58:  MOVFF  02,03
08E5C:  MOVF   01,W
08E5E:  ADDLW  C1
08E60:  MOVLB  7
08E62:  MOVWF  x40
08E64:  MOVLW  04
08E66:  ADDWFC 02,W
08E68:  MOVWF  x41
08E6A:  MOVFF  FE8,565
08E6E:  MOVFF  740,564
08E72:  MOVLW  89
08E74:  MOVWF  FE9
08E76:  MOVFF  116,746
08E7A:  MOVFF  115,745
08E7E:  MOVFF  114,744
08E82:  MOVFF  113,743
08E86:  MOVLW  03
08E88:  MOVWF  x47
08E8A:  MOVLB  0
08E8C:  CALL   576E
08E90:  MOVLW  2C
08E92:  MOVLB  7
08E94:  MOVWF  x50
08E96:  MOVLB  0
08E98:  CALL   55D0
....................    }
08E9C:  BRA    8EA4
....................    else return INV_PARAM;
08E9E:  MOVLW  02
08EA0:  MOVWF  01
08EA2:  BRA    8EA8
....................    
....................    return SUCCESS;
08EA4:  MOVLW  00
08EA6:  MOVWF  01
08EA8:  RETURN 0
.................... }
.................... 
.................... int8 getPIDdata(unsigned int8 rec){
....................   /*** ARG CHECKS ********************/ 
....................    int8 arg1;
....................    char *arg2;
....................    char *s_PV = "PV";
08EAA:  MOVLW  50
08EAC:  MOVLB  7
08EAE:  MOVWF  x10
08EB0:  MOVLW  56
08EB2:  MOVWF  x11
08EB4:  CLRF   x12
08EB6:  MOVLW  07
08EB8:  MOVWF  x0F
08EBA:  MOVLW  10
08EBC:  MOVWF  x0E
....................    char *s_CV = "CV";
08EBE:  MOVLW  43
08EC0:  MOVWF  x15
08EC2:  MOVLW  56
08EC4:  MOVWF  x16
08EC6:  CLRF   x17
08EC8:  MOVLW  07
08ECA:  MOVWF  x14
08ECC:  MOVLW  15
08ECE:  MOVWF  x13
....................    char *s_PVold = "PVold";
08ED0:  MOVLW  50
08ED2:  MOVWF  x1A
08ED4:  MOVLW  56
08ED6:  MOVWF  x1B
08ED8:  MOVLW  6F
08EDA:  MOVWF  x1C
08EDC:  MOVLW  6C
08EDE:  MOVWF  x1D
08EE0:  MOVLW  64
08EE2:  MOVWF  x1E
08EE4:  CLRF   x1F
08EE6:  MOVLW  07
08EE8:  MOVWF  x19
08EEA:  MOVLW  1A
08EEC:  MOVWF  x18
....................    char *s_I = "I";
08EEE:  MOVLW  49
08EF0:  MOVWF  x22
08EF2:  CLRF   x23
08EF4:  MOVLW  07
08EF6:  MOVWF  x21
08EF8:  MOVLW  22
08EFA:  MOVWF  x20
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
08EFC:  CLRF   x42
08EFE:  MOVFF  690,741
08F02:  CLRF   x44
08F04:  MOVLW  B5
08F06:  MOVWF  x43
08F08:  MOVLB  0
08F0A:  CALL   08B6
08F0E:  MOVFF  02,725
08F12:  MOVFF  01,724
08F16:  MOVLW  06
08F18:  MOVLB  7
08F1A:  ADDWF  x24,F
08F1C:  MOVLW  00
08F1E:  ADDWFC x25,F
08F20:  MOVLW  32
08F22:  ADDWF  x24,W
08F24:  MOVWF  01
08F26:  MOVLW  00
08F28:  ADDWFC x25,W
08F2A:  MOVWF  03
08F2C:  MOVF   01,W
08F2E:  ADDLW  EB
08F30:  MOVWF  01
08F32:  MOVLW  01
08F34:  ADDWFC 03,F
08F36:  MOVFF  01,724
08F3A:  MOVFF  03,725
08F3E:  MOVFF  03,734
08F42:  MOVFF  01,733
08F46:  MOVLB  0
08F48:  CALL   5C2A
08F4C:  MOVF   01,F
08F4E:  BNZ   8F58
08F50:  MOVLW  02
08F52:  MOVWF  01
08F54:  BRA    92EE
08F56:  BRA    8FB6
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
08F58:  MOVLB  7
08F5A:  CLRF   x42
08F5C:  MOVFF  690,741
08F60:  CLRF   x44
08F62:  MOVLW  B5
08F64:  MOVWF  x43
08F66:  MOVLB  0
08F68:  CALL   08B6
08F6C:  MOVFF  02,725
08F70:  MOVFF  01,724
08F74:  MOVLW  06
08F76:  MOVLB  7
08F78:  ADDWF  x24,F
08F7A:  MOVLW  00
08F7C:  ADDWFC x25,F
08F7E:  MOVLW  32
08F80:  ADDWF  x24,W
08F82:  MOVWF  01
08F84:  MOVLW  00
08F86:  ADDWFC x25,W
08F88:  MOVWF  03
08F8A:  MOVF   01,W
08F8C:  ADDLW  EB
08F8E:  MOVWF  01
08F90:  MOVLW  01
08F92:  ADDWFC 03,F
08F94:  MOVFF  01,724
08F98:  MOVFF  03,725
08F9C:  MOVFF  03,734
08FA0:  MOVFF  01,733
08FA4:  CLRF   x36
08FA6:  CLRF   x35
08FA8:  MOVLW  0A
08FAA:  MOVWF  x37
08FAC:  MOVLB  0
08FAE:  CALL   5D1A
08FB2:  MOVFF  01,70B
....................    
....................    arg2 = SERcmd[rec].p[3];
08FB6:  MOVLB  7
08FB8:  CLRF   x42
08FBA:  MOVFF  690,741
08FBE:  CLRF   x44
08FC0:  MOVLW  B5
08FC2:  MOVWF  x43
08FC4:  MOVLB  0
08FC6:  CALL   08B6
08FCA:  MOVFF  02,725
08FCE:  MOVFF  01,724
08FD2:  MOVLW  06
08FD4:  MOVLB  7
08FD6:  ADDWF  x24,F
08FD8:  MOVLW  00
08FDA:  ADDWFC x25,F
08FDC:  MOVLW  4B
08FDE:  ADDWF  x24,W
08FE0:  MOVWF  01
08FE2:  MOVLW  00
08FE4:  ADDWFC x25,W
08FE6:  MOVWF  03
08FE8:  MOVF   01,W
08FEA:  ADDLW  EB
08FEC:  MOVWF  01
08FEE:  MOVLW  01
08FF0:  ADDWFC 03,F
08FF2:  MOVFF  01,70C
08FF6:  MOVFF  03,70D
....................    
....................    /*** GET PV, CV, PVold, I, or A(LL) VALUE **********/
....................    if      (0 == strcmp(s_PV, arg2))     sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].PV);
08FFA:  MOVFF  70F,742
08FFE:  MOVFF  70E,741
09002:  MOVFF  70D,744
09006:  MOVFF  70C,743
0900A:  MOVLB  0
0900C:  CALL   5B0A
09010:  MOVF   01,F
09012:  BNZ   90B6
09014:  MOVLW  04
09016:  MOVLB  7
09018:  MOVWF  x42
0901A:  MOVLW  C1
0901C:  MOVWF  x41
0901E:  MOVLB  0
09020:  CALL   5598
09024:  MOVF   01,W
09026:  ADDLW  C1
09028:  MOVLB  7
0902A:  MOVWF  x24
0902C:  MOVLW  04
0902E:  ADDWFC 02,W
09030:  MOVWF  x25
09032:  MOVLW  01
09034:  SUBWF  x0B,W
09036:  MULLW  28
09038:  MOVF   FF3,W
0903A:  CLRF   x27
0903C:  MOVWF  x26
0903E:  MOVLW  10
09040:  ADDWF  x26,W
09042:  MOVWF  01
09044:  MOVLW  00
09046:  ADDWFC x27,W
09048:  MOVWF  03
0904A:  MOVF   01,W
0904C:  ADDLW  20
0904E:  MOVWF  FE9
09050:  MOVLW  00
09052:  ADDWFC 03,W
09054:  MOVWF  FEA
09056:  MOVFF  FEF,726
0905A:  MOVFF  FEC,727
0905E:  MOVFF  FEC,728
09062:  MOVFF  FEC,729
09066:  MOVFF  725,565
0906A:  MOVFF  724,564
0906E:  MOVFF  70B,734
09072:  MOVLW  18
09074:  MOVWF  x35
09076:  MOVLB  0
09078:  CALL   606E
0907C:  MOVLW  2C
0907E:  MOVLB  7
09080:  MOVWF  x50
09082:  MOVLB  0
09084:  CALL   55D0
09088:  MOVLW  89
0908A:  MOVWF  FE9
0908C:  MOVFF  729,746
09090:  MOVFF  728,745
09094:  MOVFF  727,744
09098:  MOVFF  726,743
0909C:  MOVLW  02
0909E:  MOVLB  7
090A0:  MOVWF  x47
090A2:  MOVLB  0
090A4:  CALL   576E
090A8:  MOVLW  2C
090AA:  MOVLB  7
090AC:  MOVWF  x50
090AE:  MOVLB  0
090B0:  CALL   55D0
090B4:  BRA    92EA
....................    else if (0 == strcmp(s_CV, arg2))     sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].CV);
090B6:  MOVFF  714,742
090BA:  MOVFF  713,741
090BE:  MOVFF  70D,744
090C2:  MOVFF  70C,743
090C6:  CALL   5B0A
090CA:  MOVF   01,F
090CC:  BNZ   9170
090CE:  MOVLW  04
090D0:  MOVLB  7
090D2:  MOVWF  x42
090D4:  MOVLW  C1
090D6:  MOVWF  x41
090D8:  MOVLB  0
090DA:  CALL   5598
090DE:  MOVF   01,W
090E0:  ADDLW  C1
090E2:  MOVLB  7
090E4:  MOVWF  x24
090E6:  MOVLW  04
090E8:  ADDWFC 02,W
090EA:  MOVWF  x25
090EC:  MOVLW  01
090EE:  SUBWF  x0B,W
090F0:  MULLW  28
090F2:  MOVF   FF3,W
090F4:  CLRF   x27
090F6:  MOVWF  x26
090F8:  MOVLW  18
090FA:  ADDWF  x26,W
090FC:  MOVWF  01
090FE:  MOVLW  00
09100:  ADDWFC x27,W
09102:  MOVWF  03
09104:  MOVF   01,W
09106:  ADDLW  20
09108:  MOVWF  FE9
0910A:  MOVLW  00
0910C:  ADDWFC 03,W
0910E:  MOVWF  FEA
09110:  MOVFF  FEF,726
09114:  MOVFF  FEC,727
09118:  MOVFF  FEC,728
0911C:  MOVFF  FEC,729
09120:  MOVFF  725,565
09124:  MOVFF  724,564
09128:  MOVFF  70B,734
0912C:  MOVLW  18
0912E:  MOVWF  x35
09130:  MOVLB  0
09132:  CALL   606E
09136:  MOVLW  2C
09138:  MOVLB  7
0913A:  MOVWF  x50
0913C:  MOVLB  0
0913E:  CALL   55D0
09142:  MOVLW  89
09144:  MOVWF  FE9
09146:  MOVFF  729,746
0914A:  MOVFF  728,745
0914E:  MOVFF  727,744
09152:  MOVFF  726,743
09156:  MOVLW  02
09158:  MOVLB  7
0915A:  MOVWF  x47
0915C:  MOVLB  0
0915E:  CALL   576E
09162:  MOVLW  2C
09164:  MOVLB  7
09166:  MOVWF  x50
09168:  MOVLB  0
0916A:  CALL   55D0
0916E:  BRA    92EA
....................    else if (0 == strcmp(s_PVold, arg2))  sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].PVold);
09170:  MOVFF  719,742
09174:  MOVFF  718,741
09178:  MOVFF  70D,744
0917C:  MOVFF  70C,743
09180:  CALL   5B0A
09184:  MOVF   01,F
09186:  BNZ   922A
09188:  MOVLW  04
0918A:  MOVLB  7
0918C:  MOVWF  x42
0918E:  MOVLW  C1
09190:  MOVWF  x41
09192:  MOVLB  0
09194:  CALL   5598
09198:  MOVF   01,W
0919A:  ADDLW  C1
0919C:  MOVLB  7
0919E:  MOVWF  x24
091A0:  MOVLW  04
091A2:  ADDWFC 02,W
091A4:  MOVWF  x25
091A6:  MOVLW  01
091A8:  SUBWF  x0B,W
091AA:  MULLW  28
091AC:  MOVF   FF3,W
091AE:  CLRF   x27
091B0:  MOVWF  x26
091B2:  MOVLW  14
091B4:  ADDWF  x26,W
091B6:  MOVWF  01
091B8:  MOVLW  00
091BA:  ADDWFC x27,W
091BC:  MOVWF  03
091BE:  MOVF   01,W
091C0:  ADDLW  20
091C2:  MOVWF  FE9
091C4:  MOVLW  00
091C6:  ADDWFC 03,W
091C8:  MOVWF  FEA
091CA:  MOVFF  FEF,726
091CE:  MOVFF  FEC,727
091D2:  MOVFF  FEC,728
091D6:  MOVFF  FEC,729
091DA:  MOVFF  725,565
091DE:  MOVFF  724,564
091E2:  MOVFF  70B,734
091E6:  MOVLW  18
091E8:  MOVWF  x35
091EA:  MOVLB  0
091EC:  CALL   606E
091F0:  MOVLW  2C
091F2:  MOVLB  7
091F4:  MOVWF  x50
091F6:  MOVLB  0
091F8:  CALL   55D0
091FC:  MOVLW  89
091FE:  MOVWF  FE9
09200:  MOVFF  729,746
09204:  MOVFF  728,745
09208:  MOVFF  727,744
0920C:  MOVFF  726,743
09210:  MOVLW  02
09212:  MOVLB  7
09214:  MOVWF  x47
09216:  MOVLB  0
09218:  CALL   576E
0921C:  MOVLW  2C
0921E:  MOVLB  7
09220:  MOVWF  x50
09222:  MOVLB  0
09224:  CALL   55D0
09228:  BRA    92EA
....................    else if (0 == strcmp(s_I, arg2))      sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].I);
0922A:  MOVFF  721,742
0922E:  MOVFF  720,741
09232:  MOVFF  70D,744
09236:  MOVFF  70C,743
0923A:  CALL   5B0A
0923E:  MOVF   01,F
09240:  BNZ   92E4
09242:  MOVLW  04
09244:  MOVLB  7
09246:  MOVWF  x42
09248:  MOVLW  C1
0924A:  MOVWF  x41
0924C:  MOVLB  0
0924E:  CALL   5598
09252:  MOVF   01,W
09254:  ADDLW  C1
09256:  MOVLB  7
09258:  MOVWF  x24
0925A:  MOVLW  04
0925C:  ADDWFC 02,W
0925E:  MOVWF  x25
09260:  MOVLW  01
09262:  SUBWF  x0B,W
09264:  MULLW  28
09266:  MOVF   FF3,W
09268:  CLRF   x27
0926A:  MOVWF  x26
0926C:  MOVLW  1C
0926E:  ADDWF  x26,W
09270:  MOVWF  01
09272:  MOVLW  00
09274:  ADDWFC x27,W
09276:  MOVWF  03
09278:  MOVF   01,W
0927A:  ADDLW  20
0927C:  MOVWF  FE9
0927E:  MOVLW  00
09280:  ADDWFC 03,W
09282:  MOVWF  FEA
09284:  MOVFF  FEF,726
09288:  MOVFF  FEC,727
0928C:  MOVFF  FEC,728
09290:  MOVFF  FEC,729
09294:  MOVFF  725,565
09298:  MOVFF  724,564
0929C:  MOVFF  70B,734
092A0:  MOVLW  18
092A2:  MOVWF  x35
092A4:  MOVLB  0
092A6:  CALL   606E
092AA:  MOVLW  2C
092AC:  MOVLB  7
092AE:  MOVWF  x50
092B0:  MOVLB  0
092B2:  CALL   55D0
092B6:  MOVLW  89
092B8:  MOVWF  FE9
092BA:  MOVFF  729,746
092BE:  MOVFF  728,745
092C2:  MOVFF  727,744
092C6:  MOVFF  726,743
092CA:  MOVLW  02
092CC:  MOVLB  7
092CE:  MOVWF  x47
092D0:  MOVLB  0
092D2:  CALL   576E
092D6:  MOVLW  2C
092D8:  MOVLB  7
092DA:  MOVWF  x50
092DC:  MOVLB  0
092DE:  CALL   55D0
092E2:  BRA    92EA
....................    else return INV_PARAM;
092E4:  MOVLW  02
092E6:  MOVWF  01
092E8:  BRA    92EE
....................    
....................    return SUCCESS;
092EA:  MOVLW  00
092EC:  MOVWF  01
092EE:  RETURN 0
.................... }
.................... 
.................... int8 getIPdata(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char *arg2;
....................    char *s_raw = "raw";
*
0940E:  MOVLW  72
09410:  MOVLB  7
09412:  MOVWF  x10
09414:  MOVLW  61
09416:  MOVWF  x11
09418:  MOVLW  77
0941A:  MOVWF  x12
0941C:  CLRF   x13
0941E:  MOVLW  07
09420:  MOVWF  x0F
09422:  MOVLW  10
09424:  MOVWF  x0E
....................    char *s_calibrated = "calib";
09426:  MOVLW  63
09428:  MOVWF  x16
0942A:  MOVLW  61
0942C:  MOVWF  x17
0942E:  MOVLW  6C
09430:  MOVWF  x18
09432:  MOVLW  69
09434:  MOVWF  x19
09436:  MOVLW  62
09438:  MOVWF  x1A
0943A:  CLRF   x1B
0943C:  MOVLW  07
0943E:  MOVWF  x15
09440:  MOVLW  16
09442:  MOVWF  x14
....................    char *s_p0 = "p0";
09444:  MOVLW  70
09446:  MOVWF  x1E
09448:  MOVLW  30
0944A:  MOVWF  x1F
0944C:  CLRF   x20
0944E:  MOVLW  07
09450:  MOVWF  x1D
09452:  MOVLW  1E
09454:  MOVWF  x1C
....................    char *s_poles = "poles";
09456:  MOVLW  70
09458:  MOVWF  x23
0945A:  MOVLW  6F
0945C:  MOVWF  x24
0945E:  MOVLW  6C
09460:  MOVWF  x25
09462:  MOVLW  65
09464:  MOVWF  x26
09466:  MOVLW  73
09468:  MOVWF  x27
0946A:  CLRF   x28
0946C:  MOVLW  07
0946E:  MOVWF  x22
09470:  MOVLW  23
09472:  MOVWF  x21
....................    char *s_real = "real";
09474:  MOVLW  72
09476:  MOVWF  x2B
09478:  MOVLW  65
0947A:  MOVWF  x2C
0947C:  MOVLW  61
0947E:  MOVWF  x2D
09480:  MOVLW  6C
09482:  MOVWF  x2E
09484:  CLRF   x2F
09486:  MOVLW  07
09488:  MOVWF  x2A
0948A:  MOVLW  2B
0948C:  MOVWF  x29
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0948E:  CLRF   x42
09490:  MOVFF  690,741
09494:  CLRF   x44
09496:  MOVLW  B5
09498:  MOVWF  x43
0949A:  MOVLB  0
0949C:  CALL   08B6
094A0:  MOVFF  02,731
094A4:  MOVFF  01,730
094A8:  MOVLW  06
094AA:  MOVLB  7
094AC:  ADDWF  x30,F
094AE:  MOVLW  00
094B0:  ADDWFC x31,F
094B2:  MOVLW  32
094B4:  ADDWF  x30,W
094B6:  MOVWF  01
094B8:  MOVLW  00
094BA:  ADDWFC x31,W
094BC:  MOVWF  03
094BE:  MOVF   01,W
094C0:  ADDLW  EB
094C2:  MOVWF  01
094C4:  MOVLW  01
094C6:  ADDWFC 03,F
094C8:  MOVFF  01,730
094CC:  MOVFF  03,731
094D0:  MOVFF  03,734
094D4:  MOVFF  01,733
094D8:  MOVLB  0
094DA:  CALL   5C2A
094DE:  MOVF   01,F
094E0:  BNZ   94EA
094E2:  MOVLW  02
094E4:  MOVWF  01
094E6:  BRA    9B2E
094E8:  BRA    9548
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
094EA:  MOVLB  7
094EC:  CLRF   x42
094EE:  MOVFF  690,741
094F2:  CLRF   x44
094F4:  MOVLW  B5
094F6:  MOVWF  x43
094F8:  MOVLB  0
094FA:  CALL   08B6
094FE:  MOVFF  02,731
09502:  MOVFF  01,730
09506:  MOVLW  06
09508:  MOVLB  7
0950A:  ADDWF  x30,F
0950C:  MOVLW  00
0950E:  ADDWFC x31,F
09510:  MOVLW  32
09512:  ADDWF  x30,W
09514:  MOVWF  01
09516:  MOVLW  00
09518:  ADDWFC x31,W
0951A:  MOVWF  03
0951C:  MOVF   01,W
0951E:  ADDLW  EB
09520:  MOVWF  01
09522:  MOVLW  01
09524:  ADDWFC 03,F
09526:  MOVFF  01,730
0952A:  MOVFF  03,731
0952E:  MOVFF  03,734
09532:  MOVFF  01,733
09536:  CLRF   x36
09538:  CLRF   x35
0953A:  MOVLW  0A
0953C:  MOVWF  x37
0953E:  MOVLB  0
09540:  CALL   5D1A
09544:  MOVFF  01,70B
....................    
....................    arg2 = SERcmd[rec].p[3];
09548:  MOVLB  7
0954A:  CLRF   x42
0954C:  MOVFF  690,741
09550:  CLRF   x44
09552:  MOVLW  B5
09554:  MOVWF  x43
09556:  MOVLB  0
09558:  CALL   08B6
0955C:  MOVFF  02,731
09560:  MOVFF  01,730
09564:  MOVLW  06
09566:  MOVLB  7
09568:  ADDWF  x30,F
0956A:  MOVLW  00
0956C:  ADDWFC x31,F
0956E:  MOVLW  4B
09570:  ADDWF  x30,W
09572:  MOVWF  01
09574:  MOVLW  00
09576:  ADDWFC x31,W
09578:  MOVWF  03
0957A:  MOVF   01,W
0957C:  ADDLW  EB
0957E:  MOVWF  01
09580:  MOVLW  01
09582:  ADDWFC 03,F
09584:  MOVFF  01,70C
09588:  MOVFF  03,70D
....................    
....................    /*** GET INPUT DATA ****************/
....................    if      (0 == strcmp(s_raw, arg2)) {
0958C:  MOVFF  70F,742
09590:  MOVFF  70E,741
09594:  MOVFF  70D,744
09598:  MOVFF  70C,743
0959C:  MOVLB  0
0959E:  CALL   5B0A
095A2:  MOVF   01,F
095A4:  BTFSS  FD8.2
095A6:  BRA    9722
....................       sprintf(retData+strlen(retData), "%d,", arg1);
095A8:  MOVLW  04
095AA:  MOVLB  7
095AC:  MOVWF  x42
095AE:  MOVLW  C1
095B0:  MOVWF  x41
095B2:  MOVLB  0
095B4:  CALL   5598
095B8:  MOVFF  02,03
095BC:  MOVF   01,W
095BE:  ADDLW  C1
095C0:  MOVLB  7
095C2:  MOVWF  x30
095C4:  MOVLW  04
095C6:  ADDWFC 02,W
095C8:  MOVWF  x31
095CA:  MOVFF  FE8,565
095CE:  MOVFF  730,564
095D2:  MOVFF  70B,734
095D6:  MOVLW  18
095D8:  MOVWF  x35
095DA:  MOVLB  0
095DC:  CALL   606E
095E0:  MOVLW  2C
095E2:  MOVLB  7
095E4:  MOVWF  x50
095E6:  MOVLB  0
095E8:  CALL   55D0
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].sinRaw);
095EC:  MOVLW  04
095EE:  MOVLB  7
095F0:  MOVWF  x42
095F2:  MOVLW  C1
095F4:  MOVWF  x41
095F6:  MOVLB  0
095F8:  CALL   5598
095FC:  MOVFF  02,03
09600:  MOVF   01,W
09602:  ADDLW  C1
09604:  MOVLB  7
09606:  MOVWF  x30
09608:  MOVLW  04
0960A:  ADDWFC 02,W
0960C:  MOVWF  x31
0960E:  MOVLW  01
09610:  SUBWF  x0B,W
09612:  MULLW  26
09614:  MOVF   FF3,W
09616:  CLRF   x33
09618:  MOVWF  x32
0961A:  MOVLW  17
0961C:  ADDWF  x32,W
0961E:  MOVWF  FE9
09620:  MOVLW  01
09622:  ADDWFC x33,W
09624:  MOVWF  FEA
09626:  MOVFF  FEF,750
0962A:  MOVFF  FEC,01
0962E:  MOVFF  FEC,02
09632:  MOVFF  FEC,03
09636:  MOVFF  03,753
0963A:  MOVFF  02,752
0963E:  MOVFF  01,751
09642:  MOVLB  0
09644:  CALL   5698
09648:  MOVFF  03,737
0964C:  MOVFF  02,736
09650:  MOVFF  01,735
09654:  MOVFF  00,734
09658:  MOVFF  731,565
0965C:  MOVFF  730,564
09660:  MOVLW  41
09662:  MOVWF  FE9
09664:  MOVFF  03,73C
09668:  MOVFF  02,73B
0966C:  MOVFF  01,73A
09670:  MOVFF  00,739
09674:  RCALL  92F0
09676:  MOVLW  2C
09678:  MOVLB  7
0967A:  MOVWF  x50
0967C:  MOVLB  0
0967E:  CALL   55D0
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].cosRaw);
09682:  MOVLW  04
09684:  MOVLB  7
09686:  MOVWF  x42
09688:  MOVLW  C1
0968A:  MOVWF  x41
0968C:  MOVLB  0
0968E:  CALL   5598
09692:  MOVF   01,W
09694:  ADDLW  C1
09696:  MOVLB  7
09698:  MOVWF  x30
0969A:  MOVLW  04
0969C:  ADDWFC 02,W
0969E:  MOVWF  x31
096A0:  MOVLW  01
096A2:  SUBWF  x0B,W
096A4:  MULLW  26
096A6:  MOVF   FF3,W
096A8:  CLRF   x33
096AA:  MOVWF  x32
096AC:  MOVLW  04
096AE:  ADDWF  x32,W
096B0:  MOVWF  01
096B2:  MOVLW  00
096B4:  ADDWFC x33,W
096B6:  MOVWF  03
096B8:  MOVF   01,W
096BA:  ADDLW  17
096BC:  MOVWF  FE9
096BE:  MOVLW  01
096C0:  ADDWFC 03,W
096C2:  MOVWF  FEA
096C4:  MOVFF  FEF,750
096C8:  MOVFF  FEC,01
096CC:  MOVFF  FEC,02
096D0:  MOVFF  FEC,03
096D4:  MOVFF  03,753
096D8:  MOVFF  02,752
096DC:  MOVFF  01,751
096E0:  MOVLB  0
096E2:  CALL   5698
096E6:  MOVFF  03,735
096EA:  MOVFF  02,734
096EE:  MOVFF  01,733
096F2:  MOVFF  00,732
096F6:  MOVFF  731,565
096FA:  MOVFF  730,564
096FE:  MOVLW  41
09700:  MOVWF  FE9
09702:  MOVFF  03,73C
09706:  MOVFF  02,73B
0970A:  MOVFF  01,73A
0970E:  MOVFF  00,739
09712:  RCALL  92F0
09714:  MOVLW  2C
09716:  MOVLB  7
09718:  MOVWF  x50
0971A:  MOVLB  0
0971C:  CALL   55D0
....................    }
09720:  BRA    9B2A
....................    else if (0 == strcmp(s_calibrated, arg2)) {
09722:  MOVFF  715,742
09726:  MOVFF  714,741
0972A:  MOVFF  70D,744
0972E:  MOVFF  70C,743
09732:  CALL   5B0A
09736:  MOVF   01,F
09738:  BTFSS  FD8.2
0973A:  BRA    98BE
....................       sprintf(retData+strlen(retData), "%d,", arg1);
0973C:  MOVLW  04
0973E:  MOVLB  7
09740:  MOVWF  x42
09742:  MOVLW  C1
09744:  MOVWF  x41
09746:  MOVLB  0
09748:  CALL   5598
0974C:  MOVFF  02,03
09750:  MOVF   01,W
09752:  ADDLW  C1
09754:  MOVLB  7
09756:  MOVWF  x30
09758:  MOVLW  04
0975A:  ADDWFC 02,W
0975C:  MOVWF  x31
0975E:  MOVFF  FE8,565
09762:  MOVFF  730,564
09766:  MOVFF  70B,734
0976A:  MOVLW  18
0976C:  MOVWF  x35
0976E:  MOVLB  0
09770:  CALL   606E
09774:  MOVLW  2C
09776:  MOVLB  7
09778:  MOVWF  x50
0977A:  MOVLB  0
0977C:  CALL   55D0
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].sinCounts);
09780:  MOVLW  04
09782:  MOVLB  7
09784:  MOVWF  x42
09786:  MOVLW  C1
09788:  MOVWF  x41
0978A:  MOVLB  0
0978C:  CALL   5598
09790:  MOVF   01,W
09792:  ADDLW  C1
09794:  MOVLB  7
09796:  MOVWF  x30
09798:  MOVLW  04
0979A:  ADDWFC 02,W
0979C:  MOVWF  x31
0979E:  MOVLW  01
097A0:  SUBWF  x0B,W
097A2:  MULLW  26
097A4:  MOVF   FF3,W
097A6:  CLRF   x33
097A8:  MOVWF  x32
097AA:  MOVLW  08
097AC:  ADDWF  x32,W
097AE:  MOVWF  01
097B0:  MOVLW  00
097B2:  ADDWFC x33,W
097B4:  MOVWF  03
097B6:  MOVF   01,W
097B8:  ADDLW  17
097BA:  MOVWF  FE9
097BC:  MOVLW  01
097BE:  ADDWFC 03,W
097C0:  MOVWF  FEA
097C2:  MOVFF  FEF,750
097C6:  MOVFF  FEC,01
097CA:  MOVFF  FEC,02
097CE:  MOVFF  FEC,03
097D2:  MOVFF  03,753
097D6:  MOVFF  02,752
097DA:  MOVFF  01,751
097DE:  MOVLB  0
097E0:  CALL   5698
097E4:  MOVFF  03,735
097E8:  MOVFF  02,734
097EC:  MOVFF  01,733
097F0:  MOVFF  00,732
097F4:  MOVFF  731,565
097F8:  MOVFF  730,564
097FC:  MOVLW  41
097FE:  MOVWF  FE9
09800:  MOVFF  03,73C
09804:  MOVFF  02,73B
09808:  MOVFF  01,73A
0980C:  MOVFF  00,739
09810:  RCALL  92F0
09812:  MOVLW  2C
09814:  MOVLB  7
09816:  MOVWF  x50
09818:  MOVLB  0
0981A:  CALL   55D0
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].cosCounts);
0981E:  MOVLW  04
09820:  MOVLB  7
09822:  MOVWF  x42
09824:  MOVLW  C1
09826:  MOVWF  x41
09828:  MOVLB  0
0982A:  CALL   5598
0982E:  MOVF   01,W
09830:  ADDLW  C1
09832:  MOVLB  7
09834:  MOVWF  x30
09836:  MOVLW  04
09838:  ADDWFC 02,W
0983A:  MOVWF  x31
0983C:  MOVLW  01
0983E:  SUBWF  x0B,W
09840:  MULLW  26
09842:  MOVF   FF3,W
09844:  CLRF   x33
09846:  MOVWF  x32
09848:  MOVLW  0C
0984A:  ADDWF  x32,W
0984C:  MOVWF  01
0984E:  MOVLW  00
09850:  ADDWFC x33,W
09852:  MOVWF  03
09854:  MOVF   01,W
09856:  ADDLW  17
09858:  MOVWF  FE9
0985A:  MOVLW  01
0985C:  ADDWFC 03,W
0985E:  MOVWF  FEA
09860:  MOVFF  FEF,750
09864:  MOVFF  FEC,01
09868:  MOVFF  FEC,02
0986C:  MOVFF  FEC,03
09870:  MOVFF  03,753
09874:  MOVFF  02,752
09878:  MOVFF  01,751
0987C:  MOVLB  0
0987E:  CALL   5698
09882:  MOVFF  03,735
09886:  MOVFF  02,734
0988A:  MOVFF  01,733
0988E:  MOVFF  00,732
09892:  MOVFF  731,565
09896:  MOVFF  730,564
0989A:  MOVLW  41
0989C:  MOVWF  FE9
0989E:  MOVFF  03,73C
098A2:  MOVFF  02,73B
098A6:  MOVFF  01,73A
098AA:  MOVFF  00,739
098AE:  RCALL  92F0
098B0:  MOVLW  2C
098B2:  MOVLB  7
098B4:  MOVWF  x50
098B6:  MOVLB  0
098B8:  CALL   55D0
....................    }
098BC:  BRA    9B2A
....................    else if (0 == strcmp(s_p0, arg2)) {
098BE:  MOVFF  71D,742
098C2:  MOVFF  71C,741
098C6:  MOVFF  70D,744
098CA:  MOVFF  70C,743
098CE:  CALL   5B0A
098D2:  MOVF   01,F
098D4:  BNZ   9990
....................       sprintf(retData+strlen(retData), "%d,", arg1);
098D6:  MOVLW  04
098D8:  MOVLB  7
098DA:  MOVWF  x42
098DC:  MOVLW  C1
098DE:  MOVWF  x41
098E0:  MOVLB  0
098E2:  CALL   5598
098E6:  MOVFF  02,03
098EA:  MOVF   01,W
098EC:  ADDLW  C1
098EE:  MOVLB  7
098F0:  MOVWF  x30
098F2:  MOVLW  04
098F4:  ADDWFC 02,W
098F6:  MOVWF  x31
098F8:  MOVFF  FE8,565
098FC:  MOVFF  730,564
09900:  MOVFF  70B,734
09904:  MOVLW  18
09906:  MOVWF  x35
09908:  MOVLB  0
0990A:  CALL   606E
0990E:  MOVLW  2C
09910:  MOVLB  7
09912:  MOVWF  x50
09914:  MOVLB  0
09916:  CALL   55D0
....................       sprintf(retData+strlen(retData), "%f,", adcVals[arg1-1].p0);
0991A:  MOVLW  04
0991C:  MOVLB  7
0991E:  MOVWF  x42
09920:  MOVLW  C1
09922:  MOVWF  x41
09924:  MOVLB  0
09926:  CALL   5598
0992A:  MOVF   01,W
0992C:  ADDLW  C1
0992E:  MOVLB  7
09930:  MOVWF  x30
09932:  MOVLW  04
09934:  ADDWFC 02,W
09936:  MOVWF  x31
09938:  MOVLW  01
0993A:  SUBWF  x0B,W
0993C:  MULLW  26
0993E:  MOVF   FF3,W
09940:  CLRF   x33
09942:  MOVWF  x32
09944:  MOVLW  18
09946:  ADDWF  x32,W
09948:  MOVWF  01
0994A:  MOVLW  00
0994C:  ADDWFC x33,W
0994E:  MOVWF  03
09950:  MOVF   01,W
09952:  ADDLW  17
09954:  MOVWF  FE9
09956:  MOVLW  01
09958:  ADDWFC 03,W
0995A:  MOVWF  FEA
0995C:  MOVFF  FEF,743
09960:  MOVFF  FEC,744
09964:  MOVFF  FEC,745
09968:  MOVFF  FEC,746
0996C:  MOVFF  731,565
09970:  MOVFF  730,564
09974:  MOVLW  89
09976:  MOVWF  FE9
09978:  MOVLW  02
0997A:  MOVWF  x47
0997C:  MOVLB  0
0997E:  CALL   576E
09982:  MOVLW  2C
09984:  MOVLB  7
09986:  MOVWF  x50
09988:  MOVLB  0
0998A:  CALL   55D0
....................    }
0998E:  BRA    9B2A
....................    else if (0 == strcmp(s_poles, arg2)) {
09990:  MOVFF  722,742
09994:  MOVFF  721,741
09998:  MOVFF  70D,744
0999C:  MOVFF  70C,743
099A0:  CALL   5B0A
099A4:  MOVF   01,F
099A6:  BNZ   9A52
....................       sprintf(retData+strlen(retData), "%d,", arg1);
099A8:  MOVLW  04
099AA:  MOVLB  7
099AC:  MOVWF  x42
099AE:  MOVLW  C1
099B0:  MOVWF  x41
099B2:  MOVLB  0
099B4:  CALL   5598
099B8:  MOVFF  02,03
099BC:  MOVF   01,W
099BE:  ADDLW  C1
099C0:  MOVLB  7
099C2:  MOVWF  x30
099C4:  MOVLW  04
099C6:  ADDWFC 02,W
099C8:  MOVWF  x31
099CA:  MOVFF  FE8,565
099CE:  MOVFF  730,564
099D2:  MOVFF  70B,734
099D6:  MOVLW  18
099D8:  MOVWF  x35
099DA:  MOVLB  0
099DC:  CALL   606E
099E0:  MOVLW  2C
099E2:  MOVLB  7
099E4:  MOVWF  x50
099E6:  MOVLB  0
099E8:  CALL   55D0
....................       sprintf(retData+strlen(retData), "%d,", adcVals[arg1-1].npoles);
099EC:  MOVLW  04
099EE:  MOVLB  7
099F0:  MOVWF  x42
099F2:  MOVLW  C1
099F4:  MOVWF  x41
099F6:  MOVLB  0
099F8:  CALL   5598
099FC:  MOVF   01,W
099FE:  ADDLW  C1
09A00:  MOVLB  7
09A02:  MOVWF  x30
09A04:  MOVLW  04
09A06:  ADDWFC 02,W
09A08:  MOVWF  x31
09A0A:  MOVLW  01
09A0C:  SUBWF  x0B,W
09A0E:  MULLW  26
09A10:  MOVF   FF3,W
09A12:  CLRF   x33
09A14:  MOVWF  x32
09A16:  MOVLW  1C
09A18:  ADDWF  x32,W
09A1A:  MOVWF  01
09A1C:  MOVLW  00
09A1E:  ADDWFC x33,W
09A20:  MOVWF  03
09A22:  MOVF   01,W
09A24:  ADDLW  17
09A26:  MOVWF  FE9
09A28:  MOVLW  01
09A2A:  ADDWFC 03,W
09A2C:  MOVWF  FEA
09A2E:  MOVFF  FEF,734
09A32:  MOVFF  731,565
09A36:  MOVFF  730,564
09A3A:  MOVLW  18
09A3C:  MOVWF  x35
09A3E:  MOVLB  0
09A40:  CALL   606E
09A44:  MOVLW  2C
09A46:  MOVLB  7
09A48:  MOVWF  x50
09A4A:  MOVLB  0
09A4C:  CALL   55D0
....................    }
09A50:  BRA    9B2A
....................    else if (0 == strcmp(s_real, arg2)) {
09A52:  MOVFF  72A,742
09A56:  MOVFF  729,741
09A5A:  MOVFF  70D,744
09A5E:  MOVFF  70C,743
09A62:  CALL   5B0A
09A66:  MOVF   01,F
09A68:  BNZ   9B24
....................       sprintf(retData+strlen(retData), "%d,", arg1);
09A6A:  MOVLW  04
09A6C:  MOVLB  7
09A6E:  MOVWF  x42
09A70:  MOVLW  C1
09A72:  MOVWF  x41
09A74:  MOVLB  0
09A76:  CALL   5598
09A7A:  MOVFF  02,03
09A7E:  MOVF   01,W
09A80:  ADDLW  C1
09A82:  MOVLB  7
09A84:  MOVWF  x30
09A86:  MOVLW  04
09A88:  ADDWFC 02,W
09A8A:  MOVWF  x31
09A8C:  MOVFF  FE8,565
09A90:  MOVFF  730,564
09A94:  MOVFF  70B,734
09A98:  MOVLW  18
09A9A:  MOVWF  x35
09A9C:  MOVLB  0
09A9E:  CALL   606E
09AA2:  MOVLW  2C
09AA4:  MOVLB  7
09AA6:  MOVWF  x50
09AA8:  MOVLB  0
09AAA:  CALL   55D0
....................       sprintf(retData+strlen(retData), "%f,", adcVals[arg1-1].pReal);
09AAE:  MOVLW  04
09AB0:  MOVLB  7
09AB2:  MOVWF  x42
09AB4:  MOVLW  C1
09AB6:  MOVWF  x41
09AB8:  MOVLB  0
09ABA:  CALL   5598
09ABE:  MOVF   01,W
09AC0:  ADDLW  C1
09AC2:  MOVLB  7
09AC4:  MOVWF  x30
09AC6:  MOVLW  04
09AC8:  ADDWFC 02,W
09ACA:  MOVWF  x31
09ACC:  MOVLW  01
09ACE:  SUBWF  x0B,W
09AD0:  MULLW  26
09AD2:  MOVF   FF3,W
09AD4:  CLRF   x33
09AD6:  MOVWF  x32
09AD8:  MOVLW  1D
09ADA:  ADDWF  x32,W
09ADC:  MOVWF  01
09ADE:  MOVLW  00
09AE0:  ADDWFC x33,W
09AE2:  MOVWF  03
09AE4:  MOVF   01,W
09AE6:  ADDLW  17
09AE8:  MOVWF  FE9
09AEA:  MOVLW  01
09AEC:  ADDWFC 03,W
09AEE:  MOVWF  FEA
09AF0:  MOVFF  FEF,743
09AF4:  MOVFF  FEC,744
09AF8:  MOVFF  FEC,745
09AFC:  MOVFF  FEC,746
09B00:  MOVFF  731,565
09B04:  MOVFF  730,564
09B08:  MOVLW  89
09B0A:  MOVWF  FE9
09B0C:  MOVLW  02
09B0E:  MOVWF  x47
09B10:  MOVLB  0
09B12:  CALL   576E
09B16:  MOVLW  2C
09B18:  MOVLB  7
09B1A:  MOVWF  x50
09B1C:  MOVLB  0
09B1E:  CALL   55D0
....................    }
09B22:  BRA    9B2A
....................    else return INV_PARAM;
09B24:  MOVLW  02
09B26:  MOVWF  01
09B28:  BRA    9B2E
....................    
....................    return SUCCESS;
09B2A:  MOVLW  00
09B2C:  MOVWF  01
09B2E:  RETURN 0
.................... }
.................... 
.................... int8 getManOPvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
09B30:  MOVLB  7
09B32:  CLRF   x42
09B34:  MOVFF  690,741
09B38:  CLRF   x44
09B3A:  MOVLW  B5
09B3C:  MOVWF  x43
09B3E:  MOVLB  0
09B40:  CALL   08B6
09B44:  MOVFF  02,70D
09B48:  MOVFF  01,70C
09B4C:  MOVLW  06
09B4E:  MOVLB  7
09B50:  ADDWF  x0C,F
09B52:  MOVLW  00
09B54:  ADDWFC x0D,F
09B56:  MOVLW  32
09B58:  ADDWF  x0C,W
09B5A:  MOVWF  01
09B5C:  MOVLW  00
09B5E:  ADDWFC x0D,W
09B60:  MOVWF  03
09B62:  MOVF   01,W
09B64:  ADDLW  EB
09B66:  MOVWF  01
09B68:  MOVLW  01
09B6A:  ADDWFC 03,F
09B6C:  MOVFF  01,70C
09B70:  MOVFF  03,70D
09B74:  MOVFF  03,734
09B78:  MOVFF  01,733
09B7C:  MOVLB  0
09B7E:  CALL   5C2A
09B82:  MOVF   01,F
09B84:  BNZ   9B8E
09B86:  MOVLW  02
09B88:  MOVWF  01
09B8A:  BRA    9C90
09B8C:  BRA    9BEC
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
09B8E:  MOVLB  7
09B90:  CLRF   x42
09B92:  MOVFF  690,741
09B96:  CLRF   x44
09B98:  MOVLW  B5
09B9A:  MOVWF  x43
09B9C:  MOVLB  0
09B9E:  CALL   08B6
09BA2:  MOVFF  02,70D
09BA6:  MOVFF  01,70C
09BAA:  MOVLW  06
09BAC:  MOVLB  7
09BAE:  ADDWF  x0C,F
09BB0:  MOVLW  00
09BB2:  ADDWFC x0D,F
09BB4:  MOVLW  32
09BB6:  ADDWF  x0C,W
09BB8:  MOVWF  01
09BBA:  MOVLW  00
09BBC:  ADDWFC x0D,W
09BBE:  MOVWF  03
09BC0:  MOVF   01,W
09BC2:  ADDLW  EB
09BC4:  MOVWF  01
09BC6:  MOVLW  01
09BC8:  ADDWFC 03,F
09BCA:  MOVFF  01,70C
09BCE:  MOVFF  03,70D
09BD2:  MOVFF  03,734
09BD6:  MOVFF  01,733
09BDA:  CLRF   x36
09BDC:  CLRF   x35
09BDE:  MOVLW  0A
09BE0:  MOVWF  x37
09BE2:  MOVLB  0
09BE4:  CALL   5D1A
09BE8:  MOVFF  01,70B
....................    
....................    /*** GET MANUAL OUTPUT VALUE ***************/ 
....................    sprintf(retData+strlen(retData), "%d,%f,", arg1, dacVals[arg1-1].opPcnt);
09BEC:  MOVLW  04
09BEE:  MOVLB  7
09BF0:  MOVWF  x42
09BF2:  MOVLW  C1
09BF4:  MOVWF  x41
09BF6:  MOVLB  0
09BF8:  CALL   5598
09BFC:  MOVF   01,W
09BFE:  ADDLW  C1
09C00:  MOVLB  7
09C02:  MOVWF  x0C
09C04:  MOVLW  04
09C06:  ADDWFC 02,W
09C08:  MOVWF  x0D
09C0A:  MOVLW  01
09C0C:  SUBWF  x0B,W
09C0E:  MULLW  07
09C10:  MOVF   FF3,W
09C12:  CLRF   x0F
09C14:  MOVWF  x0E
09C16:  MOVLW  03
09C18:  ADDWF  x0E,W
09C1A:  MOVWF  01
09C1C:  MOVLW  00
09C1E:  ADDWFC x0F,W
09C20:  MOVWF  03
09C22:  MOVF   01,W
09C24:  ADDLW  64
09C26:  MOVWF  FE9
09C28:  MOVLW  01
09C2A:  ADDWFC 03,W
09C2C:  MOVWF  FEA
09C2E:  MOVFF  FEF,70E
09C32:  MOVFF  FEC,70F
09C36:  MOVFF  FEC,710
09C3A:  MOVFF  FEC,711
09C3E:  MOVFF  70D,565
09C42:  MOVFF  70C,564
09C46:  MOVFF  70B,734
09C4A:  MOVLW  18
09C4C:  MOVWF  x35
09C4E:  MOVLB  0
09C50:  CALL   606E
09C54:  MOVLW  2C
09C56:  MOVLB  7
09C58:  MOVWF  x50
09C5A:  MOVLB  0
09C5C:  CALL   55D0
09C60:  MOVLW  89
09C62:  MOVWF  FE9
09C64:  MOVFF  711,746
09C68:  MOVFF  710,745
09C6C:  MOVFF  70F,744
09C70:  MOVFF  70E,743
09C74:  MOVLW  02
09C76:  MOVLB  7
09C78:  MOVWF  x47
09C7A:  MOVLB  0
09C7C:  CALL   576E
09C80:  MOVLW  2C
09C82:  MOVLB  7
09C84:  MOVWF  x50
09C86:  MOVLB  0
09C88:  CALL   55D0
....................    
....................    return SUCCESS;
09C8C:  MOVLW  00
09C8E:  MOVWF  01
09C90:  RETURN 0
.................... }
.................... 
.................... int8 setManOPvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    float arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
09C92:  MOVLB  7
09C94:  CLRF   x42
09C96:  MOVFF  690,741
09C9A:  CLRF   x44
09C9C:  MOVLW  B5
09C9E:  MOVWF  x43
09CA0:  MOVLB  0
09CA2:  CALL   08B6
09CA6:  MOVFF  02,711
09CAA:  MOVFF  01,710
09CAE:  MOVLW  06
09CB0:  MOVLB  7
09CB2:  ADDWF  x10,F
09CB4:  MOVLW  00
09CB6:  ADDWFC x11,F
09CB8:  MOVLW  32
09CBA:  ADDWF  x10,W
09CBC:  MOVWF  01
09CBE:  MOVLW  00
09CC0:  ADDWFC x11,W
09CC2:  MOVWF  03
09CC4:  MOVF   01,W
09CC6:  ADDLW  EB
09CC8:  MOVWF  01
09CCA:  MOVLW  01
09CCC:  ADDWFC 03,F
09CCE:  MOVFF  01,710
09CD2:  MOVFF  03,711
09CD6:  MOVFF  03,734
09CDA:  MOVFF  01,733
09CDE:  MOVLB  0
09CE0:  CALL   5C2A
09CE4:  MOVF   01,F
09CE6:  BNZ   9CF0
09CE8:  MOVLW  02
09CEA:  MOVWF  01
09CEC:  BRA    9F02
09CEE:  BRA    9D4E
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
09CF0:  MOVLB  7
09CF2:  CLRF   x42
09CF4:  MOVFF  690,741
09CF8:  CLRF   x44
09CFA:  MOVLW  B5
09CFC:  MOVWF  x43
09CFE:  MOVLB  0
09D00:  CALL   08B6
09D04:  MOVFF  02,711
09D08:  MOVFF  01,710
09D0C:  MOVLW  06
09D0E:  MOVLB  7
09D10:  ADDWF  x10,F
09D12:  MOVLW  00
09D14:  ADDWFC x11,F
09D16:  MOVLW  32
09D18:  ADDWF  x10,W
09D1A:  MOVWF  01
09D1C:  MOVLW  00
09D1E:  ADDWFC x11,W
09D20:  MOVWF  03
09D22:  MOVF   01,W
09D24:  ADDLW  EB
09D26:  MOVWF  01
09D28:  MOVLW  01
09D2A:  ADDWFC 03,F
09D2C:  MOVFF  01,710
09D30:  MOVFF  03,711
09D34:  MOVFF  03,734
09D38:  MOVFF  01,733
09D3C:  CLRF   x36
09D3E:  CLRF   x35
09D40:  MOVLW  0A
09D42:  MOVWF  x37
09D44:  MOVLB  0
09D46:  CALL   5D1A
09D4A:  MOVFF  01,70B
....................    
....................    if (!arg_is_float(SERcmd[rec].p[3])) return INV_PARAM;
09D4E:  MOVLB  7
09D50:  CLRF   x42
09D52:  MOVFF  690,741
09D56:  CLRF   x44
09D58:  MOVLW  B5
09D5A:  MOVWF  x43
09D5C:  MOVLB  0
09D5E:  CALL   08B6
09D62:  MOVFF  02,711
09D66:  MOVFF  01,710
09D6A:  MOVLW  06
09D6C:  MOVLB  7
09D6E:  ADDWF  x10,F
09D70:  MOVLW  00
09D72:  ADDWFC x11,F
09D74:  MOVLW  4B
09D76:  ADDWF  x10,W
09D78:  MOVWF  01
09D7A:  MOVLW  00
09D7C:  ADDWFC x11,W
09D7E:  MOVWF  03
09D80:  MOVF   01,W
09D82:  ADDLW  EB
09D84:  MOVWF  01
09D86:  MOVLW  01
09D88:  ADDWFC 03,F
09D8A:  MOVFF  01,710
09D8E:  MOVFF  03,711
09D92:  MOVFF  03,715
09D96:  MOVFF  01,714
09D9A:  MOVLB  0
09D9C:  CALL   6D3E
09DA0:  MOVF   01,F
09DA2:  BNZ   9DAC
09DA4:  MOVLW  02
09DA6:  MOVWF  01
09DA8:  BRA    9F02
09DAA:  BRA    9E12
....................    else arg2 = strtod(SERcmd[rec].p[3], '\0');
09DAC:  MOVLB  7
09DAE:  CLRF   x42
09DB0:  MOVFF  690,741
09DB4:  CLRF   x44
09DB6:  MOVLW  B5
09DB8:  MOVWF  x43
09DBA:  MOVLB  0
09DBC:  CALL   08B6
09DC0:  MOVFF  02,711
09DC4:  MOVFF  01,710
09DC8:  MOVLW  06
09DCA:  MOVLB  7
09DCC:  ADDWF  x10,F
09DCE:  MOVLW  00
09DD0:  ADDWFC x11,F
09DD2:  MOVLW  4B
09DD4:  ADDWF  x10,W
09DD6:  MOVWF  01
09DD8:  MOVLW  00
09DDA:  ADDWFC x11,W
09DDC:  MOVWF  03
09DDE:  MOVF   01,W
09DE0:  ADDLW  EB
09DE2:  MOVWF  01
09DE4:  MOVLW  01
09DE6:  ADDWFC 03,F
09DE8:  MOVFF  01,710
09DEC:  MOVFF  03,711
09DF0:  MOVFF  03,715
09DF4:  MOVFF  01,714
09DF8:  CLRF   x17
09DFA:  CLRF   x16
09DFC:  MOVLB  0
09DFE:  CALL   6E00
09E02:  MOVFF  03,70F
09E06:  MOVFF  02,70E
09E0A:  MOVFF  01,70D
09E0E:  MOVFF  00,70C
....................    
....................    /*** SET MANUAL OUTPUT VALUE ***************/
....................    if (arg2 > op_upper_bound) dacVals[arg1-1].opPcnt = op_upper_bound;
09E12:  MOVLB  7
09E14:  CLRF   x49
09E16:  CLRF   x48
09E18:  MOVLW  7C
09E1A:  MOVWF  x47
09E1C:  MOVLW  84
09E1E:  MOVWF  x46
09E20:  MOVFF  70F,74D
09E24:  MOVFF  70E,74C
09E28:  MOVFF  70D,74B
09E2C:  MOVFF  70C,74A
09E30:  MOVLB  0
09E32:  CALL   1D2C
09E36:  BNC   9E6C
09E38:  MOVLW  01
09E3A:  MOVLB  7
09E3C:  SUBWF  x0B,W
09E3E:  MULLW  07
09E40:  MOVF   FF3,W
09E42:  CLRF   x11
09E44:  MOVWF  x10
09E46:  MOVLW  03
09E48:  ADDWF  x10,W
09E4A:  MOVWF  01
09E4C:  MOVLW  00
09E4E:  ADDWFC x11,W
09E50:  MOVWF  03
09E52:  MOVF   01,W
09E54:  ADDLW  64
09E56:  MOVWF  FE9
09E58:  MOVLW  01
09E5A:  ADDWFC 03,W
09E5C:  MOVWF  FEA
09E5E:  MOVLW  84
09E60:  MOVWF  FEF
09E62:  MOVLW  7C
09E64:  MOVWF  FEC
09E66:  CLRF   FEC
09E68:  CLRF   FEC
09E6A:  BRA    9EFC
....................    else if (arg2 < op_lower_bound) dacVals[arg1-1].opPcnt = op_lower_bound;  
09E6C:  MOVFF  70F,749
09E70:  MOVFF  70E,748
09E74:  MOVFF  70D,747
09E78:  MOVFF  70C,746
09E7C:  MOVLB  7
09E7E:  CLRF   x4D
09E80:  CLRF   x4C
09E82:  MOVLW  C0
09E84:  MOVWF  x4B
09E86:  MOVLW  82
09E88:  MOVWF  x4A
09E8A:  MOVLB  0
09E8C:  CALL   1D2C
09E90:  BNC   9EC6
09E92:  MOVLW  01
09E94:  MOVLB  7
09E96:  SUBWF  x0B,W
09E98:  MULLW  07
09E9A:  MOVF   FF3,W
09E9C:  CLRF   x11
09E9E:  MOVWF  x10
09EA0:  MOVLW  03
09EA2:  ADDWF  x10,W
09EA4:  MOVWF  01
09EA6:  MOVLW  00
09EA8:  ADDWFC x11,W
09EAA:  MOVWF  03
09EAC:  MOVF   01,W
09EAE:  ADDLW  64
09EB0:  MOVWF  FE9
09EB2:  MOVLW  01
09EB4:  ADDWFC 03,W
09EB6:  MOVWF  FEA
09EB8:  MOVLW  82
09EBA:  MOVWF  FEF
09EBC:  MOVLW  C0
09EBE:  MOVWF  FEC
09EC0:  CLRF   FEC
09EC2:  CLRF   FEC
09EC4:  BRA    9EFC
....................    else dacVals[arg1-1].opPcnt = arg2;
09EC6:  MOVLW  01
09EC8:  MOVLB  7
09ECA:  SUBWF  x0B,W
09ECC:  MULLW  07
09ECE:  MOVF   FF3,W
09ED0:  CLRF   x11
09ED2:  MOVWF  x10
09ED4:  MOVLW  03
09ED6:  ADDWF  x10,W
09ED8:  MOVWF  01
09EDA:  MOVLW  00
09EDC:  ADDWFC x11,W
09EDE:  MOVWF  03
09EE0:  MOVF   01,W
09EE2:  ADDLW  64
09EE4:  MOVWF  FE9
09EE6:  MOVLW  01
09EE8:  ADDWFC 03,W
09EEA:  MOVWF  FEA
09EEC:  MOVFF  70C,FEF
09EF0:  MOVFF  70D,FEC
09EF4:  MOVFF  70E,FEC
09EF8:  MOVFF  70F,FEC
....................    
....................    return SUCCESS;
09EFC:  MOVLW  00
09EFE:  MOVWF  01
09F00:  MOVLB  0
09F02:  RETURN 0
.................... }
.................... 
.................... int8 setFilterOn(unsigned int8 rec){
....................    adcFilter = TRUE;
09F04:  MOVLB  1
09F06:  BSF    x63.0
....................    return SUCCESS;
09F08:  MOVLW  00
09F0A:  MOVWF  01
09F0C:  MOVLB  0
09F0E:  RETURN 0
.................... }
.................... 
.................... int8 setFilterOff(unsigned int8 rec){
....................    adcFilter = FALSE;
09F10:  MOVLB  1
09F12:  BCF    x63.0
....................    return SUCCESS;
09F14:  MOVLW  00
09F16:  MOVWF  01
09F18:  MOVLB  0
09F1A:  RETURN 0
.................... }
.................... 
.................... int8 setHomeAxis(unsigned int8 rec){
....................     /*** ARG CHECKS ********************/
....................     int8 arg1;
....................     
....................     if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
09F1C:  MOVLB  7
09F1E:  CLRF   x42
09F20:  MOVFF  690,741
09F24:  CLRF   x44
09F26:  MOVLW  B5
09F28:  MOVWF  x43
09F2A:  MOVLB  0
09F2C:  CALL   08B6
09F30:  MOVFF  02,70D
09F34:  MOVFF  01,70C
09F38:  MOVLW  06
09F3A:  MOVLB  7
09F3C:  ADDWF  x0C,F
09F3E:  MOVLW  00
09F40:  ADDWFC x0D,F
09F42:  MOVLW  32
09F44:  ADDWF  x0C,W
09F46:  MOVWF  01
09F48:  MOVLW  00
09F4A:  ADDWFC x0D,W
09F4C:  MOVWF  03
09F4E:  MOVF   01,W
09F50:  ADDLW  EB
09F52:  MOVWF  01
09F54:  MOVLW  01
09F56:  ADDWFC 03,F
09F58:  MOVFF  01,70C
09F5C:  MOVFF  03,70D
09F60:  MOVFF  03,734
09F64:  MOVFF  01,733
09F68:  MOVLB  0
09F6A:  CALL   5C2A
09F6E:  MOVF   01,F
09F70:  BNZ   9F7A
09F72:  MOVLW  02
09F74:  MOVWF  01
09F76:  BRA    A006
09F78:  BRA    9FD8
....................     else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
09F7A:  MOVLB  7
09F7C:  CLRF   x42
09F7E:  MOVFF  690,741
09F82:  CLRF   x44
09F84:  MOVLW  B5
09F86:  MOVWF  x43
09F88:  MOVLB  0
09F8A:  CALL   08B6
09F8E:  MOVFF  02,70D
09F92:  MOVFF  01,70C
09F96:  MOVLW  06
09F98:  MOVLB  7
09F9A:  ADDWF  x0C,F
09F9C:  MOVLW  00
09F9E:  ADDWFC x0D,F
09FA0:  MOVLW  32
09FA2:  ADDWF  x0C,W
09FA4:  MOVWF  01
09FA6:  MOVLW  00
09FA8:  ADDWFC x0D,W
09FAA:  MOVWF  03
09FAC:  MOVF   01,W
09FAE:  ADDLW  EB
09FB0:  MOVWF  01
09FB2:  MOVLW  01
09FB4:  ADDWFC 03,F
09FB6:  MOVFF  01,70C
09FBA:  MOVFF  03,70D
09FBE:  MOVFF  03,734
09FC2:  MOVFF  01,733
09FC6:  CLRF   x36
09FC8:  CLRF   x35
09FCA:  MOVLW  0A
09FCC:  MOVWF  x37
09FCE:  MOVLB  0
09FD0:  CALL   5D1A
09FD4:  MOVFF  01,70B
....................     
....................     adcVals[arg1-1].homeFlag = TRUE;
09FD8:  MOVLW  01
09FDA:  MOVLB  7
09FDC:  SUBWF  x0B,W
09FDE:  MULLW  26
09FE0:  MOVF   FF3,W
09FE2:  CLRF   x0D
09FE4:  MOVWF  x0C
09FE6:  MOVLW  25
09FE8:  ADDWF  x0C,W
09FEA:  MOVWF  01
09FEC:  MOVLW  00
09FEE:  ADDWFC x0D,W
09FF0:  MOVWF  03
09FF2:  MOVF   01,W
09FF4:  ADDLW  17
09FF6:  MOVWF  FE9
09FF8:  MOVLW  01
09FFA:  ADDWFC 03,W
09FFC:  MOVWF  FEA
09FFE:  BSF    FEF.0
....................     
....................     return SUCCESS;
0A000:  MOVLW  00
0A002:  MOVWF  01
0A004:  MOVLB  0
0A006:  RETURN 0
.................... }
.................... 
.................... int8 invalidCmd(unsigned int8 rec){
....................    return INV_CMD;
0A008:  MOVLW  01
0A00A:  MOVWF  01
0A00C:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* ARG VALIDATION HELPER FUNCS                                               */
.................... /*****************************************************************************/
.................... BOOLEAN arg_is_float(char *arg){
*
06D3E:  MOVLB  7
06D40:  BCF    x16.0
....................    BOOLEAN decimal = FALSE;
....................    for (int i=0; i<strlen(arg); i++){
06D42:  CLRF   x17
06D44:  MOVFF  715,742
06D48:  MOVFF  714,741
06D4C:  MOVLB  0
06D4E:  CALL   5598
06D52:  MOVFF  02,03
06D56:  MOVF   01,W
06D58:  MOVF   03,F
06D5A:  BNZ   6D66
06D5C:  MOVF   01,W
06D5E:  MOVLB  7
06D60:  SUBWF  x17,W
06D62:  BC    6DF8
06D64:  MOVLB  0
....................       if (!isdigit(arg[i])){
06D66:  MOVLB  7
06D68:  MOVF   x17,W
06D6A:  ADDWF  x14,W
06D6C:  MOVWF  FE9
06D6E:  MOVLW  00
06D70:  ADDWFC x15,W
06D72:  MOVWF  FEA
06D74:  MOVFF  FEF,718
06D78:  MOVF   x18,W
06D7A:  SUBLW  2F
06D7C:  BC    6D84
06D7E:  MOVF   x18,W
06D80:  SUBLW  39
06D82:  BC    6DF0
....................          // Check for negative sign
....................          if ('-' != arg[i]){
06D84:  MOVF   x17,W
06D86:  ADDWF  x14,W
06D88:  MOVWF  FE9
06D8A:  MOVLW  00
06D8C:  ADDWFC x15,W
06D8E:  MOVWF  FEA
06D90:  MOVF   FEF,W
06D92:  SUBLW  2D
06D94:  BZ    6DC0
....................             // Check for decimal
....................             if ('.' != arg[i]) return FALSE;
06D96:  MOVF   x17,W
06D98:  ADDWF  x14,W
06D9A:  MOVWF  FE9
06D9C:  MOVLW  00
06D9E:  ADDWFC x15,W
06DA0:  MOVWF  FEA
06DA2:  MOVF   FEF,W
06DA4:  SUBLW  2E
06DA6:  BZ    6DB0
06DA8:  MOVLW  00
06DAA:  MOVWF  01
06DAC:  BRA    6DFC
06DAE:  BRA    6DBE
....................             else if  (decimal) return FALSE;
06DB0:  BTFSS  x16.0
06DB2:  BRA    6DBC
06DB4:  MOVLW  00
06DB6:  MOVWF  01
06DB8:  BRA    6DFC
06DBA:  BRA    6DBE
....................             else decimal = TRUE;
06DBC:  BSF    x16.0
....................          }
06DBE:  BRA    6DF0
....................          else if (0 != i) return FALSE;
06DC0:  MOVF   x17,F
06DC2:  BZ    6DCC
06DC4:  MOVLW  00
06DC6:  MOVWF  01
06DC8:  BRA    6DFC
06DCA:  BRA    6DF0
....................          else if (1 == strlen(arg)) return FALSE;
06DCC:  MOVFF  715,742
06DD0:  MOVFF  714,741
06DD4:  MOVLB  0
06DD6:  CALL   5598
06DDA:  MOVFF  02,03
06DDE:  MOVF   01,W
06DE0:  SUBLW  01
06DE2:  BNZ   6DF2
06DE4:  MOVF   03,F
06DE6:  BNZ   6DF2
06DE8:  MOVLW  00
06DEA:  MOVWF  01
06DEC:  MOVLB  7
06DEE:  BRA    6DFC
06DF0:  MOVLB  0
....................       }
06DF2:  MOVLB  7
06DF4:  INCF   x17,F
06DF6:  BRA    6D44
....................    }
....................    return TRUE;
06DF8:  MOVLW  01
06DFA:  MOVWF  01
06DFC:  MOVLB  0
06DFE:  RETURN 0
.................... }
.................... 
.................... BOOLEAN is_valid_channel(char *arg){
....................     if (1 != strlen(arg)) return FALSE;
*
05C2A:  MOVFF  734,742
05C2E:  MOVFF  733,741
05C32:  RCALL  5598
05C34:  MOVFF  02,03
05C38:  MOVF   01,W
05C3A:  SUBLW  01
05C3C:  BNZ   5C42
05C3E:  MOVF   03,F
05C40:  BZ    5C4A
05C42:  MOVLW  00
05C44:  MOVWF  01
05C46:  BRA    5C78
05C48:  BRA    5C70
....................     else if ('1' != arg[0] && '2' != arg[0]) return FALSE;
05C4A:  MOVLB  7
05C4C:  MOVFF  733,FE9
05C50:  MOVFF  734,FEA
05C54:  MOVF   FEF,W
05C56:  SUBLW  31
05C58:  BZ    5C72
05C5A:  MOVFF  733,FE9
05C5E:  MOVFF  734,FEA
05C62:  MOVF   FEF,W
05C64:  SUBLW  32
05C66:  BZ    5C72
05C68:  MOVLW  00
05C6A:  MOVWF  01
05C6C:  MOVLB  0
05C6E:  BRA    5C78
05C70:  MOVLB  7
....................     return TRUE;
05C72:  MOVLW  01
05C74:  MOVWF  01
05C76:  MOVLB  0
05C78:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* ASCII HEX CHARACTER TO INT                                                */
.................... /*****************************************************************************/
.................... int8 hex_to_int(char ascii){
....................    if (ascii >= '0' && ascii <= '9') return ascii-'0';
*
05AD0:  MOVLB  7
05AD2:  MOVF   x0A,W
05AD4:  SUBLW  2F
05AD6:  BC    5AE8
05AD8:  MOVF   x0A,W
05ADA:  SUBLW  39
05ADC:  BNC   5AE8
05ADE:  MOVLW  30
05AE0:  SUBWF  x0A,W
05AE2:  MOVWF  01
05AE4:  BRA    5B04
05AE6:  BRA    5B04
....................    else if (ascii >= 'A' && ascii <= 'F') return ascii-'A'+10;
05AE8:  MOVF   x0A,W
05AEA:  SUBLW  40
05AEC:  BC    5B00
05AEE:  MOVF   x0A,W
05AF0:  SUBLW  46
05AF2:  BNC   5B00
05AF4:  MOVLW  41
05AF6:  SUBWF  x0A,W
05AF8:  ADDLW  0A
05AFA:  MOVWF  01
05AFC:  BRA    5B04
05AFE:  BRA    5B04
....................    else return 0xFF;
05B00:  MOVLW  FF
05B02:  MOVWF  01
05B04:  MOVLB  0
05B06:  GOTO   A0B2 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* COMMAND HANDLER/PARSER FUNCS                                              */
.................... /*****************************************************************************/
.................... void echo_cmd(unsigned int8 rec){
....................    fprintf(SERIAL, "%c", SERcmd[rec].t);
....................    while (SERcmd[rec].recReadIndex <= SERcmd[rec].recWriteIndex)
....................    {
....................       if (SERcmd[rec].recReadIndex != 0) fprintf(SERIAL, "%c", delimiter);
....................       fprintf(SERIAL, "%s", SERcmd[rec].p[SERcmd[rec].recReadIndex]);
....................       SERcmd[rec].recReadIndex++;
....................    }
....................    SERcmd[rec].recReadIndex=0;
.................... }
.................... 
.................... int8 command_parser(unsigned int8 rec){
*
0A00E:  MOVLB  7
0A010:  CLRF   x42
0A012:  MOVFF  701,741
0A016:  CLRF   x44
0A018:  MOVLW  B5
0A01A:  MOVWF  x43
0A01C:  MOVLB  0
0A01E:  CALL   08B6
0A022:  MOVFF  02,70A
0A026:  MOVFF  01,709
0A02A:  MOVLW  06
0A02C:  MOVLB  7
0A02E:  ADDWF  x09,F
0A030:  MOVLW  00
0A032:  ADDWFC x0A,F
0A034:  MOVLW  EB
0A036:  ADDWF  x09,W
0A038:  MOVWF  01
0A03A:  MOVLW  01
0A03C:  ADDWFC x0A,W
0A03E:  MOVWF  03
0A040:  MOVFF  01,702
0A044:  MOVWF  x03
0A046:  CLRF   x42
0A048:  MOVFF  701,741
0A04C:  CLRF   x44
0A04E:  MOVLW  B5
0A050:  MOVWF  x43
0A052:  MOVLB  0
0A054:  CALL   08B6
0A058:  MOVFF  02,70C
0A05C:  MOVFF  01,70B
0A060:  MOVLW  06
0A062:  MOVLB  7
0A064:  ADDWF  x0B,F
0A066:  MOVLW  00
0A068:  ADDWFC x0C,F
0A06A:  MOVLW  19
0A06C:  ADDWF  x0B,W
0A06E:  MOVWF  01
0A070:  MOVLW  00
0A072:  ADDWFC x0C,W
0A074:  MOVWF  03
0A076:  MOVF   01,W
0A078:  ADDLW  EB
0A07A:  MOVWF  01
0A07C:  MOVLW  01
0A07E:  ADDWFC 03,F
0A080:  MOVFF  01,704
0A084:  MOVFF  03,705
0A088:  CLRF   x06
0A08A:  CLRF   x07
....................    char *cmd_adr = SERcmd[rec].p[0];
....................    char *cmd_str = SERcmd[rec].p[1];
.................... //!   int8 devID = input_a();
....................    int8 devID = 0;
....................    int8 i = 0;
....................    
....................    if (hwID == cmd_adr[0]){
0A08C:  MOVFF  702,FE9
0A090:  MOVFF  703,FEA
0A094:  MOVF   FEF,W
0A096:  SUBLW  44
0A098:  BTFSS  FD8.2
0A09A:  BRA    A18A
....................       if (hex_to_int(cmd_adr[1]) == (devID & 0x0F)){
0A09C:  MOVLW  01
0A09E:  ADDWF  x02,W
0A0A0:  MOVWF  FE9
0A0A2:  MOVLW  00
0A0A4:  ADDWFC x03,W
0A0A6:  MOVWF  FEA
0A0A8:  MOVFF  FEF,70A
0A0AC:  MOVLB  0
0A0AE:  GOTO   5AD0
0A0B2:  MOVFF  01,709
0A0B6:  MOVLB  7
0A0B8:  MOVF   x06,W
0A0BA:  ANDLW  0F
0A0BC:  SUBWF  01,W
0A0BE:  BNZ   A182
....................          while (0 != strlen(cmd_list[i].cmd_name)){
0A0C0:  MOVF   x07,W
0A0C2:  MULLW  04
0A0C4:  MOVF   FF3,W
0A0C6:  CLRF   x0A
0A0C8:  MOVWF  x09
0A0CA:  MOVLW  6A
0A0CC:  ADDWF  x09,W
0A0CE:  MOVWF  FE9
0A0D0:  MOVLW  05
0A0D2:  ADDWFC x0A,W
0A0D4:  MOVWF  FEA
0A0D6:  MOVFF  FEC,742
0A0DA:  MOVF   FED,F
0A0DC:  MOVFF  FEF,741
0A0E0:  MOVLB  0
0A0E2:  CALL   5598
0A0E6:  MOVFF  02,03
0A0EA:  MOVF   01,W
0A0EC:  BNZ   A0F2
0A0EE:  MOVF   03,F
0A0F0:  BZ    A178
....................             if (0 == strcmp(cmd_str, cmd_list[i].cmd_name))
0A0F2:  MOVLB  7
0A0F4:  MOVF   x07,W
0A0F6:  MULLW  04
0A0F8:  MOVF   FF3,W
0A0FA:  CLRF   x0A
0A0FC:  MOVWF  x09
0A0FE:  MOVLW  6A
0A100:  ADDWF  x09,W
0A102:  MOVWF  FE9
0A104:  MOVLW  05
0A106:  ADDWFC x0A,W
0A108:  MOVWF  FEA
0A10A:  MOVFF  FEC,744
0A10E:  MOVF   FED,F
0A110:  MOVFF  FEF,743
0A114:  MOVFF  705,742
0A118:  MOVFF  704,741
0A11C:  MOVLB  0
0A11E:  CALL   5B0A
0A122:  MOVF   01,F
0A124:  BNZ   A170
....................             {
....................                int8 return_code = cmd_list[i].cmd_func(rec);
0A126:  MOVLB  7
0A128:  MOVF   x07,W
0A12A:  MULLW  04
0A12C:  MOVF   FF3,W
0A12E:  CLRF   x0A
0A130:  MOVWF  x09
0A132:  MOVLW  02
0A134:  ADDWF  x09,W
0A136:  MOVWF  01
0A138:  MOVLW  00
0A13A:  ADDWFC x0A,W
0A13C:  MOVWF  03
0A13E:  MOVF   01,W
0A140:  ADDLW  6A
0A142:  MOVWF  01
0A144:  MOVLW  05
0A146:  ADDWFC 03,F
0A148:  MOVFF  01,709
0A14C:  MOVFF  03,70A
0A150:  MOVFF  03,FEA
0A154:  MOVFF  01,FE9
0A158:  MOVFF  701,690
0A15C:  MOVLB  0
0A15E:  CALL   00BC
0A162:  MOVFF  01,708
....................                return return_code;
0A166:  MOVLB  7
0A168:  MOVFF  708,01
0A16C:  BRA    A18E
0A16E:  MOVLB  0
....................             }
....................             i++;
0A170:  MOVLB  7
0A172:  INCF   x07,F
0A174:  BRA    A0C0
0A176:  MOVLB  0
....................          }
....................          return INV_CMD; // INVALID_CMD
0A178:  MOVLW  01
0A17A:  MOVWF  01
0A17C:  MOVLB  7
0A17E:  BRA    A18E
....................       } else return 254; // NOT THIS ADDRESS
0A180:  BRA    A188
0A182:  MOVLW  FE
0A184:  MOVWF  01
0A186:  BRA    A18E
....................    } else return 255; // NOT THIS DEVICE TYPE
0A188:  BRA    A18E
0A18A:  MOVLW  FF
0A18C:  MOVWF  01
0A18E:  MOVLB  0
0A190:  GOTO   A27C (RETURN)
.................... }
.................... 
.................... void command_handler_task(){
....................    while (getNextSERReadIndex())
*
0A1E0:  GOTO   5A52
0A1E4:  MOVF   01,F
0A1E6:  BTFSC  FD8.2
0A1E8:  BRA    A306
....................    {
....................       int8 return_code;
....................       //echo_cmd(SRI);
....................       sprintf(retData + strlen(retData), "$%s,", SERcmd[SRI].p[0]);
0A1EA:  MOVLW  04
0A1EC:  MOVLB  7
0A1EE:  MOVWF  x42
0A1F0:  MOVLW  C1
0A1F2:  MOVWF  x41
0A1F4:  MOVLB  0
0A1F6:  CALL   5598
0A1FA:  MOVFF  02,03
0A1FE:  MOVF   01,W
0A200:  ADDLW  C1
0A202:  MOVLB  7
0A204:  MOVWF  x00
0A206:  MOVLW  04
0A208:  ADDWFC 02,W
0A20A:  MOVWF  x01
0A20C:  CLRF   x42
0A20E:  MOVFF  4BF,741
0A212:  CLRF   x44
0A214:  MOVLW  B5
0A216:  MOVWF  x43
0A218:  MOVLB  0
0A21A:  CALL   08B6
0A21E:  MOVFF  02,703
0A222:  MOVFF  01,702
0A226:  MOVLW  06
0A228:  MOVLB  7
0A22A:  ADDWF  x02,F
0A22C:  MOVLW  00
0A22E:  ADDWFC x03,F
0A230:  MOVLW  EB
0A232:  ADDWF  x02,W
0A234:  MOVWF  01
0A236:  MOVLW  01
0A238:  ADDWFC x03,W
0A23A:  MOVWF  03
0A23C:  MOVFF  01,704
0A240:  MOVWF  x05
0A242:  MOVFF  701,565
0A246:  MOVFF  700,564
0A24A:  MOVLW  24
0A24C:  MOVWF  x50
0A24E:  MOVLB  0
0A250:  CALL   55D0
0A254:  MOVFF  565,FEA
0A258:  MOVFF  564,FE9
0A25C:  CLRF   FEF
0A25E:  MOVFF  705,FEA
0A262:  MOVFF  704,FE9
0A266:  CALL   5AAC
0A26A:  MOVLW  2C
0A26C:  MOVLB  7
0A26E:  MOVWF  x50
0A270:  MOVLB  0
0A272:  CALL   55D0
....................       
....................       return_code = command_parser(SRI);
0A276:  MOVFF  4BF,701
0A27A:  BRA    A00E
0A27C:  MOVFF  01,6FB
....................       
....................       sprintf(retData + strlen(retData), "%s", resp_list[return_code].msg);
0A280:  MOVLW  04
0A282:  MOVLB  7
0A284:  MOVWF  x42
0A286:  MOVLW  C1
0A288:  MOVWF  x41
0A28A:  MOVLB  0
0A28C:  CALL   5598
0A290:  MOVF   01,W
0A292:  ADDLW  C1
0A294:  MOVLB  7
0A296:  MOVWF  x00
0A298:  MOVLW  04
0A29A:  ADDWFC 02,W
0A29C:  MOVWF  x01
0A29E:  MOVLB  6
0A2A0:  MOVF   xFB,W
0A2A2:  MULLW  03
0A2A4:  MOVF   FF3,W
0A2A6:  MOVLB  7
0A2A8:  CLRF   x03
0A2AA:  MOVWF  x02
0A2AC:  MOVLW  01
0A2AE:  ADDWF  x02,W
0A2B0:  MOVWF  01
0A2B2:  MOVLW  00
0A2B4:  ADDWFC x03,W
0A2B6:  MOVWF  03
0A2B8:  MOVF   01,W
0A2BA:  ADDLW  5C
0A2BC:  MOVWF  FE9
0A2BE:  MOVLW  06
0A2C0:  ADDWFC 03,W
0A2C2:  MOVWF  FEA
0A2C4:  MOVFF  FEC,703
0A2C8:  MOVF   FED,F
0A2CA:  MOVFF  FEF,702
0A2CE:  MOVFF  701,565
0A2D2:  MOVFF  700,564
0A2D6:  MOVFF  565,FEA
0A2DA:  MOVFF  564,FE9
0A2DE:  CLRF   FEF
0A2E0:  MOVFF  703,FEA
0A2E4:  MOVFF  702,FE9
0A2E8:  MOVLB  0
0A2EA:  CALL   5AAC
....................       serial_out(retData);
0A2EE:  MOVLW  04
0A2F0:  MOVLB  7
0A2F2:  MOVWF  x02
0A2F4:  MOVLW  C1
0A2F6:  MOVWF  x01
0A2F8:  MOVLB  0
0A2FA:  BRA    A194
....................       resetSERcmd(SRI);
0A2FC:  MOVFF  4BF,701
0A300:  CALL   0B9A
0A304:  BRA    A1E0
....................    }
0A306:  GOTO   AAD8 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... #define DEBUG_1
.................... 
.................... void main()
0A30A:  CLRF   FF8
0A30C:  BCF    FF2.5
0A30E:  BSF    07.7
0A310:  MOVLB  E
0A312:  MOVLW  55
0A314:  MOVWF  x9B
0A316:  MOVLW  AA
0A318:  MOVWF  x9B
0A31A:  BCF    x9B.0
0A31C:  MOVLW  17
0A31E:  MOVWF  xB0
0A320:  MOVLW  13
0A322:  MOVWF  xB2
0A324:  MOVLW  09
0A326:  MOVWF  x8A
0A328:  MOVLW  0A
0A32A:  MOVWF  x8B
0A32C:  MOVLW  11
0A32E:  MOVWF  xEB
0A330:  MOVLW  12
0A332:  MOVWF  xED
0A334:  MOVLW  10
0A336:  MOVWF  xF4
0A338:  MOVLW  0F
0A33A:  MOVWF  xF5
0A33C:  MOVLW  09
0A33E:  MOVWF  xF8
0A340:  MOVLW  55
0A342:  MOVWF  x9B
0A344:  MOVLW  AA
0A346:  MOVWF  x9B
0A348:  BSF    x9B.0
0A34A:  CLRF   xD8
0A34C:  CLRF   xD5
0A34E:  CLRF   xD7
0A350:  MOVLW  08
0A352:  MOVWF  xD9
0A354:  MOVLW  60
0A356:  MOVWF  xD3
0A358:  BCF    F88.7
0A35A:  BSF    F83.7
0A35C:  MOVLW  12
0A35E:  MOVWF  03
0A360:  MOVLW  FA
0A362:  MOVLB  7
0A364:  MOVWF  x01
0A366:  MOVLB  0
0A368:  CALL   03CA
0A36C:  DECFSZ 03,F
0A36E:  BRA    A372
0A370:  BRA    A376
0A372:  MOVLB  E
0A374:  BRA    A360
0A376:  MOVLW  AA
0A378:  MOVWF  xFA
0A37A:  MOVLB  1
0A37C:  BCF    x63.0
0A37E:  CLRF   x75
0A380:  CLRF   x74
0A382:  CLRF   x73
0A384:  CLRF   x72
0A386:  CLRF   x79
0A388:  CLRF   x78
0A38A:  CLRF   x77
0A38C:  CLRF   x76
0A38E:  CLRF   x7D
0A390:  CLRF   x7C
0A392:  CLRF   x7B
0A394:  CLRF   x7A
0A396:  CLRF   x7F
0A398:  CLRF   x7E
0A39A:  MOVLB  E
0A39C:  BCF    x91.5
0A39E:  MOVLW  00
0A3A0:  MOVWF  x90
0A3A2:  MOVLW  03
0A3A4:  MOVWF  x8E
0A3A6:  MOVLW  2A
0A3A8:  MOVWF  x91
0A3AA:  MOVLW  04
0A3AC:  MOVWF  F88
0A3AE:  MOVWF  F88
0A3B0:  MOVWF  F88
0A3B2:  MOVLB  1
0A3B4:  CLRF   xD0
0A3B6:  CLRF   xD1
0A3B8:  CLRF   xD2
0A3BA:  CLRF   xD3
0A3BC:  BCF    F95.5
0A3BE:  MOVLW  40
0A3C0:  MOVWF  F94
0A3C2:  MOVLW  9F
0A3C4:  MOVWF  F92
0A3C6:  MOVLW  3A
0A3C8:  MOVWF  F95
0A3CA:  MOVLW  93
0A3CC:  MOVWF  F89
0A3CE:  MOVWF  F89
0A3D0:  MOVLB  4
0A3D2:  CLRF   xBF
0A3D4:  CLRF   xC0
0A3D6:  MOVLB  5
0A3D8:  CLRF   x61
0A3DA:  CLRF   x62
0A3DC:  MOVLB  1
0A3DE:  BCF    x63.1
0A3E0:  MOVLB  5
0A3E2:  CLRF   x63
0A3E4:  BSF    F9E.3
0A3E6:  MOVLW  7C
0A3E8:  MOVWF  F9A
0A3EA:  MOVLW  00
0A3EC:  MOVWF  F9B
0A3EE:  MOVLW  A6
0A3F0:  MOVWF  F9D
0A3F2:  MOVLW  90
0A3F4:  MOVWF  F9C
0A3F6:  CLRF   x65
0A3F8:  CLRF   x64
0A3FA:  CLRF   x69
0A3FC:  CLRF   x68
0A3FE:  CLRF   x67
0A400:  CLRF   x66
0A402:  MOVLB  F
0A404:  CLRF   x0C
0A406:  CLRF   x14
0A408:  CLRF   x1C
0A40A:  CLRF   x21
0A40C:  CLRF   x29
0A40E:  CLRF   x35
0A410:  CLRF   x36
0A412:  CLRF   x37
0A414:  CLRF   x34
0A416:  CLRF   x31
0A418:  CLRF   x32
0A41A:  CLRF   x33
0A41C:  CLRF   x30
0A41E:  MOVLW  5B
0A420:  MOVLB  5
0A422:  MOVWF  x6D
0A424:  MOVLW  A2
0A426:  MOVWF  x6C
0A428:  MOVLW  5B
0A42A:  MOVWF  x71
0A42C:  MOVLW  E6
0A42E:  MOVWF  x70
0A430:  MOVLW  61
0A432:  MOVWF  x75
0A434:  MOVLW  36
0A436:  MOVWF  x74
0A438:  MOVLW  63
0A43A:  MOVWF  x79
0A43C:  MOVLW  24
0A43E:  MOVWF  x78
0A440:  MOVLW  64
0A442:  MOVWF  x7D
0A444:  MOVLW  D2
0A446:  MOVWF  x7C
0A448:  MOVLW  66
0A44A:  MOVWF  x81
0A44C:  MOVLW  62
0A44E:  MOVWF  x80
0A450:  MOVLW  68
0A452:  MOVWF  x85
0A454:  MOVLW  7C
0A456:  MOVWF  x84
0A458:  MOVLW  70
0A45A:  MOVWF  x89
0A45C:  MOVLW  5A
0A45E:  MOVWF  x88
0A460:  MOVLW  73
0A462:  MOVWF  x8D
0A464:  MOVLW  3A
0A466:  MOVWF  x8C
0A468:  MOVLW  74
0A46A:  MOVWF  x91
0A46C:  MOVLW  9C
0A46E:  MOVWF  x90
0A470:  MOVLW  76
0A472:  MOVWF  x95
0A474:  MOVLW  5A
0A476:  MOVWF  x94
0A478:  MOVLW  7A
0A47A:  MOVWF  x99
0A47C:  MOVLW  10
0A47E:  MOVWF  x98
0A480:  MOVLW  7F
0A482:  MOVWF  x9D
0A484:  MOVLW  6C
0A486:  MOVWF  x9C
0A488:  MOVLW  83
0A48A:  MOVWF  xA1
0A48C:  MOVLW  04
0A48E:  MOVWF  xA0
0A490:  MOVLW  88
0A492:  MOVWF  xA5
0A494:  MOVLW  30
0A496:  MOVWF  xA4
0A498:  MOVLW  88
0A49A:  MOVWF  xA9
0A49C:  MOVLW  36
0A49E:  MOVWF  xA8
0A4A0:  MOVLW  8E
0A4A2:  MOVWF  xAD
0A4A4:  MOVLW  AA
0A4A6:  MOVWF  xAC
0A4A8:  MOVLW  94
0A4AA:  MOVWF  xB1
0A4AC:  MOVLW  0E
0A4AE:  MOVWF  xB0
0A4B0:  MOVLW  9B
0A4B2:  MOVWF  xB5
0A4B4:  MOVLW  30
0A4B6:  MOVWF  xB4
0A4B8:  MOVLW  9C
0A4BA:  MOVWF  xB9
0A4BC:  MOVLW  92
0A4BE:  MOVWF  xB8
0A4C0:  MOVLW  9F
0A4C2:  MOVWF  xBD
0A4C4:  MOVLW  04
0A4C6:  MOVWF  xBC
0A4C8:  MOVLW  9F
0A4CA:  MOVWF  xC1
0A4CC:  MOVLW  10
0A4CE:  MOVWF  xC0
0A4D0:  MOVLW  9F
0A4D2:  MOVWF  xC5
0A4D4:  MOVLW  1C
0A4D6:  MOVWF  xC4
0A4D8:  MOVLW  A0
0A4DA:  MOVWF  xC9
0A4DC:  MOVLW  08
0A4DE:  MOVWF  xC8
0A4E0:  BRA    A6C0
0A4E2:  DATA 02,00
0A4E4:  DATA 1A,00
0A4E6:  DATA 00,0C
0A4E8:  DATA 00,20
0A4EA:  DATA 78,23
0A4EC:  DATA D7,0A
0A4EE:  DATA 7D,19
0A4F0:  DATA 99,9A
0A4F2:  DATA 7B,4C
0A4F4:  DATA CC,CD
0A4F6:  DATA 1C,C0
0A4F8:  DATA 00,0C
0A4FA:  DATA 80,78
0A4FC:  DATA 23,D7
0A4FE:  DATA 0A,7D
0A500:  DATA 19,99
0A502:  DATA 9A,7B
0A504:  DATA 4C,CC
0A506:  DATA CD,1C
0A508:  DATA C0,00
0A50A:  DATA 01,80
0A50C:  DATA 02,09
0A50E:  DATA C0,00
0A510:  DATA 05,80
0A512:  DATA 7F,00
0A514:  DATA 00,00
0A516:  DATA 7F,0B
0A518:  DATA C0,00
0A51A:  DATA 05,80
0A51C:  DATA 7F,00
0A51E:  DATA 00,00
0A520:  DATA 7F,07
0A522:  DATA C0,00
0A524:  DATA 01,80
0A526:  DATA 7F,17
0A528:  DATA C0,00
0A52A:  DATA 01,80
0A52C:  DATA 7F,17
0A52E:  DATA C0,00
0A530:  DATA 04,80
0A532:  DATA 79,B7
0A534:  DATA F3,BD
0A536:  DATA 04,C0
0A538:  DATA 00,04
0A53A:  DATA 80,7C
0A53C:  DATA 59,DF
0A53E:  DATA 4E,04
0A540:  DATA C0,00
0A542:  DATA 04,80
0A544:  DATA 78,0A
0A546:  DATA 28,88
0A548:  DATA 04,C0
0A54A:  DATA 00,04
0A54C:  DATA 80,78
0A54E:  DATA 05,EA
0A550:  DATA 16,04
0A552:  DATA C0,00
0A554:  DATA 04,80
0A556:  DATA 78,1E
0A558:  DATA 33,D7
0A55A:  DATA 04,C0
0A55C:  DATA 00,04
0A55E:  DATA 80,77
0A560:  DATA 68,7B
0A562:  DATA BB,04
0A564:  DATA C0,00
0A566:  DATA 04,80
0A568:  DATA 77,68
0A56A:  DATA 0D,C6
0A56C:  DATA 68,40
0A56E:  DATA FB,00
0A570:  DATA 0E,41
0A572:  DATA 64,00
0A574:  DATA 17,41
0A576:  DATA D4,00
0A578:  DATA 3C,45
0A57A:  DATA 25,00
0A57C:  DATA 02,05
0A57E:  DATA 6A,CA
0A580:  DATA 05,02
0A582:  DATA 05,6E
0A584:  DATA CD,05
0A586:  DATA 02,05
0A588:  DATA 72,D0
0A58A:  DATA 05,02
0A58C:  DATA 05,76
0A58E:  DATA D7,05
0A590:  DATA 02,05
0A592:  DATA 7A,DE
0A594:  DATA 05,02
0A596:  DATA 05,7E
0A598:  DATA E6,05
0A59A:  DATA 02,05
0A59C:  DATA 82,EE
0A59E:  DATA 05,02
0A5A0:  DATA 05,86
0A5A2:  DATA F3,05
0A5A4:  DATA 02,05
0A5A6:  DATA 8A,F8
0A5A8:  DATA 05,02
0A5AA:  DATA 05,8E
0A5AC:  DATA FC,05
0A5AE:  DATA 02,05
0A5B0:  DATA 92,00
0A5B2:  DATA 06,02
0A5B4:  DATA 05,96
0A5B6:  DATA 07,06
0A5B8:  DATA 02,05
0A5BA:  DATA 9A,0D
0A5BC:  DATA 06,02
0A5BE:  DATA 05,9E
0A5C0:  DATA 13,06
0A5C2:  DATA 02,05
0A5C4:  DATA A2,19
0A5C6:  DATA 06,02
0A5C8:  DATA 05,A6
0A5CA:  DATA 1F,06
0A5CC:  DATA 02,05
0A5CE:  DATA AA,24
0A5D0:  DATA 06,02
0A5D2:  DATA 05,AE
0A5D4:  DATA 2D,06
0A5D6:  DATA 02,05
0A5D8:  DATA B2,35
0A5DA:  DATA 06,02
0A5DC:  DATA 05,B6
0A5DE:  DATA 3C,06
0A5E0:  DATA 02,05
0A5E2:  DATA BA,43
0A5E4:  DATA 06,02
0A5E6:  DATA 05,BE
0A5E8:  DATA 4B,06
0A5EA:  DATA 02,05
0A5EC:  DATA C2,54
0A5EE:  DATA 06,02
0A5F0:  DATA 05,C6
0A5F2:  DATA 5A,06
0A5F4:  DATA 8F,05
0A5F6:  DATA CA,67
0A5F8:  DATA 72,00
0A5FA:  DATA 67,73
0A5FC:  DATA 00,67
0A5FE:  DATA 43,68
0A600:  DATA 4D,61
0A602:  DATA 70,00
0A604:  DATA 73,43
0A606:  DATA 68,4D
0A608:  DATA 61,70
0A60A:  DATA 00,67
0A60C:  DATA 43,68
0A60E:  DATA 4D,6F
0A610:  DATA 64,65
0A612:  DATA 00,73
0A614:  DATA 43,68
0A616:  DATA 4D,6F
0A618:  DATA 64,65
0A61A:  DATA 00,67
0A61C:  DATA 50,49
0A61E:  DATA 44,00
0A620:  DATA 73,50
0A622:  DATA 49,44
0A624:  DATA 00,67
0A626:  DATA 53,50
0A628:  DATA 00,73
0A62A:  DATA 53,50
0A62C:  DATA 00,67
0A62E:  DATA 53,43
0A630:  DATA 61,6C
0A632:  DATA 73,00
0A634:  DATA 67,53
0A636:  DATA 43,61
0A638:  DATA 6C,00
0A63A:  DATA 73,53
0A63C:  DATA 43,61
0A63E:  DATA 6C,00
0A640:  DATA 67,4D
0A642:  DATA 43,61
0A644:  DATA 6C,00
0A646:  DATA 73,4D
0A648:  DATA 43,61
0A64A:  DATA 6C,00
0A64C:  DATA 67,4D
0A64E:  DATA 6F,6E
0A650:  DATA 00,67
0A652:  DATA 50,49
0A654:  DATA 44,64
0A656:  DATA 61,74
0A658:  DATA 61,00
0A65A:  DATA 67,49
0A65C:  DATA 50,64
0A65E:  DATA 61,74
0A660:  DATA 61,00
0A662:  DATA 67,4D
0A664:  DATA 61,6E
0A666:  DATA 4F,50
0A668:  DATA 00,73
0A66A:  DATA 4D,61
0A66C:  DATA 6E,4F
0A66E:  DATA 50,00
0A670:  DATA 73,46
0A672:  DATA 69,6C
0A674:  DATA 74,4F
0A676:  DATA 6E,00
0A678:  DATA 73,46
0A67A:  DATA 69,6C
0A67C:  DATA 74,4F
0A67E:  DATA 66,66
0A680:  DATA 00,73
0A682:  DATA 48,6F
0A684:  DATA 6D,65
0A686:  DATA 04,C0
0A688:  DATA 00,33
0A68A:  DATA 80,65
0A68C:  DATA 06,01
0A68E:  DATA 6D,06
0A690:  DATA 02,7D
0A692:  DATA 06,53
0A694:  DATA 55,43
0A696:  DATA 43,45
0A698:  DATA 53,53
0A69A:  DATA 00,49
0A69C:  DATA 4E,56
0A69E:  DATA 41,4C
0A6A0:  DATA 49,44
0A6A2:  DATA 20,43
0A6A4:  DATA 4F,4D
0A6A6:  DATA 4D,41
0A6A8:  DATA 4E,44
0A6AA:  DATA 00,49
0A6AC:  DATA 4E,56
0A6AE:  DATA 41,4C
0A6B0:  DATA 49,44
0A6B2:  DATA 20,50
0A6B4:  DATA 41,52
0A6B6:  DATA 41,4D
0A6B8:  DATA 45,54
0A6BA:  DATA 45,52
0A6BC:  DATA 00,00
0A6BE:  DATA 00,00
0A6C0:  MOVLW  00
0A6C2:  MOVWF  FF8
0A6C4:  MOVLW  A4
0A6C6:  MOVWF  FF7
0A6C8:  MOVLW  E2
0A6CA:  MOVWF  FF6
0A6CC:  TBLRD*+
0A6CE:  MOVF   FF5,W
0A6D0:  MOVWF  00
0A6D2:  XORLW  00
0A6D4:  BZ    A6FC
0A6D6:  TBLRD*+
0A6D8:  MOVF   FF5,W
0A6DA:  MOVWF  01
0A6DC:  BTFSC  FE8.7
0A6DE:  BRA    A6EA
0A6E0:  ANDLW  3F
0A6E2:  MOVWF  FEA
0A6E4:  TBLRD*+
0A6E6:  MOVFF  FF5,FE9
0A6EA:  BTFSC  01.6
0A6EC:  TBLRD*+
0A6EE:  BTFSS  01.6
0A6F0:  TBLRD*+
0A6F2:  MOVFF  FF5,FEE
0A6F6:  DCFSNZ 00,F
0A6F8:  BRA    A6CC
0A6FA:  BRA    A6EE
0A6FC:  CLRF   FF8
0A6FE:  MOVLW  03
0A700:  MOVLB  6
0A702:  MOVWF  x92
0A704:  MOVLW  E8
0A706:  MOVWF  x91
0A708:  CLRF   x94
0A70A:  CLRF   x93
0A70C:  CLRF   x96
0A70E:  CLRF   x95
.................... {
....................     int16 loopDelay = 1000;
....................     int16 controlCounter = 0;
....................     int16 debugCounter = 0;
....................    
....................     char pBuff[100];
....................     
....................     IO_init();                    // set up IO 
0A710:  MOVLB  0
0A712:  GOTO   03F4
....................     params_init();                // load parameters
0A716:  GOTO   0690
....................     monitor_init();               // initialize internal ADC for voltage and current telemetry
0A71A:  GOTO   0ADC
....................     control_init();               // initialize the output control DACs
0A71E:  GOTO   0B74
....................     serial_init();                // setup the serial port
0A722:  GOTO   0D14
....................     event_timer_init();
0A726:  GOTO   0D36
.................... //!    setup_wdt(WDT_512MS);
....................     enable_interrupts(GLOBAL);
0A72A:  MOVLW  C0
0A72C:  IORWF  FF2,F
....................     
....................     while(TRUE)
....................     {
.................... //!        restart_wdt();
....................         pBuff[0] = '\0';
0A72E:  MOVLB  6
0A730:  CLRF   x97
....................         
.................... //!        if (adcVals[chX].homeFlag) home_axis(chX);
.................... //!        if (adcVals[chY].homeFlag) home_axis(chY);
....................                 
....................         internal_monitor_task();   //Update monitored voltage and currents etc
0A732:  MOVLB  0
0A734:  GOTO   110E
....................         sensor_monitor_task();     //get magnetoresistive sensor data
0A738:  GOTO   445E
....................       
....................         if (controlCounter >= 2){
0A73C:  MOVLB  6
0A73E:  MOVF   x94,F
0A740:  BNZ   A748
0A742:  MOVF   x93,W
0A744:  SUBLW  01
0A746:  BC    A756
....................             control_task();
0A748:  MOVLB  0
0A74A:  GOTO   4FD6
....................             controlCounter = 0;
0A74E:  MOVLB  6
0A750:  CLRF   x94
0A752:  CLRF   x93
....................         }else controlCounter++;
0A754:  BRA    A75C
0A756:  INCF   x93,F
0A758:  BTFSC  FD8.2
0A75A:  INCF   x94,F
....................       
....................         serial_task();             
0A75C:  MOVLB  0
0A75E:  GOTO   5080
....................       
....................         #ifdef DEBUG_1
....................         if (debugCounter >= 0){
....................             static int8 ch = 0;
....................             sprintf(pBuff+strlen(pBuff), "CNT,%u,%.0f,%.0f;", ch+1, adcVals[ch].sinCounts, adcVals[ch].cosCounts);
0A762:  MOVLW  06
0A764:  MOVLB  7
0A766:  MOVWF  x42
0A768:  MOVLW  97
0A76A:  MOVWF  x41
0A76C:  MOVLB  0
0A76E:  CALL   5598
0A772:  MOVF   01,W
0A774:  ADDLW  97
0A776:  MOVLB  6
0A778:  MOVWF  xFB
0A77A:  MOVLW  06
0A77C:  ADDWFC 02,W
0A77E:  MOVWF  xFC
0A780:  MOVLW  01
0A782:  ADDWF  x8F,W
0A784:  MOVWF  xFD
0A786:  MOVF   x8F,W
0A788:  MULLW  26
0A78A:  MOVF   FF3,W
0A78C:  CLRF   xFF
0A78E:  MOVWF  xFE
0A790:  MOVLW  08
0A792:  ADDWF  xFE,W
0A794:  MOVWF  01
0A796:  MOVLW  00
0A798:  ADDWFC xFF,W
0A79A:  MOVWF  03
0A79C:  MOVF   01,W
0A79E:  ADDLW  17
0A7A0:  MOVWF  FE9
0A7A2:  MOVLW  01
0A7A4:  ADDWFC 03,W
0A7A6:  MOVWF  FEA
0A7A8:  MOVFF  FEF,6FE
0A7AC:  MOVFF  FEC,6FF
0A7B0:  MOVFF  FEC,700
0A7B4:  MOVFF  FEC,701
0A7B8:  MOVF   x8F,W
0A7BA:  MULLW  26
0A7BC:  MOVF   FF3,W
0A7BE:  MOVLB  7
0A7C0:  CLRF   x03
0A7C2:  MOVWF  x02
0A7C4:  MOVLW  0C
0A7C6:  ADDWF  x02,W
0A7C8:  MOVWF  01
0A7CA:  MOVLW  00
0A7CC:  ADDWFC x03,W
0A7CE:  MOVWF  03
0A7D0:  MOVF   01,W
0A7D2:  ADDLW  17
0A7D4:  MOVWF  FE9
0A7D6:  MOVLW  01
0A7D8:  ADDWFC 03,W
0A7DA:  MOVWF  FEA
0A7DC:  MOVFF  FEF,702
0A7E0:  MOVFF  FEC,703
0A7E4:  MOVFF  FEC,704
0A7E8:  MOVFF  FEC,705
0A7EC:  MOVFF  6FC,565
0A7F0:  MOVFF  6FB,564
0A7F4:  MOVLW  8E
0A7F6:  MOVWF  FF6
0A7F8:  MOVLW  03
0A7FA:  MOVWF  FF7
0A7FC:  MOVLW  04
0A7FE:  MOVWF  x0F
0A800:  MOVLB  0
0A802:  CALL   55F0
0A806:  MOVFF  6FD,706
0A80A:  MOVLW  1B
0A80C:  MOVLB  7
0A80E:  MOVWF  x07
0A810:  MOVLB  0
0A812:  CALL   5618
0A816:  MOVLW  2C
0A818:  MOVLB  7
0A81A:  MOVWF  x50
0A81C:  MOVLB  0
0A81E:  CALL   55D0
0A822:  MOVLW  89
0A824:  MOVWF  FE9
0A826:  MOVFF  701,746
0A82A:  MOVFF  700,745
0A82E:  MOVFF  6FF,744
0A832:  MOVFF  6FE,743
0A836:  MOVLB  7
0A838:  CLRF   x47
0A83A:  MOVLB  0
0A83C:  CALL   576E
0A840:  MOVLW  2C
0A842:  MOVLB  7
0A844:  MOVWF  x50
0A846:  MOVLB  0
0A848:  CALL   55D0
0A84C:  MOVLW  89
0A84E:  MOVWF  FE9
0A850:  MOVFF  705,746
0A854:  MOVFF  704,745
0A858:  MOVFF  703,744
0A85C:  MOVFF  702,743
0A860:  MOVLB  7
0A862:  CLRF   x47
0A864:  MOVLB  0
0A866:  CALL   576E
0A86A:  MOVLW  3B
0A86C:  MOVLB  7
0A86E:  MOVWF  x50
0A870:  MOVLB  0
0A872:  CALL   55D0
....................             sprintf(pBuff+strlen(pBuff), "POS,%u,%3.3f;", ch+1, adcVals[ch].pReal);
0A876:  MOVLW  06
0A878:  MOVLB  7
0A87A:  MOVWF  x42
0A87C:  MOVLW  97
0A87E:  MOVWF  x41
0A880:  MOVLB  0
0A882:  CALL   5598
0A886:  MOVF   01,W
0A888:  ADDLW  97
0A88A:  MOVLB  6
0A88C:  MOVWF  xFB
0A88E:  MOVLW  06
0A890:  ADDWFC 02,W
0A892:  MOVWF  xFC
0A894:  MOVLW  01
0A896:  ADDWF  x8F,W
0A898:  MOVWF  xFD
0A89A:  MOVF   x8F,W
0A89C:  MULLW  26
0A89E:  MOVF   FF3,W
0A8A0:  CLRF   xFF
0A8A2:  MOVWF  xFE
0A8A4:  MOVLW  1D
0A8A6:  ADDWF  xFE,W
0A8A8:  MOVWF  01
0A8AA:  MOVLW  00
0A8AC:  ADDWFC xFF,W
0A8AE:  MOVWF  03
0A8B0:  MOVF   01,W
0A8B2:  ADDLW  17
0A8B4:  MOVWF  FE9
0A8B6:  MOVLW  01
0A8B8:  ADDWFC 03,W
0A8BA:  MOVWF  FEA
0A8BC:  MOVFF  FEF,6FE
0A8C0:  MOVFF  FEC,6FF
0A8C4:  MOVFF  FEC,700
0A8C8:  MOVFF  FEC,701
0A8CC:  MOVFF  6FC,565
0A8D0:  MOVFF  6FB,564
0A8D4:  MOVLW  A0
0A8D6:  MOVWF  FF6
0A8D8:  MOVLW  03
0A8DA:  MOVWF  FF7
0A8DC:  MOVLW  04
0A8DE:  MOVLB  7
0A8E0:  MOVWF  x0F
0A8E2:  MOVLB  0
0A8E4:  CALL   55F0
0A8E8:  MOVFF  6FD,706
0A8EC:  MOVLW  1B
0A8EE:  MOVLB  7
0A8F0:  MOVWF  x07
0A8F2:  MOVLB  0
0A8F4:  CALL   5618
0A8F8:  MOVLW  2C
0A8FA:  MOVLB  7
0A8FC:  MOVWF  x50
0A8FE:  MOVLB  0
0A900:  CALL   55D0
0A904:  MOVLW  89
0A906:  MOVWF  FE9
0A908:  MOVFF  701,746
0A90C:  MOVFF  700,745
0A910:  MOVFF  6FF,744
0A914:  MOVFF  6FE,743
0A918:  MOVLW  03
0A91A:  MOVLB  7
0A91C:  MOVWF  x47
0A91E:  MOVLB  0
0A920:  CALL   576E
0A924:  MOVLW  3B
0A926:  MOVLB  7
0A928:  MOVWF  x50
0A92A:  MOVLB  0
0A92C:  CALL   55D0
....................             if ( dacVals[ch].invV ) sprintf(pBuff+strlen(pBuff), "OUT,%u,-,%Lu;", ch+1, dacVals[ch].ipVal);
0A930:  MOVLB  6
0A932:  MOVF   x8F,W
0A934:  MULLW  07
0A936:  MOVF   FF3,W
0A938:  CLRF   xFC
0A93A:  MOVWF  xFB
0A93C:  MOVLW  64
0A93E:  ADDWF  xFB,W
0A940:  MOVWF  FE9
0A942:  MOVLW  01
0A944:  ADDWFC xFC,W
0A946:  MOVWF  FEA
0A948:  BTFSS  FEF.0
0A94A:  BRA    A9FA
0A94C:  MOVLW  06
0A94E:  MOVLB  7
0A950:  MOVWF  x42
0A952:  MOVLW  97
0A954:  MOVWF  x41
0A956:  MOVLB  0
0A958:  CALL   5598
0A95C:  MOVF   01,W
0A95E:  ADDLW  97
0A960:  MOVLB  6
0A962:  MOVWF  xFB
0A964:  MOVLW  06
0A966:  ADDWFC 02,W
0A968:  MOVWF  xFC
0A96A:  MOVLW  01
0A96C:  ADDWF  x8F,W
0A96E:  MOVWF  xFD
0A970:  MOVF   x8F,W
0A972:  MULLW  07
0A974:  MOVF   FF3,W
0A976:  CLRF   xFF
0A978:  MOVWF  xFE
0A97A:  MOVLW  01
0A97C:  ADDWF  xFE,W
0A97E:  MOVWF  01
0A980:  MOVLW  00
0A982:  ADDWFC xFF,W
0A984:  MOVWF  03
0A986:  MOVF   01,W
0A988:  ADDLW  64
0A98A:  MOVWF  FE9
0A98C:  MOVLW  01
0A98E:  ADDWFC 03,W
0A990:  MOVWF  FEA
0A992:  MOVFF  FEC,6FF
0A996:  MOVF   FED,F
0A998:  MOVFF  FEF,6FE
0A99C:  MOVFF  6FC,565
0A9A0:  MOVFF  6FB,564
0A9A4:  MOVLW  AE
0A9A6:  MOVWF  FF6
0A9A8:  MOVLW  03
0A9AA:  MOVWF  FF7
0A9AC:  MOVLW  04
0A9AE:  MOVLB  7
0A9B0:  MOVWF  x0F
0A9B2:  MOVLB  0
0A9B4:  CALL   55F0
0A9B8:  MOVFF  6FD,706
0A9BC:  MOVLW  1B
0A9BE:  MOVLB  7
0A9C0:  MOVWF  x07
0A9C2:  MOVLB  0
0A9C4:  CALL   5618
0A9C8:  MOVLW  B4
0A9CA:  MOVWF  FF6
0A9CC:  MOVLW  03
0A9CE:  MOVWF  FF7
0A9D0:  MOVLW  03
0A9D2:  MOVLB  7
0A9D4:  MOVWF  x0F
0A9D6:  MOVLB  0
0A9D8:  CALL   55F0
0A9DC:  MOVLW  10
0A9DE:  MOVWF  FE9
0A9E0:  MOVFF  6FF,701
0A9E4:  MOVFF  6FE,700
0A9E8:  CALL   5916
0A9EC:  MOVLW  3B
0A9EE:  MOVLB  7
0A9F0:  MOVWF  x50
0A9F2:  MOVLB  0
0A9F4:  CALL   55D0
0A9F8:  BRA    AAA6
....................             else                    sprintf(pBuff+strlen(pBuff), "OUT,%u,+,%Lu;", ch+1, dacVals[ch].ipVal);
0A9FA:  MOVLW  06
0A9FC:  MOVLB  7
0A9FE:  MOVWF  x42
0AA00:  MOVLW  97
0AA02:  MOVWF  x41
0AA04:  MOVLB  0
0AA06:  CALL   5598
0AA0A:  MOVF   01,W
0AA0C:  ADDLW  97
0AA0E:  MOVLB  6
0AA10:  MOVWF  xFB
0AA12:  MOVLW  06
0AA14:  ADDWFC 02,W
0AA16:  MOVWF  xFC
0AA18:  MOVLW  01
0AA1A:  ADDWF  x8F,W
0AA1C:  MOVWF  xFD
0AA1E:  MOVF   x8F,W
0AA20:  MULLW  07
0AA22:  MOVF   FF3,W
0AA24:  CLRF   xFF
0AA26:  MOVWF  xFE
0AA28:  MOVLW  01
0AA2A:  ADDWF  xFE,W
0AA2C:  MOVWF  01
0AA2E:  MOVLW  00
0AA30:  ADDWFC xFF,W
0AA32:  MOVWF  03
0AA34:  MOVF   01,W
0AA36:  ADDLW  64
0AA38:  MOVWF  FE9
0AA3A:  MOVLW  01
0AA3C:  ADDWFC 03,W
0AA3E:  MOVWF  FEA
0AA40:  MOVFF  FEC,6FF
0AA44:  MOVF   FED,F
0AA46:  MOVFF  FEF,6FE
0AA4A:  MOVFF  6FC,565
0AA4E:  MOVFF  6FB,564
0AA52:  MOVLW  BC
0AA54:  MOVWF  FF6
0AA56:  MOVLW  03
0AA58:  MOVWF  FF7
0AA5A:  MOVLW  04
0AA5C:  MOVLB  7
0AA5E:  MOVWF  x0F
0AA60:  MOVLB  0
0AA62:  CALL   55F0
0AA66:  MOVFF  6FD,706
0AA6A:  MOVLW  1B
0AA6C:  MOVLB  7
0AA6E:  MOVWF  x07
0AA70:  MOVLB  0
0AA72:  CALL   5618
0AA76:  MOVLW  C2
0AA78:  MOVWF  FF6
0AA7A:  MOVLW  03
0AA7C:  MOVWF  FF7
0AA7E:  MOVLW  03
0AA80:  MOVLB  7
0AA82:  MOVWF  x0F
0AA84:  MOVLB  0
0AA86:  CALL   55F0
0AA8A:  MOVLW  10
0AA8C:  MOVWF  FE9
0AA8E:  MOVFF  6FF,701
0AA92:  MOVFF  6FE,700
0AA96:  CALL   5916
0AA9A:  MOVLW  3B
0AA9C:  MOVLB  7
0AA9E:  MOVWF  x50
0AAA0:  MOVLB  0
0AAA2:  CALL   55D0
....................             ch = !ch;
0AAA6:  MOVLB  6
0AAA8:  MOVF   x8F,F
0AAAA:  BTFSC  FD8.2
0AAAC:  BRA    AAB2
0AAAE:  MOVLW  00
0AAB0:  BRA    AAB4
0AAB2:  MOVLW  01
0AAB4:  MOVWF  x8F
....................             debugCounter = 0;
0AAB6:  CLRF   x96
0AAB8:  CLRF   x95
....................         }else debugCounter++;
....................         fprintf(ICD_STREAM, "%s\n", pBuff);
0AABA:  MOVLW  06
0AABC:  MOVWF  FEA
0AABE:  MOVLW  97
0AAC0:  MOVWF  FE9
0AAC2:  MOVLB  0
0AAC4:  GOTO   5A2C
0AAC8:  MOVLW  0A
0AACA:  MOVLB  6
0AACC:  MOVWF  xFD
0AACE:  MOVLB  0
0AAD0:  CALL   59DC
....................         #endif
....................       
....................         command_handler_task();    //execute commands
0AAD4:  GOTO   A1E0
....................       
....................         delay_ms(loopDelay);
0AAD8:  MOVFF  692,6FB
0AADC:  MOVLB  6
0AADE:  INCF   xFB,F
0AAE0:  DECF   xFB,F
0AAE2:  BTFSC  FD8.2
0AAE4:  BRA    AAF4
0AAE6:  MOVLB  7
0AAE8:  SETF   x01
0AAEA:  MOVLB  0
0AAEC:  CALL   03CA
0AAF0:  MOVLB  6
0AAF2:  BRA    AAE0
0AAF4:  MOVFF  691,701
0AAF8:  MOVLB  0
0AAFA:  CALL   03CA
0AAFE:  BRA    A72E
....................     }
.................... }
0AB00:  SLEEP 

Configuration Fuses:
   Word  1: FF8C   NOEXTOSC RSTOSC_HFINTRC_64MHZ NOCLKOUT CKS FCMEN
   Word  2: FFFD   MCLR PUT NOLPBOR BROWNOUT BORV19 ZCDDIS PPS1WAY STVREN NODEBUG NOXINST
   Word  3: FF9F   WDTSW NOWDT WDTWIN_SW WDTCLK_SW
   Word  4: DFFF   NOWRT NOWRTC NOWRTB NOWRTD SCANE NOLVP
   Word  5: FFFF   NOPROTECT NOCPD
   Word  6: FFFF   NOEBTR NOEBTRB
