CCS PCH C Compiler, Version 5.109, 62303               02-Dec-25 18:59

               Filename:   C:\Users\aidan\Documents\GitHub\DiFCS-Controller\src\main.lst

               ROM used:   43318 bytes (66%)
                           Largest free fragment is 22216
               RAM used:   1689 (47%) at main() level
                           1816 (50%) worst case
               Stack used: 6 locations (4 in main + 2 for interrupts)
               Stack size: 31

*
00000:  NOP   
00002:  GOTO   A2AC
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  MOVLB  E
00056:  BTFSS  xC0.5
00058:  GOTO   0062
0005C:  BTFSC  xC8.5
0005E:  GOTO   00E8
00062:  BTFSS  xC1.0
00064:  GOTO   006E
00068:  BTFSC  xC9.0
0006A:  GOTO   025A
0006E:  MOVFF  0E,00
00072:  MOVFF  0F,01
00076:  MOVFF  10,02
0007A:  MOVFF  11,03
0007E:  MOVFF  0C,FE9
00082:  MOVFF  07,FEA
00086:  BSF    07.7
00088:  MOVFF  08,FE1
0008C:  MOVFF  09,FE2
00090:  MOVFF  0A,FD9
00094:  MOVFF  0B,FDA
00098:  MOVFF  12,FF3
0009C:  MOVFF  13,FF4
000A0:  MOVFF  14,FFA
000A4:  MOVFF  15,FF5
000A8:  MOVFF  16,FF6
000AC:  MOVFF  17,FF7
000B0:  MOVF   04,W
000B2:  MOVFF  06,FE0
000B6:  MOVFF  05,FD8
000BA:  RETFIE 0
.................... #include <main.h>
.................... #include <18F46Q10.h>
.................... //////////// Standard Header file for the PIC18F46Q10 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F46Q10
000BC:  MOVFF  FEC,FFA
000C0:  MOVF   FED,F
000C2:  MOVFF  FEF,FE8
000C6:  MOVWF  FF9
000C8:  RETURN 0
*
0032E:  DATA 32,30
00330:  DATA 32,35
00332:  DATA 31,31
00334:  DATA 30,34
00336:  DATA 00,00
00338:  DATA 30,30
0033A:  DATA 30,30
0033C:  DATA 00,00
0033E:  DATA 25,64
00340:  DATA 2C,4D
00342:  DATA 41,4E
00344:  DATA 55,41
00346:  DATA 4C,2C
00348:  DATA 00,00
0034A:  DATA 25,64
0034C:  DATA 2C,4D
0034E:  DATA 41,47
00350:  DATA 53,4E
00352:  DATA 53,2C
00354:  DATA 00,00
00356:  DATA 23,44
00358:  DATA 30,2C
0035A:  DATA 43,4E
0035C:  DATA 54,2C
0035E:  DATA 25,75
00360:  DATA 2C,25
00362:  DATA 2E,30
00364:  DATA 66,2C
00366:  DATA 25,2E
00368:  DATA 30,66
0036A:  DATA 0A,00
0036C:  DATA 23,44
0036E:  DATA 30,2C
00370:  DATA 50,4F
00372:  DATA 53,2C
00374:  DATA 25,75
00376:  DATA 2C,25
00378:  DATA 33,2E
0037A:  DATA 33,66
0037C:  DATA 0A,00
0037E:  DATA 23,44
00380:  DATA 30,2C
00382:  DATA 4F,55
00384:  DATA 54,2C
00386:  DATA 25,75
00388:  DATA 2C,2D
0038A:  DATA 2C,25
0038C:  DATA 4C,75
0038E:  DATA 0A,00
00390:  DATA 23,44
00392:  DATA 30,2C
00394:  DATA 4F,55
00396:  DATA 54,2C
00398:  DATA 25,75
0039A:  DATA 2C,2B
0039C:  DATA 2C,25
0039E:  DATA 4C,75
003A0:  DATA 0A,00
*
006C8:  ADDWF  FE8,W
006CA:  CLRF   FF7
006CC:  RLCF   FF7,F
006CE:  ADDLW  E3
006D0:  MOVWF  FF6
006D2:  MOVLW  06
006D4:  ADDWFC FF7,F
006D6:  TBLRD*-
006D8:  MOVF   FF5,W
006DA:  MOVWF  FFA
006DC:  TBLRD*
006DE:  MOVF   FF5,W
006E0:  MOVWF  FF9
006E2:  DATA 92,06
006E4:  DATA 9C,06
006E6:  DATA A6,06
006E8:  DATA B0,06
*
00868:  MOVLB  6
0086A:  MOVF   xF8,W
0086C:  XORWF  xFA,W
0086E:  ANDLW  80
00870:  MOVWF  xFC
00872:  BTFSS  xF8.7
00874:  BRA    0880
00876:  COMF   xF7,F
00878:  COMF   xF8,F
0087A:  INCF   xF7,F
0087C:  BTFSC  FD8.2
0087E:  INCF   xF8,F
00880:  BTFSS  xFA.7
00882:  BRA    088E
00884:  COMF   xF9,F
00886:  COMF   xFA,F
00888:  INCF   xF9,F
0088A:  BTFSC  FD8.2
0088C:  INCF   xFA,F
0088E:  MOVF   xF7,W
00890:  MULWF  xF9
00892:  MOVFF  FF3,01
00896:  MOVFF  FF4,00
0089A:  MULWF  xFA
0089C:  MOVF   FF3,W
0089E:  ADDWF  00,F
008A0:  MOVF   xF8,W
008A2:  MULWF  xF9
008A4:  MOVF   FF3,W
008A6:  ADDWFC 00,W
008A8:  MOVWF  02
008AA:  BTFSS  xFC.7
008AC:  BRA    08B8
008AE:  COMF   01,F
008B0:  COMF   02,F
008B2:  INCF   01,F
008B4:  BTFSC  FD8.2
008B6:  INCF   02,F
008B8:  MOVLB  0
008BA:  RETURN 0
008BC:  MOVLB  6
008BE:  MOVF   xF7,W
008C0:  XORWF  xF8,W
008C2:  ANDLW  80
008C4:  MOVWF  xFA
008C6:  BTFSS  xF7.7
008C8:  BRA    08CE
008CA:  COMF   xF7,F
008CC:  INCF   xF7,F
008CE:  BTFSS  xF8.7
008D0:  BRA    08D6
008D2:  COMF   xF8,F
008D4:  INCF   xF8,F
008D6:  MOVF   xF8,W
008D8:  CLRF   01
008DA:  SUBWF  xF7,W
008DC:  BC    08E4
008DE:  MOVFF  6F7,00
008E2:  BRA    08FC
008E4:  CLRF   00
008E6:  MOVLW  08
008E8:  MOVWF  xF9
008EA:  RLCF   xF7,F
008EC:  RLCF   00,F
008EE:  MOVF   xF8,W
008F0:  SUBWF  00,W
008F2:  BTFSC  FD8.0
008F4:  MOVWF  00
008F6:  RLCF   01,F
008F8:  DECFSZ xF9,F
008FA:  BRA    08EA
008FC:  BTFSS  xFA.7
008FE:  BRA    0904
00900:  COMF   01,F
00902:  INCF   01,F
00904:  MOVLB  0
00906:  GOTO   097C (RETURN)
*
00C0C:  MOVLB  6
00C0E:  MOVF   xF1,W
00C10:  MULWF  xF3
00C12:  MOVFF  FF3,01
00C16:  MOVFF  FF4,00
00C1A:  MULWF  xF4
00C1C:  MOVF   FF3,W
00C1E:  ADDWF  00,F
00C20:  MOVF   xF2,W
00C22:  MULWF  xF3
00C24:  MOVF   FF3,W
00C26:  ADDWFC 00,W
00C28:  MOVWF  02
00C2A:  MOVLB  0
00C2C:  RETURN 0
*
00E04:  MOVLW  8E
00E06:  MOVWF  00
00E08:  MOVFF  6E0,01
00E0C:  MOVFF  6DF,02
00E10:  CLRF   03
00E12:  MOVF   01,F
00E14:  BNZ   0E28
00E16:  MOVFF  02,01
00E1A:  CLRF   02
00E1C:  MOVLW  08
00E1E:  SUBWF  00,F
00E20:  MOVF   01,F
00E22:  BNZ   0E28
00E24:  CLRF   00
00E26:  BRA    0E38
00E28:  BCF    FD8.0
00E2A:  BTFSC  01.7
00E2C:  BRA    0E36
00E2E:  RLCF   02,F
00E30:  RLCF   01,F
00E32:  DECF   00,F
00E34:  BRA    0E28
00E36:  BCF    01.7
00E38:  RETURN 0
00E3A:  MOVLB  6
00E3C:  MOVF   xE0,W
00E3E:  BTFSC  FD8.2
00E40:  BRA    0F24
00E42:  MOVWF  00
00E44:  MOVF   xE4,W
00E46:  BTFSC  FD8.2
00E48:  BRA    0F24
00E4A:  ADDWF  00,F
00E4C:  BNC   0E56
00E4E:  MOVLW  81
00E50:  ADDWF  00,F
00E52:  BC    0F24
00E54:  BRA    0E5E
00E56:  MOVLW  7F
00E58:  SUBWF  00,F
00E5A:  BNC   0F24
00E5C:  BZ    0F24
00E5E:  MOVFF  6E1,6E8
00E62:  MOVF   xE5,W
00E64:  XORWF  xE8,F
00E66:  BSF    xE1.7
00E68:  BSF    xE5.7
00E6A:  MOVF   xE3,W
00E6C:  MULWF  xE7
00E6E:  MOVFF  FF4,6EA
00E72:  MOVF   xE2,W
00E74:  MULWF  xE6
00E76:  MOVFF  FF4,03
00E7A:  MOVFF  FF3,6E9
00E7E:  MULWF  xE7
00E80:  MOVF   FF3,W
00E82:  ADDWF  xEA,F
00E84:  MOVF   FF4,W
00E86:  ADDWFC xE9,F
00E88:  MOVLW  00
00E8A:  ADDWFC 03,F
00E8C:  MOVF   xE3,W
00E8E:  MULWF  xE6
00E90:  MOVF   FF3,W
00E92:  ADDWF  xEA,F
00E94:  MOVF   FF4,W
00E96:  ADDWFC xE9,F
00E98:  MOVLW  00
00E9A:  CLRF   02
00E9C:  ADDWFC 03,F
00E9E:  ADDWFC 02,F
00EA0:  MOVF   xE1,W
00EA2:  MULWF  xE7
00EA4:  MOVF   FF3,W
00EA6:  ADDWF  xE9,F
00EA8:  MOVF   FF4,W
00EAA:  ADDWFC 03,F
00EAC:  MOVLW  00
00EAE:  ADDWFC 02,F
00EB0:  MOVF   xE1,W
00EB2:  MULWF  xE6
00EB4:  MOVF   FF3,W
00EB6:  ADDWF  03,F
00EB8:  MOVF   FF4,W
00EBA:  ADDWFC 02,F
00EBC:  MOVLW  00
00EBE:  CLRF   01
00EC0:  ADDWFC 01,F
00EC2:  MOVF   xE3,W
00EC4:  MULWF  xE5
00EC6:  MOVF   FF3,W
00EC8:  ADDWF  xE9,F
00ECA:  MOVF   FF4,W
00ECC:  ADDWFC 03,F
00ECE:  MOVLW  00
00ED0:  ADDWFC 02,F
00ED2:  ADDWFC 01,F
00ED4:  MOVF   xE2,W
00ED6:  MULWF  xE5
00ED8:  MOVF   FF3,W
00EDA:  ADDWF  03,F
00EDC:  MOVF   FF4,W
00EDE:  ADDWFC 02,F
00EE0:  MOVLW  00
00EE2:  ADDWFC 01,F
00EE4:  MOVF   xE1,W
00EE6:  MULWF  xE5
00EE8:  MOVF   FF3,W
00EEA:  ADDWF  02,F
00EEC:  MOVF   FF4,W
00EEE:  ADDWFC 01,F
00EF0:  INCF   00,F
00EF2:  BTFSC  01.7
00EF4:  BRA    0F00
00EF6:  RLCF   xE9,F
00EF8:  RLCF   03,F
00EFA:  RLCF   02,F
00EFC:  RLCF   01,F
00EFE:  DECF   00,F
00F00:  MOVLW  00
00F02:  BTFSS  xE9.7
00F04:  BRA    0F1A
00F06:  INCF   03,F
00F08:  ADDWFC 02,F
00F0A:  ADDWFC 01,F
00F0C:  MOVF   01,W
00F0E:  BNZ   0F1A
00F10:  MOVF   02,W
00F12:  BNZ   0F1A
00F14:  MOVF   03,W
00F16:  BNZ   0F1A
00F18:  INCF   00,F
00F1A:  BTFSC  xE8.7
00F1C:  BSF    01.7
00F1E:  BTFSS  xE8.7
00F20:  BCF    01.7
00F22:  BRA    0F2C
00F24:  CLRF   00
00F26:  CLRF   01
00F28:  CLRF   02
00F2A:  CLRF   03
00F2C:  MOVLB  0
00F2E:  RETURN 0
00F30:  MOVLW  80
00F32:  BTFSS  FD8.1
00F34:  BRA    0F3A
00F36:  MOVLB  6
00F38:  XORWF  xE4,F
00F3A:  MOVLB  6
00F3C:  CLRF   xE9
00F3E:  CLRF   xEA
00F40:  MOVFF  6E0,6E8
00F44:  MOVF   xE4,W
00F46:  XORWF  xE8,F
00F48:  MOVF   xDF,W
00F4A:  BTFSC  FD8.2
00F4C:  BRA    110C
00F4E:  MOVWF  xE7
00F50:  MOVWF  00
00F52:  MOVF   xE3,W
00F54:  BTFSC  FD8.2
00F56:  BRA    111E
00F58:  SUBWF  xE7,F
00F5A:  BTFSC  FD8.2
00F5C:  BRA    1064
00F5E:  BNC   0FDC
00F60:  MOVFF  6E4,6ED
00F64:  BSF    xED.7
00F66:  MOVFF  6E5,6EC
00F6A:  MOVFF  6E6,6EB
00F6E:  CLRF   xEA
00F70:  BCF    FD8.0
00F72:  RRCF   xED,F
00F74:  RRCF   xEC,F
00F76:  RRCF   xEB,F
00F78:  RRCF   xEA,F
00F7A:  DECFSZ xE7,F
00F7C:  BRA    0F6E
00F7E:  BTFSS  xE8.7
00F80:  BRA    0F88
00F82:  BSF    xE9.0
00F84:  BRA    1146
00F86:  BCF    xE9.0
00F88:  BCF    xE7.0
00F8A:  BSF    xE9.4
00F8C:  MOVLW  06
00F8E:  MOVWF  FEA
00F90:  MOVLW  E2
00F92:  MOVWF  FE9
00F94:  BRA    116C
00F96:  BCF    xE9.4
00F98:  BTFSC  xE8.7
00F9A:  BRA    0FB0
00F9C:  BTFSS  xE7.0
00F9E:  BRA    0FC6
00FA0:  RRCF   xED,F
00FA2:  RRCF   xEC,F
00FA4:  RRCF   xEB,F
00FA6:  RRCF   xEA,F
00FA8:  INCF   00,F
00FAA:  BTFSC  FD8.2
00FAC:  BRA    113C
00FAE:  BRA    0FC6
00FB0:  BTFSC  xED.7
00FB2:  BRA    0FCC
00FB4:  BCF    FD8.0
00FB6:  RLCF   xEA,F
00FB8:  RLCF   xEB,F
00FBA:  RLCF   xEC,F
00FBC:  RLCF   xED,F
00FBE:  DECF   00,F
00FC0:  BTFSC  FD8.2
00FC2:  BRA    113C
00FC4:  BRA    0FB0
00FC6:  BSF    xE9.6
00FC8:  BRA    10A4
00FCA:  BCF    xE9.6
00FCC:  MOVFF  6E0,6E8
00FD0:  BTFSS  xE0.7
00FD2:  BRA    0FD8
00FD4:  BSF    xED.7
00FD6:  BRA    112E
00FD8:  BCF    xED.7
00FDA:  BRA    112E
00FDC:  MOVFF  6E3,6E7
00FE0:  MOVFF  6E3,00
00FE4:  MOVF   xDF,W
00FE6:  SUBWF  xE7,F
00FE8:  MOVFF  6E0,6ED
00FEC:  BSF    xED.7
00FEE:  MOVFF  6E1,6EC
00FF2:  MOVFF  6E2,6EB
00FF6:  CLRF   xEA
00FF8:  BCF    FD8.0
00FFA:  RRCF   xED,F
00FFC:  RRCF   xEC,F
00FFE:  RRCF   xEB,F
01000:  RRCF   xEA,F
01002:  DECFSZ xE7,F
01004:  BRA    0FF6
01006:  BTFSS  xE8.7
01008:  BRA    1010
0100A:  BSF    xE9.1
0100C:  BRA    1146
0100E:  BCF    xE9.1
01010:  BCF    xE7.0
01012:  BSF    xE9.5
01014:  MOVLW  06
01016:  MOVWF  FEA
01018:  MOVLW  E6
0101A:  MOVWF  FE9
0101C:  BRA    116C
0101E:  BCF    xE9.5
01020:  BTFSC  xE8.7
01022:  BRA    1038
01024:  BTFSS  xE7.0
01026:  BRA    104E
01028:  RRCF   xED,F
0102A:  RRCF   xEC,F
0102C:  RRCF   xEB,F
0102E:  RRCF   xEA,F
01030:  INCF   00,F
01032:  BTFSC  FD8.2
01034:  BRA    113C
01036:  BRA    104E
01038:  BTFSC  xED.7
0103A:  BRA    1054
0103C:  BCF    FD8.0
0103E:  RLCF   xEA,F
01040:  RLCF   xEB,F
01042:  RLCF   xEC,F
01044:  RLCF   xED,F
01046:  DECF   00,F
01048:  BTFSC  FD8.2
0104A:  BRA    113C
0104C:  BRA    1038
0104E:  BSF    xE9.7
01050:  BRA    10A4
01052:  BCF    xE9.7
01054:  MOVFF  6E4,6E8
01058:  BTFSS  xE4.7
0105A:  BRA    1060
0105C:  BSF    xED.7
0105E:  BRA    112E
01060:  BCF    xED.7
01062:  BRA    112E
01064:  MOVFF  6E4,6ED
01068:  BSF    xED.7
0106A:  MOVFF  6E5,6EC
0106E:  MOVFF  6E6,6EB
01072:  BTFSS  xE8.7
01074:  BRA    107E
01076:  BCF    xED.7
01078:  BSF    xE9.2
0107A:  BRA    1146
0107C:  BCF    xE9.2
0107E:  CLRF   xEA
01080:  BCF    xE7.0
01082:  MOVLW  06
01084:  MOVWF  FEA
01086:  MOVLW  E2
01088:  MOVWF  FE9
0108A:  BRA    116C
0108C:  BTFSC  xE8.7
0108E:  BRA    10C8
01090:  MOVFF  6E0,6E8
01094:  BTFSS  xE7.0
01096:  BRA    10A4
01098:  RRCF   xED,F
0109A:  RRCF   xEC,F
0109C:  RRCF   xEB,F
0109E:  RRCF   xEA,F
010A0:  INCF   00,F
010A2:  BZ    113C
010A4:  BTFSS  xEA.7
010A6:  BRA    10BE
010A8:  INCF   xEB,F
010AA:  BNZ   10BE
010AC:  INCF   xEC,F
010AE:  BNZ   10BE
010B0:  INCF   xED,F
010B2:  BNZ   10BE
010B4:  RRCF   xED,F
010B6:  RRCF   xEC,F
010B8:  RRCF   xEB,F
010BA:  INCF   00,F
010BC:  BZ    113C
010BE:  BTFSC  xE9.6
010C0:  BRA    0FCA
010C2:  BTFSC  xE9.7
010C4:  BRA    1052
010C6:  BRA    1100
010C8:  MOVLW  80
010CA:  XORWF  xED,F
010CC:  BTFSS  xED.7
010CE:  BRA    10D8
010D0:  BRA    1146
010D2:  MOVFF  6E4,6E8
010D6:  BRA    10EC
010D8:  MOVFF  6E0,6E8
010DC:  MOVF   xED,F
010DE:  BNZ   10EC
010E0:  MOVF   xEC,F
010E2:  BNZ   10EC
010E4:  MOVF   xEB,F
010E6:  BNZ   10EC
010E8:  CLRF   00
010EA:  BRA    112E
010EC:  BTFSC  xED.7
010EE:  BRA    1100
010F0:  BCF    FD8.0
010F2:  RLCF   xEA,F
010F4:  RLCF   xEB,F
010F6:  RLCF   xEC,F
010F8:  RLCF   xED,F
010FA:  DECFSZ 00,F
010FC:  BRA    10EC
010FE:  BRA    113C
01100:  BTFSS  xE8.7
01102:  BRA    1108
01104:  BSF    xED.7
01106:  BRA    112E
01108:  BCF    xED.7
0110A:  BRA    112E
0110C:  MOVFF  6E3,00
01110:  MOVFF  6E4,6ED
01114:  MOVFF  6E5,6EC
01118:  MOVFF  6E6,6EB
0111C:  BRA    112E
0111E:  MOVFF  6DF,00
01122:  MOVFF  6E0,6ED
01126:  MOVFF  6E1,6EC
0112A:  MOVFF  6E2,6EB
0112E:  MOVFF  6ED,01
01132:  MOVFF  6EC,02
01136:  MOVFF  6EB,03
0113A:  BRA    11A4
0113C:  CLRF   00
0113E:  CLRF   01
01140:  CLRF   02
01142:  CLRF   03
01144:  BRA    11A4
01146:  CLRF   xEA
01148:  COMF   xEB,F
0114A:  COMF   xEC,F
0114C:  COMF   xED,F
0114E:  COMF   xEA,F
01150:  INCF   xEA,F
01152:  BNZ   115E
01154:  INCF   xEB,F
01156:  BNZ   115E
01158:  INCF   xEC,F
0115A:  BNZ   115E
0115C:  INCF   xED,F
0115E:  BTFSC  xE9.0
01160:  BRA    0F86
01162:  BTFSC  xE9.1
01164:  BRA    100E
01166:  BTFSC  xE9.2
01168:  BRA    107C
0116A:  BRA    10D2
0116C:  MOVF   FEF,W
0116E:  ADDWF  xEB,F
01170:  BNC   117C
01172:  INCF   xEC,F
01174:  BNZ   117C
01176:  INCF   xED,F
01178:  BTFSC  FD8.2
0117A:  BSF    xE7.0
0117C:  MOVF   FED,F
0117E:  MOVF   FEF,W
01180:  ADDWF  xEC,F
01182:  BNC   118A
01184:  INCF   xED,F
01186:  BTFSC  FD8.2
01188:  BSF    xE7.0
0118A:  MOVF   FED,F
0118C:  MOVF   FEF,W
0118E:  BTFSC  FEF.7
01190:  BRA    1194
01192:  XORLW  80
01194:  ADDWF  xED,F
01196:  BTFSC  FD8.0
01198:  BSF    xE7.0
0119A:  BTFSC  xE9.4
0119C:  BRA    0F96
0119E:  BTFSC  xE9.5
011A0:  BRA    101E
011A2:  BRA    108C
011A4:  MOVLB  0
011A6:  RETURN 0
*
016FE:  ADDWF  FE8,W
01700:  CLRF   FF7
01702:  RLCF   FF7,F
01704:  ADDLW  19
01706:  MOVWF  FF6
01708:  MOVLW  17
0170A:  ADDWFC FF7,F
0170C:  TBLRD*-
0170E:  MOVF   FF5,W
01710:  MOVWF  FFA
01712:  TBLRD*
01714:  MOVF   FF5,W
01716:  MOVWF  FF9
01718:  DATA C0,11
0171A:  DATA 80,12
0171C:  DATA 40,13
0171E:  DATA 00,14
01720:  DATA C0,14
01722:  DATA 80,15
01724:  DATA 40,16
*
0194C:  BTFSC  FD8.1
0194E:  BRA    1958
01950:  MOVLW  06
01952:  MOVWF  FEA
01954:  MOVLW  F7
01956:  MOVWF  FE9
01958:  MOVLB  6
0195A:  MOVF   xF2,W
0195C:  XORWF  xF6,W
0195E:  ANDLW  80
01960:  MOVWF  xFC
01962:  BTFSS  xF2.7
01964:  BRA    197C
01966:  COMF   xEF,F
01968:  COMF   xF0,F
0196A:  COMF   xF1,F
0196C:  COMF   xF2,F
0196E:  INCF   xEF,F
01970:  BTFSC  FD8.2
01972:  INCF   xF0,F
01974:  BTFSC  FD8.2
01976:  INCF   xF1,F
01978:  BTFSC  FD8.2
0197A:  INCF   xF2,F
0197C:  BTFSS  xF6.7
0197E:  BRA    1996
01980:  COMF   xF3,F
01982:  COMF   xF4,F
01984:  COMF   xF5,F
01986:  COMF   xF6,F
01988:  INCF   xF3,F
0198A:  BTFSC  FD8.2
0198C:  INCF   xF4,F
0198E:  BTFSC  FD8.2
01990:  INCF   xF5,F
01992:  BTFSC  FD8.2
01994:  INCF   xF6,F
01996:  CLRF   00
01998:  CLRF   01
0199A:  CLRF   02
0199C:  CLRF   03
0199E:  CLRF   xF7
019A0:  CLRF   xF8
019A2:  CLRF   xF9
019A4:  CLRF   xFA
019A6:  MOVF   xF6,W
019A8:  IORWF  xF5,W
019AA:  IORWF  xF4,W
019AC:  IORWF  xF3,W
019AE:  BZ    1A08
019B0:  MOVLW  20
019B2:  MOVWF  xFB
019B4:  BCF    FD8.0
019B6:  RLCF   xEF,F
019B8:  RLCF   xF0,F
019BA:  RLCF   xF1,F
019BC:  RLCF   xF2,F
019BE:  RLCF   xF7,F
019C0:  RLCF   xF8,F
019C2:  RLCF   xF9,F
019C4:  RLCF   xFA,F
019C6:  MOVF   xF6,W
019C8:  SUBWF  xFA,W
019CA:  BNZ   19DC
019CC:  MOVF   xF5,W
019CE:  SUBWF  xF9,W
019D0:  BNZ   19DC
019D2:  MOVF   xF4,W
019D4:  SUBWF  xF8,W
019D6:  BNZ   19DC
019D8:  MOVF   xF3,W
019DA:  SUBWF  xF7,W
019DC:  BNC   19FC
019DE:  MOVF   xF3,W
019E0:  SUBWF  xF7,F
019E2:  MOVF   xF4,W
019E4:  BTFSS  FD8.0
019E6:  INCFSZ xF4,W
019E8:  SUBWF  xF8,F
019EA:  MOVF   xF5,W
019EC:  BTFSS  FD8.0
019EE:  INCFSZ xF5,W
019F0:  SUBWF  xF9,F
019F2:  MOVF   xF6,W
019F4:  BTFSS  FD8.0
019F6:  INCFSZ xF6,W
019F8:  SUBWF  xFA,F
019FA:  BSF    FD8.0
019FC:  RLCF   00,F
019FE:  RLCF   01,F
01A00:  RLCF   02,F
01A02:  RLCF   03,F
01A04:  DECFSZ xFB,F
01A06:  BRA    19B4
01A08:  BTFSS  xFC.7
01A0A:  BRA    1A22
01A0C:  COMF   00,F
01A0E:  COMF   01,F
01A10:  COMF   02,F
01A12:  COMF   03,F
01A14:  INCF   00,F
01A16:  BTFSC  FD8.2
01A18:  INCF   01,F
01A1A:  BTFSC  FD8.2
01A1C:  INCF   02,F
01A1E:  BTFSC  FD8.2
01A20:  INCF   03,F
01A22:  MOVFF  6F7,FEF
01A26:  MOVFF  6F8,FEC
01A2A:  MOVFF  6F9,FEC
01A2E:  MOVFF  6FA,FEC
01A32:  MOVLB  0
01A34:  RETURN 0
*
01DBE:  MOVLW  B6
01DC0:  MOVWF  00
01DC2:  CLRF   03
01DC4:  CLRF   02
01DC6:  CLRF   01
01DC8:  MOVLB  6
01DCA:  BCF    xA9.0
01DCC:  BTFSS  xA8.7
01DCE:  BRA    1DE8
01DD0:  BSF    xA9.0
01DD2:  COMF   xA5,F
01DD4:  COMF   xA6,F
01DD6:  COMF   xA7,F
01DD8:  COMF   xA8,F
01DDA:  INCF   xA5,F
01DDC:  BNZ   1DE8
01DDE:  INCF   xA6,F
01DE0:  BNZ   1DE8
01DE2:  INCF   xA7,F
01DE4:  BTFSC  FD8.2
01DE6:  INCF   xA8,F
01DE8:  MOVF   xA5,W
01DEA:  IORWF  xA6,W
01DEC:  IORWF  xA7,W
01DEE:  IORWF  xA8,W
01DF0:  BNZ   1DF6
01DF2:  CLRF   00
01DF4:  BRA    1E14
01DF6:  BCF    FD8.0
01DF8:  BTFSC  01.7
01DFA:  BRA    1E0E
01DFC:  RLCF   xA5,F
01DFE:  RLCF   xA6,F
01E00:  RLCF   xA7,F
01E02:  RLCF   xA8,F
01E04:  RLCF   03,F
01E06:  RLCF   02,F
01E08:  RLCF   01,F
01E0A:  DECFSZ 00,F
01E0C:  BRA    1DF6
01E0E:  BCF    01.7
01E10:  BTFSC  xA9.0
01E12:  BSF    01.7
01E14:  MOVLB  0
01E16:  RETURN 0
01E18:  MOVFF  6DC,6E3
01E1C:  MOVLB  6
01E1E:  MOVF   xE0,W
01E20:  XORWF  xE3,F
01E22:  BTFSS  xE3.7
01E24:  BRA    1E30
01E26:  BCF    FD8.2
01E28:  BCF    FD8.0
01E2A:  BTFSC  xDC.7
01E2C:  BSF    FD8.0
01E2E:  BRA    1E8E
01E30:  MOVFF  6DC,6E3
01E34:  MOVFF  6DF,6E4
01E38:  MOVF   xDB,W
01E3A:  SUBWF  xE4,F
01E3C:  BZ    1E4A
01E3E:  BTFSS  xE3.7
01E40:  BRA    1E8E
01E42:  MOVF   FD8,W
01E44:  XORLW  01
01E46:  MOVWF  FD8
01E48:  BRA    1E8E
01E4A:  MOVFF  6E0,6E4
01E4E:  MOVF   xDC,W
01E50:  SUBWF  xE4,F
01E52:  BZ    1E60
01E54:  BTFSS  xE3.7
01E56:  BRA    1E8E
01E58:  MOVF   FD8,W
01E5A:  XORLW  01
01E5C:  MOVWF  FD8
01E5E:  BRA    1E8E
01E60:  MOVFF  6E1,6E4
01E64:  MOVF   xDD,W
01E66:  SUBWF  xE4,F
01E68:  BZ    1E76
01E6A:  BTFSS  xE3.7
01E6C:  BRA    1E8E
01E6E:  MOVF   FD8,W
01E70:  XORLW  01
01E72:  MOVWF  FD8
01E74:  BRA    1E8E
01E76:  MOVFF  6E2,6E4
01E7A:  MOVF   xDE,W
01E7C:  SUBWF  xE4,F
01E7E:  BZ    1E8C
01E80:  BTFSS  xE3.7
01E82:  BRA    1E8E
01E84:  MOVF   FD8,W
01E86:  XORLW  01
01E88:  MOVWF  FD8
01E8A:  BRA    1E8E
01E8C:  BCF    FD8.0
01E8E:  MOVLB  0
01E90:  RETURN 0
01E92:  MOVLB  6
01E94:  MOVF   xD4,W
01E96:  BTFSC  FD8.2
01E98:  BRA    1FE4
01E9A:  MOVWF  xE0
01E9C:  MOVF   xD8,W
01E9E:  BTFSC  FD8.2
01EA0:  BRA    1FE4
01EA2:  SUBWF  xE0,F
01EA4:  BNC   1EB0
01EA6:  MOVLW  7F
01EA8:  ADDWF  xE0,F
01EAA:  BTFSC  FD8.0
01EAC:  BRA    1FE4
01EAE:  BRA    1EBC
01EB0:  MOVLW  81
01EB2:  SUBWF  xE0,F
01EB4:  BTFSS  FD8.0
01EB6:  BRA    1FE4
01EB8:  BTFSC  FD8.2
01EBA:  BRA    1FE4
01EBC:  MOVFF  6E0,00
01EC0:  CLRF   01
01EC2:  CLRF   02
01EC4:  CLRF   03
01EC6:  CLRF   xDF
01EC8:  MOVFF  6D5,6DE
01ECC:  BSF    xDE.7
01ECE:  MOVFF  6D6,6DD
01ED2:  MOVFF  6D7,6DC
01ED6:  MOVLW  19
01ED8:  MOVWF  xE0
01EDA:  MOVF   xDB,W
01EDC:  SUBWF  xDC,F
01EDE:  BC    1EFA
01EE0:  MOVLW  01
01EE2:  SUBWF  xDD,F
01EE4:  BC    1EFA
01EE6:  SUBWF  xDE,F
01EE8:  BC    1EFA
01EEA:  SUBWF  xDF,F
01EEC:  BC    1EFA
01EEE:  INCF   xDF,F
01EF0:  INCF   xDE,F
01EF2:  INCF   xDD,F
01EF4:  MOVF   xDB,W
01EF6:  ADDWF  xDC,F
01EF8:  BRA    1F4A
01EFA:  MOVF   xDA,W
01EFC:  SUBWF  xDD,F
01EFE:  BC    1F24
01F00:  MOVLW  01
01F02:  SUBWF  xDE,F
01F04:  BC    1F24
01F06:  SUBWF  xDF,F
01F08:  BC    1F24
01F0A:  INCF   xDF,F
01F0C:  INCF   xDE,F
01F0E:  MOVF   xDA,W
01F10:  ADDWF  xDD,F
01F12:  MOVF   xDB,W
01F14:  ADDWF  xDC,F
01F16:  BNC   1F4A
01F18:  INCF   xDD,F
01F1A:  BNZ   1F4A
01F1C:  INCF   xDE,F
01F1E:  BNZ   1F4A
01F20:  INCF   xDF,F
01F22:  BRA    1F4A
01F24:  MOVF   xD9,W
01F26:  IORLW  80
01F28:  SUBWF  xDE,F
01F2A:  BC    1F48
01F2C:  MOVLW  01
01F2E:  SUBWF  xDF,F
01F30:  BC    1F48
01F32:  INCF   xDF,F
01F34:  MOVF   xD9,W
01F36:  IORLW  80
01F38:  ADDWF  xDE,F
01F3A:  MOVF   xDA,W
01F3C:  ADDWF  xDD,F
01F3E:  BNC   1F12
01F40:  INCF   xDE,F
01F42:  BNZ   1F12
01F44:  INCF   xDF,F
01F46:  BRA    1F12
01F48:  BSF    03.0
01F4A:  DECFSZ xE0,F
01F4C:  BRA    1F50
01F4E:  BRA    1F66
01F50:  BCF    FD8.0
01F52:  RLCF   xDC,F
01F54:  RLCF   xDD,F
01F56:  RLCF   xDE,F
01F58:  RLCF   xDF,F
01F5A:  BCF    FD8.0
01F5C:  RLCF   03,F
01F5E:  RLCF   02,F
01F60:  RLCF   01,F
01F62:  RLCF   xE1,F
01F64:  BRA    1EDA
01F66:  BTFSS  xE1.0
01F68:  BRA    1F76
01F6A:  BCF    FD8.0
01F6C:  RRCF   01,F
01F6E:  RRCF   02,F
01F70:  RRCF   03,F
01F72:  RRCF   xE1,F
01F74:  BRA    1F7A
01F76:  DECF   00,F
01F78:  BZ    1FE4
01F7A:  BTFSC  xE1.7
01F7C:  BRA    1FBA
01F7E:  BCF    FD8.0
01F80:  RLCF   xDC,F
01F82:  RLCF   xDD,F
01F84:  RLCF   xDE,F
01F86:  RLCF   xDF,F
01F88:  MOVF   xDB,W
01F8A:  SUBWF  xDC,F
01F8C:  BC    1F9C
01F8E:  MOVLW  01
01F90:  SUBWF  xDD,F
01F92:  BC    1F9C
01F94:  SUBWF  xDE,F
01F96:  BC    1F9C
01F98:  SUBWF  xDF,F
01F9A:  BNC   1FD0
01F9C:  MOVF   xDA,W
01F9E:  SUBWF  xDD,F
01FA0:  BC    1FAC
01FA2:  MOVLW  01
01FA4:  SUBWF  xDE,F
01FA6:  BC    1FAC
01FA8:  SUBWF  xDF,F
01FAA:  BNC   1FD0
01FAC:  MOVF   xD9,W
01FAE:  IORLW  80
01FB0:  SUBWF  xDE,F
01FB2:  BC    1FBA
01FB4:  MOVLW  01
01FB6:  SUBWF  xDF,F
01FB8:  BNC   1FD0
01FBA:  INCF   03,F
01FBC:  BNZ   1FD0
01FBE:  INCF   02,F
01FC0:  BNZ   1FD0
01FC2:  INCF   01,F
01FC4:  BNZ   1FD0
01FC6:  INCF   00,F
01FC8:  BZ    1FE4
01FCA:  RRCF   01,F
01FCC:  RRCF   02,F
01FCE:  RRCF   03,F
01FD0:  MOVFF  6D5,6E0
01FD4:  MOVF   xD9,W
01FD6:  XORWF  xE0,F
01FD8:  BTFSS  xE0.7
01FDA:  BRA    1FE0
01FDC:  BSF    01.7
01FDE:  BRA    1FEC
01FE0:  BCF    01.7
01FE2:  BRA    1FEC
01FE4:  CLRF   00
01FE6:  CLRF   01
01FE8:  CLRF   02
01FEA:  CLRF   03
01FEC:  MOVLB  0
01FEE:  RETURN 0
*
0279A:  ADDWF  FE8,W
0279C:  CLRF   FF7
0279E:  RLCF   FF7,F
027A0:  ADDLW  B5
027A2:  MOVWF  FF6
027A4:  MOVLW  27
027A6:  ADDWFC FF7,F
027A8:  TBLRD*-
027AA:  MOVF   FF5,W
027AC:  MOVWF  FFA
027AE:  TBLRD*
027B0:  MOVF   FF5,W
027B2:  MOVWF  FF9
027B4:  DATA A2,26
027B6:  DATA BC,26
027B8:  DATA 10,27
027BA:  DATA 74,27
027BC:  MOVLW  8E
027BE:  MOVWF  00
027C0:  MOVFF  6D2,01
027C4:  MOVFF  6D1,02
027C8:  CLRF   03
027CA:  BTFSS  01.7
027CC:  BRA    27D8
027CE:  COMF   01,F
027D0:  COMF   02,F
027D2:  INCF   02,F
027D4:  BNZ   27D8
027D6:  INCF   01,F
027D8:  MOVF   01,F
027DA:  BNZ   27EE
027DC:  MOVFF  02,01
027E0:  CLRF   02
027E2:  MOVLW  08
027E4:  SUBWF  00,F
027E6:  MOVF   01,F
027E8:  BNZ   27EE
027EA:  CLRF   00
027EC:  BRA    280A
027EE:  BCF    FD8.0
027F0:  BTFSC  01.7
027F2:  BRA    27FC
027F4:  RLCF   02,F
027F6:  RLCF   01,F
027F8:  DECF   00,F
027FA:  BRA    27EE
027FC:  MOVLB  6
027FE:  BTFSS  xD2.7
02800:  BRA    2806
02802:  MOVLB  0
02804:  BRA    280A
02806:  BCF    01.7
02808:  MOVLB  0
0280A:  RETURN 0
0280C:  MOVLW  8E
0280E:  MOVWF  00
02810:  MOVLB  6
02812:  MOVF   xDB,W
02814:  SUBWF  00,F
02816:  MOVFF  6DC,02
0281A:  MOVFF  6DD,01
0281E:  BSF    02.7
02820:  MOVF   00,F
02822:  BZ    2836
02824:  BCF    FD8.0
02826:  MOVF   02,F
02828:  BNZ   282E
0282A:  MOVF   01,F
0282C:  BZ    2836
0282E:  RRCF   02,F
02830:  RRCF   01,F
02832:  DECFSZ 00,F
02834:  BRA    2824
02836:  BTFSS  xDC.7
02838:  BRA    2844
0283A:  COMF   01,F
0283C:  COMF   02,F
0283E:  INCF   01,F
02840:  BTFSC  FD8.2
02842:  INCF   02,F
02844:  MOVLB  0
02846:  RETURN 0
*
04684:  MOVLB  6
04686:  MOVF   x9D,W
04688:  ANDLW  07
0468A:  MOVWF  00
0468C:  RRCF   x9D,W
0468E:  MOVWF  01
04690:  RRCF   01,F
04692:  RRCF   01,F
04694:  MOVLW  1F
04696:  ANDWF  01,F
04698:  MOVF   01,W
0469A:  ADDWF  x9E,W
0469C:  MOVWF  FE9
0469E:  MOVLW  00
046A0:  ADDWFC x9F,W
046A2:  MOVWF  FEA
046A4:  MOVFF  FEF,01
046A8:  INCF   00,F
046AA:  BRA    46AE
046AC:  RRCF   01,F
046AE:  DECFSZ 00,F
046B0:  BRA    46AC
046B2:  MOVLW  01
046B4:  ANDWF  01,F
046B6:  MOVLB  0
046B8:  RETURN 0
*
050BA:  MOVF   FEF,F
050BC:  BZ    50DC
050BE:  MOVFF  FEA,696
050C2:  MOVFF  FE9,695
050C6:  MOVFF  FEF,6A6
050CA:  RCALL  5092
050CC:  MOVFF  696,FEA
050D0:  MOVFF  695,FE9
050D4:  INCF   FE9,F
050D6:  BTFSC  FD8.2
050D8:  INCF   FEA,F
050DA:  BRA    50BA
050DC:  RETURN 0
*
055D6:  TBLRD*+
055D8:  MOVFF  FF6,69A
055DC:  MOVFF  FF7,69B
055E0:  MOVFF  FF5,6A6
055E4:  RCALL  5092
055E6:  MOVFF  69A,FF6
055EA:  MOVFF  69B,FF7
055EE:  MOVLB  6
055F0:  DECFSZ x99,F
055F2:  BRA    55F6
055F4:  BRA    55FA
055F6:  MOVLB  0
055F8:  BRA    55D6
055FA:  MOVLB  0
055FC:  RETURN 0
055FE:  MOVLB  6
05600:  MOVF   xCB,W
05602:  CLRF   01
05604:  SUBWF  xCA,W
05606:  BC    560E
05608:  MOVFF  6CA,00
0560C:  BRA    5626
0560E:  CLRF   00
05610:  MOVLW  08
05612:  MOVWF  xCC
05614:  RLCF   xCA,F
05616:  RLCF   00,F
05618:  MOVF   xCB,W
0561A:  SUBWF  00,W
0561C:  BTFSC  FD8.0
0561E:  MOVWF  00
05620:  RLCF   01,F
05622:  DECFSZ xCC,F
05624:  BRA    5614
05626:  MOVLB  0
05628:  RETURN 0
0562A:  MOVF   01,W
0562C:  MOVFF  699,6CA
05630:  MOVLW  64
05632:  MOVLB  6
05634:  MOVWF  xCB
05636:  MOVLB  0
05638:  RCALL  55FE
0563A:  MOVFF  00,699
0563E:  MOVF   01,W
05640:  MOVLW  30
05642:  BNZ   5654
05644:  MOVLB  6
05646:  BTFSS  x9A.1
05648:  BRA    5668
0564A:  BTFSC  x9A.3
0564C:  BRA    5668
0564E:  BTFSC  x9A.4
05650:  MOVLW  20
05652:  BRA    565C
05654:  MOVLB  6
05656:  BCF    x9A.3
05658:  BCF    x9A.4
0565A:  BSF    x9A.0
0565C:  ADDWF  01,F
0565E:  MOVFF  01,6A6
05662:  MOVLB  0
05664:  RCALL  5092
05666:  MOVLB  6
05668:  MOVFF  699,6CA
0566C:  MOVLW  0A
0566E:  MOVWF  xCB
05670:  MOVLB  0
05672:  RCALL  55FE
05674:  MOVFF  00,699
05678:  MOVF   01,W
0567A:  MOVLW  30
0567C:  BNZ   568E
0567E:  MOVLB  6
05680:  BTFSC  x9A.3
05682:  BRA    5698
05684:  BTFSS  x9A.0
05686:  BRA    5698
05688:  BTFSC  x9A.4
0568A:  MOVLW  20
0568C:  MOVLB  0
0568E:  ADDWF  01,F
05690:  MOVFF  01,6A6
05694:  RCALL  5092
05696:  MOVLB  6
05698:  MOVLW  30
0569A:  ADDWF  x99,F
0569C:  MOVFF  699,6A6
056A0:  MOVLB  0
056A2:  RCALL  5092
056A4:  RETURN 0
056A6:  MOVLB  6
056A8:  MOVF   xE0,W
056AA:  SUBLW  B6
056AC:  MOVWF  xE0
056AE:  CLRF   03
056B0:  MOVFF  6E1,6E4
056B4:  BSF    xE1.7
056B6:  BCF    FD8.0
056B8:  RRCF   xE1,F
056BA:  RRCF   xE2,F
056BC:  RRCF   xE3,F
056BE:  RRCF   03,F
056C0:  RRCF   02,F
056C2:  RRCF   01,F
056C4:  RRCF   00,F
056C6:  DECFSZ xE0,F
056C8:  BRA    56B6
056CA:  BTFSS  xE4.7
056CC:  BRA    56E4
056CE:  COMF   00,F
056D0:  COMF   01,F
056D2:  COMF   02,F
056D4:  COMF   03,F
056D6:  INCF   00,F
056D8:  BTFSC  FD8.2
056DA:  INCF   01,F
056DC:  BTFSC  FD8.2
056DE:  INCF   02,F
056E0:  BTFSC  FD8.2
056E2:  INCF   03,F
056E4:  MOVLB  0
056E6:  RETURN 0
056E8:  BTFSC  FD8.1
056EA:  BRA    56F4
056EC:  MOVLW  06
056EE:  MOVWF  FEA
056F0:  MOVLW  E8
056F2:  MOVWF  FE9
056F4:  CLRF   00
056F6:  CLRF   01
056F8:  CLRF   02
056FA:  CLRF   03
056FC:  MOVLB  6
056FE:  CLRF   xE8
05700:  CLRF   xE9
05702:  CLRF   xEA
05704:  CLRF   xEB
05706:  MOVF   xE7,W
05708:  IORWF  xE6,W
0570A:  IORWF  xE5,W
0570C:  IORWF  xE4,W
0570E:  BZ    5768
05710:  MOVLW  20
05712:  MOVWF  xEC
05714:  BCF    FD8.0
05716:  RLCF   xE0,F
05718:  RLCF   xE1,F
0571A:  RLCF   xE2,F
0571C:  RLCF   xE3,F
0571E:  RLCF   xE8,F
05720:  RLCF   xE9,F
05722:  RLCF   xEA,F
05724:  RLCF   xEB,F
05726:  MOVF   xE7,W
05728:  SUBWF  xEB,W
0572A:  BNZ   573C
0572C:  MOVF   xE6,W
0572E:  SUBWF  xEA,W
05730:  BNZ   573C
05732:  MOVF   xE5,W
05734:  SUBWF  xE9,W
05736:  BNZ   573C
05738:  MOVF   xE4,W
0573A:  SUBWF  xE8,W
0573C:  BNC   575C
0573E:  MOVF   xE4,W
05740:  SUBWF  xE8,F
05742:  MOVF   xE5,W
05744:  BTFSS  FD8.0
05746:  INCFSZ xE5,W
05748:  SUBWF  xE9,F
0574A:  MOVF   xE6,W
0574C:  BTFSS  FD8.0
0574E:  INCFSZ xE6,W
05750:  SUBWF  xEA,F
05752:  MOVF   xE7,W
05754:  BTFSS  FD8.0
05756:  INCFSZ xE7,W
05758:  SUBWF  xEB,F
0575A:  BSF    FD8.0
0575C:  RLCF   00,F
0575E:  RLCF   01,F
05760:  RLCF   02,F
05762:  RLCF   03,F
05764:  DECFSZ xEC,F
05766:  BRA    5714
05768:  MOVFF  6E8,FEF
0576C:  MOVFF  6E9,FEC
05770:  MOVFF  6EA,FEC
05774:  MOVFF  6EB,FEC
05778:  MOVLB  0
0577A:  RETURN 0
0577C:  MOVF   FE9,W
0577E:  MOVLB  6
05780:  MOVWF  x9E
05782:  MOVF   x9D,W
05784:  MOVWF  xA0
05786:  BZ    57C0
05788:  MOVFF  69C,6E3
0578C:  MOVFF  69B,6E2
05790:  MOVFF  69A,6E1
05794:  MOVFF  699,6E0
05798:  CLRF   xE7
0579A:  CLRF   xE6
0579C:  MOVLW  20
0579E:  MOVWF  xE5
057A0:  MOVLW  82
057A2:  MOVWF  xE4
057A4:  MOVLB  0
057A6:  CALL   0E3A
057AA:  MOVFF  03,69C
057AE:  MOVFF  02,69B
057B2:  MOVFF  01,69A
057B6:  MOVFF  00,699
057BA:  MOVLB  6
057BC:  DECFSZ xA0,F
057BE:  BRA    5788
057C0:  MOVFF  69C,6E3
057C4:  MOVFF  69B,6E2
057C8:  MOVFF  69A,6E1
057CC:  MOVFF  699,6E0
057D0:  MOVLB  0
057D2:  RCALL  56A6
057D4:  MOVFF  03,69C
057D8:  MOVFF  02,69B
057DC:  MOVFF  01,69A
057E0:  MOVFF  00,699
057E4:  MOVLB  6
057E6:  BTFSS  x9C.7
057E8:  BRA    5804
057EA:  DECF   x9E,F
057EC:  BSF    x9E.5
057EE:  COMF   x99,F
057F0:  COMF   x9A,F
057F2:  COMF   x9B,F
057F4:  COMF   x9C,F
057F6:  INCF   x99,F
057F8:  BTFSC  FD8.2
057FA:  INCF   x9A,F
057FC:  BTFSC  FD8.2
057FE:  INCF   x9B,F
05800:  BTFSC  FD8.2
05802:  INCF   x9C,F
05804:  MOVLW  3B
05806:  MOVWF  xA5
05808:  MOVLW  9A
0580A:  MOVWF  xA4
0580C:  MOVLW  CA
0580E:  MOVWF  xA3
05810:  CLRF   xA2
05812:  MOVLW  0A
05814:  MOVWF  xA0
05816:  MOVF   x9D,W
05818:  BTFSC  FD8.2
0581A:  INCF   x9E,F
0581C:  BSF    FD8.1
0581E:  MOVLW  06
05820:  MOVWF  FEA
05822:  MOVLW  99
05824:  MOVWF  FE9
05826:  MOVFF  69C,6E3
0582A:  MOVFF  69B,6E2
0582E:  MOVFF  69A,6E1
05832:  MOVFF  699,6E0
05836:  MOVFF  6A5,6E7
0583A:  MOVFF  6A4,6E6
0583E:  MOVFF  6A3,6E5
05842:  MOVFF  6A2,6E4
05846:  MOVLB  0
05848:  RCALL  56E8
0584A:  MOVF   01,W
0584C:  MOVF   00,F
0584E:  BNZ   5876
05850:  MOVLB  6
05852:  INCF   x9D,W
05854:  SUBWF  xA0,W
05856:  BTFSS  FD8.2
05858:  BRA    585E
0585A:  MOVLB  0
0585C:  BRA    5876
0585E:  MOVF   x9E,W
05860:  BZ    587C
05862:  ANDLW  0F
05864:  SUBWF  xA0,W
05866:  BZ    586A
05868:  BC    58F2
0586A:  BTFSC  x9E.7
0586C:  BRA    58F2
0586E:  BTFSC  x9E.6
05870:  BRA    587C
05872:  MOVLW  20
05874:  BRA    58E4
05876:  MOVLW  20
05878:  MOVLB  6
0587A:  ANDWF  x9E,F
0587C:  BTFSS  x9E.5
0587E:  BRA    589E
05880:  BCF    x9E.5
05882:  MOVF   x9D,W
05884:  BTFSS  FD8.2
05886:  DECF   x9E,F
05888:  MOVF   00,W
0588A:  MOVWF  x9E
0588C:  MOVLW  2D
0588E:  MOVWF  xA6
05890:  MOVLB  0
05892:  CALL   5092
05896:  MOVLB  6
05898:  MOVF   x9E,W
0589A:  MOVWF  00
0589C:  CLRF   x9E
0589E:  MOVF   x9D,W
058A0:  SUBWF  xA0,W
058A2:  BNZ   58BE
058A4:  MOVF   00,W
058A6:  MOVWF  x9E
058A8:  MOVLW  2E
058AA:  MOVWF  xA6
058AC:  MOVLB  0
058AE:  CALL   5092
058B2:  MOVLB  6
058B4:  MOVF   x9E,W
058B6:  MOVWF  00
058B8:  MOVLW  20
058BA:  ANDWF  x9E,F
058BC:  MOVLW  00
058BE:  MOVLW  30
058C0:  BTFSS  x9E.5
058C2:  BRA    58E4
058C4:  BCF    x9E.5
058C6:  MOVF   x9D,W
058C8:  BTFSS  FD8.2
058CA:  DECF   x9E,F
058CC:  MOVF   00,W
058CE:  MOVWF  x9E
058D0:  MOVLW  2D
058D2:  MOVWF  xA6
058D4:  MOVLB  0
058D6:  CALL   5092
058DA:  MOVLB  6
058DC:  MOVF   x9E,W
058DE:  MOVWF  00
058E0:  CLRF   x9E
058E2:  MOVLW  30
058E4:  ADDWF  00,F
058E6:  MOVFF  00,6A6
058EA:  MOVLB  0
058EC:  CALL   5092
058F0:  MOVLB  6
058F2:  BCF    FD8.1
058F4:  MOVFF  6A5,6E3
058F8:  MOVFF  6A4,6E2
058FC:  MOVFF  6A3,6E1
05900:  MOVFF  6A2,6E0
05904:  CLRF   xE7
05906:  CLRF   xE6
05908:  CLRF   xE5
0590A:  MOVLW  0A
0590C:  MOVWF  xE4
0590E:  MOVLB  0
05910:  RCALL  56E8
05912:  MOVFF  03,6A5
05916:  MOVFF  02,6A4
0591A:  MOVFF  01,6A3
0591E:  MOVFF  00,6A2
05922:  MOVLB  6
05924:  DECFSZ xA0,F
05926:  BRA    581C
05928:  MOVLB  0
0592A:  RETURN 0
0592C:  MOVFF  FEA,69D
05930:  MOVFF  FE9,69C
05934:  MOVLB  6
05936:  SWAPF  x96,W
05938:  IORLW  F0
0593A:  MOVWF  x98
0593C:  ADDWF  x98,F
0593E:  ADDLW  E2
05940:  MOVWF  x99
05942:  ADDLW  32
05944:  MOVWF  x9B
05946:  MOVF   x96,W
05948:  ANDLW  0F
0594A:  ADDWF  x99,F
0594C:  ADDWF  x99,F
0594E:  ADDWF  x9B,F
05950:  ADDLW  E9
05952:  MOVWF  x9A
05954:  ADDWF  x9A,F
05956:  ADDWF  x9A,F
05958:  SWAPF  x95,W
0595A:  ANDLW  0F
0595C:  ADDWF  x9A,F
0595E:  ADDWF  x9B,F
05960:  RLCF   x9A,F
05962:  RLCF   x9B,F
05964:  COMF   x9B,F
05966:  RLCF   x9B,F
05968:  MOVF   x95,W
0596A:  ANDLW  0F
0596C:  ADDWF  x9B,F
0596E:  RLCF   x98,F
05970:  MOVLW  07
05972:  MOVWF  x97
05974:  MOVLW  0A
05976:  DECF   x9A,F
05978:  ADDWF  x9B,F
0597A:  BNC   5976
0597C:  DECF   x99,F
0597E:  ADDWF  x9A,F
05980:  BNC   597C
05982:  DECF   x98,F
05984:  ADDWF  x99,F
05986:  BNC   5982
05988:  DECF   x97,F
0598A:  ADDWF  x98,F
0598C:  BNC   5988
0598E:  MOVLW  06
05990:  MOVWF  FEA
05992:  MOVLW  97
05994:  MOVWF  FE9
05996:  MOVLW  07
05998:  ANDWF  x9C,W
0599A:  BCF    x9C.6
0599C:  ADDWF  FE9,F
0599E:  MOVLW  00
059A0:  ADDWFC FEA,F
059A2:  MOVF   FE9,W
059A4:  SUBLW  9B
059A6:  BNZ   59B0
059A8:  MOVF   FEA,W
059AA:  SUBLW  06
059AC:  BNZ   59B0
059AE:  BSF    x9C.6
059B0:  MOVF   FEF,W
059B2:  MOVWF  00
059B4:  BNZ   59C6
059B6:  BTFSC  x9C.6
059B8:  BRA    59C6
059BA:  BTFSC  x9C.4
059BC:  BRA    59EA
059BE:  BTFSC  x9C.3
059C0:  BRA    59C6
059C2:  MOVLW  20
059C4:  BRA    59CC
059C6:  BSF    x9C.3
059C8:  BCF    x9C.4
059CA:  MOVLW  30
059CC:  ADDWF  00,F
059CE:  MOVFF  FEA,696
059D2:  MOVFF  FE9,695
059D6:  MOVFF  00,6A6
059DA:  MOVLB  0
059DC:  CALL   5092
059E0:  MOVFF  696,FEA
059E4:  MOVFF  695,FE9
059E8:  MOVLB  6
059EA:  MOVF   FEE,W
059EC:  BTFSS  x9C.6
059EE:  BRA    59A2
059F0:  MOVLB  0
059F2:  RETURN 0
*
05B38:  MOVFF  583,FEA
05B3C:  MOVFF  582,FE9
05B40:  MOVFF  6E0,FEF
05B44:  INCF   FE9,F
05B46:  BTFSC  FD8.2
05B48:  INCF   FEA,F
05B4A:  CLRF   FEF
05B4C:  MOVLB  5
05B4E:  INCF   x82,F
05B50:  BTFSC  FD8.2
05B52:  INCF   x83,F
05B54:  MOVLB  0
05B56:  RETURN 0
05B58:  TBLRD*+
05B5A:  MOVF   FF5,F
05B5C:  BZ    5B76
05B5E:  MOVFF  FF6,69E
05B62:  MOVFF  FF7,69F
05B66:  MOVFF  FF5,6E0
05B6A:  RCALL  5B38
05B6C:  MOVFF  69E,FF6
05B70:  MOVFF  69F,FF7
05B74:  BRA    5B58
05B76:  RETURN 0
*
05FF0:  MOVLW  20
05FF2:  MOVLB  6
05FF4:  BTFSS  xC5.4
05FF6:  MOVLW  30
05FF8:  MOVWF  xC6
05FFA:  MOVFF  6C4,00
05FFE:  BTFSS  00.7
06000:  BRA    6012
06002:  COMF   00,F
06004:  INCF   00,F
06006:  MOVFF  00,6C4
0600A:  MOVLW  2D
0600C:  MOVWF  xC6
0600E:  BSF    xC5.7
06010:  BSF    xC5.0
06012:  MOVF   01,W
06014:  MOVFF  6C4,6CA
06018:  MOVLW  64
0601A:  MOVWF  xCB
0601C:  MOVLB  0
0601E:  CALL   55FE
06022:  MOVFF  00,6C4
06026:  MOVLW  30
06028:  ADDWF  01,W
0602A:  MOVLB  6
0602C:  MOVWF  xC7
0602E:  MOVFF  6C4,6CA
06032:  MOVLW  0A
06034:  MOVWF  xCB
06036:  MOVLB  0
06038:  CALL   55FE
0603C:  MOVLW  30
0603E:  ADDWF  00,W
06040:  MOVLB  6
06042:  MOVWF  xC9
06044:  MOVLW  30
06046:  ADDWF  01,W
06048:  MOVWF  xC8
0604A:  MOVFF  6C6,00
0604E:  MOVLW  30
06050:  SUBWF  xC7,W
06052:  BZ    605C
06054:  BSF    xC5.1
06056:  BTFSC  xC5.7
06058:  BSF    xC5.2
0605A:  BRA    6080
0605C:  MOVFF  6C6,6C7
06060:  MOVLW  20
06062:  MOVWF  xC6
06064:  MOVLW  30
06066:  SUBWF  xC8,W
06068:  BZ    6072
0606A:  BSF    xC5.0
0606C:  BTFSC  xC5.7
0606E:  BSF    xC5.1
06070:  BRA    6080
06072:  BTFSS  FD8.2
06074:  BSF    xC5.0
06076:  BNZ   6080
06078:  MOVFF  6C7,6C8
0607C:  MOVLW  20
0607E:  MOVWF  xC7
06080:  BTFSC  xC5.2
06082:  BRA    608E
06084:  BTFSC  xC5.1
06086:  BRA    6096
06088:  BTFSC  xC5.0
0608A:  BRA    609E
0608C:  BRA    60A6
0608E:  MOVFF  6C6,6E0
06092:  MOVLB  0
06094:  RCALL  5B38
06096:  MOVFF  6C7,6E0
0609A:  MOVLB  0
0609C:  RCALL  5B38
0609E:  MOVFF  6C8,6E0
060A2:  MOVLB  0
060A4:  RCALL  5B38
060A6:  MOVFF  6C9,6E0
060AA:  MOVLB  0
060AC:  RCALL  5B38
060AE:  RETURN 0
*
0624C:  MOVLB  6
0624E:  MOVF   xB2,W
06250:  ANDLW  07
06252:  MOVWF  00
06254:  RRCF   xB2,W
06256:  MOVWF  01
06258:  RRCF   01,F
0625A:  RRCF   01,F
0625C:  MOVLW  1F
0625E:  ANDWF  01,F
06260:  MOVF   01,W
06262:  ADDWF  xB4,W
06264:  MOVWF  FE9
06266:  MOVLW  00
06268:  ADDWFC xB5,W
0626A:  MOVWF  FEA
0626C:  CLRF   01
0626E:  INCF   01,F
06270:  INCF   00,F
06272:  BRA    6276
06274:  RLCF   01,F
06276:  DECFSZ 00,F
06278:  BRA    6274
0627A:  MOVF   xB3,F
0627C:  BZ    6284
0627E:  MOVF   01,W
06280:  IORWF  FEF,F
06282:  BRA    628A
06284:  COMF   01,F
06286:  MOVF   01,W
06288:  ANDWF  FEF,F
0628A:  MOVLB  0
0628C:  RETURN 0
*
0643C:  TBLRD*+
0643E:  MOVFF  FF6,6A0
06442:  MOVFF  FF7,6A1
06446:  MOVFF  FF5,6E0
0644A:  CALL   5B38
0644E:  MOVFF  6A0,FF6
06452:  MOVFF  6A1,FF7
06456:  MOVLB  6
06458:  DECFSZ x9F,F
0645A:  BRA    645E
0645C:  BRA    6462
0645E:  MOVLB  0
06460:  BRA    643C
06462:  MOVLB  0
06464:  RETURN 0
*
0680C:  MOVF   FE9,W
0680E:  MOVLB  6
06810:  MOVWF  xD8
06812:  MOVF   xD7,W
06814:  MOVWF  xDA
06816:  BZ    6850
06818:  MOVFF  6D6,6E3
0681C:  MOVFF  6D5,6E2
06820:  MOVFF  6D4,6E1
06824:  MOVFF  6D3,6E0
06828:  CLRF   xE7
0682A:  CLRF   xE6
0682C:  MOVLW  20
0682E:  MOVWF  xE5
06830:  MOVLW  82
06832:  MOVWF  xE4
06834:  MOVLB  0
06836:  CALL   0E3A
0683A:  MOVFF  03,6D6
0683E:  MOVFF  02,6D5
06842:  MOVFF  01,6D4
06846:  MOVFF  00,6D3
0684A:  MOVLB  6
0684C:  DECFSZ xDA,F
0684E:  BRA    6818
06850:  MOVFF  6D6,6E3
06854:  MOVFF  6D5,6E2
06858:  MOVFF  6D4,6E1
0685C:  MOVFF  6D3,6E0
06860:  MOVLB  0
06862:  CALL   56A6
06866:  MOVFF  03,6D6
0686A:  MOVFF  02,6D5
0686E:  MOVFF  01,6D4
06872:  MOVFF  00,6D3
06876:  MOVLB  6
06878:  BTFSS  xD6.7
0687A:  BRA    6896
0687C:  DECF   xD8,F
0687E:  BSF    xD8.5
06880:  COMF   xD3,F
06882:  COMF   xD4,F
06884:  COMF   xD5,F
06886:  COMF   xD6,F
06888:  INCF   xD3,F
0688A:  BTFSC  FD8.2
0688C:  INCF   xD4,F
0688E:  BTFSC  FD8.2
06890:  INCF   xD5,F
06892:  BTFSC  FD8.2
06894:  INCF   xD6,F
06896:  MOVLW  3B
06898:  MOVWF  xDF
0689A:  MOVLW  9A
0689C:  MOVWF  xDE
0689E:  MOVLW  CA
068A0:  MOVWF  xDD
068A2:  CLRF   xDC
068A4:  MOVLW  0A
068A6:  MOVWF  xDA
068A8:  MOVF   xD7,W
068AA:  BTFSC  FD8.2
068AC:  INCF   xD8,F
068AE:  BSF    FD8.1
068B0:  MOVLW  06
068B2:  MOVWF  FEA
068B4:  MOVLW  D3
068B6:  MOVWF  FE9
068B8:  MOVFF  6D6,6E3
068BC:  MOVFF  6D5,6E2
068C0:  MOVFF  6D4,6E1
068C4:  MOVFF  6D3,6E0
068C8:  MOVFF  6DF,6E7
068CC:  MOVFF  6DE,6E6
068D0:  MOVFF  6DD,6E5
068D4:  MOVFF  6DC,6E4
068D8:  MOVLB  0
068DA:  CALL   56E8
068DE:  MOVF   01,W
068E0:  MOVF   00,F
068E2:  BNZ   690A
068E4:  MOVLB  6
068E6:  INCF   xD7,W
068E8:  SUBWF  xDA,W
068EA:  BTFSS  FD8.2
068EC:  BRA    68F2
068EE:  MOVLB  0
068F0:  BRA    690A
068F2:  MOVF   xD8,W
068F4:  BZ    6910
068F6:  ANDLW  0F
068F8:  SUBWF  xDA,W
068FA:  BZ    68FE
068FC:  BC    6986
068FE:  BTFSC  xD8.7
06900:  BRA    6986
06902:  BTFSC  xD8.6
06904:  BRA    6910
06906:  MOVLW  20
06908:  BRA    6978
0690A:  MOVLW  20
0690C:  MOVLB  6
0690E:  ANDWF  xD8,F
06910:  BTFSS  xD8.5
06912:  BRA    6932
06914:  BCF    xD8.5
06916:  MOVF   xD7,W
06918:  BTFSS  FD8.2
0691A:  DECF   xD8,F
0691C:  MOVF   00,W
0691E:  MOVWF  xD8
06920:  MOVLW  2D
06922:  MOVWF  xE0
06924:  MOVLB  0
06926:  CALL   5B38
0692A:  MOVLB  6
0692C:  MOVF   xD8,W
0692E:  MOVWF  00
06930:  CLRF   xD8
06932:  MOVF   xD7,W
06934:  SUBWF  xDA,W
06936:  BNZ   6952
06938:  MOVF   00,W
0693A:  MOVWF  xD8
0693C:  MOVLW  2E
0693E:  MOVWF  xE0
06940:  MOVLB  0
06942:  CALL   5B38
06946:  MOVLB  6
06948:  MOVF   xD8,W
0694A:  MOVWF  00
0694C:  MOVLW  20
0694E:  ANDWF  xD8,F
06950:  MOVLW  00
06952:  MOVLW  30
06954:  BTFSS  xD8.5
06956:  BRA    6978
06958:  BCF    xD8.5
0695A:  MOVF   xD7,W
0695C:  BTFSS  FD8.2
0695E:  DECF   xD8,F
06960:  MOVF   00,W
06962:  MOVWF  xD8
06964:  MOVLW  2D
06966:  MOVWF  xE0
06968:  MOVLB  0
0696A:  CALL   5B38
0696E:  MOVLB  6
06970:  MOVF   xD8,W
06972:  MOVWF  00
06974:  CLRF   xD8
06976:  MOVLW  30
06978:  ADDWF  00,F
0697A:  MOVFF  00,6E0
0697E:  MOVLB  0
06980:  CALL   5B38
06984:  MOVLB  6
06986:  BCF    FD8.1
06988:  MOVFF  6DF,6E3
0698C:  MOVFF  6DE,6E2
06990:  MOVFF  6DD,6E1
06994:  MOVFF  6DC,6E0
06998:  CLRF   xE7
0699A:  CLRF   xE6
0699C:  CLRF   xE5
0699E:  MOVLW  0A
069A0:  MOVWF  xE4
069A2:  MOVLB  0
069A4:  CALL   56E8
069A8:  MOVFF  03,6DF
069AC:  MOVFF  02,6DE
069B0:  MOVFF  01,6DD
069B4:  MOVFF  00,6DC
069B8:  MOVLB  6
069BA:  DECFSZ xDA,F
069BC:  BRA    68AE
069BE:  MOVLB  0
069C0:  RETURN 0
*
0942A:  MOVF   FE9,W
0942C:  MOVLB  6
0942E:  MOVWF  xCD
09430:  BTFSS  xCC.7
09432:  BRA    944E
09434:  DECF   xCD,F
09436:  BSF    xCD.5
09438:  COMF   xC9,F
0943A:  COMF   xCA,F
0943C:  COMF   xCB,F
0943E:  COMF   xCC,F
09440:  INCF   xC9,F
09442:  BTFSC  FD8.2
09444:  INCF   xCA,F
09446:  BTFSC  FD8.2
09448:  INCF   xCB,F
0944A:  BTFSC  FD8.2
0944C:  INCF   xCC,F
0944E:  MOVLW  3B
09450:  MOVWF  xD4
09452:  MOVLW  9A
09454:  MOVWF  xD3
09456:  MOVLW  CA
09458:  MOVWF  xD2
0945A:  CLRF   xD1
0945C:  MOVLW  0A
0945E:  MOVWF  xCF
09460:  BSF    FD8.1
09462:  MOVLW  06
09464:  MOVWF  FEA
09466:  MOVLW  C9
09468:  MOVWF  FE9
0946A:  MOVFF  6CC,6E3
0946E:  MOVFF  6CB,6E2
09472:  MOVFF  6CA,6E1
09476:  MOVFF  6C9,6E0
0947A:  MOVFF  6D4,6E7
0947E:  MOVFF  6D3,6E6
09482:  MOVFF  6D2,6E5
09486:  MOVFF  6D1,6E4
0948A:  MOVLB  0
0948C:  CALL   56E8
09490:  MOVF   01,W
09492:  MOVF   00,F
09494:  BNZ   94BC
09496:  MOVLB  6
09498:  MOVF   xCF,W
0949A:  XORLW  01
0949C:  BTFSS  FD8.2
0949E:  BRA    94A4
094A0:  MOVLB  0
094A2:  BRA    94BC
094A4:  MOVF   xCD,W
094A6:  BZ    94C2
094A8:  ANDLW  0F
094AA:  SUBWF  xCF,W
094AC:  BZ    94B0
094AE:  BC    950C
094B0:  BTFSC  xCD.7
094B2:  BRA    950C
094B4:  BTFSC  xCD.6
094B6:  BRA    94C2
094B8:  MOVLW  20
094BA:  BRA    94FE
094BC:  MOVLW  20
094BE:  MOVLB  6
094C0:  ANDWF  xCD,F
094C2:  BTFSS  xCD.5
094C4:  BRA    94DE
094C6:  BCF    xCD.5
094C8:  MOVFF  00,6CD
094CC:  MOVLW  2D
094CE:  MOVWF  xE0
094D0:  MOVLB  0
094D2:  CALL   5B38
094D6:  MOVLB  6
094D8:  MOVFF  6CD,00
094DC:  CLRF   xCD
094DE:  MOVLW  30
094E0:  BTFSS  xCD.5
094E2:  BRA    94FE
094E4:  BCF    xCD.5
094E6:  MOVFF  00,6CD
094EA:  MOVLW  2D
094EC:  MOVWF  xE0
094EE:  MOVLB  0
094F0:  CALL   5B38
094F4:  MOVLB  6
094F6:  MOVFF  6CD,00
094FA:  CLRF   xCD
094FC:  MOVLW  30
094FE:  ADDWF  00,F
09500:  MOVFF  00,6E0
09504:  MOVLB  0
09506:  CALL   5B38
0950A:  MOVLB  6
0950C:  BCF    FD8.1
0950E:  MOVFF  6D4,6E3
09512:  MOVFF  6D3,6E2
09516:  MOVFF  6D2,6E1
0951A:  MOVFF  6D1,6E0
0951E:  CLRF   xE7
09520:  CLRF   xE6
09522:  CLRF   xE5
09524:  MOVLW  0A
09526:  MOVWF  xE4
09528:  MOVLB  0
0952A:  CALL   56E8
0952E:  MOVFF  03,6D4
09532:  MOVFF  02,6D3
09536:  MOVFF  01,6D2
0953A:  MOVFF  00,6D1
0953E:  MOVLB  6
09540:  DECFSZ xCF,F
09542:  BRA    9460
09544:  MOVLB  0
09546:  RETURN 0
*
0A18A:  MOVF   FEF,F
0A18C:  BZ    A1AE
0A18E:  MOVFF  FEA,696
0A192:  MOVFF  FE9,695
0A196:  MOVFF  FEF,6E0
0A19A:  CALL   5B38
0A19E:  MOVFF  696,FEA
0A1A2:  MOVFF  695,FE9
0A1A6:  INCF   FE9,F
0A1A8:  BTFSC  FD8.2
0A1AA:  INCF   FEA,F
0A1AC:  BRA    A18A
0A1AE:  GOTO   A22C (RETURN)
.................... 
.................... #list
.................... 
.................... 
.................... #device ADC=10
.................... 
.................... //!#FUSES WDT                      //Watch Dog Timer
.................... //!#FUSES WDT4096                  //Watch Dog Timer uses 1:4096 Postscale
.................... 
.................... #use delay(internal=64000000)
*
00438:  MOVLW  06
0043A:  MOVWF  FEA
0043C:  MOVLW  98
0043E:  MOVWF  FE9
00440:  MOVF   FEF,W
00442:  BZ    0460
00444:  MOVLW  14
00446:  MOVWF  01
00448:  CLRF   00
0044A:  DECFSZ 00,F
0044C:  BRA    044A
0044E:  DECFSZ 01,F
00450:  BRA    0448
00452:  MOVLW  BF
00454:  MOVWF  00
00456:  DECFSZ 00,F
00458:  BRA    0456
0045A:  BRA    045C
0045C:  DECFSZ FEF,F
0045E:  BRA    0444
00460:  RETURN 0
*
00700:  MOVLW  01
00702:  MOVLB  6
00704:  SUBWF  x9D,F
00706:  BNC   0720
00708:  MOVLW  06
0070A:  MOVWF  FEA
0070C:  MOVLW  9D
0070E:  MOVWF  FE9
00710:  MOVF   FEF,W
00712:  BZ    0720
00714:  MOVLW  04
00716:  MOVWF  00
00718:  DECFSZ 00,F
0071A:  BRA    0718
0071C:  DECFSZ FEF,F
0071E:  BRA    0714
00720:  MOVLB  0
00722:  GOTO   0768 (RETURN)
.................... #define baudRate 128000
.................... #define numChannels 2
.................... 
.................... #define version  "20251104" // SW Version
.................... #define serialID "0000"     // Unique Serial ID
.................... #define magPP 1             // Magnetoresistive Sensor Pole Pitch in mm   
.................... #define gainLvl 16          // 1, 2, 4, 8, 16, 32, 64, 128
.................... 
.................... 
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
*
003A2:  MOVLW  CF
003A4:  MOVWF  F87
003A6:  CLRF   F82
....................    output_b(portB_reset);
003A8:  MOVLW  C4
003AA:  MOVWF  F88
003AC:  CLRF   F83
....................    output_c(portC_reset);
003AE:  MOVLW  93
003B0:  MOVWF  F89
003B2:  CLRF   F84
....................    output_d(portD_reset);
003B4:  MOVLW  1F
003B6:  MOVWF  F8A
003B8:  CLRF   F85
....................    output_e(portE_reset);
003BA:  BCF    F8B.0
003BC:  BCF    F8B.1
003BE:  BCF    F8B.2
003C0:  BCF    F8B.3
003C2:  CLRF   F86
....................    
....................    port_a_pullups(portA_pullups);
003C4:  MOVLB  F
003C6:  SETF   x0B
....................    port_b_pullups(portB_pullups);
003C8:  CLRF   x13
....................    port_c_pullups(portC_pullups);
003CA:  CLRF   x1B
....................    port_d_pullups(portD_pullups);
003CC:  SETF   x20
....................    port_e_pullups(portE_pullups);
003CE:  CLRF   x28
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
003D0:  MOVLW  40
003D2:  MOVWF  x0C
003D4:  CLRF   x14
003D6:  MOVLW  03
003D8:  MOVWF  x1C
003DA:  MOVLW  0F
003DC:  MOVWF  x21
003DE:  CLRF   x29
003E0:  MOVLB  0
003E2:  GOTO   A650 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
*
05AC0:  MOVFF  6D2,FEA
05AC4:  MOVLB  6
05AC6:  MOVFF  6D1,FE9
05ACA:  MOVFF  FEF,6D5
05ACE:  MOVFF  6D4,FEA
05AD2:  MOVFF  6D3,FE9
05AD6:  MOVF   FEF,W
05AD8:  SUBWF  xD5,W
05ADA:  BNZ   5B0A
....................       if (*s1 == '\0')
05ADC:  MOVFF  6D2,03
05AE0:  MOVFF  6D1,FE9
05AE4:  MOVFF  03,FEA
05AE8:  MOVF   FEF,F
05AEA:  BNZ   5AF2
....................          return(0);
05AEC:  MOVLW  00
05AEE:  MOVWF  01
05AF0:  BRA    5B34
05AF2:  MOVFF  6D2,03
05AF6:  MOVF   xD1,W
05AF8:  INCF   xD1,F
05AFA:  BTFSC  FD8.2
05AFC:  INCF   xD2,F
05AFE:  INCF   xD3,F
05B00:  BTFSC  FD8.2
05B02:  INCF   xD4,F
05B04:  MOVLB  0
05B06:  BRA    5AC0
05B08:  MOVLB  6
....................    return((*s1 < *s2) ? -1: 1);
05B0A:  MOVFF  6D2,03
05B0E:  MOVFF  6D1,FE9
05B12:  MOVFF  03,FEA
05B16:  MOVFF  FEF,6D5
05B1A:  MOVFF  6D4,03
05B1E:  MOVFF  6D3,FE9
05B22:  MOVFF  03,FEA
05B26:  MOVF   FEF,W
05B28:  SUBWF  xD5,W
05B2A:  BC    5B30
05B2C:  MOVLW  FF
05B2E:  BRA    5B32
05B30:  MOVLW  01
05B32:  MOVWF  01
05B34:  MOVLB  0
05B36:  RETURN 0
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
*
05C50:  MOVFF  6F8,6FB
....................    for(su=s;0<n;++su,--n)
05C54:  MOVFF  6F7,6FD
05C58:  MOVFF  6F6,6FC
05C5C:  MOVLB  6
05C5E:  MOVF   xFA,F
05C60:  BNZ   5C68
05C62:  MOVF   xF9,W
05C64:  SUBLW  00
05C66:  BC    5C90
....................       if(*su==uc)
05C68:  MOVFF  6FD,FEA
05C6C:  MOVFF  6FC,FE9
05C70:  MOVF   xFB,W
05C72:  SUBWF  FEF,W
05C74:  BNZ   5C80
....................       return su;
05C76:  MOVFF  6FC,01
05C7A:  MOVFF  6FD,02
05C7E:  BRA    5C96
05C80:  INCF   xFC,F
05C82:  BTFSC  FD8.2
05C84:  INCF   xFD,F
05C86:  MOVF   xF9,W
05C88:  BTFSC  FD8.2
05C8A:  DECF   xFA,F
05C8C:  DECF   xF9,F
05C8E:  BRA    5C5E
....................    return NULL;
05C90:  MOVLW  00
05C92:  MOVWF  01
05C94:  MOVWF  02
05C96:  MOVLB  0
05C98:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
*
05A88:  MOVFF  6D2,6D4
05A8C:  MOVFF  6D1,6D3
05A90:  MOVFF  6D4,FEA
05A94:  MOVLB  6
05A96:  MOVFF  6D3,FE9
05A9A:  MOVF   FEF,F
05A9C:  BZ    5AAA
05A9E:  INCF   xD3,F
05AA0:  BTFSC  FD8.2
05AA2:  INCF   xD4,F
05AA4:  MOVLB  0
05AA6:  BRA    5A90
05AA8:  MOVLB  6
....................    return(sc - s);
05AAA:  MOVF   xD1,W
05AAC:  SUBWF  xD3,W
05AAE:  MOVWF  00
05AB0:  MOVF   xD2,W
05AB2:  SUBWFB xD4,W
05AB4:  MOVWF  03
05AB6:  MOVFF  00,01
05ABA:  MOVWF  02
05ABC:  MOVLB  0
05ABE:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
*
06F3A:  MOVLB  6
06F3C:  CLRF   xAB
06F3E:  CLRF   xAA
06F40:  CLRF   xA9
06F42:  MOVLW  7F
06F44:  MOVWF  xA8
06F46:  CLRF   xAF
06F48:  CLRF   xAE
06F4A:  CLRF   xAD
06F4C:  CLRF   xAC
06F4E:  BSF    xB0.0
06F50:  BCF    xB0.1
06F52:  BCF    xB0.2
06F54:  CLRF   xB2
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
06F56:  MOVF   xA4,W
06F58:  IORWF  xA5,W
06F5A:  BNZ   6F66
....................       return 0;
06F5C:  CLRF   00
06F5E:  CLRF   01
06F60:  CLRF   02
06F62:  CLRF   03
06F64:  BRA    7190
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
06F66:  MOVF   xB2,W
06F68:  INCF   xB2,F
06F6A:  ADDWF  xA4,W
06F6C:  MOVWF  FE9
06F6E:  MOVLW  00
06F70:  ADDWFC xA5,W
06F72:  MOVWF  FEA
06F74:  MOVFF  FEF,6B1
06F78:  MOVF   xB1,F
06F7A:  BTFSC  FD8.2
06F7C:  BRA    7114
....................    {
....................       if (skip && !isspace(c))
06F7E:  BTFSS  xB0.0
06F80:  BRA    6FA0
06F82:  MOVF   xB1,W
06F84:  SUBLW  20
06F86:  BZ    6FA0
....................       {
....................          skip = 0;
06F88:  BCF    xB0.0
....................          if (c == '+')
06F8A:  MOVF   xB1,W
06F8C:  SUBLW  2B
06F8E:  BNZ   6F96
....................          {
....................             sign = 0;
06F90:  BCF    xB0.1
....................             continue;
06F92:  BRA    70FC
....................          }            
06F94:  BRA    6FA0
....................          else if (c == '-')
06F96:  MOVF   xB1,W
06F98:  SUBLW  2D
06F9A:  BNZ   6FA0
....................          {
....................             sign = 1;
06F9C:  BSF    xB0.1
....................             continue;
06F9E:  BRA    70FC
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
06FA0:  BTFSC  xB0.0
06FA2:  BRA    6FB2
06FA4:  MOVF   xB1,W
06FA6:  SUBLW  2E
06FA8:  BNZ   6FB2
06FAA:  BTFSC  xB0.2
06FAC:  BRA    6FB2
....................          point = 1;
06FAE:  BSF    xB0.2
06FB0:  BRA    70FC
....................       else if (!skip && isdigit(c))
06FB2:  BTFSC  xB0.0
06FB4:  BRA    70F6
06FB6:  MOVF   xB1,W
06FB8:  SUBLW  2F
06FBA:  BTFSC  FD8.0
06FBC:  BRA    70F6
06FBE:  MOVF   xB1,W
06FC0:  SUBLW  39
06FC2:  BTFSS  FD8.0
06FC4:  BRA    70F6
....................       {
....................          c -= '0';
06FC6:  MOVLW  30
06FC8:  SUBWF  xB1,F
....................          if (point)
06FCA:  BTFSS  xB0.2
06FCC:  BRA    707C
....................          {
....................             pow10 = pow10 * 10.0;
06FCE:  MOVFF  6AB,6E3
06FD2:  MOVFF  6AA,6E2
06FD6:  MOVFF  6A9,6E1
06FDA:  MOVFF  6A8,6E0
06FDE:  CLRF   xE7
06FE0:  CLRF   xE6
06FE2:  MOVLW  20
06FE4:  MOVWF  xE5
06FE6:  MOVLW  82
06FE8:  MOVWF  xE4
06FEA:  MOVLB  0
06FEC:  CALL   0E3A
06FF0:  MOVFF  03,6AB
06FF4:  MOVFF  02,6AA
06FF8:  MOVFF  01,6A9
06FFC:  MOVFF  00,6A8
....................             result += (float)c / pow10;   
07000:  MOVLB  6
07002:  CLRF   xE0
07004:  MOVFF  6B1,6DF
07008:  MOVLB  0
0700A:  CALL   0E04
0700E:  MOVFF  03,6B6
07012:  MOVFF  02,6B5
07016:  MOVFF  01,6B4
0701A:  MOVFF  00,6B3
0701E:  MOVFF  03,6D7
07022:  MOVFF  02,6D6
07026:  MOVFF  01,6D5
0702A:  MOVFF  00,6D4
0702E:  MOVFF  6AB,6DB
07032:  MOVFF  6AA,6DA
07036:  MOVFF  6A9,6D9
0703A:  MOVFF  6A8,6D8
0703E:  CALL   1E92
07042:  BCF    FD8.1
07044:  MOVFF  6AF,6E2
07048:  MOVFF  6AE,6E1
0704C:  MOVFF  6AD,6E0
07050:  MOVFF  6AC,6DF
07054:  MOVFF  03,6E6
07058:  MOVFF  02,6E5
0705C:  MOVFF  01,6E4
07060:  MOVFF  00,6E3
07064:  CALL   0F30
07068:  MOVFF  03,6AF
0706C:  MOVFF  02,6AE
07070:  MOVFF  01,6AD
07074:  MOVFF  00,6AC
....................          }
07078:  BRA    70F2
0707A:  MOVLB  6
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
0707C:  CLRF   xE3
0707E:  CLRF   xE2
07080:  MOVLW  20
07082:  MOVWF  xE1
07084:  MOVLW  82
07086:  MOVWF  xE0
07088:  MOVFF  6AF,6E7
0708C:  MOVFF  6AE,6E6
07090:  MOVFF  6AD,6E5
07094:  MOVFF  6AC,6E4
07098:  MOVLB  0
0709A:  CALL   0E3A
0709E:  MOVFF  03,6B6
070A2:  MOVFF  02,6B5
070A6:  MOVFF  01,6B4
070AA:  MOVFF  00,6B3
070AE:  MOVLB  6
070B0:  CLRF   xE0
070B2:  MOVFF  6B1,6DF
070B6:  MOVLB  0
070B8:  CALL   0E04
070BC:  BCF    FD8.1
070BE:  MOVFF  6B6,6E2
070C2:  MOVFF  6B5,6E1
070C6:  MOVFF  6B4,6E0
070CA:  MOVFF  6B3,6DF
070CE:  MOVFF  03,6E6
070D2:  MOVFF  02,6E5
070D6:  MOVFF  01,6E4
070DA:  MOVFF  00,6E3
070DE:  CALL   0F30
070E2:  MOVFF  03,6AF
070E6:  MOVFF  02,6AE
070EA:  MOVFF  01,6AD
070EE:  MOVFF  00,6AC
....................          }
....................       }
070F2:  BRA    70FE
070F4:  MOVLB  6
....................       else if (!skip)
070F6:  BTFSC  xB0.0
070F8:  BRA    70FC
....................          break;
070FA:  BRA    7114
070FC:  MOVLB  0
070FE:  MOVLB  6
07100:  MOVF   xB2,W
07102:  INCF   xB2,F
07104:  ADDWF  xA4,W
07106:  MOVWF  FE9
07108:  MOVLW  00
0710A:  ADDWFC xA5,W
0710C:  MOVWF  FEA
0710E:  MOVFF  FEF,6B1
07112:  BRA    6F78
....................    }
.................... 
....................    if (sign)
07114:  BTFSS  xB0.1
07116:  BRA    714C
....................       result = -1*result;
07118:  CLRF   xE3
0711A:  CLRF   xE2
0711C:  MOVLW  80
0711E:  MOVWF  xE1
07120:  MOVLW  7F
07122:  MOVWF  xE0
07124:  MOVFF  6AF,6E7
07128:  MOVFF  6AE,6E6
0712C:  MOVFF  6AD,6E5
07130:  MOVFF  6AC,6E4
07134:  MOVLB  0
07136:  CALL   0E3A
0713A:  MOVFF  03,6AF
0713E:  MOVFF  02,6AE
07142:  MOVFF  01,6AD
07146:  MOVFF  00,6AC
0714A:  MOVLB  6
....................       
....................    if(endptr)
0714C:  MOVF   xA6,W
0714E:  IORWF  xA7,W
07150:  BZ    7180
....................    {
....................       if (ptr) {
07152:  MOVF   xB2,F
07154:  BZ    716E
....................          ptr--;
07156:  DECF   xB2,F
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
07158:  MOVFF  6A7,FEA
0715C:  MOVFF  6A6,FE9
07160:  MOVF   xB2,W
07162:  ADDWF  xA4,W
07164:  MOVWF  FEF
07166:  MOVLW  00
07168:  ADDWFC xA5,W
0716A:  MOVWF  FEC
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
0716C:  BRA    7180
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
0716E:  MOVFF  6A7,FEA
07172:  MOVFF  6A6,FE9
07176:  MOVFF  6A5,FEC
0717A:  MOVF   FED,F
0717C:  MOVFF  6A4,FEF
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
07180:  MOVFF  6AC,00
07184:  MOVFF  6AD,01
07188:  MOVFF  6AE,02
0718C:  MOVFF  6AF,03
07190:  MOVLB  0
07192:  RETURN 0
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
*
05C9A:  MOVLB  6
05C9C:  CLRF   xCF
05C9E:  CLRF   xCE
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
05CA0:  MOVLW  30
05CA2:  MOVWF  xD1
05CA4:  MOVLW  31
05CA6:  MOVWF  xD2
05CA8:  MOVLW  32
05CAA:  MOVWF  xD3
05CAC:  MOVLW  33
05CAE:  MOVWF  xD4
05CB0:  MOVLW  34
05CB2:  MOVWF  xD5
05CB4:  MOVLW  35
05CB6:  MOVWF  xD6
05CB8:  MOVLW  36
05CBA:  MOVWF  xD7
05CBC:  MOVLW  37
05CBE:  MOVWF  xD8
05CC0:  MOVLW  38
05CC2:  MOVWF  xD9
05CC4:  MOVLW  39
05CC6:  MOVWF  xDA
05CC8:  MOVLW  61
05CCA:  MOVWF  xDB
05CCC:  MOVLW  62
05CCE:  MOVWF  xDC
05CD0:  MOVLW  63
05CD2:  MOVWF  xDD
05CD4:  MOVLW  64
05CD6:  MOVWF  xDE
05CD8:  MOVLW  65
05CDA:  MOVWF  xDF
05CDC:  MOVLW  66
05CDE:  MOVWF  xE0
05CE0:  MOVLW  67
05CE2:  MOVWF  xE1
05CE4:  MOVLW  68
05CE6:  MOVWF  xE2
05CE8:  MOVLW  69
05CEA:  MOVWF  xE3
05CEC:  MOVLW  6A
05CEE:  MOVWF  xE4
05CF0:  MOVLW  6B
05CF2:  MOVWF  xE5
05CF4:  MOVLW  6C
05CF6:  MOVWF  xE6
05CF8:  MOVLW  6D
05CFA:  MOVWF  xE7
05CFC:  MOVLW  6E
05CFE:  MOVWF  xE8
05D00:  MOVLW  6F
05D02:  MOVWF  xE9
05D04:  MOVLW  70
05D06:  MOVWF  xEA
05D08:  MOVLW  71
05D0A:  MOVWF  xEB
05D0C:  MOVLW  73
05D0E:  MOVWF  xEC
05D10:  MOVLW  74
05D12:  MOVWF  xED
05D14:  MOVLW  75
05D16:  MOVWF  xEE
05D18:  MOVLW  76
05D1A:  MOVWF  xEF
05D1C:  MOVLW  77
05D1E:  MOVWF  xF0
05D20:  MOVLW  78
05D22:  MOVWF  xF1
05D24:  MOVLW  79
05D26:  MOVWF  xF2
05D28:  MOVLW  7A
05D2A:  MOVWF  xF3
05D2C:  CLRF   xF4
....................    for(sc=s;isspace(*sc);++sc);
05D2E:  MOVFF  6C4,6C9
05D32:  MOVFF  6C3,6C8
05D36:  MOVFF  6C9,FEA
05D3A:  MOVFF  6C8,FE9
05D3E:  MOVF   FEF,W
05D40:  SUBLW  20
05D42:  BNZ   5D4C
05D44:  INCF   xC8,F
05D46:  BTFSC  FD8.2
05D48:  INCF   xC9,F
05D4A:  BRA    5D36
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
05D4C:  MOVFF  6C9,03
05D50:  MOVFF  6C8,FE9
05D54:  MOVFF  03,FEA
05D58:  MOVF   FEF,W
05D5A:  SUBLW  2D
05D5C:  BZ    5D6C
05D5E:  MOVFF  6C9,FEA
05D62:  MOVFF  6C8,FE9
05D66:  MOVF   FEF,W
05D68:  SUBLW  2B
05D6A:  BNZ   5D7E
05D6C:  MOVFF  6C9,FEA
05D70:  MOVF   xC8,W
05D72:  INCF   xC8,F
05D74:  BTFSC  FD8.2
05D76:  INCF   xC9,F
05D78:  MOVWF  FE9
05D7A:  MOVF   FEF,W
05D7C:  BRA    5D80
05D7E:  MOVLW  2B
05D80:  MOVWF  xD0
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
05D82:  MOVF   xD0,W
05D84:  SUBLW  2D
05D86:  BZ    5D9C
05D88:  BTFSC  xC7.7
05D8A:  BRA    5D9C
05D8C:  DECFSZ xC7,W
05D8E:  BRA    5D92
05D90:  BRA    5D9C
05D92:  BTFSC  xC7.7
05D94:  BRA    5DA0
05D96:  MOVF   xC7,W
05D98:  SUBLW  24
05D9A:  BC    5DA0
....................    goto StrtoulGO;
05D9C:  BRA    5FAA
05D9E:  BRA    5E98
.................... 
....................    else if (base)
05DA0:  MOVF   xC7,F
05DA2:  BZ    5E30
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
05DA4:  MOVF   xC7,W
05DA6:  SUBLW  10
05DA8:  BNZ   5DE4
05DAA:  MOVFF  6C9,FEA
05DAE:  MOVFF  6C8,FE9
05DB2:  MOVF   FEF,W
05DB4:  SUBLW  30
05DB6:  BNZ   5DE4
05DB8:  MOVLW  01
05DBA:  ADDWF  xC8,W
05DBC:  MOVWF  FE9
05DBE:  MOVLW  00
05DC0:  ADDWFC xC9,W
05DC2:  MOVWF  FEA
05DC4:  MOVF   FEF,W
05DC6:  SUBLW  78
05DC8:  BZ    5DDC
05DCA:  MOVLW  01
05DCC:  ADDWF  xC8,W
05DCE:  MOVWF  FE9
05DD0:  MOVLW  00
05DD2:  ADDWFC xC9,W
05DD4:  MOVWF  FEA
05DD6:  MOVF   FEF,W
05DD8:  SUBLW  58
05DDA:  BNZ   5DE4
....................          sc+=2;
05DDC:  MOVLW  02
05DDE:  ADDWF  xC8,F
05DE0:  MOVLW  00
05DE2:  ADDWFC xC9,F
....................       if(base==8 && *sc =='0')
05DE4:  MOVF   xC7,W
05DE6:  SUBLW  08
05DE8:  BNZ   5E00
05DEA:  MOVFF  6C9,FEA
05DEE:  MOVFF  6C8,FE9
05DF2:  MOVF   FEF,W
05DF4:  SUBLW  30
05DF6:  BNZ   5E00
....................          sc+=1;
05DF8:  MOVLW  01
05DFA:  ADDWF  xC8,F
05DFC:  MOVLW  00
05DFE:  ADDWFC xC9,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
05E00:  MOVF   xC7,W
05E02:  SUBLW  02
05E04:  BNZ   5E2E
05E06:  MOVFF  6C9,FEA
05E0A:  MOVFF  6C8,FE9
05E0E:  MOVF   FEF,W
05E10:  SUBLW  30
05E12:  BNZ   5E2E
05E14:  MOVLW  01
05E16:  ADDWF  xC8,W
05E18:  MOVWF  FE9
05E1A:  MOVLW  00
05E1C:  ADDWFC xC9,W
05E1E:  MOVWF  FEA
05E20:  MOVF   FEF,W
05E22:  SUBLW  62
05E24:  BNZ   5E2E
....................          sc+=2;
05E26:  MOVLW  02
05E28:  ADDWF  xC8,F
05E2A:  MOVLW  00
05E2C:  ADDWFC xC9,F
.................... 
....................    }
05E2E:  BRA    5E98
....................    else if(*sc!='0') // base is 0, find base
05E30:  MOVFF  6C9,FEA
05E34:  MOVFF  6C8,FE9
05E38:  MOVF   FEF,W
05E3A:  SUBLW  30
05E3C:  BZ    5E44
....................       base=10;
05E3E:  MOVLW  0A
05E40:  MOVWF  xC7
05E42:  BRA    5E98
....................    else if (sc[1]=='x' || sc[1]=='X')
05E44:  MOVLW  01
05E46:  ADDWF  xC8,W
05E48:  MOVWF  FE9
05E4A:  MOVLW  00
05E4C:  ADDWFC xC9,W
05E4E:  MOVWF  FEA
05E50:  MOVF   FEF,W
05E52:  SUBLW  78
05E54:  BZ    5E68
05E56:  MOVLW  01
05E58:  ADDWF  xC8,W
05E5A:  MOVWF  FE9
05E5C:  MOVLW  00
05E5E:  ADDWFC xC9,W
05E60:  MOVWF  FEA
05E62:  MOVF   FEF,W
05E64:  SUBLW  58
05E66:  BNZ   5E76
....................       base =16,sc+=2;
05E68:  MOVLW  10
05E6A:  MOVWF  xC7
05E6C:  MOVLW  02
05E6E:  ADDWF  xC8,F
05E70:  MOVLW  00
05E72:  ADDWFC xC9,F
05E74:  BRA    5E98
....................    else if(sc[1]=='b')
05E76:  MOVLW  01
05E78:  ADDWF  xC8,W
05E7A:  MOVWF  FE9
05E7C:  MOVLW  00
05E7E:  ADDWFC xC9,W
05E80:  MOVWF  FEA
05E82:  MOVF   FEF,W
05E84:  SUBLW  62
05E86:  BNZ   5E94
....................       base=2,sc+=2;
05E88:  MOVLW  02
05E8A:  MOVWF  xC7
05E8C:  ADDWF  xC8,F
05E8E:  MOVLW  00
05E90:  ADDWFC xC9,F
05E92:  BRA    5E98
....................    else
....................       base=8;
05E94:  MOVLW  08
05E96:  MOVWF  xC7
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
05E98:  MOVFF  6C9,6CB
05E9C:  MOVFF  6C8,6CA
05EA0:  MOVFF  6C9,FEA
05EA4:  MOVFF  6C8,FE9
05EA8:  MOVF   FEF,W
05EAA:  SUBLW  30
05EAC:  BNZ   5EB6
05EAE:  INCF   xC8,F
05EB0:  BTFSC  FD8.2
05EB2:  INCF   xC9,F
05EB4:  BRA    5EA0
....................    sd=memchr(digits,tolower(*sc),base);
05EB6:  MOVFF  6C9,03
05EBA:  MOVFF  6C8,FE9
05EBE:  MOVFF  03,FEA
05EC2:  MOVFF  FEF,6F5
05EC6:  MOVF   xF5,W
05EC8:  SUBLW  40
05ECA:  BC    5ED8
05ECC:  MOVF   xF5,W
05ECE:  SUBLW  5A
05ED0:  BNC   5ED8
05ED2:  MOVF   xF5,W
05ED4:  IORLW  20
05ED6:  BRA    5EDA
05ED8:  MOVF   xF5,W
05EDA:  MOVWF  xF5
05EDC:  MOVLW  06
05EDE:  MOVWF  xF7
05EE0:  MOVLW  D1
05EE2:  MOVWF  xF6
05EE4:  MOVFF  6F5,6F8
05EE8:  CLRF   xFA
05EEA:  MOVFF  6C7,6F9
05EEE:  BTFSC  xF9.7
05EF0:  DECF   xFA,F
05EF2:  MOVLB  0
05EF4:  RCALL  5C50
05EF6:  MOVFF  02,6CD
05EFA:  MOVFF  01,6CC
....................    for(; sd!=0; )
05EFE:  MOVLB  6
05F00:  MOVF   xCC,F
05F02:  BNZ   5F08
05F04:  MOVF   xCD,F
05F06:  BZ    5F9E
....................    {
....................       x=x*base+(int16)(sd-digits);
05F08:  CLRF   03
05F0A:  MOVF   xC7,W
05F0C:  MOVWF  00
05F0E:  BTFSC  FE8.7
05F10:  DECF   03,F
05F12:  MOVWF  xF5
05F14:  MOVFF  03,6F6
05F18:  MOVFF  6CF,6F8
05F1C:  MOVFF  6CE,6F7
05F20:  MOVFF  03,6FA
05F24:  MOVWF  xF9
05F26:  MOVLB  0
05F28:  CALL   0868
05F2C:  MOVFF  01,6F5
05F30:  MOVLW  D1
05F32:  MOVLB  6
05F34:  SUBWF  xCC,W
05F36:  MOVWF  00
05F38:  MOVLW  06
05F3A:  SUBWFB xCD,W
05F3C:  MOVWF  03
05F3E:  MOVF   00,W
05F40:  ADDWF  01,W
05F42:  MOVWF  01
05F44:  MOVF   02,W
05F46:  ADDWFC 03,F
05F48:  MOVFF  01,6CE
05F4C:  MOVFF  03,6CF
....................       ++sc;
05F50:  INCF   xC8,F
05F52:  BTFSC  FD8.2
05F54:  INCF   xC9,F
....................       sd=memchr(digits,tolower(*sc),base);
05F56:  MOVFF  6C9,FEA
05F5A:  MOVFF  6C8,FE9
05F5E:  MOVFF  FEF,6F5
05F62:  MOVF   xF5,W
05F64:  SUBLW  40
05F66:  BC    5F74
05F68:  MOVF   xF5,W
05F6A:  SUBLW  5A
05F6C:  BNC   5F74
05F6E:  MOVF   xF5,W
05F70:  IORLW  20
05F72:  BRA    5F76
05F74:  MOVF   xF5,W
05F76:  MOVWF  xF5
05F78:  MOVLW  06
05F7A:  MOVWF  xF7
05F7C:  MOVLW  D1
05F7E:  MOVWF  xF6
05F80:  MOVFF  6F5,6F8
05F84:  CLRF   xFA
05F86:  MOVFF  6C7,6F9
05F8A:  BTFSC  xF9.7
05F8C:  DECF   xFA,F
05F8E:  MOVLB  0
05F90:  RCALL  5C50
05F92:  MOVFF  02,6CD
05F96:  MOVFF  01,6CC
05F9A:  BRA    5EFE
05F9C:  MOVLB  6
....................    }
....................    if(s1==sc)
05F9E:  MOVF   xC8,W
05FA0:  SUBWF  xCA,W
05FA2:  BNZ   5FCC
05FA4:  MOVF   xC9,W
05FA6:  SUBWF  xCB,W
05FA8:  BNZ   5FCC
....................    {
....................    StrtoulGO:
....................       if (endptr)
05FAA:  MOVLB  6
05FAC:  MOVF   xC5,W
05FAE:  IORWF  xC6,W
05FB0:  BZ    5FC4
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
05FB2:  MOVFF  6C6,FEA
05FB6:  MOVFF  6C5,FE9
05FBA:  MOVFF  6C4,FEC
05FBE:  MOVF   FED,F
05FC0:  MOVFF  6C3,FEF
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
05FC4:  MOVLW  00
05FC6:  MOVWF  01
05FC8:  MOVWF  02
05FCA:  BRA    5FEC
....................    }
....................    if (endptr)
05FCC:  MOVF   xC5,W
05FCE:  IORWF  xC6,W
05FD0:  BZ    5FE4
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
05FD2:  MOVFF  6C6,FEA
05FD6:  MOVFF  6C5,FE9
05FDA:  MOVFF  6C9,FEC
05FDE:  MOVF   FED,F
05FE0:  MOVFF  6C8,FEF
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
05FE4:  MOVFF  6CE,01
05FE8:  MOVFF  6CF,02
05FEC:  MOVLB  0
05FEE:  RETURN 0
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
*
017F6:  BCF    FD8.0
017F8:  MOVLB  6
017FA:  RRCF   xEF,W
017FC:  MOVWF  xF3
....................    while( m > 0 ) {
017FE:  MOVF   xF3,F
01800:  BTFSC  FD8.2
01802:  BRA    1948
....................      for(j=0; j<(qitems-m); ++j) {
01804:  CLRF   xF4
01806:  MOVF   xF3,W
01808:  SUBWF  xEF,W
0180A:  SUBWF  xF4,W
0180C:  BTFSC  FD8.0
0180E:  BRA    1942
....................         i = j;
01810:  MOVFF  6F4,6F5
....................         do
....................         {
....................            done=1;
01814:  BSF    xF7.0
....................            l = i+m;
01816:  MOVF   xF3,W
01818:  ADDWF  xF5,W
0181A:  MOVWF  xF6
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
0181C:  MOVF   xF5,W
0181E:  MULWF  xF0
01820:  MOVF   FF3,W
01822:  ADDWF  xED,W
01824:  MOVLB  7
01826:  MOVWF  x08
01828:  MOVLW  00
0182A:  MOVLB  6
0182C:  ADDWFC xEE,W
0182E:  MOVLB  7
01830:  MOVWF  x09
01832:  MOVLB  6
01834:  MOVF   xF6,W
01836:  MULWF  xF0
01838:  MOVF   FF3,W
0183A:  ADDWF  xED,W
0183C:  MOVLB  7
0183E:  MOVWF  x0A
01840:  MOVLW  00
01842:  MOVLB  6
01844:  ADDWFC xEE,W
01846:  MOVLB  7
01848:  MOVWF  x0B
0184A:  MOVLW  06
0184C:  MOVWF  FEA
0184E:  MOVLW  F1
01850:  MOVWF  FE9
01852:  MOVFF  709,68C
01856:  MOVFF  708,68B
0185A:  MOVFF  70B,68E
0185E:  MOVFF  70A,68D
01862:  MOVLB  0
01864:  CALL   00BC
01868:  BTFSC  01.7
0186A:  BRA    1938
0186C:  MOVF   01,W
0186E:  SUBLW  00
01870:  BC    1938
....................               memcpy(t, qdata+i*qsize, qsize);
01872:  MOVLB  6
01874:  MOVF   xF5,W
01876:  MULWF  xF0
01878:  MOVF   FF3,W
0187A:  ADDWF  xED,W
0187C:  MOVLB  7
0187E:  MOVWF  x08
01880:  MOVLW  00
01882:  MOVLB  6
01884:  ADDWFC xEE,W
01886:  MOVLB  7
01888:  MOVWF  x09
0188A:  MOVLW  06
0188C:  MOVWF  FEA
0188E:  MOVLW  F8
01890:  MOVWF  FE9
01892:  MOVFF  709,FE2
01896:  MOVFF  708,FE1
0189A:  MOVLB  6
0189C:  MOVF   xF0,W
0189E:  MOVWF  01
018A0:  BZ    18AA
018A2:  MOVFF  FE6,FEE
018A6:  DECFSZ 01,F
018A8:  BRA    18A2
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
018AA:  MOVF   xF5,W
018AC:  MULWF  xF0
018AE:  MOVF   FF3,W
018B0:  ADDWF  xED,W
018B2:  MOVLB  7
018B4:  MOVWF  x08
018B6:  MOVLW  00
018B8:  MOVLB  6
018BA:  ADDWFC xEE,W
018BC:  MOVLB  7
018BE:  MOVWF  x09
018C0:  MOVLB  6
018C2:  MOVF   xF6,W
018C4:  MULWF  xF0
018C6:  MOVF   FF3,W
018C8:  ADDWF  xED,W
018CA:  MOVLB  7
018CC:  MOVWF  x0A
018CE:  MOVLW  00
018D0:  MOVLB  6
018D2:  ADDWFC xEE,W
018D4:  MOVLB  7
018D6:  MOVWF  x0B
018D8:  MOVFF  709,FEA
018DC:  MOVFF  708,FE9
018E0:  MOVWF  FE2
018E2:  MOVFF  70A,FE1
018E6:  MOVLB  6
018E8:  MOVF   xF0,W
018EA:  MOVWF  01
018EC:  BZ    18F6
018EE:  MOVFF  FE6,FEE
018F2:  DECFSZ 01,F
018F4:  BRA    18EE
....................               memcpy(qdata+l*qsize, t, qsize);
018F6:  MOVF   xF6,W
018F8:  MULWF  xF0
018FA:  MOVF   FF3,W
018FC:  ADDWF  xED,W
018FE:  MOVLB  7
01900:  MOVWF  x08
01902:  MOVLW  00
01904:  MOVLB  6
01906:  ADDWFC xEE,W
01908:  MOVLB  7
0190A:  MOVWF  x09
0190C:  MOVWF  FEA
0190E:  MOVFF  708,FE9
01912:  MOVLW  06
01914:  MOVWF  FE2
01916:  MOVLW  F8
01918:  MOVWF  FE1
0191A:  MOVLB  6
0191C:  MOVF   xF0,W
0191E:  MOVWF  01
01920:  BZ    192A
01922:  MOVFF  FE6,FEE
01926:  DECFSZ 01,F
01928:  BRA    1922
....................               if(m <= i)
0192A:  MOVF   xF3,W
0192C:  SUBWF  xF5,W
0192E:  BNC   1934
....................                 i -= m;
01930:  MOVF   xF3,W
01932:  SUBWF  xF5,F
....................                 done = 0;
01934:  BCF    xF7.0
01936:  MOVLB  0
....................            }
....................         } while(!done);
01938:  MOVLB  6
0193A:  BTFSS  xF7.0
0193C:  BRA    1814
0193E:  INCF   xF4,F
01940:  BRA    1806
....................      }
....................      m = m/2;
01942:  BCF    FD8.0
01944:  RRCF   xF3,F
01946:  BRA    17FE
....................    }
01948:  MOVLB  0
0194A:  RETURN 0
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0.3,0.1,0,0,0,0,0},
....................    {0.01,0.3,0.1,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
*
00462:  MOVLB  6
00464:  CLRF   x95
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
00466:  CLRF   x95
00468:  MOVF   x94,W
0046A:  SUBWF  x95,W
0046C:  BC    04C4
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
0046E:  MOVF   x95,W
00470:  ADDWF  x92,W
00472:  MOVWF  x96
00474:  MOVLW  00
00476:  ADDWFC x93,W
00478:  MOVWF  x97
0047A:  MOVF   x95,W
0047C:  ADDWF  x90,W
0047E:  MOVWF  01
00480:  MOVLW  00
00482:  ADDWFC x91,W
00484:  MOVWF  03
00486:  MOVF   01,W
00488:  MOVWF  FE9
0048A:  MOVFF  03,FEA
0048E:  MOVFF  FEF,698
00492:  BSF    F7F.7
00494:  MOVF   FF2,W
00496:  MOVWF  00
00498:  BCF    FF2.7
0049A:  MOVFF  697,F7A
0049E:  MOVFF  696,F79
004A2:  MOVLW  31
004A4:  MOVWF  F7B
004A6:  MOVFF  698,F7C
004AA:  MOVLB  F
004AC:  MOVLW  55
004AE:  MOVWF  F81
004B0:  MOVLW  AA
004B2:  MOVWF  F81
004B4:  BSF    F80.4
004B6:  BTFSC  F80.4
004B8:  BRA    04B6
004BA:  MOVF   00,W
004BC:  IORWF  FF2,F
004BE:  MOVLB  6
004C0:  INCF   x95,F
004C2:  BRA    0468
....................    }
004C4:  MOVLB  0
004C6:  RETURN 0
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
*
003E6:  MOVLB  6
003E8:  CLRF   x95
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
003EA:  CLRF   x95
003EC:  MOVF   x94,W
003EE:  SUBWF  x95,W
003F0:  BC    0434
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
003F2:  MOVF   x95,W
003F4:  ADDWF  x90,W
003F6:  MOVWF  01
003F8:  MOVLW  00
003FA:  ADDWFC x91,W
003FC:  MOVWF  03
003FE:  MOVF   01,W
00400:  MOVWF  FE9
00402:  MOVFF  03,FEA
00406:  MOVF   x95,W
00408:  ADDWF  x92,W
0040A:  MOVWF  x98
0040C:  MOVLW  00
0040E:  ADDWFC x93,W
00410:  MOVWF  x99
00412:  BSF    F7F.7
00414:  MOVFF  FF2,69A
00418:  BCF    FF2.7
0041A:  MOVFF  699,F7A
0041E:  MOVFF  698,F79
00422:  MOVLW  31
00424:  MOVWF  F7B
00426:  BSF    F80.0
00428:  MOVF   F7C,W
0042A:  BTFSC  x9A.7
0042C:  BSF    FF2.7
0042E:  MOVWF  FEF
00430:  INCF   x95,F
00432:  BRA    03EC
....................    }
00434:  MOVLB  0
00436:  RETURN 0
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
*
004C8:  MOVLB  6
004CA:  CLRF   x91
004CC:  MOVLW  20
004CE:  MOVWF  x90
004D0:  CLRF   x93
004D2:  CLRF   x92
004D4:  MOVLW  80
004D6:  MOVWF  x94
004D8:  MOVLB  0
004DA:  RCALL  0462
....................    delay_ms(1);
004DC:  MOVLW  01
004DE:  MOVLB  6
004E0:  MOVWF  x98
004E2:  MOVLB  0
004E4:  RCALL  0438
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
004E6:  MOVLB  6
004E8:  CLRF   x91
004EA:  MOVLW  60
004EC:  MOVWF  x90
004EE:  CLRF   x93
004F0:  MOVLW  80
004F2:  MOVWF  x92
004F4:  MOVLW  02
004F6:  MOVWF  x94
004F8:  MOVLB  0
004FA:  RCALL  0462
....................    delay_ms(1);
004FC:  MOVLW  01
004FE:  MOVLB  6
00500:  MOVWF  x98
00502:  MOVLB  0
00504:  RCALL  0438
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
00506:  MOVLB  6
00508:  CLRF   x91
0050A:  MOVLW  61
0050C:  MOVWF  x90
0050E:  CLRF   x93
00510:  MOVLW  90
00512:  MOVWF  x92
00514:  MOVLW  02
00516:  MOVWF  x94
00518:  MOVLB  0
0051A:  RCALL  0462
....................    delay_ms(1);
0051C:  MOVLW  01
0051E:  MOVLB  6
00520:  MOVWF  x98
00522:  MOVLB  0
00524:  RCALL  0438
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
00526:  MOVLB  6
00528:  CLRF   x91
0052A:  MOVLW  62
0052C:  MOVWF  x90
0052E:  CLRF   x93
00530:  MOVLW  A0
00532:  MOVWF  x92
00534:  MOVLW  20
00536:  MOVWF  x94
00538:  MOVLB  0
0053A:  RCALL  0462
....................    delay_ms(1);
0053C:  MOVLW  01
0053E:  MOVLB  6
00540:  MOVWF  x98
00542:  MOVLB  0
00544:  RCALL  0438
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
00546:  MOVLB  6
00548:  CLRF   x91
0054A:  MOVLW  82
0054C:  MOVWF  x90
0054E:  CLRF   x93
00550:  MOVLW  C0
00552:  MOVWF  x92
00554:  MOVLW  30
00556:  MOVWF  x94
00558:  MOVLB  0
0055A:  RCALL  0462
....................    delay_ms(1);
0055C:  MOVLW  01
0055E:  MOVLB  6
00560:  MOVWF  x98
00562:  MOVLB  0
00564:  RCALL  0438
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
00566:  MOVLB  6
00568:  CLRF   x91
0056A:  MOVLW  B2
0056C:  MOVWF  x90
0056E:  CLRF   x93
00570:  MOVLW  F0
00572:  MOVWF  x92
00574:  MOVLW  38
00576:  MOVWF  x94
00578:  MOVLB  0
0057A:  RCALL  0462
....................    delay_ms(1);
0057C:  MOVLW  01
0057E:  MOVLB  6
00580:  MOVWF  x98
00582:  MOVLB  0
00584:  RCALL  0438
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
00586:  MOVLB  6
00588:  CLRF   x91
0058A:  MOVLW  F2
0058C:  MOVWF  x90
0058E:  MOVLW  01
00590:  MOVWF  x93
00592:  MOVLW  40
00594:  MOVWF  x92
00596:  MOVLW  01
00598:  MOVWF  x94
0059A:  MOVLB  0
0059C:  RCALL  0462
....................    delay_ms(1);
0059E:  MOVLW  01
005A0:  MOVLB  6
005A2:  MOVWF  x98
005A4:  MOVLB  0
005A6:  RCALL  0438
005A8:  GOTO   0678 (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
005AC:  MOVLB  6
005AE:  CLRF   x91
005B0:  MOVLW  20
005B2:  MOVWF  x90
005B4:  CLRF   x93
005B6:  CLRF   x92
005B8:  MOVLW  80
005BA:  MOVWF  x94
005BC:  MOVLB  0
005BE:  RCALL  03E6
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
005C0:  MOVLB  6
005C2:  CLRF   x91
005C4:  MOVLW  60
005C6:  MOVWF  x90
005C8:  CLRF   x93
005CA:  MOVLW  80
005CC:  MOVWF  x92
005CE:  MOVLW  02
005D0:  MOVWF  x94
005D2:  MOVLB  0
005D4:  RCALL  03E6
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
005D6:  MOVLB  6
005D8:  CLRF   x91
005DA:  MOVLW  61
005DC:  MOVWF  x90
005DE:  CLRF   x93
005E0:  MOVLW  90
005E2:  MOVWF  x92
005E4:  MOVLW  02
005E6:  MOVWF  x94
005E8:  MOVLB  0
005EA:  RCALL  03E6
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
005EC:  MOVLB  6
005EE:  CLRF   x91
005F0:  MOVLW  62
005F2:  MOVWF  x90
005F4:  CLRF   x93
005F6:  MOVLW  A0
005F8:  MOVWF  x92
005FA:  MOVLW  20
005FC:  MOVWF  x94
005FE:  MOVLB  0
00600:  RCALL  03E6
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
00602:  MOVLB  6
00604:  CLRF   x91
00606:  MOVLW  82
00608:  MOVWF  x90
0060A:  CLRF   x93
0060C:  MOVLW  C0
0060E:  MOVWF  x92
00610:  MOVLW  30
00612:  MOVWF  x94
00614:  MOVLB  0
00616:  RCALL  03E6
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
00618:  MOVLB  6
0061A:  CLRF   x91
0061C:  MOVLW  B2
0061E:  MOVWF  x90
00620:  CLRF   x93
00622:  MOVLW  F0
00624:  MOVWF  x92
00626:  MOVLW  38
00628:  MOVWF  x94
0062A:  MOVLB  0
0062C:  RCALL  03E6
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
0062E:  MOVLB  6
00630:  CLRF   x91
00632:  MOVLW  F2
00634:  MOVWF  x90
00636:  MOVLW  01
00638:  MOVWF  x93
0063A:  MOVLW  40
0063C:  MOVWF  x92
0063E:  MOVLW  01
00640:  MOVWF  x94
00642:  MOVLB  0
00644:  RCALL  03E6
00646:  GOTO   067C (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
0064A:  MOVLB  6
0064C:  CLRF   x91
0064E:  MOVLW  F2
00650:  MOVWF  x90
00652:  MOVLW  01
00654:  MOVWF  x93
00656:  MOVLW  40
00658:  MOVWF  x92
0065A:  MOVLW  01
0065C:  MOVWF  x94
0065E:  MOVLB  0
00660:  RCALL  03E6
....................    delay_ms(1);
00662:  MOVLW  01
00664:  MOVLB  6
00666:  MOVWF  x98
00668:  MOVLB  0
0066A:  RCALL  0438
....................    if (paramsValid != isValid)
0066C:  MOVF   xF2,W
0066E:  SUBLW  AA
00670:  BZ    067A
....................    {
....................       paramsValid = isValid;
00672:  MOVLW  AA
00674:  MOVWF  xF2
....................       params_save_to_ee(); // saves the base parameters on first boot
00676:  BRA    04C8
....................    }
00678:  BRA    067C
....................    else
....................    {
....................       params_load_from_ee();
0067A:  BRA    05AC
....................    }
0067C:  GOTO   A654 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <monitor.h>
.................... #ifndef monitor
.................... #define monitor
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
....................    output_b(portB_reset);
....................    output_c(portC_reset);
....................    output_d(portD_reset);
....................    output_e(portE_reset);
....................    
....................    port_a_pullups(portA_pullups);
....................    port_b_pullups(portB_pullups);
....................    port_c_pullups(portC_pullups);
....................    port_d_pullups(portD_pullups);
....................    port_e_pullups(portE_pullups);
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0.3,0.1,0,0,0,0,0},
....................    {0.01,0.3,0.1,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <ADS1220.h>
.................... #ifndef ADS1220
.................... #define ADS1220
.................... 
.................... /*****************************************************************************/
.................... /* SET UP PORTS FOR USE WITH DRIVER                                          */
.................... /*****************************************************************************/
.................... #define _CS0  PIN_D5 // chip select pins 
.................... #define _CS1  PIN_D6
.................... #define _CS2  PIN_D7
.................... #define _CS3  PIN_B0
.................... 
.................... #pin_select SCK2=PIN_B1
.................... #pin_select SDI2=PIN_B2
.................... #pin_select SDO2=PIN_B3
.................... #use spi(MASTER, SPI2, BAUD=4096000, MODE=1, STREAM=SPI_mon)
.................... //!setup_spi2(SPI_MASTER | SPI_SCK_IDLE_LOW | SPI_XMIT_H_TO_L | SPI_CLK_DIV_64);
.................... 
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* REGISTER DEFINITIONS                                                      */
.................... /*****************************************************************************/
.................... typedef enum {reg0 = 0x00,reg1 = 0x04 ,reg2 = 0x08, reg3 = 0x0C}adsReg;
.................... 
.................... //REGISTER 0 OPTIONS
.................... 
.................... #define IPp0n1 0x00
.................... #define IPp0n2 0x10
.................... #define IPp0n3 0x20
.................... #define IPp1n2 0x30
.................... #define IPp1n3 0x40
.................... #define IPp2n3 0x50
.................... #define IPp1n0 0x60
.................... #define IPp3n2 0x70
.................... #define IPp0nVss 0x80
.................... #define IPp1nVss 0x90
.................... #define IPp2nVss 0xA0
.................... #define IPp3nVss 0xB0
.................... #define IPVrpVrn 0xC0
.................... #define IPVddVss 0xD0
.................... #define IPhalfRail 0xE0
.................... 
.................... #define g1 0x00
.................... #define g2 0x02
.................... #define g4 0x04
.................... #define g8 0x06
.................... #define g16 0x08
.................... #define g32 0x0A
.................... #define g64 0x0C
.................... #define g128 0x0E
.................... 
.................... #define PGAenabled 0x00
.................... #define PGAbypass 0x01
.................... 
.................... //REGISTER 1 OPTIONS
.................... 
.................... #define DRn20 0x00
.................... #define DRn45 0x20
.................... #define DRn90 0x40
.................... #define DRn175 0x60
.................... #define DRn330 0x80
.................... #define DRn600 0xA0
.................... #define DRn1000 0xC0
.................... 
.................... #define MDnormal 0x00
.................... #define MDduty 0x80
.................... #define MDturbo 0x10
.................... 
.................... #define CMsingle 0x00
.................... #define CMcont 0x40
.................... 
.................... #define TSdisable 0x00
.................... #define TSenable 0x20
.................... 
.................... #define BCSoff 0x00
.................... #define BCSon 0x01
.................... 
.................... //REGISTER 2 OPTIONS
.................... 
.................... #define REFinternal 0x00
.................... #define REFp0n0 0x40
.................... #define REFp1n1 0x80
.................... #define REFVddVss 0xC0
.................... 
.................... #define FIRoff 0x00
.................... #define FIR5060 0x10
.................... #define FIR50 0x20
.................... #define FIR60 0x30
.................... 
.................... #define PSWopen 0x00
.................... #define PSWstart 0x08
.................... 
.................... #define Ioff 0x00
.................... #define Iu10 0x01
.................... #define Iu50 0x02
.................... #define Iu100 0x03
.................... #define Iu250 0x04
.................... #define Iu500 0x05
.................... #define Iu1000 0x06
.................... #define Iu1500 0x07  
.................... 
.................... //REGISTER 3 OPTIONS
.................... 
.................... #define I1disabled 0x00
.................... #define I1a0p1 0x20
.................... #define I1a1 0x40
.................... #define I1a2 0x60
.................... #define I1a3n1 0x80
.................... #define I1p0 0xA0
.................... #define I1n0 0xC0
.................... 
.................... #define I2disabled 0x00
.................... #define I2a0p1 0x04
.................... #define I2a1 0x08
.................... #define I2a2 0x0A
.................... #define I2a3n1 0x10
.................... #define I2p0 0x14
.................... #define I2n0 0x18
.................... 
.................... #define drdyPin 0x00
.................... #define doutPin 0x20
.................... 
.................... // REGISTER CONGIGURATIONS FOR THIS APP
.................... #define reg0config IPp1n2|g1|PGAenabled // 0x30//
.................... #define reg1config DRn20|MDturbo|CMsingle|TSDisable|BCSoff //0x10
.................... #define reg2config REFinternal|FIRoff|PSWopen|Ioff //0x30
.................... #define reg3config I1disabled|I2disabled|drdyPin //0x00
.................... 
.................... //COMMANDS
.................... #define ADSreset 0x06
.................... #define ADSstart 0x08
.................... #define ADSpowerDn 0x02
.................... #define ADSreadData 0x10
.................... #define ADSreadReg 0x20
.................... #define ADSwriteReg 0x40
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* DESELECT ALL ADCs                                                         */
.................... /*****************************************************************************/
.................... void ads_deselect_all()
.................... {   
....................    output_high(_CS0); // deselect all chip select pins
*
00136:  MOVLW  1F
00138:  MOVWF  F8A
0013A:  BSF    F85.5
....................    output_high(_CS1);
0013C:  MOVWF  F8A
0013E:  BSF    F85.6
....................    output_high(_CS2);
00140:  MOVWF  F8A
00142:  BSF    F85.7
....................    output_high(_CS3); 
00144:  MOVLW  C4
00146:  MOVWF  F88
00148:  BSF    F83.0
....................    delay_us(10);
0014A:  MOVLW  35
0014C:  MOVWF  00
0014E:  DECFSZ 00,F
00150:  BRA    014E
00152:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT DESIRED ADC                                                        */
.................... /*****************************************************************************/
.................... void ads_select_ch(int8 ch)
.................... {
....................    ads_deselect_all();
*
00680:  RCALL  0136
....................    switch(ch)
00682:  MOVLB  6
00684:  MOVF   xA2,W
00686:  ADDLW  FC
00688:  BC    06BC
0068A:  ADDLW  04
0068C:  MOVLB  0
0068E:  GOTO   06C8
....................    {
....................       case 0:
....................          output_low(_CS0);
00692:  MOVLW  1F
00694:  MOVWF  F8A
00696:  BCF    F85.5
....................       break; 
00698:  MOVLB  6
0069A:  BRA    06BC
....................       case 1:
....................          output_low(_CS1);
0069C:  MOVLW  1F
0069E:  MOVWF  F8A
006A0:  BCF    F85.6
....................       break;   
006A2:  MOVLB  6
006A4:  BRA    06BC
....................       case 2:
....................          output_low(_CS2);
006A6:  MOVLW  1F
006A8:  MOVWF  F8A
006AA:  BCF    F85.7
....................       break;
006AC:  MOVLB  6
006AE:  BRA    06BC
....................       case 3:
....................          output_low(_CS3);
006B0:  MOVLW  C4
006B2:  MOVWF  F88
006B4:  BCF    F83.0
....................       break;              
006B6:  MOVLB  6
006B8:  BRA    06BC
006BA:  MOVLB  6
....................    }
....................    delay_us(10);
006BC:  MOVLW  35
006BE:  MOVWF  00
006C0:  DECFSZ 00,F
006C2:  BRA    06C0
006C4:  MOVLB  0
006C6:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT ADC BLOCK (2 ADCs/BLOCK)                                           */
.................... /*****************************************************************************/
.................... void ads_select_block(int8 block)
.................... {
....................    ads_deselect_all();
*
00154:  RCALL  0136
....................    switch(block)
00156:  MOVLB  7
00158:  MOVF   x17,W
0015A:  XORLW  00
0015C:  MOVLB  0
0015E:  BZ    0166
00160:  XORLW  01
00162:  BZ    0172
00164:  BRA    017E
....................    {
....................       case 0:
....................          output_low(_CS0);
00166:  MOVLW  1F
00168:  MOVWF  F8A
0016A:  BCF    F85.5
....................          output_low(_CS1);
0016C:  MOVWF  F8A
0016E:  BCF    F85.6
....................       break; 
00170:  BRA    017E
....................       case 1:         
....................          output_low(_CS2);
00172:  MOVLW  1F
00174:  MOVWF  F8A
00176:  BCF    F85.7
....................          output_low(_CS3);
00178:  MOVLW  C4
0017A:  MOVWF  F88
0017C:  BCF    F83.0
....................       break;         
....................    }
....................    delay_us(10);
0017E:  MOVLW  35
00180:  MOVWF  00
00182:  DECFSZ 00,F
00184:  BRA    0182
00186:  GOTO   0190 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT ALL ADCs                                                           */
.................... /*****************************************************************************/
.................... void ads_select_all()
.................... {
....................    output_low(_CS0);
*
007B6:  MOVLW  1F
007B8:  MOVWF  F8A
007BA:  BCF    F85.5
....................    output_low(_CS1);
007BC:  MOVWF  F8A
007BE:  BCF    F85.6
....................    output_low(_CS2);
007C0:  MOVWF  F8A
007C2:  BCF    F85.7
....................    output_low(_CS3);
007C4:  MOVLW  C4
007C6:  MOVWF  F88
007C8:  BCF    F83.0
....................    delay_us(10);
007CA:  MOVLW  35
007CC:  MOVWF  00
007CE:  DECFSZ 00,F
007D0:  BRA    07CE
007D2:  GOTO   07D8 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO AN ADC                                          */
.................... /*****************************************************************************/
.................... void ads_write_command(int8 ch, unsigned int8 command)
.................... {
....................    ads_select_ch(ch);
*
006EA:  MOVFF  6A0,6A2
006EE:  RCALL  0680
....................    spi_write2(command);
006F0:  MOVLB  E
006F2:  MOVF   x8D,W
006F4:  MOVFF  6A1,E8D
006F8:  RRCF   x90,W
006FA:  BNC   06F8
006FC:  MOVLB  0
006FE:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO A BLOCK OF ADCs                                 */
.................... /*****************************************************************************/
.................... void ads_write_command_block(int8 block, unsigned int8 command)
.................... {
....................    ads_select_block(block);
*
0018A:  MOVFF  715,717
0018E:  BRA    0154
....................    spi_write2(command);
00190:  MOVLB  E
00192:  MOVF   x8D,W
00194:  MOVFF  716,E8D
00198:  RRCF   x90,W
0019A:  BNC   0198
0019C:  MOVLB  0
0019E:  GOTO   01B0 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO ALL ADCs                                        */
.................... /*****************************************************************************/
.................... void ads_write_command_all(unsigned int8 command)
.................... {
....................    ads_select_all();
*
007D6:  BRA    07B6
....................    spi_write2(command);
007D8:  MOVLB  E
007DA:  MOVF   x8D,W
007DC:  MOVFF  697,E8D
007E0:  RRCF   x90,W
007E2:  BNC   07E0
007E4:  MOVLB  0
007E6:  GOTO   07F4 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PREPARE TO READ FROM AN ADC                                               */
.................... /*****************************************************************************/
.................... void ads_read_command(int8 ch, unsigned int8 command)
.................... {
....................    ads_select_ch(ch);
*
00802:  MOVFF  69F,6A2
00806:  RCALL  0680
....................    spi_read2(command);
00808:  MOVLB  E
0080A:  MOVF   x8D,W
0080C:  MOVFF  6A0,E8D
00810:  RRCF   x90,W
00812:  BNC   0810
00814:  MOVLB  0
00816:  GOTO   0828 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE TO THE CONFIGURATION REGISTERS                                      */
.................... /*****************************************************************************/
.................... void ads_write_reg(int8 ch, adsReg regID, int8 data)
*
00726:  MOVLB  6
00728:  MOVF   x9D,W
0072A:  IORLW  40
0072C:  MOVWF  x9F
.................... {
....................    unsigned int8 command = ADSwriteReg | regID | 0; // 0 is numbytes to write-1
....................    ads_write_command(ch, command);
0072E:  MOVFF  69C,6A0
00732:  MOVFF  69F,6A1
00736:  MOVLB  0
00738:  RCALL  06EA
....................    spi_write2(data);
0073A:  MOVLB  E
0073C:  MOVF   x8D,W
0073E:  MOVFF  69E,E8D
00742:  RRCF   x90,W
00744:  BNC   0742
....................    ads_deselect_all();
00746:  MOVLB  0
00748:  RCALL  0136
0074A:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* READ FROM THE CONFIGURATION REGISTERS                                     */
.................... /*****************************************************************************/
.................... unsigned int8 ads_read_reg(int8 ch, adsReg regID)
.................... {
....................    unsigned int8 command = ADSreadReg | regID | 0;
....................    ads_read_command(ch, command);
....................    unsigned int8 data = spi_read2(0);
....................    ads_deselect_all();
....................    return data;
.................... }
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* START BLOCK CONVERSION                                                    */
.................... /*****************************************************************************/
.................... void ads_start_conv_block(int8 block)
.................... {
....................    ads_write_command_block(block, ADSstart);
*
001A2:  MOVFF  714,715
001A6:  MOVLW  08
001A8:  MOVLB  7
001AA:  MOVWF  x16
001AC:  MOVLB  0
001AE:  BRA    018A
....................    delay_us(10);
001B0:  MOVLW  35
001B2:  MOVWF  00
001B4:  DECFSZ 00,F
001B6:  BRA    01B4
....................    ads_deselect_all();
001B8:  RCALL  0136
001BA:  GOTO   0200 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* START ALL CONVERSION                                                      */
.................... /*****************************************************************************/
.................... void ads_start_conv_all()
.................... {
....................    ads_write_command_all(ADSstart);
*
007EA:  MOVLW  08
007EC:  MOVLB  6
007EE:  MOVWF  x97
007F0:  MOVLB  0
007F2:  BRA    07D6
....................    delay_us(10);
007F4:  MOVLW  35
007F6:  MOVWF  00
007F8:  DECFSZ 00,F
007FA:  BRA    07F8
....................    ads_deselect_all();
007FC:  RCALL  0136
007FE:  GOTO   09E2 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* READ THE MOST RECENT CONVERSION                                           */
.................... /*****************************************************************************/
.................... signed int32 ads_read_data(int8 ch)
.................... {
....................    union Data
....................    {
....................       unsigned int8 dBytes[4];
....................       signed int32 dWord;
....................    }data;
....................    
....................    ads_read_command(ch, ADSreadData);
*
0081A:  MOVFF  69A,69F
0081E:  MOVLW  10
00820:  MOVLB  6
00822:  MOVWF  xA0
00824:  MOVLB  0
00826:  BRA    0802
....................    data.dBytes[0] = 0;
00828:  MOVLB  6
0082A:  CLRF   x9B
....................    data.dBytes[3] = spi_read2(0);
0082C:  MOVLB  E
0082E:  MOVF   x8D,W
00830:  CLRF   x8D
00832:  RRCF   x90,W
00834:  BNC   0832
00836:  MOVFF  E8D,69E
....................    data.dBytes[2] = spi_read2(0);
0083A:  MOVF   x8D,W
0083C:  CLRF   x8D
0083E:  RRCF   x90,W
00840:  BNC   083E
00842:  MOVFF  E8D,69D
....................    data.dBytes[1] = spi_read2(0);
00846:  MOVF   x8D,W
00848:  CLRF   x8D
0084A:  RRCF   x90,W
0084C:  BNC   084A
0084E:  MOVFF  E8D,69C
....................    
....................    ads_deselect_all();
00852:  MOVLB  0
00854:  RCALL  0136
....................    return data.dWord;
00856:  MOVFF  69B,00
0085A:  MOVFF  69C,01
0085E:  MOVFF  69D,02
00862:  MOVFF  69E,03
00866:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE A CHANNEL                                                      */
.................... /*****************************************************************************/
.................... 
.................... void ADS1220init(int8 ch, rc0=reg0config, rc1=reg1config, rc2=reg2config, rc3=reg3config)
.................... {
....................    ads_write_command(ch, ADSreset);   //reset the device
*
0074C:  MOVFF  697,6A0
00750:  MOVLW  06
00752:  MOVLB  6
00754:  MOVWF  xA1
00756:  MOVLB  0
00758:  RCALL  06EA
....................    delay_us(300);                    
0075A:  MOVLW  02
0075C:  MOVLB  6
0075E:  MOVWF  x9C
00760:  MOVLW  96
00762:  MOVWF  x9D
00764:  MOVLB  0
00766:  BRA    0700
00768:  MOVLB  6
0076A:  DECFSZ x9C,F
0076C:  BRA    0760
....................    ads_write_reg(ch, reg0, rc0);   //send default configurations
0076E:  MOVFF  697,69C
00772:  CLRF   x9D
00774:  MOVFF  698,69E
00778:  MOVLB  0
0077A:  RCALL  0726
....................    ads_write_reg(ch, reg1, rc1);
0077C:  MOVFF  697,69C
00780:  MOVLW  04
00782:  MOVLB  6
00784:  MOVWF  x9D
00786:  MOVFF  699,69E
0078A:  MOVLB  0
0078C:  RCALL  0726
....................    ads_write_reg(ch, reg2, rc2);
0078E:  MOVFF  697,69C
00792:  MOVLW  08
00794:  MOVLB  6
00796:  MOVWF  x9D
00798:  MOVFF  69A,69E
0079C:  MOVLB  0
0079E:  RCALL  0726
....................    ads_write_reg(ch, reg3, rc3);  
007A0:  MOVFF  697,69C
007A4:  MOVLW  0C
007A6:  MOVLB  6
007A8:  MOVWF  x9D
007AA:  MOVFF  69B,69E
007AE:  MOVLB  0
007B0:  RCALL  0726
007B2:  GOTO   09C4 (RETURN)
.................... }
.................... #endif 
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
*
02848:  MOVLB  6
0284A:  BCF    xDA.0
....................    y = x;
0284C:  MOVFF  6CE,6D3
02850:  MOVFF  6CD,6D2
02854:  MOVFF  6CC,6D1
02858:  MOVFF  6CB,6D0
.................... 
....................    if (x < 0)
0285C:  MOVFF  6CE,6DE
02860:  MOVFF  6CD,6DD
02864:  MOVFF  6CC,6DC
02868:  MOVFF  6CB,6DB
0286C:  CLRF   xE2
0286E:  CLRF   xE1
02870:  CLRF   xE0
02872:  CLRF   xDF
02874:  MOVLB  0
02876:  CALL   1E18
0287A:  BNC   2888
....................    {
....................       s = 1;
0287C:  MOVLB  6
0287E:  BSF    xDA.0
....................       y = -y;
02880:  MOVF   xD1,W
02882:  XORLW  80
02884:  MOVWF  xD1
02886:  MOVLB  0
....................    }
.................... 
....................    if (y <= 32768.0)
02888:  MOVFF  6D3,6DE
0288C:  MOVFF  6D2,6DD
02890:  MOVFF  6D1,6DC
02894:  MOVFF  6D0,6DB
02898:  MOVLB  6
0289A:  CLRF   xE2
0289C:  CLRF   xE1
0289E:  CLRF   xE0
028A0:  MOVLW  8E
028A2:  MOVWF  xDF
028A4:  MOVLB  0
028A6:  CALL   1E18
028AA:  BC    28AE
028AC:  BNZ   28DE
....................       res = (float32)(unsigned int16)y;
028AE:  MOVFF  6D3,6DE
028B2:  MOVFF  6D2,6DD
028B6:  MOVFF  6D1,6DC
028BA:  MOVFF  6D0,6DB
028BE:  RCALL  280C
028C0:  MOVFF  02,6E0
028C4:  MOVFF  01,6DF
028C8:  CALL   0E04
028CC:  MOVFF  03,6D7
028D0:  MOVFF  02,6D6
028D4:  MOVFF  01,6D5
028D8:  MOVFF  00,6D4
028DC:  BRA    2A80
.................... 
....................  else if (y < 10000000.0)
028DE:  MOVFF  6D3,6DE
028E2:  MOVFF  6D2,6DD
028E6:  MOVFF  6D1,6DC
028EA:  MOVFF  6D0,6DB
028EE:  MOVLW  80
028F0:  MOVLB  6
028F2:  MOVWF  xE2
028F4:  MOVLW  96
028F6:  MOVWF  xE1
028F8:  MOVLW  18
028FA:  MOVWF  xE0
028FC:  MOVLW  96
028FE:  MOVWF  xDF
02900:  MOVLB  0
02902:  CALL   1E18
02906:  BTFSS  FD8.0
02908:  BRA    2A70
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
0290A:  MOVFF  6D3,6E3
0290E:  MOVFF  6D2,6E2
02912:  MOVFF  6D1,6E1
02916:  MOVFF  6D0,6E0
0291A:  MOVLB  6
0291C:  CLRF   xE7
0291E:  CLRF   xE6
02920:  CLRF   xE5
02922:  MOVLW  70
02924:  MOVWF  xE4
02926:  MOVLB  0
02928:  CALL   0E3A
0292C:  MOVFF  03,6DE
02930:  MOVFF  02,6DD
02934:  MOVFF  01,6DC
02938:  MOVFF  00,6DB
0293C:  RCALL  280C
0293E:  MOVFF  02,6D9
02942:  MOVFF  01,6D8
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
02946:  MOVFF  6D3,6E3
0294A:  MOVFF  6D2,6E2
0294E:  MOVFF  6D1,6E1
02952:  MOVFF  6D0,6E0
02956:  MOVLB  6
02958:  CLRF   xE7
0295A:  CLRF   xE6
0295C:  CLRF   xE5
0295E:  MOVLW  70
02960:  MOVWF  xE4
02962:  MOVLB  0
02964:  CALL   0E3A
02968:  MOVFF  03,6DE
0296C:  MOVFF  02,6DD
02970:  MOVFF  01,6DC
02974:  MOVFF  00,6DB
02978:  MOVFF  6D9,6E0
0297C:  MOVFF  6D8,6DF
02980:  CALL   0E04
02984:  BSF    FD8.1
02986:  MOVFF  6DE,6E2
0298A:  MOVFF  6DD,6E1
0298E:  MOVFF  6DC,6E0
02992:  MOVFF  6DB,6DF
02996:  MOVFF  03,6E6
0299A:  MOVFF  02,6E5
0299E:  MOVFF  01,6E4
029A2:  MOVFF  00,6E3
029A6:  CALL   0F30
029AA:  MOVLB  6
029AC:  CLRF   xE3
029AE:  CLRF   xE2
029B0:  CLRF   xE1
029B2:  MOVLW  8E
029B4:  MOVWF  xE0
029B6:  MOVFF  03,6E7
029BA:  MOVFF  02,6E6
029BE:  MOVFF  01,6E5
029C2:  MOVFF  00,6E4
029C6:  MOVLB  0
029C8:  CALL   0E3A
029CC:  MOVFF  03,6D3
029D0:  MOVFF  02,6D2
029D4:  MOVFF  01,6D1
029D8:  MOVFF  00,6D0
....................       res = 32768.0*(float32)l;
029DC:  MOVFF  6D9,6E0
029E0:  MOVFF  6D8,6DF
029E4:  CALL   0E04
029E8:  MOVLB  6
029EA:  CLRF   xE3
029EC:  CLRF   xE2
029EE:  CLRF   xE1
029F0:  MOVLW  8E
029F2:  MOVWF  xE0
029F4:  MOVFF  03,6E7
029F8:  MOVFF  02,6E6
029FC:  MOVFF  01,6E5
02A00:  MOVFF  00,6E4
02A04:  MOVLB  0
02A06:  CALL   0E3A
02A0A:  MOVFF  03,6D7
02A0E:  MOVFF  02,6D6
02A12:  MOVFF  01,6D5
02A16:  MOVFF  00,6D4
....................       res += (float32)(unsigned int16)y;
02A1A:  MOVFF  6D3,6DE
02A1E:  MOVFF  6D2,6DD
02A22:  MOVFF  6D1,6DC
02A26:  MOVFF  6D0,6DB
02A2A:  RCALL  280C
02A2C:  MOVFF  02,6E0
02A30:  MOVFF  01,6DF
02A34:  CALL   0E04
02A38:  BCF    FD8.1
02A3A:  MOVFF  6D7,6E2
02A3E:  MOVFF  6D6,6E1
02A42:  MOVFF  6D5,6E0
02A46:  MOVFF  6D4,6DF
02A4A:  MOVFF  03,6E6
02A4E:  MOVFF  02,6E5
02A52:  MOVFF  01,6E4
02A56:  MOVFF  00,6E3
02A5A:  CALL   0F30
02A5E:  MOVFF  03,6D7
02A62:  MOVFF  02,6D6
02A66:  MOVFF  01,6D5
02A6A:  MOVFF  00,6D4
....................    }
02A6E:  BRA    2A80
.................... 
....................  else
....................   res = y;
02A70:  MOVFF  6D3,6D7
02A74:  MOVFF  6D2,6D6
02A78:  MOVFF  6D1,6D5
02A7C:  MOVFF  6D0,6D4
.................... 
....................  y = y - (float32)(unsigned int16)y;
02A80:  MOVFF  6D3,6DE
02A84:  MOVFF  6D2,6DD
02A88:  MOVFF  6D1,6DC
02A8C:  MOVFF  6D0,6DB
02A90:  RCALL  280C
02A92:  MOVFF  02,6E0
02A96:  MOVFF  01,6DF
02A9A:  CALL   0E04
02A9E:  BSF    FD8.1
02AA0:  MOVFF  6D3,6E2
02AA4:  MOVFF  6D2,6E1
02AA8:  MOVFF  6D1,6E0
02AAC:  MOVFF  6D0,6DF
02AB0:  MOVFF  03,6E6
02AB4:  MOVFF  02,6E5
02AB8:  MOVFF  01,6E4
02ABC:  MOVFF  00,6E3
02AC0:  CALL   0F30
02AC4:  MOVFF  03,6D3
02AC8:  MOVFF  02,6D2
02ACC:  MOVFF  01,6D1
02AD0:  MOVFF  00,6D0
.................... 
....................  if (s)
02AD4:  MOVLB  6
02AD6:  BTFSS  xDA.0
02AD8:  BRA    2AE0
....................   res = -res;
02ADA:  MOVF   xD5,W
02ADC:  XORLW  80
02ADE:  MOVWF  xD5
.................... 
....................  if (y != 0)
02AE0:  MOVFF  6D3,6DE
02AE4:  MOVFF  6D2,6DD
02AE8:  MOVFF  6D1,6DC
02AEC:  MOVFF  6D0,6DB
02AF0:  CLRF   xE2
02AF2:  CLRF   xE1
02AF4:  CLRF   xE0
02AF6:  CLRF   xDF
02AF8:  MOVLB  0
02AFA:  CALL   1E18
02AFE:  BZ    2B78
....................  {
....................   if (s == 1 && n == 0)
02B00:  MOVLB  6
02B02:  BTFSS  xDA.0
02B04:  BRA    2B3E
02B06:  MOVF   xCF,F
02B08:  BNZ   2B3E
....................    res -= 1.0;
02B0A:  BSF    FD8.1
02B0C:  MOVFF  6D7,6E2
02B10:  MOVFF  6D6,6E1
02B14:  MOVFF  6D5,6E0
02B18:  MOVFF  6D4,6DF
02B1C:  CLRF   xE6
02B1E:  CLRF   xE5
02B20:  CLRF   xE4
02B22:  MOVLW  7F
02B24:  MOVWF  xE3
02B26:  MOVLB  0
02B28:  CALL   0F30
02B2C:  MOVFF  03,6D7
02B30:  MOVFF  02,6D6
02B34:  MOVFF  01,6D5
02B38:  MOVFF  00,6D4
02B3C:  MOVLB  6
.................... 
....................   if (s == 0 && n == 1)
02B3E:  BTFSC  xDA.0
02B40:  BRA    2B7A
02B42:  DECFSZ xCF,W
02B44:  BRA    2B7A
....................    res += 1.0;
02B46:  BCF    FD8.1
02B48:  MOVFF  6D7,6E2
02B4C:  MOVFF  6D6,6E1
02B50:  MOVFF  6D5,6E0
02B54:  MOVFF  6D4,6DF
02B58:  CLRF   xE6
02B5A:  CLRF   xE5
02B5C:  CLRF   xE4
02B5E:  MOVLW  7F
02B60:  MOVWF  xE3
02B62:  MOVLB  0
02B64:  CALL   0F30
02B68:  MOVFF  03,6D7
02B6C:  MOVFF  02,6D6
02B70:  MOVFF  01,6D5
02B74:  MOVFF  00,6D4
02B78:  MOVLB  6
....................  }
....................  if (x == 0)
02B7A:  MOVFF  6CE,6DE
02B7E:  MOVFF  6CD,6DD
02B82:  MOVFF  6CC,6DC
02B86:  MOVFF  6CB,6DB
02B8A:  CLRF   xE2
02B8C:  CLRF   xE1
02B8E:  CLRF   xE0
02B90:  CLRF   xDF
02B92:  MOVLB  0
02B94:  CALL   1E18
02B98:  BNZ   2BA6
....................     res = 0;
02B9A:  MOVLB  6
02B9C:  CLRF   xD7
02B9E:  CLRF   xD6
02BA0:  CLRF   xD5
02BA2:  CLRF   xD4
02BA4:  MOVLB  0
.................... 
....................  return (res);
02BA6:  MOVFF  6D4,00
02BAA:  MOVFF  6D5,01
02BAE:  MOVFF  6D6,02
02BB2:  MOVFF  6D7,03
02BB6:  RETURN 0
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
*
02BD6:  MOVFF  6CA,6CE
02BDA:  MOVFF  6C9,6CD
02BDE:  MOVFF  6C8,6CC
02BE2:  MOVFF  6C7,6CB
02BE6:  MOVLB  6
02BE8:  CLRF   xCF
02BEA:  MOVLB  0
02BEC:  RCALL  2848
02BEE:  GOTO   2CFA (RETURN)
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
*
02BB8:  MOVFF  6CA,6CE
02BBC:  MOVFF  6C9,6CD
02BC0:  MOVFF  6C8,6CC
02BC4:  MOVFF  6C7,6CB
02BC8:  MOVLW  01
02BCA:  MOVLB  6
02BCC:  MOVWF  xCF
02BCE:  MOVLB  0
02BD0:  RCALL  2848
02BD2:  GOTO   2CB2 (RETURN)
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
*
02BF2:  MOVFF  6BE,6DE
02BF6:  MOVFF  6BD,6DD
02BFA:  MOVFF  6BC,6DC
02BFE:  MOVFF  6BB,6DB
02C02:  MOVLB  6
02C04:  CLRF   xE2
02C06:  CLRF   xE1
02C08:  CLRF   xE0
02C0A:  CLRF   xDF
02C0C:  MOVLB  0
02C0E:  CALL   1E18
02C12:  BTFSC  FD8.2
02C14:  BRA    2D56
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
02C16:  MOVFF  6BA,6D7
02C1A:  MOVFF  6B9,6D6
02C1E:  MOVFF  6B8,6D5
02C22:  MOVFF  6B7,6D4
02C26:  MOVFF  6BE,6DB
02C2A:  MOVFF  6BD,6DA
02C2E:  MOVFF  6BC,6D9
02C32:  MOVFF  6BB,6D8
02C36:  CALL   1E92
02C3A:  MOVFF  03,6C6
02C3E:  MOVFF  02,6C5
02C42:  MOVFF  01,6C4
02C46:  MOVFF  00,6C3
02C4A:  MOVFF  03,6DE
02C4E:  MOVFF  02,6DD
02C52:  MOVFF  01,6DC
02C56:  MOVFF  00,6DB
02C5A:  MOVLB  6
02C5C:  CLRF   xE2
02C5E:  CLRF   xE1
02C60:  CLRF   xE0
02C62:  CLRF   xDF
02C64:  MOVLB  0
02C66:  CALL   1E18
02C6A:  BNC   2CB4
02C6C:  MOVFF  6BA,6D7
02C70:  MOVFF  6B9,6D6
02C74:  MOVFF  6B8,6D5
02C78:  MOVFF  6B7,6D4
02C7C:  MOVFF  6BE,6DB
02C80:  MOVFF  6BD,6DA
02C84:  MOVFF  6BC,6D9
02C88:  MOVFF  6BB,6D8
02C8C:  CALL   1E92
02C90:  MOVFF  03,6C6
02C94:  MOVFF  02,6C5
02C98:  MOVFF  01,6C4
02C9C:  MOVFF  00,6C3
02CA0:  MOVFF  03,6CA
02CA4:  MOVFF  02,6C9
02CA8:  MOVFF  01,6C8
02CAC:  MOVFF  00,6C7
02CB0:  BRA    2BB8
02CB2:  BRA    2CFA
02CB4:  MOVFF  6BA,6D7
02CB8:  MOVFF  6B9,6D6
02CBC:  MOVFF  6B8,6D5
02CC0:  MOVFF  6B7,6D4
02CC4:  MOVFF  6BE,6DB
02CC8:  MOVFF  6BD,6DA
02CCC:  MOVFF  6BC,6D9
02CD0:  MOVFF  6BB,6D8
02CD4:  CALL   1E92
02CD8:  MOVFF  03,6C6
02CDC:  MOVFF  02,6C5
02CE0:  MOVFF  01,6C4
02CE4:  MOVFF  00,6C3
02CE8:  MOVFF  03,6CA
02CEC:  MOVFF  02,6C9
02CF0:  MOVFF  01,6C8
02CF4:  MOVFF  00,6C7
02CF8:  BRA    2BD6
02CFA:  MOVFF  03,6C2
02CFE:  MOVFF  02,6C1
02D02:  MOVFF  01,6C0
02D06:  MOVFF  00,6BF
....................       return(x-(i*y));
02D0A:  MOVFF  6C2,6E3
02D0E:  MOVFF  6C1,6E2
02D12:  MOVFF  6C0,6E1
02D16:  MOVFF  6BF,6E0
02D1A:  MOVFF  6BE,6E7
02D1E:  MOVFF  6BD,6E6
02D22:  MOVFF  6BC,6E5
02D26:  MOVFF  6BB,6E4
02D2A:  CALL   0E3A
02D2E:  BSF    FD8.1
02D30:  MOVFF  6BA,6E2
02D34:  MOVFF  6B9,6E1
02D38:  MOVFF  6B8,6E0
02D3C:  MOVFF  6B7,6DF
02D40:  MOVFF  03,6E6
02D44:  MOVFF  02,6E5
02D48:  MOVFF  01,6E4
02D4C:  MOVFF  00,6E3
02D50:  CALL   0F30
02D54:  BRA    2D56
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
02D56:  RETURN 0
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
*
030EC:  MOVFF  6BE,6E3
030F0:  MOVFF  6BD,6E2
030F4:  MOVFF  6BC,6E1
030F8:  MOVFF  6BB,6E0
030FC:  MOVLW  3B
030FE:  MOVLB  6
03100:  MOVWF  xE7
03102:  MOVLW  AA
03104:  MOVWF  xE6
03106:  MOVLW  38
03108:  MOVWF  xE5
0310A:  MOVLW  7F
0310C:  MOVWF  xE4
0310E:  MOVLB  0
03110:  CALL   0E3A
03114:  MOVFF  03,6DE
03118:  MOVFF  02,6DD
0311C:  MOVFF  01,6DC
03120:  MOVFF  00,6DB
03124:  CALL   280C
03128:  MOVFF  01,6CB
....................    s = 0;
0312C:  MOVLB  6
0312E:  BCF    xCC.0
....................    y = x;
03130:  MOVFF  6BE,6C2
03134:  MOVFF  6BD,6C1
03138:  MOVFF  6BC,6C0
0313C:  MOVFF  6BB,6BF
.................... 
....................    if (x < 0)
03140:  MOVFF  6BE,6DE
03144:  MOVFF  6BD,6DD
03148:  MOVFF  6BC,6DC
0314C:  MOVFF  6BB,6DB
03150:  CLRF   xE2
03152:  CLRF   xE1
03154:  CLRF   xE0
03156:  CLRF   xDF
03158:  MOVLB  0
0315A:  CALL   1E18
0315E:  BNC   316E
....................    {
....................       s = 1;
03160:  MOVLB  6
03162:  BSF    xCC.0
....................       n = -n;
03164:  NEGF   xCB
....................       y = -y;
03166:  MOVF   xC0,W
03168:  XORLW  80
0316A:  MOVWF  xC0
0316C:  MOVLB  0
....................    }
.................... 
....................    res = 0.0;
0316E:  MOVLB  6
03170:  CLRF   xC6
03172:  CLRF   xC5
03174:  CLRF   xC4
03176:  CLRF   xC3
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
03178:  MOVLW  06
0317A:  MOVWF  xCE
0317C:  MOVLW  C3
0317E:  MOVFF  6CE,FEA
03182:  MOVWF  FE9
03184:  MOVLW  7F
03186:  ADDWF  xCB,W
03188:  MOVWF  FEF
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
0318A:  MOVFF  6C2,6E3
0318E:  MOVFF  6C1,6E2
03192:  MOVFF  6C0,6E1
03196:  MOVFF  6BF,6E0
0319A:  MOVLW  3B
0319C:  MOVWF  xE7
0319E:  MOVLW  AA
031A0:  MOVWF  xE6
031A2:  MOVLW  38
031A4:  MOVWF  xE5
031A6:  MOVLW  7F
031A8:  MOVWF  xE4
031AA:  MOVLB  0
031AC:  CALL   0E3A
031B0:  MOVFF  03,6D0
031B4:  MOVFF  02,6CF
031B8:  MOVFF  01,6CE
031BC:  MOVFF  00,6CD
031C0:  MOVLB  6
031C2:  CLRF   xD2
031C4:  MOVFF  6CB,6D1
031C8:  BTFSC  xD1.7
031CA:  DECF   xD2,F
031CC:  MOVLB  0
031CE:  CALL   27BC
031D2:  BSF    FD8.1
031D4:  MOVFF  6D0,6E2
031D8:  MOVFF  6CF,6E1
031DC:  MOVFF  6CE,6E0
031E0:  MOVFF  6CD,6DF
031E4:  MOVFF  03,6E6
031E8:  MOVFF  02,6E5
031EC:  MOVFF  01,6E4
031F0:  MOVFF  00,6E3
031F4:  CALL   0F30
031F8:  MOVFF  03,6C2
031FC:  MOVFF  02,6C1
03200:  MOVFF  01,6C0
03204:  MOVFF  00,6BF
.................... 
....................    r = pe[0]*y + pe[1];
03208:  MOVLW  7C
0320A:  MOVLB  6
0320C:  MOVWF  xE3
0320E:  MOVLW  88
03210:  MOVWF  xE2
03212:  MOVLW  59
03214:  MOVWF  xE1
03216:  MOVLW  72
03218:  MOVWF  xE0
0321A:  MOVFF  6C2,6E7
0321E:  MOVFF  6C1,6E6
03222:  MOVFF  6C0,6E5
03226:  MOVFF  6BF,6E4
0322A:  MOVLB  0
0322C:  CALL   0E3A
03230:  MOVFF  03,6D0
03234:  MOVFF  02,6CF
03238:  MOVFF  01,6CE
0323C:  MOVFF  00,6CD
03240:  BCF    FD8.1
03242:  MOVFF  03,6E2
03246:  MOVFF  02,6E1
0324A:  MOVFF  01,6E0
0324E:  MOVFF  00,6DF
03252:  MOVLW  E0
03254:  MOVLB  6
03256:  MOVWF  xE6
03258:  MOVLW  97
0325A:  MOVWF  xE5
0325C:  MOVLW  26
0325E:  MOVWF  xE4
03260:  MOVLW  75
03262:  MOVWF  xE3
03264:  MOVLB  0
03266:  CALL   0F30
0326A:  MOVFF  03,6CA
0326E:  MOVFF  02,6C9
03272:  MOVFF  01,6C8
03276:  MOVFF  00,6C7
....................    r = r*y + pe[2];
0327A:  MOVFF  6CA,6E3
0327E:  MOVFF  6C9,6E2
03282:  MOVFF  6C8,6E1
03286:  MOVFF  6C7,6E0
0328A:  MOVFF  6C2,6E7
0328E:  MOVFF  6C1,6E6
03292:  MOVFF  6C0,6E5
03296:  MOVFF  6BF,6E4
0329A:  CALL   0E3A
0329E:  MOVFF  03,6D0
032A2:  MOVFF  02,6CF
032A6:  MOVFF  01,6CE
032AA:  MOVFF  00,6CD
032AE:  BCF    FD8.1
032B0:  MOVFF  03,6E2
032B4:  MOVFF  02,6E1
032B8:  MOVFF  01,6E0
032BC:  MOVFF  00,6DF
032C0:  MOVLW  C4
032C2:  MOVLB  6
032C4:  MOVWF  xE6
032C6:  MOVLW  1D
032C8:  MOVWF  xE5
032CA:  MOVLW  1E
032CC:  MOVWF  xE4
032CE:  MOVLW  78
032D0:  MOVWF  xE3
032D2:  MOVLB  0
032D4:  CALL   0F30
032D8:  MOVFF  03,6CA
032DC:  MOVFF  02,6C9
032E0:  MOVFF  01,6C8
032E4:  MOVFF  00,6C7
....................    r = r*y + pe[3];
032E8:  MOVFF  6CA,6E3
032EC:  MOVFF  6C9,6E2
032F0:  MOVFF  6C8,6E1
032F4:  MOVFF  6C7,6E0
032F8:  MOVFF  6C2,6E7
032FC:  MOVFF  6C1,6E6
03300:  MOVFF  6C0,6E5
03304:  MOVFF  6BF,6E4
03308:  CALL   0E3A
0330C:  MOVFF  03,6D0
03310:  MOVFF  02,6CF
03314:  MOVFF  01,6CE
03318:  MOVFF  00,6CD
0331C:  BCF    FD8.1
0331E:  MOVFF  03,6E2
03322:  MOVFF  02,6E1
03326:  MOVFF  01,6E0
0332A:  MOVFF  00,6DF
0332E:  MOVLW  5E
03330:  MOVLB  6
03332:  MOVWF  xE6
03334:  MOVLW  50
03336:  MOVWF  xE5
03338:  MOVLW  63
0333A:  MOVWF  xE4
0333C:  MOVLW  7A
0333E:  MOVWF  xE3
03340:  MOVLB  0
03342:  CALL   0F30
03346:  MOVFF  03,6CA
0334A:  MOVFF  02,6C9
0334E:  MOVFF  01,6C8
03352:  MOVFF  00,6C7
....................    r = r*y + pe[4];
03356:  MOVFF  6CA,6E3
0335A:  MOVFF  6C9,6E2
0335E:  MOVFF  6C8,6E1
03362:  MOVFF  6C7,6E0
03366:  MOVFF  6C2,6E7
0336A:  MOVFF  6C1,6E6
0336E:  MOVFF  6C0,6E5
03372:  MOVFF  6BF,6E4
03376:  CALL   0E3A
0337A:  MOVFF  03,6D0
0337E:  MOVFF  02,6CF
03382:  MOVFF  01,6CE
03386:  MOVFF  00,6CD
0338A:  BCF    FD8.1
0338C:  MOVFF  03,6E2
03390:  MOVFF  02,6E1
03394:  MOVFF  01,6E0
03398:  MOVFF  00,6DF
0339C:  MOVLW  1A
0339E:  MOVLB  6
033A0:  MOVWF  xE6
033A2:  MOVLW  FE
033A4:  MOVWF  xE5
033A6:  MOVLW  75
033A8:  MOVWF  xE4
033AA:  MOVLW  7C
033AC:  MOVWF  xE3
033AE:  MOVLB  0
033B0:  CALL   0F30
033B4:  MOVFF  03,6CA
033B8:  MOVFF  02,6C9
033BC:  MOVFF  01,6C8
033C0:  MOVFF  00,6C7
....................    r = r*y + pe[5];
033C4:  MOVFF  6CA,6E3
033C8:  MOVFF  6C9,6E2
033CC:  MOVFF  6C8,6E1
033D0:  MOVFF  6C7,6E0
033D4:  MOVFF  6C2,6E7
033D8:  MOVFF  6C1,6E6
033DC:  MOVFF  6C0,6E5
033E0:  MOVFF  6BF,6E4
033E4:  CALL   0E3A
033E8:  MOVFF  03,6D0
033EC:  MOVFF  02,6CF
033F0:  MOVFF  01,6CE
033F4:  MOVFF  00,6CD
033F8:  BCF    FD8.1
033FA:  MOVFF  03,6E2
033FE:  MOVFF  02,6E1
03402:  MOVFF  01,6E0
03406:  MOVFF  00,6DF
0340A:  MOVLW  18
0340C:  MOVLB  6
0340E:  MOVWF  xE6
03410:  MOVLW  72
03412:  MOVWF  xE5
03414:  MOVLW  31
03416:  MOVWF  xE4
03418:  MOVLW  7E
0341A:  MOVWF  xE3
0341C:  MOVLB  0
0341E:  CALL   0F30
03422:  MOVFF  03,6CA
03426:  MOVFF  02,6C9
0342A:  MOVFF  01,6C8
0342E:  MOVFF  00,6C7
.................... 
....................    res = res*(1.0 + y*r);
03432:  MOVFF  6C2,6E3
03436:  MOVFF  6C1,6E2
0343A:  MOVFF  6C0,6E1
0343E:  MOVFF  6BF,6E0
03442:  MOVFF  6CA,6E7
03446:  MOVFF  6C9,6E6
0344A:  MOVFF  6C8,6E5
0344E:  MOVFF  6C7,6E4
03452:  CALL   0E3A
03456:  BCF    FD8.1
03458:  MOVLB  6
0345A:  CLRF   xE2
0345C:  CLRF   xE1
0345E:  CLRF   xE0
03460:  MOVLW  7F
03462:  MOVWF  xDF
03464:  MOVFF  03,6E6
03468:  MOVFF  02,6E5
0346C:  MOVFF  01,6E4
03470:  MOVFF  00,6E3
03474:  MOVLB  0
03476:  CALL   0F30
0347A:  MOVFF  6C6,6E3
0347E:  MOVFF  6C5,6E2
03482:  MOVFF  6C4,6E1
03486:  MOVFF  6C3,6E0
0348A:  MOVFF  03,6E7
0348E:  MOVFF  02,6E6
03492:  MOVFF  01,6E5
03496:  MOVFF  00,6E4
0349A:  CALL   0E3A
0349E:  MOVFF  03,6C6
034A2:  MOVFF  02,6C5
034A6:  MOVFF  01,6C4
034AA:  MOVFF  00,6C3
.................... 
....................    if (s)
034AE:  MOVLB  6
034B0:  BTFSS  xCC.0
034B2:  BRA    34E6
....................       res = 1.0/res;
034B4:  CLRF   xD7
034B6:  CLRF   xD6
034B8:  CLRF   xD5
034BA:  MOVLW  7F
034BC:  MOVWF  xD4
034BE:  MOVFF  6C6,6DB
034C2:  MOVFF  6C5,6DA
034C6:  MOVFF  6C4,6D9
034CA:  MOVFF  6C3,6D8
034CE:  MOVLB  0
034D0:  CALL   1E92
034D4:  MOVFF  03,6C6
034D8:  MOVFF  02,6C5
034DC:  MOVFF  01,6C4
034E0:  MOVFF  00,6C3
034E4:  MOVLB  6
....................    return(res);
034E6:  MOVFF  6C3,00
034EA:  MOVFF  6C4,01
034EE:  MOVFF  6C5,02
034F2:  MOVFF  6C6,03
034F6:  MOVLB  0
034F8:  RETURN 0
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
*
02D58:  MOVFF  6BE,6C2
02D5C:  MOVFF  6BD,6C1
02D60:  MOVFF  6BC,6C0
02D64:  MOVFF  6BB,6BF
.................... 
....................    if (y != 1.0)
02D68:  MOVFF  6C2,6DE
02D6C:  MOVFF  6C1,6DD
02D70:  MOVFF  6C0,6DC
02D74:  MOVFF  6BF,6DB
02D78:  MOVLB  6
02D7A:  CLRF   xE2
02D7C:  CLRF   xE1
02D7E:  CLRF   xE0
02D80:  MOVLW  7F
02D82:  MOVWF  xDF
02D84:  MOVLB  0
02D86:  CALL   1E18
02D8A:  BTFSC  FD8.2
02D8C:  BRA    30CE
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
02D8E:  MOVLW  06
02D90:  MOVLB  6
02D92:  MOVWF  xD1
02D94:  MOVLW  BF
02D96:  MOVFF  6D1,FEA
02D9A:  MOVWF  FE9
02D9C:  MOVLW  7E
02D9E:  MOVWF  FEF
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
02DA0:  BSF    FD8.1
02DA2:  MOVFF  6C2,6E2
02DA6:  MOVFF  6C1,6E1
02DAA:  MOVFF  6C0,6E0
02DAE:  MOVFF  6BF,6DF
02DB2:  CLRF   xE6
02DB4:  CLRF   xE5
02DB6:  CLRF   xE4
02DB8:  MOVLW  7F
02DBA:  MOVWF  xE3
02DBC:  MOVLB  0
02DBE:  CALL   0F30
02DC2:  MOVFF  03,6D3
02DC6:  MOVFF  02,6D2
02DCA:  MOVFF  01,6D1
02DCE:  MOVFF  00,6D0
02DD2:  BCF    FD8.1
02DD4:  MOVFF  6C2,6E2
02DD8:  MOVFF  6C1,6E1
02DDC:  MOVFF  6C0,6E0
02DE0:  MOVFF  6BF,6DF
02DE4:  MOVLB  6
02DE6:  CLRF   xE6
02DE8:  CLRF   xE5
02DEA:  CLRF   xE4
02DEC:  MOVLW  7F
02DEE:  MOVWF  xE3
02DF0:  MOVLB  0
02DF2:  CALL   0F30
02DF6:  MOVFF  6D3,6D7
02DFA:  MOVFF  6D2,6D6
02DFE:  MOVFF  6D1,6D5
02E02:  MOVFF  6D0,6D4
02E06:  MOVFF  03,6DB
02E0A:  MOVFF  02,6DA
02E0E:  MOVFF  01,6D9
02E12:  MOVFF  00,6D8
02E16:  CALL   1E92
02E1A:  MOVFF  03,6C2
02E1E:  MOVFF  02,6C1
02E22:  MOVFF  01,6C0
02E26:  MOVFF  00,6BF
.................... 
....................       y2=y*y;
02E2A:  MOVFF  6C2,6E3
02E2E:  MOVFF  6C1,6E2
02E32:  MOVFF  6C0,6E1
02E36:  MOVFF  6BF,6E0
02E3A:  MOVFF  6C2,6E7
02E3E:  MOVFF  6C1,6E6
02E42:  MOVFF  6C0,6E5
02E46:  MOVFF  6BF,6E4
02E4A:  CALL   0E3A
02E4E:  MOVFF  03,6CE
02E52:  MOVFF  02,6CD
02E56:  MOVFF  01,6CC
02E5A:  MOVFF  00,6CB
.................... 
....................       res = pl[0]*y2 + pl[1];
02E5E:  MOVLW  99
02E60:  MOVLB  6
02E62:  MOVWF  xE3
02E64:  MOVLW  47
02E66:  MOVWF  xE2
02E68:  MOVLW  8A
02E6A:  MOVWF  xE1
02E6C:  MOVLW  7F
02E6E:  MOVWF  xE0
02E70:  MOVFF  6CE,6E7
02E74:  MOVFF  6CD,6E6
02E78:  MOVFF  6CC,6E5
02E7C:  MOVFF  6CB,6E4
02E80:  MOVLB  0
02E82:  CALL   0E3A
02E86:  MOVFF  03,6D3
02E8A:  MOVFF  02,6D2
02E8E:  MOVFF  01,6D1
02E92:  MOVFF  00,6D0
02E96:  BCF    FD8.1
02E98:  MOVFF  03,6E2
02E9C:  MOVFF  02,6E1
02EA0:  MOVFF  01,6E0
02EA4:  MOVFF  00,6DF
02EA8:  MOVLB  6
02EAA:  CLRF   xE6
02EAC:  CLRF   xE5
02EAE:  CLRF   xE4
02EB0:  MOVLW  80
02EB2:  MOVWF  xE3
02EB4:  MOVLB  0
02EB6:  CALL   0F30
02EBA:  MOVFF  03,6C6
02EBE:  MOVFF  02,6C5
02EC2:  MOVFF  01,6C4
02EC6:  MOVFF  00,6C3
.................... 
....................       r = ql[0]*y2 + ql[1];
02ECA:  MOVLW  4C
02ECC:  MOVLB  6
02ECE:  MOVWF  xE3
02ED0:  MOVLW  F3
02ED2:  MOVWF  xE2
02ED4:  MOVLW  3A
02ED6:  MOVWF  xE1
02ED8:  MOVLW  7B
02EDA:  MOVWF  xE0
02EDC:  MOVFF  6CE,6E7
02EE0:  MOVFF  6CD,6E6
02EE4:  MOVFF  6CC,6E5
02EE8:  MOVFF  6CB,6E4
02EEC:  MOVLB  0
02EEE:  CALL   0E3A
02EF2:  MOVFF  03,6D3
02EF6:  MOVFF  02,6D2
02EFA:  MOVFF  01,6D1
02EFE:  MOVFF  00,6D0
02F02:  BCF    FD8.1
02F04:  MOVFF  03,6E2
02F08:  MOVFF  02,6E1
02F0C:  MOVFF  01,6E0
02F10:  MOVFF  00,6DF
02F14:  MOVLW  2B
02F16:  MOVLB  6
02F18:  MOVWF  xE6
02F1A:  MOVLW  9D
02F1C:  MOVWF  xE5
02F1E:  MOVLW  DF
02F20:  MOVWF  xE4
02F22:  MOVLW  7E
02F24:  MOVWF  xE3
02F26:  MOVLB  0
02F28:  CALL   0F30
02F2C:  MOVFF  03,6CA
02F30:  MOVFF  02,6C9
02F34:  MOVFF  01,6C8
02F38:  MOVFF  00,6C7
....................       r = r*y2 + 1.0;
02F3C:  MOVFF  6CA,6E3
02F40:  MOVFF  6C9,6E2
02F44:  MOVFF  6C8,6E1
02F48:  MOVFF  6C7,6E0
02F4C:  MOVFF  6CE,6E7
02F50:  MOVFF  6CD,6E6
02F54:  MOVFF  6CC,6E5
02F58:  MOVFF  6CB,6E4
02F5C:  CALL   0E3A
02F60:  MOVFF  03,6D3
02F64:  MOVFF  02,6D2
02F68:  MOVFF  01,6D1
02F6C:  MOVFF  00,6D0
02F70:  BCF    FD8.1
02F72:  MOVFF  03,6E2
02F76:  MOVFF  02,6E1
02F7A:  MOVFF  01,6E0
02F7E:  MOVFF  00,6DF
02F82:  MOVLB  6
02F84:  CLRF   xE6
02F86:  CLRF   xE5
02F88:  CLRF   xE4
02F8A:  MOVLW  7F
02F8C:  MOVWF  xE3
02F8E:  MOVLB  0
02F90:  CALL   0F30
02F94:  MOVFF  03,6CA
02F98:  MOVFF  02,6C9
02F9C:  MOVFF  01,6C8
02FA0:  MOVFF  00,6C7
.................... 
....................       res = y*res/r;
02FA4:  MOVFF  6C2,6E3
02FA8:  MOVFF  6C1,6E2
02FAC:  MOVFF  6C0,6E1
02FB0:  MOVFF  6BF,6E0
02FB4:  MOVFF  6C6,6E7
02FB8:  MOVFF  6C5,6E6
02FBC:  MOVFF  6C4,6E5
02FC0:  MOVFF  6C3,6E4
02FC4:  CALL   0E3A
02FC8:  MOVFF  03,6D3
02FCC:  MOVFF  02,6D2
02FD0:  MOVFF  01,6D1
02FD4:  MOVFF  00,6D0
02FD8:  MOVFF  03,6D7
02FDC:  MOVFF  02,6D6
02FE0:  MOVFF  01,6D5
02FE4:  MOVFF  00,6D4
02FE8:  MOVFF  6CA,6DB
02FEC:  MOVFF  6C9,6DA
02FF0:  MOVFF  6C8,6D9
02FF4:  MOVFF  6C7,6D8
02FF8:  CALL   1E92
02FFC:  MOVFF  03,6C6
03000:  MOVFF  02,6C5
03004:  MOVFF  01,6C4
03008:  MOVFF  00,6C3
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
0300C:  MOVLW  06
0300E:  MOVLB  6
03010:  MOVWF  xD1
03012:  MOVLW  BB
03014:  MOVFF  6D1,FEA
03018:  MOVWF  FE9
0301A:  MOVLW  7E
0301C:  SUBWF  FEF,W
0301E:  MOVWF  xCF
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
03020:  BTFSS  xCF.7
03022:  BRA    304E
....................          r = -(float32)-n;
03024:  MOVLW  00
03026:  BSF    FD8.0
03028:  SUBFWB xCF,W
0302A:  CLRF   xD2
0302C:  MOVWF  xD1
0302E:  BTFSC  xD1.7
03030:  DECF   xD2,F
03032:  MOVLB  0
03034:  CALL   27BC
03038:  MOVFF  00,6C7
0303C:  MOVF   01,W
0303E:  XORLW  80
03040:  MOVLB  6
03042:  MOVWF  xC8
03044:  MOVFF  02,6C9
03048:  MOVFF  03,6CA
0304C:  BRA    3070
....................       else
....................          r = (float32)n;
0304E:  CLRF   xD2
03050:  MOVFF  6CF,6D1
03054:  BTFSC  xD1.7
03056:  DECF   xD2,F
03058:  MOVLB  0
0305A:  CALL   27BC
0305E:  MOVFF  03,6CA
03062:  MOVFF  02,6C9
03066:  MOVFF  01,6C8
0306A:  MOVFF  00,6C7
0306E:  MOVLB  6
.................... 
....................       res += r*LN2;
03070:  MOVFF  6CA,6E3
03074:  MOVFF  6C9,6E2
03078:  MOVFF  6C8,6E1
0307C:  MOVFF  6C7,6E0
03080:  MOVLW  18
03082:  MOVWF  xE7
03084:  MOVLW  72
03086:  MOVWF  xE6
03088:  MOVLW  31
0308A:  MOVWF  xE5
0308C:  MOVLW  7E
0308E:  MOVWF  xE4
03090:  MOVLB  0
03092:  CALL   0E3A
03096:  BCF    FD8.1
03098:  MOVFF  6C6,6E2
0309C:  MOVFF  6C5,6E1
030A0:  MOVFF  6C4,6E0
030A4:  MOVFF  6C3,6DF
030A8:  MOVFF  03,6E6
030AC:  MOVFF  02,6E5
030B0:  MOVFF  01,6E4
030B4:  MOVFF  00,6E3
030B8:  CALL   0F30
030BC:  MOVFF  03,6C6
030C0:  MOVFF  02,6C5
030C4:  MOVFF  01,6C4
030C8:  MOVFF  00,6C3
....................    }
030CC:  BRA    30DA
.................... 
....................    else
....................       res = 0.0;
030CE:  MOVLB  6
030D0:  CLRF   xC6
030D2:  CLRF   xC5
030D4:  CLRF   xC4
030D6:  CLRF   xC3
030D8:  MOVLB  0
.................... 
....................    return(res);
030DA:  MOVFF  6C3,00
030DE:  MOVFF  6C4,01
030E2:  MOVFF  6C5,02
030E6:  MOVFF  6C6,03
030EA:  RETURN 0
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
*
034FA:  MOVFF  6B2,6DE
034FE:  MOVFF  6B1,6DD
03502:  MOVFF  6B0,6DC
03506:  MOVFF  6AF,6DB
0350A:  MOVLB  6
0350C:  CLRF   xE2
0350E:  CLRF   xE1
03510:  CLRF   xE0
03512:  CLRF   xDF
03514:  MOVLB  0
03516:  CALL   1E18
0351A:  BTFSS  FD8.0
0351C:  BRA    36B8
0351E:  MOVFF  6B6,6BA
03522:  MOVFF  6B5,6B9
03526:  MOVFF  6B4,6B8
0352A:  MOVFF  6B3,6B7
0352E:  MOVLB  6
03530:  CLRF   xBE
03532:  CLRF   xBD
03534:  CLRF   xBC
03536:  MOVLW  7F
03538:  MOVWF  xBB
0353A:  MOVLB  0
0353C:  CALL   2BF2
03540:  MOVFF  03,6BA
03544:  MOVFF  02,6B9
03548:  MOVFF  01,6B8
0354C:  MOVFF  00,6B7
03550:  MOVFF  03,6DE
03554:  MOVFF  02,6DD
03558:  MOVFF  01,6DC
0355C:  MOVFF  00,6DB
03560:  MOVLB  6
03562:  CLRF   xE2
03564:  CLRF   xE1
03566:  CLRF   xE0
03568:  CLRF   xDF
0356A:  MOVLB  0
0356C:  CALL   1E18
03570:  BTFSS  FD8.2
03572:  BRA    36B8
....................       if(fmod(y, 2) == 0) {
03574:  MOVFF  6B6,6BA
03578:  MOVFF  6B5,6B9
0357C:  MOVFF  6B4,6B8
03580:  MOVFF  6B3,6B7
03584:  MOVLB  6
03586:  CLRF   xBE
03588:  CLRF   xBD
0358A:  CLRF   xBC
0358C:  MOVLW  80
0358E:  MOVWF  xBB
03590:  MOVLB  0
03592:  CALL   2BF2
03596:  MOVFF  03,6BA
0359A:  MOVFF  02,6B9
0359E:  MOVFF  01,6B8
035A2:  MOVFF  00,6B7
035A6:  MOVFF  03,6DE
035AA:  MOVFF  02,6DD
035AE:  MOVFF  01,6DC
035B2:  MOVFF  00,6DB
035B6:  MOVLB  6
035B8:  CLRF   xE2
035BA:  CLRF   xE1
035BC:  CLRF   xE0
035BE:  CLRF   xDF
035C0:  MOVLB  0
035C2:  CALL   1E18
035C6:  BNZ   363E
....................          return (exp(log(-x) * y));
035C8:  MOVLB  6
035CA:  MOVF   xB0,W
035CC:  XORLW  80
035CE:  MOVWF  xB8
035D0:  MOVFF  6B2,6BE
035D4:  MOVFF  6B1,6BD
035D8:  MOVWF  xBC
035DA:  MOVFF  6AF,6BB
035DE:  MOVLB  0
035E0:  CALL   2D58
035E4:  MOVFF  03,6BA
035E8:  MOVFF  02,6B9
035EC:  MOVFF  01,6B8
035F0:  MOVFF  00,6B7
035F4:  MOVFF  03,6E3
035F8:  MOVFF  02,6E2
035FC:  MOVFF  01,6E1
03600:  MOVFF  00,6E0
03604:  MOVFF  6B6,6E7
03608:  MOVFF  6B5,6E6
0360C:  MOVFF  6B4,6E5
03610:  MOVFF  6B3,6E4
03614:  CALL   0E3A
03618:  MOVFF  03,6BA
0361C:  MOVFF  02,6B9
03620:  MOVFF  01,6B8
03624:  MOVFF  00,6B7
03628:  MOVFF  03,6BE
0362C:  MOVFF  02,6BD
03630:  MOVFF  01,6BC
03634:  MOVFF  00,6BB
03638:  RCALL  30EC
0363A:  BRA    37F6
....................       } else {
0363C:  BRA    36B6
....................          return (-exp(log(-x) * y));
0363E:  MOVLB  6
03640:  MOVF   xB0,W
03642:  XORLW  80
03644:  MOVWF  xB8
03646:  MOVFF  6B2,6BE
0364A:  MOVFF  6B1,6BD
0364E:  MOVWF  xBC
03650:  MOVFF  6AF,6BB
03654:  MOVLB  0
03656:  CALL   2D58
0365A:  MOVFF  03,6BA
0365E:  MOVFF  02,6B9
03662:  MOVFF  01,6B8
03666:  MOVFF  00,6B7
0366A:  MOVFF  03,6E3
0366E:  MOVFF  02,6E2
03672:  MOVFF  01,6E1
03676:  MOVFF  00,6E0
0367A:  MOVFF  6B6,6E7
0367E:  MOVFF  6B5,6E6
03682:  MOVFF  6B4,6E5
03686:  MOVFF  6B3,6E4
0368A:  CALL   0E3A
0368E:  MOVFF  03,6BA
03692:  MOVFF  02,6B9
03696:  MOVFF  01,6B8
0369A:  MOVFF  00,6B7
0369E:  MOVFF  03,6BE
036A2:  MOVFF  02,6BD
036A6:  MOVFF  01,6BC
036AA:  MOVFF  00,6BB
036AE:  RCALL  30EC
036B0:  MOVLW  80
036B2:  XORWF  01,F
036B4:  BRA    37F6
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
036B6:  BRA    37F6
036B8:  MOVFF  6B2,6DE
036BC:  MOVFF  6B1,6DD
036C0:  MOVFF  6B0,6DC
036C4:  MOVFF  6AF,6DB
036C8:  MOVLB  6
036CA:  CLRF   xE2
036CC:  CLRF   xE1
036CE:  CLRF   xE0
036D0:  CLRF   xDF
036D2:  MOVLB  0
036D4:  CALL   1E18
036D8:  BNC   373A
036DA:  MOVFF  6B6,6BA
036DE:  MOVFF  6B5,6B9
036E2:  MOVFF  6B4,6B8
036E6:  MOVFF  6B3,6B7
036EA:  MOVLB  6
036EC:  CLRF   xBE
036EE:  CLRF   xBD
036F0:  CLRF   xBC
036F2:  MOVLW  7F
036F4:  MOVWF  xBB
036F6:  MOVLB  0
036F8:  CALL   2BF2
036FC:  MOVFF  03,6BA
03700:  MOVFF  02,6B9
03704:  MOVFF  01,6B8
03708:  MOVFF  00,6B7
0370C:  MOVFF  03,6DE
03710:  MOVFF  02,6DD
03714:  MOVFF  01,6DC
03718:  MOVFF  00,6DB
0371C:  MOVLB  6
0371E:  CLRF   xE2
03720:  CLRF   xE1
03722:  CLRF   xE0
03724:  CLRF   xDF
03726:  MOVLB  0
03728:  CALL   1E18
0372C:  BZ    373A
....................       return 0;
0372E:  CLRF   00
03730:  CLRF   01
03732:  CLRF   02
03734:  CLRF   03
03736:  BRA    37F6
....................    } else {
03738:  BRA    37F6
....................       if(x != 0 || 0 >= y) {
0373A:  MOVFF  6B2,6DE
0373E:  MOVFF  6B1,6DD
03742:  MOVFF  6B0,6DC
03746:  MOVFF  6AF,6DB
0374A:  MOVLB  6
0374C:  CLRF   xE2
0374E:  CLRF   xE1
03750:  CLRF   xE0
03752:  CLRF   xDF
03754:  MOVLB  0
03756:  CALL   1E18
0375A:  BNZ   3780
0375C:  MOVFF  6B6,6DE
03760:  MOVFF  6B5,6DD
03764:  MOVFF  6B4,6DC
03768:  MOVFF  6B3,6DB
0376C:  MOVLB  6
0376E:  CLRF   xE2
03770:  CLRF   xE1
03772:  CLRF   xE0
03774:  CLRF   xDF
03776:  MOVLB  0
03778:  CALL   1E18
0377C:  BC    3780
0377E:  BNZ   37EE
....................          return (exp(log(x) * y));
03780:  MOVFF  6B2,6BE
03784:  MOVFF  6B1,6BD
03788:  MOVFF  6B0,6BC
0378C:  MOVFF  6AF,6BB
03790:  CALL   2D58
03794:  MOVFF  03,6BA
03798:  MOVFF  02,6B9
0379C:  MOVFF  01,6B8
037A0:  MOVFF  00,6B7
037A4:  MOVFF  03,6E3
037A8:  MOVFF  02,6E2
037AC:  MOVFF  01,6E1
037B0:  MOVFF  00,6E0
037B4:  MOVFF  6B6,6E7
037B8:  MOVFF  6B5,6E6
037BC:  MOVFF  6B4,6E5
037C0:  MOVFF  6B3,6E4
037C4:  CALL   0E3A
037C8:  MOVFF  03,6BA
037CC:  MOVFF  02,6B9
037D0:  MOVFF  01,6B8
037D4:  MOVFF  00,6B7
037D8:  MOVFF  03,6BE
037DC:  MOVFF  02,6BD
037E0:  MOVFF  01,6BC
037E4:  MOVFF  00,6BB
037E8:  RCALL  30EC
037EA:  BRA    37F6
....................       } else return 0;
037EC:  BRA    37F6
037EE:  CLRF   00
037F0:  CLRF   01
037F2:  CLRF   02
037F4:  CLRF   03
....................    }
037F6:  RETURN 0
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
*
01FF0:  MOVLB  6
01FF2:  BCF    xCD.0
....................    flag = 0;
01FF4:  BCF    xCD.1
....................    y = x;
01FF6:  MOVFF  6C0,6C4
01FFA:  MOVFF  6BF,6C3
01FFE:  MOVFF  6BE,6C2
02002:  MOVFF  6BD,6C1
.................... 
....................    if (x < 0)
02006:  MOVFF  6C0,6DE
0200A:  MOVFF  6BF,6DD
0200E:  MOVFF  6BE,6DC
02012:  MOVFF  6BD,6DB
02016:  CLRF   xE2
02018:  CLRF   xE1
0201A:  CLRF   xE0
0201C:  CLRF   xDF
0201E:  MOVLB  0
02020:  RCALL  1E18
02022:  BNC   2030
....................    {
....................       s = 1;
02024:  MOVLB  6
02026:  BSF    xCD.0
....................       y = -y;
02028:  MOVF   xC2,W
0202A:  XORLW  80
0202C:  MOVWF  xC2
0202E:  MOVLB  0
....................    }
.................... 
....................    if (y > 1.0)
02030:  MOVLB  6
02032:  CLRF   xDE
02034:  CLRF   xDD
02036:  CLRF   xDC
02038:  MOVLW  7F
0203A:  MOVWF  xDB
0203C:  MOVFF  6C4,6E2
02040:  MOVFF  6C3,6E1
02044:  MOVFF  6C2,6E0
02048:  MOVFF  6C1,6DF
0204C:  MOVLB  0
0204E:  RCALL  1E18
02050:  BNC   2088
....................    {
....................       y = 1.0/y;
02052:  MOVLB  6
02054:  CLRF   xD7
02056:  CLRF   xD6
02058:  CLRF   xD5
0205A:  MOVLW  7F
0205C:  MOVWF  xD4
0205E:  MOVFF  6C4,6DB
02062:  MOVFF  6C3,6DA
02066:  MOVFF  6C2,6D9
0206A:  MOVFF  6C1,6D8
0206E:  MOVLB  0
02070:  RCALL  1E92
02072:  MOVFF  03,6C4
02076:  MOVFF  02,6C3
0207A:  MOVFF  01,6C2
0207E:  MOVFF  00,6C1
....................       flag = 1;
02082:  MOVLB  6
02084:  BSF    xCD.1
02086:  MOVLB  0
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
02088:  MOVLW  0A
0208A:  MOVLB  6
0208C:  MOVWF  xE3
0208E:  MOVLW  89
02090:  MOVWF  xE2
02092:  MOVLW  34
02094:  MOVWF  xE1
02096:  MOVLW  7C
02098:  MOVWF  xE0
0209A:  MOVFF  6C4,6E7
0209E:  MOVFF  6C3,6E6
020A2:  MOVFF  6C2,6E5
020A6:  MOVFF  6C1,6E4
020AA:  MOVLB  0
020AC:  CALL   0E3A
020B0:  MOVFF  03,6D1
020B4:  MOVFF  02,6D0
020B8:  MOVFF  01,6CF
020BC:  MOVFF  00,6CE
020C0:  MOVFF  03,6E3
020C4:  MOVFF  02,6E2
020C8:  MOVFF  01,6E1
020CC:  MOVFF  00,6E0
020D0:  MOVFF  6C4,6E7
020D4:  MOVFF  6C3,6E6
020D8:  MOVFF  6C2,6E5
020DC:  MOVFF  6C1,6E4
020E0:  CALL   0E3A
020E4:  MOVFF  03,6D1
020E8:  MOVFF  02,6D0
020EC:  MOVFF  01,6CF
020F0:  MOVFF  00,6CE
020F4:  BCF    FD8.1
020F6:  MOVFF  03,6E2
020FA:  MOVFF  02,6E1
020FE:  MOVFF  01,6E0
02102:  MOVFF  00,6DF
02106:  MOVLW  7C
02108:  MOVLB  6
0210A:  MOVWF  xE6
0210C:  MOVLW  79
0210E:  MOVWF  xE5
02110:  MOVLW  35
02112:  MOVWF  xE4
02114:  MOVLW  81
02116:  MOVWF  xE3
02118:  MOVLB  0
0211A:  CALL   0F30
0211E:  MOVFF  03,6C8
02122:  MOVFF  02,6C7
02126:  MOVFF  01,6C6
0212A:  MOVFF  00,6C5
....................    res = res*y*y + pat[2];
0212E:  MOVFF  6C8,6E3
02132:  MOVFF  6C7,6E2
02136:  MOVFF  6C6,6E1
0213A:  MOVFF  6C5,6E0
0213E:  MOVFF  6C4,6E7
02142:  MOVFF  6C3,6E6
02146:  MOVFF  6C2,6E5
0214A:  MOVFF  6C1,6E4
0214E:  CALL   0E3A
02152:  MOVFF  03,6D1
02156:  MOVFF  02,6D0
0215A:  MOVFF  01,6CF
0215E:  MOVFF  00,6CE
02162:  MOVFF  03,6E3
02166:  MOVFF  02,6E2
0216A:  MOVFF  01,6E1
0216E:  MOVFF  00,6E0
02172:  MOVFF  6C4,6E7
02176:  MOVFF  6C3,6E6
0217A:  MOVFF  6C2,6E5
0217E:  MOVFF  6C1,6E4
02182:  CALL   0E3A
02186:  MOVFF  03,6D1
0218A:  MOVFF  02,6D0
0218E:  MOVFF  01,6CF
02192:  MOVFF  00,6CE
02196:  BCF    FD8.1
02198:  MOVFF  03,6E2
0219C:  MOVFF  02,6E1
021A0:  MOVFF  01,6E0
021A4:  MOVFF  00,6DF
021A8:  MOVLW  3F
021AA:  MOVLB  6
021AC:  MOVWF  xE6
021AE:  MOVLW  02
021B0:  MOVWF  xE5
021B2:  MOVLW  33
021B4:  MOVWF  xE4
021B6:  MOVLW  83
021B8:  MOVWF  xE3
021BA:  MOVLB  0
021BC:  CALL   0F30
021C0:  MOVFF  03,6C8
021C4:  MOVFF  02,6C7
021C8:  MOVFF  01,6C6
021CC:  MOVFF  00,6C5
....................    res = res*y*y + pat[3];
021D0:  MOVFF  6C8,6E3
021D4:  MOVFF  6C7,6E2
021D8:  MOVFF  6C6,6E1
021DC:  MOVFF  6C5,6E0
021E0:  MOVFF  6C4,6E7
021E4:  MOVFF  6C3,6E6
021E8:  MOVFF  6C2,6E5
021EC:  MOVFF  6C1,6E4
021F0:  CALL   0E3A
021F4:  MOVFF  03,6D1
021F8:  MOVFF  02,6D0
021FC:  MOVFF  01,6CF
02200:  MOVFF  00,6CE
02204:  MOVFF  03,6E3
02208:  MOVFF  02,6E2
0220C:  MOVFF  01,6E1
02210:  MOVFF  00,6E0
02214:  MOVFF  6C4,6E7
02218:  MOVFF  6C3,6E6
0221C:  MOVFF  6C2,6E5
02220:  MOVFF  6C1,6E4
02224:  CALL   0E3A
02228:  MOVFF  03,6D1
0222C:  MOVFF  02,6D0
02230:  MOVFF  01,6CF
02234:  MOVFF  00,6CE
02238:  BCF    FD8.1
0223A:  MOVFF  03,6E2
0223E:  MOVFF  02,6E1
02242:  MOVFF  01,6E0
02246:  MOVFF  00,6DF
0224A:  MOVLW  33
0224C:  MOVLB  6
0224E:  MOVWF  xE6
02250:  MOVLW  8C
02252:  MOVWF  xE5
02254:  MOVLW  1E
02256:  MOVWF  xE4
02258:  MOVLW  83
0225A:  MOVWF  xE3
0225C:  MOVLB  0
0225E:  CALL   0F30
02262:  MOVFF  03,6C8
02266:  MOVFF  02,6C7
0226A:  MOVFF  01,6C6
0226E:  MOVFF  00,6C5
.................... 
....................    r = qat[0]*y*y + qat[1];
02272:  MOVLB  6
02274:  CLRF   xE3
02276:  CLRF   xE2
02278:  CLRF   xE1
0227A:  MOVLW  7F
0227C:  MOVWF  xE0
0227E:  MOVFF  6C4,6E7
02282:  MOVFF  6C3,6E6
02286:  MOVFF  6C2,6E5
0228A:  MOVFF  6C1,6E4
0228E:  MOVLB  0
02290:  CALL   0E3A
02294:  MOVFF  03,6D1
02298:  MOVFF  02,6D0
0229C:  MOVFF  01,6CF
022A0:  MOVFF  00,6CE
022A4:  MOVFF  03,6E3
022A8:  MOVFF  02,6E2
022AC:  MOVFF  01,6E1
022B0:  MOVFF  00,6E0
022B4:  MOVFF  6C4,6E7
022B8:  MOVFF  6C3,6E6
022BC:  MOVFF  6C2,6E5
022C0:  MOVFF  6C1,6E4
022C4:  CALL   0E3A
022C8:  MOVFF  03,6D1
022CC:  MOVFF  02,6D0
022D0:  MOVFF  01,6CF
022D4:  MOVFF  00,6CE
022D8:  BCF    FD8.1
022DA:  MOVFF  03,6E2
022DE:  MOVFF  02,6E1
022E2:  MOVFF  01,6E0
022E6:  MOVFF  00,6DF
022EA:  MOVLW  1B
022EC:  MOVLB  6
022EE:  MOVWF  xE6
022F0:  MOVLW  E4
022F2:  MOVWF  xE5
022F4:  MOVLW  35
022F6:  MOVWF  xE4
022F8:  MOVLW  82
022FA:  MOVWF  xE3
022FC:  MOVLB  0
022FE:  CALL   0F30
02302:  MOVFF  03,6CC
02306:  MOVFF  02,6CB
0230A:  MOVFF  01,6CA
0230E:  MOVFF  00,6C9
....................    r = r*y*y + qat[2];
02312:  MOVFF  6CC,6E3
02316:  MOVFF  6CB,6E2
0231A:  MOVFF  6CA,6E1
0231E:  MOVFF  6C9,6E0
02322:  MOVFF  6C4,6E7
02326:  MOVFF  6C3,6E6
0232A:  MOVFF  6C2,6E5
0232E:  MOVFF  6C1,6E4
02332:  CALL   0E3A
02336:  MOVFF  03,6D1
0233A:  MOVFF  02,6D0
0233E:  MOVFF  01,6CF
02342:  MOVFF  00,6CE
02346:  MOVFF  03,6E3
0234A:  MOVFF  02,6E2
0234E:  MOVFF  01,6E1
02352:  MOVFF  00,6E0
02356:  MOVFF  6C4,6E7
0235A:  MOVFF  6C3,6E6
0235E:  MOVFF  6C2,6E5
02362:  MOVFF  6C1,6E4
02366:  CALL   0E3A
0236A:  MOVFF  03,6D1
0236E:  MOVFF  02,6D0
02372:  MOVFF  01,6CF
02376:  MOVFF  00,6CE
0237A:  BCF    FD8.1
0237C:  MOVFF  03,6E2
02380:  MOVFF  02,6E1
02384:  MOVFF  01,6E0
02388:  MOVFF  00,6DF
0238C:  MOVLW  A4
0238E:  MOVLB  6
02390:  MOVWF  xE6
02392:  MOVLW  DB
02394:  MOVWF  xE5
02396:  MOVLW  67
02398:  MOVWF  xE4
0239A:  MOVLW  83
0239C:  MOVWF  xE3
0239E:  MOVLB  0
023A0:  CALL   0F30
023A4:  MOVFF  03,6CC
023A8:  MOVFF  02,6CB
023AC:  MOVFF  01,6CA
023B0:  MOVFF  00,6C9
....................    r = r*y*y + qat[3];
023B4:  MOVFF  6CC,6E3
023B8:  MOVFF  6CB,6E2
023BC:  MOVFF  6CA,6E1
023C0:  MOVFF  6C9,6E0
023C4:  MOVFF  6C4,6E7
023C8:  MOVFF  6C3,6E6
023CC:  MOVFF  6C2,6E5
023D0:  MOVFF  6C1,6E4
023D4:  CALL   0E3A
023D8:  MOVFF  03,6D1
023DC:  MOVFF  02,6D0
023E0:  MOVFF  01,6CF
023E4:  MOVFF  00,6CE
023E8:  MOVFF  03,6E3
023EC:  MOVFF  02,6E2
023F0:  MOVFF  01,6E1
023F4:  MOVFF  00,6E0
023F8:  MOVFF  6C4,6E7
023FC:  MOVFF  6C3,6E6
02400:  MOVFF  6C2,6E5
02404:  MOVFF  6C1,6E4
02408:  CALL   0E3A
0240C:  MOVFF  03,6D1
02410:  MOVFF  02,6D0
02414:  MOVFF  01,6CF
02418:  MOVFF  00,6CE
0241C:  BCF    FD8.1
0241E:  MOVFF  03,6E2
02422:  MOVFF  02,6E1
02426:  MOVFF  01,6E0
0242A:  MOVFF  00,6DF
0242E:  MOVLW  33
02430:  MOVLB  6
02432:  MOVWF  xE6
02434:  MOVLW  8C
02436:  MOVWF  xE5
02438:  MOVLW  1E
0243A:  MOVWF  xE4
0243C:  MOVLW  83
0243E:  MOVWF  xE3
02440:  MOVLB  0
02442:  CALL   0F30
02446:  MOVFF  03,6CC
0244A:  MOVFF  02,6CB
0244E:  MOVFF  01,6CA
02452:  MOVFF  00,6C9
.................... 
....................    res = y*res/r;
02456:  MOVFF  6C4,6E3
0245A:  MOVFF  6C3,6E2
0245E:  MOVFF  6C2,6E1
02462:  MOVFF  6C1,6E0
02466:  MOVFF  6C8,6E7
0246A:  MOVFF  6C7,6E6
0246E:  MOVFF  6C6,6E5
02472:  MOVFF  6C5,6E4
02476:  CALL   0E3A
0247A:  MOVFF  03,6D1
0247E:  MOVFF  02,6D0
02482:  MOVFF  01,6CF
02486:  MOVFF  00,6CE
0248A:  MOVFF  03,6D7
0248E:  MOVFF  02,6D6
02492:  MOVFF  01,6D5
02496:  MOVFF  00,6D4
0249A:  MOVFF  6CC,6DB
0249E:  MOVFF  6CB,6DA
024A2:  MOVFF  6CA,6D9
024A6:  MOVFF  6C9,6D8
024AA:  RCALL  1E92
024AC:  MOVFF  03,6C8
024B0:  MOVFF  02,6C7
024B4:  MOVFF  01,6C6
024B8:  MOVFF  00,6C5
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
024BC:  MOVLB  6
024BE:  BTFSS  xCD.1
024C0:  BRA    24FC
....................       res = PI_DIV_BY_TWO - res;
024C2:  BSF    FD8.1
024C4:  MOVLW  DB
024C6:  MOVWF  xE2
024C8:  MOVLW  0F
024CA:  MOVWF  xE1
024CC:  MOVLW  49
024CE:  MOVWF  xE0
024D0:  MOVLW  7F
024D2:  MOVWF  xDF
024D4:  MOVFF  6C8,6E6
024D8:  MOVFF  6C7,6E5
024DC:  MOVFF  6C6,6E4
024E0:  MOVFF  6C5,6E3
024E4:  MOVLB  0
024E6:  CALL   0F30
024EA:  MOVFF  03,6C8
024EE:  MOVFF  02,6C7
024F2:  MOVFF  01,6C6
024F6:  MOVFF  00,6C5
024FA:  MOVLB  6
....................    if (s)
024FC:  BTFSS  xCD.0
024FE:  BRA    2506
....................       res = -res;
02500:  MOVF   xC6,W
02502:  XORLW  80
02504:  MOVWF  xC6
.................... 
....................    return(res);
02506:  MOVFF  6C5,00
0250A:  MOVFF  6C6,01
0250E:  MOVFF  6C7,02
02512:  MOVFF  6C8,03
02516:  MOVLB  0
02518:  RETURN 0
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
0251A:  MOVLB  6
0251C:  BCF    xBB.0
....................    quad=0; //quadrant
0251E:  CLRF   xBC
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
02520:  MOVFF  6B2,6DE
02524:  MOVFF  6B1,6DD
02528:  MOVFF  6B0,6DC
0252C:  MOVFF  6AF,6DB
02530:  CLRF   xE2
02532:  CLRF   xE1
02534:  CLRF   xE0
02536:  CLRF   xDF
02538:  MOVLB  0
0253A:  RCALL  1E18
0253C:  BC    2540
0253E:  BNZ   256A
02540:  MOVFF  6B6,6DE
02544:  MOVFF  6B5,6DD
02548:  MOVFF  6B4,6DC
0254C:  MOVFF  6B3,6DB
02550:  MOVLB  6
02552:  CLRF   xE2
02554:  CLRF   xE1
02556:  CLRF   xE0
02558:  CLRF   xDF
0255A:  MOVLB  0
0255C:  RCALL  1E18
0255E:  BC    2562
02560:  BNZ   2566
02562:  MOVLW  03
02564:  BRA    2568
02566:  MOVLW  04
02568:  BRA    2590
0256A:  MOVFF  6B6,6DE
0256E:  MOVFF  6B5,6DD
02572:  MOVFF  6B4,6DC
02576:  MOVFF  6B3,6DB
0257A:  MOVLB  6
0257C:  CLRF   xE2
0257E:  CLRF   xE1
02580:  CLRF   xE0
02582:  CLRF   xDF
02584:  MOVLB  0
02586:  RCALL  1E18
02588:  BNC   258E
0258A:  MOVLW  02
0258C:  BRA    2590
0258E:  MOVLW  01
02590:  MOVLB  6
02592:  MOVWF  xBC
....................    if(y<0.0)
02594:  MOVFF  6B2,6DE
02598:  MOVFF  6B1,6DD
0259C:  MOVFF  6B0,6DC
025A0:  MOVFF  6AF,6DB
025A4:  CLRF   xE2
025A6:  CLRF   xE1
025A8:  CLRF   xE0
025AA:  CLRF   xDF
025AC:  MOVLB  0
025AE:  RCALL  1E18
025B0:  BNC   25BE
....................    {
....................       sign=1;
025B2:  MOVLB  6
025B4:  BSF    xBB.0
....................       y=-y;
025B6:  MOVF   xB0,W
025B8:  XORLW  80
025BA:  MOVWF  xB0
025BC:  MOVLB  0
....................    }
....................    if(x<0.0)
025BE:  MOVFF  6B6,6DE
025C2:  MOVFF  6B5,6DD
025C6:  MOVFF  6B4,6DC
025CA:  MOVFF  6B3,6DB
025CE:  MOVLB  6
025D0:  CLRF   xE2
025D2:  CLRF   xE1
025D4:  CLRF   xE0
025D6:  CLRF   xDF
025D8:  MOVLB  0
025DA:  RCALL  1E18
025DC:  BNC   25E8
....................    {
....................       x=-x;
025DE:  MOVLB  6
025E0:  MOVF   xB4,W
025E2:  XORLW  80
025E4:  MOVWF  xB4
025E6:  MOVLB  0
....................    }
....................    if (x==0.0)
025E8:  MOVFF  6B6,6DE
025EC:  MOVFF  6B5,6DD
025F0:  MOVFF  6B4,6DC
025F4:  MOVFF  6B3,6DB
025F8:  MOVLB  6
025FA:  CLRF   xE2
025FC:  CLRF   xE1
025FE:  CLRF   xE0
02600:  CLRF   xDF
02602:  MOVLB  0
02604:  RCALL  1E18
02606:  BNZ   265C
....................    {
....................       if(y==0.0)
02608:  MOVFF  6B2,6DE
0260C:  MOVFF  6B1,6DD
02610:  MOVFF  6B0,6DC
02614:  MOVFF  6AF,6DB
02618:  MOVLB  6
0261A:  CLRF   xE2
0261C:  CLRF   xE1
0261E:  CLRF   xE0
02620:  CLRF   xDF
02622:  MOVLB  0
02624:  CALL   1E18
02628:  BNZ   262C
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
0262A:  BRA    265A
....................       else
....................       {
....................          if(sign)
0262C:  MOVLB  6
0262E:  BTFSS  xBB.0
02630:  BRA    2646
....................          {
....................          return (-(PI_DIV_BY_TWO));
02632:  MOVLW  7F
02634:  MOVWF  00
02636:  MOVLW  C9
02638:  MOVWF  01
0263A:  MOVLW  0F
0263C:  MOVWF  02
0263E:  MOVLW  DB
02640:  MOVWF  03
02642:  BRA    2794
....................          }
02644:  BRA    2658
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
02646:  MOVLW  7F
02648:  MOVWF  00
0264A:  MOVLW  49
0264C:  MOVWF  01
0264E:  MOVLW  0F
02650:  MOVWF  02
02652:  MOVLW  DB
02654:  MOVWF  03
02656:  BRA    2794
02658:  MOVLB  0
....................          }
....................       }
....................    }
0265A:  BRA    2792
....................    else
....................    {
....................       z=y/x;
0265C:  MOVFF  6B2,6D7
02660:  MOVFF  6B1,6D6
02664:  MOVFF  6B0,6D5
02668:  MOVFF  6AF,6D4
0266C:  MOVFF  6B6,6DB
02670:  MOVFF  6B5,6DA
02674:  MOVFF  6B4,6D9
02678:  MOVFF  6B3,6D8
0267C:  RCALL  1E92
0267E:  MOVFF  03,6BA
02682:  MOVFF  02,6B9
02686:  MOVFF  01,6B8
0268A:  MOVFF  00,6B7
....................       switch(quad)
0268E:  MOVLW  01
02690:  MOVLB  6
02692:  SUBWF  xBC,W
02694:  ADDLW  FC
02696:  BTFSC  FD8.0
02698:  BRA    2794
0269A:  ADDLW  04
0269C:  MOVLB  0
0269E:  GOTO   279A
....................       {
....................          case 1:
....................          {
....................             return atan(z);
026A2:  MOVFF  6BA,6C0
026A6:  MOVFF  6B9,6BF
026AA:  MOVFF  6B8,6BE
026AE:  MOVFF  6B7,6BD
026B2:  RCALL  1FF0
026B4:  MOVLB  6
026B6:  BRA    2794
....................             break;
026B8:  BRA    2794
026BA:  MOVLB  0
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
026BC:  MOVFF  6BA,6C0
026C0:  MOVFF  6B9,6BF
026C4:  MOVFF  6B8,6BE
026C8:  MOVFF  6B7,6BD
026CC:  RCALL  1FF0
026CE:  MOVFF  FEA,6BE
026D2:  MOVFF  FE9,6BD
026D6:  BSF    FD8.1
026D8:  MOVLW  DB
026DA:  MOVLB  6
026DC:  MOVWF  xE2
026DE:  MOVLW  0F
026E0:  MOVWF  xE1
026E2:  MOVLW  49
026E4:  MOVWF  xE0
026E6:  MOVLW  80
026E8:  MOVWF  xDF
026EA:  MOVFF  03,6E6
026EE:  MOVFF  02,6E5
026F2:  MOVFF  01,6E4
026F6:  MOVFF  00,6E3
026FA:  MOVLB  0
026FC:  CALL   0F30
02700:  MOVFF  6BE,FEA
02704:  MOVFF  6BD,FE9
02708:  MOVLB  6
0270A:  BRA    2794
....................             break;
0270C:  BRA    2794
0270E:  MOVLB  0
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
02710:  MOVFF  6BA,6C0
02714:  MOVFF  6B9,6BF
02718:  MOVFF  6B8,6BE
0271C:  MOVFF  6B7,6BD
02720:  RCALL  1FF0
02722:  MOVFF  03,6C0
02726:  MOVFF  02,6BF
0272A:  MOVFF  01,6BE
0272E:  MOVFF  00,6BD
02732:  MOVFF  FEA,6C2
02736:  MOVFF  FE9,6C1
0273A:  BSF    FD8.1
0273C:  MOVFF  03,6E2
02740:  MOVFF  02,6E1
02744:  MOVFF  01,6E0
02748:  MOVFF  00,6DF
0274C:  MOVLW  DB
0274E:  MOVLB  6
02750:  MOVWF  xE6
02752:  MOVLW  0F
02754:  MOVWF  xE5
02756:  MOVLW  49
02758:  MOVWF  xE4
0275A:  MOVLW  80
0275C:  MOVWF  xE3
0275E:  MOVLB  0
02760:  CALL   0F30
02764:  MOVFF  6C2,FEA
02768:  MOVFF  6C1,FE9
0276C:  MOVLB  6
0276E:  BRA    2794
....................             break;
02770:  BRA    2794
02772:  MOVLB  0
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
02774:  MOVFF  6BA,6C0
02778:  MOVFF  6B9,6BF
0277C:  MOVFF  6B8,6BE
02780:  MOVFF  6B7,6BD
02784:  RCALL  1FF0
02786:  MOVLW  80
02788:  XORWF  01,F
0278A:  MOVLB  6
0278C:  BRA    2794
....................             break;
0278E:  BRA    2794
02790:  MOVLB  0
02792:  MOVLB  6
....................          }
....................       }
....................    }
02794:  MOVLB  0
02796:  GOTO   3EA0 (RETURN)
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... #define sensorSampleRate 50 // 50mS delay between each sensor sample = 200ms cadence 
.................... 
.................... #define maxCount 16777216.0   // ADC max count
.................... #define vRef 2.048            // ADC vRef
.................... 
.................... #define sc sensorCal
.................... 
.................... #define vMonN15   6
.................... #define vMon200   16
.................... #define vMon5V6   24
.................... #define vMon5VA   25
.................... #define vMon3V6X  17
.................... #define vMon3V3A  27
.................... #define vMon3V3D  26
.................... 
.................... #define BUFFER_SIZE 8
.................... typedef struct {
....................    signed int8 in;
.................... //!   signed int8 out;
....................    signed int32 buff[BUFFER_SIZE];
.................... } buffer;
.................... 
.................... buffer sinQ_x;
.................... buffer cosQ_x;
.................... buffer sinQ_y;
.................... buffer cosQ_y;
.................... 
.................... //!#define incin(buff) ((buff->in==(BUFFER_SIZE-1))?0:buff->in+1)
.................... //!#define incout(buff) ((buff->out==(BUFFER_SIZE-1))?0:buff->out+1)
.................... //!#define isempty(buff) (buff->in==buff->out)
.................... //!#define hasdata(buff) (buff->in!=buff->out)
.................... //!#define isfull(buff) (incin(buff)==buff->out)
.................... //!
.................... //!#define tobuff(bname,c) { bname->buff[bname->in]=c;\
.................... //!   bname->in=incin(bname);\
.................... //!   if (bname->in==bname->out) bname->out=incout(bname);\
.................... //!   }
.................... //!#define frombuff(bname) (btemp##bname=bname->buff[bname->out],\
.................... //!   bname->out=incout(bname), \
.................... //!   btemp##bname)
.................... //!#define clrbuff(buff) buff->in=buff->out=0
.................... 
.................... //!#define COMPARE(a,b) (((a) > (b)) - ((a) < (b)))
.................... 
.................... struct sensorMonitorData
.................... {
....................    boolean dataReady;
....................    boolean adcBusy;
....................    buffer* sinQ;
....................    buffer* cosQ;
....................    signed int32 avgSin;
....................    signed int32 avgCos;
.................... } smData[2] = 
.................... {
....................    {false, false, &sinQ_x, &cosQ_x, 0, 0},
....................    {false, false, &sinQ_y, &cosQ_y, 0, 0}
.................... };
.................... 
.................... signed int compar(void *a, void *b) {
....................     if ((* (signed int32 *)a) < (* (signed int32 *)b)) return -1;
*
01726:  MOVFF  68C,03
0172A:  MOVFF  68B,FE9
0172E:  MOVFF  03,FEA
01732:  MOVFF  FEF,70C
01736:  MOVFF  FEC,70D
0173A:  MOVFF  FEC,70E
0173E:  MOVFF  FEC,70F
01742:  MOVFF  68E,03
01746:  MOVFF  68D,FE9
0174A:  MOVFF  03,FEA
0174E:  MOVFF  FEF,00
01752:  MOVFF  FEC,01
01756:  MOVFF  FEC,02
0175A:  MOVFF  FEC,03
0175E:  MOVLB  7
01760:  BTFSS  x0F.7
01762:  BRA    176A
01764:  BTFSS  03.7
01766:  BRA    178C
01768:  BRA    176E
0176A:  BTFSC  03.7
0176C:  BRA    1794
0176E:  MOVF   x0F,W
01770:  SUBWF  03,W
01772:  BNC   1794
01774:  BNZ   178C
01776:  MOVF   x0E,W
01778:  SUBWF  02,W
0177A:  BNC   1794
0177C:  BNZ   178C
0177E:  MOVF   x0D,W
01780:  SUBWF  01,W
01782:  BNC   1794
01784:  BNZ   178C
01786:  MOVF   00,W
01788:  SUBWF  x0C,W
0178A:  BC    1794
0178C:  MOVLW  FF
0178E:  MOVWF  01
01790:  BRA    17F2
01792:  BRA    17F2
....................     else if ((* (signed int32 *)a) == (* (signed int32 *)b)) return 0;
01794:  MOVFF  68C,03
01798:  MOVFF  68B,FE9
0179C:  MOVFF  03,FEA
017A0:  MOVFF  FEF,70C
017A4:  MOVFF  FEC,70D
017A8:  MOVFF  FEC,70E
017AC:  MOVFF  FEC,70F
017B0:  MOVFF  68E,03
017B4:  MOVFF  68D,FE9
017B8:  MOVFF  03,FEA
017BC:  MOVFF  FEF,00
017C0:  MOVFF  FEC,01
017C4:  MOVFF  FEC,02
017C8:  MOVFF  FEC,03
017CC:  MOVF   00,W
017CE:  MOVLB  7
017D0:  SUBWF  x0C,W
017D2:  BNZ   17EE
017D4:  MOVF   01,W
017D6:  SUBWF  x0D,W
017D8:  BNZ   17EE
017DA:  MOVF   02,W
017DC:  SUBWF  x0E,W
017DE:  BNZ   17EE
017E0:  MOVF   03,W
017E2:  SUBWF  x0F,W
017E4:  BNZ   17EE
017E6:  MOVLW  00
017E8:  MOVWF  01
017EA:  BRA    17F2
017EC:  BRA    17F2
....................     else return 1;
017EE:  MOVLW  01
017F0:  MOVWF  01
017F2:  MOVLB  0
017F4:  RETURN 0
.................... }
.................... 
.................... void push(buffer* q, signed int32 newData) {
....................    q->buff[q->in]=newData;
*
0090A:  MOVLB  6
0090C:  MOVFF  6ED,FE9
00910:  MOVFF  6EE,FEA
00914:  CLRF   xF4
00916:  MOVFF  FEF,6F3
0091A:  BTFSC  xF3.7
0091C:  DECF   xF4,F
0091E:  MOVFF  6F4,6F8
00922:  MOVFF  6F3,6F7
00926:  CLRF   xFA
00928:  MOVLW  04
0092A:  MOVWF  xF9
0092C:  MOVLB  0
0092E:  RCALL  0868
00930:  MOVFF  02,03
00934:  MOVF   01,W
00936:  ADDLW  01
00938:  MOVWF  01
0093A:  MOVLW  00
0093C:  ADDWFC 03,F
0093E:  MOVF   01,W
00940:  MOVLB  6
00942:  ADDWF  xED,W
00944:  MOVWF  FE9
00946:  MOVF   xEE,W
00948:  ADDWFC 03,W
0094A:  MOVWF  FEA
0094C:  MOVFF  6EF,FEF
00950:  MOVFF  6F0,FEC
00954:  MOVFF  6F1,FEC
00958:  MOVFF  6F2,FEC
....................    q->in=(q->in+1) % BUFFER_SIZE;
0095C:  MOVFF  6ED,6F3
00960:  MOVFF  6EE,6F4
00964:  MOVFF  6ED,FE9
00968:  MOVFF  6EE,FEA
0096C:  MOVLW  01
0096E:  ADDWF  FEF,W
00970:  MOVWF  xF6
00972:  MOVWF  xF7
00974:  MOVLW  08
00976:  MOVWF  xF8
00978:  MOVLB  0
0097A:  BRA    08BC
0097C:  MOVLB  6
0097E:  MOVFF  6F4,FEA
00982:  MOVFF  6F3,FE9
00986:  MOVFF  00,FEF
0098A:  MOVLB  0
0098C:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INTERNAL MONITOR task - gets voltages                                     */
.................... /* gets one value each time the task is run                                  */
.................... /*****************************************************************************/
.................... void internal_monitor_task()
.................... {
....................    static int8 state = 0;
....................    if (adc_done())
*
011A8:  MOVLB  F
011AA:  BTFSC  x5B.0
011AC:  BRA    16F8
....................    {
....................       switch (state)
011AE:  MOVLB  2
011B0:  MOVF   x03,W
011B2:  ADDLW  F9
011B4:  BTFSC  FD8.0
011B6:  BRA    16F6
011B8:  ADDLW  07
011BA:  MOVLB  0
011BC:  GOTO   16FE
....................       {
....................          case 0:     // vMonN15
....................             monitorVals.vN15 = read_adc(ADC_READ_ONLY) * monCal.vN15[1] + monCal.vN15[0];
011C0:  MOVLB  F
011C2:  BTFSC  x5B.0
011C4:  BRA    11C2
011C6:  MOVFF  F5F,02
011CA:  MOVFF  F5E,01
011CE:  MOVFF  02,691
011D2:  MOVFF  01,690
011D6:  MOVFF  02,6E0
011DA:  MOVFF  01,6DF
011DE:  MOVLB  0
011E0:  RCALL  0E04
011E2:  MOVFF  03,6E3
011E6:  MOVFF  02,6E2
011EA:  MOVFF  01,6E1
011EE:  MOVFF  00,6E0
011F2:  MOVFF  B9,6E7
011F6:  MOVFF  B8,6E6
011FA:  MOVFF  B7,6E5
011FE:  MOVFF  B6,6E4
01202:  RCALL  0E3A
01204:  MOVFF  03,693
01208:  MOVFF  02,692
0120C:  MOVFF  01,691
01210:  MOVFF  00,690
01214:  BCF    FD8.1
01216:  MOVFF  03,6E2
0121A:  MOVFF  02,6E1
0121E:  MOVFF  01,6E0
01222:  MOVFF  00,6DF
01226:  MOVFF  B5,6E6
0122A:  MOVFF  B4,6E5
0122E:  MOVFF  B3,6E4
01232:  MOVFF  B2,6E3
01236:  RCALL  0F30
01238:  MOVFF  03,F6
0123C:  MOVFF  02,F5
01240:  MOVFF  01,F4
01244:  MOVFF  00,F3
....................             set_adc_channel(vMon200);
01248:  MOVLB  F
0124A:  MOVF   x5A,W
0124C:  ANDLW  3F
0124E:  MOVWF  01
01250:  MOVLW  10
01252:  MOVWF  x5A
01254:  BTFSS  x5B.7
01256:  BRA    1266
01258:  MOVF   01,W
0125A:  SUBLW  10
0125C:  BZ    1266
0125E:  BSF    x5B.0
01260:  NOP   
01262:  BTFSC  x5B.0
01264:  BRA    1262
....................             delay_ms(10);
01266:  MOVLW  0A
01268:  MOVLB  6
0126A:  MOVWF  x98
0126C:  MOVLB  0
0126E:  CALL   0438
....................             read_adc(ADC_START_ONLY);
01272:  MOVLB  F
01274:  BSF    x5B.0
01276:  NOP   
....................             state = 1;
01278:  MOVLW  01
0127A:  MOVLB  2
0127C:  MOVWF  x03
....................          break;
0127E:  BRA    16F6
....................          
....................          case 1:     // vMon200
....................             monitorVals.v200 = read_adc(ADC_READ_ONLY) * monCal.v200[1] + monCal.v200[0];
01280:  MOVLB  F
01282:  BTFSC  x5B.0
01284:  BRA    1282
01286:  MOVFF  F5F,02
0128A:  MOVFF  F5E,01
0128E:  MOVFF  02,691
01292:  MOVFF  01,690
01296:  MOVFF  02,6E0
0129A:  MOVFF  01,6DF
0129E:  MOVLB  0
012A0:  RCALL  0E04
012A2:  MOVFF  03,6E3
012A6:  MOVFF  02,6E2
012AA:  MOVFF  01,6E1
012AE:  MOVFF  00,6E0
012B2:  MOVFF  C1,6E7
012B6:  MOVFF  C0,6E6
012BA:  MOVFF  BF,6E5
012BE:  MOVFF  BE,6E4
012C2:  RCALL  0E3A
012C4:  MOVFF  03,693
012C8:  MOVFF  02,692
012CC:  MOVFF  01,691
012D0:  MOVFF  00,690
012D4:  BCF    FD8.1
012D6:  MOVFF  03,6E2
012DA:  MOVFF  02,6E1
012DE:  MOVFF  01,6E0
012E2:  MOVFF  00,6DF
012E6:  MOVFF  BD,6E6
012EA:  MOVFF  BC,6E5
012EE:  MOVFF  BB,6E4
012F2:  MOVFF  BA,6E3
012F6:  RCALL  0F30
012F8:  MOVFF  03,FA
012FC:  MOVFF  02,F9
01300:  MOVFF  01,F8
01304:  MOVFF  00,F7
....................             set_adc_channel(vMon5V6);
01308:  MOVLB  F
0130A:  MOVF   x5A,W
0130C:  ANDLW  3F
0130E:  MOVWF  01
01310:  MOVLW  18
01312:  MOVWF  x5A
01314:  BTFSS  x5B.7
01316:  BRA    1326
01318:  MOVF   01,W
0131A:  SUBLW  18
0131C:  BZ    1326
0131E:  BSF    x5B.0
01320:  NOP   
01322:  BTFSC  x5B.0
01324:  BRA    1322
....................             delay_ms(10);
01326:  MOVLW  0A
01328:  MOVLB  6
0132A:  MOVWF  x98
0132C:  MOVLB  0
0132E:  CALL   0438
....................             read_adc(ADC_START_ONLY);
01332:  MOVLB  F
01334:  BSF    x5B.0
01336:  NOP   
....................             state = 2;
01338:  MOVLW  02
0133A:  MOVLB  2
0133C:  MOVWF  x03
....................          break;
0133E:  BRA    16F6
....................          
....................          case 2:     // vMon5V6
....................             monitorVals.v5V6 = read_adc(ADC_READ_ONLY) * monCal.v5V6[1] + monCal.v5V6[0];
01340:  MOVLB  F
01342:  BTFSC  x5B.0
01344:  BRA    1342
01346:  MOVFF  F5F,02
0134A:  MOVFF  F5E,01
0134E:  MOVFF  02,691
01352:  MOVFF  01,690
01356:  MOVFF  02,6E0
0135A:  MOVFF  01,6DF
0135E:  MOVLB  0
01360:  RCALL  0E04
01362:  MOVFF  03,6E3
01366:  MOVFF  02,6E2
0136A:  MOVFF  01,6E1
0136E:  MOVFF  00,6E0
01372:  MOVFF  C9,6E7
01376:  MOVFF  C8,6E6
0137A:  MOVFF  C7,6E5
0137E:  MOVFF  C6,6E4
01382:  RCALL  0E3A
01384:  MOVFF  03,693
01388:  MOVFF  02,692
0138C:  MOVFF  01,691
01390:  MOVFF  00,690
01394:  BCF    FD8.1
01396:  MOVFF  03,6E2
0139A:  MOVFF  02,6E1
0139E:  MOVFF  01,6E0
013A2:  MOVFF  00,6DF
013A6:  MOVFF  C5,6E6
013AA:  MOVFF  C4,6E5
013AE:  MOVFF  C3,6E4
013B2:  MOVFF  C2,6E3
013B6:  RCALL  0F30
013B8:  MOVFF  03,FE
013BC:  MOVFF  02,FD
013C0:  MOVFF  01,FC
013C4:  MOVFF  00,FB
....................             set_adc_channel(vMon5VA);
013C8:  MOVLB  F
013CA:  MOVF   x5A,W
013CC:  ANDLW  3F
013CE:  MOVWF  01
013D0:  MOVLW  19
013D2:  MOVWF  x5A
013D4:  BTFSS  x5B.7
013D6:  BRA    13E6
013D8:  MOVF   01,W
013DA:  SUBLW  19
013DC:  BZ    13E6
013DE:  BSF    x5B.0
013E0:  NOP   
013E2:  BTFSC  x5B.0
013E4:  BRA    13E2
....................             delay_ms(10);
013E6:  MOVLW  0A
013E8:  MOVLB  6
013EA:  MOVWF  x98
013EC:  MOVLB  0
013EE:  CALL   0438
....................             read_adc(ADC_START_ONLY);
013F2:  MOVLB  F
013F4:  BSF    x5B.0
013F6:  NOP   
....................             state = 3;
013F8:  MOVLW  03
013FA:  MOVLB  2
013FC:  MOVWF  x03
....................          break;
013FE:  BRA    16F6
....................          
....................          case 3:     // vMon5VA
....................             monitorVals.v5VA = read_adc(ADC_READ_ONLY) * monCal.v5VA[1] + monCal.v5VA[0];
01400:  MOVLB  F
01402:  BTFSC  x5B.0
01404:  BRA    1402
01406:  MOVFF  F5F,02
0140A:  MOVFF  F5E,01
0140E:  MOVFF  02,691
01412:  MOVFF  01,690
01416:  MOVFF  02,6E0
0141A:  MOVFF  01,6DF
0141E:  MOVLB  0
01420:  RCALL  0E04
01422:  MOVFF  03,6E3
01426:  MOVFF  02,6E2
0142A:  MOVFF  01,6E1
0142E:  MOVFF  00,6E0
01432:  MOVFF  D1,6E7
01436:  MOVFF  D0,6E6
0143A:  MOVFF  CF,6E5
0143E:  MOVFF  CE,6E4
01442:  RCALL  0E3A
01444:  MOVFF  03,693
01448:  MOVFF  02,692
0144C:  MOVFF  01,691
01450:  MOVFF  00,690
01454:  BCF    FD8.1
01456:  MOVFF  03,6E2
0145A:  MOVFF  02,6E1
0145E:  MOVFF  01,6E0
01462:  MOVFF  00,6DF
01466:  MOVFF  CD,6E6
0146A:  MOVFF  CC,6E5
0146E:  MOVFF  CB,6E4
01472:  MOVFF  CA,6E3
01476:  RCALL  0F30
01478:  MOVFF  03,102
0147C:  MOVFF  02,101
01480:  MOVFF  01,100
01484:  MOVFF  00,FF
....................             set_adc_channel(vMon3V6X);
01488:  MOVLB  F
0148A:  MOVF   x5A,W
0148C:  ANDLW  3F
0148E:  MOVWF  01
01490:  MOVLW  11
01492:  MOVWF  x5A
01494:  BTFSS  x5B.7
01496:  BRA    14A6
01498:  MOVF   01,W
0149A:  SUBLW  11
0149C:  BZ    14A6
0149E:  BSF    x5B.0
014A0:  NOP   
014A2:  BTFSC  x5B.0
014A4:  BRA    14A2
....................             delay_ms(10);
014A6:  MOVLW  0A
014A8:  MOVLB  6
014AA:  MOVWF  x98
014AC:  MOVLB  0
014AE:  CALL   0438
....................             read_adc(ADC_START_ONLY);
014B2:  MOVLB  F
014B4:  BSF    x5B.0
014B6:  NOP   
....................             state = 4;
014B8:  MOVLW  04
014BA:  MOVLB  2
014BC:  MOVWF  x03
....................          break;
014BE:  BRA    16F6
....................          
....................          case 4:     // vMon3V6X
....................             monitorVals.v3V6X = read_adc(ADC_READ_ONLY) * monCal.v3V6X[1] + monCal.v3V6X[0];
014C0:  MOVLB  F
014C2:  BTFSC  x5B.0
014C4:  BRA    14C2
014C6:  MOVFF  F5F,02
014CA:  MOVFF  F5E,01
014CE:  MOVFF  02,691
014D2:  MOVFF  01,690
014D6:  MOVFF  02,6E0
014DA:  MOVFF  01,6DF
014DE:  MOVLB  0
014E0:  RCALL  0E04
014E2:  MOVFF  03,6E3
014E6:  MOVFF  02,6E2
014EA:  MOVFF  01,6E1
014EE:  MOVFF  00,6E0
014F2:  MOVFF  D9,6E7
014F6:  MOVFF  D8,6E6
014FA:  MOVFF  D7,6E5
014FE:  MOVFF  D6,6E4
01502:  RCALL  0E3A
01504:  MOVFF  03,693
01508:  MOVFF  02,692
0150C:  MOVFF  01,691
01510:  MOVFF  00,690
01514:  BCF    FD8.1
01516:  MOVFF  03,6E2
0151A:  MOVFF  02,6E1
0151E:  MOVFF  01,6E0
01522:  MOVFF  00,6DF
01526:  MOVFF  D5,6E6
0152A:  MOVFF  D4,6E5
0152E:  MOVFF  D3,6E4
01532:  MOVFF  D2,6E3
01536:  RCALL  0F30
01538:  MOVFF  03,106
0153C:  MOVFF  02,105
01540:  MOVFF  01,104
01544:  MOVFF  00,103
....................             set_adc_channel(vMon3V3A);
01548:  MOVLB  F
0154A:  MOVF   x5A,W
0154C:  ANDLW  3F
0154E:  MOVWF  01
01550:  MOVLW  1B
01552:  MOVWF  x5A
01554:  BTFSS  x5B.7
01556:  BRA    1566
01558:  MOVF   01,W
0155A:  SUBLW  1B
0155C:  BZ    1566
0155E:  BSF    x5B.0
01560:  NOP   
01562:  BTFSC  x5B.0
01564:  BRA    1562
....................             delay_ms(10);
01566:  MOVLW  0A
01568:  MOVLB  6
0156A:  MOVWF  x98
0156C:  MOVLB  0
0156E:  CALL   0438
....................             read_adc(ADC_START_ONLY);
01572:  MOVLB  F
01574:  BSF    x5B.0
01576:  NOP   
....................             state = 5;
01578:  MOVLW  05
0157A:  MOVLB  2
0157C:  MOVWF  x03
....................          break;
0157E:  BRA    16F6
....................          
....................          case 5:     // vMon3V3A
....................             monitorVals.v3V3A = read_adc(ADC_READ_ONLY) * monCal.v3V3A[1] + monCal.v3V3A[0];
01580:  MOVLB  F
01582:  BTFSC  x5B.0
01584:  BRA    1582
01586:  MOVFF  F5F,02
0158A:  MOVFF  F5E,01
0158E:  MOVFF  02,691
01592:  MOVFF  01,690
01596:  MOVFF  02,6E0
0159A:  MOVFF  01,6DF
0159E:  MOVLB  0
015A0:  RCALL  0E04
015A2:  MOVFF  03,6E3
015A6:  MOVFF  02,6E2
015AA:  MOVFF  01,6E1
015AE:  MOVFF  00,6E0
015B2:  MOVFF  E1,6E7
015B6:  MOVFF  E0,6E6
015BA:  MOVFF  DF,6E5
015BE:  MOVFF  DE,6E4
015C2:  RCALL  0E3A
015C4:  MOVFF  03,693
015C8:  MOVFF  02,692
015CC:  MOVFF  01,691
015D0:  MOVFF  00,690
015D4:  BCF    FD8.1
015D6:  MOVFF  03,6E2
015DA:  MOVFF  02,6E1
015DE:  MOVFF  01,6E0
015E2:  MOVFF  00,6DF
015E6:  MOVFF  DD,6E6
015EA:  MOVFF  DC,6E5
015EE:  MOVFF  DB,6E4
015F2:  MOVFF  DA,6E3
015F6:  RCALL  0F30
015F8:  MOVFF  03,10A
015FC:  MOVFF  02,109
01600:  MOVFF  01,108
01604:  MOVFF  00,107
....................             set_adc_channel(vMon3V3D);
01608:  MOVLB  F
0160A:  MOVF   x5A,W
0160C:  ANDLW  3F
0160E:  MOVWF  01
01610:  MOVLW  1A
01612:  MOVWF  x5A
01614:  BTFSS  x5B.7
01616:  BRA    1626
01618:  MOVF   01,W
0161A:  SUBLW  1A
0161C:  BZ    1626
0161E:  BSF    x5B.0
01620:  NOP   
01622:  BTFSC  x5B.0
01624:  BRA    1622
....................             delay_ms(10);
01626:  MOVLW  0A
01628:  MOVLB  6
0162A:  MOVWF  x98
0162C:  MOVLB  0
0162E:  CALL   0438
....................             read_adc(ADC_START_ONLY);
01632:  MOVLB  F
01634:  BSF    x5B.0
01636:  NOP   
....................             state = 6;
01638:  MOVLW  06
0163A:  MOVLB  2
0163C:  MOVWF  x03
....................          break;
0163E:  BRA    16F6
....................          
....................          case 6:    // vMon3V3D
....................             monitorVals.v3V3D = read_adc(ADC_READ_ONLY) * monCal.v3V3D[1] + monCal.v3V3D[0];
01640:  MOVLB  F
01642:  BTFSC  x5B.0
01644:  BRA    1642
01646:  MOVFF  F5F,02
0164A:  MOVFF  F5E,01
0164E:  MOVFF  02,691
01652:  MOVFF  01,690
01656:  MOVFF  02,6E0
0165A:  MOVFF  01,6DF
0165E:  MOVLB  0
01660:  CALL   0E04
01664:  MOVFF  03,6E3
01668:  MOVFF  02,6E2
0166C:  MOVFF  01,6E1
01670:  MOVFF  00,6E0
01674:  MOVFF  E9,6E7
01678:  MOVFF  E8,6E6
0167C:  MOVFF  E7,6E5
01680:  MOVFF  E6,6E4
01684:  CALL   0E3A
01688:  MOVFF  03,693
0168C:  MOVFF  02,692
01690:  MOVFF  01,691
01694:  MOVFF  00,690
01698:  BCF    FD8.1
0169A:  MOVFF  03,6E2
0169E:  MOVFF  02,6E1
016A2:  MOVFF  01,6E0
016A6:  MOVFF  00,6DF
016AA:  MOVFF  E5,6E6
016AE:  MOVFF  E4,6E5
016B2:  MOVFF  E3,6E4
016B6:  MOVFF  E2,6E3
016BA:  RCALL  0F30
016BC:  MOVFF  03,10E
016C0:  MOVFF  02,10D
016C4:  MOVFF  01,10C
016C8:  MOVFF  00,10B
....................             set_adc_channel(vMonN15);
016CC:  MOVLB  F
016CE:  MOVF   x5A,W
016D0:  ANDLW  3F
016D2:  MOVWF  01
016D4:  MOVLW  06
016D6:  MOVWF  x5A
016D8:  BTFSS  x5B.7
016DA:  BRA    16EA
016DC:  MOVF   01,W
016DE:  SUBLW  06
016E0:  BZ    16EA
016E2:  BSF    x5B.0
016E4:  NOP   
016E6:  BTFSC  x5B.0
016E8:  BRA    16E6
....................             read_adc(ADC_START_ONLY);
016EA:  BSF    x5B.0
016EC:  NOP   
....................             state = 0;
016EE:  MOVLB  2
016F0:  CLRF   x03
....................          break;   
016F2:  BRA    16F6
016F4:  MOVLB  2
016F6:  MOVLB  F
....................       }
....................    }
016F8:  MOVLB  0
016FA:  GOTO   A66C (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* PROCESS ADC SENSOR DATA                                                   */
.................... /*****************************************************************************/
.................... void sensor_process_data(int8 ch)//, signed int32 sinRawCounts, signed int32 cosRawCounts)
.................... {
....................    adcVals[ch].sinLast = adcVals[ch].sinCounts;
*
037F8:  MOVLB  6
037FA:  MOVF   x98,W
037FC:  MULLW  21
037FE:  MOVF   FF3,W
03800:  CLRF   xA2
03802:  MOVWF  xA1
03804:  MOVLW  10
03806:  ADDWF  xA1,W
03808:  MOVWF  01
0380A:  MOVLW  00
0380C:  ADDWFC xA2,W
0380E:  MOVWF  03
03810:  MOVF   01,W
03812:  ADDLW  0F
03814:  MOVWF  01
03816:  MOVLW  01
03818:  ADDWFC 03,F
0381A:  MOVFF  01,6A1
0381E:  MOVFF  03,6A2
03822:  MOVF   x98,W
03824:  MULLW  21
03826:  MOVF   FF3,W
03828:  CLRF   xA4
0382A:  MOVWF  xA3
0382C:  MOVLW  08
0382E:  ADDWF  xA3,W
03830:  MOVWF  01
03832:  MOVLW  00
03834:  ADDWFC xA4,W
03836:  MOVWF  03
03838:  MOVF   01,W
0383A:  ADDLW  0F
0383C:  MOVWF  FE9
0383E:  MOVLW  01
03840:  ADDWFC 03,W
03842:  MOVWF  FEA
03844:  MOVFF  FEF,00
03848:  MOVFF  FEC,01
0384C:  MOVFF  FEC,02
03850:  MOVFF  FEC,03
03854:  MOVFF  6A2,FEA
03858:  MOVFF  6A1,FE9
0385C:  MOVFF  00,FEF
03860:  MOVFF  01,FEC
03864:  MOVFF  02,FEC
03868:  MOVFF  03,FEC
....................    adcVals[ch].cosLast = adcVals[ch].cosCounts;
0386C:  MOVF   x98,W
0386E:  MULLW  21
03870:  MOVF   FF3,W
03872:  CLRF   xA2
03874:  MOVWF  xA1
03876:  MOVLW  14
03878:  ADDWF  xA1,W
0387A:  MOVWF  01
0387C:  MOVLW  00
0387E:  ADDWFC xA2,W
03880:  MOVWF  03
03882:  MOVF   01,W
03884:  ADDLW  0F
03886:  MOVWF  01
03888:  MOVLW  01
0388A:  ADDWFC 03,F
0388C:  MOVFF  01,6A1
03890:  MOVFF  03,6A2
03894:  MOVF   x98,W
03896:  MULLW  21
03898:  MOVF   FF3,W
0389A:  CLRF   xA4
0389C:  MOVWF  xA3
0389E:  MOVLW  0C
038A0:  ADDWF  xA3,W
038A2:  MOVWF  01
038A4:  MOVLW  00
038A6:  ADDWFC xA4,W
038A8:  MOVWF  03
038AA:  MOVF   01,W
038AC:  ADDLW  0F
038AE:  MOVWF  FE9
038B0:  MOVLW  01
038B2:  ADDWFC 03,W
038B4:  MOVWF  FEA
038B6:  MOVFF  FEF,00
038BA:  MOVFF  FEC,01
038BE:  MOVFF  FEC,02
038C2:  MOVFF  FEC,03
038C6:  MOVFF  6A2,FEA
038CA:  MOVFF  6A1,FE9
038CE:  MOVFF  00,FEF
038D2:  MOVFF  01,FEC
038D6:  MOVFF  02,FEC
038DA:  MOVFF  03,FEC
....................    
....................    adcVals[ch].sinRaw = (float)smData[ch].avgSin;
038DE:  MOVF   x98,W
038E0:  MULLW  21
038E2:  MOVF   FF3,W
038E4:  CLRF   xA2
038E6:  MOVWF  xA1
038E8:  MOVLW  0F
038EA:  ADDWF  xA1,W
038EC:  MOVWF  01
038EE:  MOVLW  01
038F0:  ADDWFC xA2,W
038F2:  MOVWF  03
038F4:  MOVFF  01,6A3
038F8:  MOVWF  xA4
038FA:  MOVF   x98,W
038FC:  MULLW  0D
038FE:  MOVF   FF3,W
03900:  CLRF   xA6
03902:  MOVWF  xA5
03904:  MOVLW  05
03906:  ADDWF  xA5,W
03908:  MOVWF  01
0390A:  MOVLW  00
0390C:  ADDWFC xA6,W
0390E:  MOVWF  03
03910:  MOVF   01,W
03912:  ADDLW  E9
03914:  MOVWF  FE9
03916:  MOVLW  01
03918:  ADDWFC 03,W
0391A:  MOVWF  FEA
0391C:  MOVFF  FEF,6A5
03920:  MOVFF  FEC,01
03924:  MOVFF  FEC,02
03928:  MOVFF  FEC,03
0392C:  MOVFF  03,6A8
03930:  MOVFF  02,6A7
03934:  MOVFF  01,6A6
03938:  MOVLB  0
0393A:  CALL   1DBE
0393E:  MOVFF  6A4,FEA
03942:  MOVFF  6A3,FE9
03946:  MOVFF  00,FEF
0394A:  MOVFF  01,FEC
0394E:  MOVFF  02,FEC
03952:  MOVFF  03,FEC
....................    adcVals[ch].cosRaw = (float)smData[ch].avgCos;
03956:  MOVLB  6
03958:  MOVF   x98,W
0395A:  MULLW  21
0395C:  MOVF   FF3,W
0395E:  CLRF   xA2
03960:  MOVWF  xA1
03962:  MOVLW  04
03964:  ADDWF  xA1,W
03966:  MOVWF  01
03968:  MOVLW  00
0396A:  ADDWFC xA2,W
0396C:  MOVWF  03
0396E:  MOVF   01,W
03970:  ADDLW  0F
03972:  MOVWF  01
03974:  MOVLW  01
03976:  ADDWFC 03,F
03978:  MOVFF  01,6A1
0397C:  MOVFF  03,6A2
03980:  MOVF   x98,W
03982:  MULLW  0D
03984:  MOVF   FF3,W
03986:  CLRF   xA4
03988:  MOVWF  xA3
0398A:  MOVLW  09
0398C:  ADDWF  xA3,W
0398E:  MOVWF  01
03990:  MOVLW  00
03992:  ADDWFC xA4,W
03994:  MOVWF  03
03996:  MOVF   01,W
03998:  ADDLW  E9
0399A:  MOVWF  FE9
0399C:  MOVLW  01
0399E:  ADDWFC 03,W
039A0:  MOVWF  FEA
039A2:  MOVFF  FEF,6A5
039A6:  MOVFF  FEC,01
039AA:  MOVFF  FEC,02
039AE:  MOVFF  FEC,03
039B2:  MOVFF  03,6A8
039B6:  MOVFF  02,6A7
039BA:  MOVFF  01,6A6
039BE:  MOVLB  0
039C0:  CALL   1DBE
039C4:  MOVFF  6A2,FEA
039C8:  MOVFF  6A1,FE9
039CC:  MOVFF  00,FEF
039D0:  MOVFF  01,FEC
039D4:  MOVFF  02,FEC
039D8:  MOVFF  03,FEC
....................    
....................    adcVals[ch].sinCounts = adcVals[ch].sinRaw * adcCal[ch].sinGain + adcCal[ch].sinOS;
039DC:  MOVLB  6
039DE:  MOVF   x98,W
039E0:  MULLW  21
039E2:  MOVF   FF3,W
039E4:  CLRF   xA2
039E6:  MOVWF  xA1
039E8:  MOVLW  08
039EA:  ADDWF  xA1,W
039EC:  MOVWF  01
039EE:  MOVLW  00
039F0:  ADDWFC xA2,W
039F2:  MOVWF  03
039F4:  MOVF   01,W
039F6:  ADDLW  0F
039F8:  MOVWF  01
039FA:  MOVLW  01
039FC:  ADDWFC 03,F
039FE:  MOVFF  01,6A1
03A02:  MOVFF  03,6A2
03A06:  MOVF   x98,W
03A08:  MULLW  21
03A0A:  MOVF   FF3,W
03A0C:  CLRF   xA4
03A0E:  MOVWF  xA3
03A10:  MOVLW  0F
03A12:  ADDWF  xA3,W
03A14:  MOVWF  FE9
03A16:  MOVLW  01
03A18:  ADDWFC xA4,W
03A1A:  MOVWF  FEA
03A1C:  MOVFF  FEF,6E0
03A20:  MOVFF  FEC,6E1
03A24:  MOVFF  FEC,6E2
03A28:  MOVFF  FEC,6E3
03A2C:  MOVF   x98,W
03A2E:  MULLW  10
03A30:  MOVF   FF3,W
03A32:  CLRF   xAA
03A34:  MOVWF  xA9
03A36:  MOVLW  08
03A38:  ADDWF  xA9,W
03A3A:  MOVWF  01
03A3C:  MOVLW  00
03A3E:  ADDWFC xAA,W
03A40:  MOVWF  03
03A42:  MOVF   01,W
03A44:  ADDLW  62
03A46:  MOVWF  FE9
03A48:  MOVLW  00
03A4A:  ADDWFC 03,W
03A4C:  MOVWF  FEA
03A4E:  MOVFF  FEF,6E4
03A52:  MOVFF  FEC,01
03A56:  MOVFF  FEC,02
03A5A:  MOVFF  FEC,03
03A5E:  MOVFF  03,6E7
03A62:  MOVFF  02,6E6
03A66:  MOVFF  01,6E5
03A6A:  MOVLB  0
03A6C:  CALL   0E3A
03A70:  MOVFF  03,6E2
03A74:  MOVFF  02,6E1
03A78:  MOVFF  01,6E0
03A7C:  MOVFF  00,6DF
03A80:  MOVLB  6
03A82:  MOVF   x98,W
03A84:  MULLW  10
03A86:  MOVF   FF3,W
03A88:  CLRF   xAA
03A8A:  MOVWF  xA9
03A8C:  MOVLW  62
03A8E:  ADDWF  xA9,W
03A90:  MOVWF  FE9
03A92:  MOVLW  00
03A94:  ADDWFC xAA,W
03A96:  MOVWF  FEA
03A98:  MOVFF  FEF,6E3
03A9C:  MOVFF  FEC,01
03AA0:  MOVFF  FEC,02
03AA4:  MOVFF  FEC,03
03AA8:  BCF    FD8.1
03AAA:  MOVFF  03,6E6
03AAE:  MOVFF  02,6E5
03AB2:  MOVFF  01,6E4
03AB6:  MOVLB  0
03AB8:  CALL   0F30
03ABC:  MOVFF  6A2,FEA
03AC0:  MOVFF  6A1,FE9
03AC4:  MOVFF  00,FEF
03AC8:  MOVFF  01,FEC
03ACC:  MOVFF  02,FEC
03AD0:  MOVFF  03,FEC
....................    adcVals[ch].cosCounts = adcVals[ch].cosRaw * adcCal[ch].cosGain + adcCal[ch].cosOS;
03AD4:  MOVLB  6
03AD6:  MOVF   x98,W
03AD8:  MULLW  21
03ADA:  MOVF   FF3,W
03ADC:  CLRF   xA2
03ADE:  MOVWF  xA1
03AE0:  MOVLW  0C
03AE2:  ADDWF  xA1,W
03AE4:  MOVWF  01
03AE6:  MOVLW  00
03AE8:  ADDWFC xA2,W
03AEA:  MOVWF  03
03AEC:  MOVF   01,W
03AEE:  ADDLW  0F
03AF0:  MOVWF  01
03AF2:  MOVLW  01
03AF4:  ADDWFC 03,F
03AF6:  MOVFF  01,6A1
03AFA:  MOVFF  03,6A2
03AFE:  MOVF   x98,W
03B00:  MULLW  21
03B02:  MOVF   FF3,W
03B04:  CLRF   xA4
03B06:  MOVWF  xA3
03B08:  MOVLW  04
03B0A:  ADDWF  xA3,W
03B0C:  MOVWF  01
03B0E:  MOVLW  00
03B10:  ADDWFC xA4,W
03B12:  MOVWF  03
03B14:  MOVF   01,W
03B16:  ADDLW  0F
03B18:  MOVWF  FE9
03B1A:  MOVLW  01
03B1C:  ADDWFC 03,W
03B1E:  MOVWF  FEA
03B20:  MOVFF  FEF,6E0
03B24:  MOVFF  FEC,6E1
03B28:  MOVFF  FEC,6E2
03B2C:  MOVFF  FEC,6E3
03B30:  MOVF   x98,W
03B32:  MULLW  10
03B34:  MOVF   FF3,W
03B36:  CLRF   xA8
03B38:  MOVWF  xA7
03B3A:  MOVLW  0C
03B3C:  ADDWF  xA7,W
03B3E:  MOVWF  01
03B40:  MOVLW  00
03B42:  ADDWFC xA8,W
03B44:  MOVWF  03
03B46:  MOVF   01,W
03B48:  ADDLW  62
03B4A:  MOVWF  FE9
03B4C:  MOVLW  00
03B4E:  ADDWFC 03,W
03B50:  MOVWF  FEA
03B52:  MOVFF  FEF,6E4
03B56:  MOVFF  FEC,01
03B5A:  MOVFF  FEC,02
03B5E:  MOVFF  FEC,03
03B62:  MOVFF  03,6E7
03B66:  MOVFF  02,6E6
03B6A:  MOVFF  01,6E5
03B6E:  MOVLB  0
03B70:  CALL   0E3A
03B74:  MOVFF  03,6E2
03B78:  MOVFF  02,6E1
03B7C:  MOVFF  01,6E0
03B80:  MOVFF  00,6DF
03B84:  MOVLB  6
03B86:  MOVF   x98,W
03B88:  MULLW  10
03B8A:  MOVF   FF3,W
03B8C:  CLRF   xA8
03B8E:  MOVWF  xA7
03B90:  MOVLW  04
03B92:  ADDWF  xA7,W
03B94:  MOVWF  01
03B96:  MOVLW  00
03B98:  ADDWFC xA8,W
03B9A:  MOVWF  03
03B9C:  MOVF   01,W
03B9E:  ADDLW  62
03BA0:  MOVWF  FE9
03BA2:  MOVLW  00
03BA4:  ADDWFC 03,W
03BA6:  MOVWF  FEA
03BA8:  MOVFF  FEF,6E3
03BAC:  MOVFF  FEC,01
03BB0:  MOVFF  FEC,02
03BB4:  MOVFF  FEC,03
03BB8:  BCF    FD8.1
03BBA:  MOVFF  03,6E6
03BBE:  MOVFF  02,6E5
03BC2:  MOVFF  01,6E4
03BC6:  MOVLB  0
03BC8:  CALL   0F30
03BCC:  MOVFF  6A2,FEA
03BD0:  MOVFF  6A1,FE9
03BD4:  MOVFF  00,FEF
03BD8:  MOVFF  01,FEC
03BDC:  MOVFF  02,FEC
03BE0:  MOVFF  03,FEC
....................    float pTmp = 0;
....................    float polePitch = magPP;
03BE4:  MOVLB  6
03BE6:  CLRF   x9C
03BE8:  CLRF   x9B
03BEA:  CLRF   x9A
03BEC:  CLRF   x99
03BEE:  CLRF   xA0
03BF0:  CLRF   x9F
03BF2:  CLRF   x9E
03BF4:  MOVLW  7F
03BF6:  MOVWF  x9D
....................    
....................    if (adcVals[ch].cosCounts < 0){
03BF8:  MOVF   x98,W
03BFA:  MULLW  21
03BFC:  MOVF   FF3,W
03BFE:  CLRF   xA2
03C00:  MOVWF  xA1
03C02:  MOVLW  0C
03C04:  ADDWF  xA1,W
03C06:  MOVWF  01
03C08:  MOVLW  00
03C0A:  ADDWFC xA2,W
03C0C:  MOVWF  03
03C0E:  MOVF   01,W
03C10:  ADDLW  0F
03C12:  MOVWF  FE9
03C14:  MOVLW  01
03C16:  ADDWFC 03,W
03C18:  MOVWF  FEA
03C1A:  MOVFF  FEF,6DB
03C1E:  MOVFF  FEC,6DC
03C22:  MOVFF  FEC,6DD
03C26:  MOVFF  FEC,6DE
03C2A:  CLRF   xE2
03C2C:  CLRF   xE1
03C2E:  CLRF   xE0
03C30:  CLRF   xDF
03C32:  MOVLB  0
03C34:  CALL   1E18
03C38:  BTFSS  FD8.0
03C3A:  BRA    3DA4
....................       if ((adcVals[ch].sinCounts > 0) && (adcVals[ch].sinLast < 0)){
03C3C:  MOVLB  6
03C3E:  MOVF   x98,W
03C40:  MULLW  21
03C42:  MOVF   FF3,W
03C44:  CLRF   xA2
03C46:  MOVWF  xA1
03C48:  MOVLW  08
03C4A:  ADDWF  xA1,W
03C4C:  MOVWF  01
03C4E:  MOVLW  00
03C50:  ADDWFC xA2,W
03C52:  MOVWF  03
03C54:  MOVF   01,W
03C56:  ADDLW  0F
03C58:  MOVWF  FE9
03C5A:  MOVLW  01
03C5C:  ADDWFC 03,W
03C5E:  MOVWF  FEA
03C60:  MOVFF  FEF,6DF
03C64:  MOVFF  FEC,6A2
03C68:  MOVFF  FEC,6E1
03C6C:  MOVFF  FEC,6E2
03C70:  CLRF   xDE
03C72:  CLRF   xDD
03C74:  CLRF   xDC
03C76:  CLRF   xDB
03C78:  MOVFF  6A2,6E0
03C7C:  MOVLB  0
03C7E:  CALL   1E18
03C82:  BNC   3CF0
03C84:  MOVLB  6
03C86:  MOVF   x98,W
03C88:  MULLW  21
03C8A:  MOVF   FF3,W
03C8C:  CLRF   xA2
03C8E:  MOVWF  xA1
03C90:  MOVLW  10
03C92:  ADDWF  xA1,W
03C94:  MOVWF  01
03C96:  MOVLW  00
03C98:  ADDWFC xA2,W
03C9A:  MOVWF  03
03C9C:  MOVF   01,W
03C9E:  ADDLW  0F
03CA0:  MOVWF  FE9
03CA2:  MOVLW  01
03CA4:  ADDWFC 03,W
03CA6:  MOVWF  FEA
03CA8:  MOVFF  FEF,6DB
03CAC:  MOVFF  FEC,6DC
03CB0:  MOVFF  FEC,6DD
03CB4:  MOVFF  FEC,6DE
03CB8:  CLRF   xE2
03CBA:  CLRF   xE1
03CBC:  CLRF   xE0
03CBE:  CLRF   xDF
03CC0:  MOVLB  0
03CC2:  CALL   1E18
03CC6:  BNC   3CF0
....................          adcVals[ch].npoles--;
03CC8:  MOVLB  6
03CCA:  MOVF   x98,W
03CCC:  MULLW  21
03CCE:  MOVF   FF3,W
03CD0:  CLRF   xA2
03CD2:  MOVWF  xA1
03CD4:  MOVLW  1C
03CD6:  ADDWF  xA1,W
03CD8:  MOVWF  01
03CDA:  MOVLW  00
03CDC:  ADDWFC xA2,W
03CDE:  MOVWF  03
03CE0:  MOVF   01,W
03CE2:  ADDLW  0F
03CE4:  MOVWF  FE9
03CE6:  MOVLW  01
03CE8:  ADDWFC 03,W
03CEA:  MOVWF  FEA
03CEC:  DECF   FEF,F
....................       }
03CEE:  BRA    3DA2
....................       else if ((adcVals[ch].sinCounts < 0) && (adcVals[ch].sinLast > 0)){
03CF0:  MOVLB  6
03CF2:  MOVF   x98,W
03CF4:  MULLW  21
03CF6:  MOVF   FF3,W
03CF8:  CLRF   xA2
03CFA:  MOVWF  xA1
03CFC:  MOVLW  08
03CFE:  ADDWF  xA1,W
03D00:  MOVWF  01
03D02:  MOVLW  00
03D04:  ADDWFC xA2,W
03D06:  MOVWF  03
03D08:  MOVF   01,W
03D0A:  ADDLW  0F
03D0C:  MOVWF  FE9
03D0E:  MOVLW  01
03D10:  ADDWFC 03,W
03D12:  MOVWF  FEA
03D14:  MOVFF  FEF,6DB
03D18:  MOVFF  FEC,6A2
03D1C:  MOVFF  FEC,6DD
03D20:  MOVFF  FEC,6DE
03D24:  MOVFF  6A2,6DC
03D28:  CLRF   xE2
03D2A:  CLRF   xE1
03D2C:  CLRF   xE0
03D2E:  CLRF   xDF
03D30:  MOVLB  0
03D32:  CALL   1E18
03D36:  BNC   3DA4
03D38:  MOVLB  6
03D3A:  MOVF   x98,W
03D3C:  MULLW  21
03D3E:  MOVF   FF3,W
03D40:  CLRF   xA2
03D42:  MOVWF  xA1
03D44:  MOVLW  10
03D46:  ADDWF  xA1,W
03D48:  MOVWF  01
03D4A:  MOVLW  00
03D4C:  ADDWFC xA2,W
03D4E:  MOVWF  03
03D50:  MOVF   01,W
03D52:  ADDLW  0F
03D54:  MOVWF  FE9
03D56:  MOVLW  01
03D58:  ADDWFC 03,W
03D5A:  MOVWF  FEA
03D5C:  MOVFF  FEF,6DF
03D60:  MOVFF  FEC,6E0
03D64:  MOVFF  FEC,6E1
03D68:  MOVFF  FEC,6E2
03D6C:  CLRF   xDE
03D6E:  CLRF   xDD
03D70:  CLRF   xDC
03D72:  CLRF   xDB
03D74:  MOVLB  0
03D76:  CALL   1E18
03D7A:  BNC   3DA4
....................          adcVals[ch].npoles++;
03D7C:  MOVLB  6
03D7E:  MOVF   x98,W
03D80:  MULLW  21
03D82:  MOVF   FF3,W
03D84:  CLRF   xA2
03D86:  MOVWF  xA1
03D88:  MOVLW  1C
03D8A:  ADDWF  xA1,W
03D8C:  MOVWF  01
03D8E:  MOVLW  00
03D90:  ADDWFC xA2,W
03D92:  MOVWF  03
03D94:  MOVF   01,W
03D96:  ADDLW  0F
03D98:  MOVWF  FE9
03D9A:  MOVLW  01
03D9C:  ADDWFC 03,W
03D9E:  MOVWF  FEA
03DA0:  INCF   FEF,F
03DA2:  MOVLB  0
....................       }
....................    }
....................    
....................    adcVals[ch].p0 = polePitch * ( 1000 / (2*PI) ) * atan2( (float)adcVals[ch].sinCounts, (float)adcVals[ch].cosCounts );
03DA4:  MOVLB  6
03DA6:  MOVF   x98,W
03DA8:  MULLW  21
03DAA:  MOVF   FF3,W
03DAC:  CLRF   xA2
03DAE:  MOVWF  xA1
03DB0:  MOVLW  18
03DB2:  ADDWF  xA1,W
03DB4:  MOVWF  01
03DB6:  MOVLW  00
03DB8:  ADDWFC xA2,W
03DBA:  MOVWF  03
03DBC:  MOVF   01,W
03DBE:  ADDLW  0F
03DC0:  MOVWF  01
03DC2:  MOVLW  01
03DC4:  ADDWFC 03,F
03DC6:  MOVFF  01,6A1
03DCA:  MOVFF  03,6A2
03DCE:  MOVFF  6A0,6E3
03DD2:  MOVFF  69F,6E2
03DD6:  MOVFF  69E,6E1
03DDA:  MOVFF  69D,6E0
03DDE:  MOVLW  AA
03DE0:  MOVWF  xE7
03DE2:  MOVLW  27
03DE4:  MOVWF  xE6
03DE6:  MOVLW  1F
03DE8:  MOVWF  xE5
03DEA:  MOVLW  86
03DEC:  MOVWF  xE4
03DEE:  MOVLB  0
03DF0:  CALL   0E3A
03DF4:  MOVFF  03,6A6
03DF8:  MOVFF  02,6A5
03DFC:  MOVFF  01,6A4
03E00:  MOVFF  00,6A3
03E04:  MOVLB  6
03E06:  MOVF   x98,W
03E08:  MULLW  21
03E0A:  MOVF   FF3,W
03E0C:  CLRF   xA8
03E0E:  MOVWF  xA7
03E10:  MOVLW  08
03E12:  ADDWF  xA7,W
03E14:  MOVWF  01
03E16:  MOVLW  00
03E18:  ADDWFC xA8,W
03E1A:  MOVWF  03
03E1C:  MOVF   01,W
03E1E:  ADDLW  0F
03E20:  MOVWF  FE9
03E22:  MOVLW  01
03E24:  ADDWFC 03,W
03E26:  MOVWF  FEA
03E28:  MOVFF  FEF,6A7
03E2C:  MOVFF  FEC,6A8
03E30:  MOVFF  FEC,6A9
03E34:  MOVFF  FEC,6AA
03E38:  MOVF   x98,W
03E3A:  MULLW  21
03E3C:  MOVF   FF3,W
03E3E:  CLRF   xAC
03E40:  MOVWF  xAB
03E42:  MOVLW  0C
03E44:  ADDWF  xAB,W
03E46:  MOVWF  01
03E48:  MOVLW  00
03E4A:  ADDWFC xAC,W
03E4C:  MOVWF  03
03E4E:  MOVF   01,W
03E50:  ADDLW  0F
03E52:  MOVWF  FE9
03E54:  MOVLW  01
03E56:  ADDWFC 03,W
03E58:  MOVWF  FEA
03E5A:  MOVFF  FEF,00
03E5E:  MOVFF  FEC,01
03E62:  MOVFF  FEC,02
03E66:  MOVFF  FEC,03
03E6A:  MOVFF  03,6AE
03E6E:  MOVFF  02,6AD
03E72:  MOVFF  01,6AC
03E76:  MOVFF  00,6AB
03E7A:  MOVFF  6AA,6B2
03E7E:  MOVFF  6A9,6B1
03E82:  MOVFF  6A8,6B0
03E86:  MOVFF  6A7,6AF
03E8A:  MOVFF  03,6B6
03E8E:  MOVFF  02,6B5
03E92:  MOVFF  01,6B4
03E96:  MOVFF  00,6B3
03E9A:  MOVLB  0
03E9C:  GOTO   251A
03EA0:  MOVFF  6A6,6E3
03EA4:  MOVFF  6A5,6E2
03EA8:  MOVFF  6A4,6E1
03EAC:  MOVFF  6A3,6E0
03EB0:  MOVFF  03,6E7
03EB4:  MOVFF  02,6E6
03EB8:  MOVFF  01,6E5
03EBC:  MOVFF  00,6E4
03EC0:  CALL   0E3A
03EC4:  MOVFF  6A2,FEA
03EC8:  MOVFF  6A1,FE9
03ECC:  MOVFF  00,FEF
03ED0:  MOVFF  01,FEC
03ED4:  MOVFF  02,FEC
03ED8:  MOVFF  03,FEC
....................    pTmp = adcVals[ch].p0 + ( 1000 * polePitch * (float)adcVals[ch].npoles );
03EDC:  MOVLB  6
03EDE:  MOVF   x98,W
03EE0:  MULLW  21
03EE2:  MOVF   FF3,W
03EE4:  CLRF   xA2
03EE6:  MOVWF  xA1
03EE8:  MOVLW  18
03EEA:  ADDWF  xA1,W
03EEC:  MOVWF  01
03EEE:  MOVLW  00
03EF0:  ADDWFC xA2,W
03EF2:  MOVWF  03
03EF4:  MOVF   01,W
03EF6:  ADDLW  0F
03EF8:  MOVWF  FE9
03EFA:  MOVLW  01
03EFC:  ADDWFC 03,W
03EFE:  MOVWF  FEA
03F00:  MOVFF  FEF,6A1
03F04:  MOVFF  FEC,6A2
03F08:  MOVFF  FEC,6A3
03F0C:  MOVFF  FEC,6A4
03F10:  CLRF   xE3
03F12:  CLRF   xE2
03F14:  MOVLW  7A
03F16:  MOVWF  xE1
03F18:  MOVLW  88
03F1A:  MOVWF  xE0
03F1C:  MOVFF  6A0,6E7
03F20:  MOVFF  69F,6E6
03F24:  MOVFF  69E,6E5
03F28:  MOVFF  69D,6E4
03F2C:  MOVLB  0
03F2E:  CALL   0E3A
03F32:  MOVFF  03,6A8
03F36:  MOVFF  02,6A7
03F3A:  MOVFF  01,6A6
03F3E:  MOVFF  00,6A5
03F42:  MOVLB  6
03F44:  MOVF   x98,W
03F46:  MULLW  21
03F48:  MOVF   FF3,W
03F4A:  CLRF   xAA
03F4C:  MOVWF  xA9
03F4E:  MOVLW  1C
03F50:  ADDWF  xA9,W
03F52:  MOVWF  01
03F54:  MOVLW  00
03F56:  ADDWFC xAA,W
03F58:  MOVWF  03
03F5A:  MOVF   01,W
03F5C:  ADDLW  0F
03F5E:  MOVWF  FE9
03F60:  MOVLW  01
03F62:  ADDWFC 03,W
03F64:  MOVWF  FEA
03F66:  MOVF   FEF,W
03F68:  CLRF   xD2
03F6A:  MOVWF  xD1
03F6C:  BTFSC  xD1.7
03F6E:  DECF   xD2,F
03F70:  MOVLB  0
03F72:  CALL   27BC
03F76:  MOVFF  6A8,6E3
03F7A:  MOVFF  6A7,6E2
03F7E:  MOVFF  6A6,6E1
03F82:  MOVFF  6A5,6E0
03F86:  MOVFF  03,6E7
03F8A:  MOVFF  02,6E6
03F8E:  MOVFF  01,6E5
03F92:  MOVFF  00,6E4
03F96:  CALL   0E3A
03F9A:  MOVFF  FEA,6A6
03F9E:  MOVFF  FE9,6A5
03FA2:  BCF    FD8.1
03FA4:  MOVFF  6A4,6E2
03FA8:  MOVFF  6A3,6E1
03FAC:  MOVFF  6A2,6E0
03FB0:  MOVFF  6A1,6DF
03FB4:  MOVFF  03,6E6
03FB8:  MOVFF  02,6E5
03FBC:  MOVFF  01,6E4
03FC0:  MOVFF  00,6E3
03FC4:  CALL   0F30
03FC8:  MOVFF  6A6,FEA
03FCC:  MOVFF  6A5,FE9
03FD0:  MOVFF  03,69C
03FD4:  MOVFF  02,69B
03FD8:  MOVFF  01,69A
03FDC:  MOVFF  00,699
....................    
....................    adcVals[ch].pReal = (pow(pTmp*sc[ch].c5,5) + pow(pTmp*sc[ch].c4,4) + pow(pTmp*sc[ch].c3,3) + pow(pTmp*sc[ch].c2,2) + pTmp*sc[ch].c1 + sc[ch].c0);
03FE0:  MOVLB  6
03FE2:  MOVF   x98,W
03FE4:  MULLW  21
03FE6:  MOVF   FF3,W
03FE8:  CLRF   xA2
03FEA:  MOVWF  xA1
03FEC:  MOVLW  1D
03FEE:  ADDWF  xA1,W
03FF0:  MOVWF  01
03FF2:  MOVLW  00
03FF4:  ADDWFC xA2,W
03FF6:  MOVWF  03
03FF8:  MOVF   01,W
03FFA:  ADDLW  0F
03FFC:  MOVWF  01
03FFE:  MOVLW  01
04000:  ADDWFC 03,F
04002:  MOVFF  01,6A1
04006:  MOVFF  03,6A2
0400A:  MOVF   x98,W
0400C:  MULLW  18
0400E:  MOVF   FF3,W
04010:  CLRF   xA4
04012:  MOVWF  xA3
04014:  MOVLW  14
04016:  ADDWF  xA3,W
04018:  MOVWF  01
0401A:  MOVLW  00
0401C:  ADDWFC xA4,W
0401E:  MOVWF  03
04020:  MOVF   01,W
04022:  ADDLW  82
04024:  MOVWF  FE9
04026:  MOVLW  00
04028:  ADDWFC 03,W
0402A:  MOVWF  FEA
0402C:  MOVFF  FEF,6E4
04030:  MOVFF  FEC,01
04034:  MOVFF  FEC,02
04038:  MOVFF  FEC,03
0403C:  MOVFF  69C,6E3
04040:  MOVFF  69B,6E2
04044:  MOVFF  69A,6E1
04048:  MOVFF  699,6E0
0404C:  MOVFF  03,6E7
04050:  MOVFF  02,6E6
04054:  MOVFF  01,6E5
04058:  MOVLB  0
0405A:  CALL   0E3A
0405E:  MOVFF  03,6A6
04062:  MOVFF  02,6A5
04066:  MOVFF  01,6A4
0406A:  MOVFF  00,6A3
0406E:  MOVFF  03,6B2
04072:  MOVFF  02,6B1
04076:  MOVFF  01,6B0
0407A:  MOVFF  00,6AF
0407E:  MOVLB  6
04080:  CLRF   xB6
04082:  CLRF   xB5
04084:  MOVLW  20
04086:  MOVWF  xB4
04088:  MOVLW  81
0408A:  MOVWF  xB3
0408C:  MOVLB  0
0408E:  CALL   34FA
04092:  MOVFF  03,6A6
04096:  MOVFF  02,6A5
0409A:  MOVFF  01,6A4
0409E:  MOVFF  00,6A3
040A2:  MOVLB  6
040A4:  MOVF   x98,W
040A6:  MULLW  18
040A8:  MOVF   FF3,W
040AA:  CLRF   xA8
040AC:  MOVWF  xA7
040AE:  MOVLW  10
040B0:  ADDWF  xA7,W
040B2:  MOVWF  01
040B4:  MOVLW  00
040B6:  ADDWFC xA8,W
040B8:  MOVWF  03
040BA:  MOVF   01,W
040BC:  ADDLW  82
040BE:  MOVWF  FE9
040C0:  MOVLW  00
040C2:  ADDWFC 03,W
040C4:  MOVWF  FEA
040C6:  MOVFF  FEF,6E4
040CA:  MOVFF  FEC,01
040CE:  MOVFF  FEC,02
040D2:  MOVFF  FEC,03
040D6:  MOVFF  69C,6E3
040DA:  MOVFF  69B,6E2
040DE:  MOVFF  69A,6E1
040E2:  MOVFF  699,6E0
040E6:  MOVFF  03,6E7
040EA:  MOVFF  02,6E6
040EE:  MOVFF  01,6E5
040F2:  MOVLB  0
040F4:  CALL   0E3A
040F8:  MOVFF  03,6AA
040FC:  MOVFF  02,6A9
04100:  MOVFF  01,6A8
04104:  MOVFF  00,6A7
04108:  MOVFF  03,6B2
0410C:  MOVFF  02,6B1
04110:  MOVFF  01,6B0
04114:  MOVFF  00,6AF
04118:  MOVLB  6
0411A:  CLRF   xB6
0411C:  CLRF   xB5
0411E:  CLRF   xB4
04120:  MOVLW  81
04122:  MOVWF  xB3
04124:  MOVLB  0
04126:  CALL   34FA
0412A:  MOVFF  FEA,6A8
0412E:  MOVFF  FE9,6A7
04132:  BCF    FD8.1
04134:  MOVFF  6A6,6E2
04138:  MOVFF  6A5,6E1
0413C:  MOVFF  6A4,6E0
04140:  MOVFF  6A3,6DF
04144:  MOVFF  03,6E6
04148:  MOVFF  02,6E5
0414C:  MOVFF  01,6E4
04150:  MOVFF  00,6E3
04154:  CALL   0F30
04158:  MOVFF  6A8,FEA
0415C:  MOVFF  6A7,FE9
04160:  MOVFF  03,6A6
04164:  MOVFF  02,6A5
04168:  MOVFF  01,6A4
0416C:  MOVFF  00,6A3
04170:  MOVLB  6
04172:  MOVF   x98,W
04174:  MULLW  18
04176:  MOVF   FF3,W
04178:  CLRF   xAA
0417A:  MOVWF  xA9
0417C:  MOVLW  0C
0417E:  ADDWF  xA9,W
04180:  MOVWF  01
04182:  MOVLW  00
04184:  ADDWFC xAA,W
04186:  MOVWF  03
04188:  MOVF   01,W
0418A:  ADDLW  82
0418C:  MOVWF  FE9
0418E:  MOVLW  00
04190:  ADDWFC 03,W
04192:  MOVWF  FEA
04194:  MOVFF  FEF,6E4
04198:  MOVFF  FEC,01
0419C:  MOVFF  FEC,02
041A0:  MOVFF  FEC,03
041A4:  MOVFF  69C,6E3
041A8:  MOVFF  69B,6E2
041AC:  MOVFF  69A,6E1
041B0:  MOVFF  699,6E0
041B4:  MOVFF  03,6E7
041B8:  MOVFF  02,6E6
041BC:  MOVFF  01,6E5
041C0:  MOVLB  0
041C2:  CALL   0E3A
041C6:  MOVFF  03,6AC
041CA:  MOVFF  02,6AB
041CE:  MOVFF  01,6AA
041D2:  MOVFF  00,6A9
041D6:  MOVFF  03,6B2
041DA:  MOVFF  02,6B1
041DE:  MOVFF  01,6B0
041E2:  MOVFF  00,6AF
041E6:  MOVLB  6
041E8:  CLRF   xB6
041EA:  CLRF   xB5
041EC:  MOVLW  40
041EE:  MOVWF  xB4
041F0:  MOVLW  80
041F2:  MOVWF  xB3
041F4:  MOVLB  0
041F6:  CALL   34FA
041FA:  MOVFF  FEA,6AA
041FE:  MOVFF  FE9,6A9
04202:  BCF    FD8.1
04204:  MOVFF  6A6,6E2
04208:  MOVFF  6A5,6E1
0420C:  MOVFF  6A4,6E0
04210:  MOVFF  6A3,6DF
04214:  MOVFF  03,6E6
04218:  MOVFF  02,6E5
0421C:  MOVFF  01,6E4
04220:  MOVFF  00,6E3
04224:  CALL   0F30
04228:  MOVFF  6AA,FEA
0422C:  MOVFF  6A9,FE9
04230:  MOVFF  03,6A6
04234:  MOVFF  02,6A5
04238:  MOVFF  01,6A4
0423C:  MOVFF  00,6A3
04240:  MOVLB  6
04242:  MOVF   x98,W
04244:  MULLW  18
04246:  MOVF   FF3,W
04248:  CLRF   xAC
0424A:  MOVWF  xAB
0424C:  MOVLW  08
0424E:  ADDWF  xAB,W
04250:  MOVWF  01
04252:  MOVLW  00
04254:  ADDWFC xAC,W
04256:  MOVWF  03
04258:  MOVF   01,W
0425A:  ADDLW  82
0425C:  MOVWF  FE9
0425E:  MOVLW  00
04260:  ADDWFC 03,W
04262:  MOVWF  FEA
04264:  MOVFF  FEF,6E4
04268:  MOVFF  FEC,01
0426C:  MOVFF  FEC,02
04270:  MOVFF  FEC,03
04274:  MOVFF  69C,6E3
04278:  MOVFF  69B,6E2
0427C:  MOVFF  69A,6E1
04280:  MOVFF  699,6E0
04284:  MOVFF  03,6E7
04288:  MOVFF  02,6E6
0428C:  MOVFF  01,6E5
04290:  MOVLB  0
04292:  CALL   0E3A
04296:  MOVFF  03,6AE
0429A:  MOVFF  02,6AD
0429E:  MOVFF  01,6AC
042A2:  MOVFF  00,6AB
042A6:  MOVFF  03,6B2
042AA:  MOVFF  02,6B1
042AE:  MOVFF  01,6B0
042B2:  MOVFF  00,6AF
042B6:  MOVLB  6
042B8:  CLRF   xB6
042BA:  CLRF   xB5
042BC:  CLRF   xB4
042BE:  MOVLW  80
042C0:  MOVWF  xB3
042C2:  MOVLB  0
042C4:  CALL   34FA
042C8:  MOVFF  FEA,6AC
042CC:  MOVFF  FE9,6AB
042D0:  BCF    FD8.1
042D2:  MOVFF  6A6,6E2
042D6:  MOVFF  6A5,6E1
042DA:  MOVFF  6A4,6E0
042DE:  MOVFF  6A3,6DF
042E2:  MOVFF  03,6E6
042E6:  MOVFF  02,6E5
042EA:  MOVFF  01,6E4
042EE:  MOVFF  00,6E3
042F2:  CALL   0F30
042F6:  MOVFF  6AC,FEA
042FA:  MOVFF  6AB,FE9
042FE:  MOVFF  03,6A6
04302:  MOVFF  02,6A5
04306:  MOVFF  01,6A4
0430A:  MOVFF  00,6A3
0430E:  MOVLB  6
04310:  MOVF   x98,W
04312:  MULLW  18
04314:  MOVF   FF3,W
04316:  CLRF   xAE
04318:  MOVWF  xAD
0431A:  MOVLW  04
0431C:  ADDWF  xAD,W
0431E:  MOVWF  01
04320:  MOVLW  00
04322:  ADDWFC xAE,W
04324:  MOVWF  03
04326:  MOVF   01,W
04328:  ADDLW  82
0432A:  MOVWF  FE9
0432C:  MOVLW  00
0432E:  ADDWFC 03,W
04330:  MOVWF  FEA
04332:  MOVFF  FEF,6E4
04336:  MOVFF  FEC,01
0433A:  MOVFF  FEC,02
0433E:  MOVFF  FEC,03
04342:  MOVFF  69C,6E3
04346:  MOVFF  69B,6E2
0434A:  MOVFF  69A,6E1
0434E:  MOVFF  699,6E0
04352:  MOVFF  03,6E7
04356:  MOVFF  02,6E6
0435A:  MOVFF  01,6E5
0435E:  MOVLB  0
04360:  CALL   0E3A
04364:  MOVFF  FEA,6AE
04368:  MOVFF  FE9,6AD
0436C:  BCF    FD8.1
0436E:  MOVFF  6A6,6E2
04372:  MOVFF  6A5,6E1
04376:  MOVFF  6A4,6E0
0437A:  MOVFF  6A3,6DF
0437E:  MOVFF  03,6E6
04382:  MOVFF  02,6E5
04386:  MOVFF  01,6E4
0438A:  MOVFF  00,6E3
0438E:  CALL   0F30
04392:  MOVFF  6AE,FEA
04396:  MOVFF  6AD,FE9
0439A:  MOVFF  03,6E2
0439E:  MOVFF  02,6E1
043A2:  MOVFF  01,6E0
043A6:  MOVFF  00,6DF
043AA:  MOVLB  6
043AC:  MOVF   x98,W
043AE:  MULLW  18
043B0:  MOVF   FF3,W
043B2:  CLRF   xB0
043B4:  MOVWF  xAF
043B6:  MOVLW  82
043B8:  ADDWF  xAF,W
043BA:  MOVWF  FE9
043BC:  MOVLW  00
043BE:  ADDWFC xB0,W
043C0:  MOVWF  FEA
043C2:  MOVFF  FEF,6E3
043C6:  MOVFF  FEC,01
043CA:  MOVFF  FEC,02
043CE:  MOVFF  FEC,03
043D2:  BCF    FD8.1
043D4:  MOVFF  03,6E6
043D8:  MOVFF  02,6E5
043DC:  MOVFF  01,6E4
043E0:  MOVLB  0
043E2:  CALL   0F30
043E6:  MOVFF  6A2,FEA
043EA:  MOVFF  6A1,FE9
043EE:  MOVFF  00,FEF
043F2:  MOVFF  01,FEC
043F6:  MOVFF  02,FEC
043FA:  MOVFF  03,FEC
....................    if (ch == chX) adcVals[ch].pReal *= -1;
043FE:  MOVLB  6
04400:  MOVF   x98,F
04402:  BNZ   4460
04404:  MOVF   x98,W
04406:  MULLW  21
04408:  MOVF   FF3,W
0440A:  CLRF   xA2
0440C:  MOVWF  xA1
0440E:  MOVLW  1D
04410:  ADDWF  xA1,W
04412:  MOVWF  01
04414:  MOVLW  00
04416:  ADDWFC xA2,W
04418:  MOVWF  03
0441A:  MOVF   01,W
0441C:  ADDLW  0F
0441E:  MOVWF  FE9
04420:  MOVLW  01
04422:  ADDWFC 03,W
04424:  MOVWF  FEA
04426:  MOVFF  FEF,6E0
0442A:  MOVFF  FEC,6E1
0442E:  MOVFF  FEC,6E2
04432:  MOVFF  FEC,6E3
04436:  MOVF   FED,F
04438:  MOVF   FED,F
0443A:  MOVF   FED,F
0443C:  CLRF   xE7
0443E:  CLRF   xE6
04440:  MOVLW  80
04442:  MOVWF  xE5
04444:  MOVLW  7F
04446:  MOVWF  xE4
04448:  MOVLB  0
0444A:  CALL   0E3A
0444E:  MOVFF  00,FEF
04452:  MOVFF  01,FEC
04456:  MOVFF  02,FEC
0445A:  MOVFF  03,FEC
0445E:  MOVLB  6
....................    PID[ch].PVold = PID[ch].PV;
04460:  MOVF   x98,W
04462:  MULLW  20
04464:  MOVF   FF3,W
04466:  CLRF   xA2
04468:  MOVWF  xA1
0446A:  MOVLW  14
0446C:  ADDWF  xA1,W
0446E:  MOVWF  01
04470:  MOVLW  00
04472:  ADDWFC xA2,W
04474:  MOVWF  03
04476:  MOVF   01,W
04478:  ADDLW  20
0447A:  MOVWF  01
0447C:  MOVLW  00
0447E:  ADDWFC 03,F
04480:  MOVFF  01,6A1
04484:  MOVFF  03,6A2
04488:  MOVF   x98,W
0448A:  MULLW  20
0448C:  MOVF   FF3,W
0448E:  CLRF   xA4
04490:  MOVWF  xA3
04492:  MOVLW  10
04494:  ADDWF  xA3,W
04496:  MOVWF  01
04498:  MOVLW  00
0449A:  ADDWFC xA4,W
0449C:  MOVWF  03
0449E:  MOVF   01,W
044A0:  ADDLW  20
044A2:  MOVWF  FE9
044A4:  MOVLW  00
044A6:  ADDWFC 03,W
044A8:  MOVWF  FEA
044AA:  MOVFF  FEF,00
044AE:  MOVFF  FEC,01
044B2:  MOVFF  FEC,02
044B6:  MOVFF  FEC,03
044BA:  MOVFF  6A2,FEA
044BE:  MOVFF  6A1,FE9
044C2:  MOVFF  00,FEF
044C6:  MOVFF  01,FEC
044CA:  MOVFF  02,FEC
044CE:  MOVFF  03,FEC
....................    PID[ch].PV = adcVals[ch].pReal;
044D2:  MOVF   x98,W
044D4:  MULLW  20
044D6:  MOVF   FF3,W
044D8:  CLRF   xA2
044DA:  MOVWF  xA1
044DC:  MOVLW  10
044DE:  ADDWF  xA1,W
044E0:  MOVWF  01
044E2:  MOVLW  00
044E4:  ADDWFC xA2,W
044E6:  MOVWF  03
044E8:  MOVF   01,W
044EA:  ADDLW  20
044EC:  MOVWF  01
044EE:  MOVLW  00
044F0:  ADDWFC 03,F
044F2:  MOVFF  01,6A1
044F6:  MOVFF  03,6A2
044FA:  MOVF   x98,W
044FC:  MULLW  21
044FE:  MOVF   FF3,W
04500:  CLRF   xA4
04502:  MOVWF  xA3
04504:  MOVLW  1D
04506:  ADDWF  xA3,W
04508:  MOVWF  01
0450A:  MOVLW  00
0450C:  ADDWFC xA4,W
0450E:  MOVWF  03
04510:  MOVF   01,W
04512:  ADDLW  0F
04514:  MOVWF  FE9
04516:  MOVLW  01
04518:  ADDWFC 03,W
0451A:  MOVWF  FEA
0451C:  MOVFF  FEF,00
04520:  MOVFF  FEC,01
04524:  MOVFF  FEC,02
04528:  MOVFF  FEC,03
0452C:  MOVFF  6A2,FEA
04530:  MOVFF  6A1,FE9
04534:  MOVFF  00,FEF
04538:  MOVFF  01,FEC
0453C:  MOVFF  02,FEC
04540:  MOVFF  03,FEC
04544:  MOVLB  0
04546:  GOTO   462A (RETURN)
.................... }  
.................... 
.................... /*****************************************************************************/
.................... /* SENSOR MONITOR INTERRUPT TASK                                             */
.................... /* starts conversion of the other two ADCs                                   */
.................... /*****************************************************************************/
.................... void sensor_monitor_interrupt_task()
.................... {
....................    static int8 ch = 0;
....................    
....................    if (!smData[ch].adcBusy)
*
001BE:  MOVLB  2
001C0:  MOVF   x04,W
001C2:  MULLW  0D
001C4:  MOVF   FF3,W
001C6:  MOVLB  7
001C8:  CLRF   x15
001CA:  MOVWF  x14
001CC:  MOVLW  E9
001CE:  ADDWF  x14,W
001D0:  MOVWF  FE9
001D2:  MOVLW  01
001D4:  ADDWFC x15,W
001D6:  MOVWF  FEA
001D8:  BTFSC  FEF.1
001DA:  BRA    0254
....................    {
....................       smData[ch].adcBusy = true;
001DC:  MOVLB  2
001DE:  MOVF   x04,W
001E0:  MULLW  0D
001E2:  MOVF   FF3,W
001E4:  MOVLB  7
001E6:  CLRF   x15
001E8:  MOVWF  x14
001EA:  MOVLW  E9
001EC:  ADDWF  x14,W
001EE:  MOVWF  FE9
001F0:  MOVLW  01
001F2:  ADDWFC x15,W
001F4:  MOVWF  FEA
001F6:  BSF    FEF.1
....................       
....................       ads_start_conv_block(ch);
001F8:  MOVFF  204,714
001FC:  MOVLB  0
001FE:  BRA    01A2
....................       ch = !ch;
00200:  MOVLB  2
00202:  MOVF   x04,F
00204:  BZ    020A
00206:  MOVLW  00
00208:  BRA    020C
0020A:  MOVLW  01
0020C:  MOVWF  x04
....................       
....................       smData[!ch].dataReady = true;
0020E:  MOVF   x04,F
00210:  BZ    0216
00212:  MOVLW  00
00214:  BRA    0218
00216:  MOVLW  01
00218:  MULLW  0D
0021A:  MOVF   FF3,W
0021C:  MOVLB  7
0021E:  CLRF   x15
00220:  MOVWF  x14
00222:  MOVLW  E9
00224:  ADDWF  x14,W
00226:  MOVWF  FE9
00228:  MOVLW  01
0022A:  ADDWFC x15,W
0022C:  MOVWF  FEA
0022E:  BSF    FEF.0
....................       smData[!ch].adcBusy = false;
00230:  MOVLB  2
00232:  MOVF   x04,F
00234:  BZ    023A
00236:  MOVLW  00
00238:  BRA    023C
0023A:  MOVLW  01
0023C:  MULLW  0D
0023E:  MOVF   FF3,W
00240:  MOVLB  7
00242:  CLRF   x15
00244:  MOVWF  x14
00246:  MOVLW  E9
00248:  ADDWF  x14,W
0024A:  MOVWF  FE9
0024C:  MOVLW  01
0024E:  ADDWFC x15,W
00250:  MOVWF  FEA
00252:  BCF    FEF.1
....................    }
00254:  MOVLB  0
00256:  GOTO   0318 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Interquartile Mean Ring Buffer                                            */
.................... /* Filters the ADC data to remove spurious readings                          */
.................... /*****************************************************************************/
.................... void iqm_ring_buffer(int8 ch, signed int32 sinCnts, signed int32 cosCnts)
*
01A36:  MOVLB  6
01A38:  CLRF   xE4
01A3A:  CLRF   xE3
01A3C:  CLRF   xE2
01A3E:  CLRF   xE1
01A40:  CLRF   xE8
01A42:  CLRF   xE7
01A44:  CLRF   xE6
01A46:  CLRF   xE5
.................... {
....................    signed int32 iqmBufSin[BUFFER_SIZE];
....................    signed int32 iqmBufCos[BUFFER_SIZE];
....................    signed int32 sumSin=0;
....................    signed int32 sumCos=0;
....................    
.................... //!   tobuff(smData[ch].sinQ, sinCnts); // push new data into queues
.................... //!   tobuff(smData[ch].cosQ, cosCnts);
....................    
....................    push(smData[ch].sinQ, sinCnts); // push new data into queues
01A48:  MOVF   x98,W
01A4A:  MULLW  0D
01A4C:  MOVF   FF3,W
01A4E:  CLRF   xEC
01A50:  MOVWF  xEB
01A52:  MOVLW  01
01A54:  ADDWF  xEB,W
01A56:  MOVWF  01
01A58:  MOVLW  00
01A5A:  ADDWFC xEC,W
01A5C:  MOVWF  03
01A5E:  MOVF   01,W
01A60:  ADDLW  E9
01A62:  MOVWF  FE9
01A64:  MOVLW  01
01A66:  ADDWFC 03,W
01A68:  MOVWF  FEA
01A6A:  MOVFF  FEC,6EE
01A6E:  MOVF   FED,F
01A70:  MOVFF  FEF,6ED
01A74:  MOVFF  69C,6F2
01A78:  MOVFF  69B,6F1
01A7C:  MOVFF  69A,6F0
01A80:  MOVFF  699,6EF
01A84:  MOVLB  0
01A86:  CALL   090A
....................    push(smData[ch].cosQ, cosCnts);
01A8A:  MOVLB  6
01A8C:  MOVF   x98,W
01A8E:  MULLW  0D
01A90:  MOVF   FF3,W
01A92:  CLRF   xEC
01A94:  MOVWF  xEB
01A96:  MOVLW  03
01A98:  ADDWF  xEB,W
01A9A:  MOVWF  01
01A9C:  MOVLW  00
01A9E:  ADDWFC xEC,W
01AA0:  MOVWF  03
01AA2:  MOVF   01,W
01AA4:  ADDLW  E9
01AA6:  MOVWF  FE9
01AA8:  MOVLW  01
01AAA:  ADDWFC 03,W
01AAC:  MOVWF  FEA
01AAE:  MOVFF  FEC,6EE
01AB2:  MOVF   FED,F
01AB4:  MOVFF  FEF,6ED
01AB8:  MOVFF  6A0,6F2
01ABC:  MOVFF  69F,6F1
01AC0:  MOVFF  69E,6F0
01AC4:  MOVFF  69D,6EF
01AC8:  MOVLB  0
01ACA:  CALL   090A
....................    
....................    // copy queue contents out to buffer for qsorting
....................    for (int j=0; j<BUFFER_SIZE; j++){
01ACE:  MOVLB  6
01AD0:  CLRF   xE9
01AD2:  MOVF   xE9,W
01AD4:  SUBLW  07
01AD6:  BTFSS  FD8.0
01AD8:  BRA    1C2E
....................       iqmBufSin[j] = smData[ch].sinQ->buff[j];
01ADA:  MOVF   xE9,W
01ADC:  MULLW  04
01ADE:  MOVF   FF3,W
01AE0:  CLRF   03
01AE2:  ADDLW  A1
01AE4:  MOVWF  01
01AE6:  MOVLW  06
01AE8:  ADDWFC 03,F
01AEA:  MOVFF  01,6EB
01AEE:  MOVFF  03,6EC
01AF2:  MOVF   x98,W
01AF4:  MULLW  0D
01AF6:  MOVF   FF3,W
01AF8:  CLRF   xEE
01AFA:  MOVWF  xED
01AFC:  MOVLW  01
01AFE:  ADDWF  xED,W
01B00:  MOVWF  01
01B02:  MOVLW  00
01B04:  ADDWFC xEE,W
01B06:  MOVWF  03
01B08:  MOVF   01,W
01B0A:  ADDLW  E9
01B0C:  MOVWF  01
01B0E:  MOVLW  01
01B10:  ADDWFC 03,F
01B12:  MOVFF  01,6ED
01B16:  MOVFF  03,6EE
01B1A:  MOVFF  03,FEA
01B1E:  MOVFF  01,FE9
01B22:  MOVFF  FEC,6F0
01B26:  MOVF   FED,F
01B28:  MOVFF  FEF,6EF
01B2C:  CLRF   xF2
01B2E:  MOVFF  6E9,6F1
01B32:  CLRF   xF4
01B34:  MOVLW  04
01B36:  MOVWF  xF3
01B38:  MOVLB  0
01B3A:  CALL   0C0C
01B3E:  MOVFF  02,03
01B42:  MOVF   01,W
01B44:  ADDLW  01
01B46:  MOVWF  01
01B48:  MOVLW  00
01B4A:  ADDWFC 03,F
01B4C:  MOVF   01,W
01B4E:  MOVLB  6
01B50:  ADDWF  xEF,W
01B52:  MOVWF  FE9
01B54:  MOVF   xF0,W
01B56:  ADDWFC 03,W
01B58:  MOVWF  FEA
01B5A:  MOVFF  FEF,00
01B5E:  MOVFF  FEC,01
01B62:  MOVFF  FEC,02
01B66:  MOVFF  FEC,03
01B6A:  MOVFF  6EC,FEA
01B6E:  MOVFF  6EB,FE9
01B72:  MOVFF  00,FEF
01B76:  MOVFF  01,FEC
01B7A:  MOVFF  02,FEC
01B7E:  MOVFF  03,FEC
....................       iqmBufCos[j] = smData[ch].cosQ->buff[j];
01B82:  MOVF   xE9,W
01B84:  MULLW  04
01B86:  MOVF   FF3,W
01B88:  CLRF   03
01B8A:  ADDLW  C1
01B8C:  MOVWF  01
01B8E:  MOVLW  06
01B90:  ADDWFC 03,F
01B92:  MOVFF  01,6EB
01B96:  MOVFF  03,6EC
01B9A:  MOVF   x98,W
01B9C:  MULLW  0D
01B9E:  MOVF   FF3,W
01BA0:  CLRF   xEE
01BA2:  MOVWF  xED
01BA4:  MOVLW  03
01BA6:  ADDWF  xED,W
01BA8:  MOVWF  01
01BAA:  MOVLW  00
01BAC:  ADDWFC xEE,W
01BAE:  MOVWF  03
01BB0:  MOVF   01,W
01BB2:  ADDLW  E9
01BB4:  MOVWF  01
01BB6:  MOVLW  01
01BB8:  ADDWFC 03,F
01BBA:  MOVFF  01,6ED
01BBE:  MOVFF  03,6EE
01BC2:  MOVFF  03,FEA
01BC6:  MOVFF  01,FE9
01BCA:  MOVFF  FEC,6F0
01BCE:  MOVF   FED,F
01BD0:  MOVFF  FEF,6EF
01BD4:  CLRF   xF2
01BD6:  MOVFF  6E9,6F1
01BDA:  CLRF   xF4
01BDC:  MOVLW  04
01BDE:  MOVWF  xF3
01BE0:  MOVLB  0
01BE2:  CALL   0C0C
01BE6:  MOVFF  02,03
01BEA:  MOVF   01,W
01BEC:  ADDLW  01
01BEE:  MOVWF  01
01BF0:  MOVLW  00
01BF2:  ADDWFC 03,F
01BF4:  MOVF   01,W
01BF6:  MOVLB  6
01BF8:  ADDWF  xEF,W
01BFA:  MOVWF  FE9
01BFC:  MOVF   xF0,W
01BFE:  ADDWFC 03,W
01C00:  MOVWF  FEA
01C02:  MOVFF  FEF,00
01C06:  MOVFF  FEC,01
01C0A:  MOVFF  FEC,02
01C0E:  MOVFF  FEC,03
01C12:  MOVFF  6EC,FEA
01C16:  MOVFF  6EB,FE9
01C1A:  MOVFF  00,FEF
01C1E:  MOVFF  01,FEC
01C22:  MOVFF  02,FEC
01C26:  MOVFF  03,FEC
01C2A:  INCF   xE9,F
01C2C:  BRA    1AD2
....................    }
....................    
....................    qsort(iqmBufSin, BUFFER_SIZE, sizeof(*iqmBufSin), compar);
01C2E:  MOVLW  17
01C30:  MOVWF  03
01C32:  MOVLW  26
01C34:  MOVWF  xEB
01C36:  MOVFF  03,6EC
01C3A:  MOVLW  06
01C3C:  MOVWF  xEE
01C3E:  MOVLW  A1
01C40:  MOVWF  xED
01C42:  MOVLW  08
01C44:  MOVWF  xEF
01C46:  MOVLW  01
01C48:  MOVWF  xF0
01C4A:  MOVFF  03,6F2
01C4E:  MOVFF  6EB,6F1
01C52:  MOVLB  0
01C54:  RCALL  17F6
....................    qsort(iqmBufCos, BUFFER_SIZE, sizeof(*iqmBufCos), compar);
01C56:  MOVLW  17
01C58:  MOVWF  03
01C5A:  MOVLW  26
01C5C:  MOVLB  6
01C5E:  MOVWF  xEB
01C60:  MOVFF  03,6EC
01C64:  MOVLW  06
01C66:  MOVWF  xEE
01C68:  MOVLW  C1
01C6A:  MOVWF  xED
01C6C:  MOVLW  08
01C6E:  MOVWF  xEF
01C70:  MOVLW  01
01C72:  MOVWF  xF0
01C74:  MOVFF  03,6F2
01C78:  MOVFF  6EB,6F1
01C7C:  MOVLB  0
01C7E:  RCALL  17F6
....................    
....................    for (int k=1; k<(BUFFER_SIZE-1); k++){
01C80:  MOVLW  01
01C82:  MOVLB  6
01C84:  MOVWF  xEA
01C86:  MOVF   xEA,W
01C88:  SUBLW  06
01C8A:  BNC   1CF4
....................       sumSin+=iqmBufSin[k];
01C8C:  MOVF   xEA,W
01C8E:  MULLW  04
01C90:  MOVF   FF3,W
01C92:  CLRF   03
01C94:  ADDLW  A1
01C96:  MOVWF  FE9
01C98:  MOVLW  06
01C9A:  ADDWFC 03,W
01C9C:  MOVWF  FEA
01C9E:  MOVFF  FEF,00
01CA2:  MOVFF  FEC,01
01CA6:  MOVFF  FEC,02
01CAA:  MOVFF  FEC,03
01CAE:  MOVF   00,W
01CB0:  ADDWF  xE1,F
01CB2:  MOVF   01,W
01CB4:  ADDWFC xE2,F
01CB6:  MOVF   02,W
01CB8:  ADDWFC xE3,F
01CBA:  MOVF   03,W
01CBC:  ADDWFC xE4,F
....................       sumCos+=iqmBufCos[k];
01CBE:  MOVF   xEA,W
01CC0:  MULLW  04
01CC2:  MOVF   FF3,W
01CC4:  CLRF   03
01CC6:  ADDLW  C1
01CC8:  MOVWF  FE9
01CCA:  MOVLW  06
01CCC:  ADDWFC 03,W
01CCE:  MOVWF  FEA
01CD0:  MOVFF  FEF,00
01CD4:  MOVFF  FEC,01
01CD8:  MOVFF  FEC,02
01CDC:  MOVFF  FEC,03
01CE0:  MOVF   00,W
01CE2:  ADDWF  xE5,F
01CE4:  MOVF   01,W
01CE6:  ADDWFC xE6,F
01CE8:  MOVF   02,W
01CEA:  ADDWFC xE7,F
01CEC:  MOVF   03,W
01CEE:  ADDWFC xE8,F
01CF0:  INCF   xEA,F
01CF2:  BRA    1C86
....................    }
....................    smData[ch].avgSin = sumSin / (BUFFER_SIZE-2);
01CF4:  MOVF   x98,W
01CF6:  MULLW  0D
01CF8:  MOVF   FF3,W
01CFA:  CLRF   xEC
01CFC:  MOVWF  xEB
01CFE:  MOVLW  05
01D00:  ADDWF  xEB,W
01D02:  MOVWF  01
01D04:  MOVLW  00
01D06:  ADDWFC xEC,W
01D08:  MOVWF  03
01D0A:  MOVF   01,W
01D0C:  ADDLW  E9
01D0E:  MOVWF  FE9
01D10:  MOVLW  01
01D12:  ADDWFC 03,W
01D14:  MOVWF  FEA
01D16:  MOVFF  FEA,6EE
01D1A:  MOVFF  FE9,6ED
01D1E:  BCF    FD8.1
01D20:  MOVFF  6E4,6F2
01D24:  MOVFF  6E3,6F1
01D28:  MOVFF  6E2,6F0
01D2C:  MOVFF  6E1,6EF
01D30:  CLRF   xF6
01D32:  CLRF   xF5
01D34:  CLRF   xF4
01D36:  MOVLW  06
01D38:  MOVWF  xF3
01D3A:  MOVLB  0
01D3C:  RCALL  194C
01D3E:  MOVFF  6EE,FEA
01D42:  MOVFF  6ED,FE9
01D46:  MOVFF  00,FEF
01D4A:  MOVFF  01,FEC
01D4E:  MOVFF  02,FEC
01D52:  MOVFF  03,FEC
....................    smData[ch].avgCos = sumCos / (BUFFER_SIZE-2);
01D56:  MOVLB  6
01D58:  MOVF   x98,W
01D5A:  MULLW  0D
01D5C:  MOVF   FF3,W
01D5E:  CLRF   xEC
01D60:  MOVWF  xEB
01D62:  MOVLW  09
01D64:  ADDWF  xEB,W
01D66:  MOVWF  01
01D68:  MOVLW  00
01D6A:  ADDWFC xEC,W
01D6C:  MOVWF  03
01D6E:  MOVF   01,W
01D70:  ADDLW  E9
01D72:  MOVWF  FE9
01D74:  MOVLW  01
01D76:  ADDWFC 03,W
01D78:  MOVWF  FEA
01D7A:  MOVFF  FEA,6EE
01D7E:  MOVFF  FE9,6ED
01D82:  BCF    FD8.1
01D84:  MOVFF  6E8,6F2
01D88:  MOVFF  6E7,6F1
01D8C:  MOVFF  6E6,6F0
01D90:  MOVFF  6E5,6EF
01D94:  CLRF   xF6
01D96:  CLRF   xF5
01D98:  CLRF   xF4
01D9A:  MOVLW  06
01D9C:  MOVWF  xF3
01D9E:  MOVLB  0
01DA0:  RCALL  194C
01DA2:  MOVFF  6EE,FEA
01DA6:  MOVFF  6ED,FE9
01DAA:  MOVFF  00,FEF
01DAE:  MOVFF  01,FEC
01DB2:  MOVFF  02,FEC
01DB6:  MOVFF  03,FEC
01DBA:  GOTO   4622 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SENSOR MONITOR task - gets magnetoresistive sensor counts                 */
.................... /* gets two values each time the task is run                                 */
.................... /*****************************************************************************/
.................... void sensor_monitor_task()
*
0454A:  MOVLB  6
0454C:  CLRF   x93
0454E:  CLRF   x92
04550:  CLRF   x91
04552:  CLRF   x90
04554:  CLRF   x97
04556:  CLRF   x96
04558:  CLRF   x95
0455A:  CLRF   x94
.................... {
....................    static int8 ch = 0;
....................    signed int32 sinNew = 0;
....................    signed int32 cosNew = 0;
....................    
....................    if ( (!smData[ch].adcBusy) && smData[ch].dataReady ){
0455C:  MOVLB  2
0455E:  MOVF   x05,W
04560:  MULLW  0D
04562:  MOVF   FF3,W
04564:  MOVLB  6
04566:  CLRF   x99
04568:  MOVWF  x98
0456A:  MOVLW  E9
0456C:  ADDWF  x98,W
0456E:  MOVWF  FE9
04570:  MOVLW  01
04572:  ADDWFC x99,W
04574:  MOVWF  FEA
04576:  BTFSC  FEF.1
04578:  BRA    467E
0457A:  MOVLB  2
0457C:  MOVF   x05,W
0457E:  MULLW  0D
04580:  MOVF   FF3,W
04582:  MOVLB  6
04584:  CLRF   x9B
04586:  MOVWF  x9A
04588:  MOVLW  E9
0458A:  ADDWF  x9A,W
0458C:  MOVWF  FE9
0458E:  MOVLW  01
04590:  ADDWFC x9B,W
04592:  MOVWF  FEA
04594:  BTFSS  FEF.0
04596:  BRA    467E
....................       smData[ch].adcBusy = true;
04598:  MOVLB  2
0459A:  MOVF   x05,W
0459C:  MULLW  0D
0459E:  MOVF   FF3,W
045A0:  MOVLB  6
045A2:  CLRF   x99
045A4:  MOVWF  x98
045A6:  MOVLW  E9
045A8:  ADDWF  x98,W
045AA:  MOVWF  FE9
045AC:  MOVLW  01
045AE:  ADDWFC x99,W
045B0:  MOVWF  FEA
045B2:  BSF    FEF.1
....................       
....................       sinNew = ads_read_data(ch*2);
045B4:  BCF    FD8.0
045B6:  MOVLB  2
045B8:  RLCF   x05,W
045BA:  MOVLB  6
045BC:  MOVWF  x98
045BE:  MOVWF  x9A
045C0:  MOVLB  0
045C2:  CALL   081A
045C6:  MOVFF  03,693
045CA:  MOVFF  02,692
045CE:  MOVFF  01,691
045D2:  MOVFF  00,690
....................       cosNew = ads_read_data(ch*2+1);      
045D6:  BCF    FD8.0
045D8:  MOVLB  2
045DA:  RLCF   x05,W
045DC:  ADDLW  01
045DE:  MOVLB  6
045E0:  MOVWF  x98
045E2:  MOVWF  x9A
045E4:  MOVLB  0
045E6:  CALL   081A
045EA:  MOVFF  03,697
045EE:  MOVFF  02,696
045F2:  MOVFF  01,695
045F6:  MOVFF  00,694
....................       
....................       iqm_ring_buffer(ch, sinNew, cosNew);
045FA:  MOVFF  205,698
045FE:  MOVFF  693,69C
04602:  MOVFF  692,69B
04606:  MOVFF  691,69A
0460A:  MOVFF  690,699
0460E:  MOVFF  697,6A0
04612:  MOVFF  696,69F
04616:  MOVFF  695,69E
0461A:  MOVFF  694,69D
0461E:  GOTO   1A36
....................       
....................       sensor_process_data(ch);
04622:  MOVFF  205,698
04626:  GOTO   37F8
....................       ch = !ch;
0462A:  MOVLB  2
0462C:  MOVF   x05,F
0462E:  BZ    4634
04630:  MOVLW  00
04632:  BRA    4636
04634:  MOVLW  01
04636:  MOVWF  x05
....................       
....................       smData[!ch].dataReady = false;
04638:  MOVF   x05,F
0463A:  BZ    4640
0463C:  MOVLW  00
0463E:  BRA    4642
04640:  MOVLW  01
04642:  MULLW  0D
04644:  MOVF   FF3,W
04646:  MOVLB  6
04648:  CLRF   x99
0464A:  MOVWF  x98
0464C:  MOVLW  E9
0464E:  ADDWF  x98,W
04650:  MOVWF  FE9
04652:  MOVLW  01
04654:  ADDWFC x99,W
04656:  MOVWF  FEA
04658:  BCF    FEF.0
....................       smData[!ch].adcBusy = false;
0465A:  MOVLB  2
0465C:  MOVF   x05,F
0465E:  BZ    4664
04660:  MOVLW  00
04662:  BRA    4666
04664:  MOVLW  01
04666:  MULLW  0D
04668:  MOVF   FF3,W
0466A:  MOVLB  6
0466C:  CLRF   x99
0466E:  MOVWF  x98
04670:  MOVLW  E9
04672:  ADDWF  x98,W
04674:  MOVWF  FE9
04676:  MOVLW  01
04678:  ADDWFC x99,W
0467A:  MOVWF  FEA
0467C:  BCF    FEF.1
....................    }
0467E:  MOVLB  0
04680:  GOTO   A670 (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* INITIALIZE ADC's                                                          */
.................... /*****************************************************************************/
.................... void setup_external_ADCs()
*
0098E:  MOVLB  6
00990:  CLRF   x90
00992:  CLRF   x91
00994:  CLRF   x92
00996:  CLRF   x93
.................... {
....................    unsigned int8 rc0=0;
....................    unsigned int8 rc1=0;
....................    unsigned int8 rc2=0;
....................    unsigned int8 rc3=0;
....................    
....................    for (int ch = 0; ch < 4; ch++){
00998:  CLRF   x94
0099A:  MOVF   x94,W
0099C:  SUBLW  03
0099E:  BNC   09D4
....................       rc0=reg0config;
009A0:  MOVLW  30
009A2:  MOVWF  x90
....................       rc1=reg1config;
009A4:  MOVLW  10
009A6:  MOVWF  x91
....................       rc2=reg2config;
009A8:  CLRF   x92
....................       rc3=reg3config;
009AA:  CLRF   x93
....................       
....................       ADS1220init(ch, rc0, rc1, rc2, rc3);
009AC:  MOVFF  694,697
009B0:  MOVFF  690,698
009B4:  MOVFF  691,699
009B8:  MOVFF  692,69A
009BC:  MOVFF  693,69B
009C0:  MOVLB  0
009C2:  BRA    074C
....................       delay_ms(100);
009C4:  MOVLW  64
009C6:  MOVLB  6
009C8:  MOVWF  x98
009CA:  MOVLB  0
009CC:  RCALL  0438
009CE:  MOVLB  6
009D0:  INCF   x94,F
009D2:  BRA    099A
....................    }
....................    
....................    for (int i = 0; i < BUFFER_SIZE; i++){
009D4:  CLRF   x95
009D6:  MOVF   x95,W
009D8:  SUBLW  07
009DA:  BTFSS  FD8.0
009DC:  BRA    0B4A
....................       ads_start_conv_all();
009DE:  MOVLB  0
009E0:  BRA    07EA
....................       delay_ms(600);
009E2:  MOVLW  03
009E4:  MOVLB  6
009E6:  MOVWF  x97
009E8:  MOVLW  C8
009EA:  MOVWF  x98
009EC:  MOVLB  0
009EE:  RCALL  0438
009F0:  MOVLB  6
009F2:  DECFSZ x97,F
009F4:  BRA    09E8
....................       for (int b = 0; b < 2; b++){
009F6:  CLRF   x96
009F8:  MOVF   x96,W
009FA:  SUBLW  01
009FC:  BTFSS  FD8.0
009FE:  BRA    0B46
....................          smData[b].sinQ->in = 0;
00A00:  MOVF   x96,W
00A02:  MULLW  0D
00A04:  MOVF   FF3,W
00A06:  CLRF   x98
00A08:  MOVWF  x97
00A0A:  MOVLW  01
00A0C:  ADDWF  x97,W
00A0E:  MOVWF  01
00A10:  MOVLW  00
00A12:  ADDWFC x98,W
00A14:  MOVWF  03
00A16:  MOVF   01,W
00A18:  ADDLW  E9
00A1A:  MOVWF  01
00A1C:  MOVLW  01
00A1E:  ADDWFC 03,F
00A20:  MOVFF  03,FEA
00A24:  MOVFF  01,FE9
00A28:  MOVFF  FEC,69A
00A2C:  MOVF   FED,F
00A2E:  MOVFF  FEF,699
00A32:  MOVFF  699,FE9
00A36:  MOVFF  69A,FEA
00A3A:  CLRF   FEF
....................          smData[b].cosQ->in = 0;
00A3C:  MOVF   x96,W
00A3E:  MULLW  0D
00A40:  MOVF   FF3,W
00A42:  CLRF   x98
00A44:  MOVWF  x97
00A46:  MOVLW  03
00A48:  ADDWF  x97,W
00A4A:  MOVWF  01
00A4C:  MOVLW  00
00A4E:  ADDWFC x98,W
00A50:  MOVWF  03
00A52:  MOVF   01,W
00A54:  ADDLW  E9
00A56:  MOVWF  01
00A58:  MOVLW  01
00A5A:  ADDWFC 03,F
00A5C:  MOVFF  03,FEA
00A60:  MOVFF  01,FE9
00A64:  MOVFF  FEC,69A
00A68:  MOVF   FED,F
00A6A:  MOVFF  FEF,699
00A6E:  MOVFF  699,FE9
00A72:  MOVFF  69A,FEA
00A76:  CLRF   FEF
.................... //!         tobuff(smData[b].sinQ, ads_read_data(b*2));
.................... //!         tobuff(smData[b].cosQ, ads_read_data(b*2+1));      
....................          push(smData[b].sinQ, ads_read_data(b*2));
00A78:  MOVF   x96,W
00A7A:  MULLW  0D
00A7C:  MOVF   FF3,W
00A7E:  CLRF   x98
00A80:  MOVWF  x97
00A82:  MOVLW  01
00A84:  ADDWF  x97,W
00A86:  MOVWF  01
00A88:  MOVLW  00
00A8A:  ADDWFC x98,W
00A8C:  MOVWF  03
00A8E:  MOVF   01,W
00A90:  ADDLW  E9
00A92:  MOVWF  FE9
00A94:  MOVLW  01
00A96:  ADDWFC 03,W
00A98:  MOVWF  FEA
00A9A:  MOVFF  FEC,698
00A9E:  MOVF   FED,F
00AA0:  MOVFF  FEF,697
00AA4:  BCF    FD8.0
00AA6:  RLCF   x96,W
00AA8:  MOVWF  x99
00AAA:  MOVWF  x9A
00AAC:  MOVLB  0
00AAE:  RCALL  081A
00AB0:  MOVFF  03,69C
00AB4:  MOVFF  02,69B
00AB8:  MOVFF  01,69A
00ABC:  MOVFF  00,699
00AC0:  MOVFF  698,6EE
00AC4:  MOVFF  697,6ED
00AC8:  MOVFF  03,6F2
00ACC:  MOVFF  02,6F1
00AD0:  MOVFF  01,6F0
00AD4:  MOVFF  00,6EF
00AD8:  RCALL  090A
....................          push(smData[b].cosQ, ads_read_data(b*2+1));      
00ADA:  MOVLB  6
00ADC:  MOVF   x96,W
00ADE:  MULLW  0D
00AE0:  MOVF   FF3,W
00AE2:  CLRF   x98
00AE4:  MOVWF  x97
00AE6:  MOVLW  03
00AE8:  ADDWF  x97,W
00AEA:  MOVWF  01
00AEC:  MOVLW  00
00AEE:  ADDWFC x98,W
00AF0:  MOVWF  03
00AF2:  MOVF   01,W
00AF4:  ADDLW  E9
00AF6:  MOVWF  FE9
00AF8:  MOVLW  01
00AFA:  ADDWFC 03,W
00AFC:  MOVWF  FEA
00AFE:  MOVFF  FEC,698
00B02:  MOVF   FED,F
00B04:  MOVFF  FEF,697
00B08:  BCF    FD8.0
00B0A:  RLCF   x96,W
00B0C:  ADDLW  01
00B0E:  MOVWF  x99
00B10:  MOVWF  x9A
00B12:  MOVLB  0
00B14:  RCALL  081A
00B16:  MOVFF  03,69C
00B1A:  MOVFF  02,69B
00B1E:  MOVFF  01,69A
00B22:  MOVFF  00,699
00B26:  MOVFF  698,6EE
00B2A:  MOVFF  697,6ED
00B2E:  MOVFF  03,6F2
00B32:  MOVFF  02,6F1
00B36:  MOVFF  01,6F0
00B3A:  MOVFF  00,6EF
00B3E:  RCALL  090A
00B40:  MOVLB  6
00B42:  INCF   x96,F
00B44:  BRA    09F8
....................       }
00B46:  INCF   x95,F
00B48:  BRA    09D6
....................    }
00B4A:  MOVLB  0
00B4C:  GOTO   0BB0 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE MONITOR -- sets up ADC channels                                */
.................... /*****************************************************************************/
.................... void monitor_init()
.................... {
....................    setup_adc_ports(sAN6 | sAN16 | sAN17 | sAN24 | sAN25 | sAN26 | sAN27, NO_ANALOGS_P2, VSS_VDD);
00B50:  MOVLW  00
00B52:  MOVLB  F
00B54:  MOVWF  x53
00B56:  MOVLW  40
00B58:  MOVWF  x0C
00B5A:  MOVLW  00
00B5C:  MOVWF  x14
00B5E:  MOVLW  03
00B60:  MOVWF  x1C
00B62:  MOVLW  0F
00B64:  MOVWF  x21
00B66:  MOVLW  00
00B68:  MOVWF  x29
....................    setup_adc(ADC_CLOCK_INTERNAL | ADC_TAD_MUL_255 | ADC_LEGACY_MODE | ADC_THRESHOLD_INT_DISABLED);
00B6A:  MOVLW  08
00B6C:  MOVWF  x55
00B6E:  CLRF   x56
00B70:  CLRF   x52
00B72:  SETF   x57
00B74:  CLRF   F61
00B76:  MOVLW  94
00B78:  MOVWF  x5B
....................    output_high(EN_EXC);
00B7A:  MOVLW  E8
00B7C:  MOVWF  F8B
00B7E:  BSF    F86.0
....................    set_adc_channel(vMonN15); // internal MUX
00B80:  MOVF   x5A,W
00B82:  ANDLW  3F
00B84:  MOVWF  01
00B86:  MOVLW  06
00B88:  MOVWF  x5A
00B8A:  BTFSS  x5B.7
00B8C:  BRA    0B9C
00B8E:  MOVF   01,W
00B90:  SUBLW  06
00B92:  BZ    0B9C
00B94:  BSF    x5B.0
00B96:  NOP   
00B98:  BTFSC  x5B.0
00B9A:  BRA    0B98
....................    delay_ms(10);
00B9C:  MOVLW  0A
00B9E:  MOVLB  6
00BA0:  MOVWF  x98
00BA2:  MOVLB  0
00BA4:  RCALL  0438
....................    read_adc(ADC_START_ONLY);
00BA6:  MOVLB  F
00BA8:  BSF    x5B.0
00BAA:  NOP   
....................    setup_external_ADCs();
00BAC:  MOVLB  0
00BAE:  BRA    098E
....................    intTimeoutReg = sensorSampleRate;
00BB0:  MOVLB  1
00BB2:  CLRF   x64
00BB4:  MOVLW  32
00BB6:  MOVWF  x63
00BB8:  MOVLB  0
00BBA:  GOTO   A658 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <control.h>
.................... #ifndef control
.................... #define control
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0.3,0.1,0,0,0,0,0},
....................    {0.01,0.3,0.1,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <pid.h>
.................... #ifndef pidcontroller
.................... #define pidcontroller
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0.3,0.1,0,0,0,0,0},
....................    {0.01,0.3,0.1,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float32)(unsigned int16)y;
.................... 
....................  else if (y < 10000000.0)
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
....................       res = 32768.0*(float32)l;
....................       res += (float32)(unsigned int16)y;
....................    }
.................... 
....................  else
....................   res = y;
.................... 
....................  y = y - (float32)(unsigned int16)y;
.................... 
....................  if (s)
....................   res = -res;
.................... 
....................  if (y != 0)
....................  {
....................   if (s == 1 && n == 0)
....................    res -= 1.0;
.................... 
....................   if (s == 0 && n == 1)
....................    res += 1.0;
....................  }
....................  if (x == 0)
....................     res = 0;
.................... 
....................  return (res);
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl[0]*y2 + pl[1];
.................... 
....................       r = ql[0]*y2 + ql[1];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
....................          r = -(float32)-n;
....................       else
....................          r = (float32)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* UPDATE the Control Variable (CV)                                          */
.................... /*****************************************************************************/
.................... void pid_update (channelMap ch){
*
0475E:  MOVLB  6
04760:  MOVF   x94,W
04762:  MULLW  20
04764:  MOVF   FF3,W
04766:  CLRF   xA2
04768:  MOVWF  xA1
0476A:  MOVLW  0C
0476C:  ADDWF  xA1,W
0476E:  MOVWF  01
04770:  MOVLW  00
04772:  ADDWFC xA2,W
04774:  MOVWF  03
04776:  MOVF   01,W
04778:  ADDLW  20
0477A:  MOVWF  FE9
0477C:  MOVLW  00
0477E:  ADDWFC 03,W
04780:  MOVWF  FEA
04782:  MOVFF  FEF,6DF
04786:  MOVFF  FEC,6E0
0478A:  MOVFF  FEC,6E1
0478E:  MOVFF  FEC,6E2
04792:  MOVF   x94,W
04794:  MULLW  20
04796:  MOVF   FF3,W
04798:  CLRF   xA6
0479A:  MOVWF  xA5
0479C:  MOVLW  10
0479E:  ADDWF  xA5,W
047A0:  MOVWF  01
047A2:  MOVLW  00
047A4:  ADDWFC xA6,W
047A6:  MOVWF  03
047A8:  MOVF   01,W
047AA:  ADDLW  20
047AC:  MOVWF  FE9
047AE:  MOVLW  00
047B0:  ADDWFC 03,W
047B2:  MOVWF  FEA
047B4:  MOVFF  FEF,6E3
047B8:  MOVFF  FEC,01
047BC:  MOVFF  FEC,02
047C0:  MOVFF  FEC,03
047C4:  MOVFF  FEA,6A6
047C8:  MOVFF  FE9,6A5
047CC:  BSF    FD8.1
047CE:  MOVFF  03,6E6
047D2:  MOVFF  02,6E5
047D6:  MOVFF  01,6E4
047DA:  MOVLB  0
047DC:  CALL   0F30
047E0:  MOVFF  6A6,FEA
047E4:  MOVFF  6A5,FE9
047E8:  MOVFF  03,698
047EC:  MOVFF  02,697
047F0:  MOVFF  01,696
047F4:  MOVFF  00,695
....................    float err = PID[ch].SP - PID[ch].PV;  // error = set value - measured
....................    
....................    PID[ch].I += err*PID[ch].kI;
047F8:  MOVLB  6
047FA:  MOVF   x94,W
047FC:  MULLW  20
047FE:  MOVF   FF3,W
04800:  CLRF   xA2
04802:  MOVWF  xA1
04804:  MOVLW  1C
04806:  ADDWF  xA1,W
04808:  MOVWF  01
0480A:  MOVLW  00
0480C:  ADDWFC xA2,W
0480E:  MOVWF  03
04810:  MOVF   01,W
04812:  ADDLW  20
04814:  MOVWF  01
04816:  MOVLW  00
04818:  ADDWFC 03,F
0481A:  MOVFF  01,6A1
0481E:  MOVFF  03,6A2
04822:  MOVFF  03,FEA
04826:  MOVFF  01,FE9
0482A:  MOVFF  FEF,6A3
0482E:  MOVFF  FEC,6A4
04832:  MOVFF  FEC,6A5
04836:  MOVFF  FEC,6A6
0483A:  MOVF   x94,W
0483C:  MULLW  20
0483E:  MOVF   FF3,W
04840:  CLRF   xA8
04842:  MOVWF  xA7
04844:  MOVLW  04
04846:  ADDWF  xA7,W
04848:  MOVWF  01
0484A:  MOVLW  00
0484C:  ADDWFC xA8,W
0484E:  MOVWF  03
04850:  MOVF   01,W
04852:  ADDLW  20
04854:  MOVWF  FE9
04856:  MOVLW  00
04858:  ADDWFC 03,W
0485A:  MOVWF  FEA
0485C:  MOVFF  FEF,6E4
04860:  MOVFF  FEC,01
04864:  MOVFF  FEC,02
04868:  MOVFF  FEC,03
0486C:  MOVFF  698,6E3
04870:  MOVFF  697,6E2
04874:  MOVFF  696,6E1
04878:  MOVFF  695,6E0
0487C:  MOVFF  03,6E7
04880:  MOVFF  02,6E6
04884:  MOVFF  01,6E5
04888:  MOVLB  0
0488A:  CALL   0E3A
0488E:  BCF    FD8.1
04890:  MOVFF  6A6,6E2
04894:  MOVFF  6A5,6E1
04898:  MOVFF  6A4,6E0
0489C:  MOVFF  6A3,6DF
048A0:  MOVFF  03,6E6
048A4:  MOVFF  02,6E5
048A8:  MOVFF  01,6E4
048AC:  MOVFF  00,6E3
048B0:  CALL   0F30
048B4:  MOVFF  6A2,FEA
048B8:  MOVFF  6A1,FE9
048BC:  MOVFF  00,FEF
048C0:  MOVFF  01,FEC
048C4:  MOVFF  02,FEC
048C8:  MOVFF  03,FEC
....................    if (PID[ch].I > op_upper_bound) PID[ch].I = op_upper_bound; // anti-windup
048CC:  MOVLB  6
048CE:  MOVF   x94,W
048D0:  MULLW  20
048D2:  MOVF   FF3,W
048D4:  CLRF   xA2
048D6:  MOVWF  xA1
048D8:  MOVLW  1C
048DA:  ADDWF  xA1,W
048DC:  MOVWF  01
048DE:  MOVLW  00
048E0:  ADDWFC xA2,W
048E2:  MOVWF  03
048E4:  MOVF   01,W
048E6:  ADDLW  20
048E8:  MOVWF  FE9
048EA:  MOVLW  00
048EC:  ADDWFC 03,W
048EE:  MOVWF  FEA
048F0:  MOVFF  FEF,6DF
048F4:  MOVFF  FEC,6A2
048F8:  MOVFF  FEC,6E1
048FC:  MOVFF  FEC,6E2
04900:  CLRF   xDE
04902:  CLRF   xDD
04904:  MOVLW  7C
04906:  MOVWF  xDC
04908:  MOVLW  84
0490A:  MOVWF  xDB
0490C:  MOVFF  6A2,6E0
04910:  MOVLB  0
04912:  CALL   1E18
04916:  BNC   494A
04918:  MOVLB  6
0491A:  MOVF   x94,W
0491C:  MULLW  20
0491E:  MOVF   FF3,W
04920:  CLRF   xA2
04922:  MOVWF  xA1
04924:  MOVLW  1C
04926:  ADDWF  xA1,W
04928:  MOVWF  01
0492A:  MOVLW  00
0492C:  ADDWFC xA2,W
0492E:  MOVWF  03
04930:  MOVF   01,W
04932:  ADDLW  20
04934:  MOVWF  FE9
04936:  MOVLW  00
04938:  ADDWFC 03,W
0493A:  MOVWF  FEA
0493C:  MOVLW  84
0493E:  MOVWF  FEF
04940:  MOVLW  7C
04942:  MOVWF  FEC
04944:  CLRF   FEC
04946:  CLRF   FEC
04948:  BRA    49C6
....................    else if (PID[ch].I < op_lower_bound) PID[ch].I = op_lower_bound;
0494A:  MOVLB  6
0494C:  MOVF   x94,W
0494E:  MULLW  20
04950:  MOVF   FF3,W
04952:  CLRF   xA2
04954:  MOVWF  xA1
04956:  MOVLW  1C
04958:  ADDWF  xA1,W
0495A:  MOVWF  01
0495C:  MOVLW  00
0495E:  ADDWFC xA2,W
04960:  MOVWF  03
04962:  MOVF   01,W
04964:  ADDLW  20
04966:  MOVWF  FE9
04968:  MOVLW  00
0496A:  ADDWFC 03,W
0496C:  MOVWF  FEA
0496E:  MOVFF  FEF,6DB
04972:  MOVFF  FEC,6A2
04976:  MOVFF  FEC,6DD
0497A:  MOVFF  FEC,6DE
0497E:  MOVFF  6A2,6DC
04982:  CLRF   xE2
04984:  CLRF   xE1
04986:  MOVLW  FC
04988:  MOVWF  xE0
0498A:  MOVLW  84
0498C:  MOVWF  xDF
0498E:  MOVLB  0
04990:  CALL   1E18
04994:  BNC   49C8
04996:  MOVLB  6
04998:  MOVF   x94,W
0499A:  MULLW  20
0499C:  MOVF   FF3,W
0499E:  CLRF   xA2
049A0:  MOVWF  xA1
049A2:  MOVLW  1C
049A4:  ADDWF  xA1,W
049A6:  MOVWF  01
049A8:  MOVLW  00
049AA:  ADDWFC xA2,W
049AC:  MOVWF  03
049AE:  MOVF   01,W
049B0:  ADDLW  20
049B2:  MOVWF  FE9
049B4:  MOVLW  00
049B6:  ADDWFC 03,W
049B8:  MOVWF  FEA
049BA:  MOVLW  84
049BC:  MOVWF  FEF
049BE:  MOVLW  FC
049C0:  MOVWF  FEC
049C2:  CLRF   FEC
049C4:  CLRF   FEC
049C6:  MOVLB  0
....................    
....................    float P = err * PID[ch].kP;  // proportional value
....................    
....................    float D = PID[ch].kD * (PID[ch].PV - PID[ch].PVold);  // derivative value
049C8:  MOVLB  6
049CA:  MOVF   x94,W
049CC:  MULLW  20
049CE:  MOVF   FF3,W
049D0:  CLRF   xA2
049D2:  MOVWF  xA1
049D4:  MOVLW  20
049D6:  ADDWF  xA1,W
049D8:  MOVWF  FE9
049DA:  MOVLW  00
049DC:  ADDWFC xA2,W
049DE:  MOVWF  FEA
049E0:  MOVFF  FEF,6E4
049E4:  MOVFF  FEC,01
049E8:  MOVFF  FEC,02
049EC:  MOVFF  FEC,03
049F0:  MOVFF  698,6E3
049F4:  MOVFF  697,6E2
049F8:  MOVFF  696,6E1
049FC:  MOVFF  695,6E0
04A00:  MOVFF  03,6E7
04A04:  MOVFF  02,6E6
04A08:  MOVFF  01,6E5
04A0C:  MOVLB  0
04A0E:  CALL   0E3A
04A12:  MOVFF  03,69C
04A16:  MOVFF  02,69B
04A1A:  MOVFF  01,69A
04A1E:  MOVFF  00,699
04A22:  MOVLB  6
04A24:  MOVF   x94,W
04A26:  MULLW  20
04A28:  MOVF   FF3,W
04A2A:  CLRF   xA4
04A2C:  MOVWF  xA3
04A2E:  MOVLW  08
04A30:  ADDWF  xA3,W
04A32:  MOVWF  01
04A34:  MOVLW  00
04A36:  ADDWFC xA4,W
04A38:  MOVWF  03
04A3A:  MOVF   01,W
04A3C:  ADDLW  20
04A3E:  MOVWF  FE9
04A40:  MOVLW  00
04A42:  ADDWFC 03,W
04A44:  MOVWF  FEA
04A46:  MOVFF  FEF,6A3
04A4A:  MOVFF  FEC,6A4
04A4E:  MOVFF  FEC,6A5
04A52:  MOVFF  FEC,6A6
04A56:  MOVF   x94,W
04A58:  MULLW  20
04A5A:  MOVF   FF3,W
04A5C:  CLRF   xA8
04A5E:  MOVWF  xA7
04A60:  MOVLW  10
04A62:  ADDWF  xA7,W
04A64:  MOVWF  01
04A66:  MOVLW  00
04A68:  ADDWFC xA8,W
04A6A:  MOVWF  03
04A6C:  MOVF   01,W
04A6E:  ADDLW  20
04A70:  MOVWF  FE9
04A72:  MOVLW  00
04A74:  ADDWFC 03,W
04A76:  MOVWF  FEA
04A78:  MOVFF  FEF,6DF
04A7C:  MOVFF  FEC,6E0
04A80:  MOVFF  FEC,6E1
04A84:  MOVFF  FEC,6E2
04A88:  MOVF   x94,W
04A8A:  MULLW  20
04A8C:  MOVF   FF3,W
04A8E:  CLRF   xAC
04A90:  MOVWF  xAB
04A92:  MOVLW  14
04A94:  ADDWF  xAB,W
04A96:  MOVWF  01
04A98:  MOVLW  00
04A9A:  ADDWFC xAC,W
04A9C:  MOVWF  03
04A9E:  MOVF   01,W
04AA0:  ADDLW  20
04AA2:  MOVWF  FE9
04AA4:  MOVLW  00
04AA6:  ADDWFC 03,W
04AA8:  MOVWF  FEA
04AAA:  MOVFF  FEF,6E3
04AAE:  MOVFF  FEC,01
04AB2:  MOVFF  FEC,02
04AB6:  MOVFF  FEC,03
04ABA:  MOVFF  FEA,6AC
04ABE:  MOVFF  FE9,6AB
04AC2:  BSF    FD8.1
04AC4:  MOVFF  03,6E6
04AC8:  MOVFF  02,6E5
04ACC:  MOVFF  01,6E4
04AD0:  MOVLB  0
04AD2:  CALL   0F30
04AD6:  MOVFF  6AC,FEA
04ADA:  MOVFF  6AB,FE9
04ADE:  MOVFF  6A6,6E3
04AE2:  MOVFF  6A5,6E2
04AE6:  MOVFF  6A4,6E1
04AEA:  MOVFF  6A3,6E0
04AEE:  MOVFF  03,6E7
04AF2:  MOVFF  02,6E6
04AF6:  MOVFF  01,6E5
04AFA:  MOVFF  00,6E4
04AFE:  CALL   0E3A
04B02:  MOVFF  03,6A0
04B06:  MOVFF  02,69F
04B0A:  MOVFF  01,69E
04B0E:  MOVFF  00,69D
....................    
....................    PID[ch].CV = P + PID[ch].I + D;  // new control variable
04B12:  MOVLB  6
04B14:  MOVF   x94,W
04B16:  MULLW  20
04B18:  MOVF   FF3,W
04B1A:  CLRF   xA2
04B1C:  MOVWF  xA1
04B1E:  MOVLW  18
04B20:  ADDWF  xA1,W
04B22:  MOVWF  01
04B24:  MOVLW  00
04B26:  ADDWFC xA2,W
04B28:  MOVWF  03
04B2A:  MOVF   01,W
04B2C:  ADDLW  20
04B2E:  MOVWF  01
04B30:  MOVLW  00
04B32:  ADDWFC 03,F
04B34:  MOVFF  01,6A1
04B38:  MOVFF  03,6A2
04B3C:  MOVF   x94,W
04B3E:  MULLW  20
04B40:  MOVF   FF3,W
04B42:  CLRF   xA4
04B44:  MOVWF  xA3
04B46:  MOVLW  1C
04B48:  ADDWF  xA3,W
04B4A:  MOVWF  01
04B4C:  MOVLW  00
04B4E:  ADDWFC xA4,W
04B50:  MOVWF  03
04B52:  MOVF   01,W
04B54:  ADDLW  20
04B56:  MOVWF  FE9
04B58:  MOVLW  00
04B5A:  ADDWFC 03,W
04B5C:  MOVWF  FEA
04B5E:  MOVFF  FEF,6E3
04B62:  MOVFF  FEC,01
04B66:  MOVFF  FEC,02
04B6A:  MOVFF  FEC,03
04B6E:  MOVFF  FEA,6A4
04B72:  MOVFF  FE9,6A3
04B76:  BCF    FD8.1
04B78:  MOVFF  69C,6E2
04B7C:  MOVFF  69B,6E1
04B80:  MOVFF  69A,6E0
04B84:  MOVFF  699,6DF
04B88:  MOVFF  03,6E6
04B8C:  MOVFF  02,6E5
04B90:  MOVFF  01,6E4
04B94:  MOVLB  0
04B96:  CALL   0F30
04B9A:  MOVFF  6A4,FEA
04B9E:  MOVFF  6A3,FE9
04BA2:  MOVFF  03,6A8
04BA6:  MOVFF  02,6A7
04BAA:  MOVFF  01,6A6
04BAE:  MOVFF  00,6A5
04BB2:  BCF    FD8.1
04BB4:  MOVFF  03,6E2
04BB8:  MOVFF  02,6E1
04BBC:  MOVFF  01,6E0
04BC0:  MOVFF  00,6DF
04BC4:  MOVFF  6A0,6E6
04BC8:  MOVFF  69F,6E5
04BCC:  MOVFF  69E,6E4
04BD0:  MOVFF  69D,6E3
04BD4:  CALL   0F30
04BD8:  MOVFF  6A2,FEA
04BDC:  MOVFF  6A1,FE9
04BE0:  MOVFF  00,FEF
04BE4:  MOVFF  01,FEC
04BE8:  MOVFF  02,FEC
04BEC:  MOVFF  03,FEC
....................    if (PID[ch].CV > op_upper_bound) PID[ch].CV = op_upper_bound; // limit positive output
04BF0:  MOVLB  6
04BF2:  MOVF   x94,W
04BF4:  MULLW  20
04BF6:  MOVF   FF3,W
04BF8:  CLRF   xA2
04BFA:  MOVWF  xA1
04BFC:  MOVLW  18
04BFE:  ADDWF  xA1,W
04C00:  MOVWF  01
04C02:  MOVLW  00
04C04:  ADDWFC xA2,W
04C06:  MOVWF  03
04C08:  MOVF   01,W
04C0A:  ADDLW  20
04C0C:  MOVWF  FE9
04C0E:  MOVLW  00
04C10:  ADDWFC 03,W
04C12:  MOVWF  FEA
04C14:  MOVFF  FEF,6DF
04C18:  MOVFF  FEC,6A2
04C1C:  MOVFF  FEC,6E1
04C20:  MOVFF  FEC,6E2
04C24:  CLRF   xDE
04C26:  CLRF   xDD
04C28:  MOVLW  7C
04C2A:  MOVWF  xDC
04C2C:  MOVLW  84
04C2E:  MOVWF  xDB
04C30:  MOVFF  6A2,6E0
04C34:  MOVLB  0
04C36:  CALL   1E18
04C3A:  BNC   4C6E
04C3C:  MOVLB  6
04C3E:  MOVF   x94,W
04C40:  MULLW  20
04C42:  MOVF   FF3,W
04C44:  CLRF   xA2
04C46:  MOVWF  xA1
04C48:  MOVLW  18
04C4A:  ADDWF  xA1,W
04C4C:  MOVWF  01
04C4E:  MOVLW  00
04C50:  ADDWFC xA2,W
04C52:  MOVWF  03
04C54:  MOVF   01,W
04C56:  ADDLW  20
04C58:  MOVWF  FE9
04C5A:  MOVLW  00
04C5C:  ADDWFC 03,W
04C5E:  MOVWF  FEA
04C60:  MOVLW  84
04C62:  MOVWF  FEF
04C64:  MOVLW  7C
04C66:  MOVWF  FEC
04C68:  CLRF   FEC
04C6A:  CLRF   FEC
04C6C:  BRA    4CEA
....................    else if (PID[ch].CV < op_lower_bound) PID[ch].CV = op_lower_bound; // limit negative output
04C6E:  MOVLB  6
04C70:  MOVF   x94,W
04C72:  MULLW  20
04C74:  MOVF   FF3,W
04C76:  CLRF   xA2
04C78:  MOVWF  xA1
04C7A:  MOVLW  18
04C7C:  ADDWF  xA1,W
04C7E:  MOVWF  01
04C80:  MOVLW  00
04C82:  ADDWFC xA2,W
04C84:  MOVWF  03
04C86:  MOVF   01,W
04C88:  ADDLW  20
04C8A:  MOVWF  FE9
04C8C:  MOVLW  00
04C8E:  ADDWFC 03,W
04C90:  MOVWF  FEA
04C92:  MOVFF  FEF,6DB
04C96:  MOVFF  FEC,6A2
04C9A:  MOVFF  FEC,6DD
04C9E:  MOVFF  FEC,6DE
04CA2:  MOVFF  6A2,6DC
04CA6:  CLRF   xE2
04CA8:  CLRF   xE1
04CAA:  MOVLW  FC
04CAC:  MOVWF  xE0
04CAE:  MOVLW  84
04CB0:  MOVWF  xDF
04CB2:  MOVLB  0
04CB4:  CALL   1E18
04CB8:  BNC   4CEA
04CBA:  MOVLB  6
04CBC:  MOVF   x94,W
04CBE:  MULLW  20
04CC0:  MOVF   FF3,W
04CC2:  CLRF   xA2
04CC4:  MOVWF  xA1
04CC6:  MOVLW  18
04CC8:  ADDWF  xA1,W
04CCA:  MOVWF  01
04CCC:  MOVLW  00
04CCE:  ADDWFC xA2,W
04CD0:  MOVWF  03
04CD2:  MOVF   01,W
04CD4:  ADDLW  20
04CD6:  MOVWF  FE9
04CD8:  MOVLW  00
04CDA:  ADDWFC 03,W
04CDC:  MOVWF  FEA
04CDE:  MOVLW  84
04CE0:  MOVWF  FEF
04CE2:  MOVLW  FC
04CE4:  MOVWF  FEC
04CE6:  CLRF   FEC
04CE8:  CLRF   FEC
04CEA:  MOVLB  0
04CEC:  GOTO   4D64 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PID Task - looks for change to PV and updates CV                          */
.................... /*****************************************************************************/
.................... void pid_task(channelMap ch){
....................    static int index = 0;
....................    if (PID[ch].SP != PID[ch].PV) pid_update(ch);
04CF0:  MOVLB  6
04CF2:  MOVF   x93,W
04CF4:  MULLW  20
04CF6:  MOVF   FF3,W
04CF8:  CLRF   x95
04CFA:  MOVWF  x94
04CFC:  MOVLW  0C
04CFE:  ADDWF  x94,W
04D00:  MOVWF  01
04D02:  MOVLW  00
04D04:  ADDWFC x95,W
04D06:  MOVWF  03
04D08:  MOVF   01,W
04D0A:  ADDLW  20
04D0C:  MOVWF  FE9
04D0E:  MOVLW  00
04D10:  ADDWFC 03,W
04D12:  MOVWF  FEA
04D14:  MOVFF  FEF,6DB
04D18:  MOVFF  FEC,6DC
04D1C:  MOVFF  FEC,6DD
04D20:  MOVFF  FEC,6DE
04D24:  MOVF   x93,W
04D26:  MULLW  20
04D28:  MOVF   FF3,W
04D2A:  CLRF   x99
04D2C:  MOVWF  x98
04D2E:  MOVLW  10
04D30:  ADDWF  x98,W
04D32:  MOVWF  01
04D34:  MOVLW  00
04D36:  ADDWFC x99,W
04D38:  MOVWF  03
04D3A:  MOVF   01,W
04D3C:  ADDLW  20
04D3E:  MOVWF  FE9
04D40:  MOVLW  00
04D42:  ADDWFC 03,W
04D44:  MOVWF  FEA
04D46:  MOVFF  FEF,6DF
04D4A:  MOVFF  FEC,6E0
04D4E:  MOVFF  FEC,6E1
04D52:  MOVFF  FEC,6E2
04D56:  MOVLB  0
04D58:  CALL   1E18
04D5C:  BZ    4D64
04D5E:  MOVFF  693,694
04D62:  BRA    475E
....................    if ((index++) >= numChannels) index = 0;
04D64:  MOVLB  2
04D66:  MOVF   x06,W
04D68:  INCF   x06,F
04D6A:  SUBLW  01
04D6C:  BC    4D70
04D6E:  CLRF   x06
04D70:  MOVLB  0
04D72:  GOTO   4E5E (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... #pin_select SCK1=PIN_C3
.................... #pin_select SDO1=PIN_C2
.................... #use spi (MASTER, SPI1, BAUD=100000, MODE=2, STREAM=SPI_ctrl)
*
00BBE:  CLRF   03
00BC0:  MOVF   F91,W
00BC2:  MOVFF  695,F91
00BC6:  RRCF   F94,W
00BC8:  BNC   0BC6
00BCA:  MOVF   F91,W
00BCC:  MOVWF  02
00BCE:  MOVFF  694,F91
00BD2:  RRCF   F94,W
00BD4:  BNC   0BD2
00BD6:  MOVF   F91,W
00BD8:  MOVWF  01
00BDA:  MOVFF  693,F91
00BDE:  RRCF   F94,W
00BE0:  BNC   0BDE
00BE2:  MOVFF  F91,00
00BE6:  RETURN 0
.................... 
.................... #define DACfullScale 655.35 // full scale/100 because CV = %
.................... 
.................... /*****************************************************************************/
.................... /*  Inverts the output voltage ( -180V - 0V )                                */ 
.................... /*****************************************************************************/
.................... void invert_voltage(channelMap ch, BOOLEAN inv_v){
....................    if ( inv_v ) {
*
046BA:  MOVLB  6
046BC:  MOVF   x94,F
046BE:  BZ    470E
....................       if (chMap[0] == ch) output_low(INV_HVX);
046C0:  MOVLW  00
046C2:  MOVLB  0
046C4:  BTFSC  x60.0
046C6:  MOVLW  01
046C8:  MOVLB  6
046CA:  SUBWF  x93,W
046CC:  BNZ   46D4
046CE:  MOVLW  C4
046D0:  MOVWF  F88
046D2:  BCF    F83.4
....................       if (chMap[1] == ch) output_low(INV_HVY);
046D4:  MOVLW  00
046D6:  MOVLB  0
046D8:  BTFSC  x60.1
046DA:  MOVLW  01
046DC:  MOVLB  6
046DE:  SUBWF  x93,W
046E0:  BNZ   46E8
046E2:  MOVLW  C4
046E4:  MOVWF  F88
046E6:  BCF    F83.5
....................       dacVals[ch].invV = TRUE;
046E8:  MOVF   x93,W
046EA:  MULLW  03
046EC:  MOVF   FF3,W
046EE:  CLRF   x96
046F0:  MOVWF  x95
046F2:  MOVLW  02
046F4:  ADDWF  x95,W
046F6:  MOVWF  01
046F8:  MOVLW  00
046FA:  ADDWFC x96,W
046FC:  MOVWF  03
046FE:  MOVF   01,W
04700:  ADDLW  51
04702:  MOVWF  FE9
04704:  MOVLW  01
04706:  ADDWFC 03,W
04708:  MOVWF  FEA
0470A:  BSF    FEF.0
....................    }
0470C:  BRA    475A
....................    else {
....................       if (chMap[0] == ch) output_high(INV_HVX);
0470E:  MOVLW  00
04710:  MOVLB  0
04712:  BTFSC  x60.0
04714:  MOVLW  01
04716:  MOVLB  6
04718:  SUBWF  x93,W
0471A:  BNZ   4722
0471C:  MOVLW  C4
0471E:  MOVWF  F88
04720:  BSF    F83.4
....................       if (chMap[1] == ch) output_high(INV_HVY);
04722:  MOVLW  00
04724:  MOVLB  0
04726:  BTFSC  x60.1
04728:  MOVLW  01
0472A:  MOVLB  6
0472C:  SUBWF  x93,W
0472E:  BNZ   4736
04730:  MOVLW  C4
04732:  MOVWF  F88
04734:  BSF    F83.5
....................       dacVals[ch].invV = FALSE;
04736:  MOVF   x93,W
04738:  MULLW  03
0473A:  MOVF   FF3,W
0473C:  CLRF   x96
0473E:  MOVWF  x95
04740:  MOVLW  02
04742:  ADDWF  x95,W
04744:  MOVWF  01
04746:  MOVLW  00
04748:  ADDWFC x96,W
0474A:  MOVWF  03
0474C:  MOVF   01,W
0474E:  ADDLW  51
04750:  MOVWF  FE9
04752:  MOVLW  01
04754:  ADDWFC 03,W
04756:  MOVWF  FEA
04758:  BCF    FEF.0
....................    }
0475A:  MOVLB  0
0475C:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  Nano DAC's have a 16bit serial shift register. Data is sync'ed to output */ 
.................... /*****************************************************************************/
.................... void set_nanoDAC_outputs(channelMap ch){
*
04D76:  MOVLB  6
04D78:  CLRF   x92
04D7A:  CLRF   x91
....................    unsigned int16 txData = 0;
....................    
....................    // use manualOutputValues if channel is manual mode
....................    // else, use PID control variable
....................    if (chMode[ch] == MANUAL){
04D7C:  MOVFF  690,69D
04D80:  CLRF   x9F
04D82:  MOVLW  61
04D84:  MOVWF  x9E
04D86:  MOVLB  0
04D88:  RCALL  4684
04D8A:  MOVF   01,F
04D8C:  BNZ   4E58
....................       if ( manualOutputValues[ch] < 0) invert_voltage(ch, TRUE); 
04D8E:  MOVLB  6
04D90:  MOVF   x90,W
04D92:  MULLW  04
04D94:  MOVF   FF3,W
04D96:  CLRF   03
04D98:  ADDLW  EA
04D9A:  MOVWF  FE9
04D9C:  MOVLW  00
04D9E:  ADDWFC 03,W
04DA0:  MOVWF  FEA
04DA2:  MOVFF  FEF,6DB
04DA6:  MOVFF  FEC,6DC
04DAA:  MOVFF  FEC,6DD
04DAE:  MOVFF  FEC,6DE
04DB2:  CLRF   xE2
04DB4:  CLRF   xE1
04DB6:  CLRF   xE0
04DB8:  CLRF   xDF
04DBA:  MOVLB  0
04DBC:  CALL   1E18
04DC0:  BNC   4DD2
04DC2:  MOVFF  690,693
04DC6:  MOVLW  01
04DC8:  MOVLB  6
04DCA:  MOVWF  x94
04DCC:  MOVLB  0
04DCE:  RCALL  46BA
04DD0:  BRA    4DDE
....................       else                             invert_voltage(ch, FALSE);
04DD2:  MOVFF  690,693
04DD6:  MOVLB  6
04DD8:  CLRF   x94
04DDA:  MOVLB  0
04DDC:  RCALL  46BA
....................       
....................       txData = (unsigned int16)(abs(manualOutputValues[ch]) * DACfullScale);
04DDE:  MOVLB  6
04DE0:  MOVF   x90,W
04DE2:  MULLW  04
04DE4:  MOVF   FF3,W
04DE6:  CLRF   03
04DE8:  ADDLW  EA
04DEA:  MOVWF  FE9
04DEC:  MOVLW  00
04DEE:  ADDWFC 03,W
04DF0:  MOVWF  FEA
04DF2:  MOVFF  FEF,00
04DF6:  MOVFF  FEC,01
04DFA:  MOVFF  FEC,02
04DFE:  MOVFF  FEC,03
04E02:  BCF    01.7
04E04:  MOVFF  03,696
04E08:  MOVFF  02,695
04E0C:  MOVFF  01,694
04E10:  MOVFF  00,693
04E14:  MOVFF  03,6E3
04E18:  MOVFF  02,6E2
04E1C:  MOVFF  01,6E1
04E20:  MOVFF  00,6E0
04E24:  MOVLW  66
04E26:  MOVWF  xE7
04E28:  MOVLW  D6
04E2A:  MOVWF  xE6
04E2C:  MOVLW  23
04E2E:  MOVWF  xE5
04E30:  MOVLW  88
04E32:  MOVWF  xE4
04E34:  MOVLB  0
04E36:  CALL   0E3A
04E3A:  MOVFF  03,6DE
04E3E:  MOVFF  02,6DD
04E42:  MOVFF  01,6DC
04E46:  MOVFF  00,6DB
04E4A:  CALL   280C
04E4E:  MOVFF  02,692
04E52:  MOVFF  01,691
....................    }
04E56:  BRA    4F48
....................    else {
....................       pid_task(ch);
04E58:  MOVFF  690,693
04E5C:  BRA    4CF0
....................       if ( PID[(int)ch].CV < 0 ) invert_voltage(ch, TRUE); 
04E5E:  MOVLB  6
04E60:  MOVF   x90,W
04E62:  MULLW  20
04E64:  MOVF   FF3,W
04E66:  CLRF   x94
04E68:  MOVWF  x93
04E6A:  MOVLW  18
04E6C:  ADDWF  x93,W
04E6E:  MOVWF  01
04E70:  MOVLW  00
04E72:  ADDWFC x94,W
04E74:  MOVWF  03
04E76:  MOVF   01,W
04E78:  ADDLW  20
04E7A:  MOVWF  FE9
04E7C:  MOVLW  00
04E7E:  ADDWFC 03,W
04E80:  MOVWF  FEA
04E82:  MOVFF  FEF,6DB
04E86:  MOVFF  FEC,6DC
04E8A:  MOVFF  FEC,6DD
04E8E:  MOVFF  FEC,6DE
04E92:  CLRF   xE2
04E94:  CLRF   xE1
04E96:  CLRF   xE0
04E98:  CLRF   xDF
04E9A:  MOVLB  0
04E9C:  CALL   1E18
04EA0:  BNC   4EB2
04EA2:  MOVFF  690,693
04EA6:  MOVLW  01
04EA8:  MOVLB  6
04EAA:  MOVWF  x94
04EAC:  MOVLB  0
04EAE:  RCALL  46BA
04EB0:  BRA    4EC0
....................       else                       invert_voltage(ch, FALSE);
04EB2:  MOVFF  690,693
04EB6:  MOVLB  6
04EB8:  CLRF   x94
04EBA:  MOVLB  0
04EBC:  CALL   46BA
....................       
....................       txData = (unsigned int16)(abs(PID[(int)ch].CV) * DACfullScale);
04EC0:  MOVLB  6
04EC2:  MOVF   x90,W
04EC4:  MULLW  20
04EC6:  MOVF   FF3,W
04EC8:  CLRF   x94
04ECA:  MOVWF  x93
04ECC:  MOVLW  18
04ECE:  ADDWF  x93,W
04ED0:  MOVWF  01
04ED2:  MOVLW  00
04ED4:  ADDWFC x94,W
04ED6:  MOVWF  03
04ED8:  MOVF   01,W
04EDA:  ADDLW  20
04EDC:  MOVWF  FE9
04EDE:  MOVLW  00
04EE0:  ADDWFC 03,W
04EE2:  MOVWF  FEA
04EE4:  MOVFF  FEF,00
04EE8:  MOVFF  FEC,01
04EEC:  MOVFF  FEC,02
04EF0:  MOVFF  FEC,03
04EF4:  BCF    01.7
04EF6:  MOVFF  03,696
04EFA:  MOVFF  02,695
04EFE:  MOVFF  01,694
04F02:  MOVFF  00,693
04F06:  MOVFF  03,6E3
04F0A:  MOVFF  02,6E2
04F0E:  MOVFF  01,6E1
04F12:  MOVFF  00,6E0
04F16:  MOVLW  66
04F18:  MOVWF  xE7
04F1A:  MOVLW  D6
04F1C:  MOVWF  xE6
04F1E:  MOVLW  23
04F20:  MOVWF  xE5
04F22:  MOVLW  88
04F24:  MOVWF  xE4
04F26:  MOVLB  0
04F28:  CALL   0E3A
04F2C:  MOVFF  03,6DE
04F30:  MOVFF  02,6DD
04F34:  MOVFF  01,6DC
04F38:  MOVFF  00,6DB
04F3C:  CALL   280C
04F40:  MOVFF  02,692
04F44:  MOVFF  01,691
....................    }
....................    
....................    dacVals[ch].val = txData;
04F48:  MOVLB  6
04F4A:  MOVF   x90,W
04F4C:  MULLW  03
04F4E:  MOVF   FF3,W
04F50:  CLRF   x94
04F52:  MOVWF  x93
04F54:  MOVLW  51
04F56:  ADDWF  x93,W
04F58:  MOVWF  FE9
04F5A:  MOVLW  01
04F5C:  ADDWFC x94,W
04F5E:  MOVWF  FEA
04F60:  MOVFF  692,FEC
04F64:  MOVF   FED,F
04F66:  MOVFF  691,FEF
....................    
....................    // use channel map to decide which outputs channels to update
....................    // strobe _sync low to push data to the outputs
....................    if (chMap[0] == ch) output_high(_SYNC_X);
04F6A:  MOVLW  00
04F6C:  MOVLB  0
04F6E:  BTFSC  x60.0
04F70:  MOVLW  01
04F72:  MOVLB  6
04F74:  SUBWF  x90,W
04F76:  BNZ   4F7E
04F78:  MOVLW  E8
04F7A:  MOVWF  F8B
04F7C:  BSF    F86.2
....................    if (chMap[1] == ch) output_high(_SYNC_Y);
04F7E:  MOVLW  00
04F80:  MOVLB  0
04F82:  BTFSC  x60.1
04F84:  MOVLW  01
04F86:  MOVLB  6
04F88:  SUBWF  x90,W
04F8A:  BNZ   4F92
04F8C:  MOVLW  E8
04F8E:  MOVWF  F8B
04F90:  BSF    F86.1
....................    
....................    delay_ms(1);
04F92:  MOVLW  01
04F94:  MOVWF  x98
04F96:  MOVLB  0
04F98:  CALL   0438
....................    
....................    if (chMap[0] == ch) output_low(_SYNC_X);
04F9C:  MOVLW  00
04F9E:  BTFSC  x60.0
04FA0:  MOVLW  01
04FA2:  MOVLB  6
04FA4:  SUBWF  x90,W
04FA6:  BNZ   4FAE
04FA8:  MOVLW  E8
04FAA:  MOVWF  F8B
04FAC:  BCF    F86.2
....................    if (chMap[1] == ch) output_low(_SYNC_Y);
04FAE:  MOVLW  00
04FB0:  MOVLB  0
04FB2:  BTFSC  x60.1
04FB4:  MOVLW  01
04FB6:  MOVLB  6
04FB8:  SUBWF  x90,W
04FBA:  BNZ   4FC2
04FBC:  MOVLW  E8
04FBE:  MOVWF  F8B
04FC0:  BCF    F86.1
....................    delay_ms(1);
04FC2:  MOVLW  01
04FC4:  MOVWF  x98
04FC6:  MOVLB  0
04FC8:  CALL   0438
....................    
....................    // shift 16 bits of data
....................    spi_xfer(SPI_ctrl, txData, 24);
04FCC:  MOVLB  6
04FCE:  CLRF   x96
04FD0:  CLRF   x95
04FD2:  MOVFF  692,694
04FD6:  MOVFF  691,693
04FDA:  MOVLB  0
04FDC:  CALL   0BBE
....................    delay_ms(1);
04FE0:  MOVLW  01
04FE2:  MOVLB  6
04FE4:  MOVWF  x98
04FE6:  MOVLB  0
04FE8:  CALL   0438
....................    
....................    if (chMap[0] == ch) output_high(_SYNC_X);
04FEC:  MOVLW  00
04FEE:  BTFSC  x60.0
04FF0:  MOVLW  01
04FF2:  MOVLB  6
04FF4:  SUBWF  x90,W
04FF6:  BNZ   4FFE
04FF8:  MOVLW  E8
04FFA:  MOVWF  F8B
04FFC:  BSF    F86.2
....................    if (chMap[1] == ch) output_high(_SYNC_Y);
04FFE:  MOVLW  00
05000:  MOVLB  0
05002:  BTFSC  x60.1
05004:  MOVLW  01
05006:  MOVLB  6
05008:  SUBWF  x90,W
0500A:  BNZ   5012
0500C:  MOVLW  E8
0500E:  MOVWF  F8B
05010:  BSF    F86.1
05012:  MOVLB  0
05014:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  control task sets up the outputs channels                                */ 
.................... /*****************************************************************************/
.................... void control_task(){
....................    static int state = 0;
....................    
....................    switch (state)
05016:  MOVLB  2
05018:  MOVF   x07,W
0501A:  XORLW  00
0501C:  MOVLB  0
0501E:  BZ    5026
05020:  XORLW  01
05022:  BZ    5038
05024:  BRA    5048
....................    {
....................       case 0:
....................          set_nanoDAC_outputs(chX);
05026:  MOVLB  6
05028:  CLRF   x90
0502A:  MOVLB  0
0502C:  RCALL  4D76
....................          state = 1;
0502E:  MOVLW  01
05030:  MOVLB  2
05032:  MOVWF  x07
....................       break;
05034:  MOVLB  0
05036:  BRA    5048
....................       case 1:
....................          set_nanoDAC_outputs(chY);
05038:  MOVLW  01
0503A:  MOVLB  6
0503C:  MOVWF  x90
0503E:  MOVLB  0
05040:  RCALL  4D76
....................          state = 0;
05042:  MOVLB  2
05044:  CLRF   x07
....................       break;
05046:  MOVLB  0
....................    }
05048:  GOTO   A674 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  control task sets up the outputs channels                                */ 
.................... /*****************************************************************************/
.................... void control_init(){
....................    spi_xfer(SPI_ctrl, 0, 24);
*
00BE8:  MOVLB  6
00BEA:  CLRF   x96
00BEC:  CLRF   x95
00BEE:  CLRF   x94
00BF0:  CLRF   x93
00BF2:  MOVLB  0
00BF4:  RCALL  0BBE
....................    output_low(_SYNC_X);
00BF6:  MOVLW  E8
00BF8:  MOVWF  F8B
00BFA:  BCF    F86.2
....................    output_low(_SYNC_Y);
00BFC:  MOVWF  F8B
00BFE:  BCF    F86.1
....................    output_high(_SYNC_X);
00C00:  MOVWF  F8B
00C02:  BSF    F86.2
....................    output_high(_SYNC_Y);
00C04:  MOVWF  F8B
00C06:  BSF    F86.1
00C08:  GOTO   A65C (RETURN)
.................... }
.................... #endif
.................... 
.................... #include <serialport.h>
.................... #ifndef serialPort
.................... #define serialPort
.................... #include <cmdBuffer.h>
.................... #ifndef cmd_buffer
.................... #define cmd_buffer
.................... 
.................... /*****************************************************************************/
.................... /* DIFCS COMMAND BUFFER                                                      */
.................... /* The beginning of a message is signified by an address record. The address */
.................... /* is 4 characters. The first 2 are the hardware identifier (TC - temperature*/
.................... /* controller, DC - difics controller, etc..) The second 2 characters dev-   */
.................... /* ice ID... Valid values are 00 thru 0F. A device ID of FF writes to all    */
.................... /* boards. This might be used to feed angles data to all listeners.          */
.................... /*****************************************************************************/
.................... 
.................... // t,p0,p1,p2,p3,p4,p5,p6
.................... // t is the start character, p0 is the address, p1 is command, p2-6 are params
.................... // these characters used for storing messages
.................... 
.................... #define startChr '~' // start character. Also diagnostic command type
.................... #define diagCmdType startChr
.................... #define endChr '\n'
.................... #define delimiter ','
.................... #define ignoreChr1 '\r'
.................... #define ignoreChr2 ' '
.................... #define noRecordFound (char)0xFF
.................... 
.................... #define numRecords 4
.................... #define numParam 7
.................... #define lenParam 25
.................... 
.................... #define useSerial
.................... //#define useTCPIP
.................... 
.................... typedef enum cmdMode {tcp, ser};
.................... 
.................... // this structure holds a command. This is used by the serial routine as well
.................... // as the TCP routine to store an incoming command + parameters
.................... // in the case of TCP socket id is also passed in this structure
.................... typedef struct cmd 
.................... {
....................    BOOLEAN full;        // if full, command is ready to execute
....................    unsigned int8 chrIndex;
....................    unsigned int8 paramIndex;
....................    unsigned int8 recReadIndex;
....................    unsigned int8 recWriteIndex;
....................    #ifdef useTCPIP
....................    TCP_SOCKET s;              // socket ID for TCP commands 
....................    #endif
....................    char t;
....................    char p[numParam][lenParam];   // only used with ~ type command
.................... };
.................... 
.................... #ifdef useSerial
.................... struct cmd SERcmd[numRecords]; // holds serial command 
.................... unsigned int8 SRI = 0; //usb readindex
.................... unsigned int8 SWI = 0; //usb write index
.................... #endif
.................... 
.................... #ifdef useTCPIP
.................... struct cmd TCPcmd[numRecords]; // holds TCP command
.................... unsigned int8 TRI = 0; //usb readindex
.................... unsigned int8 TWI = 0; //usb write index
.................... #endif
.................... 
.................... char retData[100]; // this is used to hold return data 
.................... 
.................... #ifdef useSerial
.................... /*****************************************************************************/
.................... /* RESET SER COMMAND -- ready for a new command                              */
.................... /*****************************************************************************/
.................... void resetSERcmd(unsigned int8 recNum)
.................... {
....................    if (recNum < numRecords)
*
00C2E:  MOVLB  6
00C30:  MOVF   x91,W
00C32:  SUBLW  03
00C34:  BTFSS  FD8.0
00C36:  BRA    0DA4
....................    {
....................       for (int i = 0; i <numParam; i ++)
00C38:  CLRF   x92
00C3A:  MOVF   x92,W
00C3C:  SUBLW  06
00C3E:  BNC   0C8E
....................       {
....................          SERcmd[recNum].p[i][0] = '\0';
00C40:  CLRF   xF2
00C42:  MOVFF  691,6F1
00C46:  CLRF   xF4
00C48:  MOVLW  B5
00C4A:  MOVWF  xF3
00C4C:  MOVLB  0
00C4E:  RCALL  0C0C
00C50:  MOVFF  02,694
00C54:  MOVFF  01,693
00C58:  MOVLW  06
00C5A:  MOVLB  6
00C5C:  ADDWF  x93,F
00C5E:  MOVLW  00
00C60:  ADDWFC x94,F
00C62:  CLRF   xF2
00C64:  MOVFF  692,6F1
00C68:  CLRF   xF4
00C6A:  MOVLW  19
00C6C:  MOVWF  xF3
00C6E:  MOVLB  0
00C70:  RCALL  0C0C
00C72:  MOVF   01,W
00C74:  MOVLB  6
00C76:  ADDWF  x93,F
00C78:  MOVF   02,W
00C7A:  ADDWFC x94,F
00C7C:  MOVLW  08
00C7E:  ADDWF  x93,W
00C80:  MOVWF  FE9
00C82:  MOVLW  02
00C84:  ADDWFC x94,W
00C86:  MOVWF  FEA
00C88:  CLRF   FEF
00C8A:  INCF   x92,F
00C8C:  BRA    0C3A
....................       }
....................       SERcmd[recNum].t = 0;
00C8E:  CLRF   xF2
00C90:  MOVFF  691,6F1
00C94:  CLRF   xF4
00C96:  MOVLW  B5
00C98:  MOVWF  xF3
00C9A:  MOVLB  0
00C9C:  RCALL  0C0C
00C9E:  MOVFF  01,693
00CA2:  MOVLW  05
00CA4:  MOVLB  6
00CA6:  ADDWF  01,W
00CA8:  MOVWF  01
00CAA:  MOVLW  00
00CAC:  ADDWFC 02,W
00CAE:  MOVWF  03
00CB0:  MOVF   01,W
00CB2:  ADDLW  08
00CB4:  MOVWF  FE9
00CB6:  MOVLW  02
00CB8:  ADDWFC 03,W
00CBA:  MOVWF  FEA
00CBC:  CLRF   FEF
....................       SERcmd[recNum].chrIndex = 0;
00CBE:  CLRF   xF2
00CC0:  MOVFF  691,6F1
00CC4:  CLRF   xF4
00CC6:  MOVLW  B5
00CC8:  MOVWF  xF3
00CCA:  MOVLB  0
00CCC:  RCALL  0C0C
00CCE:  MOVFF  01,693
00CD2:  MOVLW  01
00CD4:  MOVLB  6
00CD6:  ADDWF  01,W
00CD8:  MOVWF  01
00CDA:  MOVLW  00
00CDC:  ADDWFC 02,W
00CDE:  MOVWF  03
00CE0:  MOVF   01,W
00CE2:  ADDLW  08
00CE4:  MOVWF  FE9
00CE6:  MOVLW  02
00CE8:  ADDWFC 03,W
00CEA:  MOVWF  FEA
00CEC:  CLRF   FEF
....................       SERcmd[recNum].paramIndex = 0;
00CEE:  CLRF   xF2
00CF0:  MOVFF  691,6F1
00CF4:  CLRF   xF4
00CF6:  MOVLW  B5
00CF8:  MOVWF  xF3
00CFA:  MOVLB  0
00CFC:  RCALL  0C0C
00CFE:  MOVFF  01,693
00D02:  MOVLW  02
00D04:  MOVLB  6
00D06:  ADDWF  01,W
00D08:  MOVWF  01
00D0A:  MOVLW  00
00D0C:  ADDWFC 02,W
00D0E:  MOVWF  03
00D10:  MOVF   01,W
00D12:  ADDLW  08
00D14:  MOVWF  FE9
00D16:  MOVLW  02
00D18:  ADDWFC 03,W
00D1A:  MOVWF  FEA
00D1C:  CLRF   FEF
....................       SERcmd[recNum].recReadIndex = 0;
00D1E:  CLRF   xF2
00D20:  MOVFF  691,6F1
00D24:  CLRF   xF4
00D26:  MOVLW  B5
00D28:  MOVWF  xF3
00D2A:  MOVLB  0
00D2C:  RCALL  0C0C
00D2E:  MOVFF  01,693
00D32:  MOVLW  03
00D34:  MOVLB  6
00D36:  ADDWF  01,W
00D38:  MOVWF  01
00D3A:  MOVLW  00
00D3C:  ADDWFC 02,W
00D3E:  MOVWF  03
00D40:  MOVF   01,W
00D42:  ADDLW  08
00D44:  MOVWF  FE9
00D46:  MOVLW  02
00D48:  ADDWFC 03,W
00D4A:  MOVWF  FEA
00D4C:  CLRF   FEF
....................       SERcmd[recNum].recWriteIndex = 0;
00D4E:  CLRF   xF2
00D50:  MOVFF  691,6F1
00D54:  CLRF   xF4
00D56:  MOVLW  B5
00D58:  MOVWF  xF3
00D5A:  MOVLB  0
00D5C:  RCALL  0C0C
00D5E:  MOVFF  01,693
00D62:  MOVLW  04
00D64:  MOVLB  6
00D66:  ADDWF  01,W
00D68:  MOVWF  01
00D6A:  MOVLW  00
00D6C:  ADDWFC 02,W
00D6E:  MOVWF  03
00D70:  MOVF   01,W
00D72:  ADDLW  08
00D74:  MOVWF  FE9
00D76:  MOVLW  02
00D78:  ADDWFC 03,W
00D7A:  MOVWF  FEA
00D7C:  CLRF   FEF
....................       SERcmd[recNum].full = FALSE;
00D7E:  CLRF   xF2
00D80:  MOVFF  691,6F1
00D84:  CLRF   xF4
00D86:  MOVLW  B5
00D88:  MOVWF  xF3
00D8A:  MOVLB  0
00D8C:  RCALL  0C0C
00D8E:  MOVLW  08
00D90:  MOVLB  6
00D92:  ADDWF  01,W
00D94:  MOVWF  FE9
00D96:  MOVLW  02
00D98:  ADDWFC 02,W
00D9A:  MOVWF  FEA
00D9C:  BCF    FEF.0
....................       retData[0] = '\0';
00D9E:  MOVLB  4
00DA0:  CLRF   xDE
00DA2:  MOVLB  6
....................    }
00DA4:  MOVLB  0
00DA6:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next serial read index (SRI)                                          */
.................... /*****************************************************************************/
.................... BOOLEAN getNextSERReadIndex()
.................... {
....................    while (!SERcmd[SRI].full)
*
059F4:  MOVLB  6
059F6:  CLRF   xF2
059F8:  MOVFF  4DC,6F1
059FC:  CLRF   xF4
059FE:  MOVLW  B5
05A00:  MOVWF  xF3
05A02:  MOVLB  0
05A04:  CALL   0C0C
05A08:  MOVFF  02,692
05A0C:  MOVFF  01,691
05A10:  MOVLW  08
05A12:  MOVLB  6
05A14:  ADDWF  01,W
05A16:  MOVWF  FE9
05A18:  MOVLW  02
05A1A:  ADDWFC 02,W
05A1C:  MOVWF  FEA
05A1E:  BTFSC  FEF.0
05A20:  BRA    5A42
....................    {
....................       if (SRI == SWI) return FALSE;
05A22:  MOVLB  4
05A24:  MOVF   xDD,W
05A26:  SUBWF  xDC,W
05A28:  BNZ   5A30
05A2A:  MOVLW  00
05A2C:  MOVWF  01
05A2E:  BRA    5A48
....................       SRI +=1;
05A30:  MOVLW  01
05A32:  ADDWF  xDC,F
....................       if (SRI >= numRecords) SRI=0;
05A34:  MOVF   xDC,W
05A36:  SUBLW  03
05A38:  BC    5A3C
05A3A:  CLRF   xDC
05A3C:  MOVLB  0
05A3E:  BRA    59F4
05A40:  MOVLB  6
....................    }
....................    return TRUE;
05A42:  MOVLW  01
05A44:  MOVWF  01
05A46:  MOVLB  4
05A48:  MOVLB  0
05A4A:  GOTO   A1B6 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next serial write index (SWI)                                         */
.................... /*****************************************************************************/
.................... void setNextSERWriteIndex()
.................... {
....................    SWI +=1;
*
05080:  MOVLW  01
05082:  MOVLB  4
05084:  ADDWF  xDD,F
....................    if (SWI >= numRecords) SWI=0;
05086:  MOVF   xDD,W
05088:  SUBLW  03
0508A:  BC    508E
0508C:  CLRF   xDD
0508E:  MOVLB  0
05090:  RETURN 0
.................... }
.................... #endif
.................... 
.................... #ifdef useTCPIP
.................... /*****************************************************************************/
.................... /* RESET TCP COMMAND -- ready for a new command                              */
.................... /*****************************************************************************/
.................... void resetTCPcmd(unsigned int8 recNum)
.................... {
....................    if(recNum < numRecords)
....................    {
....................       for (int i = 0; i <numParam; i ++)
....................       {
....................          TCPcmd[recNum].p[i][0] = '\0';
....................       }
....................       TCPcmd[recNum].t = 0;
....................       TCPcmd[recNum].chrIndex = 0;
....................       TCPcmd[recNum].paramIndex = 0;
....................       TCPcmd[recNum].full = FALSE;
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next TCP read index (TRI)                                             */
.................... /*****************************************************************************/
.................... BOOLEAN getNextTCPReadIndex()
.................... {
....................    while (!TCPcmd[TRI].full)
....................    {
....................       if (TRI == TWI) return FALSE;
....................       TRI +=1;
....................       if (TRI >= numRecords) TRI=0;
....................    }
....................    return TRUE;
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next TCP write index (TWI)                                            */
.................... /*****************************************************************************/
.................... void setNextTCPWriteIndex()
.................... {
....................    TWI +=1;
....................    if (TWI >= numRecords) TWI=0;
.................... }
.................... #endif
.................... #endif
.................... 
.................... 
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
....................    output_b(portB_reset);
....................    output_c(portC_reset);
....................    output_d(portD_reset);
....................    output_e(portE_reset);
....................    
....................    port_a_pullups(portA_pullups);
....................    port_b_pullups(portB_pullups);
....................    port_c_pullups(portC_pullups);
....................    port_d_pullups(portD_pullups);
....................    port_e_pullups(portE_pullups);
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... #define use_RS485 // adds RX enable pin//
.................... 
.................... #define oneByteCmdTestValue 128
.................... #define UART_BUFFER_SIZE 60
.................... #define UART_EOT_CHAR1 0x0D //Carriage Return
.................... #define UART_EOT_CHAR2 0x0A //Line Feed
.................... #define UART_SOT_CHAR  '~' // START CHARACTER
.................... #define line_turnaround_char 0xFF
.................... 
.................... #bit UART_TXBuffer_Empty = 0x0FAC.1
.................... 
.................... char UART_BUFFER[UART_BUFFER_SIZE] = {0};
.................... unsigned int8 UART_WR_PTR = 0;
.................... unsigned int8 UART_RD_PTR = 0;
.................... boolean BYTES_AVAILABLE= FALSE;
.................... 
.................... #ifdef use_RS485
.................... #use rs232(baud=baudRate, xmit=TX_PIN, rcv=RX_PIN, enable=TX_ENABLE, stream=SERIAL, ERRORS)
*
000CA:  MOVLB  E
000CC:  BTFSS  xC8.5
000CE:  BRA    00CC
000D0:  MOVFF  F9C,581
000D4:  MOVLB  5
000D6:  MOVFF  F98,01
000DA:  BTFSS  x81.1
000DC:  BRA    00E2
000DE:  BCF    F9C.4
000E0:  BSF    F9C.4
000E2:  MOVLB  0
000E4:  GOTO   010C (RETURN)
*
05092:  MOVLW  93
05094:  MOVWF  F89
05096:  BSF    F84.5
05098:  MOVLB  E
0509A:  BTFSS  xC8.4
0509C:  BRA    509A
0509E:  MOVLW  93
050A0:  MOVWF  F89
050A2:  BSF    F84.5
050A4:  MOVLB  6
050A6:  MOVFF  6A6,F99
050AA:  NOP   
050AC:  BTFSS  F9D.1
050AE:  BRA    50AC
050B0:  MOVLW  93
050B2:  MOVWF  F89
050B4:  BCF    F84.5
050B6:  MOVLB  0
050B8:  RETURN 0
.................... #else
.................... #use rs232(baud=baudRate, xmit=TX_PIN, rcv=RX_PIN, stream=SERIAL)
.................... #endif
.................... 
.................... // Message format: [SOT]addr ,cmd, arg1, arg2, arg3[EOT]} 
.................... // arguments are optional
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* SERIAL PORT ISR                                                           */
.................... /*****************************************************************************/
.................... #INT_RDA
.................... void RX_isr()
*
000E8:  MOVLB  0
.................... {
....................    while (kbhit())
000EA:  MOVLB  E
000EC:  BTFSS  xC8.5
000EE:  BRA    012E
....................    {
....................       UART_BUFFER[UART_WR_PTR]=getch();
000F0:  CLRF   03
000F2:  MOVLB  5
000F4:  MOVF   x7E,W
000F6:  ADDLW  42
000F8:  MOVWF  FE9
000FA:  MOVLW  05
000FC:  ADDWFC 03,W
000FE:  MOVWF  FEA
00100:  MOVFF  FEA,717
00104:  MOVFF  FE9,716
00108:  MOVLB  0
0010A:  BRA    00CA
0010C:  MOVFF  717,FEA
00110:  MOVFF  716,FE9
00114:  MOVFF  01,FEF
....................       UART_WR_PTR +=1;
00118:  MOVLW  01
0011A:  MOVLB  5
0011C:  ADDWF  x7E,F
....................       if (UART_WR_PTR>=UART_BUFFER_SIZE) UART_WR_PTR=0;
0011E:  MOVF   x7E,W
00120:  SUBLW  3B
00122:  BC    0126
00124:  CLRF   x7E
....................       BYTES_AVAILABLE=TRUE;
00126:  BSF    x80.0
00128:  MOVLB  0
0012A:  BRA    00EA
0012C:  MOVLB  E
....................    }
0012E:  BCF    xC8.5
00130:  MOVLB  0
00132:  GOTO   006E
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get character from buffer                                                 */
.................... /*****************************************************************************/
.................... char getchFromBuffer()
*
0504C:  CLRF   03
0504E:  MOVLB  5
05050:  MOVF   x7F,W
05052:  ADDLW  42
05054:  MOVWF  FE9
05056:  MOVLW  05
05058:  ADDWFC 03,W
0505A:  MOVWF  FEA
0505C:  MOVFF  FEF,691
.................... {
....................    char data = UART_BUFFER[UART_RD_PTR];
....................    UART_RD_PTR +=1;
05060:  MOVLW  01
05062:  ADDWF  x7F,F
....................    if (UART_RD_PTR>=UART_BUFFER_SIZE) UART_RD_PTR=0;
05064:  MOVF   x7F,W
05066:  SUBLW  3B
05068:  BC    506C
0506A:  CLRF   x7F
....................    if (UART_RD_PTR == UART_WR_PTR) BYTES_AVAILABLE=FALSE;
0506C:  MOVF   x7E,W
0506E:  SUBWF  x7F,W
05070:  BNZ   5074
05072:  BCF    x80.0
....................    return data;
05074:  MOVLB  6
05076:  MOVFF  691,01
0507A:  MOVLB  0
0507C:  GOTO   5120 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Serial Task transfers bytes to command buffer                             */
.................... /*****************************************************************************/
.................... void serial_task()
.................... {
....................    while(BYTES_AVAILABLE && SERcmd[SWI].full==FALSE)
*
050DE:  MOVLB  5
050E0:  BTFSS  x80.0
050E2:  BRA    55D0
050E4:  MOVLB  6
050E6:  CLRF   xF2
050E8:  MOVFF  4DD,6F1
050EC:  CLRF   xF4
050EE:  MOVLW  B5
050F0:  MOVWF  xF3
050F2:  MOVLB  0
050F4:  CALL   0C0C
050F8:  MOVFF  02,692
050FC:  MOVFF  01,691
05100:  MOVLW  08
05102:  MOVLB  6
05104:  ADDWF  01,W
05106:  MOVWF  01
05108:  MOVLW  02
0510A:  ADDWFC 02,W
0510C:  MOVWF  03
0510E:  MOVFF  01,FE9
05112:  MOVWF  FEA
05114:  BTFSS  FEF.0
05116:  BRA    511C
05118:  MOVLB  5
0511A:  BRA    55D0
....................    {  
....................       unsigned int8 rxChar = getchFromBuffer();
0511C:  MOVLB  0
0511E:  BRA    504C
05120:  MOVFF  01,690
....................       if (rxChar == ignoreChr1 || rxChar == ignoreChr2)
05124:  MOVLB  6
05126:  MOVF   x90,W
05128:  SUBLW  0D
0512A:  BZ    5132
0512C:  MOVF   x90,W
0512E:  SUBLW  20
05130:  BNZ   5134
....................       {
....................       }
05132:  BRA    55CA
....................       else if (rxChar == UART_SOT_CHAR)
05134:  MOVF   x90,W
05136:  SUBLW  7E
05138:  BNZ   517C
....................       {
....................          resetSERcmd(SWI);
0513A:  MOVFF  4DD,691
0513E:  MOVLB  0
05140:  CALL   0C2E
....................          SERcmd[SWI].t = rxChar;
05144:  MOVLB  6
05146:  CLRF   xF2
05148:  MOVFF  4DD,6F1
0514C:  CLRF   xF4
0514E:  MOVLW  B5
05150:  MOVWF  xF3
05152:  MOVLB  0
05154:  CALL   0C0C
05158:  MOVFF  01,691
0515C:  MOVLW  05
0515E:  MOVLB  6
05160:  ADDWF  01,W
05162:  MOVWF  01
05164:  MOVLW  00
05166:  ADDWFC 02,W
05168:  MOVWF  03
0516A:  MOVF   01,W
0516C:  ADDLW  08
0516E:  MOVWF  FE9
05170:  MOVLW  02
05172:  ADDWFC 03,W
05174:  MOVWF  FEA
05176:  MOVFF  690,FEF
....................       }
0517A:  BRA    55CA
....................       else if (rxChar >= oneByteCmdTestValue)
0517C:  MOVF   x90,W
0517E:  SUBLW  7F
05180:  BC    51EC
....................       {
....................          resetSERcmd(SWI);
05182:  MOVFF  4DD,691
05186:  MOVLB  0
05188:  CALL   0C2E
....................          SERcmd[SWI].t = rxChar;
0518C:  MOVLB  6
0518E:  CLRF   xF2
05190:  MOVFF  4DD,6F1
05194:  CLRF   xF4
05196:  MOVLW  B5
05198:  MOVWF  xF3
0519A:  MOVLB  0
0519C:  CALL   0C0C
051A0:  MOVFF  01,691
051A4:  MOVLW  05
051A6:  MOVLB  6
051A8:  ADDWF  01,W
051AA:  MOVWF  01
051AC:  MOVLW  00
051AE:  ADDWFC 02,W
051B0:  MOVWF  03
051B2:  MOVF   01,W
051B4:  ADDLW  08
051B6:  MOVWF  FE9
051B8:  MOVLW  02
051BA:  ADDWFC 03,W
051BC:  MOVWF  FEA
051BE:  MOVFF  690,FEF
....................          SERcmd[SWI].full = TRUE;
051C2:  CLRF   xF2
051C4:  MOVFF  4DD,6F1
051C8:  CLRF   xF4
051CA:  MOVLW  B5
051CC:  MOVWF  xF3
051CE:  MOVLB  0
051D0:  CALL   0C0C
051D4:  MOVLW  08
051D6:  MOVLB  6
051D8:  ADDWF  01,W
051DA:  MOVWF  FE9
051DC:  MOVLW  02
051DE:  ADDWFC 02,W
051E0:  MOVWF  FEA
051E2:  BSF    FEF.0
....................          setNextSERWriteIndex();
051E4:  MOVLB  0
051E6:  RCALL  5080
....................       }
051E8:  BRA    55C8
051EA:  MOVLB  6
....................       else if (rxChar == UART_EOT_CHAR2)
051EC:  MOVF   x90,W
051EE:  SUBLW  0A
051F0:  BTFSS  FD8.2
051F2:  BRA    52F8
....................       {
....................          SERcmd[SWI].full = TRUE;
051F4:  CLRF   xF2
051F6:  MOVFF  4DD,6F1
051FA:  CLRF   xF4
051FC:  MOVLW  B5
051FE:  MOVWF  xF3
05200:  MOVLB  0
05202:  CALL   0C0C
05206:  MOVLW  08
05208:  MOVLB  6
0520A:  ADDWF  01,W
0520C:  MOVWF  FE9
0520E:  MOVLW  02
05210:  ADDWFC 02,W
05212:  MOVWF  FEA
05214:  BSF    FEF.0
....................          SERcmd[SWI].recWriteIndex = SERcmd[SWI].paramIndex;
05216:  CLRF   xF2
05218:  MOVFF  4DD,6F1
0521C:  CLRF   xF4
0521E:  MOVLW  B5
05220:  MOVWF  xF3
05222:  MOVLB  0
05224:  CALL   0C0C
05228:  MOVFF  01,691
0522C:  MOVLW  04
0522E:  MOVLB  6
05230:  ADDWF  01,W
05232:  MOVWF  01
05234:  MOVLW  00
05236:  ADDWFC 02,W
05238:  MOVWF  03
0523A:  MOVF   01,W
0523C:  ADDLW  08
0523E:  MOVWF  01
05240:  MOVLW  02
05242:  ADDWFC 03,F
05244:  MOVFF  01,691
05248:  MOVFF  03,692
0524C:  CLRF   xF2
0524E:  MOVFF  4DD,6F1
05252:  CLRF   xF4
05254:  MOVLW  B5
05256:  MOVWF  xF3
05258:  MOVLB  0
0525A:  CALL   0C0C
0525E:  MOVFF  01,693
05262:  MOVLW  02
05264:  MOVLB  6
05266:  ADDWF  01,W
05268:  MOVWF  01
0526A:  MOVLW  00
0526C:  ADDWFC 02,W
0526E:  MOVWF  03
05270:  MOVF   01,W
05272:  ADDLW  08
05274:  MOVWF  FE9
05276:  MOVLW  02
05278:  ADDWFC 03,W
0527A:  MOVWF  FEA
0527C:  MOVFF  FEF,693
05280:  MOVFF  692,FEA
05284:  MOVFF  691,FE9
05288:  MOVFF  693,FEF
....................          SERcmd[SWI].chrIndex = 0;
0528C:  CLRF   xF2
0528E:  MOVFF  4DD,6F1
05292:  CLRF   xF4
05294:  MOVLW  B5
05296:  MOVWF  xF3
05298:  MOVLB  0
0529A:  CALL   0C0C
0529E:  MOVFF  01,691
052A2:  MOVLW  01
052A4:  MOVLB  6
052A6:  ADDWF  01,W
052A8:  MOVWF  01
052AA:  MOVLW  00
052AC:  ADDWFC 02,W
052AE:  MOVWF  03
052B0:  MOVF   01,W
052B2:  ADDLW  08
052B4:  MOVWF  FE9
052B6:  MOVLW  02
052B8:  ADDWFC 03,W
052BA:  MOVWF  FEA
052BC:  CLRF   FEF
....................          SERcmd[SWI].paramIndex = 0;
052BE:  CLRF   xF2
052C0:  MOVFF  4DD,6F1
052C4:  CLRF   xF4
052C6:  MOVLW  B5
052C8:  MOVWF  xF3
052CA:  MOVLB  0
052CC:  CALL   0C0C
052D0:  MOVFF  01,691
052D4:  MOVLW  02
052D6:  MOVLB  6
052D8:  ADDWF  01,W
052DA:  MOVWF  01
052DC:  MOVLW  00
052DE:  ADDWFC 02,W
052E0:  MOVWF  03
052E2:  MOVF   01,W
052E4:  ADDLW  08
052E6:  MOVWF  FE9
052E8:  MOVLW  02
052EA:  ADDWFC 03,W
052EC:  MOVWF  FEA
052EE:  CLRF   FEF
....................          setNextSERWriteIndex();
052F0:  MOVLB  0
052F2:  RCALL  5080
....................       }
052F4:  BRA    55C8
052F6:  MOVLB  6
....................       else if (rxChar == delimiter)
052F8:  MOVF   x90,W
052FA:  SUBLW  2C
052FC:  BNZ   53BA
....................       {
....................          if (SERcmd[SWI].paramIndex < numParam-1)
052FE:  CLRF   xF2
05300:  MOVFF  4DD,6F1
05304:  CLRF   xF4
05306:  MOVLW  B5
05308:  MOVWF  xF3
0530A:  MOVLB  0
0530C:  CALL   0C0C
05310:  MOVFF  02,692
05314:  MOVFF  01,691
05318:  MOVLW  02
0531A:  MOVLB  6
0531C:  ADDWF  01,W
0531E:  MOVWF  01
05320:  MOVLW  00
05322:  ADDWFC 02,W
05324:  MOVWF  03
05326:  MOVF   01,W
05328:  ADDLW  08
0532A:  MOVWF  FE9
0532C:  MOVLW  02
0532E:  ADDWFC 03,W
05330:  MOVWF  FEA
05332:  MOVF   FEF,W
05334:  SUBLW  05
05336:  BNC   53A2
....................          {
....................             SERcmd[SWI].paramIndex +=1;
05338:  CLRF   xF2
0533A:  MOVFF  4DD,6F1
0533E:  CLRF   xF4
05340:  MOVLW  B5
05342:  MOVWF  xF3
05344:  MOVLB  0
05346:  CALL   0C0C
0534A:  MOVFF  01,691
0534E:  MOVLW  02
05350:  MOVLB  6
05352:  ADDWF  01,W
05354:  MOVWF  01
05356:  MOVLW  00
05358:  ADDWFC 02,W
0535A:  MOVWF  03
0535C:  MOVF   01,W
0535E:  ADDLW  08
05360:  MOVWF  FE9
05362:  MOVLW  02
05364:  ADDWFC 03,W
05366:  MOVWF  FEA
05368:  MOVLW  01
0536A:  ADDWF  FEF,W
0536C:  MOVWF  FEF
....................             SERcmd[SWI].chrIndex = 0;
0536E:  CLRF   xF2
05370:  MOVFF  4DD,6F1
05374:  CLRF   xF4
05376:  MOVLW  B5
05378:  MOVWF  xF3
0537A:  MOVLB  0
0537C:  CALL   0C0C
05380:  MOVFF  01,691
05384:  MOVLW  01
05386:  MOVLB  6
05388:  ADDWF  01,W
0538A:  MOVWF  01
0538C:  MOVLW  00
0538E:  ADDWFC 02,W
05390:  MOVWF  03
05392:  MOVF   01,W
05394:  ADDLW  08
05396:  MOVWF  FE9
05398:  MOVLW  02
0539A:  ADDWFC 03,W
0539C:  MOVWF  FEA
0539E:  CLRF   FEF
....................          }
053A0:  BRA    53B8
....................          else
....................          {
....................             resetSERcmd(SWI); // exceed number of params... reset capture
053A2:  MOVFF  4DD,691
053A6:  MOVLB  0
053A8:  CALL   0C2E
....................             fprintf(SERIAL, retData);
053AC:  MOVLW  04
053AE:  MOVWF  FEA
053B0:  MOVLW  DE
053B2:  MOVWF  FE9
053B4:  RCALL  50BA
053B6:  MOVLB  6
....................          }
....................       }
053B8:  BRA    55CA
....................       
....................       else
....................       {
....................          if (SERcmd[SWI].chrIndex < lenParam)
053BA:  CLRF   xF2
053BC:  MOVFF  4DD,6F1
053C0:  CLRF   xF4
053C2:  MOVLW  B5
053C4:  MOVWF  xF3
053C6:  MOVLB  0
053C8:  CALL   0C0C
053CC:  MOVFF  02,692
053D0:  MOVFF  01,691
053D4:  MOVLW  01
053D6:  MOVLB  6
053D8:  ADDWF  01,W
053DA:  MOVWF  01
053DC:  MOVLW  00
053DE:  ADDWFC 02,W
053E0:  MOVWF  03
053E2:  MOVF   01,W
053E4:  ADDLW  08
053E6:  MOVWF  FE9
053E8:  MOVLW  02
053EA:  ADDWFC 03,W
053EC:  MOVWF  FEA
053EE:  MOVF   FEF,W
053F0:  SUBLW  18
053F2:  BTFSS  FD8.0
053F4:  BRA    55B4
....................          {
....................             SERcmd[SWI].p[SERcmd[SWI].paramIndex][SERcmd[SWI].chrIndex] = rxChar;
053F6:  CLRF   xF2
053F8:  MOVFF  4DD,6F1
053FC:  CLRF   xF4
053FE:  MOVLW  B5
05400:  MOVWF  xF3
05402:  MOVLB  0
05404:  CALL   0C0C
05408:  MOVFF  02,692
0540C:  MOVFF  01,691
05410:  MOVLW  06
05412:  MOVLB  6
05414:  ADDWF  x91,F
05416:  MOVLW  00
05418:  ADDWFC x92,F
0541A:  CLRF   xF2
0541C:  MOVFF  4DD,6F1
05420:  CLRF   xF4
05422:  MOVLW  B5
05424:  MOVWF  xF3
05426:  MOVLB  0
05428:  CALL   0C0C
0542C:  MOVFF  02,694
05430:  MOVFF  01,693
05434:  MOVLW  02
05436:  MOVLB  6
05438:  ADDWF  01,W
0543A:  MOVWF  01
0543C:  MOVLW  00
0543E:  ADDWFC 02,W
05440:  MOVWF  03
05442:  MOVF   01,W
05444:  ADDLW  08
05446:  MOVWF  FE9
05448:  MOVLW  02
0544A:  ADDWFC 03,W
0544C:  MOVWF  FEA
0544E:  CLRF   xF2
05450:  MOVFF  FEF,6F1
05454:  CLRF   xF4
05456:  MOVLW  19
05458:  MOVWF  xF3
0545A:  MOVLB  0
0545C:  CALL   0C0C
05460:  MOVFF  02,03
05464:  MOVF   01,W
05466:  MOVLB  6
05468:  ADDWF  x91,F
0546A:  MOVF   02,W
0546C:  ADDWFC x92,F
0546E:  CLRF   xF2
05470:  MOVFF  4DD,6F1
05474:  CLRF   xF4
05476:  MOVLW  B5
05478:  MOVWF  xF3
0547A:  MOVLB  0
0547C:  CALL   0C0C
05480:  MOVFF  01,693
05484:  MOVLW  01
05486:  MOVLB  6
05488:  ADDWF  01,W
0548A:  MOVWF  01
0548C:  MOVLW  00
0548E:  ADDWFC 02,W
05490:  MOVWF  03
05492:  MOVF   01,W
05494:  ADDLW  08
05496:  MOVWF  FE9
05498:  MOVLW  02
0549A:  ADDWFC 03,W
0549C:  MOVWF  FEA
0549E:  MOVF   FEF,W
054A0:  ADDWF  x91,W
054A2:  MOVWF  01
054A4:  MOVLW  00
054A6:  ADDWFC x92,W
054A8:  MOVWF  03
054AA:  MOVF   01,W
054AC:  ADDLW  08
054AE:  MOVWF  FE9
054B0:  MOVLW  02
054B2:  ADDWFC 03,W
054B4:  MOVWF  FEA
054B6:  MOVFF  690,FEF
....................             SERcmd[SWI].chrIndex += 1;
054BA:  CLRF   xF2
054BC:  MOVFF  4DD,6F1
054C0:  CLRF   xF4
054C2:  MOVLW  B5
054C4:  MOVWF  xF3
054C6:  MOVLB  0
054C8:  CALL   0C0C
054CC:  MOVFF  01,691
054D0:  MOVLW  01
054D2:  MOVLB  6
054D4:  ADDWF  01,W
054D6:  MOVWF  01
054D8:  MOVLW  00
054DA:  ADDWFC 02,W
054DC:  MOVWF  03
054DE:  MOVF   01,W
054E0:  ADDLW  08
054E2:  MOVWF  FE9
054E4:  MOVLW  02
054E6:  ADDWFC 03,W
054E8:  MOVWF  FEA
054EA:  MOVLW  01
054EC:  ADDWF  FEF,W
054EE:  MOVWF  FEF
....................             SERcmd[SWI].p[SERcmd[SWI].paramIndex][SERcmd[SWI].chrIndex] = '\0';
054F0:  CLRF   xF2
054F2:  MOVFF  4DD,6F1
054F6:  CLRF   xF4
054F8:  MOVLW  B5
054FA:  MOVWF  xF3
054FC:  MOVLB  0
054FE:  CALL   0C0C
05502:  MOVFF  02,692
05506:  MOVFF  01,691
0550A:  MOVLW  06
0550C:  MOVLB  6
0550E:  ADDWF  x91,F
05510:  MOVLW  00
05512:  ADDWFC x92,F
05514:  CLRF   xF2
05516:  MOVFF  4DD,6F1
0551A:  CLRF   xF4
0551C:  MOVLW  B5
0551E:  MOVWF  xF3
05520:  MOVLB  0
05522:  CALL   0C0C
05526:  MOVFF  02,694
0552A:  MOVFF  01,693
0552E:  MOVLW  02
05530:  MOVLB  6
05532:  ADDWF  01,W
05534:  MOVWF  01
05536:  MOVLW  00
05538:  ADDWFC 02,W
0553A:  MOVWF  03
0553C:  MOVF   01,W
0553E:  ADDLW  08
05540:  MOVWF  FE9
05542:  MOVLW  02
05544:  ADDWFC 03,W
05546:  MOVWF  FEA
05548:  CLRF   xF2
0554A:  MOVFF  FEF,6F1
0554E:  CLRF   xF4
05550:  MOVLW  19
05552:  MOVWF  xF3
05554:  MOVLB  0
05556:  CALL   0C0C
0555A:  MOVFF  02,03
0555E:  MOVF   01,W
05560:  MOVLB  6
05562:  ADDWF  x91,F
05564:  MOVF   02,W
05566:  ADDWFC x92,F
05568:  CLRF   xF2
0556A:  MOVFF  4DD,6F1
0556E:  CLRF   xF4
05570:  MOVLW  B5
05572:  MOVWF  xF3
05574:  MOVLB  0
05576:  CALL   0C0C
0557A:  MOVFF  01,693
0557E:  MOVLW  01
05580:  MOVLB  6
05582:  ADDWF  01,W
05584:  MOVWF  01
05586:  MOVLW  00
05588:  ADDWFC 02,W
0558A:  MOVWF  03
0558C:  MOVF   01,W
0558E:  ADDLW  08
05590:  MOVWF  FE9
05592:  MOVLW  02
05594:  ADDWFC 03,W
05596:  MOVWF  FEA
05598:  MOVF   FEF,W
0559A:  ADDWF  x91,W
0559C:  MOVWF  01
0559E:  MOVLW  00
055A0:  ADDWFC x92,W
055A2:  MOVWF  03
055A4:  MOVF   01,W
055A6:  ADDLW  08
055A8:  MOVWF  FE9
055AA:  MOVLW  02
055AC:  ADDWFC 03,W
055AE:  MOVWF  FEA
055B0:  CLRF   FEF
....................          }
055B2:  BRA    55CA
....................          else
....................          {
....................             resetSERcmd(SWI); // exceed number of characters... reset capture
055B4:  MOVFF  4DD,691
055B8:  MOVLB  0
055BA:  CALL   0C2E
....................             fprintf(SERIAL, retData);
055BE:  MOVLW  04
055C0:  MOVWF  FEA
055C2:  MOVLW  DE
055C4:  MOVWF  FE9
055C6:  RCALL  50BA
055C8:  MOVLB  6
....................          }
....................       }
055CA:  MOVLB  0
055CC:  BRA    50DE
055CE:  MOVLB  5
....................    }          
055D0:  MOVLB  0
055D2:  GOTO   A678 (RETURN)
.................... }
....................            
.................... /*****************************************************************************/
.................... /* serialInit ROUTINE  - Sets up serial port                                 */
.................... /*****************************************************************************/ 
.................... void serial_init()
.................... {
....................    for (int i = 0; i < numRecords; i++) 
*
00DA8:  MOVLB  6
00DAA:  CLRF   x90
00DAC:  MOVF   x90,W
00DAE:  SUBLW  03
00DB0:  BNC   0DC0
....................    {
....................       resetSERcmd(i);
00DB2:  MOVFF  690,691
00DB6:  MOVLB  0
00DB8:  RCALL  0C2E
00DBA:  MOVLB  6
00DBC:  INCF   x90,F
00DBE:  BRA    0DAC
....................    }
....................    enable_interrupts(INT_RDA);
00DC0:  MOVLB  E
00DC2:  BSF    xC0.5
00DC4:  MOVLB  0
00DC6:  GOTO   A660 (RETURN)
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #include <pid.h>
.................... #ifndef pidcontroller
.................... #define pidcontroller
.................... #include <parameters.h>
.................... #include <math.h>
.................... 
.................... /*****************************************************************************/
.................... /* UPDATE the Control Variable (CV)                                          */
.................... /*****************************************************************************/
.................... void pid_update (channelMap ch){
....................    float err = PID[ch].SP - PID[ch].PV;  // error = set value - measured
....................    
....................    PID[ch].I += err*PID[ch].kI;
....................    if (PID[ch].I > op_upper_bound) PID[ch].I = op_upper_bound; // anti-windup
....................    else if (PID[ch].I < op_lower_bound) PID[ch].I = op_lower_bound;
....................    
....................    float P = err * PID[ch].kP;  // proportional value
....................    
....................    float D = PID[ch].kD * (PID[ch].PV - PID[ch].PVold);  // derivative value
....................    
....................    PID[ch].CV = P + PID[ch].I + D;  // new control variable
....................    if (PID[ch].CV > op_upper_bound) PID[ch].CV = op_upper_bound; // limit positive output
....................    else if (PID[ch].CV < op_lower_bound) PID[ch].CV = op_lower_bound; // limit negative output
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PID Task - looks for change to PV and updates CV                          */
.................... /*****************************************************************************/
.................... void pid_task(channelMap ch){
....................    static int index = 0;
....................    if (PID[ch].SP != PID[ch].PV) pid_update(ch);
....................    if ((index++) >= numChannels) index = 0;
.................... }
.................... 
.................... #endif
.................... 
.................... #include <eventTimer.h>
.................... #ifndef timeout
.................... #define timeout
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0.3,0.1,0,0,0,0,0},
....................    {0.01,0.3,0.1,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/           
.................... /* Global timers used by all routnes                                         */
.................... /* timeoutReg0-2 are used for timeouts. Other routines monitor the value of  */
.................... /* intTimeoutReg. On boot, they will be loaded from EEProm. Any              */
.................... /* configuration changes will be changed in EEprom, hence will be restored on*/
.................... /* subsequent boot.                                                          */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* Register definitions                                                      */
.................... /*****************************************************************************/
.................... //!unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... //!unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... //!unsigned int32 timeoutReg2 = 0;
.................... //!unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... unsigned int32 timeCounter = 0;
.................... 
.................... /*****************************************************************************/
.................... /* TIMEOUT_INIT initializes the timer                                        */
.................... /*****************************************************************************/
.................... void event_timer_init()
.................... {        
....................    disable_interrupts(INT_TIMER1);
00DCA:  MOVLB  E
00DCC:  BCF    xC1.0
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_1);
00DCE:  MOVLW  01
00DD0:  MOVWF  FD1
00DD2:  MOVLW  07
00DD4:  MOVWF  FCE
00DD6:  CLRF   FCF
00DD8:  CLRF   FD0
....................    timeoutReg0 = 0;  // clear all the timers
00DDA:  MOVLB  1
00DDC:  CLRF   x5A
00DDE:  CLRF   x59
00DE0:  CLRF   x58
00DE2:  CLRF   x57
....................    timeoutReg1 = 0;
00DE4:  CLRF   x5E
00DE6:  CLRF   x5D
00DE8:  CLRF   x5C
00DEA:  CLRF   x5B
....................    timeoutReg2 = 0;
00DEC:  CLRF   x62
00DEE:  CLRF   x61
00DF0:  CLRF   x60
00DF2:  CLRF   x5F
....................    intTimeoutReg = 50;
00DF4:  CLRF   x64
00DF6:  MOVLW  32
00DF8:  MOVWF  x63
....................    enable_interrupts(INT_TIMER1);
00DFA:  MOVLB  E
00DFC:  BSF    xC1.0
00DFE:  MOVLB  0
00E00:  GOTO   A664 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* TIMEOUT INTERRUPT decrements the timeout registers every second           */
.................... /*****************************************************************************/
.................... #INT_TIMER1
.................... void TIMER1_isr(void) 
*
0025A:  MOVLB  0
.................... {
....................    set_timer1(0x0BDB); // load timer register to allow 10 millisecond interupts
0025C:  MOVLW  0B
0025E:  MOVWF  FCD
00260:  MOVLW  DB
00262:  MOVWF  FCC
00264:  NOP   
....................    if (timeoutReg0 > 10) timeoutReg0 -= 10; else timeoutReg0 = 0;
00266:  MOVLB  1
00268:  MOVF   x5A,F
0026A:  BNZ   027A
0026C:  MOVF   x59,F
0026E:  BNZ   027A
00270:  MOVF   x58,F
00272:  BNZ   027A
00274:  MOVF   x57,W
00276:  SUBLW  0A
00278:  BC    0288
0027A:  MOVLW  0A
0027C:  SUBWF  x57,F
0027E:  MOVLW  00
00280:  SUBWFB x58,F
00282:  SUBWFB x59,F
00284:  SUBWFB x5A,F
00286:  BRA    0290
00288:  CLRF   x5A
0028A:  CLRF   x59
0028C:  CLRF   x58
0028E:  CLRF   x57
....................    if (timeoutReg1 > 10) timeoutReg1 -= 10; else timeoutReg1 = 0;
00290:  MOVF   x5E,F
00292:  BNZ   02A2
00294:  MOVF   x5D,F
00296:  BNZ   02A2
00298:  MOVF   x5C,F
0029A:  BNZ   02A2
0029C:  MOVF   x5B,W
0029E:  SUBLW  0A
002A0:  BC    02B0
002A2:  MOVLW  0A
002A4:  SUBWF  x5B,F
002A6:  MOVLW  00
002A8:  SUBWFB x5C,F
002AA:  SUBWFB x5D,F
002AC:  SUBWFB x5E,F
002AE:  BRA    02B8
002B0:  CLRF   x5E
002B2:  CLRF   x5D
002B4:  CLRF   x5C
002B6:  CLRF   x5B
....................    if (timeoutReg2 > 10) timeoutReg2 -= 10; else timeoutReg2 = 0;
002B8:  MOVF   x62,F
002BA:  BNZ   02CA
002BC:  MOVF   x61,F
002BE:  BNZ   02CA
002C0:  MOVF   x60,F
002C2:  BNZ   02CA
002C4:  MOVF   x5F,W
002C6:  SUBLW  0A
002C8:  BC    02D8
002CA:  MOVLW  0A
002CC:  SUBWF  x5F,F
002CE:  MOVLW  00
002D0:  SUBWFB x60,F
002D2:  SUBWFB x61,F
002D4:  SUBWFB x62,F
002D6:  BRA    02E0
002D8:  CLRF   x62
002DA:  CLRF   x61
002DC:  CLRF   x60
002DE:  CLRF   x5F
....................    if (intTimeoutReg != 0) // INTERRUPTING TIMER
002E0:  MOVF   x63,F
002E2:  BNZ   02E8
002E4:  MOVF   x64,F
002E6:  BZ    0324
....................    {
....................       timeCounter+=10;
002E8:  MOVLW  0A
002EA:  MOVLB  5
002EC:  ADDWF  x84,F
002EE:  MOVLW  00
002F0:  ADDWFC x85,F
002F2:  ADDWFC x86,F
002F4:  ADDWFC x87,F
....................       if (timeCounter >= intTimeoutReg)
002F6:  MOVF   x87,F
002F8:  BNZ   0314
002FA:  MOVF   x86,F
002FC:  BNZ   0314
002FE:  MOVLB  1
00300:  MOVF   x64,W
00302:  MOVLB  5
00304:  SUBWF  x85,W
00306:  BNC   0322
00308:  BNZ   0314
0030A:  MOVLB  1
0030C:  MOVF   x63,W
0030E:  MOVLB  5
00310:  SUBWF  x84,W
00312:  BNC   0322
....................       {
....................          sensor_monitor_interrupt_task();
00314:  MOVLB  0
00316:  BRA    01BE
....................          timeCounter = 0;
00318:  MOVLB  5
0031A:  CLRF   x87
0031C:  CLRF   x86
0031E:  CLRF   x85
00320:  CLRF   x84
00322:  MOVLB  1
....................       }
....................    }
.................... }
.................... 
.................... #endif
.................... 
.................... #include <commandHandler.c>
.................... #ifndef cmdHandlerC
.................... #define cmdHandlerC
.................... #include <commandHandler.h>
.................... #ifndef cmdHandler
.................... #define cmdHandler
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0.3,0.1,0,0,0,0,0},
....................    {0.01,0.3,0.1,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... 
00324:  MOVLB  E
00326:  BCF    xC9.0
00328:  MOVLB  0
0032A:  GOTO   006E
.................... #define hwID 'D'   // DiFCS
.................... 
.................... /*****************************************************************************/
.................... /* RESPONSE MESSAGES                                                         */
.................... /*****************************************************************************/
.................... typedef struct response {
....................    int8 id;
....................    char *msg;
.................... } resp;
.................... 
.................... //!#define INVALID_DATA "error - invalid data"
.................... //!#define invalidTime "error - invalid TO value"
.................... //!#define overrun "error - buffer overrun"
.................... //!#define dcVoltage "VDC:%f1"
.................... //!#define USBVoltage "VUSB:%f"
.................... //!#define USBupstream "VUSBup:%f"
.................... //!#define plus5V "5V Rail:%f"
.................... //!#define plus3V3 "3V3 Rai:%f"
.................... //!#define allVoltages "All Voltages = %f, %f, %f, %f, %f"
.................... //!#define USBdownstream "USB downstream status:\r\nPG:%s\r\nch0:%s\r\nch1:%s"
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC MESSGAGE DUMP                                                  */
.................... /*****************************************************************************/
.................... //!#define voltageMsg "V0:%f\r\nV1:%f\r\nV2:%f\r\nV3:%f\r\nV4:%f"
.................... //!#define TimerMsg "T0:%Lu\r\nT1:%Lu\r\nT2:%Lu\r\Tint:%Lu\r\nTtick:%Lu"
.................... //!#define ioStatusMsg "Inputs:%u\r\nOutputs:%u\r\nStatus:%u"
.................... //!#define diagnosticMsg "V0:%f\r\nV1:%f\r\nV2:%f\r\nV3:%f\r\nV4:%f\r\nT0:%Lu\r\nT1:%Lu\r\nT2:%Lu\r\nTint:%Lu\r\nTtick:%Lu\r\nInputs:%u\r\nOutputs:%u\r\nStatus:%u"
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC COMMAND PROTOTYPES                                             */
.................... /*****************************************************************************/
.................... int8 getRev(unsigned int8);                // gr 
.................... int8 getSN(unsigned int8);                 // gs
.................... 
.................... int8 getOPchMap(unsigned int8);            // gChMap,   {1|2}
.................... int8 setOPchMap(unsigned int8);            // sChMap,   {1|2}, {X|Y}
.................... 
.................... int8 getIPchMode(unsigned int8);           // gChMode,  {1|2}
.................... int8 setIPchMode(unsigned int8);           // sChMode,  {1|2}, {MANUAL|MAGSNS}
....................    
.................... int8 getPIDvals(unsigned int8);            // gPID,     {1|2}, {P|I|D}
.................... int8 setPIDvals(unsigned int8);            // sPID,     {1|2}, {P|I|D}, <float>
.................... 
.................... int8 enablePID(unsigned int8);             // enaPID,   {1|2}
.................... int8 disablePID(unsigned int8);            // disPID,   {1|2}
.................... 
.................... int8 getSetPoint(unsigned int8);           // gSP,      {1|2}
.................... int8 setSetPoint(unsigned int8);           // sSP,      {1|2}, <float>
.................... 
.................... int8 getAllSensorCalParams(unsigned int8); // gSCals,   {1|2}
.................... int8 getSensorCalParam(unsigned int8);     // gSCal,    {1|2}, {0|1|2|3|4|5}
.................... int8 setSensorCalParam(unsigned int8);     // sSCal,    {1|2}, {0|1|2|3|4|5}, <float>
.................... 
.................... int8 getMonitorCalParam(unsigned int8);    // gMCal,    {N15|200|5V6|5VA|3V6X|3V3A|3V3D}
.................... int8 setMonitorCalParam(unsigned int8);    // sMCal,    {N15|200|5V6|5VA|3V6X|3V3A|3V3D}, <float>, <float>
.................... int8 getMonitorValue(unsigned int8);       // gMon,     {N15|200|5V6|5VA|3V6X|3V3A|3V3D|all}
.................... 
.................... int8 getPIDdata(unsigned int8);            // gPIDdata, {1|2}, {PV|CV|PVold|I}
.................... 
.................... int8 getIPdata(unsigned int8);             // gIPdata,  {1|2}, {raw|calib|p0|poles|real}
....................    
.................... int8 getManOPvals(unsigned int8);          // gManOP,   {1|2}  
.................... int8 setManOPvals(unsigned int8);          // sManOP,   {1|2}, <float>  
.................... 
.................... int8 invalidCmd(unsigned int8);
.................... 
.................... struct command {
....................    char *cmd_name;
....................    int8 (*cmd_func)(unsigned int8);
.................... };
.................... 
.................... BOOLEAN arg_is_float(char *);
.................... BOOLEAN is_valid_channel(char *);
.................... int8 hex_to_int(char);
.................... void echo_cmd(unsigned int8 rec);
.................... int8 command_parser(unsigned int8 rec);
.................... void command_handler_task();
.................... 
.................... #endif
.................... 
.................... 
.................... /* LIST OF DIAGNOSTIC COMMAND KEYWORDS AND THEIR FUNCTIONS */
.................... struct command cmd_list[] = {
....................    {"gr",       &getRev},
....................    {"gs",       &getSN},
....................    {"gChMap",   &getOPchMap},
....................    {"sChMap",   &setOPchMap},
....................    {"gChMode",  &getIPchMode},
....................    {"sChMode",  &setIPchMode},
....................    {"gPID",     &getPIDvals},
....................    {"sPID",     &setPIDvals},
.................... //!   {"enaPID",   &enablePID},
.................... //!   {"disPID",   &disablePID},
....................    {"gSP",      &getSetPoint},
....................    {"sSP",      &setSetPoint},
....................    {"gSCals",   &getAllSensorCalParams},
....................    {"gSCal",    &getSensorCalParam},
....................    {"sSCal",    &setSensorCalParam},
....................    {"gMCal",    &getMonitorCalParam},
....................    {"sMCal",    &setMonitorCalParam},
....................    {"gMon",     &getMonitorValue},
....................    {"gPIDdata", &getPIDdata},
....................    {"gIPdata",  &getIPdata},
....................    {"gManOP",   &getManOPvals},
....................    {"sManOP",   &setManOPvals},
....................    {"\0", &invalidCmd}
.................... };
.................... 
.................... /* LIST OF RESPONSE MESSAGES */
.................... enum resp_e { 
....................    SUCCESS,
....................    INV_CMD,
....................    INV_PARAM 
.................... };
.................... 
.................... resp resp_list[] = {
....................    {SUCCESS, "SUCCESS"},
....................    {INV_CMD, "INVALID COMMAND"},
....................    {INV_PARAM, "INVALID PARAMETER"}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC COMMAND DEFINITIONS                                            */
.................... /*****************************************************************************/
....................                           
.................... int8 getRev(unsigned int8 rec){
....................    sprintf(retData+strlen(retData), "%s,", version);
*
05B78:  MOVLW  04
05B7A:  MOVLB  6
05B7C:  MOVWF  xD2
05B7E:  MOVLW  DE
05B80:  MOVWF  xD1
05B82:  MOVLB  0
05B84:  RCALL  5A88
05B86:  MOVFF  02,03
05B8A:  MOVF   01,W
05B8C:  ADDLW  DE
05B8E:  MOVLB  6
05B90:  MOVWF  x9B
05B92:  MOVLW  04
05B94:  ADDWFC 02,W
05B96:  MOVWF  x9C
05B98:  MOVFF  FE8,583
05B9C:  MOVFF  69B,582
05BA0:  MOVLW  2E
05BA2:  MOVWF  FF6
05BA4:  MOVLW  03
05BA6:  MOVWF  FF7
05BA8:  MOVLB  0
05BAA:  RCALL  5B58
05BAC:  MOVLW  2C
05BAE:  MOVLB  6
05BB0:  MOVWF  xE0
05BB2:  MOVLB  0
05BB4:  RCALL  5B38
....................    return SUCCESS;
05BB6:  MOVLW  00
05BB8:  MOVWF  01
05BBA:  RETURN 0
.................... }
.................... 
.................... int8 getSN(unsigned int8 rec){
....................    sprintf(retData+strlen(retData), "%s,", serialID);
05BBC:  MOVLW  04
05BBE:  MOVLB  6
05BC0:  MOVWF  xD2
05BC2:  MOVLW  DE
05BC4:  MOVWF  xD1
05BC6:  MOVLB  0
05BC8:  RCALL  5A88
05BCA:  MOVFF  02,03
05BCE:  MOVF   01,W
05BD0:  ADDLW  DE
05BD2:  MOVLB  6
05BD4:  MOVWF  x9B
05BD6:  MOVLW  04
05BD8:  ADDWFC 02,W
05BDA:  MOVWF  x9C
05BDC:  MOVFF  FE8,583
05BE0:  MOVFF  69B,582
05BE4:  MOVLW  38
05BE6:  MOVWF  FF6
05BE8:  MOVLW  03
05BEA:  MOVWF  FF7
05BEC:  MOVLB  0
05BEE:  RCALL  5B58
05BF0:  MOVLW  2C
05BF2:  MOVLB  6
05BF4:  MOVWF  xE0
05BF6:  MOVLB  0
05BF8:  RCALL  5B38
....................    return SUCCESS;
05BFA:  MOVLW  00
05BFC:  MOVWF  01
05BFE:  RETURN 0
.................... }
.................... 
.................... int8 getOPchMap(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
060B0:  MOVLB  6
060B2:  CLRF   xF2
060B4:  MOVFF  68F,6F1
060B8:  CLRF   xF4
060BA:  MOVLW  B5
060BC:  MOVWF  xF3
060BE:  MOVLB  0
060C0:  CALL   0C0C
060C4:  MOVFF  02,69D
060C8:  MOVFF  01,69C
060CC:  MOVLW  06
060CE:  MOVLB  6
060D0:  ADDWF  x9C,F
060D2:  MOVLW  00
060D4:  ADDWFC x9D,F
060D6:  MOVLW  32
060D8:  ADDWF  x9C,W
060DA:  MOVWF  01
060DC:  MOVLW  00
060DE:  ADDWFC x9D,W
060E0:  MOVWF  03
060E2:  MOVF   01,W
060E4:  ADDLW  08
060E6:  MOVWF  01
060E8:  MOVLW  02
060EA:  ADDWFC 03,F
060EC:  MOVFF  01,69C
060F0:  MOVFF  03,69D
060F4:  MOVFF  03,6C4
060F8:  MOVFF  01,6C3
060FC:  MOVLB  0
060FE:  RCALL  5C00
06100:  MOVF   01,F
06102:  BNZ   610C
06104:  MOVLW  02
06106:  MOVWF  01
06108:  BRA    624A
0610A:  BRA    6168
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
0610C:  MOVLB  6
0610E:  CLRF   xF2
06110:  MOVFF  68F,6F1
06114:  CLRF   xF4
06116:  MOVLW  B5
06118:  MOVWF  xF3
0611A:  MOVLB  0
0611C:  CALL   0C0C
06120:  MOVFF  02,69D
06124:  MOVFF  01,69C
06128:  MOVLW  06
0612A:  MOVLB  6
0612C:  ADDWF  x9C,F
0612E:  MOVLW  00
06130:  ADDWFC x9D,F
06132:  MOVLW  32
06134:  ADDWF  x9C,W
06136:  MOVWF  01
06138:  MOVLW  00
0613A:  ADDWFC x9D,W
0613C:  MOVWF  03
0613E:  MOVF   01,W
06140:  ADDLW  08
06142:  MOVWF  01
06144:  MOVLW  02
06146:  ADDWFC 03,F
06148:  MOVFF  01,69C
0614C:  MOVFF  03,69D
06150:  MOVFF  03,6C4
06154:  MOVFF  01,6C3
06158:  CLRF   xC6
0615A:  CLRF   xC5
0615C:  MOVLW  0A
0615E:  MOVWF  xC7
06160:  MOVLB  0
06162:  RCALL  5C9A
06164:  MOVFF  01,69B
....................    
....................    /*** GET CHANNEL MAP ***************/ 
....................    if      (0 == chMap[arg1-1]) sprintf(retData+strlen(retData), "%d,%c,", arg1, 'X');
06168:  MOVLW  01
0616A:  MOVLB  6
0616C:  SUBWF  x9B,W
0616E:  MOVWF  x9D
06170:  CLRF   x9F
06172:  MOVLW  60
06174:  MOVWF  x9E
06176:  MOVLB  0
06178:  CALL   4684
0617C:  BTFSC  01.0
0617E:  BRA    61D4
06180:  MOVLW  04
06182:  MOVLB  6
06184:  MOVWF  xD2
06186:  MOVLW  DE
06188:  MOVWF  xD1
0618A:  MOVLB  0
0618C:  RCALL  5A88
0618E:  MOVFF  02,03
06192:  MOVF   01,W
06194:  ADDLW  DE
06196:  MOVLB  6
06198:  MOVWF  x9C
0619A:  MOVLW  04
0619C:  ADDWFC 02,W
0619E:  MOVWF  x9D
061A0:  MOVFF  FE8,583
061A4:  MOVFF  69C,582
061A8:  MOVFF  69B,6C4
061AC:  MOVLW  18
061AE:  MOVWF  xC5
061B0:  MOVLB  0
061B2:  RCALL  5FF0
061B4:  MOVLW  2C
061B6:  MOVLB  6
061B8:  MOVWF  xE0
061BA:  MOVLB  0
061BC:  RCALL  5B38
061BE:  MOVLW  58
061C0:  MOVLB  6
061C2:  MOVWF  xE0
061C4:  MOVLB  0
061C6:  RCALL  5B38
061C8:  MOVLW  2C
061CA:  MOVLB  6
061CC:  MOVWF  xE0
061CE:  MOVLB  0
061D0:  RCALL  5B38
061D2:  BRA    6246
....................    else if (1 == chMap[arg1-1]) sprintf(retData+strlen(retData), "%d,%c,", arg1, 'Y');
061D4:  MOVLW  01
061D6:  MOVLB  6
061D8:  SUBWF  x9B,W
061DA:  MOVWF  x9D
061DC:  CLRF   x9F
061DE:  MOVLW  60
061E0:  MOVWF  x9E
061E2:  MOVLB  0
061E4:  CALL   4684
061E8:  BTFSS  01.0
061EA:  BRA    6240
061EC:  MOVLW  04
061EE:  MOVLB  6
061F0:  MOVWF  xD2
061F2:  MOVLW  DE
061F4:  MOVWF  xD1
061F6:  MOVLB  0
061F8:  RCALL  5A88
061FA:  MOVFF  02,03
061FE:  MOVF   01,W
06200:  ADDLW  DE
06202:  MOVLB  6
06204:  MOVWF  x9C
06206:  MOVLW  04
06208:  ADDWFC 02,W
0620A:  MOVWF  x9D
0620C:  MOVFF  FE8,583
06210:  MOVFF  69C,582
06214:  MOVFF  69B,6C4
06218:  MOVLW  18
0621A:  MOVWF  xC5
0621C:  MOVLB  0
0621E:  RCALL  5FF0
06220:  MOVLW  2C
06222:  MOVLB  6
06224:  MOVWF  xE0
06226:  MOVLB  0
06228:  RCALL  5B38
0622A:  MOVLW  59
0622C:  MOVLB  6
0622E:  MOVWF  xE0
06230:  MOVLB  0
06232:  RCALL  5B38
06234:  MOVLW  2C
06236:  MOVLB  6
06238:  MOVWF  xE0
0623A:  MOVLB  0
0623C:  RCALL  5B38
0623E:  BRA    6246
....................    else return INV_PARAM;
06240:  MOVLW  02
06242:  MOVWF  01
06244:  BRA    624A
....................    
....................    return SUCCESS;
06246:  MOVLW  00
06248:  MOVWF  01
0624A:  RETURN 0
.................... }
.................... 
.................... int8 setOPchMap(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
0628E:  MOVLB  6
06290:  CLRF   xF2
06292:  MOVFF  68F,6F1
06296:  CLRF   xF4
06298:  MOVLW  B5
0629A:  MOVWF  xF3
0629C:  MOVLB  0
0629E:  CALL   0C0C
062A2:  MOVFF  02,69E
062A6:  MOVFF  01,69D
062AA:  MOVLW  06
062AC:  MOVLB  6
062AE:  ADDWF  x9D,F
062B0:  MOVLW  00
062B2:  ADDWFC x9E,F
062B4:  MOVLW  32
062B6:  ADDWF  x9D,W
062B8:  MOVWF  01
062BA:  MOVLW  00
062BC:  ADDWFC x9E,W
062BE:  MOVWF  03
062C0:  MOVF   01,W
062C2:  ADDLW  08
062C4:  MOVWF  01
062C6:  MOVLW  02
062C8:  ADDWFC 03,F
062CA:  MOVFF  01,69D
062CE:  MOVFF  03,69E
062D2:  MOVFF  03,6C4
062D6:  MOVFF  01,6C3
062DA:  MOVLB  0
062DC:  RCALL  5C00
062DE:  MOVF   01,F
062E0:  BNZ   62EA
062E2:  MOVLW  02
062E4:  MOVWF  01
062E6:  BRA    643A
062E8:  BRA    6346
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
062EA:  MOVLB  6
062EC:  CLRF   xF2
062EE:  MOVFF  68F,6F1
062F2:  CLRF   xF4
062F4:  MOVLW  B5
062F6:  MOVWF  xF3
062F8:  MOVLB  0
062FA:  CALL   0C0C
062FE:  MOVFF  02,69E
06302:  MOVFF  01,69D
06306:  MOVLW  06
06308:  MOVLB  6
0630A:  ADDWF  x9D,F
0630C:  MOVLW  00
0630E:  ADDWFC x9E,F
06310:  MOVLW  32
06312:  ADDWF  x9D,W
06314:  MOVWF  01
06316:  MOVLW  00
06318:  ADDWFC x9E,W
0631A:  MOVWF  03
0631C:  MOVF   01,W
0631E:  ADDLW  08
06320:  MOVWF  01
06322:  MOVLW  02
06324:  ADDWFC 03,F
06326:  MOVFF  01,69D
0632A:  MOVFF  03,69E
0632E:  MOVFF  03,6C4
06332:  MOVFF  01,6C3
06336:  CLRF   xC6
06338:  CLRF   xC5
0633A:  MOVLW  0A
0633C:  MOVWF  xC7
0633E:  MOVLB  0
06340:  RCALL  5C9A
06342:  MOVFF  01,69B
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
06346:  MOVLB  6
06348:  CLRF   xF2
0634A:  MOVFF  68F,6F1
0634E:  CLRF   xF4
06350:  MOVLW  B5
06352:  MOVWF  xF3
06354:  MOVLB  0
06356:  CALL   0C0C
0635A:  MOVFF  02,69E
0635E:  MOVFF  01,69D
06362:  MOVLW  06
06364:  MOVLB  6
06366:  ADDWF  x9D,F
06368:  MOVLW  00
0636A:  ADDWFC x9E,F
0636C:  MOVLW  4B
0636E:  ADDWF  x9D,W
06370:  MOVWF  01
06372:  MOVLW  00
06374:  ADDWFC x9E,W
06376:  MOVWF  03
06378:  MOVF   01,W
0637A:  ADDLW  08
0637C:  MOVWF  01
0637E:  MOVLW  02
06380:  ADDWFC 03,F
06382:  MOVFF  01,69D
06386:  MOVFF  03,69E
0638A:  MOVFF  03,6D2
0638E:  MOVFF  01,6D1
06392:  MOVLB  0
06394:  CALL   5A88
06398:  MOVFF  02,03
0639C:  MOVF   01,W
0639E:  SUBLW  01
063A0:  BNZ   63A6
063A2:  MOVF   03,F
063A4:  BZ    63AE
063A6:  MOVLW  02
063A8:  MOVWF  01
063AA:  BRA    643A
063AC:  BRA    63EE
....................    else arg2 = SERcmd[rec].p[3][0];
063AE:  MOVLB  6
063B0:  CLRF   xF2
063B2:  MOVFF  68F,6F1
063B6:  CLRF   xF4
063B8:  MOVLW  B5
063BA:  MOVWF  xF3
063BC:  MOVLB  0
063BE:  CALL   0C0C
063C2:  MOVFF  02,69E
063C6:  MOVFF  01,69D
063CA:  MOVLW  06
063CC:  MOVLB  6
063CE:  ADDWF  x9D,F
063D0:  MOVLW  00
063D2:  ADDWFC x9E,F
063D4:  MOVLW  4B
063D6:  ADDWF  x9D,F
063D8:  MOVLW  00
063DA:  ADDWFC x9E,F
063DC:  MOVLW  08
063DE:  ADDWF  x9D,W
063E0:  MOVWF  FE9
063E2:  MOVLW  02
063E4:  ADDWFC x9E,W
063E6:  MOVWF  FEA
063E8:  MOVFF  FEF,69C
063EC:  MOVLB  0
....................    
....................    /*** SET CHANNEL MAP ***************/
....................    if      ('X' == arg2) chMap[arg1-1] = chX;
063EE:  MOVLB  6
063F0:  MOVF   x9C,W
063F2:  SUBLW  58
063F4:  BNZ   640E
063F6:  MOVLW  01
063F8:  SUBWF  x9B,W
063FA:  MOVWF  x9D
063FC:  MOVWF  xB2
063FE:  CLRF   xB3
06400:  CLRF   xB5
06402:  MOVLW  60
06404:  MOVWF  xB4
06406:  MOVLB  0
06408:  RCALL  624C
0640A:  BRA    6436
0640C:  MOVLB  6
....................    else if ('Y' == arg2) chMap[arg1-1] = chY;
0640E:  MOVF   x9C,W
06410:  SUBLW  59
06412:  BNZ   642E
06414:  MOVLW  01
06416:  SUBWF  x9B,W
06418:  MOVWF  x9D
0641A:  MOVWF  xB2
0641C:  MOVLW  01
0641E:  MOVWF  xB3
06420:  CLRF   xB5
06422:  MOVLW  60
06424:  MOVWF  xB4
06426:  MOVLB  0
06428:  RCALL  624C
0642A:  BRA    6436
0642C:  MOVLB  6
....................    else return INV_PARAM;
0642E:  MOVLW  02
06430:  MOVWF  01
06432:  MOVLB  0
06434:  BRA    643A
....................    
....................    return SUCCESS;
06436:  MOVLW  00
06438:  MOVWF  01
0643A:  RETURN 0
.................... }
.................... 
.................... int8 getIPchMode(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
06466:  MOVLB  6
06468:  CLRF   xF2
0646A:  MOVFF  68F,6F1
0646E:  CLRF   xF4
06470:  MOVLW  B5
06472:  MOVWF  xF3
06474:  MOVLB  0
06476:  CALL   0C0C
0647A:  MOVFF  02,69D
0647E:  MOVFF  01,69C
06482:  MOVLW  06
06484:  MOVLB  6
06486:  ADDWF  x9C,F
06488:  MOVLW  00
0648A:  ADDWFC x9D,F
0648C:  MOVLW  32
0648E:  ADDWF  x9C,W
06490:  MOVWF  01
06492:  MOVLW  00
06494:  ADDWFC x9D,W
06496:  MOVWF  03
06498:  MOVF   01,W
0649A:  ADDLW  08
0649C:  MOVWF  01
0649E:  MOVLW  02
064A0:  ADDWFC 03,F
064A2:  MOVFF  01,69C
064A6:  MOVFF  03,69D
064AA:  MOVFF  03,6C4
064AE:  MOVFF  01,6C3
064B2:  MOVLB  0
064B4:  CALL   5C00
064B8:  MOVF   01,F
064BA:  BNZ   64C4
064BC:  MOVLW  02
064BE:  MOVWF  01
064C0:  BRA    65F0
064C2:  BRA    6522
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
064C4:  MOVLB  6
064C6:  CLRF   xF2
064C8:  MOVFF  68F,6F1
064CC:  CLRF   xF4
064CE:  MOVLW  B5
064D0:  MOVWF  xF3
064D2:  MOVLB  0
064D4:  CALL   0C0C
064D8:  MOVFF  02,69D
064DC:  MOVFF  01,69C
064E0:  MOVLW  06
064E2:  MOVLB  6
064E4:  ADDWF  x9C,F
064E6:  MOVLW  00
064E8:  ADDWFC x9D,F
064EA:  MOVLW  32
064EC:  ADDWF  x9C,W
064EE:  MOVWF  01
064F0:  MOVLW  00
064F2:  ADDWFC x9D,W
064F4:  MOVWF  03
064F6:  MOVF   01,W
064F8:  ADDLW  08
064FA:  MOVWF  01
064FC:  MOVLW  02
064FE:  ADDWFC 03,F
06500:  MOVFF  01,69C
06504:  MOVFF  03,69D
06508:  MOVFF  03,6C4
0650C:  MOVFF  01,6C3
06510:  CLRF   xC6
06512:  CLRF   xC5
06514:  MOVLW  0A
06516:  MOVWF  xC7
06518:  MOVLB  0
0651A:  CALL   5C9A
0651E:  MOVFF  01,69B
....................    
....................    /*** GET INPUT MAP *****************/
....................    if      (0 == chMode[arg1-1]) sprintf(retData+strlen(retData), "%d,MANUAL,", arg1);
06522:  MOVLW  01
06524:  MOVLB  6
06526:  SUBWF  x9B,W
06528:  MOVWF  x9D
0652A:  CLRF   x9F
0652C:  MOVLW  61
0652E:  MOVWF  x9E
06530:  MOVLB  0
06532:  CALL   4684
06536:  BTFSC  01.0
06538:  BRA    6584
0653A:  MOVLW  04
0653C:  MOVLB  6
0653E:  MOVWF  xD2
06540:  MOVLW  DE
06542:  MOVWF  xD1
06544:  MOVLB  0
06546:  CALL   5A88
0654A:  MOVFF  02,03
0654E:  MOVF   01,W
06550:  ADDLW  DE
06552:  MOVLB  6
06554:  MOVWF  x9C
06556:  MOVLW  04
06558:  ADDWFC 02,W
0655A:  MOVWF  x9D
0655C:  MOVFF  FE8,583
06560:  MOVFF  69C,582
06564:  MOVFF  69B,6C4
06568:  MOVLW  18
0656A:  MOVWF  xC5
0656C:  MOVLB  0
0656E:  RCALL  5FF0
06570:  MOVLW  40
06572:  MOVWF  FF6
06574:  MOVLW  03
06576:  MOVWF  FF7
06578:  MOVLW  08
0657A:  MOVLB  6
0657C:  MOVWF  x9F
0657E:  MOVLB  0
06580:  RCALL  643C
06582:  BRA    65EC
....................    else if (1 == chMode[arg1-1]) sprintf(retData+strlen(retData), "%d,MAGSNS,", arg1);
06584:  MOVLW  01
06586:  MOVLB  6
06588:  SUBWF  x9B,W
0658A:  MOVWF  x9D
0658C:  CLRF   x9F
0658E:  MOVLW  61
06590:  MOVWF  x9E
06592:  MOVLB  0
06594:  CALL   4684
06598:  BTFSS  01.0
0659A:  BRA    65E6
0659C:  MOVLW  04
0659E:  MOVLB  6
065A0:  MOVWF  xD2
065A2:  MOVLW  DE
065A4:  MOVWF  xD1
065A6:  MOVLB  0
065A8:  CALL   5A88
065AC:  MOVFF  02,03
065B0:  MOVF   01,W
065B2:  ADDLW  DE
065B4:  MOVLB  6
065B6:  MOVWF  x9C
065B8:  MOVLW  04
065BA:  ADDWFC 02,W
065BC:  MOVWF  x9D
065BE:  MOVFF  FE8,583
065C2:  MOVFF  69C,582
065C6:  MOVFF  69B,6C4
065CA:  MOVLW  18
065CC:  MOVWF  xC5
065CE:  MOVLB  0
065D0:  RCALL  5FF0
065D2:  MOVLW  4C
065D4:  MOVWF  FF6
065D6:  MOVLW  03
065D8:  MOVWF  FF7
065DA:  MOVLW  08
065DC:  MOVLB  6
065DE:  MOVWF  x9F
065E0:  MOVLB  0
065E2:  RCALL  643C
065E4:  BRA    65EC
....................    else return INV_PARAM;
065E6:  MOVLW  02
065E8:  MOVWF  01
065EA:  BRA    65F0
....................    
....................    return SUCCESS;
065EC:  MOVLW  00
065EE:  MOVWF  01
065F0:  RETURN 0
.................... }
.................... 
.................... int8 setIPchMode(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char *arg2;
....................    char *s_manual = "MANUAL";
065F2:  MOVLW  4D
065F4:  MOVLB  6
065F6:  MOVWF  xA0
065F8:  MOVLW  41
065FA:  MOVWF  xA1
065FC:  MOVLW  4E
065FE:  MOVWF  xA2
06600:  MOVLW  55
06602:  MOVWF  xA3
06604:  MOVLW  41
06606:  MOVWF  xA4
06608:  MOVLW  4C
0660A:  MOVWF  xA5
0660C:  CLRF   xA6
0660E:  MOVLW  06
06610:  MOVWF  x9F
06612:  MOVLW  A0
06614:  MOVWF  x9E
....................    char *s_magsns = "MAGSNS";
06616:  MOVLW  4D
06618:  MOVWF  xA9
0661A:  MOVLW  41
0661C:  MOVWF  xAA
0661E:  MOVLW  47
06620:  MOVWF  xAB
06622:  MOVLW  53
06624:  MOVWF  xAC
06626:  MOVLW  4E
06628:  MOVWF  xAD
0662A:  MOVLW  53
0662C:  MOVWF  xAE
0662E:  CLRF   xAF
06630:  MOVLW  06
06632:  MOVWF  xA8
06634:  MOVLW  A9
06636:  MOVWF  xA7
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
06638:  CLRF   xF2
0663A:  MOVFF  68F,6F1
0663E:  CLRF   xF4
06640:  MOVLW  B5
06642:  MOVWF  xF3
06644:  MOVLB  0
06646:  CALL   0C0C
0664A:  MOVFF  02,6B1
0664E:  MOVFF  01,6B0
06652:  MOVLW  06
06654:  MOVLB  6
06656:  ADDWF  xB0,F
06658:  MOVLW  00
0665A:  ADDWFC xB1,F
0665C:  MOVLW  32
0665E:  ADDWF  xB0,W
06660:  MOVWF  01
06662:  MOVLW  00
06664:  ADDWFC xB1,W
06666:  MOVWF  03
06668:  MOVF   01,W
0666A:  ADDLW  08
0666C:  MOVWF  01
0666E:  MOVLW  02
06670:  ADDWFC 03,F
06672:  MOVFF  01,6B0
06676:  MOVFF  03,6B1
0667A:  MOVFF  03,6C4
0667E:  MOVFF  01,6C3
06682:  MOVLB  0
06684:  CALL   5C00
06688:  MOVF   01,F
0668A:  BNZ   6694
0668C:  MOVLW  02
0668E:  MOVWF  01
06690:  BRA    680A
06692:  BRA    66F2
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06694:  MOVLB  6
06696:  CLRF   xF2
06698:  MOVFF  68F,6F1
0669C:  CLRF   xF4
0669E:  MOVLW  B5
066A0:  MOVWF  xF3
066A2:  MOVLB  0
066A4:  CALL   0C0C
066A8:  MOVFF  02,6B1
066AC:  MOVFF  01,6B0
066B0:  MOVLW  06
066B2:  MOVLB  6
066B4:  ADDWF  xB0,F
066B6:  MOVLW  00
066B8:  ADDWFC xB1,F
066BA:  MOVLW  32
066BC:  ADDWF  xB0,W
066BE:  MOVWF  01
066C0:  MOVLW  00
066C2:  ADDWFC xB1,W
066C4:  MOVWF  03
066C6:  MOVF   01,W
066C8:  ADDLW  08
066CA:  MOVWF  01
066CC:  MOVLW  02
066CE:  ADDWFC 03,F
066D0:  MOVFF  01,6B0
066D4:  MOVFF  03,6B1
066D8:  MOVFF  03,6C4
066DC:  MOVFF  01,6C3
066E0:  CLRF   xC6
066E2:  CLRF   xC5
066E4:  MOVLW  0A
066E6:  MOVWF  xC7
066E8:  MOVLB  0
066EA:  CALL   5C9A
066EE:  MOVFF  01,69B
....................    
....................    if (0 == strlen(SERcmd[rec].p[3])) return INV_PARAM;
066F2:  MOVLB  6
066F4:  CLRF   xF2
066F6:  MOVFF  68F,6F1
066FA:  CLRF   xF4
066FC:  MOVLW  B5
066FE:  MOVWF  xF3
06700:  MOVLB  0
06702:  CALL   0C0C
06706:  MOVFF  02,6B1
0670A:  MOVFF  01,6B0
0670E:  MOVLW  06
06710:  MOVLB  6
06712:  ADDWF  xB0,F
06714:  MOVLW  00
06716:  ADDWFC xB1,F
06718:  MOVLW  4B
0671A:  ADDWF  xB0,W
0671C:  MOVWF  01
0671E:  MOVLW  00
06720:  ADDWFC xB1,W
06722:  MOVWF  03
06724:  MOVF   01,W
06726:  ADDLW  08
06728:  MOVWF  01
0672A:  MOVLW  02
0672C:  ADDWFC 03,F
0672E:  MOVFF  01,6B0
06732:  MOVFF  03,6B1
06736:  MOVFF  03,6D2
0673A:  MOVFF  01,6D1
0673E:  MOVLB  0
06740:  CALL   5A88
06744:  MOVFF  02,03
06748:  MOVF   01,W
0674A:  BNZ   6758
0674C:  MOVF   03,F
0674E:  BNZ   6758
06750:  MOVLW  02
06752:  MOVWF  01
06754:  BRA    680A
06756:  BRA    679E
....................    else arg2 = SERcmd[rec].p[3];
06758:  MOVLB  6
0675A:  CLRF   xF2
0675C:  MOVFF  68F,6F1
06760:  CLRF   xF4
06762:  MOVLW  B5
06764:  MOVWF  xF3
06766:  MOVLB  0
06768:  CALL   0C0C
0676C:  MOVFF  02,6B1
06770:  MOVFF  01,6B0
06774:  MOVLW  06
06776:  MOVLB  6
06778:  ADDWF  xB0,F
0677A:  MOVLW  00
0677C:  ADDWFC xB1,F
0677E:  MOVLW  4B
06780:  ADDWF  xB0,W
06782:  MOVWF  01
06784:  MOVLW  00
06786:  ADDWFC xB1,W
06788:  MOVWF  03
0678A:  MOVF   01,W
0678C:  ADDLW  08
0678E:  MOVWF  01
06790:  MOVLW  02
06792:  ADDWFC 03,F
06794:  MOVFF  01,69C
06798:  MOVFF  03,69D
0679C:  MOVLB  0
....................    
....................    /*** SET INPUT MAP *****************/
....................    if      (0 == strcmp(s_manual, arg2)) chMode[arg1-1] = MANUAL;
0679E:  MOVFF  69F,6D2
067A2:  MOVFF  69E,6D1
067A6:  MOVFF  69D,6D4
067AA:  MOVFF  69C,6D3
067AE:  CALL   5AC0
067B2:  MOVF   01,F
067B4:  BNZ   67CE
067B6:  MOVLW  01
067B8:  MOVLB  6
067BA:  SUBWF  x9B,W
067BC:  MOVWF  xB0
067BE:  MOVWF  xB2
067C0:  CLRF   xB3
067C2:  CLRF   xB5
067C4:  MOVLW  61
067C6:  MOVWF  xB4
067C8:  MOVLB  0
067CA:  RCALL  624C
067CC:  BRA    6806
....................    else if (0 == strcmp(s_magsns, arg2)) chMode[arg1-1] = MAGSNS;
067CE:  MOVFF  6A8,6D2
067D2:  MOVFF  6A7,6D1
067D6:  MOVFF  69D,6D4
067DA:  MOVFF  69C,6D3
067DE:  CALL   5AC0
067E2:  MOVF   01,F
067E4:  BNZ   6800
067E6:  MOVLW  01
067E8:  MOVLB  6
067EA:  SUBWF  x9B,W
067EC:  MOVWF  xB0
067EE:  MOVWF  xB2
067F0:  MOVLW  01
067F2:  MOVWF  xB3
067F4:  CLRF   xB5
067F6:  MOVLW  61
067F8:  MOVWF  xB4
067FA:  MOVLB  0
067FC:  RCALL  624C
067FE:  BRA    6806
....................    else return INV_PARAM;
06800:  MOVLW  02
06802:  MOVWF  01
06804:  BRA    680A
....................    
....................    return SUCCESS;
06806:  MOVLW  00
06808:  MOVWF  01
0680A:  RETURN 0
.................... }
.................... 
.................... int8 getPIDvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/ 
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
069C2:  MOVLB  6
069C4:  CLRF   xF2
069C6:  MOVFF  68F,6F1
069CA:  CLRF   xF4
069CC:  MOVLW  B5
069CE:  MOVWF  xF3
069D0:  MOVLB  0
069D2:  CALL   0C0C
069D6:  MOVFF  02,69E
069DA:  MOVFF  01,69D
069DE:  MOVLW  06
069E0:  MOVLB  6
069E2:  ADDWF  x9D,F
069E4:  MOVLW  00
069E6:  ADDWFC x9E,F
069E8:  MOVLW  32
069EA:  ADDWF  x9D,W
069EC:  MOVWF  01
069EE:  MOVLW  00
069F0:  ADDWFC x9E,W
069F2:  MOVWF  03
069F4:  MOVF   01,W
069F6:  ADDLW  08
069F8:  MOVWF  01
069FA:  MOVLW  02
069FC:  ADDWFC 03,F
069FE:  MOVFF  01,69D
06A02:  MOVFF  03,69E
06A06:  MOVFF  03,6C4
06A0A:  MOVFF  01,6C3
06A0E:  MOVLB  0
06A10:  CALL   5C00
06A14:  MOVF   01,F
06A16:  BNZ   6A20
06A18:  MOVLW  02
06A1A:  MOVWF  01
06A1C:  BRA    6E76
06A1E:  BRA    6A7E
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06A20:  MOVLB  6
06A22:  CLRF   xF2
06A24:  MOVFF  68F,6F1
06A28:  CLRF   xF4
06A2A:  MOVLW  B5
06A2C:  MOVWF  xF3
06A2E:  MOVLB  0
06A30:  CALL   0C0C
06A34:  MOVFF  02,69E
06A38:  MOVFF  01,69D
06A3C:  MOVLW  06
06A3E:  MOVLB  6
06A40:  ADDWF  x9D,F
06A42:  MOVLW  00
06A44:  ADDWFC x9E,F
06A46:  MOVLW  32
06A48:  ADDWF  x9D,W
06A4A:  MOVWF  01
06A4C:  MOVLW  00
06A4E:  ADDWFC x9E,W
06A50:  MOVWF  03
06A52:  MOVF   01,W
06A54:  ADDLW  08
06A56:  MOVWF  01
06A58:  MOVLW  02
06A5A:  ADDWFC 03,F
06A5C:  MOVFF  01,69D
06A60:  MOVFF  03,69E
06A64:  MOVFF  03,6C4
06A68:  MOVFF  01,6C3
06A6C:  CLRF   xC6
06A6E:  CLRF   xC5
06A70:  MOVLW  0A
06A72:  MOVWF  xC7
06A74:  MOVLB  0
06A76:  CALL   5C9A
06A7A:  MOVFF  01,69B
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
06A7E:  MOVLB  6
06A80:  CLRF   xF2
06A82:  MOVFF  68F,6F1
06A86:  CLRF   xF4
06A88:  MOVLW  B5
06A8A:  MOVWF  xF3
06A8C:  MOVLB  0
06A8E:  CALL   0C0C
06A92:  MOVFF  02,69E
06A96:  MOVFF  01,69D
06A9A:  MOVLW  06
06A9C:  MOVLB  6
06A9E:  ADDWF  x9D,F
06AA0:  MOVLW  00
06AA2:  ADDWFC x9E,F
06AA4:  MOVLW  4B
06AA6:  ADDWF  x9D,W
06AA8:  MOVWF  01
06AAA:  MOVLW  00
06AAC:  ADDWFC x9E,W
06AAE:  MOVWF  03
06AB0:  MOVF   01,W
06AB2:  ADDLW  08
06AB4:  MOVWF  01
06AB6:  MOVLW  02
06AB8:  ADDWFC 03,F
06ABA:  MOVFF  01,69D
06ABE:  MOVFF  03,69E
06AC2:  MOVFF  03,6D2
06AC6:  MOVFF  01,6D1
06ACA:  MOVLB  0
06ACC:  CALL   5A88
06AD0:  MOVFF  02,03
06AD4:  MOVF   01,W
06AD6:  SUBLW  01
06AD8:  BNZ   6ADE
06ADA:  MOVF   03,F
06ADC:  BZ    6AE6
06ADE:  MOVLW  02
06AE0:  MOVWF  01
06AE2:  BRA    6E76
06AE4:  BRA    6B26
....................    else arg2 = SERcmd[rec].p[3][0];
06AE6:  MOVLB  6
06AE8:  CLRF   xF2
06AEA:  MOVFF  68F,6F1
06AEE:  CLRF   xF4
06AF0:  MOVLW  B5
06AF2:  MOVWF  xF3
06AF4:  MOVLB  0
06AF6:  CALL   0C0C
06AFA:  MOVFF  02,69E
06AFE:  MOVFF  01,69D
06B02:  MOVLW  06
06B04:  MOVLB  6
06B06:  ADDWF  x9D,F
06B08:  MOVLW  00
06B0A:  ADDWFC x9E,F
06B0C:  MOVLW  4B
06B0E:  ADDWF  x9D,F
06B10:  MOVLW  00
06B12:  ADDWFC x9E,F
06B14:  MOVLW  08
06B16:  ADDWF  x9D,W
06B18:  MOVWF  FE9
06B1A:  MOVLW  02
06B1C:  ADDWFC x9E,W
06B1E:  MOVWF  FEA
06B20:  MOVFF  FEF,69C
06B24:  MOVLB  0
....................    
....................    /*** GET P, I, D, or A(LL) VALUE **********/
....................    if      ('P' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kP);
06B26:  MOVLB  6
06B28:  MOVF   x9C,W
06B2A:  SUBLW  50
06B2C:  BNZ   6BC6
06B2E:  MOVLW  04
06B30:  MOVWF  xD2
06B32:  MOVLW  DE
06B34:  MOVWF  xD1
06B36:  MOVLB  0
06B38:  CALL   5A88
06B3C:  MOVFF  02,03
06B40:  MOVF   01,W
06B42:  ADDLW  DE
06B44:  MOVLB  6
06B46:  MOVWF  x9D
06B48:  MOVLW  04
06B4A:  ADDWFC 02,W
06B4C:  MOVWF  x9E
06B4E:  MOVLW  01
06B50:  SUBWF  x9B,W
06B52:  MULLW  20
06B54:  MOVF   FF3,W
06B56:  CLRF   xA0
06B58:  MOVWF  x9F
06B5A:  MOVLW  20
06B5C:  ADDWF  x9F,W
06B5E:  MOVWF  FE9
06B60:  MOVLW  00
06B62:  ADDWFC xA0,W
06B64:  MOVWF  FEA
06B66:  MOVFF  FEF,6A1
06B6A:  MOVFF  FEC,6A2
06B6E:  MOVFF  FEC,6A3
06B72:  MOVFF  FEC,6A4
06B76:  MOVFF  69E,583
06B7A:  MOVFF  69D,582
06B7E:  MOVFF  69B,6C4
06B82:  MOVLW  18
06B84:  MOVWF  xC5
06B86:  MOVLB  0
06B88:  CALL   5FF0
06B8C:  MOVLW  2C
06B8E:  MOVLB  6
06B90:  MOVWF  xE0
06B92:  MOVLB  0
06B94:  CALL   5B38
06B98:  MOVLW  89
06B9A:  MOVWF  FE9
06B9C:  MOVFF  6A4,6D6
06BA0:  MOVFF  6A3,6D5
06BA4:  MOVFF  6A2,6D4
06BA8:  MOVFF  6A1,6D3
06BAC:  MOVLW  02
06BAE:  MOVLB  6
06BB0:  MOVWF  xD7
06BB2:  MOVLB  0
06BB4:  RCALL  680C
06BB6:  MOVLW  2C
06BB8:  MOVLB  6
06BBA:  MOVWF  xE0
06BBC:  MOVLB  0
06BBE:  CALL   5B38
06BC2:  BRA    6E72
06BC4:  MOVLB  6
....................    else if ('I' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kI);
06BC6:  MOVF   x9C,W
06BC8:  SUBLW  49
06BCA:  BNZ   6C6C
06BCC:  MOVLW  04
06BCE:  MOVWF  xD2
06BD0:  MOVLW  DE
06BD2:  MOVWF  xD1
06BD4:  MOVLB  0
06BD6:  CALL   5A88
06BDA:  MOVF   01,W
06BDC:  ADDLW  DE
06BDE:  MOVLB  6
06BE0:  MOVWF  x9D
06BE2:  MOVLW  04
06BE4:  ADDWFC 02,W
06BE6:  MOVWF  x9E
06BE8:  MOVLW  01
06BEA:  SUBWF  x9B,W
06BEC:  MULLW  20
06BEE:  MOVF   FF3,W
06BF0:  CLRF   xA0
06BF2:  MOVWF  x9F
06BF4:  MOVLW  04
06BF6:  ADDWF  x9F,W
06BF8:  MOVWF  01
06BFA:  MOVLW  00
06BFC:  ADDWFC xA0,W
06BFE:  MOVWF  03
06C00:  MOVF   01,W
06C02:  ADDLW  20
06C04:  MOVWF  FE9
06C06:  MOVLW  00
06C08:  ADDWFC 03,W
06C0A:  MOVWF  FEA
06C0C:  MOVFF  FEF,69F
06C10:  MOVFF  FEC,6A0
06C14:  MOVFF  FEC,6A1
06C18:  MOVFF  FEC,6A2
06C1C:  MOVFF  69E,583
06C20:  MOVFF  69D,582
06C24:  MOVFF  69B,6C4
06C28:  MOVLW  18
06C2A:  MOVWF  xC5
06C2C:  MOVLB  0
06C2E:  CALL   5FF0
06C32:  MOVLW  2C
06C34:  MOVLB  6
06C36:  MOVWF  xE0
06C38:  MOVLB  0
06C3A:  CALL   5B38
06C3E:  MOVLW  89
06C40:  MOVWF  FE9
06C42:  MOVFF  6A2,6D6
06C46:  MOVFF  6A1,6D5
06C4A:  MOVFF  6A0,6D4
06C4E:  MOVFF  69F,6D3
06C52:  MOVLW  02
06C54:  MOVLB  6
06C56:  MOVWF  xD7
06C58:  MOVLB  0
06C5A:  RCALL  680C
06C5C:  MOVLW  2C
06C5E:  MOVLB  6
06C60:  MOVWF  xE0
06C62:  MOVLB  0
06C64:  CALL   5B38
06C68:  BRA    6E72
06C6A:  MOVLB  6
....................    else if ('D' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kD);
06C6C:  MOVF   x9C,W
06C6E:  SUBLW  44
06C70:  BNZ   6D12
06C72:  MOVLW  04
06C74:  MOVWF  xD2
06C76:  MOVLW  DE
06C78:  MOVWF  xD1
06C7A:  MOVLB  0
06C7C:  CALL   5A88
06C80:  MOVF   01,W
06C82:  ADDLW  DE
06C84:  MOVLB  6
06C86:  MOVWF  x9D
06C88:  MOVLW  04
06C8A:  ADDWFC 02,W
06C8C:  MOVWF  x9E
06C8E:  MOVLW  01
06C90:  SUBWF  x9B,W
06C92:  MULLW  20
06C94:  MOVF   FF3,W
06C96:  CLRF   xA0
06C98:  MOVWF  x9F
06C9A:  MOVLW  08
06C9C:  ADDWF  x9F,W
06C9E:  MOVWF  01
06CA0:  MOVLW  00
06CA2:  ADDWFC xA0,W
06CA4:  MOVWF  03
06CA6:  MOVF   01,W
06CA8:  ADDLW  20
06CAA:  MOVWF  FE9
06CAC:  MOVLW  00
06CAE:  ADDWFC 03,W
06CB0:  MOVWF  FEA
06CB2:  MOVFF  FEF,69F
06CB6:  MOVFF  FEC,6A0
06CBA:  MOVFF  FEC,6A1
06CBE:  MOVFF  FEC,6A2
06CC2:  MOVFF  69E,583
06CC6:  MOVFF  69D,582
06CCA:  MOVFF  69B,6C4
06CCE:  MOVLW  18
06CD0:  MOVWF  xC5
06CD2:  MOVLB  0
06CD4:  CALL   5FF0
06CD8:  MOVLW  2C
06CDA:  MOVLB  6
06CDC:  MOVWF  xE0
06CDE:  MOVLB  0
06CE0:  CALL   5B38
06CE4:  MOVLW  89
06CE6:  MOVWF  FE9
06CE8:  MOVFF  6A2,6D6
06CEC:  MOVFF  6A1,6D5
06CF0:  MOVFF  6A0,6D4
06CF4:  MOVFF  69F,6D3
06CF8:  MOVLW  02
06CFA:  MOVLB  6
06CFC:  MOVWF  xD7
06CFE:  MOVLB  0
06D00:  RCALL  680C
06D02:  MOVLW  2C
06D04:  MOVLB  6
06D06:  MOVWF  xE0
06D08:  MOVLB  0
06D0A:  CALL   5B38
06D0E:  BRA    6E72
06D10:  MOVLB  6
....................    else if ('A' == arg2) sprintf(retData+strlen(retData), "%d,%f,%f,%f,", arg1, PID[arg1-1].kP, PID[arg1-1].kI, PID[arg1-1].kD);
06D12:  MOVF   x9C,W
06D14:  SUBLW  41
06D16:  BTFSS  FD8.2
06D18:  BRA    6E6A
06D1A:  MOVLW  04
06D1C:  MOVWF  xD2
06D1E:  MOVLW  DE
06D20:  MOVWF  xD1
06D22:  MOVLB  0
06D24:  CALL   5A88
06D28:  MOVF   01,W
06D2A:  ADDLW  DE
06D2C:  MOVLB  6
06D2E:  MOVWF  x9D
06D30:  MOVLW  04
06D32:  ADDWFC 02,W
06D34:  MOVWF  x9E
06D36:  MOVLW  01
06D38:  SUBWF  x9B,W
06D3A:  MULLW  20
06D3C:  MOVF   FF3,W
06D3E:  CLRF   xA0
06D40:  MOVWF  x9F
06D42:  MOVLW  20
06D44:  ADDWF  x9F,W
06D46:  MOVWF  FE9
06D48:  MOVLW  00
06D4A:  ADDWFC xA0,W
06D4C:  MOVWF  FEA
06D4E:  MOVFF  FEF,6A1
06D52:  MOVFF  FEC,6A2
06D56:  MOVFF  FEC,6A3
06D5A:  MOVFF  FEC,6A4
06D5E:  MOVLW  01
06D60:  SUBWF  x9B,W
06D62:  MULLW  20
06D64:  MOVF   FF3,W
06D66:  CLRF   xA6
06D68:  MOVWF  xA5
06D6A:  MOVLW  04
06D6C:  ADDWF  xA5,W
06D6E:  MOVWF  01
06D70:  MOVLW  00
06D72:  ADDWFC xA6,W
06D74:  MOVWF  03
06D76:  MOVF   01,W
06D78:  ADDLW  20
06D7A:  MOVWF  FE9
06D7C:  MOVLW  00
06D7E:  ADDWFC 03,W
06D80:  MOVWF  FEA
06D82:  MOVFF  FEF,6A5
06D86:  MOVFF  FEC,6A6
06D8A:  MOVFF  FEC,6A7
06D8E:  MOVFF  FEC,6A8
06D92:  MOVLW  01
06D94:  SUBWF  x9B,W
06D96:  MULLW  20
06D98:  MOVF   FF3,W
06D9A:  CLRF   xAA
06D9C:  MOVWF  xA9
06D9E:  MOVLW  08
06DA0:  ADDWF  xA9,W
06DA2:  MOVWF  01
06DA4:  MOVLW  00
06DA6:  ADDWFC xAA,W
06DA8:  MOVWF  03
06DAA:  MOVF   01,W
06DAC:  ADDLW  20
06DAE:  MOVWF  FE9
06DB0:  MOVLW  00
06DB2:  ADDWFC 03,W
06DB4:  MOVWF  FEA
06DB6:  MOVFF  FEF,6A9
06DBA:  MOVFF  FEC,6AA
06DBE:  MOVFF  FEC,6AB
06DC2:  MOVFF  FEC,6AC
06DC6:  MOVFF  69E,583
06DCA:  MOVFF  69D,582
06DCE:  MOVFF  69B,6C4
06DD2:  MOVLW  18
06DD4:  MOVWF  xC5
06DD6:  MOVLB  0
06DD8:  CALL   5FF0
06DDC:  MOVLW  2C
06DDE:  MOVLB  6
06DE0:  MOVWF  xE0
06DE2:  MOVLB  0
06DE4:  CALL   5B38
06DE8:  MOVLW  89
06DEA:  MOVWF  FE9
06DEC:  MOVFF  6A4,6D6
06DF0:  MOVFF  6A3,6D5
06DF4:  MOVFF  6A2,6D4
06DF8:  MOVFF  6A1,6D3
06DFC:  MOVLW  02
06DFE:  MOVLB  6
06E00:  MOVWF  xD7
06E02:  MOVLB  0
06E04:  RCALL  680C
06E06:  MOVLW  2C
06E08:  MOVLB  6
06E0A:  MOVWF  xE0
06E0C:  MOVLB  0
06E0E:  CALL   5B38
06E12:  MOVLW  89
06E14:  MOVWF  FE9
06E16:  MOVFF  6A8,6D6
06E1A:  MOVFF  6A7,6D5
06E1E:  MOVFF  6A6,6D4
06E22:  MOVFF  6A5,6D3
06E26:  MOVLW  02
06E28:  MOVLB  6
06E2A:  MOVWF  xD7
06E2C:  MOVLB  0
06E2E:  RCALL  680C
06E30:  MOVLW  2C
06E32:  MOVLB  6
06E34:  MOVWF  xE0
06E36:  MOVLB  0
06E38:  CALL   5B38
06E3C:  MOVLW  89
06E3E:  MOVWF  FE9
06E40:  MOVFF  6AC,6D6
06E44:  MOVFF  6AB,6D5
06E48:  MOVFF  6AA,6D4
06E4C:  MOVFF  6A9,6D3
06E50:  MOVLW  02
06E52:  MOVLB  6
06E54:  MOVWF  xD7
06E56:  MOVLB  0
06E58:  RCALL  680C
06E5A:  MOVLW  2C
06E5C:  MOVLB  6
06E5E:  MOVWF  xE0
06E60:  MOVLB  0
06E62:  CALL   5B38
06E66:  BRA    6E72
06E68:  MOVLB  6
....................    else return INV_PARAM;
06E6A:  MOVLW  02
06E6C:  MOVWF  01
06E6E:  MOVLB  0
06E70:  BRA    6E76
....................    
....................    return SUCCESS;
06E72:  MOVLW  00
06E74:  MOVWF  01
06E76:  RETURN 0
.................... }
.................... 
.................... int8 setPIDvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char  arg2;
....................    float arg3;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
07194:  MOVLB  6
07196:  CLRF   xF2
07198:  MOVFF  68F,6F1
0719C:  CLRF   xF4
0719E:  MOVLW  B5
071A0:  MOVWF  xF3
071A2:  MOVLB  0
071A4:  CALL   0C0C
071A8:  MOVFF  02,6A2
071AC:  MOVFF  01,6A1
071B0:  MOVLW  06
071B2:  MOVLB  6
071B4:  ADDWF  xA1,F
071B6:  MOVLW  00
071B8:  ADDWFC xA2,F
071BA:  MOVLW  32
071BC:  ADDWF  xA1,W
071BE:  MOVWF  01
071C0:  MOVLW  00
071C2:  ADDWFC xA2,W
071C4:  MOVWF  03
071C6:  MOVF   01,W
071C8:  ADDLW  08
071CA:  MOVWF  01
071CC:  MOVLW  02
071CE:  ADDWFC 03,F
071D0:  MOVFF  01,6A1
071D4:  MOVFF  03,6A2
071D8:  MOVFF  03,6C4
071DC:  MOVFF  01,6C3
071E0:  MOVLB  0
071E2:  CALL   5C00
071E6:  MOVF   01,F
071E8:  BNZ   71F2
071EA:  MOVLW  02
071EC:  MOVWF  01
071EE:  BRA    7472
071F0:  BRA    7250
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
071F2:  MOVLB  6
071F4:  CLRF   xF2
071F6:  MOVFF  68F,6F1
071FA:  CLRF   xF4
071FC:  MOVLW  B5
071FE:  MOVWF  xF3
07200:  MOVLB  0
07202:  CALL   0C0C
07206:  MOVFF  02,6A2
0720A:  MOVFF  01,6A1
0720E:  MOVLW  06
07210:  MOVLB  6
07212:  ADDWF  xA1,F
07214:  MOVLW  00
07216:  ADDWFC xA2,F
07218:  MOVLW  32
0721A:  ADDWF  xA1,W
0721C:  MOVWF  01
0721E:  MOVLW  00
07220:  ADDWFC xA2,W
07222:  MOVWF  03
07224:  MOVF   01,W
07226:  ADDLW  08
07228:  MOVWF  01
0722A:  MOVLW  02
0722C:  ADDWFC 03,F
0722E:  MOVFF  01,6A1
07232:  MOVFF  03,6A2
07236:  MOVFF  03,6C4
0723A:  MOVFF  01,6C3
0723E:  CLRF   xC6
07240:  CLRF   xC5
07242:  MOVLW  0A
07244:  MOVWF  xC7
07246:  MOVLB  0
07248:  CALL   5C9A
0724C:  MOVFF  01,69B
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
07250:  MOVLB  6
07252:  CLRF   xF2
07254:  MOVFF  68F,6F1
07258:  CLRF   xF4
0725A:  MOVLW  B5
0725C:  MOVWF  xF3
0725E:  MOVLB  0
07260:  CALL   0C0C
07264:  MOVFF  02,6A2
07268:  MOVFF  01,6A1
0726C:  MOVLW  06
0726E:  MOVLB  6
07270:  ADDWF  xA1,F
07272:  MOVLW  00
07274:  ADDWFC xA2,F
07276:  MOVLW  4B
07278:  ADDWF  xA1,W
0727A:  MOVWF  01
0727C:  MOVLW  00
0727E:  ADDWFC xA2,W
07280:  MOVWF  03
07282:  MOVF   01,W
07284:  ADDLW  08
07286:  MOVWF  01
07288:  MOVLW  02
0728A:  ADDWFC 03,F
0728C:  MOVFF  01,6A1
07290:  MOVFF  03,6A2
07294:  MOVFF  03,6D2
07298:  MOVFF  01,6D1
0729C:  MOVLB  0
0729E:  CALL   5A88
072A2:  MOVFF  02,03
072A6:  MOVF   01,W
072A8:  SUBLW  01
072AA:  BNZ   72B0
072AC:  MOVF   03,F
072AE:  BZ    72B8
072B0:  MOVLW  02
072B2:  MOVWF  01
072B4:  BRA    7472
072B6:  BRA    72F8
....................    else arg2 = SERcmd[rec].p[3][0];
072B8:  MOVLB  6
072BA:  CLRF   xF2
072BC:  MOVFF  68F,6F1
072C0:  CLRF   xF4
072C2:  MOVLW  B5
072C4:  MOVWF  xF3
072C6:  MOVLB  0
072C8:  CALL   0C0C
072CC:  MOVFF  02,6A2
072D0:  MOVFF  01,6A1
072D4:  MOVLW  06
072D6:  MOVLB  6
072D8:  ADDWF  xA1,F
072DA:  MOVLW  00
072DC:  ADDWFC xA2,F
072DE:  MOVLW  4B
072E0:  ADDWF  xA1,F
072E2:  MOVLW  00
072E4:  ADDWFC xA2,F
072E6:  MOVLW  08
072E8:  ADDWF  xA1,W
072EA:  MOVWF  FE9
072EC:  MOVLW  02
072EE:  ADDWFC xA2,W
072F0:  MOVWF  FEA
072F2:  MOVFF  FEF,69C
072F6:  MOVLB  0
....................    
....................    if (!arg_is_float(SERcmd[rec].p[4])) return INV_PARAM;
072F8:  MOVLB  6
072FA:  CLRF   xF2
072FC:  MOVFF  68F,6F1
07300:  CLRF   xF4
07302:  MOVLW  B5
07304:  MOVWF  xF3
07306:  MOVLB  0
07308:  CALL   0C0C
0730C:  MOVFF  02,6A2
07310:  MOVFF  01,6A1
07314:  MOVLW  06
07316:  MOVLB  6
07318:  ADDWF  xA1,F
0731A:  MOVLW  00
0731C:  ADDWFC xA2,F
0731E:  MOVLW  64
07320:  ADDWF  xA1,W
07322:  MOVWF  01
07324:  MOVLW  00
07326:  ADDWFC xA2,W
07328:  MOVWF  03
0732A:  MOVF   01,W
0732C:  ADDLW  08
0732E:  MOVWF  01
07330:  MOVLW  02
07332:  ADDWFC 03,F
07334:  MOVFF  01,6A1
07338:  MOVFF  03,6A2
0733C:  MOVFF  03,6A5
07340:  MOVFF  01,6A4
07344:  MOVLB  0
07346:  RCALL  6E78
07348:  MOVF   01,F
0734A:  BNZ   7354
0734C:  MOVLW  02
0734E:  MOVWF  01
07350:  BRA    7472
07352:  BRA    73B8
....................    else arg3 = strtod(SERcmd[rec].p[4], '\0');
07354:  MOVLB  6
07356:  CLRF   xF2
07358:  MOVFF  68F,6F1
0735C:  CLRF   xF4
0735E:  MOVLW  B5
07360:  MOVWF  xF3
07362:  MOVLB  0
07364:  CALL   0C0C
07368:  MOVFF  02,6A2
0736C:  MOVFF  01,6A1
07370:  MOVLW  06
07372:  MOVLB  6
07374:  ADDWF  xA1,F
07376:  MOVLW  00
07378:  ADDWFC xA2,F
0737A:  MOVLW  64
0737C:  ADDWF  xA1,W
0737E:  MOVWF  01
07380:  MOVLW  00
07382:  ADDWFC xA2,W
07384:  MOVWF  03
07386:  MOVF   01,W
07388:  ADDLW  08
0738A:  MOVWF  01
0738C:  MOVLW  02
0738E:  ADDWFC 03,F
07390:  MOVFF  01,6A1
07394:  MOVFF  03,6A2
07398:  MOVFF  03,6A5
0739C:  MOVFF  01,6A4
073A0:  CLRF   xA7
073A2:  CLRF   xA6
073A4:  MOVLB  0
073A6:  RCALL  6F3A
073A8:  MOVFF  03,6A0
073AC:  MOVFF  02,69F
073B0:  MOVFF  01,69E
073B4:  MOVFF  00,69D
....................    
....................    /*** SET P, I, or D VALUE **********/
....................    if      ('P' == arg2) PID[arg1-1].kP = arg3;
073B8:  MOVLB  6
073BA:  MOVF   x9C,W
073BC:  SUBLW  50
073BE:  BNZ   73EA
073C0:  MOVLW  01
073C2:  SUBWF  x9B,W
073C4:  MULLW  20
073C6:  MOVF   FF3,W
073C8:  CLRF   xA2
073CA:  MOVWF  xA1
073CC:  MOVLW  20
073CE:  ADDWF  xA1,W
073D0:  MOVWF  FE9
073D2:  MOVLW  00
073D4:  ADDWFC xA2,W
073D6:  MOVWF  FEA
073D8:  MOVFF  69D,FEF
073DC:  MOVFF  69E,FEC
073E0:  MOVFF  69F,FEC
073E4:  MOVFF  6A0,FEC
073E8:  BRA    746C
....................    else if ('I' == arg2) PID[arg1-1].kI = arg3;
073EA:  MOVF   x9C,W
073EC:  SUBLW  49
073EE:  BNZ   7426
073F0:  MOVLW  01
073F2:  SUBWF  x9B,W
073F4:  MULLW  20
073F6:  MOVF   FF3,W
073F8:  CLRF   xA2
073FA:  MOVWF  xA1
073FC:  MOVLW  04
073FE:  ADDWF  xA1,W
07400:  MOVWF  01
07402:  MOVLW  00
07404:  ADDWFC xA2,W
07406:  MOVWF  03
07408:  MOVF   01,W
0740A:  ADDLW  20
0740C:  MOVWF  FE9
0740E:  MOVLW  00
07410:  ADDWFC 03,W
07412:  MOVWF  FEA
07414:  MOVFF  69D,FEF
07418:  MOVFF  69E,FEC
0741C:  MOVFF  69F,FEC
07420:  MOVFF  6A0,FEC
07424:  BRA    746C
....................    else if ('D' == arg2) PID[arg1-1].kD = arg3;
07426:  MOVF   x9C,W
07428:  SUBLW  44
0742A:  BNZ   7462
0742C:  MOVLW  01
0742E:  SUBWF  x9B,W
07430:  MULLW  20
07432:  MOVF   FF3,W
07434:  CLRF   xA2
07436:  MOVWF  xA1
07438:  MOVLW  08
0743A:  ADDWF  xA1,W
0743C:  MOVWF  01
0743E:  MOVLW  00
07440:  ADDWFC xA2,W
07442:  MOVWF  03
07444:  MOVF   01,W
07446:  ADDLW  20
07448:  MOVWF  FE9
0744A:  MOVLW  00
0744C:  ADDWFC 03,W
0744E:  MOVWF  FEA
07450:  MOVFF  69D,FEF
07454:  MOVFF  69E,FEC
07458:  MOVFF  69F,FEC
0745C:  MOVFF  6A0,FEC
07460:  BRA    746C
....................    else return INV_PARAM;
07462:  MOVLW  02
07464:  MOVWF  01
07466:  MOVLB  0
07468:  BRA    7472
0746A:  MOVLB  6
....................    
....................    return SUCCESS;
0746C:  MOVLW  00
0746E:  MOVWF  01
07470:  MOVLB  0
07472:  RETURN 0
.................... }
.................... 
.................... //!int8 enablePID(unsigned int8 rec){
.................... //!   /*** ARG CHECKS ********************/
.................... //!   int8  arg1;
.................... //!   
.................... //!   if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
.................... //!   else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
.................... //!   
.................... //!   PID[arg1-1].enable = TRUE;
.................... //!   
.................... //!   return SUCCESS;
.................... //!}
.................... //!
.................... //!int8 disablePID(unsigned int8 rec){
.................... //!   /*** ARG CHECKS ********************/
.................... //!   int8  arg1;
.................... //!   
.................... //!   if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
.................... //!   else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
.................... //!   
.................... //!   PID[arg1-1].enable = FALSE;
.................... //!   
.................... //!   return SUCCESS;
.................... //!}
.................... 
.................... int8 getSetPoint(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
07474:  MOVLB  6
07476:  CLRF   xF2
07478:  MOVFF  68F,6F1
0747C:  CLRF   xF4
0747E:  MOVLW  B5
07480:  MOVWF  xF3
07482:  MOVLB  0
07484:  CALL   0C0C
07488:  MOVFF  02,69D
0748C:  MOVFF  01,69C
07490:  MOVLW  06
07492:  MOVLB  6
07494:  ADDWF  x9C,F
07496:  MOVLW  00
07498:  ADDWFC x9D,F
0749A:  MOVLW  32
0749C:  ADDWF  x9C,W
0749E:  MOVWF  01
074A0:  MOVLW  00
074A2:  ADDWFC x9D,W
074A4:  MOVWF  03
074A6:  MOVF   01,W
074A8:  ADDLW  08
074AA:  MOVWF  01
074AC:  MOVLW  02
074AE:  ADDWFC 03,F
074B0:  MOVFF  01,69C
074B4:  MOVFF  03,69D
074B8:  MOVFF  03,6C4
074BC:  MOVFF  01,6C3
074C0:  MOVLB  0
074C2:  CALL   5C00
074C6:  MOVF   01,F
074C8:  BNZ   74D2
074CA:  MOVLW  02
074CC:  MOVWF  01
074CE:  BRA    75D4
074D0:  BRA    7530
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
074D2:  MOVLB  6
074D4:  CLRF   xF2
074D6:  MOVFF  68F,6F1
074DA:  CLRF   xF4
074DC:  MOVLW  B5
074DE:  MOVWF  xF3
074E0:  MOVLB  0
074E2:  CALL   0C0C
074E6:  MOVFF  02,69D
074EA:  MOVFF  01,69C
074EE:  MOVLW  06
074F0:  MOVLB  6
074F2:  ADDWF  x9C,F
074F4:  MOVLW  00
074F6:  ADDWFC x9D,F
074F8:  MOVLW  32
074FA:  ADDWF  x9C,W
074FC:  MOVWF  01
074FE:  MOVLW  00
07500:  ADDWFC x9D,W
07502:  MOVWF  03
07504:  MOVF   01,W
07506:  ADDLW  08
07508:  MOVWF  01
0750A:  MOVLW  02
0750C:  ADDWFC 03,F
0750E:  MOVFF  01,69C
07512:  MOVFF  03,69D
07516:  MOVFF  03,6C4
0751A:  MOVFF  01,6C3
0751E:  CLRF   xC6
07520:  CLRF   xC5
07522:  MOVLW  0A
07524:  MOVWF  xC7
07526:  MOVLB  0
07528:  CALL   5C9A
0752C:  MOVFF  01,69B
....................    
....................    /*** GET SETPOINT ******************/ 
....................    sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].SP);
07530:  MOVLW  04
07532:  MOVLB  6
07534:  MOVWF  xD2
07536:  MOVLW  DE
07538:  MOVWF  xD1
0753A:  MOVLB  0
0753C:  CALL   5A88
07540:  MOVF   01,W
07542:  ADDLW  DE
07544:  MOVLB  6
07546:  MOVWF  x9C
07548:  MOVLW  04
0754A:  ADDWFC 02,W
0754C:  MOVWF  x9D
0754E:  MOVLW  01
07550:  SUBWF  x9B,W
07552:  MULLW  20
07554:  MOVF   FF3,W
07556:  CLRF   x9F
07558:  MOVWF  x9E
0755A:  MOVLW  0C
0755C:  ADDWF  x9E,W
0755E:  MOVWF  01
07560:  MOVLW  00
07562:  ADDWFC x9F,W
07564:  MOVWF  03
07566:  MOVF   01,W
07568:  ADDLW  20
0756A:  MOVWF  FE9
0756C:  MOVLW  00
0756E:  ADDWFC 03,W
07570:  MOVWF  FEA
07572:  MOVFF  FEF,69E
07576:  MOVFF  FEC,69F
0757A:  MOVFF  FEC,6A0
0757E:  MOVFF  FEC,6A1
07582:  MOVFF  69D,583
07586:  MOVFF  69C,582
0758A:  MOVFF  69B,6C4
0758E:  MOVLW  18
07590:  MOVWF  xC5
07592:  MOVLB  0
07594:  CALL   5FF0
07598:  MOVLW  2C
0759A:  MOVLB  6
0759C:  MOVWF  xE0
0759E:  MOVLB  0
075A0:  CALL   5B38
075A4:  MOVLW  89
075A6:  MOVWF  FE9
075A8:  MOVFF  6A1,6D6
075AC:  MOVFF  6A0,6D5
075B0:  MOVFF  69F,6D4
075B4:  MOVFF  69E,6D3
075B8:  MOVLW  02
075BA:  MOVLB  6
075BC:  MOVWF  xD7
075BE:  MOVLB  0
075C0:  CALL   680C
075C4:  MOVLW  2C
075C6:  MOVLB  6
075C8:  MOVWF  xE0
075CA:  MOVLB  0
075CC:  CALL   5B38
....................    return SUCCESS;
075D0:  MOVLW  00
075D2:  MOVWF  01
075D4:  RETURN 0
.................... }
.................... 
.................... int8 setSetPoint(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/   
....................    int8  arg1;
....................    float arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
075D6:  MOVLB  6
075D8:  CLRF   xF2
075DA:  MOVFF  68F,6F1
075DE:  CLRF   xF4
075E0:  MOVLW  B5
075E2:  MOVWF  xF3
075E4:  MOVLB  0
075E6:  CALL   0C0C
075EA:  MOVFF  02,6A1
075EE:  MOVFF  01,6A0
075F2:  MOVLW  06
075F4:  MOVLB  6
075F6:  ADDWF  xA0,F
075F8:  MOVLW  00
075FA:  ADDWFC xA1,F
075FC:  MOVLW  32
075FE:  ADDWF  xA0,W
07600:  MOVWF  01
07602:  MOVLW  00
07604:  ADDWFC xA1,W
07606:  MOVWF  03
07608:  MOVF   01,W
0760A:  ADDLW  08
0760C:  MOVWF  01
0760E:  MOVLW  02
07610:  ADDWFC 03,F
07612:  MOVFF  01,6A0
07616:  MOVFF  03,6A1
0761A:  MOVFF  03,6C4
0761E:  MOVFF  01,6C3
07622:  MOVLB  0
07624:  CALL   5C00
07628:  MOVF   01,F
0762A:  BNZ   7634
0762C:  MOVLW  02
0762E:  MOVWF  01
07630:  BRA    7792
07632:  BRA    7692
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07634:  MOVLB  6
07636:  CLRF   xF2
07638:  MOVFF  68F,6F1
0763C:  CLRF   xF4
0763E:  MOVLW  B5
07640:  MOVWF  xF3
07642:  MOVLB  0
07644:  CALL   0C0C
07648:  MOVFF  02,6A1
0764C:  MOVFF  01,6A0
07650:  MOVLW  06
07652:  MOVLB  6
07654:  ADDWF  xA0,F
07656:  MOVLW  00
07658:  ADDWFC xA1,F
0765A:  MOVLW  32
0765C:  ADDWF  xA0,W
0765E:  MOVWF  01
07660:  MOVLW  00
07662:  ADDWFC xA1,W
07664:  MOVWF  03
07666:  MOVF   01,W
07668:  ADDLW  08
0766A:  MOVWF  01
0766C:  MOVLW  02
0766E:  ADDWFC 03,F
07670:  MOVFF  01,6A0
07674:  MOVFF  03,6A1
07678:  MOVFF  03,6C4
0767C:  MOVFF  01,6C3
07680:  CLRF   xC6
07682:  CLRF   xC5
07684:  MOVLW  0A
07686:  MOVWF  xC7
07688:  MOVLB  0
0768A:  CALL   5C9A
0768E:  MOVFF  01,69B
....................    
....................    if (!arg_is_float(SERcmd[rec].p[3])) return INV_PARAM;
07692:  MOVLB  6
07694:  CLRF   xF2
07696:  MOVFF  68F,6F1
0769A:  CLRF   xF4
0769C:  MOVLW  B5
0769E:  MOVWF  xF3
076A0:  MOVLB  0
076A2:  CALL   0C0C
076A6:  MOVFF  02,6A1
076AA:  MOVFF  01,6A0
076AE:  MOVLW  06
076B0:  MOVLB  6
076B2:  ADDWF  xA0,F
076B4:  MOVLW  00
076B6:  ADDWFC xA1,F
076B8:  MOVLW  4B
076BA:  ADDWF  xA0,W
076BC:  MOVWF  01
076BE:  MOVLW  00
076C0:  ADDWFC xA1,W
076C2:  MOVWF  03
076C4:  MOVF   01,W
076C6:  ADDLW  08
076C8:  MOVWF  01
076CA:  MOVLW  02
076CC:  ADDWFC 03,F
076CE:  MOVFF  01,6A0
076D2:  MOVFF  03,6A1
076D6:  MOVFF  03,6A5
076DA:  MOVFF  01,6A4
076DE:  MOVLB  0
076E0:  CALL   6E78
076E4:  MOVF   01,F
076E6:  BNZ   76F0
076E8:  MOVLW  02
076EA:  MOVWF  01
076EC:  BRA    7792
076EE:  BRA    7756
....................    else arg2 = strtod(SERcmd[rec].p[3], '\0');
076F0:  MOVLB  6
076F2:  CLRF   xF2
076F4:  MOVFF  68F,6F1
076F8:  CLRF   xF4
076FA:  MOVLW  B5
076FC:  MOVWF  xF3
076FE:  MOVLB  0
07700:  CALL   0C0C
07704:  MOVFF  02,6A1
07708:  MOVFF  01,6A0
0770C:  MOVLW  06
0770E:  MOVLB  6
07710:  ADDWF  xA0,F
07712:  MOVLW  00
07714:  ADDWFC xA1,F
07716:  MOVLW  4B
07718:  ADDWF  xA0,W
0771A:  MOVWF  01
0771C:  MOVLW  00
0771E:  ADDWFC xA1,W
07720:  MOVWF  03
07722:  MOVF   01,W
07724:  ADDLW  08
07726:  MOVWF  01
07728:  MOVLW  02
0772A:  ADDWFC 03,F
0772C:  MOVFF  01,6A0
07730:  MOVFF  03,6A1
07734:  MOVFF  03,6A5
07738:  MOVFF  01,6A4
0773C:  CLRF   xA7
0773E:  CLRF   xA6
07740:  MOVLB  0
07742:  CALL   6F3A
07746:  MOVFF  03,69F
0774A:  MOVFF  02,69E
0774E:  MOVFF  01,69D
07752:  MOVFF  00,69C
....................    
....................    /*** SET SETPOINT ******************/ 
....................    PID[arg1-1].SP = arg2;
07756:  MOVLW  01
07758:  MOVLB  6
0775A:  SUBWF  x9B,W
0775C:  MULLW  20
0775E:  MOVF   FF3,W
07760:  CLRF   xA1
07762:  MOVWF  xA0
07764:  MOVLW  0C
07766:  ADDWF  xA0,W
07768:  MOVWF  01
0776A:  MOVLW  00
0776C:  ADDWFC xA1,W
0776E:  MOVWF  03
07770:  MOVF   01,W
07772:  ADDLW  20
07774:  MOVWF  FE9
07776:  MOVLW  00
07778:  ADDWFC 03,W
0777A:  MOVWF  FEA
0777C:  MOVFF  69C,FEF
07780:  MOVFF  69D,FEC
07784:  MOVFF  69E,FEC
07788:  MOVFF  69F,FEC
....................    
....................    return SUCCESS;
0778C:  MOVLW  00
0778E:  MOVWF  01
07790:  MOVLB  0
07792:  RETURN 0
.................... }
.................... 
.................... int8 getAllSensorCalParams(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
07794:  MOVLB  6
07796:  CLRF   xF2
07798:  MOVFF  68F,6F1
0779C:  CLRF   xF4
0779E:  MOVLW  B5
077A0:  MOVWF  xF3
077A2:  MOVLB  0
077A4:  CALL   0C0C
077A8:  MOVFF  02,69D
077AC:  MOVFF  01,69C
077B0:  MOVLW  06
077B2:  MOVLB  6
077B4:  ADDWF  x9C,F
077B6:  MOVLW  00
077B8:  ADDWFC x9D,F
077BA:  MOVLW  32
077BC:  ADDWF  x9C,W
077BE:  MOVWF  01
077C0:  MOVLW  00
077C2:  ADDWFC x9D,W
077C4:  MOVWF  03
077C6:  MOVF   01,W
077C8:  ADDLW  08
077CA:  MOVWF  01
077CC:  MOVLW  02
077CE:  ADDWFC 03,F
077D0:  MOVFF  01,69C
077D4:  MOVFF  03,69D
077D8:  MOVFF  03,6C4
077DC:  MOVFF  01,6C3
077E0:  MOVLB  0
077E2:  CALL   5C00
077E6:  MOVF   01,F
077E8:  BNZ   77F2
077EA:  MOVLW  02
077EC:  MOVWF  01
077EE:  BRA    7B48
077F0:  BRA    7850
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
077F2:  MOVLB  6
077F4:  CLRF   xF2
077F6:  MOVFF  68F,6F1
077FA:  CLRF   xF4
077FC:  MOVLW  B5
077FE:  MOVWF  xF3
07800:  MOVLB  0
07802:  CALL   0C0C
07806:  MOVFF  02,69D
0780A:  MOVFF  01,69C
0780E:  MOVLW  06
07810:  MOVLB  6
07812:  ADDWF  x9C,F
07814:  MOVLW  00
07816:  ADDWFC x9D,F
07818:  MOVLW  32
0781A:  ADDWF  x9C,W
0781C:  MOVWF  01
0781E:  MOVLW  00
07820:  ADDWFC x9D,W
07822:  MOVWF  03
07824:  MOVF   01,W
07826:  ADDLW  08
07828:  MOVWF  01
0782A:  MOVLW  02
0782C:  ADDWFC 03,F
0782E:  MOVFF  01,69C
07832:  MOVFF  03,69D
07836:  MOVFF  03,6C4
0783A:  MOVFF  01,6C3
0783E:  CLRF   xC6
07840:  CLRF   xC5
07842:  MOVLW  0A
07844:  MOVWF  xC7
07846:  MOVLB  0
07848:  CALL   5C9A
0784C:  MOVFF  01,69B
....................    
....................    /*** GET ALL SENSOR CAL PARAMS *****/
....................    sprintf(retData+strlen(retData), "%d,", arg1);
07850:  MOVLW  04
07852:  MOVLB  6
07854:  MOVWF  xD2
07856:  MOVLW  DE
07858:  MOVWF  xD1
0785A:  MOVLB  0
0785C:  CALL   5A88
07860:  MOVFF  02,03
07864:  MOVF   01,W
07866:  ADDLW  DE
07868:  MOVLB  6
0786A:  MOVWF  x9C
0786C:  MOVLW  04
0786E:  ADDWFC 02,W
07870:  MOVWF  x9D
07872:  MOVFF  FE8,583
07876:  MOVFF  69C,582
0787A:  MOVFF  69B,6C4
0787E:  MOVLW  18
07880:  MOVWF  xC5
07882:  MOVLB  0
07884:  CALL   5FF0
07888:  MOVLW  2C
0788A:  MOVLB  6
0788C:  MOVWF  xE0
0788E:  MOVLB  0
07890:  CALL   5B38
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c0);
07894:  MOVLW  04
07896:  MOVLB  6
07898:  MOVWF  xD2
0789A:  MOVLW  DE
0789C:  MOVWF  xD1
0789E:  MOVLB  0
078A0:  CALL   5A88
078A4:  MOVFF  02,03
078A8:  MOVF   01,W
078AA:  ADDLW  DE
078AC:  MOVLB  6
078AE:  MOVWF  x9C
078B0:  MOVLW  04
078B2:  ADDWFC 02,W
078B4:  MOVWF  x9D
078B6:  MOVLW  01
078B8:  SUBWF  x9B,W
078BA:  MULLW  18
078BC:  MOVF   FF3,W
078BE:  CLRF   x9F
078C0:  MOVWF  x9E
078C2:  MOVLW  82
078C4:  ADDWF  x9E,W
078C6:  MOVWF  FE9
078C8:  MOVLW  00
078CA:  ADDWFC x9F,W
078CC:  MOVWF  FEA
078CE:  MOVFF  FEF,6D3
078D2:  MOVFF  FEC,6D4
078D6:  MOVFF  FEC,6D5
078DA:  MOVFF  FEC,6D6
078DE:  MOVFF  69D,583
078E2:  MOVFF  69C,582
078E6:  MOVLW  89
078E8:  MOVWF  FE9
078EA:  MOVLW  02
078EC:  MOVWF  xD7
078EE:  MOVLB  0
078F0:  CALL   680C
078F4:  MOVLW  2C
078F6:  MOVLB  6
078F8:  MOVWF  xE0
078FA:  MOVLB  0
078FC:  CALL   5B38
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c1);
07900:  MOVLW  04
07902:  MOVLB  6
07904:  MOVWF  xD2
07906:  MOVLW  DE
07908:  MOVWF  xD1
0790A:  MOVLB  0
0790C:  CALL   5A88
07910:  MOVF   01,W
07912:  ADDLW  DE
07914:  MOVLB  6
07916:  MOVWF  x9C
07918:  MOVLW  04
0791A:  ADDWFC 02,W
0791C:  MOVWF  x9D
0791E:  MOVLW  01
07920:  SUBWF  x9B,W
07922:  MULLW  18
07924:  MOVF   FF3,W
07926:  CLRF   x9F
07928:  MOVWF  x9E
0792A:  MOVLW  04
0792C:  ADDWF  x9E,W
0792E:  MOVWF  01
07930:  MOVLW  00
07932:  ADDWFC x9F,W
07934:  MOVWF  03
07936:  MOVF   01,W
07938:  ADDLW  82
0793A:  MOVWF  FE9
0793C:  MOVLW  00
0793E:  ADDWFC 03,W
07940:  MOVWF  FEA
07942:  MOVFF  FEF,6D3
07946:  MOVFF  FEC,6D4
0794A:  MOVFF  FEC,6D5
0794E:  MOVFF  FEC,6D6
07952:  MOVFF  69D,583
07956:  MOVFF  69C,582
0795A:  MOVLW  89
0795C:  MOVWF  FE9
0795E:  MOVLW  02
07960:  MOVWF  xD7
07962:  MOVLB  0
07964:  CALL   680C
07968:  MOVLW  2C
0796A:  MOVLB  6
0796C:  MOVWF  xE0
0796E:  MOVLB  0
07970:  CALL   5B38
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c2);
07974:  MOVLW  04
07976:  MOVLB  6
07978:  MOVWF  xD2
0797A:  MOVLW  DE
0797C:  MOVWF  xD1
0797E:  MOVLB  0
07980:  CALL   5A88
07984:  MOVF   01,W
07986:  ADDLW  DE
07988:  MOVLB  6
0798A:  MOVWF  x9C
0798C:  MOVLW  04
0798E:  ADDWFC 02,W
07990:  MOVWF  x9D
07992:  MOVLW  01
07994:  SUBWF  x9B,W
07996:  MULLW  18
07998:  MOVF   FF3,W
0799A:  CLRF   x9F
0799C:  MOVWF  x9E
0799E:  MOVLW  08
079A0:  ADDWF  x9E,W
079A2:  MOVWF  01
079A4:  MOVLW  00
079A6:  ADDWFC x9F,W
079A8:  MOVWF  03
079AA:  MOVF   01,W
079AC:  ADDLW  82
079AE:  MOVWF  FE9
079B0:  MOVLW  00
079B2:  ADDWFC 03,W
079B4:  MOVWF  FEA
079B6:  MOVFF  FEF,6D3
079BA:  MOVFF  FEC,6D4
079BE:  MOVFF  FEC,6D5
079C2:  MOVFF  FEC,6D6
079C6:  MOVFF  69D,583
079CA:  MOVFF  69C,582
079CE:  MOVLW  89
079D0:  MOVWF  FE9
079D2:  MOVLW  02
079D4:  MOVWF  xD7
079D6:  MOVLB  0
079D8:  CALL   680C
079DC:  MOVLW  2C
079DE:  MOVLB  6
079E0:  MOVWF  xE0
079E2:  MOVLB  0
079E4:  CALL   5B38
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c3);
079E8:  MOVLW  04
079EA:  MOVLB  6
079EC:  MOVWF  xD2
079EE:  MOVLW  DE
079F0:  MOVWF  xD1
079F2:  MOVLB  0
079F4:  CALL   5A88
079F8:  MOVF   01,W
079FA:  ADDLW  DE
079FC:  MOVLB  6
079FE:  MOVWF  x9C
07A00:  MOVLW  04
07A02:  ADDWFC 02,W
07A04:  MOVWF  x9D
07A06:  MOVLW  01
07A08:  SUBWF  x9B,W
07A0A:  MULLW  18
07A0C:  MOVF   FF3,W
07A0E:  CLRF   x9F
07A10:  MOVWF  x9E
07A12:  MOVLW  0C
07A14:  ADDWF  x9E,W
07A16:  MOVWF  01
07A18:  MOVLW  00
07A1A:  ADDWFC x9F,W
07A1C:  MOVWF  03
07A1E:  MOVF   01,W
07A20:  ADDLW  82
07A22:  MOVWF  FE9
07A24:  MOVLW  00
07A26:  ADDWFC 03,W
07A28:  MOVWF  FEA
07A2A:  MOVFF  FEF,6D3
07A2E:  MOVFF  FEC,6D4
07A32:  MOVFF  FEC,6D5
07A36:  MOVFF  FEC,6D6
07A3A:  MOVFF  69D,583
07A3E:  MOVFF  69C,582
07A42:  MOVLW  89
07A44:  MOVWF  FE9
07A46:  MOVLW  02
07A48:  MOVWF  xD7
07A4A:  MOVLB  0
07A4C:  CALL   680C
07A50:  MOVLW  2C
07A52:  MOVLB  6
07A54:  MOVWF  xE0
07A56:  MOVLB  0
07A58:  CALL   5B38
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c4);
07A5C:  MOVLW  04
07A5E:  MOVLB  6
07A60:  MOVWF  xD2
07A62:  MOVLW  DE
07A64:  MOVWF  xD1
07A66:  MOVLB  0
07A68:  CALL   5A88
07A6C:  MOVF   01,W
07A6E:  ADDLW  DE
07A70:  MOVLB  6
07A72:  MOVWF  x9C
07A74:  MOVLW  04
07A76:  ADDWFC 02,W
07A78:  MOVWF  x9D
07A7A:  MOVLW  01
07A7C:  SUBWF  x9B,W
07A7E:  MULLW  18
07A80:  MOVF   FF3,W
07A82:  CLRF   x9F
07A84:  MOVWF  x9E
07A86:  MOVLW  10
07A88:  ADDWF  x9E,W
07A8A:  MOVWF  01
07A8C:  MOVLW  00
07A8E:  ADDWFC x9F,W
07A90:  MOVWF  03
07A92:  MOVF   01,W
07A94:  ADDLW  82
07A96:  MOVWF  FE9
07A98:  MOVLW  00
07A9A:  ADDWFC 03,W
07A9C:  MOVWF  FEA
07A9E:  MOVFF  FEF,6D3
07AA2:  MOVFF  FEC,6D4
07AA6:  MOVFF  FEC,6D5
07AAA:  MOVFF  FEC,6D6
07AAE:  MOVFF  69D,583
07AB2:  MOVFF  69C,582
07AB6:  MOVLW  89
07AB8:  MOVWF  FE9
07ABA:  MOVLW  02
07ABC:  MOVWF  xD7
07ABE:  MOVLB  0
07AC0:  CALL   680C
07AC4:  MOVLW  2C
07AC6:  MOVLB  6
07AC8:  MOVWF  xE0
07ACA:  MOVLB  0
07ACC:  CALL   5B38
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c5);
07AD0:  MOVLW  04
07AD2:  MOVLB  6
07AD4:  MOVWF  xD2
07AD6:  MOVLW  DE
07AD8:  MOVWF  xD1
07ADA:  MOVLB  0
07ADC:  CALL   5A88
07AE0:  MOVF   01,W
07AE2:  ADDLW  DE
07AE4:  MOVLB  6
07AE6:  MOVWF  x9C
07AE8:  MOVLW  04
07AEA:  ADDWFC 02,W
07AEC:  MOVWF  x9D
07AEE:  MOVLW  01
07AF0:  SUBWF  x9B,W
07AF2:  MULLW  18
07AF4:  MOVF   FF3,W
07AF6:  CLRF   x9F
07AF8:  MOVWF  x9E
07AFA:  MOVLW  14
07AFC:  ADDWF  x9E,W
07AFE:  MOVWF  01
07B00:  MOVLW  00
07B02:  ADDWFC x9F,W
07B04:  MOVWF  03
07B06:  MOVF   01,W
07B08:  ADDLW  82
07B0A:  MOVWF  FE9
07B0C:  MOVLW  00
07B0E:  ADDWFC 03,W
07B10:  MOVWF  FEA
07B12:  MOVFF  FEF,6D3
07B16:  MOVFF  FEC,6D4
07B1A:  MOVFF  FEC,6D5
07B1E:  MOVFF  FEC,6D6
07B22:  MOVFF  69D,583
07B26:  MOVFF  69C,582
07B2A:  MOVLW  89
07B2C:  MOVWF  FE9
07B2E:  MOVLW  02
07B30:  MOVWF  xD7
07B32:  MOVLB  0
07B34:  CALL   680C
07B38:  MOVLW  2C
07B3A:  MOVLB  6
07B3C:  MOVWF  xE0
07B3E:  MOVLB  0
07B40:  CALL   5B38
....................    
....................    return SUCCESS;
07B44:  MOVLW  00
07B46:  MOVWF  01
07B48:  RETURN 0
.................... }
.................... 
.................... int8 getSensorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
07B4A:  MOVLB  6
07B4C:  CLRF   xF2
07B4E:  MOVFF  68F,6F1
07B52:  CLRF   xF4
07B54:  MOVLW  B5
07B56:  MOVWF  xF3
07B58:  MOVLB  0
07B5A:  CALL   0C0C
07B5E:  MOVFF  02,69E
07B62:  MOVFF  01,69D
07B66:  MOVLW  06
07B68:  MOVLB  6
07B6A:  ADDWF  x9D,F
07B6C:  MOVLW  00
07B6E:  ADDWFC x9E,F
07B70:  MOVLW  32
07B72:  ADDWF  x9D,W
07B74:  MOVWF  01
07B76:  MOVLW  00
07B78:  ADDWFC x9E,W
07B7A:  MOVWF  03
07B7C:  MOVF   01,W
07B7E:  ADDLW  08
07B80:  MOVWF  01
07B82:  MOVLW  02
07B84:  ADDWFC 03,F
07B86:  MOVFF  01,69D
07B8A:  MOVFF  03,69E
07B8E:  MOVFF  03,6C4
07B92:  MOVFF  01,6C3
07B96:  MOVLB  0
07B98:  CALL   5C00
07B9C:  MOVF   01,F
07B9E:  BNZ   7BA8
07BA0:  MOVLW  02
07BA2:  MOVWF  01
07BA4:  BRA    80A4
07BA6:  BRA    7C06
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07BA8:  MOVLB  6
07BAA:  CLRF   xF2
07BAC:  MOVFF  68F,6F1
07BB0:  CLRF   xF4
07BB2:  MOVLW  B5
07BB4:  MOVWF  xF3
07BB6:  MOVLB  0
07BB8:  CALL   0C0C
07BBC:  MOVFF  02,69E
07BC0:  MOVFF  01,69D
07BC4:  MOVLW  06
07BC6:  MOVLB  6
07BC8:  ADDWF  x9D,F
07BCA:  MOVLW  00
07BCC:  ADDWFC x9E,F
07BCE:  MOVLW  32
07BD0:  ADDWF  x9D,W
07BD2:  MOVWF  01
07BD4:  MOVLW  00
07BD6:  ADDWFC x9E,W
07BD8:  MOVWF  03
07BDA:  MOVF   01,W
07BDC:  ADDLW  08
07BDE:  MOVWF  01
07BE0:  MOVLW  02
07BE2:  ADDWFC 03,F
07BE4:  MOVFF  01,69D
07BE8:  MOVFF  03,69E
07BEC:  MOVFF  03,6C4
07BF0:  MOVFF  01,6C3
07BF4:  CLRF   xC6
07BF6:  CLRF   xC5
07BF8:  MOVLW  0A
07BFA:  MOVWF  xC7
07BFC:  MOVLB  0
07BFE:  CALL   5C9A
07C02:  MOVFF  01,69B
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
07C06:  MOVLB  6
07C08:  CLRF   xF2
07C0A:  MOVFF  68F,6F1
07C0E:  CLRF   xF4
07C10:  MOVLW  B5
07C12:  MOVWF  xF3
07C14:  MOVLB  0
07C16:  CALL   0C0C
07C1A:  MOVFF  02,69E
07C1E:  MOVFF  01,69D
07C22:  MOVLW  06
07C24:  MOVLB  6
07C26:  ADDWF  x9D,F
07C28:  MOVLW  00
07C2A:  ADDWFC x9E,F
07C2C:  MOVLW  4B
07C2E:  ADDWF  x9D,W
07C30:  MOVWF  01
07C32:  MOVLW  00
07C34:  ADDWFC x9E,W
07C36:  MOVWF  03
07C38:  MOVF   01,W
07C3A:  ADDLW  08
07C3C:  MOVWF  01
07C3E:  MOVLW  02
07C40:  ADDWFC 03,F
07C42:  MOVFF  01,69D
07C46:  MOVFF  03,69E
07C4A:  MOVFF  03,6D2
07C4E:  MOVFF  01,6D1
07C52:  MOVLB  0
07C54:  CALL   5A88
07C58:  MOVFF  02,03
07C5C:  MOVF   01,W
07C5E:  SUBLW  01
07C60:  BNZ   7C66
07C62:  MOVF   03,F
07C64:  BZ    7C6E
07C66:  MOVLW  02
07C68:  MOVWF  01
07C6A:  BRA    80A4
07C6C:  BRA    7CAE
....................    else arg2 = SERcmd[rec].p[3][0];
07C6E:  MOVLB  6
07C70:  CLRF   xF2
07C72:  MOVFF  68F,6F1
07C76:  CLRF   xF4
07C78:  MOVLW  B5
07C7A:  MOVWF  xF3
07C7C:  MOVLB  0
07C7E:  CALL   0C0C
07C82:  MOVFF  02,69E
07C86:  MOVFF  01,69D
07C8A:  MOVLW  06
07C8C:  MOVLB  6
07C8E:  ADDWF  x9D,F
07C90:  MOVLW  00
07C92:  ADDWFC x9E,F
07C94:  MOVLW  4B
07C96:  ADDWF  x9D,F
07C98:  MOVLW  00
07C9A:  ADDWFC x9E,F
07C9C:  MOVLW  08
07C9E:  ADDWF  x9D,W
07CA0:  MOVWF  FE9
07CA2:  MOVLW  02
07CA4:  ADDWFC x9E,W
07CA6:  MOVWF  FEA
07CA8:  MOVFF  FEF,69C
07CAC:  MOVLB  0
....................    
....................    /*** GET SENSOR CAL PARAM **********/
....................    if      ('0' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c0);
07CAE:  MOVLB  6
07CB0:  MOVF   x9C,W
07CB2:  SUBLW  30
07CB4:  BNZ   7D50
07CB6:  MOVLW  04
07CB8:  MOVWF  xD2
07CBA:  MOVLW  DE
07CBC:  MOVWF  xD1
07CBE:  MOVLB  0
07CC0:  CALL   5A88
07CC4:  MOVFF  02,03
07CC8:  MOVF   01,W
07CCA:  ADDLW  DE
07CCC:  MOVLB  6
07CCE:  MOVWF  x9D
07CD0:  MOVLW  04
07CD2:  ADDWFC 02,W
07CD4:  MOVWF  x9E
07CD6:  MOVLW  01
07CD8:  SUBWF  x9B,W
07CDA:  MULLW  18
07CDC:  MOVF   FF3,W
07CDE:  CLRF   xA0
07CE0:  MOVWF  x9F
07CE2:  MOVLW  82
07CE4:  ADDWF  x9F,W
07CE6:  MOVWF  FE9
07CE8:  MOVLW  00
07CEA:  ADDWFC xA0,W
07CEC:  MOVWF  FEA
07CEE:  MOVFF  FEF,6A1
07CF2:  MOVFF  FEC,6A2
07CF6:  MOVFF  FEC,6A3
07CFA:  MOVFF  FEC,6A4
07CFE:  MOVFF  69E,583
07D02:  MOVFF  69D,582
07D06:  MOVFF  69B,6C4
07D0A:  MOVLW  18
07D0C:  MOVWF  xC5
07D0E:  MOVLB  0
07D10:  CALL   5FF0
07D14:  MOVLW  2C
07D16:  MOVLB  6
07D18:  MOVWF  xE0
07D1A:  MOVLB  0
07D1C:  CALL   5B38
07D20:  MOVLW  89
07D22:  MOVWF  FE9
07D24:  MOVFF  6A4,6D6
07D28:  MOVFF  6A3,6D5
07D2C:  MOVFF  6A2,6D4
07D30:  MOVFF  6A1,6D3
07D34:  MOVLW  02
07D36:  MOVLB  6
07D38:  MOVWF  xD7
07D3A:  MOVLB  0
07D3C:  CALL   680C
07D40:  MOVLW  2C
07D42:  MOVLB  6
07D44:  MOVWF  xE0
07D46:  MOVLB  0
07D48:  CALL   5B38
07D4C:  BRA    80A0
07D4E:  MOVLB  6
....................    else if ('1' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c1);
07D50:  MOVF   x9C,W
07D52:  SUBLW  31
07D54:  BNZ   7DF8
07D56:  MOVLW  04
07D58:  MOVWF  xD2
07D5A:  MOVLW  DE
07D5C:  MOVWF  xD1
07D5E:  MOVLB  0
07D60:  CALL   5A88
07D64:  MOVF   01,W
07D66:  ADDLW  DE
07D68:  MOVLB  6
07D6A:  MOVWF  x9D
07D6C:  MOVLW  04
07D6E:  ADDWFC 02,W
07D70:  MOVWF  x9E
07D72:  MOVLW  01
07D74:  SUBWF  x9B,W
07D76:  MULLW  18
07D78:  MOVF   FF3,W
07D7A:  CLRF   xA0
07D7C:  MOVWF  x9F
07D7E:  MOVLW  04
07D80:  ADDWF  x9F,W
07D82:  MOVWF  01
07D84:  MOVLW  00
07D86:  ADDWFC xA0,W
07D88:  MOVWF  03
07D8A:  MOVF   01,W
07D8C:  ADDLW  82
07D8E:  MOVWF  FE9
07D90:  MOVLW  00
07D92:  ADDWFC 03,W
07D94:  MOVWF  FEA
07D96:  MOVFF  FEF,69F
07D9A:  MOVFF  FEC,6A0
07D9E:  MOVFF  FEC,6A1
07DA2:  MOVFF  FEC,6A2
07DA6:  MOVFF  69E,583
07DAA:  MOVFF  69D,582
07DAE:  MOVFF  69B,6C4
07DB2:  MOVLW  18
07DB4:  MOVWF  xC5
07DB6:  MOVLB  0
07DB8:  CALL   5FF0
07DBC:  MOVLW  2C
07DBE:  MOVLB  6
07DC0:  MOVWF  xE0
07DC2:  MOVLB  0
07DC4:  CALL   5B38
07DC8:  MOVLW  89
07DCA:  MOVWF  FE9
07DCC:  MOVFF  6A2,6D6
07DD0:  MOVFF  6A1,6D5
07DD4:  MOVFF  6A0,6D4
07DD8:  MOVFF  69F,6D3
07DDC:  MOVLW  02
07DDE:  MOVLB  6
07DE0:  MOVWF  xD7
07DE2:  MOVLB  0
07DE4:  CALL   680C
07DE8:  MOVLW  2C
07DEA:  MOVLB  6
07DEC:  MOVWF  xE0
07DEE:  MOVLB  0
07DF0:  CALL   5B38
07DF4:  BRA    80A0
07DF6:  MOVLB  6
....................    else if ('2' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c2);
07DF8:  MOVF   x9C,W
07DFA:  SUBLW  32
07DFC:  BNZ   7EA0
07DFE:  MOVLW  04
07E00:  MOVWF  xD2
07E02:  MOVLW  DE
07E04:  MOVWF  xD1
07E06:  MOVLB  0
07E08:  CALL   5A88
07E0C:  MOVF   01,W
07E0E:  ADDLW  DE
07E10:  MOVLB  6
07E12:  MOVWF  x9D
07E14:  MOVLW  04
07E16:  ADDWFC 02,W
07E18:  MOVWF  x9E
07E1A:  MOVLW  01
07E1C:  SUBWF  x9B,W
07E1E:  MULLW  18
07E20:  MOVF   FF3,W
07E22:  CLRF   xA0
07E24:  MOVWF  x9F
07E26:  MOVLW  08
07E28:  ADDWF  x9F,W
07E2A:  MOVWF  01
07E2C:  MOVLW  00
07E2E:  ADDWFC xA0,W
07E30:  MOVWF  03
07E32:  MOVF   01,W
07E34:  ADDLW  82
07E36:  MOVWF  FE9
07E38:  MOVLW  00
07E3A:  ADDWFC 03,W
07E3C:  MOVWF  FEA
07E3E:  MOVFF  FEF,69F
07E42:  MOVFF  FEC,6A0
07E46:  MOVFF  FEC,6A1
07E4A:  MOVFF  FEC,6A2
07E4E:  MOVFF  69E,583
07E52:  MOVFF  69D,582
07E56:  MOVFF  69B,6C4
07E5A:  MOVLW  18
07E5C:  MOVWF  xC5
07E5E:  MOVLB  0
07E60:  CALL   5FF0
07E64:  MOVLW  2C
07E66:  MOVLB  6
07E68:  MOVWF  xE0
07E6A:  MOVLB  0
07E6C:  CALL   5B38
07E70:  MOVLW  89
07E72:  MOVWF  FE9
07E74:  MOVFF  6A2,6D6
07E78:  MOVFF  6A1,6D5
07E7C:  MOVFF  6A0,6D4
07E80:  MOVFF  69F,6D3
07E84:  MOVLW  02
07E86:  MOVLB  6
07E88:  MOVWF  xD7
07E8A:  MOVLB  0
07E8C:  CALL   680C
07E90:  MOVLW  2C
07E92:  MOVLB  6
07E94:  MOVWF  xE0
07E96:  MOVLB  0
07E98:  CALL   5B38
07E9C:  BRA    80A0
07E9E:  MOVLB  6
....................    else if ('3' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c3);
07EA0:  MOVF   x9C,W
07EA2:  SUBLW  33
07EA4:  BNZ   7F48
07EA6:  MOVLW  04
07EA8:  MOVWF  xD2
07EAA:  MOVLW  DE
07EAC:  MOVWF  xD1
07EAE:  MOVLB  0
07EB0:  CALL   5A88
07EB4:  MOVF   01,W
07EB6:  ADDLW  DE
07EB8:  MOVLB  6
07EBA:  MOVWF  x9D
07EBC:  MOVLW  04
07EBE:  ADDWFC 02,W
07EC0:  MOVWF  x9E
07EC2:  MOVLW  01
07EC4:  SUBWF  x9B,W
07EC6:  MULLW  18
07EC8:  MOVF   FF3,W
07ECA:  CLRF   xA0
07ECC:  MOVWF  x9F
07ECE:  MOVLW  0C
07ED0:  ADDWF  x9F,W
07ED2:  MOVWF  01
07ED4:  MOVLW  00
07ED6:  ADDWFC xA0,W
07ED8:  MOVWF  03
07EDA:  MOVF   01,W
07EDC:  ADDLW  82
07EDE:  MOVWF  FE9
07EE0:  MOVLW  00
07EE2:  ADDWFC 03,W
07EE4:  MOVWF  FEA
07EE6:  MOVFF  FEF,69F
07EEA:  MOVFF  FEC,6A0
07EEE:  MOVFF  FEC,6A1
07EF2:  MOVFF  FEC,6A2
07EF6:  MOVFF  69E,583
07EFA:  MOVFF  69D,582
07EFE:  MOVFF  69B,6C4
07F02:  MOVLW  18
07F04:  MOVWF  xC5
07F06:  MOVLB  0
07F08:  CALL   5FF0
07F0C:  MOVLW  2C
07F0E:  MOVLB  6
07F10:  MOVWF  xE0
07F12:  MOVLB  0
07F14:  CALL   5B38
07F18:  MOVLW  89
07F1A:  MOVWF  FE9
07F1C:  MOVFF  6A2,6D6
07F20:  MOVFF  6A1,6D5
07F24:  MOVFF  6A0,6D4
07F28:  MOVFF  69F,6D3
07F2C:  MOVLW  02
07F2E:  MOVLB  6
07F30:  MOVWF  xD7
07F32:  MOVLB  0
07F34:  CALL   680C
07F38:  MOVLW  2C
07F3A:  MOVLB  6
07F3C:  MOVWF  xE0
07F3E:  MOVLB  0
07F40:  CALL   5B38
07F44:  BRA    80A0
07F46:  MOVLB  6
....................    else if ('4' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c4);
07F48:  MOVF   x9C,W
07F4A:  SUBLW  34
07F4C:  BNZ   7FF0
07F4E:  MOVLW  04
07F50:  MOVWF  xD2
07F52:  MOVLW  DE
07F54:  MOVWF  xD1
07F56:  MOVLB  0
07F58:  CALL   5A88
07F5C:  MOVF   01,W
07F5E:  ADDLW  DE
07F60:  MOVLB  6
07F62:  MOVWF  x9D
07F64:  MOVLW  04
07F66:  ADDWFC 02,W
07F68:  MOVWF  x9E
07F6A:  MOVLW  01
07F6C:  SUBWF  x9B,W
07F6E:  MULLW  18
07F70:  MOVF   FF3,W
07F72:  CLRF   xA0
07F74:  MOVWF  x9F
07F76:  MOVLW  10
07F78:  ADDWF  x9F,W
07F7A:  MOVWF  01
07F7C:  MOVLW  00
07F7E:  ADDWFC xA0,W
07F80:  MOVWF  03
07F82:  MOVF   01,W
07F84:  ADDLW  82
07F86:  MOVWF  FE9
07F88:  MOVLW  00
07F8A:  ADDWFC 03,W
07F8C:  MOVWF  FEA
07F8E:  MOVFF  FEF,69F
07F92:  MOVFF  FEC,6A0
07F96:  MOVFF  FEC,6A1
07F9A:  MOVFF  FEC,6A2
07F9E:  MOVFF  69E,583
07FA2:  MOVFF  69D,582
07FA6:  MOVFF  69B,6C4
07FAA:  MOVLW  18
07FAC:  MOVWF  xC5
07FAE:  MOVLB  0
07FB0:  CALL   5FF0
07FB4:  MOVLW  2C
07FB6:  MOVLB  6
07FB8:  MOVWF  xE0
07FBA:  MOVLB  0
07FBC:  CALL   5B38
07FC0:  MOVLW  89
07FC2:  MOVWF  FE9
07FC4:  MOVFF  6A2,6D6
07FC8:  MOVFF  6A1,6D5
07FCC:  MOVFF  6A0,6D4
07FD0:  MOVFF  69F,6D3
07FD4:  MOVLW  02
07FD6:  MOVLB  6
07FD8:  MOVWF  xD7
07FDA:  MOVLB  0
07FDC:  CALL   680C
07FE0:  MOVLW  2C
07FE2:  MOVLB  6
07FE4:  MOVWF  xE0
07FE6:  MOVLB  0
07FE8:  CALL   5B38
07FEC:  BRA    80A0
07FEE:  MOVLB  6
....................    else if ('5' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c5);
07FF0:  MOVF   x9C,W
07FF2:  SUBLW  35
07FF4:  BNZ   8098
07FF6:  MOVLW  04
07FF8:  MOVWF  xD2
07FFA:  MOVLW  DE
07FFC:  MOVWF  xD1
07FFE:  MOVLB  0
08000:  CALL   5A88
08004:  MOVF   01,W
08006:  ADDLW  DE
08008:  MOVLB  6
0800A:  MOVWF  x9D
0800C:  MOVLW  04
0800E:  ADDWFC 02,W
08010:  MOVWF  x9E
08012:  MOVLW  01
08014:  SUBWF  x9B,W
08016:  MULLW  18
08018:  MOVF   FF3,W
0801A:  CLRF   xA0
0801C:  MOVWF  x9F
0801E:  MOVLW  14
08020:  ADDWF  x9F,W
08022:  MOVWF  01
08024:  MOVLW  00
08026:  ADDWFC xA0,W
08028:  MOVWF  03
0802A:  MOVF   01,W
0802C:  ADDLW  82
0802E:  MOVWF  FE9
08030:  MOVLW  00
08032:  ADDWFC 03,W
08034:  MOVWF  FEA
08036:  MOVFF  FEF,69F
0803A:  MOVFF  FEC,6A0
0803E:  MOVFF  FEC,6A1
08042:  MOVFF  FEC,6A2
08046:  MOVFF  69E,583
0804A:  MOVFF  69D,582
0804E:  MOVFF  69B,6C4
08052:  MOVLW  18
08054:  MOVWF  xC5
08056:  MOVLB  0
08058:  CALL   5FF0
0805C:  MOVLW  2C
0805E:  MOVLB  6
08060:  MOVWF  xE0
08062:  MOVLB  0
08064:  CALL   5B38
08068:  MOVLW  89
0806A:  MOVWF  FE9
0806C:  MOVFF  6A2,6D6
08070:  MOVFF  6A1,6D5
08074:  MOVFF  6A0,6D4
08078:  MOVFF  69F,6D3
0807C:  MOVLW  02
0807E:  MOVLB  6
08080:  MOVWF  xD7
08082:  MOVLB  0
08084:  CALL   680C
08088:  MOVLW  2C
0808A:  MOVLB  6
0808C:  MOVWF  xE0
0808E:  MOVLB  0
08090:  CALL   5B38
08094:  BRA    80A0
08096:  MOVLB  6
....................    else return INV_PARAM;
08098:  MOVLW  02
0809A:  MOVWF  01
0809C:  MOVLB  0
0809E:  BRA    80A4
....................    
....................    return SUCCESS;
080A0:  MOVLW  00
080A2:  MOVWF  01
080A4:  RETURN 0
.................... }
.................... 
.................... int8 setSensorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char  arg2;
....................    float arg3;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
080A6:  MOVLB  6
080A8:  CLRF   xF2
080AA:  MOVFF  68F,6F1
080AE:  CLRF   xF4
080B0:  MOVLW  B5
080B2:  MOVWF  xF3
080B4:  MOVLB  0
080B6:  CALL   0C0C
080BA:  MOVFF  02,6A2
080BE:  MOVFF  01,6A1
080C2:  MOVLW  06
080C4:  MOVLB  6
080C6:  ADDWF  xA1,F
080C8:  MOVLW  00
080CA:  ADDWFC xA2,F
080CC:  MOVLW  32
080CE:  ADDWF  xA1,W
080D0:  MOVWF  01
080D2:  MOVLW  00
080D4:  ADDWFC xA2,W
080D6:  MOVWF  03
080D8:  MOVF   01,W
080DA:  ADDLW  08
080DC:  MOVWF  01
080DE:  MOVLW  02
080E0:  ADDWFC 03,F
080E2:  MOVFF  01,6A1
080E6:  MOVFF  03,6A2
080EA:  MOVFF  03,6C4
080EE:  MOVFF  01,6C3
080F2:  MOVLB  0
080F4:  CALL   5C00
080F8:  MOVF   01,F
080FA:  BNZ   8104
080FC:  MOVLW  02
080FE:  MOVWF  01
08100:  BRA    843C
08102:  BRA    8162
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
08104:  MOVLB  6
08106:  CLRF   xF2
08108:  MOVFF  68F,6F1
0810C:  CLRF   xF4
0810E:  MOVLW  B5
08110:  MOVWF  xF3
08112:  MOVLB  0
08114:  CALL   0C0C
08118:  MOVFF  02,6A2
0811C:  MOVFF  01,6A1
08120:  MOVLW  06
08122:  MOVLB  6
08124:  ADDWF  xA1,F
08126:  MOVLW  00
08128:  ADDWFC xA2,F
0812A:  MOVLW  32
0812C:  ADDWF  xA1,W
0812E:  MOVWF  01
08130:  MOVLW  00
08132:  ADDWFC xA2,W
08134:  MOVWF  03
08136:  MOVF   01,W
08138:  ADDLW  08
0813A:  MOVWF  01
0813C:  MOVLW  02
0813E:  ADDWFC 03,F
08140:  MOVFF  01,6A1
08144:  MOVFF  03,6A2
08148:  MOVFF  03,6C4
0814C:  MOVFF  01,6C3
08150:  CLRF   xC6
08152:  CLRF   xC5
08154:  MOVLW  0A
08156:  MOVWF  xC7
08158:  MOVLB  0
0815A:  CALL   5C9A
0815E:  MOVFF  01,69B
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
08162:  MOVLB  6
08164:  CLRF   xF2
08166:  MOVFF  68F,6F1
0816A:  CLRF   xF4
0816C:  MOVLW  B5
0816E:  MOVWF  xF3
08170:  MOVLB  0
08172:  CALL   0C0C
08176:  MOVFF  02,6A2
0817A:  MOVFF  01,6A1
0817E:  MOVLW  06
08180:  MOVLB  6
08182:  ADDWF  xA1,F
08184:  MOVLW  00
08186:  ADDWFC xA2,F
08188:  MOVLW  4B
0818A:  ADDWF  xA1,W
0818C:  MOVWF  01
0818E:  MOVLW  00
08190:  ADDWFC xA2,W
08192:  MOVWF  03
08194:  MOVF   01,W
08196:  ADDLW  08
08198:  MOVWF  01
0819A:  MOVLW  02
0819C:  ADDWFC 03,F
0819E:  MOVFF  01,6A1
081A2:  MOVFF  03,6A2
081A6:  MOVFF  03,6D2
081AA:  MOVFF  01,6D1
081AE:  MOVLB  0
081B0:  CALL   5A88
081B4:  MOVFF  02,03
081B8:  MOVF   01,W
081BA:  SUBLW  01
081BC:  BNZ   81C2
081BE:  MOVF   03,F
081C0:  BZ    81CA
081C2:  MOVLW  02
081C4:  MOVWF  01
081C6:  BRA    843C
081C8:  BRA    820A
....................    else arg2 = SERcmd[rec].p[3][0];
081CA:  MOVLB  6
081CC:  CLRF   xF2
081CE:  MOVFF  68F,6F1
081D2:  CLRF   xF4
081D4:  MOVLW  B5
081D6:  MOVWF  xF3
081D8:  MOVLB  0
081DA:  CALL   0C0C
081DE:  MOVFF  02,6A2
081E2:  MOVFF  01,6A1
081E6:  MOVLW  06
081E8:  MOVLB  6
081EA:  ADDWF  xA1,F
081EC:  MOVLW  00
081EE:  ADDWFC xA2,F
081F0:  MOVLW  4B
081F2:  ADDWF  xA1,F
081F4:  MOVLW  00
081F6:  ADDWFC xA2,F
081F8:  MOVLW  08
081FA:  ADDWF  xA1,W
081FC:  MOVWF  FE9
081FE:  MOVLW  02
08200:  ADDWFC xA2,W
08202:  MOVWF  FEA
08204:  MOVFF  FEF,69C
08208:  MOVLB  0
....................    
....................    if (!arg_is_float(SERcmd[rec].p[4])) return INV_PARAM;
0820A:  MOVLB  6
0820C:  CLRF   xF2
0820E:  MOVFF  68F,6F1
08212:  CLRF   xF4
08214:  MOVLW  B5
08216:  MOVWF  xF3
08218:  MOVLB  0
0821A:  CALL   0C0C
0821E:  MOVFF  02,6A2
08222:  MOVFF  01,6A1
08226:  MOVLW  06
08228:  MOVLB  6
0822A:  ADDWF  xA1,F
0822C:  MOVLW  00
0822E:  ADDWFC xA2,F
08230:  MOVLW  64
08232:  ADDWF  xA1,W
08234:  MOVWF  01
08236:  MOVLW  00
08238:  ADDWFC xA2,W
0823A:  MOVWF  03
0823C:  MOVF   01,W
0823E:  ADDLW  08
08240:  MOVWF  01
08242:  MOVLW  02
08244:  ADDWFC 03,F
08246:  MOVFF  01,6A1
0824A:  MOVFF  03,6A2
0824E:  MOVFF  03,6A5
08252:  MOVFF  01,6A4
08256:  MOVLB  0
08258:  CALL   6E78
0825C:  MOVF   01,F
0825E:  BNZ   8268
08260:  MOVLW  02
08262:  MOVWF  01
08264:  BRA    843C
08266:  BRA    82CE
....................    else arg3 = strtod(SERcmd[rec].p[4], '\0');
08268:  MOVLB  6
0826A:  CLRF   xF2
0826C:  MOVFF  68F,6F1
08270:  CLRF   xF4
08272:  MOVLW  B5
08274:  MOVWF  xF3
08276:  MOVLB  0
08278:  CALL   0C0C
0827C:  MOVFF  02,6A2
08280:  MOVFF  01,6A1
08284:  MOVLW  06
08286:  MOVLB  6
08288:  ADDWF  xA1,F
0828A:  MOVLW  00
0828C:  ADDWFC xA2,F
0828E:  MOVLW  64
08290:  ADDWF  xA1,W
08292:  MOVWF  01
08294:  MOVLW  00
08296:  ADDWFC xA2,W
08298:  MOVWF  03
0829A:  MOVF   01,W
0829C:  ADDLW  08
0829E:  MOVWF  01
082A0:  MOVLW  02
082A2:  ADDWFC 03,F
082A4:  MOVFF  01,6A1
082A8:  MOVFF  03,6A2
082AC:  MOVFF  03,6A5
082B0:  MOVFF  01,6A4
082B4:  CLRF   xA7
082B6:  CLRF   xA6
082B8:  MOVLB  0
082BA:  CALL   6F3A
082BE:  MOVFF  03,6A0
082C2:  MOVFF  02,69F
082C6:  MOVFF  01,69E
082CA:  MOVFF  00,69D
....................    
....................    /*** SET SENSOR CAL PARAM **********/
....................    if      ('0' == arg2) sensorCal[arg1-1].c0 = arg3;
082CE:  MOVLB  6
082D0:  MOVF   x9C,W
082D2:  SUBLW  30
082D4:  BNZ   8300
082D6:  MOVLW  01
082D8:  SUBWF  x9B,W
082DA:  MULLW  18
082DC:  MOVF   FF3,W
082DE:  CLRF   xA2
082E0:  MOVWF  xA1
082E2:  MOVLW  82
082E4:  ADDWF  xA1,W
082E6:  MOVWF  FE9
082E8:  MOVLW  00
082EA:  ADDWFC xA2,W
082EC:  MOVWF  FEA
082EE:  MOVFF  69D,FEF
082F2:  MOVFF  69E,FEC
082F6:  MOVFF  69F,FEC
082FA:  MOVFF  6A0,FEC
082FE:  BRA    8436
....................    else if ('1' == arg2) sensorCal[arg1-1].c1 = arg3;
08300:  MOVF   x9C,W
08302:  SUBLW  31
08304:  BNZ   833C
08306:  MOVLW  01
08308:  SUBWF  x9B,W
0830A:  MULLW  18
0830C:  MOVF   FF3,W
0830E:  CLRF   xA2
08310:  MOVWF  xA1
08312:  MOVLW  04
08314:  ADDWF  xA1,W
08316:  MOVWF  01
08318:  MOVLW  00
0831A:  ADDWFC xA2,W
0831C:  MOVWF  03
0831E:  MOVF   01,W
08320:  ADDLW  82
08322:  MOVWF  FE9
08324:  MOVLW  00
08326:  ADDWFC 03,W
08328:  MOVWF  FEA
0832A:  MOVFF  69D,FEF
0832E:  MOVFF  69E,FEC
08332:  MOVFF  69F,FEC
08336:  MOVFF  6A0,FEC
0833A:  BRA    8436
....................    else if ('2' == arg2) sensorCal[arg1-1].c2 = arg3;
0833C:  MOVF   x9C,W
0833E:  SUBLW  32
08340:  BNZ   8378
08342:  MOVLW  01
08344:  SUBWF  x9B,W
08346:  MULLW  18
08348:  MOVF   FF3,W
0834A:  CLRF   xA2
0834C:  MOVWF  xA1
0834E:  MOVLW  08
08350:  ADDWF  xA1,W
08352:  MOVWF  01
08354:  MOVLW  00
08356:  ADDWFC xA2,W
08358:  MOVWF  03
0835A:  MOVF   01,W
0835C:  ADDLW  82
0835E:  MOVWF  FE9
08360:  MOVLW  00
08362:  ADDWFC 03,W
08364:  MOVWF  FEA
08366:  MOVFF  69D,FEF
0836A:  MOVFF  69E,FEC
0836E:  MOVFF  69F,FEC
08372:  MOVFF  6A0,FEC
08376:  BRA    8436
....................    else if ('3' == arg2) sensorCal[arg1-1].c3 = arg3;
08378:  MOVF   x9C,W
0837A:  SUBLW  33
0837C:  BNZ   83B4
0837E:  MOVLW  01
08380:  SUBWF  x9B,W
08382:  MULLW  18
08384:  MOVF   FF3,W
08386:  CLRF   xA2
08388:  MOVWF  xA1
0838A:  MOVLW  0C
0838C:  ADDWF  xA1,W
0838E:  MOVWF  01
08390:  MOVLW  00
08392:  ADDWFC xA2,W
08394:  MOVWF  03
08396:  MOVF   01,W
08398:  ADDLW  82
0839A:  MOVWF  FE9
0839C:  MOVLW  00
0839E:  ADDWFC 03,W
083A0:  MOVWF  FEA
083A2:  MOVFF  69D,FEF
083A6:  MOVFF  69E,FEC
083AA:  MOVFF  69F,FEC
083AE:  MOVFF  6A0,FEC
083B2:  BRA    8436
....................    else if ('4' == arg2) sensorCal[arg1-1].c4 = arg3;
083B4:  MOVF   x9C,W
083B6:  SUBLW  34
083B8:  BNZ   83F0
083BA:  MOVLW  01
083BC:  SUBWF  x9B,W
083BE:  MULLW  18
083C0:  MOVF   FF3,W
083C2:  CLRF   xA2
083C4:  MOVWF  xA1
083C6:  MOVLW  10
083C8:  ADDWF  xA1,W
083CA:  MOVWF  01
083CC:  MOVLW  00
083CE:  ADDWFC xA2,W
083D0:  MOVWF  03
083D2:  MOVF   01,W
083D4:  ADDLW  82
083D6:  MOVWF  FE9
083D8:  MOVLW  00
083DA:  ADDWFC 03,W
083DC:  MOVWF  FEA
083DE:  MOVFF  69D,FEF
083E2:  MOVFF  69E,FEC
083E6:  MOVFF  69F,FEC
083EA:  MOVFF  6A0,FEC
083EE:  BRA    8436
....................    else if ('5' == arg2) sensorCal[arg1-1].c5 = arg3;
083F0:  MOVF   x9C,W
083F2:  SUBLW  35
083F4:  BNZ   842C
083F6:  MOVLW  01
083F8:  SUBWF  x9B,W
083FA:  MULLW  18
083FC:  MOVF   FF3,W
083FE:  CLRF   xA2
08400:  MOVWF  xA1
08402:  MOVLW  14
08404:  ADDWF  xA1,W
08406:  MOVWF  01
08408:  MOVLW  00
0840A:  ADDWFC xA2,W
0840C:  MOVWF  03
0840E:  MOVF   01,W
08410:  ADDLW  82
08412:  MOVWF  FE9
08414:  MOVLW  00
08416:  ADDWFC 03,W
08418:  MOVWF  FEA
0841A:  MOVFF  69D,FEF
0841E:  MOVFF  69E,FEC
08422:  MOVFF  69F,FEC
08426:  MOVFF  6A0,FEC
0842A:  BRA    8436
....................    else return INV_PARAM;
0842C:  MOVLW  02
0842E:  MOVWF  01
08430:  MOVLB  0
08432:  BRA    843C
08434:  MOVLB  6
....................    
....................    return SUCCESS;
08436:  MOVLW  00
08438:  MOVWF  01
0843A:  MOVLB  0
0843C:  RETURN 0
.................... }
.................... 
.................... int8 getMonitorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    char *arg1;
....................    char *s_N15 = "N15";
0843E:  MOVLW  4E
08440:  MOVLB  6
08442:  MOVWF  x9F
08444:  MOVLW  31
08446:  MOVWF  xA0
08448:  MOVLW  35
0844A:  MOVWF  xA1
0844C:  CLRF   xA2
0844E:  MOVLW  06
08450:  MOVWF  x9E
08452:  MOVLW  9F
08454:  MOVWF  x9D
....................    char *s_200 = "200";
08456:  MOVLW  32
08458:  MOVWF  xA5
0845A:  MOVLW  30
0845C:  MOVWF  xA6
0845E:  MOVWF  xA7
08460:  CLRF   xA8
08462:  MOVLW  06
08464:  MOVWF  xA4
08466:  MOVLW  A5
08468:  MOVWF  xA3
....................    char *s_5V6 = "5V6";
0846A:  MOVLW  35
0846C:  MOVWF  xAB
0846E:  MOVLW  56
08470:  MOVWF  xAC
08472:  MOVLW  36
08474:  MOVWF  xAD
08476:  CLRF   xAE
08478:  MOVLW  06
0847A:  MOVWF  xAA
0847C:  MOVLW  AB
0847E:  MOVWF  xA9
....................    char *s_5VA = "5VA";
08480:  MOVLW  35
08482:  MOVWF  xB1
08484:  MOVLW  56
08486:  MOVWF  xB2
08488:  MOVLW  41
0848A:  MOVWF  xB3
0848C:  CLRF   xB4
0848E:  MOVLW  06
08490:  MOVWF  xB0
08492:  MOVLW  B1
08494:  MOVWF  xAF
....................    char *s_3V6X = "3V6X";
08496:  MOVLW  33
08498:  MOVWF  xB7
0849A:  MOVLW  56
0849C:  MOVWF  xB8
0849E:  MOVLW  36
084A0:  MOVWF  xB9
084A2:  MOVLW  58
084A4:  MOVWF  xBA
084A6:  CLRF   xBB
084A8:  MOVLW  06
084AA:  MOVWF  xB6
084AC:  MOVLW  B7
084AE:  MOVWF  xB5
....................    char *s_3V3A = "3V3A";
084B0:  MOVLW  33
084B2:  MOVWF  xBE
084B4:  MOVLW  56
084B6:  MOVWF  xBF
084B8:  MOVLW  33
084BA:  MOVWF  xC0
084BC:  MOVLW  41
084BE:  MOVWF  xC1
084C0:  CLRF   xC2
084C2:  MOVLW  06
084C4:  MOVWF  xBD
084C6:  MOVLW  BE
084C8:  MOVWF  xBC
....................    char *s_3V3D = "3V3D";
084CA:  MOVLW  33
084CC:  MOVWF  xC5
084CE:  MOVLW  56
084D0:  MOVWF  xC6
084D2:  MOVLW  33
084D4:  MOVWF  xC7
084D6:  MOVLW  44
084D8:  MOVWF  xC8
084DA:  CLRF   xC9
084DC:  MOVLW  06
084DE:  MOVWF  xC4
084E0:  MOVLW  C5
084E2:  MOVWF  xC3
.................... //!   char *s_all = "all";
....................    
....................    arg1 = SERcmd[rec].p[2];
084E4:  CLRF   xF2
084E6:  MOVFF  68F,6F1
084EA:  CLRF   xF4
084EC:  MOVLW  B5
084EE:  MOVWF  xF3
084F0:  MOVLB  0
084F2:  CALL   0C0C
084F6:  MOVFF  02,6CB
084FA:  MOVFF  01,6CA
084FE:  MOVLW  06
08500:  MOVLB  6
08502:  ADDWF  xCA,F
08504:  MOVLW  00
08506:  ADDWFC xCB,F
08508:  MOVLW  32
0850A:  ADDWF  xCA,W
0850C:  MOVWF  01
0850E:  MOVLW  00
08510:  ADDWFC xCB,W
08512:  MOVWF  03
08514:  MOVF   01,W
08516:  ADDLW  08
08518:  MOVWF  01
0851A:  MOVLW  02
0851C:  ADDWFC 03,F
0851E:  MOVFF  01,69B
08522:  MOVFF  03,69C
....................    
....................    /*** GET MONITOR VALUES ************/
....................    if      (0 == strcmp(s_N15, arg1)) {
08526:  MOVFF  69E,6D2
0852A:  MOVFF  69D,6D1
0852E:  MOVFF  69C,6D4
08532:  MOVFF  69B,6D3
08536:  MOVLB  0
08538:  CALL   5AC0
0853C:  MOVF   01,F
0853E:  BNZ   85C2
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.vN15[0],monCal.vN15[1]);
08540:  MOVLW  04
08542:  MOVLB  6
08544:  MOVWF  xD2
08546:  MOVLW  DE
08548:  MOVWF  xD1
0854A:  MOVLB  0
0854C:  CALL   5A88
08550:  MOVFF  02,03
08554:  MOVF   01,W
08556:  ADDLW  DE
08558:  MOVLB  6
0855A:  MOVWF  xCA
0855C:  MOVLW  04
0855E:  ADDWFC 02,W
08560:  MOVWF  xCB
08562:  MOVFF  FE8,583
08566:  MOVFF  6CA,582
0856A:  MOVLW  89
0856C:  MOVWF  FE9
0856E:  MOVFF  B5,6D6
08572:  MOVFF  B4,6D5
08576:  MOVFF  B3,6D4
0857A:  MOVFF  B2,6D3
0857E:  MOVLW  02
08580:  MOVWF  xD7
08582:  MOVLB  0
08584:  CALL   680C
08588:  MOVLW  2C
0858A:  MOVLB  6
0858C:  MOVWF  xE0
0858E:  MOVLB  0
08590:  CALL   5B38
08594:  MOVLW  89
08596:  MOVWF  FE9
08598:  MOVFF  B9,6D6
0859C:  MOVFF  B8,6D5
085A0:  MOVFF  B7,6D4
085A4:  MOVFF  B6,6D3
085A8:  MOVLW  02
085AA:  MOVLB  6
085AC:  MOVWF  xD7
085AE:  MOVLB  0
085B0:  CALL   680C
085B4:  MOVLW  2C
085B6:  MOVLB  6
085B8:  MOVWF  xE0
085BA:  MOVLB  0
085BC:  CALL   5B38
....................    }
085C0:  BRA    8964
....................    else if (0 == strcmp(s_200, arg1)) {
085C2:  MOVFF  6A4,6D2
085C6:  MOVFF  6A3,6D1
085CA:  MOVFF  69C,6D4
085CE:  MOVFF  69B,6D3
085D2:  CALL   5AC0
085D6:  MOVF   01,F
085D8:  BNZ   865C
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v200[0],monCal.v200[1]);
085DA:  MOVLW  04
085DC:  MOVLB  6
085DE:  MOVWF  xD2
085E0:  MOVLW  DE
085E2:  MOVWF  xD1
085E4:  MOVLB  0
085E6:  CALL   5A88
085EA:  MOVFF  02,03
085EE:  MOVF   01,W
085F0:  ADDLW  DE
085F2:  MOVLB  6
085F4:  MOVWF  xCA
085F6:  MOVLW  04
085F8:  ADDWFC 02,W
085FA:  MOVWF  xCB
085FC:  MOVFF  FE8,583
08600:  MOVFF  6CA,582
08604:  MOVLW  89
08606:  MOVWF  FE9
08608:  MOVFF  BD,6D6
0860C:  MOVFF  BC,6D5
08610:  MOVFF  BB,6D4
08614:  MOVFF  BA,6D3
08618:  MOVLW  02
0861A:  MOVWF  xD7
0861C:  MOVLB  0
0861E:  CALL   680C
08622:  MOVLW  2C
08624:  MOVLB  6
08626:  MOVWF  xE0
08628:  MOVLB  0
0862A:  CALL   5B38
0862E:  MOVLW  89
08630:  MOVWF  FE9
08632:  MOVFF  C1,6D6
08636:  MOVFF  C0,6D5
0863A:  MOVFF  BF,6D4
0863E:  MOVFF  BE,6D3
08642:  MOVLW  02
08644:  MOVLB  6
08646:  MOVWF  xD7
08648:  MOVLB  0
0864A:  CALL   680C
0864E:  MOVLW  2C
08650:  MOVLB  6
08652:  MOVWF  xE0
08654:  MOVLB  0
08656:  CALL   5B38
....................    }
0865A:  BRA    8964
....................    else if (0 == strcmp(s_5V6, arg1)) {
0865C:  MOVFF  6AA,6D2
08660:  MOVFF  6A9,6D1
08664:  MOVFF  69C,6D4
08668:  MOVFF  69B,6D3
0866C:  CALL   5AC0
08670:  MOVF   01,F
08672:  BNZ   86F6
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v5V6[0],monCal.v5V6[1]);
08674:  MOVLW  04
08676:  MOVLB  6
08678:  MOVWF  xD2
0867A:  MOVLW  DE
0867C:  MOVWF  xD1
0867E:  MOVLB  0
08680:  CALL   5A88
08684:  MOVFF  02,03
08688:  MOVF   01,W
0868A:  ADDLW  DE
0868C:  MOVLB  6
0868E:  MOVWF  xCA
08690:  MOVLW  04
08692:  ADDWFC 02,W
08694:  MOVWF  xCB
08696:  MOVFF  FE8,583
0869A:  MOVFF  6CA,582
0869E:  MOVLW  89
086A0:  MOVWF  FE9
086A2:  MOVFF  C5,6D6
086A6:  MOVFF  C4,6D5
086AA:  MOVFF  C3,6D4
086AE:  MOVFF  C2,6D3
086B2:  MOVLW  02
086B4:  MOVWF  xD7
086B6:  MOVLB  0
086B8:  CALL   680C
086BC:  MOVLW  2C
086BE:  MOVLB  6
086C0:  MOVWF  xE0
086C2:  MOVLB  0
086C4:  CALL   5B38
086C8:  MOVLW  89
086CA:  MOVWF  FE9
086CC:  MOVFF  C9,6D6
086D0:  MOVFF  C8,6D5
086D4:  MOVFF  C7,6D4
086D8:  MOVFF  C6,6D3
086DC:  MOVLW  02
086DE:  MOVLB  6
086E0:  MOVWF  xD7
086E2:  MOVLB  0
086E4:  CALL   680C
086E8:  MOVLW  2C
086EA:  MOVLB  6
086EC:  MOVWF  xE0
086EE:  MOVLB  0
086F0:  CALL   5B38
....................    }
086F4:  BRA    8964
....................    else if (0 == strcmp(s_5VA, arg1)) {
086F6:  MOVFF  6B0,6D2
086FA:  MOVFF  6AF,6D1
086FE:  MOVFF  69C,6D4
08702:  MOVFF  69B,6D3
08706:  CALL   5AC0
0870A:  MOVF   01,F
0870C:  BNZ   8790
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v5VA[0],monCal.v5VA[1]);
0870E:  MOVLW  04
08710:  MOVLB  6
08712:  MOVWF  xD2
08714:  MOVLW  DE
08716:  MOVWF  xD1
08718:  MOVLB  0
0871A:  CALL   5A88
0871E:  MOVFF  02,03
08722:  MOVF   01,W
08724:  ADDLW  DE
08726:  MOVLB  6
08728:  MOVWF  xCA
0872A:  MOVLW  04
0872C:  ADDWFC 02,W
0872E:  MOVWF  xCB
08730:  MOVFF  FE8,583
08734:  MOVFF  6CA,582
08738:  MOVLW  89
0873A:  MOVWF  FE9
0873C:  MOVFF  CD,6D6
08740:  MOVFF  CC,6D5
08744:  MOVFF  CB,6D4
08748:  MOVFF  CA,6D3
0874C:  MOVLW  02
0874E:  MOVWF  xD7
08750:  MOVLB  0
08752:  CALL   680C
08756:  MOVLW  2C
08758:  MOVLB  6
0875A:  MOVWF  xE0
0875C:  MOVLB  0
0875E:  CALL   5B38
08762:  MOVLW  89
08764:  MOVWF  FE9
08766:  MOVFF  D1,6D6
0876A:  MOVFF  D0,6D5
0876E:  MOVFF  CF,6D4
08772:  MOVFF  CE,6D3
08776:  MOVLW  02
08778:  MOVLB  6
0877A:  MOVWF  xD7
0877C:  MOVLB  0
0877E:  CALL   680C
08782:  MOVLW  2C
08784:  MOVLB  6
08786:  MOVWF  xE0
08788:  MOVLB  0
0878A:  CALL   5B38
....................    }
0878E:  BRA    8964
....................    else if (0 == strcmp(s_3V6X, arg1)) {
08790:  MOVFF  6B6,6D2
08794:  MOVFF  6B5,6D1
08798:  MOVFF  69C,6D4
0879C:  MOVFF  69B,6D3
087A0:  CALL   5AC0
087A4:  MOVF   01,F
087A6:  BNZ   882A
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V6X[0],monCal.v3V6X[1]);
087A8:  MOVLW  04
087AA:  MOVLB  6
087AC:  MOVWF  xD2
087AE:  MOVLW  DE
087B0:  MOVWF  xD1
087B2:  MOVLB  0
087B4:  CALL   5A88
087B8:  MOVFF  02,03
087BC:  MOVF   01,W
087BE:  ADDLW  DE
087C0:  MOVLB  6
087C2:  MOVWF  xCA
087C4:  MOVLW  04
087C6:  ADDWFC 02,W
087C8:  MOVWF  xCB
087CA:  MOVFF  FE8,583
087CE:  MOVFF  6CA,582
087D2:  MOVLW  89
087D4:  MOVWF  FE9
087D6:  MOVFF  D5,6D6
087DA:  MOVFF  D4,6D5
087DE:  MOVFF  D3,6D4
087E2:  MOVFF  D2,6D3
087E6:  MOVLW  02
087E8:  MOVWF  xD7
087EA:  MOVLB  0
087EC:  CALL   680C
087F0:  MOVLW  2C
087F2:  MOVLB  6
087F4:  MOVWF  xE0
087F6:  MOVLB  0
087F8:  CALL   5B38
087FC:  MOVLW  89
087FE:  MOVWF  FE9
08800:  MOVFF  D9,6D6
08804:  MOVFF  D8,6D5
08808:  MOVFF  D7,6D4
0880C:  MOVFF  D6,6D3
08810:  MOVLW  02
08812:  MOVLB  6
08814:  MOVWF  xD7
08816:  MOVLB  0
08818:  CALL   680C
0881C:  MOVLW  2C
0881E:  MOVLB  6
08820:  MOVWF  xE0
08822:  MOVLB  0
08824:  CALL   5B38
....................    }
08828:  BRA    8964
....................    else if (0 == strcmp(s_3V3A, arg1)) {
0882A:  MOVFF  6BD,6D2
0882E:  MOVFF  6BC,6D1
08832:  MOVFF  69C,6D4
08836:  MOVFF  69B,6D3
0883A:  CALL   5AC0
0883E:  MOVF   01,F
08840:  BNZ   88C4
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3A[0],monCal.v3V3A[1]);
08842:  MOVLW  04
08844:  MOVLB  6
08846:  MOVWF  xD2
08848:  MOVLW  DE
0884A:  MOVWF  xD1
0884C:  MOVLB  0
0884E:  CALL   5A88
08852:  MOVFF  02,03
08856:  MOVF   01,W
08858:  ADDLW  DE
0885A:  MOVLB  6
0885C:  MOVWF  xCA
0885E:  MOVLW  04
08860:  ADDWFC 02,W
08862:  MOVWF  xCB
08864:  MOVFF  FE8,583
08868:  MOVFF  6CA,582
0886C:  MOVLW  89
0886E:  MOVWF  FE9
08870:  MOVFF  DD,6D6
08874:  MOVFF  DC,6D5
08878:  MOVFF  DB,6D4
0887C:  MOVFF  DA,6D3
08880:  MOVLW  02
08882:  MOVWF  xD7
08884:  MOVLB  0
08886:  CALL   680C
0888A:  MOVLW  2C
0888C:  MOVLB  6
0888E:  MOVWF  xE0
08890:  MOVLB  0
08892:  CALL   5B38
08896:  MOVLW  89
08898:  MOVWF  FE9
0889A:  MOVFF  E1,6D6
0889E:  MOVFF  E0,6D5
088A2:  MOVFF  DF,6D4
088A6:  MOVFF  DE,6D3
088AA:  MOVLW  02
088AC:  MOVLB  6
088AE:  MOVWF  xD7
088B0:  MOVLB  0
088B2:  CALL   680C
088B6:  MOVLW  2C
088B8:  MOVLB  6
088BA:  MOVWF  xE0
088BC:  MOVLB  0
088BE:  CALL   5B38
....................    }
088C2:  BRA    8964
....................    else if (0 == strcmp(s_3V3D, arg1)) {
088C4:  MOVFF  6C4,6D2
088C8:  MOVFF  6C3,6D1
088CC:  MOVFF  69C,6D4
088D0:  MOVFF  69B,6D3
088D4:  CALL   5AC0
088D8:  MOVF   01,F
088DA:  BNZ   895E
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3D[0],monCal.v3V3D[1]);
088DC:  MOVLW  04
088DE:  MOVLB  6
088E0:  MOVWF  xD2
088E2:  MOVLW  DE
088E4:  MOVWF  xD1
088E6:  MOVLB  0
088E8:  CALL   5A88
088EC:  MOVFF  02,03
088F0:  MOVF   01,W
088F2:  ADDLW  DE
088F4:  MOVLB  6
088F6:  MOVWF  xCA
088F8:  MOVLW  04
088FA:  ADDWFC 02,W
088FC:  MOVWF  xCB
088FE:  MOVFF  FE8,583
08902:  MOVFF  6CA,582
08906:  MOVLW  89
08908:  MOVWF  FE9
0890A:  MOVFF  E5,6D6
0890E:  MOVFF  E4,6D5
08912:  MOVFF  E3,6D4
08916:  MOVFF  E2,6D3
0891A:  MOVLW  02
0891C:  MOVWF  xD7
0891E:  MOVLB  0
08920:  CALL   680C
08924:  MOVLW  2C
08926:  MOVLB  6
08928:  MOVWF  xE0
0892A:  MOVLB  0
0892C:  CALL   5B38
08930:  MOVLW  89
08932:  MOVWF  FE9
08934:  MOVFF  E9,6D6
08938:  MOVFF  E8,6D5
0893C:  MOVFF  E7,6D4
08940:  MOVFF  E6,6D3
08944:  MOVLW  02
08946:  MOVLB  6
08948:  MOVWF  xD7
0894A:  MOVLB  0
0894C:  CALL   680C
08950:  MOVLW  2C
08952:  MOVLB  6
08954:  MOVWF  xE0
08956:  MOVLB  0
08958:  CALL   5B38
....................    }
0895C:  BRA    8964
.................... //!   else if (0 == strcmp(s_all, arg1)) {
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.vN15[0],monCal.vN15[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v200[0],monCal.v200[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v5V6[0],monCal.v5V6[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v5VA[0],monCal.v5VA[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V6X[0],monCal.v3V6X[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3A[0],monCal.v3V3A[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3D[0],monCal.v3V3D[1]);
.................... //!   }
....................    else return INV_PARAM;
0895E:  MOVLW  02
08960:  MOVWF  01
08962:  BRA    8968
....................    
....................    return SUCCESS;
08964:  MOVLW  00
08966:  MOVWF  01
08968:  RETURN 0
.................... }
.................... 
.................... int8 setMonitorCalParam(unsigned int8 rec){
.................... 
....................    return SUCCESS;
0896A:  MOVLW  00
0896C:  MOVWF  01
0896E:  RETURN 0
.................... }
.................... 
.................... int8 getMonitorValue(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    char *arg1;
....................    char *s_N15 = "N15";
08970:  MOVLW  4E
08972:  MOVLB  6
08974:  MOVWF  x9F
08976:  MOVLW  31
08978:  MOVWF  xA0
0897A:  MOVLW  35
0897C:  MOVWF  xA1
0897E:  CLRF   xA2
08980:  MOVLW  06
08982:  MOVWF  x9E
08984:  MOVLW  9F
08986:  MOVWF  x9D
....................    char *s_200 = "200";
08988:  MOVLW  32
0898A:  MOVWF  xA5
0898C:  MOVLW  30
0898E:  MOVWF  xA6
08990:  MOVWF  xA7
08992:  CLRF   xA8
08994:  MOVLW  06
08996:  MOVWF  xA4
08998:  MOVLW  A5
0899A:  MOVWF  xA3
....................    char *s_5V6 = "5V6";
0899C:  MOVLW  35
0899E:  MOVWF  xAB
089A0:  MOVLW  56
089A2:  MOVWF  xAC
089A4:  MOVLW  36
089A6:  MOVWF  xAD
089A8:  CLRF   xAE
089AA:  MOVLW  06
089AC:  MOVWF  xAA
089AE:  MOVLW  AB
089B0:  MOVWF  xA9
....................    char *s_5VA = "5VA";
089B2:  MOVLW  35
089B4:  MOVWF  xB1
089B6:  MOVLW  56
089B8:  MOVWF  xB2
089BA:  MOVLW  41
089BC:  MOVWF  xB3
089BE:  CLRF   xB4
089C0:  MOVLW  06
089C2:  MOVWF  xB0
089C4:  MOVLW  B1
089C6:  MOVWF  xAF
....................    char *s_3V6X = "3V6X";
089C8:  MOVLW  33
089CA:  MOVWF  xB7
089CC:  MOVLW  56
089CE:  MOVWF  xB8
089D0:  MOVLW  36
089D2:  MOVWF  xB9
089D4:  MOVLW  58
089D6:  MOVWF  xBA
089D8:  CLRF   xBB
089DA:  MOVLW  06
089DC:  MOVWF  xB6
089DE:  MOVLW  B7
089E0:  MOVWF  xB5
....................    char *s_3V3A = "3V3A";
089E2:  MOVLW  33
089E4:  MOVWF  xBE
089E6:  MOVLW  56
089E8:  MOVWF  xBF
089EA:  MOVLW  33
089EC:  MOVWF  xC0
089EE:  MOVLW  41
089F0:  MOVWF  xC1
089F2:  CLRF   xC2
089F4:  MOVLW  06
089F6:  MOVWF  xBD
089F8:  MOVLW  BE
089FA:  MOVWF  xBC
....................    char *s_3V3D = "3V3D";
089FC:  MOVLW  33
089FE:  MOVWF  xC5
08A00:  MOVLW  56
08A02:  MOVWF  xC6
08A04:  MOVLW  33
08A06:  MOVWF  xC7
08A08:  MOVLW  44
08A0A:  MOVWF  xC8
08A0C:  CLRF   xC9
08A0E:  MOVLW  06
08A10:  MOVWF  xC4
08A12:  MOVLW  C5
08A14:  MOVWF  xC3
....................    char *s_all = "all";
08A16:  MOVLW  61
08A18:  MOVWF  xCC
08A1A:  MOVLW  6C
08A1C:  MOVWF  xCD
08A1E:  MOVWF  xCE
08A20:  CLRF   xCF
08A22:  MOVLW  06
08A24:  MOVWF  xCB
08A26:  MOVLW  CC
08A28:  MOVWF  xCA
....................    
....................    arg1 = SERcmd[rec].p[2];
08A2A:  CLRF   xF2
08A2C:  MOVFF  68F,6F1
08A30:  CLRF   xF4
08A32:  MOVLW  B5
08A34:  MOVWF  xF3
08A36:  MOVLB  0
08A38:  CALL   0C0C
08A3C:  MOVFF  02,6D1
08A40:  MOVFF  01,6D0
08A44:  MOVLW  06
08A46:  MOVLB  6
08A48:  ADDWF  xD0,F
08A4A:  MOVLW  00
08A4C:  ADDWFC xD1,F
08A4E:  MOVLW  32
08A50:  ADDWF  xD0,W
08A52:  MOVWF  01
08A54:  MOVLW  00
08A56:  ADDWFC xD1,W
08A58:  MOVWF  03
08A5A:  MOVF   01,W
08A5C:  ADDLW  08
08A5E:  MOVWF  01
08A60:  MOVLW  02
08A62:  ADDWFC 03,F
08A64:  MOVFF  01,69B
08A68:  MOVFF  03,69C
....................    
....................    /*** GET MONITOR VALUES ************/
....................    if      (0 == strcmp(s_N15, arg1)) {
08A6C:  MOVFF  69E,6D2
08A70:  MOVFF  69D,6D1
08A74:  MOVFF  69C,6D4
08A78:  MOVFF  69B,6D3
08A7C:  MOVLB  0
08A7E:  CALL   5AC0
08A82:  MOVF   01,F
08A84:  BNZ   8ADC
....................       sprintf(retData+strlen(retData), "%.2f,", monitorVals.vN15);
08A86:  MOVLW  04
08A88:  MOVLB  6
08A8A:  MOVWF  xD2
08A8C:  MOVLW  DE
08A8E:  MOVWF  xD1
08A90:  MOVLB  0
08A92:  CALL   5A88
08A96:  MOVFF  02,03
08A9A:  MOVF   01,W
08A9C:  ADDLW  DE
08A9E:  MOVLB  6
08AA0:  MOVWF  xD0
08AA2:  MOVLW  04
08AA4:  ADDWFC 02,W
08AA6:  MOVWF  xD1
08AA8:  MOVFF  FE8,583
08AAC:  MOVFF  6D0,582
08AB0:  MOVLW  89
08AB2:  MOVWF  FE9
08AB4:  MOVFF  F6,6D6
08AB8:  MOVFF  F5,6D5
08ABC:  MOVFF  F4,6D4
08AC0:  MOVFF  F3,6D3
08AC4:  MOVLW  02
08AC6:  MOVWF  xD7
08AC8:  MOVLB  0
08ACA:  CALL   680C
08ACE:  MOVLW  2C
08AD0:  MOVLB  6
08AD2:  MOVWF  xE0
08AD4:  MOVLB  0
08AD6:  CALL   5B38
....................    }
08ADA:  BRA    8FDE
....................    else if (0 == strcmp(s_200, arg1)) {
08ADC:  MOVFF  6A4,6D2
08AE0:  MOVFF  6A3,6D1
08AE4:  MOVFF  69C,6D4
08AE8:  MOVFF  69B,6D3
08AEC:  CALL   5AC0
08AF0:  MOVF   01,F
08AF2:  BNZ   8B4A
....................       sprintf(retData+strlen(retData), "%.1f,", monitorVals.v200);
08AF4:  MOVLW  04
08AF6:  MOVLB  6
08AF8:  MOVWF  xD2
08AFA:  MOVLW  DE
08AFC:  MOVWF  xD1
08AFE:  MOVLB  0
08B00:  CALL   5A88
08B04:  MOVFF  02,03
08B08:  MOVF   01,W
08B0A:  ADDLW  DE
08B0C:  MOVLB  6
08B0E:  MOVWF  xD0
08B10:  MOVLW  04
08B12:  ADDWFC 02,W
08B14:  MOVWF  xD1
08B16:  MOVFF  FE8,583
08B1A:  MOVFF  6D0,582
08B1E:  MOVLW  89
08B20:  MOVWF  FE9
08B22:  MOVFF  FA,6D6
08B26:  MOVFF  F9,6D5
08B2A:  MOVFF  F8,6D4
08B2E:  MOVFF  F7,6D3
08B32:  MOVLW  01
08B34:  MOVWF  xD7
08B36:  MOVLB  0
08B38:  CALL   680C
08B3C:  MOVLW  2C
08B3E:  MOVLB  6
08B40:  MOVWF  xE0
08B42:  MOVLB  0
08B44:  CALL   5B38
....................    }
08B48:  BRA    8FDE
....................    else if (0 == strcmp(s_5V6, arg1)) {
08B4A:  MOVFF  6AA,6D2
08B4E:  MOVFF  6A9,6D1
08B52:  MOVFF  69C,6D4
08B56:  MOVFF  69B,6D3
08B5A:  CALL   5AC0
08B5E:  MOVF   01,F
08B60:  BNZ   8BB8
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5V6);
08B62:  MOVLW  04
08B64:  MOVLB  6
08B66:  MOVWF  xD2
08B68:  MOVLW  DE
08B6A:  MOVWF  xD1
08B6C:  MOVLB  0
08B6E:  CALL   5A88
08B72:  MOVFF  02,03
08B76:  MOVF   01,W
08B78:  ADDLW  DE
08B7A:  MOVLB  6
08B7C:  MOVWF  xD0
08B7E:  MOVLW  04
08B80:  ADDWFC 02,W
08B82:  MOVWF  xD1
08B84:  MOVFF  FE8,583
08B88:  MOVFF  6D0,582
08B8C:  MOVLW  89
08B8E:  MOVWF  FE9
08B90:  MOVFF  FE,6D6
08B94:  MOVFF  FD,6D5
08B98:  MOVFF  FC,6D4
08B9C:  MOVFF  FB,6D3
08BA0:  MOVLW  03
08BA2:  MOVWF  xD7
08BA4:  MOVLB  0
08BA6:  CALL   680C
08BAA:  MOVLW  2C
08BAC:  MOVLB  6
08BAE:  MOVWF  xE0
08BB0:  MOVLB  0
08BB2:  CALL   5B38
....................    }
08BB6:  BRA    8FDE
....................    else if (0 == strcmp(s_5VA, arg1)) {
08BB8:  MOVFF  6B0,6D2
08BBC:  MOVFF  6AF,6D1
08BC0:  MOVFF  69C,6D4
08BC4:  MOVFF  69B,6D3
08BC8:  CALL   5AC0
08BCC:  MOVF   01,F
08BCE:  BNZ   8C26
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5VA);
08BD0:  MOVLW  04
08BD2:  MOVLB  6
08BD4:  MOVWF  xD2
08BD6:  MOVLW  DE
08BD8:  MOVWF  xD1
08BDA:  MOVLB  0
08BDC:  CALL   5A88
08BE0:  MOVFF  02,03
08BE4:  MOVF   01,W
08BE6:  ADDLW  DE
08BE8:  MOVLB  6
08BEA:  MOVWF  xD0
08BEC:  MOVLW  04
08BEE:  ADDWFC 02,W
08BF0:  MOVWF  xD1
08BF2:  MOVFF  FE8,583
08BF6:  MOVFF  6D0,582
08BFA:  MOVLW  89
08BFC:  MOVWF  FE9
08BFE:  MOVFF  102,6D6
08C02:  MOVFF  101,6D5
08C06:  MOVFF  100,6D4
08C0A:  MOVFF  FF,6D3
08C0E:  MOVLW  03
08C10:  MOVWF  xD7
08C12:  MOVLB  0
08C14:  CALL   680C
08C18:  MOVLW  2C
08C1A:  MOVLB  6
08C1C:  MOVWF  xE0
08C1E:  MOVLB  0
08C20:  CALL   5B38
....................    }
08C24:  BRA    8FDE
....................    else if (0 == strcmp(s_3V6X, arg1)) {
08C26:  MOVFF  6B6,6D2
08C2A:  MOVFF  6B5,6D1
08C2E:  MOVFF  69C,6D4
08C32:  MOVFF  69B,6D3
08C36:  CALL   5AC0
08C3A:  MOVF   01,F
08C3C:  BNZ   8C94
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V6X);
08C3E:  MOVLW  04
08C40:  MOVLB  6
08C42:  MOVWF  xD2
08C44:  MOVLW  DE
08C46:  MOVWF  xD1
08C48:  MOVLB  0
08C4A:  CALL   5A88
08C4E:  MOVFF  02,03
08C52:  MOVF   01,W
08C54:  ADDLW  DE
08C56:  MOVLB  6
08C58:  MOVWF  xD0
08C5A:  MOVLW  04
08C5C:  ADDWFC 02,W
08C5E:  MOVWF  xD1
08C60:  MOVFF  FE8,583
08C64:  MOVFF  6D0,582
08C68:  MOVLW  89
08C6A:  MOVWF  FE9
08C6C:  MOVFF  106,6D6
08C70:  MOVFF  105,6D5
08C74:  MOVFF  104,6D4
08C78:  MOVFF  103,6D3
08C7C:  MOVLW  03
08C7E:  MOVWF  xD7
08C80:  MOVLB  0
08C82:  CALL   680C
08C86:  MOVLW  2C
08C88:  MOVLB  6
08C8A:  MOVWF  xE0
08C8C:  MOVLB  0
08C8E:  CALL   5B38
....................    }
08C92:  BRA    8FDE
....................    else if (0 == strcmp(s_3V3A, arg1)) {
08C94:  MOVFF  6BD,6D2
08C98:  MOVFF  6BC,6D1
08C9C:  MOVFF  69C,6D4
08CA0:  MOVFF  69B,6D3
08CA4:  CALL   5AC0
08CA8:  MOVF   01,F
08CAA:  BNZ   8D02
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3A);
08CAC:  MOVLW  04
08CAE:  MOVLB  6
08CB0:  MOVWF  xD2
08CB2:  MOVLW  DE
08CB4:  MOVWF  xD1
08CB6:  MOVLB  0
08CB8:  CALL   5A88
08CBC:  MOVFF  02,03
08CC0:  MOVF   01,W
08CC2:  ADDLW  DE
08CC4:  MOVLB  6
08CC6:  MOVWF  xD0
08CC8:  MOVLW  04
08CCA:  ADDWFC 02,W
08CCC:  MOVWF  xD1
08CCE:  MOVFF  FE8,583
08CD2:  MOVFF  6D0,582
08CD6:  MOVLW  89
08CD8:  MOVWF  FE9
08CDA:  MOVFF  10A,6D6
08CDE:  MOVFF  109,6D5
08CE2:  MOVFF  108,6D4
08CE6:  MOVFF  107,6D3
08CEA:  MOVLW  03
08CEC:  MOVWF  xD7
08CEE:  MOVLB  0
08CF0:  CALL   680C
08CF4:  MOVLW  2C
08CF6:  MOVLB  6
08CF8:  MOVWF  xE0
08CFA:  MOVLB  0
08CFC:  CALL   5B38
....................    }
08D00:  BRA    8FDE
....................    else if (0 == strcmp(s_3V3D, arg1)) {
08D02:  MOVFF  6C4,6D2
08D06:  MOVFF  6C3,6D1
08D0A:  MOVFF  69C,6D4
08D0E:  MOVFF  69B,6D3
08D12:  CALL   5AC0
08D16:  MOVF   01,F
08D18:  BNZ   8D70
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3D);
08D1A:  MOVLW  04
08D1C:  MOVLB  6
08D1E:  MOVWF  xD2
08D20:  MOVLW  DE
08D22:  MOVWF  xD1
08D24:  MOVLB  0
08D26:  CALL   5A88
08D2A:  MOVFF  02,03
08D2E:  MOVF   01,W
08D30:  ADDLW  DE
08D32:  MOVLB  6
08D34:  MOVWF  xD0
08D36:  MOVLW  04
08D38:  ADDWFC 02,W
08D3A:  MOVWF  xD1
08D3C:  MOVFF  FE8,583
08D40:  MOVFF  6D0,582
08D44:  MOVLW  89
08D46:  MOVWF  FE9
08D48:  MOVFF  10E,6D6
08D4C:  MOVFF  10D,6D5
08D50:  MOVFF  10C,6D4
08D54:  MOVFF  10B,6D3
08D58:  MOVLW  03
08D5A:  MOVWF  xD7
08D5C:  MOVLB  0
08D5E:  CALL   680C
08D62:  MOVLW  2C
08D64:  MOVLB  6
08D66:  MOVWF  xE0
08D68:  MOVLB  0
08D6A:  CALL   5B38
....................    }
08D6E:  BRA    8FDE
....................    else if (0 == strcmp(s_all, arg1)) {
08D70:  MOVFF  6CB,6D2
08D74:  MOVFF  6CA,6D1
08D78:  MOVFF  69C,6D4
08D7C:  MOVFF  69B,6D3
08D80:  CALL   5AC0
08D84:  MOVF   01,F
08D86:  BTFSS  FD8.2
08D88:  BRA    8FD8
....................       sprintf(retData+strlen(retData), "%.2f,", monitorVals.vN15);
08D8A:  MOVLW  04
08D8C:  MOVLB  6
08D8E:  MOVWF  xD2
08D90:  MOVLW  DE
08D92:  MOVWF  xD1
08D94:  MOVLB  0
08D96:  CALL   5A88
08D9A:  MOVFF  02,03
08D9E:  MOVF   01,W
08DA0:  ADDLW  DE
08DA2:  MOVLB  6
08DA4:  MOVWF  xD0
08DA6:  MOVLW  04
08DA8:  ADDWFC 02,W
08DAA:  MOVWF  xD1
08DAC:  MOVFF  FE8,583
08DB0:  MOVFF  6D0,582
08DB4:  MOVLW  89
08DB6:  MOVWF  FE9
08DB8:  MOVFF  F6,6D6
08DBC:  MOVFF  F5,6D5
08DC0:  MOVFF  F4,6D4
08DC4:  MOVFF  F3,6D3
08DC8:  MOVLW  02
08DCA:  MOVWF  xD7
08DCC:  MOVLB  0
08DCE:  CALL   680C
08DD2:  MOVLW  2C
08DD4:  MOVLB  6
08DD6:  MOVWF  xE0
08DD8:  MOVLB  0
08DDA:  CALL   5B38
....................       sprintf(retData+strlen(retData), "%.1f,", monitorVals.v200);
08DDE:  MOVLW  04
08DE0:  MOVLB  6
08DE2:  MOVWF  xD2
08DE4:  MOVLW  DE
08DE6:  MOVWF  xD1
08DE8:  MOVLB  0
08DEA:  CALL   5A88
08DEE:  MOVFF  02,03
08DF2:  MOVF   01,W
08DF4:  ADDLW  DE
08DF6:  MOVLB  6
08DF8:  MOVWF  xD0
08DFA:  MOVLW  04
08DFC:  ADDWFC 02,W
08DFE:  MOVWF  xD1
08E00:  MOVFF  FE8,583
08E04:  MOVFF  6D0,582
08E08:  MOVLW  89
08E0A:  MOVWF  FE9
08E0C:  MOVFF  FA,6D6
08E10:  MOVFF  F9,6D5
08E14:  MOVFF  F8,6D4
08E18:  MOVFF  F7,6D3
08E1C:  MOVLW  01
08E1E:  MOVWF  xD7
08E20:  MOVLB  0
08E22:  CALL   680C
08E26:  MOVLW  2C
08E28:  MOVLB  6
08E2A:  MOVWF  xE0
08E2C:  MOVLB  0
08E2E:  CALL   5B38
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5V6);
08E32:  MOVLW  04
08E34:  MOVLB  6
08E36:  MOVWF  xD2
08E38:  MOVLW  DE
08E3A:  MOVWF  xD1
08E3C:  MOVLB  0
08E3E:  CALL   5A88
08E42:  MOVFF  02,03
08E46:  MOVF   01,W
08E48:  ADDLW  DE
08E4A:  MOVLB  6
08E4C:  MOVWF  xD0
08E4E:  MOVLW  04
08E50:  ADDWFC 02,W
08E52:  MOVWF  xD1
08E54:  MOVFF  FE8,583
08E58:  MOVFF  6D0,582
08E5C:  MOVLW  89
08E5E:  MOVWF  FE9
08E60:  MOVFF  FE,6D6
08E64:  MOVFF  FD,6D5
08E68:  MOVFF  FC,6D4
08E6C:  MOVFF  FB,6D3
08E70:  MOVLW  03
08E72:  MOVWF  xD7
08E74:  MOVLB  0
08E76:  CALL   680C
08E7A:  MOVLW  2C
08E7C:  MOVLB  6
08E7E:  MOVWF  xE0
08E80:  MOVLB  0
08E82:  CALL   5B38
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5VA);
08E86:  MOVLW  04
08E88:  MOVLB  6
08E8A:  MOVWF  xD2
08E8C:  MOVLW  DE
08E8E:  MOVWF  xD1
08E90:  MOVLB  0
08E92:  CALL   5A88
08E96:  MOVFF  02,03
08E9A:  MOVF   01,W
08E9C:  ADDLW  DE
08E9E:  MOVLB  6
08EA0:  MOVWF  xD0
08EA2:  MOVLW  04
08EA4:  ADDWFC 02,W
08EA6:  MOVWF  xD1
08EA8:  MOVFF  FE8,583
08EAC:  MOVFF  6D0,582
08EB0:  MOVLW  89
08EB2:  MOVWF  FE9
08EB4:  MOVFF  102,6D6
08EB8:  MOVFF  101,6D5
08EBC:  MOVFF  100,6D4
08EC0:  MOVFF  FF,6D3
08EC4:  MOVLW  03
08EC6:  MOVWF  xD7
08EC8:  MOVLB  0
08ECA:  CALL   680C
08ECE:  MOVLW  2C
08ED0:  MOVLB  6
08ED2:  MOVWF  xE0
08ED4:  MOVLB  0
08ED6:  CALL   5B38
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V6X);
08EDA:  MOVLW  04
08EDC:  MOVLB  6
08EDE:  MOVWF  xD2
08EE0:  MOVLW  DE
08EE2:  MOVWF  xD1
08EE4:  MOVLB  0
08EE6:  CALL   5A88
08EEA:  MOVFF  02,03
08EEE:  MOVF   01,W
08EF0:  ADDLW  DE
08EF2:  MOVLB  6
08EF4:  MOVWF  xD0
08EF6:  MOVLW  04
08EF8:  ADDWFC 02,W
08EFA:  MOVWF  xD1
08EFC:  MOVFF  FE8,583
08F00:  MOVFF  6D0,582
08F04:  MOVLW  89
08F06:  MOVWF  FE9
08F08:  MOVFF  106,6D6
08F0C:  MOVFF  105,6D5
08F10:  MOVFF  104,6D4
08F14:  MOVFF  103,6D3
08F18:  MOVLW  03
08F1A:  MOVWF  xD7
08F1C:  MOVLB  0
08F1E:  CALL   680C
08F22:  MOVLW  2C
08F24:  MOVLB  6
08F26:  MOVWF  xE0
08F28:  MOVLB  0
08F2A:  CALL   5B38
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3A);
08F2E:  MOVLW  04
08F30:  MOVLB  6
08F32:  MOVWF  xD2
08F34:  MOVLW  DE
08F36:  MOVWF  xD1
08F38:  MOVLB  0
08F3A:  CALL   5A88
08F3E:  MOVFF  02,03
08F42:  MOVF   01,W
08F44:  ADDLW  DE
08F46:  MOVLB  6
08F48:  MOVWF  xD0
08F4A:  MOVLW  04
08F4C:  ADDWFC 02,W
08F4E:  MOVWF  xD1
08F50:  MOVFF  FE8,583
08F54:  MOVFF  6D0,582
08F58:  MOVLW  89
08F5A:  MOVWF  FE9
08F5C:  MOVFF  10A,6D6
08F60:  MOVFF  109,6D5
08F64:  MOVFF  108,6D4
08F68:  MOVFF  107,6D3
08F6C:  MOVLW  03
08F6E:  MOVWF  xD7
08F70:  MOVLB  0
08F72:  CALL   680C
08F76:  MOVLW  2C
08F78:  MOVLB  6
08F7A:  MOVWF  xE0
08F7C:  MOVLB  0
08F7E:  CALL   5B38
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3D);
08F82:  MOVLW  04
08F84:  MOVLB  6
08F86:  MOVWF  xD2
08F88:  MOVLW  DE
08F8A:  MOVWF  xD1
08F8C:  MOVLB  0
08F8E:  CALL   5A88
08F92:  MOVFF  02,03
08F96:  MOVF   01,W
08F98:  ADDLW  DE
08F9A:  MOVLB  6
08F9C:  MOVWF  xD0
08F9E:  MOVLW  04
08FA0:  ADDWFC 02,W
08FA2:  MOVWF  xD1
08FA4:  MOVFF  FE8,583
08FA8:  MOVFF  6D0,582
08FAC:  MOVLW  89
08FAE:  MOVWF  FE9
08FB0:  MOVFF  10E,6D6
08FB4:  MOVFF  10D,6D5
08FB8:  MOVFF  10C,6D4
08FBC:  MOVFF  10B,6D3
08FC0:  MOVLW  03
08FC2:  MOVWF  xD7
08FC4:  MOVLB  0
08FC6:  CALL   680C
08FCA:  MOVLW  2C
08FCC:  MOVLB  6
08FCE:  MOVWF  xE0
08FD0:  MOVLB  0
08FD2:  CALL   5B38
....................    }
08FD6:  BRA    8FDE
....................    else return INV_PARAM;
08FD8:  MOVLW  02
08FDA:  MOVWF  01
08FDC:  BRA    8FE2
....................    
....................    return SUCCESS;
08FDE:  MOVLW  00
08FE0:  MOVWF  01
08FE2:  RETURN 0
.................... }
.................... 
.................... int8 getPIDdata(unsigned int8 rec){
....................   /*** ARG CHECKS ********************/ 
....................    int8 arg1;
....................    char *arg2;
....................    char *s_PV = "PV";
08FE4:  MOVLW  50
08FE6:  MOVLB  6
08FE8:  MOVWF  xA0
08FEA:  MOVLW  56
08FEC:  MOVWF  xA1
08FEE:  CLRF   xA2
08FF0:  MOVLW  06
08FF2:  MOVWF  x9F
08FF4:  MOVLW  A0
08FF6:  MOVWF  x9E
....................    char *s_CV = "CV";
08FF8:  MOVLW  43
08FFA:  MOVWF  xA5
08FFC:  MOVLW  56
08FFE:  MOVWF  xA6
09000:  CLRF   xA7
09002:  MOVLW  06
09004:  MOVWF  xA4
09006:  MOVLW  A5
09008:  MOVWF  xA3
....................    char *s_PVold = "PVold";
0900A:  MOVLW  50
0900C:  MOVWF  xAA
0900E:  MOVLW  56
09010:  MOVWF  xAB
09012:  MOVLW  6F
09014:  MOVWF  xAC
09016:  MOVLW  6C
09018:  MOVWF  xAD
0901A:  MOVLW  64
0901C:  MOVWF  xAE
0901E:  CLRF   xAF
09020:  MOVLW  06
09022:  MOVWF  xA9
09024:  MOVLW  AA
09026:  MOVWF  xA8
....................    char *s_I = "I";
09028:  MOVLW  49
0902A:  MOVWF  xB2
0902C:  CLRF   xB3
0902E:  MOVLW  06
09030:  MOVWF  xB1
09032:  MOVLW  B2
09034:  MOVWF  xB0
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
09036:  CLRF   xF2
09038:  MOVFF  68F,6F1
0903C:  CLRF   xF4
0903E:  MOVLW  B5
09040:  MOVWF  xF3
09042:  MOVLB  0
09044:  CALL   0C0C
09048:  MOVFF  02,6B5
0904C:  MOVFF  01,6B4
09050:  MOVLW  06
09052:  MOVLB  6
09054:  ADDWF  xB4,F
09056:  MOVLW  00
09058:  ADDWFC xB5,F
0905A:  MOVLW  32
0905C:  ADDWF  xB4,W
0905E:  MOVWF  01
09060:  MOVLW  00
09062:  ADDWFC xB5,W
09064:  MOVWF  03
09066:  MOVF   01,W
09068:  ADDLW  08
0906A:  MOVWF  01
0906C:  MOVLW  02
0906E:  ADDWFC 03,F
09070:  MOVFF  01,6B4
09074:  MOVFF  03,6B5
09078:  MOVFF  03,6C4
0907C:  MOVFF  01,6C3
09080:  MOVLB  0
09082:  CALL   5C00
09086:  MOVF   01,F
09088:  BNZ   9092
0908A:  MOVLW  02
0908C:  MOVWF  01
0908E:  BRA    9428
09090:  BRA    90F0
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
09092:  MOVLB  6
09094:  CLRF   xF2
09096:  MOVFF  68F,6F1
0909A:  CLRF   xF4
0909C:  MOVLW  B5
0909E:  MOVWF  xF3
090A0:  MOVLB  0
090A2:  CALL   0C0C
090A6:  MOVFF  02,6B5
090AA:  MOVFF  01,6B4
090AE:  MOVLW  06
090B0:  MOVLB  6
090B2:  ADDWF  xB4,F
090B4:  MOVLW  00
090B6:  ADDWFC xB5,F
090B8:  MOVLW  32
090BA:  ADDWF  xB4,W
090BC:  MOVWF  01
090BE:  MOVLW  00
090C0:  ADDWFC xB5,W
090C2:  MOVWF  03
090C4:  MOVF   01,W
090C6:  ADDLW  08
090C8:  MOVWF  01
090CA:  MOVLW  02
090CC:  ADDWFC 03,F
090CE:  MOVFF  01,6B4
090D2:  MOVFF  03,6B5
090D6:  MOVFF  03,6C4
090DA:  MOVFF  01,6C3
090DE:  CLRF   xC6
090E0:  CLRF   xC5
090E2:  MOVLW  0A
090E4:  MOVWF  xC7
090E6:  MOVLB  0
090E8:  CALL   5C9A
090EC:  MOVFF  01,69B
....................    
....................    arg2 = SERcmd[rec].p[3];
090F0:  MOVLB  6
090F2:  CLRF   xF2
090F4:  MOVFF  68F,6F1
090F8:  CLRF   xF4
090FA:  MOVLW  B5
090FC:  MOVWF  xF3
090FE:  MOVLB  0
09100:  CALL   0C0C
09104:  MOVFF  02,6B5
09108:  MOVFF  01,6B4
0910C:  MOVLW  06
0910E:  MOVLB  6
09110:  ADDWF  xB4,F
09112:  MOVLW  00
09114:  ADDWFC xB5,F
09116:  MOVLW  4B
09118:  ADDWF  xB4,W
0911A:  MOVWF  01
0911C:  MOVLW  00
0911E:  ADDWFC xB5,W
09120:  MOVWF  03
09122:  MOVF   01,W
09124:  ADDLW  08
09126:  MOVWF  01
09128:  MOVLW  02
0912A:  ADDWFC 03,F
0912C:  MOVFF  01,69C
09130:  MOVFF  03,69D
....................    
....................    /*** GET PV, CV, PVold, I, or A(LL) VALUE **********/
....................    if      (0 == strcmp(s_PV, arg2))     sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].PV);
09134:  MOVFF  69F,6D2
09138:  MOVFF  69E,6D1
0913C:  MOVFF  69D,6D4
09140:  MOVFF  69C,6D3
09144:  MOVLB  0
09146:  CALL   5AC0
0914A:  MOVF   01,F
0914C:  BNZ   91F0
0914E:  MOVLW  04
09150:  MOVLB  6
09152:  MOVWF  xD2
09154:  MOVLW  DE
09156:  MOVWF  xD1
09158:  MOVLB  0
0915A:  CALL   5A88
0915E:  MOVF   01,W
09160:  ADDLW  DE
09162:  MOVLB  6
09164:  MOVWF  xB4
09166:  MOVLW  04
09168:  ADDWFC 02,W
0916A:  MOVWF  xB5
0916C:  MOVLW  01
0916E:  SUBWF  x9B,W
09170:  MULLW  20
09172:  MOVF   FF3,W
09174:  CLRF   xB7
09176:  MOVWF  xB6
09178:  MOVLW  10
0917A:  ADDWF  xB6,W
0917C:  MOVWF  01
0917E:  MOVLW  00
09180:  ADDWFC xB7,W
09182:  MOVWF  03
09184:  MOVF   01,W
09186:  ADDLW  20
09188:  MOVWF  FE9
0918A:  MOVLW  00
0918C:  ADDWFC 03,W
0918E:  MOVWF  FEA
09190:  MOVFF  FEF,6B6
09194:  MOVFF  FEC,6B7
09198:  MOVFF  FEC,6B8
0919C:  MOVFF  FEC,6B9
091A0:  MOVFF  6B5,583
091A4:  MOVFF  6B4,582
091A8:  MOVFF  69B,6C4
091AC:  MOVLW  18
091AE:  MOVWF  xC5
091B0:  MOVLB  0
091B2:  CALL   5FF0
091B6:  MOVLW  2C
091B8:  MOVLB  6
091BA:  MOVWF  xE0
091BC:  MOVLB  0
091BE:  CALL   5B38
091C2:  MOVLW  89
091C4:  MOVWF  FE9
091C6:  MOVFF  6B9,6D6
091CA:  MOVFF  6B8,6D5
091CE:  MOVFF  6B7,6D4
091D2:  MOVFF  6B6,6D3
091D6:  MOVLW  02
091D8:  MOVLB  6
091DA:  MOVWF  xD7
091DC:  MOVLB  0
091DE:  CALL   680C
091E2:  MOVLW  2C
091E4:  MOVLB  6
091E6:  MOVWF  xE0
091E8:  MOVLB  0
091EA:  CALL   5B38
091EE:  BRA    9424
....................    else if (0 == strcmp(s_CV, arg2))     sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].CV);
091F0:  MOVFF  6A4,6D2
091F4:  MOVFF  6A3,6D1
091F8:  MOVFF  69D,6D4
091FC:  MOVFF  69C,6D3
09200:  CALL   5AC0
09204:  MOVF   01,F
09206:  BNZ   92AA
09208:  MOVLW  04
0920A:  MOVLB  6
0920C:  MOVWF  xD2
0920E:  MOVLW  DE
09210:  MOVWF  xD1
09212:  MOVLB  0
09214:  CALL   5A88
09218:  MOVF   01,W
0921A:  ADDLW  DE
0921C:  MOVLB  6
0921E:  MOVWF  xB4
09220:  MOVLW  04
09222:  ADDWFC 02,W
09224:  MOVWF  xB5
09226:  MOVLW  01
09228:  SUBWF  x9B,W
0922A:  MULLW  20
0922C:  MOVF   FF3,W
0922E:  CLRF   xB7
09230:  MOVWF  xB6
09232:  MOVLW  18
09234:  ADDWF  xB6,W
09236:  MOVWF  01
09238:  MOVLW  00
0923A:  ADDWFC xB7,W
0923C:  MOVWF  03
0923E:  MOVF   01,W
09240:  ADDLW  20
09242:  MOVWF  FE9
09244:  MOVLW  00
09246:  ADDWFC 03,W
09248:  MOVWF  FEA
0924A:  MOVFF  FEF,6B6
0924E:  MOVFF  FEC,6B7
09252:  MOVFF  FEC,6B8
09256:  MOVFF  FEC,6B9
0925A:  MOVFF  6B5,583
0925E:  MOVFF  6B4,582
09262:  MOVFF  69B,6C4
09266:  MOVLW  18
09268:  MOVWF  xC5
0926A:  MOVLB  0
0926C:  CALL   5FF0
09270:  MOVLW  2C
09272:  MOVLB  6
09274:  MOVWF  xE0
09276:  MOVLB  0
09278:  CALL   5B38
0927C:  MOVLW  89
0927E:  MOVWF  FE9
09280:  MOVFF  6B9,6D6
09284:  MOVFF  6B8,6D5
09288:  MOVFF  6B7,6D4
0928C:  MOVFF  6B6,6D3
09290:  MOVLW  02
09292:  MOVLB  6
09294:  MOVWF  xD7
09296:  MOVLB  0
09298:  CALL   680C
0929C:  MOVLW  2C
0929E:  MOVLB  6
092A0:  MOVWF  xE0
092A2:  MOVLB  0
092A4:  CALL   5B38
092A8:  BRA    9424
....................    else if (0 == strcmp(s_PVold, arg2))  sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].PVold);
092AA:  MOVFF  6A9,6D2
092AE:  MOVFF  6A8,6D1
092B2:  MOVFF  69D,6D4
092B6:  MOVFF  69C,6D3
092BA:  CALL   5AC0
092BE:  MOVF   01,F
092C0:  BNZ   9364
092C2:  MOVLW  04
092C4:  MOVLB  6
092C6:  MOVWF  xD2
092C8:  MOVLW  DE
092CA:  MOVWF  xD1
092CC:  MOVLB  0
092CE:  CALL   5A88
092D2:  MOVF   01,W
092D4:  ADDLW  DE
092D6:  MOVLB  6
092D8:  MOVWF  xB4
092DA:  MOVLW  04
092DC:  ADDWFC 02,W
092DE:  MOVWF  xB5
092E0:  MOVLW  01
092E2:  SUBWF  x9B,W
092E4:  MULLW  20
092E6:  MOVF   FF3,W
092E8:  CLRF   xB7
092EA:  MOVWF  xB6
092EC:  MOVLW  14
092EE:  ADDWF  xB6,W
092F0:  MOVWF  01
092F2:  MOVLW  00
092F4:  ADDWFC xB7,W
092F6:  MOVWF  03
092F8:  MOVF   01,W
092FA:  ADDLW  20
092FC:  MOVWF  FE9
092FE:  MOVLW  00
09300:  ADDWFC 03,W
09302:  MOVWF  FEA
09304:  MOVFF  FEF,6B6
09308:  MOVFF  FEC,6B7
0930C:  MOVFF  FEC,6B8
09310:  MOVFF  FEC,6B9
09314:  MOVFF  6B5,583
09318:  MOVFF  6B4,582
0931C:  MOVFF  69B,6C4
09320:  MOVLW  18
09322:  MOVWF  xC5
09324:  MOVLB  0
09326:  CALL   5FF0
0932A:  MOVLW  2C
0932C:  MOVLB  6
0932E:  MOVWF  xE0
09330:  MOVLB  0
09332:  CALL   5B38
09336:  MOVLW  89
09338:  MOVWF  FE9
0933A:  MOVFF  6B9,6D6
0933E:  MOVFF  6B8,6D5
09342:  MOVFF  6B7,6D4
09346:  MOVFF  6B6,6D3
0934A:  MOVLW  02
0934C:  MOVLB  6
0934E:  MOVWF  xD7
09350:  MOVLB  0
09352:  CALL   680C
09356:  MOVLW  2C
09358:  MOVLB  6
0935A:  MOVWF  xE0
0935C:  MOVLB  0
0935E:  CALL   5B38
09362:  BRA    9424
....................    else if (0 == strcmp(s_I, arg2))      sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].I);
09364:  MOVFF  6B1,6D2
09368:  MOVFF  6B0,6D1
0936C:  MOVFF  69D,6D4
09370:  MOVFF  69C,6D3
09374:  CALL   5AC0
09378:  MOVF   01,F
0937A:  BNZ   941E
0937C:  MOVLW  04
0937E:  MOVLB  6
09380:  MOVWF  xD2
09382:  MOVLW  DE
09384:  MOVWF  xD1
09386:  MOVLB  0
09388:  CALL   5A88
0938C:  MOVF   01,W
0938E:  ADDLW  DE
09390:  MOVLB  6
09392:  MOVWF  xB4
09394:  MOVLW  04
09396:  ADDWFC 02,W
09398:  MOVWF  xB5
0939A:  MOVLW  01
0939C:  SUBWF  x9B,W
0939E:  MULLW  20
093A0:  MOVF   FF3,W
093A2:  CLRF   xB7
093A4:  MOVWF  xB6
093A6:  MOVLW  1C
093A8:  ADDWF  xB6,W
093AA:  MOVWF  01
093AC:  MOVLW  00
093AE:  ADDWFC xB7,W
093B0:  MOVWF  03
093B2:  MOVF   01,W
093B4:  ADDLW  20
093B6:  MOVWF  FE9
093B8:  MOVLW  00
093BA:  ADDWFC 03,W
093BC:  MOVWF  FEA
093BE:  MOVFF  FEF,6B6
093C2:  MOVFF  FEC,6B7
093C6:  MOVFF  FEC,6B8
093CA:  MOVFF  FEC,6B9
093CE:  MOVFF  6B5,583
093D2:  MOVFF  6B4,582
093D6:  MOVFF  69B,6C4
093DA:  MOVLW  18
093DC:  MOVWF  xC5
093DE:  MOVLB  0
093E0:  CALL   5FF0
093E4:  MOVLW  2C
093E6:  MOVLB  6
093E8:  MOVWF  xE0
093EA:  MOVLB  0
093EC:  CALL   5B38
093F0:  MOVLW  89
093F2:  MOVWF  FE9
093F4:  MOVFF  6B9,6D6
093F8:  MOVFF  6B8,6D5
093FC:  MOVFF  6B7,6D4
09400:  MOVFF  6B6,6D3
09404:  MOVLW  02
09406:  MOVLB  6
09408:  MOVWF  xD7
0940A:  MOVLB  0
0940C:  CALL   680C
09410:  MOVLW  2C
09412:  MOVLB  6
09414:  MOVWF  xE0
09416:  MOVLB  0
09418:  CALL   5B38
0941C:  BRA    9424
....................    else return INV_PARAM;
0941E:  MOVLW  02
09420:  MOVWF  01
09422:  BRA    9428
....................    
....................    return SUCCESS;
09424:  MOVLW  00
09426:  MOVWF  01
09428:  RETURN 0
.................... }
.................... 
.................... int8 getIPdata(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char *arg2;
....................    char *s_raw = "raw";
*
09548:  MOVLW  72
0954A:  MOVLB  6
0954C:  MOVWF  xA0
0954E:  MOVLW  61
09550:  MOVWF  xA1
09552:  MOVLW  77
09554:  MOVWF  xA2
09556:  CLRF   xA3
09558:  MOVLW  06
0955A:  MOVWF  x9F
0955C:  MOVLW  A0
0955E:  MOVWF  x9E
....................    char *s_calibrated = "calib";
09560:  MOVLW  63
09562:  MOVWF  xA6
09564:  MOVLW  61
09566:  MOVWF  xA7
09568:  MOVLW  6C
0956A:  MOVWF  xA8
0956C:  MOVLW  69
0956E:  MOVWF  xA9
09570:  MOVLW  62
09572:  MOVWF  xAA
09574:  CLRF   xAB
09576:  MOVLW  06
09578:  MOVWF  xA5
0957A:  MOVLW  A6
0957C:  MOVWF  xA4
....................    char *s_p0 = "p0";
0957E:  MOVLW  70
09580:  MOVWF  xAE
09582:  MOVLW  30
09584:  MOVWF  xAF
09586:  CLRF   xB0
09588:  MOVLW  06
0958A:  MOVWF  xAD
0958C:  MOVLW  AE
0958E:  MOVWF  xAC
....................    char *s_poles = "poles";
09590:  MOVLW  70
09592:  MOVWF  xB3
09594:  MOVLW  6F
09596:  MOVWF  xB4
09598:  MOVLW  6C
0959A:  MOVWF  xB5
0959C:  MOVLW  65
0959E:  MOVWF  xB6
095A0:  MOVLW  73
095A2:  MOVWF  xB7
095A4:  CLRF   xB8
095A6:  MOVLW  06
095A8:  MOVWF  xB2
095AA:  MOVLW  B3
095AC:  MOVWF  xB1
....................    char *s_real = "real";
095AE:  MOVLW  72
095B0:  MOVWF  xBB
095B2:  MOVLW  65
095B4:  MOVWF  xBC
095B6:  MOVLW  61
095B8:  MOVWF  xBD
095BA:  MOVLW  6C
095BC:  MOVWF  xBE
095BE:  CLRF   xBF
095C0:  MOVLW  06
095C2:  MOVWF  xBA
095C4:  MOVLW  BB
095C6:  MOVWF  xB9
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
095C8:  CLRF   xF2
095CA:  MOVFF  68F,6F1
095CE:  CLRF   xF4
095D0:  MOVLW  B5
095D2:  MOVWF  xF3
095D4:  MOVLB  0
095D6:  CALL   0C0C
095DA:  MOVFF  02,6C1
095DE:  MOVFF  01,6C0
095E2:  MOVLW  06
095E4:  MOVLB  6
095E6:  ADDWF  xC0,F
095E8:  MOVLW  00
095EA:  ADDWFC xC1,F
095EC:  MOVLW  32
095EE:  ADDWF  xC0,W
095F0:  MOVWF  01
095F2:  MOVLW  00
095F4:  ADDWFC xC1,W
095F6:  MOVWF  03
095F8:  MOVF   01,W
095FA:  ADDLW  08
095FC:  MOVWF  01
095FE:  MOVLW  02
09600:  ADDWFC 03,F
09602:  MOVFF  01,6C0
09606:  MOVFF  03,6C1
0960A:  MOVFF  03,6C4
0960E:  MOVFF  01,6C3
09612:  MOVLB  0
09614:  CALL   5C00
09618:  MOVF   01,F
0961A:  BNZ   9624
0961C:  MOVLW  02
0961E:  MOVWF  01
09620:  BRA    9C68
09622:  BRA    9682
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
09624:  MOVLB  6
09626:  CLRF   xF2
09628:  MOVFF  68F,6F1
0962C:  CLRF   xF4
0962E:  MOVLW  B5
09630:  MOVWF  xF3
09632:  MOVLB  0
09634:  CALL   0C0C
09638:  MOVFF  02,6C1
0963C:  MOVFF  01,6C0
09640:  MOVLW  06
09642:  MOVLB  6
09644:  ADDWF  xC0,F
09646:  MOVLW  00
09648:  ADDWFC xC1,F
0964A:  MOVLW  32
0964C:  ADDWF  xC0,W
0964E:  MOVWF  01
09650:  MOVLW  00
09652:  ADDWFC xC1,W
09654:  MOVWF  03
09656:  MOVF   01,W
09658:  ADDLW  08
0965A:  MOVWF  01
0965C:  MOVLW  02
0965E:  ADDWFC 03,F
09660:  MOVFF  01,6C0
09664:  MOVFF  03,6C1
09668:  MOVFF  03,6C4
0966C:  MOVFF  01,6C3
09670:  CLRF   xC6
09672:  CLRF   xC5
09674:  MOVLW  0A
09676:  MOVWF  xC7
09678:  MOVLB  0
0967A:  CALL   5C9A
0967E:  MOVFF  01,69B
....................    
....................    arg2 = SERcmd[rec].p[3];
09682:  MOVLB  6
09684:  CLRF   xF2
09686:  MOVFF  68F,6F1
0968A:  CLRF   xF4
0968C:  MOVLW  B5
0968E:  MOVWF  xF3
09690:  MOVLB  0
09692:  CALL   0C0C
09696:  MOVFF  02,6C1
0969A:  MOVFF  01,6C0
0969E:  MOVLW  06
096A0:  MOVLB  6
096A2:  ADDWF  xC0,F
096A4:  MOVLW  00
096A6:  ADDWFC xC1,F
096A8:  MOVLW  4B
096AA:  ADDWF  xC0,W
096AC:  MOVWF  01
096AE:  MOVLW  00
096B0:  ADDWFC xC1,W
096B2:  MOVWF  03
096B4:  MOVF   01,W
096B6:  ADDLW  08
096B8:  MOVWF  01
096BA:  MOVLW  02
096BC:  ADDWFC 03,F
096BE:  MOVFF  01,69C
096C2:  MOVFF  03,69D
....................    
....................    /*** GET INPUT DATA ****************/
....................    if      (0 == strcmp(s_raw, arg2)) {
096C6:  MOVFF  69F,6D2
096CA:  MOVFF  69E,6D1
096CE:  MOVFF  69D,6D4
096D2:  MOVFF  69C,6D3
096D6:  MOVLB  0
096D8:  CALL   5AC0
096DC:  MOVF   01,F
096DE:  BTFSS  FD8.2
096E0:  BRA    985C
....................       sprintf(retData+strlen(retData), "%d,", arg1);
096E2:  MOVLW  04
096E4:  MOVLB  6
096E6:  MOVWF  xD2
096E8:  MOVLW  DE
096EA:  MOVWF  xD1
096EC:  MOVLB  0
096EE:  CALL   5A88
096F2:  MOVFF  02,03
096F6:  MOVF   01,W
096F8:  ADDLW  DE
096FA:  MOVLB  6
096FC:  MOVWF  xC0
096FE:  MOVLW  04
09700:  ADDWFC 02,W
09702:  MOVWF  xC1
09704:  MOVFF  FE8,583
09708:  MOVFF  6C0,582
0970C:  MOVFF  69B,6C4
09710:  MOVLW  18
09712:  MOVWF  xC5
09714:  MOVLB  0
09716:  CALL   5FF0
0971A:  MOVLW  2C
0971C:  MOVLB  6
0971E:  MOVWF  xE0
09720:  MOVLB  0
09722:  CALL   5B38
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].sinRaw);
09726:  MOVLW  04
09728:  MOVLB  6
0972A:  MOVWF  xD2
0972C:  MOVLW  DE
0972E:  MOVWF  xD1
09730:  MOVLB  0
09732:  CALL   5A88
09736:  MOVFF  02,03
0973A:  MOVF   01,W
0973C:  ADDLW  DE
0973E:  MOVLB  6
09740:  MOVWF  xC0
09742:  MOVLW  04
09744:  ADDWFC 02,W
09746:  MOVWF  xC1
09748:  MOVLW  01
0974A:  SUBWF  x9B,W
0974C:  MULLW  21
0974E:  MOVF   FF3,W
09750:  CLRF   xC3
09752:  MOVWF  xC2
09754:  MOVLW  0F
09756:  ADDWF  xC2,W
09758:  MOVWF  FE9
0975A:  MOVLW  01
0975C:  ADDWFC xC3,W
0975E:  MOVWF  FEA
09760:  MOVFF  FEF,6E0
09764:  MOVFF  FEC,01
09768:  MOVFF  FEC,02
0976C:  MOVFF  FEC,03
09770:  MOVFF  03,6E3
09774:  MOVFF  02,6E2
09778:  MOVFF  01,6E1
0977C:  MOVLB  0
0977E:  CALL   56A6
09782:  MOVFF  03,6C7
09786:  MOVFF  02,6C6
0978A:  MOVFF  01,6C5
0978E:  MOVFF  00,6C4
09792:  MOVFF  6C1,583
09796:  MOVFF  6C0,582
0979A:  MOVLW  41
0979C:  MOVWF  FE9
0979E:  MOVFF  03,6CC
097A2:  MOVFF  02,6CB
097A6:  MOVFF  01,6CA
097AA:  MOVFF  00,6C9
097AE:  RCALL  942A
097B0:  MOVLW  2C
097B2:  MOVLB  6
097B4:  MOVWF  xE0
097B6:  MOVLB  0
097B8:  CALL   5B38
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].cosRaw);
097BC:  MOVLW  04
097BE:  MOVLB  6
097C0:  MOVWF  xD2
097C2:  MOVLW  DE
097C4:  MOVWF  xD1
097C6:  MOVLB  0
097C8:  CALL   5A88
097CC:  MOVF   01,W
097CE:  ADDLW  DE
097D0:  MOVLB  6
097D2:  MOVWF  xC0
097D4:  MOVLW  04
097D6:  ADDWFC 02,W
097D8:  MOVWF  xC1
097DA:  MOVLW  01
097DC:  SUBWF  x9B,W
097DE:  MULLW  21
097E0:  MOVF   FF3,W
097E2:  CLRF   xC3
097E4:  MOVWF  xC2
097E6:  MOVLW  04
097E8:  ADDWF  xC2,W
097EA:  MOVWF  01
097EC:  MOVLW  00
097EE:  ADDWFC xC3,W
097F0:  MOVWF  03
097F2:  MOVF   01,W
097F4:  ADDLW  0F
097F6:  MOVWF  FE9
097F8:  MOVLW  01
097FA:  ADDWFC 03,W
097FC:  MOVWF  FEA
097FE:  MOVFF  FEF,6E0
09802:  MOVFF  FEC,01
09806:  MOVFF  FEC,02
0980A:  MOVFF  FEC,03
0980E:  MOVFF  03,6E3
09812:  MOVFF  02,6E2
09816:  MOVFF  01,6E1
0981A:  MOVLB  0
0981C:  CALL   56A6
09820:  MOVFF  03,6C5
09824:  MOVFF  02,6C4
09828:  MOVFF  01,6C3
0982C:  MOVFF  00,6C2
09830:  MOVFF  6C1,583
09834:  MOVFF  6C0,582
09838:  MOVLW  41
0983A:  MOVWF  FE9
0983C:  MOVFF  03,6CC
09840:  MOVFF  02,6CB
09844:  MOVFF  01,6CA
09848:  MOVFF  00,6C9
0984C:  RCALL  942A
0984E:  MOVLW  2C
09850:  MOVLB  6
09852:  MOVWF  xE0
09854:  MOVLB  0
09856:  CALL   5B38
....................    }
0985A:  BRA    9C64
....................    else if (0 == strcmp(s_calibrated, arg2)) {
0985C:  MOVFF  6A5,6D2
09860:  MOVFF  6A4,6D1
09864:  MOVFF  69D,6D4
09868:  MOVFF  69C,6D3
0986C:  CALL   5AC0
09870:  MOVF   01,F
09872:  BTFSS  FD8.2
09874:  BRA    99F8
....................       sprintf(retData+strlen(retData), "%d,", arg1);
09876:  MOVLW  04
09878:  MOVLB  6
0987A:  MOVWF  xD2
0987C:  MOVLW  DE
0987E:  MOVWF  xD1
09880:  MOVLB  0
09882:  CALL   5A88
09886:  MOVFF  02,03
0988A:  MOVF   01,W
0988C:  ADDLW  DE
0988E:  MOVLB  6
09890:  MOVWF  xC0
09892:  MOVLW  04
09894:  ADDWFC 02,W
09896:  MOVWF  xC1
09898:  MOVFF  FE8,583
0989C:  MOVFF  6C0,582
098A0:  MOVFF  69B,6C4
098A4:  MOVLW  18
098A6:  MOVWF  xC5
098A8:  MOVLB  0
098AA:  CALL   5FF0
098AE:  MOVLW  2C
098B0:  MOVLB  6
098B2:  MOVWF  xE0
098B4:  MOVLB  0
098B6:  CALL   5B38
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].sinCounts);
098BA:  MOVLW  04
098BC:  MOVLB  6
098BE:  MOVWF  xD2
098C0:  MOVLW  DE
098C2:  MOVWF  xD1
098C4:  MOVLB  0
098C6:  CALL   5A88
098CA:  MOVF   01,W
098CC:  ADDLW  DE
098CE:  MOVLB  6
098D0:  MOVWF  xC0
098D2:  MOVLW  04
098D4:  ADDWFC 02,W
098D6:  MOVWF  xC1
098D8:  MOVLW  01
098DA:  SUBWF  x9B,W
098DC:  MULLW  21
098DE:  MOVF   FF3,W
098E0:  CLRF   xC3
098E2:  MOVWF  xC2
098E4:  MOVLW  08
098E6:  ADDWF  xC2,W
098E8:  MOVWF  01
098EA:  MOVLW  00
098EC:  ADDWFC xC3,W
098EE:  MOVWF  03
098F0:  MOVF   01,W
098F2:  ADDLW  0F
098F4:  MOVWF  FE9
098F6:  MOVLW  01
098F8:  ADDWFC 03,W
098FA:  MOVWF  FEA
098FC:  MOVFF  FEF,6E0
09900:  MOVFF  FEC,01
09904:  MOVFF  FEC,02
09908:  MOVFF  FEC,03
0990C:  MOVFF  03,6E3
09910:  MOVFF  02,6E2
09914:  MOVFF  01,6E1
09918:  MOVLB  0
0991A:  CALL   56A6
0991E:  MOVFF  03,6C5
09922:  MOVFF  02,6C4
09926:  MOVFF  01,6C3
0992A:  MOVFF  00,6C2
0992E:  MOVFF  6C1,583
09932:  MOVFF  6C0,582
09936:  MOVLW  41
09938:  MOVWF  FE9
0993A:  MOVFF  03,6CC
0993E:  MOVFF  02,6CB
09942:  MOVFF  01,6CA
09946:  MOVFF  00,6C9
0994A:  RCALL  942A
0994C:  MOVLW  2C
0994E:  MOVLB  6
09950:  MOVWF  xE0
09952:  MOVLB  0
09954:  CALL   5B38
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].cosCounts);
09958:  MOVLW  04
0995A:  MOVLB  6
0995C:  MOVWF  xD2
0995E:  MOVLW  DE
09960:  MOVWF  xD1
09962:  MOVLB  0
09964:  CALL   5A88
09968:  MOVF   01,W
0996A:  ADDLW  DE
0996C:  MOVLB  6
0996E:  MOVWF  xC0
09970:  MOVLW  04
09972:  ADDWFC 02,W
09974:  MOVWF  xC1
09976:  MOVLW  01
09978:  SUBWF  x9B,W
0997A:  MULLW  21
0997C:  MOVF   FF3,W
0997E:  CLRF   xC3
09980:  MOVWF  xC2
09982:  MOVLW  0C
09984:  ADDWF  xC2,W
09986:  MOVWF  01
09988:  MOVLW  00
0998A:  ADDWFC xC3,W
0998C:  MOVWF  03
0998E:  MOVF   01,W
09990:  ADDLW  0F
09992:  MOVWF  FE9
09994:  MOVLW  01
09996:  ADDWFC 03,W
09998:  MOVWF  FEA
0999A:  MOVFF  FEF,6E0
0999E:  MOVFF  FEC,01
099A2:  MOVFF  FEC,02
099A6:  MOVFF  FEC,03
099AA:  MOVFF  03,6E3
099AE:  MOVFF  02,6E2
099B2:  MOVFF  01,6E1
099B6:  MOVLB  0
099B8:  CALL   56A6
099BC:  MOVFF  03,6C5
099C0:  MOVFF  02,6C4
099C4:  MOVFF  01,6C3
099C8:  MOVFF  00,6C2
099CC:  MOVFF  6C1,583
099D0:  MOVFF  6C0,582
099D4:  MOVLW  41
099D6:  MOVWF  FE9
099D8:  MOVFF  03,6CC
099DC:  MOVFF  02,6CB
099E0:  MOVFF  01,6CA
099E4:  MOVFF  00,6C9
099E8:  RCALL  942A
099EA:  MOVLW  2C
099EC:  MOVLB  6
099EE:  MOVWF  xE0
099F0:  MOVLB  0
099F2:  CALL   5B38
....................    }
099F6:  BRA    9C64
....................    else if (0 == strcmp(s_p0, arg2)) {
099F8:  MOVFF  6AD,6D2
099FC:  MOVFF  6AC,6D1
09A00:  MOVFF  69D,6D4
09A04:  MOVFF  69C,6D3
09A08:  CALL   5AC0
09A0C:  MOVF   01,F
09A0E:  BNZ   9ACA
....................       sprintf(retData+strlen(retData), "%d,", arg1);
09A10:  MOVLW  04
09A12:  MOVLB  6
09A14:  MOVWF  xD2
09A16:  MOVLW  DE
09A18:  MOVWF  xD1
09A1A:  MOVLB  0
09A1C:  CALL   5A88
09A20:  MOVFF  02,03
09A24:  MOVF   01,W
09A26:  ADDLW  DE
09A28:  MOVLB  6
09A2A:  MOVWF  xC0
09A2C:  MOVLW  04
09A2E:  ADDWFC 02,W
09A30:  MOVWF  xC1
09A32:  MOVFF  FE8,583
09A36:  MOVFF  6C0,582
09A3A:  MOVFF  69B,6C4
09A3E:  MOVLW  18
09A40:  MOVWF  xC5
09A42:  MOVLB  0
09A44:  CALL   5FF0
09A48:  MOVLW  2C
09A4A:  MOVLB  6
09A4C:  MOVWF  xE0
09A4E:  MOVLB  0
09A50:  CALL   5B38
....................       sprintf(retData+strlen(retData), "%f,", adcVals[arg1-1].p0);
09A54:  MOVLW  04
09A56:  MOVLB  6
09A58:  MOVWF  xD2
09A5A:  MOVLW  DE
09A5C:  MOVWF  xD1
09A5E:  MOVLB  0
09A60:  CALL   5A88
09A64:  MOVF   01,W
09A66:  ADDLW  DE
09A68:  MOVLB  6
09A6A:  MOVWF  xC0
09A6C:  MOVLW  04
09A6E:  ADDWFC 02,W
09A70:  MOVWF  xC1
09A72:  MOVLW  01
09A74:  SUBWF  x9B,W
09A76:  MULLW  21
09A78:  MOVF   FF3,W
09A7A:  CLRF   xC3
09A7C:  MOVWF  xC2
09A7E:  MOVLW  18
09A80:  ADDWF  xC2,W
09A82:  MOVWF  01
09A84:  MOVLW  00
09A86:  ADDWFC xC3,W
09A88:  MOVWF  03
09A8A:  MOVF   01,W
09A8C:  ADDLW  0F
09A8E:  MOVWF  FE9
09A90:  MOVLW  01
09A92:  ADDWFC 03,W
09A94:  MOVWF  FEA
09A96:  MOVFF  FEF,6D3
09A9A:  MOVFF  FEC,6D4
09A9E:  MOVFF  FEC,6D5
09AA2:  MOVFF  FEC,6D6
09AA6:  MOVFF  6C1,583
09AAA:  MOVFF  6C0,582
09AAE:  MOVLW  89
09AB0:  MOVWF  FE9
09AB2:  MOVLW  02
09AB4:  MOVWF  xD7
09AB6:  MOVLB  0
09AB8:  CALL   680C
09ABC:  MOVLW  2C
09ABE:  MOVLB  6
09AC0:  MOVWF  xE0
09AC2:  MOVLB  0
09AC4:  CALL   5B38
....................    }
09AC8:  BRA    9C64
....................    else if (0 == strcmp(s_poles, arg2)) {
09ACA:  MOVFF  6B2,6D2
09ACE:  MOVFF  6B1,6D1
09AD2:  MOVFF  69D,6D4
09AD6:  MOVFF  69C,6D3
09ADA:  CALL   5AC0
09ADE:  MOVF   01,F
09AE0:  BNZ   9B8C
....................       sprintf(retData+strlen(retData), "%d,", arg1);
09AE2:  MOVLW  04
09AE4:  MOVLB  6
09AE6:  MOVWF  xD2
09AE8:  MOVLW  DE
09AEA:  MOVWF  xD1
09AEC:  MOVLB  0
09AEE:  CALL   5A88
09AF2:  MOVFF  02,03
09AF6:  MOVF   01,W
09AF8:  ADDLW  DE
09AFA:  MOVLB  6
09AFC:  MOVWF  xC0
09AFE:  MOVLW  04
09B00:  ADDWFC 02,W
09B02:  MOVWF  xC1
09B04:  MOVFF  FE8,583
09B08:  MOVFF  6C0,582
09B0C:  MOVFF  69B,6C4
09B10:  MOVLW  18
09B12:  MOVWF  xC5
09B14:  MOVLB  0
09B16:  CALL   5FF0
09B1A:  MOVLW  2C
09B1C:  MOVLB  6
09B1E:  MOVWF  xE0
09B20:  MOVLB  0
09B22:  CALL   5B38
....................       sprintf(retData+strlen(retData), "%d,", adcVals[arg1-1].npoles);
09B26:  MOVLW  04
09B28:  MOVLB  6
09B2A:  MOVWF  xD2
09B2C:  MOVLW  DE
09B2E:  MOVWF  xD1
09B30:  MOVLB  0
09B32:  CALL   5A88
09B36:  MOVF   01,W
09B38:  ADDLW  DE
09B3A:  MOVLB  6
09B3C:  MOVWF  xC0
09B3E:  MOVLW  04
09B40:  ADDWFC 02,W
09B42:  MOVWF  xC1
09B44:  MOVLW  01
09B46:  SUBWF  x9B,W
09B48:  MULLW  21
09B4A:  MOVF   FF3,W
09B4C:  CLRF   xC3
09B4E:  MOVWF  xC2
09B50:  MOVLW  1C
09B52:  ADDWF  xC2,W
09B54:  MOVWF  01
09B56:  MOVLW  00
09B58:  ADDWFC xC3,W
09B5A:  MOVWF  03
09B5C:  MOVF   01,W
09B5E:  ADDLW  0F
09B60:  MOVWF  FE9
09B62:  MOVLW  01
09B64:  ADDWFC 03,W
09B66:  MOVWF  FEA
09B68:  MOVFF  FEF,6C4
09B6C:  MOVFF  6C1,583
09B70:  MOVFF  6C0,582
09B74:  MOVLW  18
09B76:  MOVWF  xC5
09B78:  MOVLB  0
09B7A:  CALL   5FF0
09B7E:  MOVLW  2C
09B80:  MOVLB  6
09B82:  MOVWF  xE0
09B84:  MOVLB  0
09B86:  CALL   5B38
....................    }
09B8A:  BRA    9C64
....................    else if (0 == strcmp(s_real, arg2)) {
09B8C:  MOVFF  6BA,6D2
09B90:  MOVFF  6B9,6D1
09B94:  MOVFF  69D,6D4
09B98:  MOVFF  69C,6D3
09B9C:  CALL   5AC0
09BA0:  MOVF   01,F
09BA2:  BNZ   9C5E
....................       sprintf(retData+strlen(retData), "%d,", arg1);
09BA4:  MOVLW  04
09BA6:  MOVLB  6
09BA8:  MOVWF  xD2
09BAA:  MOVLW  DE
09BAC:  MOVWF  xD1
09BAE:  MOVLB  0
09BB0:  CALL   5A88
09BB4:  MOVFF  02,03
09BB8:  MOVF   01,W
09BBA:  ADDLW  DE
09BBC:  MOVLB  6
09BBE:  MOVWF  xC0
09BC0:  MOVLW  04
09BC2:  ADDWFC 02,W
09BC4:  MOVWF  xC1
09BC6:  MOVFF  FE8,583
09BCA:  MOVFF  6C0,582
09BCE:  MOVFF  69B,6C4
09BD2:  MOVLW  18
09BD4:  MOVWF  xC5
09BD6:  MOVLB  0
09BD8:  CALL   5FF0
09BDC:  MOVLW  2C
09BDE:  MOVLB  6
09BE0:  MOVWF  xE0
09BE2:  MOVLB  0
09BE4:  CALL   5B38
....................       sprintf(retData+strlen(retData), "%f,", adcVals[arg1-1].pReal);
09BE8:  MOVLW  04
09BEA:  MOVLB  6
09BEC:  MOVWF  xD2
09BEE:  MOVLW  DE
09BF0:  MOVWF  xD1
09BF2:  MOVLB  0
09BF4:  CALL   5A88
09BF8:  MOVF   01,W
09BFA:  ADDLW  DE
09BFC:  MOVLB  6
09BFE:  MOVWF  xC0
09C00:  MOVLW  04
09C02:  ADDWFC 02,W
09C04:  MOVWF  xC1
09C06:  MOVLW  01
09C08:  SUBWF  x9B,W
09C0A:  MULLW  21
09C0C:  MOVF   FF3,W
09C0E:  CLRF   xC3
09C10:  MOVWF  xC2
09C12:  MOVLW  1D
09C14:  ADDWF  xC2,W
09C16:  MOVWF  01
09C18:  MOVLW  00
09C1A:  ADDWFC xC3,W
09C1C:  MOVWF  03
09C1E:  MOVF   01,W
09C20:  ADDLW  0F
09C22:  MOVWF  FE9
09C24:  MOVLW  01
09C26:  ADDWFC 03,W
09C28:  MOVWF  FEA
09C2A:  MOVFF  FEF,6D3
09C2E:  MOVFF  FEC,6D4
09C32:  MOVFF  FEC,6D5
09C36:  MOVFF  FEC,6D6
09C3A:  MOVFF  6C1,583
09C3E:  MOVFF  6C0,582
09C42:  MOVLW  89
09C44:  MOVWF  FE9
09C46:  MOVLW  02
09C48:  MOVWF  xD7
09C4A:  MOVLB  0
09C4C:  CALL   680C
09C50:  MOVLW  2C
09C52:  MOVLB  6
09C54:  MOVWF  xE0
09C56:  MOVLB  0
09C58:  CALL   5B38
....................    }
09C5C:  BRA    9C64
....................    else return INV_PARAM;
09C5E:  MOVLW  02
09C60:  MOVWF  01
09C62:  BRA    9C68
....................    
....................    return SUCCESS;
09C64:  MOVLW  00
09C66:  MOVWF  01
09C68:  RETURN 0
.................... }
.................... 
.................... int8 getManOPvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
09C6A:  MOVLB  6
09C6C:  CLRF   xF2
09C6E:  MOVFF  68F,6F1
09C72:  CLRF   xF4
09C74:  MOVLW  B5
09C76:  MOVWF  xF3
09C78:  MOVLB  0
09C7A:  CALL   0C0C
09C7E:  MOVFF  02,69D
09C82:  MOVFF  01,69C
09C86:  MOVLW  06
09C88:  MOVLB  6
09C8A:  ADDWF  x9C,F
09C8C:  MOVLW  00
09C8E:  ADDWFC x9D,F
09C90:  MOVLW  32
09C92:  ADDWF  x9C,W
09C94:  MOVWF  01
09C96:  MOVLW  00
09C98:  ADDWFC x9D,W
09C9A:  MOVWF  03
09C9C:  MOVF   01,W
09C9E:  ADDLW  08
09CA0:  MOVWF  01
09CA2:  MOVLW  02
09CA4:  ADDWFC 03,F
09CA6:  MOVFF  01,69C
09CAA:  MOVFF  03,69D
09CAE:  MOVFF  03,6C4
09CB2:  MOVFF  01,6C3
09CB6:  MOVLB  0
09CB8:  CALL   5C00
09CBC:  MOVF   01,F
09CBE:  BNZ   9CC8
09CC0:  MOVLW  02
09CC2:  MOVWF  01
09CC4:  BRA    9DBA
09CC6:  BRA    9D26
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
09CC8:  MOVLB  6
09CCA:  CLRF   xF2
09CCC:  MOVFF  68F,6F1
09CD0:  CLRF   xF4
09CD2:  MOVLW  B5
09CD4:  MOVWF  xF3
09CD6:  MOVLB  0
09CD8:  CALL   0C0C
09CDC:  MOVFF  02,69D
09CE0:  MOVFF  01,69C
09CE4:  MOVLW  06
09CE6:  MOVLB  6
09CE8:  ADDWF  x9C,F
09CEA:  MOVLW  00
09CEC:  ADDWFC x9D,F
09CEE:  MOVLW  32
09CF0:  ADDWF  x9C,W
09CF2:  MOVWF  01
09CF4:  MOVLW  00
09CF6:  ADDWFC x9D,W
09CF8:  MOVWF  03
09CFA:  MOVF   01,W
09CFC:  ADDLW  08
09CFE:  MOVWF  01
09D00:  MOVLW  02
09D02:  ADDWFC 03,F
09D04:  MOVFF  01,69C
09D08:  MOVFF  03,69D
09D0C:  MOVFF  03,6C4
09D10:  MOVFF  01,6C3
09D14:  CLRF   xC6
09D16:  CLRF   xC5
09D18:  MOVLW  0A
09D1A:  MOVWF  xC7
09D1C:  MOVLB  0
09D1E:  CALL   5C9A
09D22:  MOVFF  01,69B
....................    
....................    /*** GET MANUAL OUTPUT VALUE ***************/ 
....................    sprintf(retData+strlen(retData), "%d,%f,", arg1, manualOutputValues[arg1-1]);
09D26:  MOVLW  04
09D28:  MOVLB  6
09D2A:  MOVWF  xD2
09D2C:  MOVLW  DE
09D2E:  MOVWF  xD1
09D30:  MOVLB  0
09D32:  CALL   5A88
09D36:  MOVF   01,W
09D38:  ADDLW  DE
09D3A:  MOVLB  6
09D3C:  MOVWF  x9C
09D3E:  MOVLW  04
09D40:  ADDWFC 02,W
09D42:  MOVWF  x9D
09D44:  MOVLW  01
09D46:  SUBWF  x9B,W
09D48:  MULLW  04
09D4A:  MOVF   FF3,W
09D4C:  CLRF   03
09D4E:  ADDLW  EA
09D50:  MOVWF  FE9
09D52:  MOVLW  00
09D54:  ADDWFC 03,W
09D56:  MOVWF  FEA
09D58:  MOVFF  FEF,69E
09D5C:  MOVFF  FEC,69F
09D60:  MOVFF  FEC,6A0
09D64:  MOVFF  FEC,6A1
09D68:  MOVFF  69D,583
09D6C:  MOVFF  69C,582
09D70:  MOVFF  69B,6C4
09D74:  MOVLW  18
09D76:  MOVWF  xC5
09D78:  MOVLB  0
09D7A:  CALL   5FF0
09D7E:  MOVLW  2C
09D80:  MOVLB  6
09D82:  MOVWF  xE0
09D84:  MOVLB  0
09D86:  CALL   5B38
09D8A:  MOVLW  89
09D8C:  MOVWF  FE9
09D8E:  MOVFF  6A1,6D6
09D92:  MOVFF  6A0,6D5
09D96:  MOVFF  69F,6D4
09D9A:  MOVFF  69E,6D3
09D9E:  MOVLW  02
09DA0:  MOVLB  6
09DA2:  MOVWF  xD7
09DA4:  MOVLB  0
09DA6:  CALL   680C
09DAA:  MOVLW  2C
09DAC:  MOVLB  6
09DAE:  MOVWF  xE0
09DB0:  MOVLB  0
09DB2:  CALL   5B38
....................    
....................    return SUCCESS;
09DB6:  MOVLW  00
09DB8:  MOVWF  01
09DBA:  RETURN 0
.................... }
.................... 
.................... int8 setManOPvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    float arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
09DBC:  MOVLB  6
09DBE:  CLRF   xF2
09DC0:  MOVFF  68F,6F1
09DC4:  CLRF   xF4
09DC6:  MOVLW  B5
09DC8:  MOVWF  xF3
09DCA:  MOVLB  0
09DCC:  CALL   0C0C
09DD0:  MOVFF  02,6A1
09DD4:  MOVFF  01,6A0
09DD8:  MOVLW  06
09DDA:  MOVLB  6
09DDC:  ADDWF  xA0,F
09DDE:  MOVLW  00
09DE0:  ADDWFC xA1,F
09DE2:  MOVLW  32
09DE4:  ADDWF  xA0,W
09DE6:  MOVWF  01
09DE8:  MOVLW  00
09DEA:  ADDWFC xA1,W
09DEC:  MOVWF  03
09DEE:  MOVF   01,W
09DF0:  ADDLW  08
09DF2:  MOVWF  01
09DF4:  MOVLW  02
09DF6:  ADDWFC 03,F
09DF8:  MOVFF  01,6A0
09DFC:  MOVFF  03,6A1
09E00:  MOVFF  03,6C4
09E04:  MOVFF  01,6C3
09E08:  MOVLB  0
09E0A:  CALL   5C00
09E0E:  MOVF   01,F
09E10:  BNZ   9E1A
09E12:  MOVLW  02
09E14:  MOVWF  01
09E16:  BRA    9FFC
09E18:  BRA    9E78
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
09E1A:  MOVLB  6
09E1C:  CLRF   xF2
09E1E:  MOVFF  68F,6F1
09E22:  CLRF   xF4
09E24:  MOVLW  B5
09E26:  MOVWF  xF3
09E28:  MOVLB  0
09E2A:  CALL   0C0C
09E2E:  MOVFF  02,6A1
09E32:  MOVFF  01,6A0
09E36:  MOVLW  06
09E38:  MOVLB  6
09E3A:  ADDWF  xA0,F
09E3C:  MOVLW  00
09E3E:  ADDWFC xA1,F
09E40:  MOVLW  32
09E42:  ADDWF  xA0,W
09E44:  MOVWF  01
09E46:  MOVLW  00
09E48:  ADDWFC xA1,W
09E4A:  MOVWF  03
09E4C:  MOVF   01,W
09E4E:  ADDLW  08
09E50:  MOVWF  01
09E52:  MOVLW  02
09E54:  ADDWFC 03,F
09E56:  MOVFF  01,6A0
09E5A:  MOVFF  03,6A1
09E5E:  MOVFF  03,6C4
09E62:  MOVFF  01,6C3
09E66:  CLRF   xC6
09E68:  CLRF   xC5
09E6A:  MOVLW  0A
09E6C:  MOVWF  xC7
09E6E:  MOVLB  0
09E70:  CALL   5C9A
09E74:  MOVFF  01,69B
....................    
....................    if (!arg_is_float(SERcmd[rec].p[3])) return INV_PARAM;
09E78:  MOVLB  6
09E7A:  CLRF   xF2
09E7C:  MOVFF  68F,6F1
09E80:  CLRF   xF4
09E82:  MOVLW  B5
09E84:  MOVWF  xF3
09E86:  MOVLB  0
09E88:  CALL   0C0C
09E8C:  MOVFF  02,6A1
09E90:  MOVFF  01,6A0
09E94:  MOVLW  06
09E96:  MOVLB  6
09E98:  ADDWF  xA0,F
09E9A:  MOVLW  00
09E9C:  ADDWFC xA1,F
09E9E:  MOVLW  4B
09EA0:  ADDWF  xA0,W
09EA2:  MOVWF  01
09EA4:  MOVLW  00
09EA6:  ADDWFC xA1,W
09EA8:  MOVWF  03
09EAA:  MOVF   01,W
09EAC:  ADDLW  08
09EAE:  MOVWF  01
09EB0:  MOVLW  02
09EB2:  ADDWFC 03,F
09EB4:  MOVFF  01,6A0
09EB8:  MOVFF  03,6A1
09EBC:  MOVFF  03,6A5
09EC0:  MOVFF  01,6A4
09EC4:  MOVLB  0
09EC6:  CALL   6E78
09ECA:  MOVF   01,F
09ECC:  BNZ   9ED6
09ECE:  MOVLW  02
09ED0:  MOVWF  01
09ED2:  BRA    9FFC
09ED4:  BRA    9F3C
....................    else arg2 = strtod(SERcmd[rec].p[3], '\0');
09ED6:  MOVLB  6
09ED8:  CLRF   xF2
09EDA:  MOVFF  68F,6F1
09EDE:  CLRF   xF4
09EE0:  MOVLW  B5
09EE2:  MOVWF  xF3
09EE4:  MOVLB  0
09EE6:  CALL   0C0C
09EEA:  MOVFF  02,6A1
09EEE:  MOVFF  01,6A0
09EF2:  MOVLW  06
09EF4:  MOVLB  6
09EF6:  ADDWF  xA0,F
09EF8:  MOVLW  00
09EFA:  ADDWFC xA1,F
09EFC:  MOVLW  4B
09EFE:  ADDWF  xA0,W
09F00:  MOVWF  01
09F02:  MOVLW  00
09F04:  ADDWFC xA1,W
09F06:  MOVWF  03
09F08:  MOVF   01,W
09F0A:  ADDLW  08
09F0C:  MOVWF  01
09F0E:  MOVLW  02
09F10:  ADDWFC 03,F
09F12:  MOVFF  01,6A0
09F16:  MOVFF  03,6A1
09F1A:  MOVFF  03,6A5
09F1E:  MOVFF  01,6A4
09F22:  CLRF   xA7
09F24:  CLRF   xA6
09F26:  MOVLB  0
09F28:  CALL   6F3A
09F2C:  MOVFF  03,69F
09F30:  MOVFF  02,69E
09F34:  MOVFF  01,69D
09F38:  MOVFF  00,69C
....................    
....................    /*** SET MANUAL OUTPUT VALUE ***************/
....................    if (arg2 > op_upper_bound) manualOutputValues[arg1-1] = op_upper_bound;
09F3C:  MOVLB  6
09F3E:  CLRF   xDE
09F40:  CLRF   xDD
09F42:  MOVLW  7C
09F44:  MOVWF  xDC
09F46:  MOVLW  84
09F48:  MOVWF  xDB
09F4A:  MOVFF  69F,6E2
09F4E:  MOVFF  69E,6E1
09F52:  MOVFF  69D,6E0
09F56:  MOVFF  69C,6DF
09F5A:  MOVLB  0
09F5C:  CALL   1E18
09F60:  BNC   9F86
09F62:  MOVLW  01
09F64:  MOVLB  6
09F66:  SUBWF  x9B,W
09F68:  MULLW  04
09F6A:  MOVF   FF3,W
09F6C:  CLRF   03
09F6E:  ADDLW  EA
09F70:  MOVWF  FE9
09F72:  MOVLW  00
09F74:  ADDWFC 03,W
09F76:  MOVWF  FEA
09F78:  MOVLW  84
09F7A:  MOVWF  FEF
09F7C:  MOVLW  7C
09F7E:  MOVWF  FEC
09F80:  CLRF   FEC
09F82:  CLRF   FEC
09F84:  BRA    9FF6
....................    else if (arg2 < op_lower_bound) manualOutputValues[arg1-1] = op_lower_bound;  
09F86:  MOVFF  69F,6DE
09F8A:  MOVFF  69E,6DD
09F8E:  MOVFF  69D,6DC
09F92:  MOVFF  69C,6DB
09F96:  MOVLB  6
09F98:  CLRF   xE2
09F9A:  CLRF   xE1
09F9C:  MOVLW  FC
09F9E:  MOVWF  xE0
09FA0:  MOVLW  84
09FA2:  MOVWF  xDF
09FA4:  MOVLB  0
09FA6:  CALL   1E18
09FAA:  BNC   9FD0
09FAC:  MOVLW  01
09FAE:  MOVLB  6
09FB0:  SUBWF  x9B,W
09FB2:  MULLW  04
09FB4:  MOVF   FF3,W
09FB6:  CLRF   03
09FB8:  ADDLW  EA
09FBA:  MOVWF  FE9
09FBC:  MOVLW  00
09FBE:  ADDWFC 03,W
09FC0:  MOVWF  FEA
09FC2:  MOVLW  84
09FC4:  MOVWF  FEF
09FC6:  MOVLW  FC
09FC8:  MOVWF  FEC
09FCA:  CLRF   FEC
09FCC:  CLRF   FEC
09FCE:  BRA    9FF6
....................    else manualOutputValues[arg1-1] = arg2;
09FD0:  MOVLW  01
09FD2:  MOVLB  6
09FD4:  SUBWF  x9B,W
09FD6:  MULLW  04
09FD8:  MOVF   FF3,W
09FDA:  CLRF   03
09FDC:  ADDLW  EA
09FDE:  MOVWF  FE9
09FE0:  MOVLW  00
09FE2:  ADDWFC 03,W
09FE4:  MOVWF  FEA
09FE6:  MOVFF  69C,FEF
09FEA:  MOVFF  69D,FEC
09FEE:  MOVFF  69E,FEC
09FF2:  MOVFF  69F,FEC
....................    
....................    return SUCCESS;
09FF6:  MOVLW  00
09FF8:  MOVWF  01
09FFA:  MOVLB  0
09FFC:  RETURN 0
.................... }
.................... 
.................... int8 invalidCmd(unsigned int8 rec){
....................    return INV_CMD;
09FFE:  MOVLW  01
0A000:  MOVWF  01
0A002:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* ARG VALIDATION HELPER FUNCS                                               */
.................... /*****************************************************************************/
.................... BOOLEAN arg_is_float(char *arg){
*
06E78:  MOVLB  6
06E7A:  BCF    xA6.0
....................    BOOLEAN decimal = FALSE;
....................    for (int i=0; i<strlen(arg); i++){
06E7C:  CLRF   xA7
06E7E:  MOVFF  6A5,6D2
06E82:  MOVFF  6A4,6D1
06E86:  MOVLB  0
06E88:  CALL   5A88
06E8C:  MOVFF  02,03
06E90:  MOVF   01,W
06E92:  MOVF   03,F
06E94:  BNZ   6EA0
06E96:  MOVF   01,W
06E98:  MOVLB  6
06E9A:  SUBWF  xA7,W
06E9C:  BC    6F32
06E9E:  MOVLB  0
....................       if (!isdigit(arg[i])){
06EA0:  MOVLB  6
06EA2:  MOVF   xA7,W
06EA4:  ADDWF  xA4,W
06EA6:  MOVWF  FE9
06EA8:  MOVLW  00
06EAA:  ADDWFC xA5,W
06EAC:  MOVWF  FEA
06EAE:  MOVFF  FEF,6A8
06EB2:  MOVF   xA8,W
06EB4:  SUBLW  2F
06EB6:  BC    6EBE
06EB8:  MOVF   xA8,W
06EBA:  SUBLW  39
06EBC:  BC    6F2A
....................          // Check for negative sign
....................          if ('-' != arg[i]){
06EBE:  MOVF   xA7,W
06EC0:  ADDWF  xA4,W
06EC2:  MOVWF  FE9
06EC4:  MOVLW  00
06EC6:  ADDWFC xA5,W
06EC8:  MOVWF  FEA
06ECA:  MOVF   FEF,W
06ECC:  SUBLW  2D
06ECE:  BZ    6EFA
....................             // Check for decimal
....................             if ('.' != arg[i]) return FALSE;
06ED0:  MOVF   xA7,W
06ED2:  ADDWF  xA4,W
06ED4:  MOVWF  FE9
06ED6:  MOVLW  00
06ED8:  ADDWFC xA5,W
06EDA:  MOVWF  FEA
06EDC:  MOVF   FEF,W
06EDE:  SUBLW  2E
06EE0:  BZ    6EEA
06EE2:  MOVLW  00
06EE4:  MOVWF  01
06EE6:  BRA    6F36
06EE8:  BRA    6EF8
....................             else if  (decimal) return FALSE;
06EEA:  BTFSS  xA6.0
06EEC:  BRA    6EF6
06EEE:  MOVLW  00
06EF0:  MOVWF  01
06EF2:  BRA    6F36
06EF4:  BRA    6EF8
....................             else decimal = TRUE;
06EF6:  BSF    xA6.0
....................          }
06EF8:  BRA    6F2A
....................          else if (0 != i) return FALSE;
06EFA:  MOVF   xA7,F
06EFC:  BZ    6F06
06EFE:  MOVLW  00
06F00:  MOVWF  01
06F02:  BRA    6F36
06F04:  BRA    6F2A
....................          else if (1 == strlen(arg)) return FALSE;
06F06:  MOVFF  6A5,6D2
06F0A:  MOVFF  6A4,6D1
06F0E:  MOVLB  0
06F10:  CALL   5A88
06F14:  MOVFF  02,03
06F18:  MOVF   01,W
06F1A:  SUBLW  01
06F1C:  BNZ   6F2C
06F1E:  MOVF   03,F
06F20:  BNZ   6F2C
06F22:  MOVLW  00
06F24:  MOVWF  01
06F26:  MOVLB  6
06F28:  BRA    6F36
06F2A:  MOVLB  0
....................       }
06F2C:  MOVLB  6
06F2E:  INCF   xA7,F
06F30:  BRA    6E7E
....................    }
....................    return TRUE;
06F32:  MOVLW  01
06F34:  MOVWF  01
06F36:  MOVLB  0
06F38:  RETURN 0
.................... }
.................... 
.................... BOOLEAN is_valid_channel(char *arg){
....................     if (1 != strlen(arg)) return FALSE;
*
05C00:  MOVFF  6C4,6D2
05C04:  MOVFF  6C3,6D1
05C08:  RCALL  5A88
05C0A:  MOVFF  02,03
05C0E:  MOVF   01,W
05C10:  SUBLW  01
05C12:  BNZ   5C18
05C14:  MOVF   03,F
05C16:  BZ    5C20
05C18:  MOVLW  00
05C1A:  MOVWF  01
05C1C:  BRA    5C4E
05C1E:  BRA    5C46
....................     else if ('1' != arg[0] && '2' != arg[0]) return FALSE;
05C20:  MOVLB  6
05C22:  MOVFF  6C3,FE9
05C26:  MOVFF  6C4,FEA
05C2A:  MOVF   FEF,W
05C2C:  SUBLW  31
05C2E:  BZ    5C48
05C30:  MOVFF  6C3,FE9
05C34:  MOVFF  6C4,FEA
05C38:  MOVF   FEF,W
05C3A:  SUBLW  32
05C3C:  BZ    5C48
05C3E:  MOVLW  00
05C40:  MOVWF  01
05C42:  MOVLB  0
05C44:  BRA    5C4E
05C46:  MOVLB  6
....................     return TRUE;
05C48:  MOVLW  01
05C4A:  MOVWF  01
05C4C:  MOVLB  0
05C4E:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* ASCII HEX CHARACTER TO INT                                                */
.................... /*****************************************************************************/
.................... int8 hex_to_int(char ascii){
....................    if (ascii >= '0' && ascii <= '9') return ascii-'0';
*
05A4E:  MOVLB  6
05A50:  MOVF   x9A,W
05A52:  SUBLW  2F
05A54:  BC    5A66
05A56:  MOVF   x9A,W
05A58:  SUBLW  39
05A5A:  BNC   5A66
05A5C:  MOVLW  30
05A5E:  SUBWF  x9A,W
05A60:  MOVWF  01
05A62:  BRA    5A82
05A64:  BRA    5A82
....................    else if (ascii >= 'A' && ascii <= 'F') return ascii-'A'+10;
05A66:  MOVF   x9A,W
05A68:  SUBLW  40
05A6A:  BC    5A7E
05A6C:  MOVF   x9A,W
05A6E:  SUBLW  46
05A70:  BNC   5A7E
05A72:  MOVLW  41
05A74:  SUBWF  x9A,W
05A76:  ADDLW  0A
05A78:  MOVWF  01
05A7A:  BRA    5A82
05A7C:  BRA    5A82
....................    else return 0xFF;
05A7E:  MOVLW  FF
05A80:  MOVWF  01
05A82:  MOVLB  0
05A84:  GOTO   A0A8 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* COMMAND HANDLER/PARSER FUNCS                                              */
.................... /*****************************************************************************/
.................... void echo_cmd(unsigned int8 rec){
....................    fprintf(SERIAL, "%c", SERcmd[rec].t);
....................    while (SERcmd[rec].recReadIndex <= SERcmd[rec].recWriteIndex)
....................    {
....................       if (SERcmd[rec].recReadIndex != 0) fprintf(SERIAL, "%c", delimiter);
....................       fprintf(SERIAL, "%s", SERcmd[rec].p[SERcmd[rec].recReadIndex]);
....................       SERcmd[rec].recReadIndex++;
....................    }
....................    SERcmd[rec].recReadIndex=0;
.................... }
.................... 
.................... int8 command_parser(unsigned int8 rec){
*
0A004:  MOVLB  6
0A006:  CLRF   xF2
0A008:  MOVFF  691,6F1
0A00C:  CLRF   xF4
0A00E:  MOVLW  B5
0A010:  MOVWF  xF3
0A012:  MOVLB  0
0A014:  CALL   0C0C
0A018:  MOVFF  02,69A
0A01C:  MOVFF  01,699
0A020:  MOVLW  06
0A022:  MOVLB  6
0A024:  ADDWF  x99,F
0A026:  MOVLW  00
0A028:  ADDWFC x9A,F
0A02A:  MOVLW  08
0A02C:  ADDWF  x99,W
0A02E:  MOVWF  01
0A030:  MOVLW  02
0A032:  ADDWFC x9A,W
0A034:  MOVWF  03
0A036:  MOVFF  01,692
0A03A:  MOVWF  x93
0A03C:  CLRF   xF2
0A03E:  MOVFF  691,6F1
0A042:  CLRF   xF4
0A044:  MOVLW  B5
0A046:  MOVWF  xF3
0A048:  MOVLB  0
0A04A:  CALL   0C0C
0A04E:  MOVFF  02,69C
0A052:  MOVFF  01,69B
0A056:  MOVLW  06
0A058:  MOVLB  6
0A05A:  ADDWF  x9B,F
0A05C:  MOVLW  00
0A05E:  ADDWFC x9C,F
0A060:  MOVLW  19
0A062:  ADDWF  x9B,W
0A064:  MOVWF  01
0A066:  MOVLW  00
0A068:  ADDWFC x9C,W
0A06A:  MOVWF  03
0A06C:  MOVF   01,W
0A06E:  ADDLW  08
0A070:  MOVWF  01
0A072:  MOVLW  02
0A074:  ADDWFC 03,F
0A076:  MOVFF  01,694
0A07A:  MOVFF  03,695
0A07E:  CLRF   x96
0A080:  CLRF   x97
....................    char *cmd_adr = SERcmd[rec].p[0];
....................    char *cmd_str = SERcmd[rec].p[1];
.................... //!   int8 devID = input_a();
....................    int8 devID = 0;
....................    int8 i = 0;
....................    
....................    if (hwID == cmd_adr[0]){
0A082:  MOVFF  692,FE9
0A086:  MOVFF  693,FEA
0A08A:  MOVF   FEF,W
0A08C:  SUBLW  44
0A08E:  BTFSS  FD8.2
0A090:  BRA    A180
....................       if (hex_to_int(cmd_adr[1]) == (devID & 0x0F)){
0A092:  MOVLW  01
0A094:  ADDWF  x92,W
0A096:  MOVWF  FE9
0A098:  MOVLW  00
0A09A:  ADDWFC x93,W
0A09C:  MOVWF  FEA
0A09E:  MOVFF  FEF,69A
0A0A2:  MOVLB  0
0A0A4:  GOTO   5A4E
0A0A8:  MOVFF  01,699
0A0AC:  MOVLB  6
0A0AE:  MOVF   x96,W
0A0B0:  ANDLW  0F
0A0B2:  SUBWF  01,W
0A0B4:  BNZ   A178
....................          while (0 != strlen(cmd_list[i].cmd_name)){
0A0B6:  MOVF   x97,W
0A0B8:  MULLW  04
0A0BA:  MOVF   FF3,W
0A0BC:  CLRF   x9A
0A0BE:  MOVWF  x99
0A0C0:  MOVLW  88
0A0C2:  ADDWF  x99,W
0A0C4:  MOVWF  FE9
0A0C6:  MOVLW  05
0A0C8:  ADDWFC x9A,W
0A0CA:  MOVWF  FEA
0A0CC:  MOVFF  FEC,6D2
0A0D0:  MOVF   FED,F
0A0D2:  MOVFF  FEF,6D1
0A0D6:  MOVLB  0
0A0D8:  CALL   5A88
0A0DC:  MOVFF  02,03
0A0E0:  MOVF   01,W
0A0E2:  BNZ   A0E8
0A0E4:  MOVF   03,F
0A0E6:  BZ    A16E
....................             if (0 == strcmp(cmd_str, cmd_list[i].cmd_name))
0A0E8:  MOVLB  6
0A0EA:  MOVF   x97,W
0A0EC:  MULLW  04
0A0EE:  MOVF   FF3,W
0A0F0:  CLRF   x9A
0A0F2:  MOVWF  x99
0A0F4:  MOVLW  88
0A0F6:  ADDWF  x99,W
0A0F8:  MOVWF  FE9
0A0FA:  MOVLW  05
0A0FC:  ADDWFC x9A,W
0A0FE:  MOVWF  FEA
0A100:  MOVFF  FEC,6D4
0A104:  MOVF   FED,F
0A106:  MOVFF  FEF,6D3
0A10A:  MOVFF  695,6D2
0A10E:  MOVFF  694,6D1
0A112:  MOVLB  0
0A114:  CALL   5AC0
0A118:  MOVF   01,F
0A11A:  BNZ   A166
....................             {
....................                int8 return_code = cmd_list[i].cmd_func(rec);
0A11C:  MOVLB  6
0A11E:  MOVF   x97,W
0A120:  MULLW  04
0A122:  MOVF   FF3,W
0A124:  CLRF   x9A
0A126:  MOVWF  x99
0A128:  MOVLW  02
0A12A:  ADDWF  x99,W
0A12C:  MOVWF  01
0A12E:  MOVLW  00
0A130:  ADDWFC x9A,W
0A132:  MOVWF  03
0A134:  MOVF   01,W
0A136:  ADDLW  88
0A138:  MOVWF  01
0A13A:  MOVLW  05
0A13C:  ADDWFC 03,F
0A13E:  MOVFF  01,699
0A142:  MOVFF  03,69A
0A146:  MOVFF  03,FEA
0A14A:  MOVFF  01,FE9
0A14E:  MOVFF  691,68F
0A152:  MOVLB  0
0A154:  CALL   00BC
0A158:  MOVFF  01,698
....................                return return_code;
0A15C:  MOVLB  6
0A15E:  MOVFF  698,01
0A162:  BRA    A184
0A164:  MOVLB  0
....................             }
....................             i++;
0A166:  MOVLB  6
0A168:  INCF   x97,F
0A16A:  BRA    A0B6
0A16C:  MOVLB  0
....................          }
....................          return INV_CMD; // INVALID_CMD
0A16E:  MOVLW  01
0A170:  MOVWF  01
0A172:  MOVLB  6
0A174:  BRA    A184
....................       } else return 254; // NOT THIS ADDRESS
0A176:  BRA    A17E
0A178:  MOVLW  FE
0A17A:  MOVWF  01
0A17C:  BRA    A184
....................    } else return 255; // NOT THIS DEVICE TYPE
0A17E:  BRA    A184
0A180:  MOVLW  FF
0A182:  MOVWF  01
0A184:  MOVLB  0
0A186:  GOTO   A1C0 (RETURN)
.................... }
.................... 
.................... void command_handler_task(){
....................    while (getNextSERReadIndex())
*
0A1B2:  GOTO   59F4
0A1B6:  MOVF   01,F
0A1B8:  BZ    A2A8
....................    {
....................       int8 return_code = command_parser(SRI);
0A1BA:  MOVFF  4DC,691
0A1BE:  BRA    A004
0A1C0:  MOVFF  01,690
....................       //echo_cmd(SRI);
....................       sprintf(retData + strlen(retData), "%s", resp_list[return_code].msg);
0A1C4:  MOVLW  04
0A1C6:  MOVLB  6
0A1C8:  MOVWF  xD2
0A1CA:  MOVLW  DE
0A1CC:  MOVWF  xD1
0A1CE:  MOVLB  0
0A1D0:  CALL   5A88
0A1D4:  MOVF   01,W
0A1D6:  ADDLW  DE
0A1D8:  MOVLB  6
0A1DA:  MOVWF  x91
0A1DC:  MOVLW  04
0A1DE:  ADDWFC 02,W
0A1E0:  MOVWF  x92
0A1E2:  MOVF   x90,W
0A1E4:  MULLW  03
0A1E6:  MOVF   FF3,W
0A1E8:  CLRF   x94
0A1EA:  MOVWF  x93
0A1EC:  MOVLW  01
0A1EE:  ADDWF  x93,W
0A1F0:  MOVWF  01
0A1F2:  MOVLW  00
0A1F4:  ADDWFC x94,W
0A1F6:  MOVWF  03
0A1F8:  MOVF   01,W
0A1FA:  ADDLW  57
0A1FC:  MOVWF  FE9
0A1FE:  MOVLW  06
0A200:  ADDWFC 03,W
0A202:  MOVWF  FEA
0A204:  MOVFF  FEC,694
0A208:  MOVF   FED,F
0A20A:  MOVFF  FEF,693
0A20E:  MOVFF  692,583
0A212:  MOVFF  691,582
0A216:  MOVFF  583,FEA
0A21A:  MOVFF  582,FE9
0A21E:  CLRF   FEF
0A220:  MOVFF  694,FEA
0A224:  MOVFF  693,FE9
0A228:  MOVLB  0
0A22A:  BRA    A18A
....................       fprintf(SERIAL, "$%s,%s\n", SERcmd[SRI].p[0], retData);
0A22C:  MOVLB  6
0A22E:  CLRF   xF2
0A230:  MOVFF  4DC,6F1
0A234:  CLRF   xF4
0A236:  MOVLW  B5
0A238:  MOVWF  xF3
0A23A:  MOVLB  0
0A23C:  CALL   0C0C
0A240:  MOVFF  02,692
0A244:  MOVFF  01,691
0A248:  MOVLW  06
0A24A:  MOVLB  6
0A24C:  ADDWF  x91,F
0A24E:  MOVLW  00
0A250:  ADDWFC x92,F
0A252:  MOVLW  08
0A254:  ADDWF  x91,W
0A256:  MOVWF  01
0A258:  MOVLW  02
0A25A:  ADDWFC x92,W
0A25C:  MOVWF  03
0A25E:  MOVFF  01,693
0A262:  MOVWF  x94
0A264:  MOVLW  24
0A266:  MOVWF  xA6
0A268:  MOVLB  0
0A26A:  CALL   5092
0A26E:  MOVFF  694,FEA
0A272:  MOVFF  693,FE9
0A276:  CALL   50BA
0A27A:  MOVLW  2C
0A27C:  MOVLB  6
0A27E:  MOVWF  xA6
0A280:  MOVLB  0
0A282:  CALL   5092
0A286:  MOVLW  04
0A288:  MOVWF  FEA
0A28A:  MOVLW  DE
0A28C:  MOVWF  FE9
0A28E:  CALL   50BA
0A292:  MOVLW  0A
0A294:  MOVLB  6
0A296:  MOVWF  xA6
0A298:  MOVLB  0
0A29A:  CALL   5092
....................       
....................       resetSERcmd(SRI);
0A29E:  MOVFF  4DC,691
0A2A2:  CALL   0C2E
0A2A6:  BRA    A1B2
....................    }
0A2A8:  GOTO   A928 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... #define DEBUG_1
.................... 
.................... void main()
0A2AC:  CLRF   FF8
0A2AE:  BCF    FF2.5
0A2B0:  BSF    07.7
0A2B2:  MOVLB  E
0A2B4:  MOVLW  55
0A2B6:  MOVWF  x9B
0A2B8:  MOVLW  AA
0A2BA:  MOVWF  x9B
0A2BC:  BCF    x9B.0
0A2BE:  MOVLW  17
0A2C0:  MOVWF  xB0
0A2C2:  MOVLW  13
0A2C4:  MOVWF  xB2
0A2C6:  MOVLW  09
0A2C8:  MOVWF  x8A
0A2CA:  MOVLW  0A
0A2CC:  MOVWF  x8B
0A2CE:  MOVLW  11
0A2D0:  MOVWF  xEB
0A2D2:  MOVLW  12
0A2D4:  MOVWF  xED
0A2D6:  MOVLW  10
0A2D8:  MOVWF  xF4
0A2DA:  MOVLW  0F
0A2DC:  MOVWF  xF5
0A2DE:  MOVLW  09
0A2E0:  MOVWF  xF8
0A2E2:  MOVLW  55
0A2E4:  MOVWF  x9B
0A2E6:  MOVLW  AA
0A2E8:  MOVWF  x9B
0A2EA:  BSF    x9B.0
0A2EC:  CLRF   xD8
0A2EE:  CLRF   xD5
0A2F0:  CLRF   xD7
0A2F2:  MOVLW  08
0A2F4:  MOVWF  xD9
0A2F6:  MOVLW  60
0A2F8:  MOVWF  xD3
0A2FA:  MOVLW  AA
0A2FC:  MOVLB  0
0A2FE:  MOVWF  xF2
0A300:  MOVLB  1
0A302:  CLRF   x5A
0A304:  CLRF   x59
0A306:  CLRF   x58
0A308:  CLRF   x57
0A30A:  CLRF   x5E
0A30C:  CLRF   x5D
0A30E:  CLRF   x5C
0A310:  CLRF   x5B
0A312:  CLRF   x62
0A314:  CLRF   x61
0A316:  CLRF   x60
0A318:  CLRF   x5F
0A31A:  CLRF   x64
0A31C:  CLRF   x63
0A31E:  MOVLB  E
0A320:  BCF    x91.5
0A322:  MOVLW  00
0A324:  MOVWF  x90
0A326:  MOVLW  03
0A328:  MOVWF  x8E
0A32A:  MOVLW  2A
0A32C:  MOVWF  x91
0A32E:  MOVLW  C4
0A330:  MOVWF  F88
0A332:  MOVWF  F88
0A334:  MOVWF  F88
0A336:  BCF    F95.5
0A338:  MOVLW  40
0A33A:  MOVWF  F94
0A33C:  MOVLW  9F
0A33E:  MOVWF  F92
0A340:  MOVLW  3A
0A342:  MOVWF  F95
0A344:  MOVLW  93
0A346:  MOVWF  F89
0A348:  MOVWF  F89
0A34A:  MOVLB  4
0A34C:  CLRF   xDC
0A34E:  CLRF   xDD
0A350:  MOVLB  5
0A352:  CLRF   x7E
0A354:  CLRF   x7F
0A356:  BCF    x80.0
0A358:  CLRF   x81
0A35A:  BSF    F9E.3
0A35C:  MOVLW  7C
0A35E:  MOVWF  F9A
0A360:  MOVLW  00
0A362:  MOVWF  F9B
0A364:  MOVLW  A6
0A366:  MOVWF  F9D
0A368:  MOVLW  90
0A36A:  MOVWF  F9C
0A36C:  MOVLW  93
0A36E:  MOVWF  F89
0A370:  BCF    F84.5
0A372:  CLRF   x83
0A374:  CLRF   x82
0A376:  CLRF   x87
0A378:  CLRF   x86
0A37A:  CLRF   x85
0A37C:  CLRF   x84
0A37E:  MOVLB  F
0A380:  CLRF   x0C
0A382:  CLRF   x14
0A384:  CLRF   x1C
0A386:  CLRF   x21
0A388:  CLRF   x29
0A38A:  CLRF   x35
0A38C:  CLRF   x36
0A38E:  CLRF   x37
0A390:  CLRF   x34
0A392:  CLRF   x31
0A394:  CLRF   x32
0A396:  CLRF   x33
0A398:  CLRF   x30
0A39A:  MOVLW  5B
0A39C:  MOVLB  5
0A39E:  MOVWF  x8B
0A3A0:  MOVLW  78
0A3A2:  MOVWF  x8A
0A3A4:  MOVLW  5B
0A3A6:  MOVWF  x8F
0A3A8:  MOVLW  BC
0A3AA:  MOVWF  x8E
0A3AC:  MOVLW  60
0A3AE:  MOVWF  x93
0A3B0:  MOVLW  B0
0A3B2:  MOVWF  x92
0A3B4:  MOVLW  62
0A3B6:  MOVWF  x97
0A3B8:  MOVLW  8E
0A3BA:  MOVWF  x96
0A3BC:  MOVLW  64
0A3BE:  MOVWF  x9B
0A3C0:  MOVLW  66
0A3C2:  MOVWF  x9A
0A3C4:  MOVLW  65
0A3C6:  MOVWF  x9F
0A3C8:  MOVLW  F2
0A3CA:  MOVWF  x9E
0A3CC:  MOVLW  69
0A3CE:  MOVWF  xA3
0A3D0:  MOVLW  C2
0A3D2:  MOVWF  xA2
0A3D4:  MOVLW  71
0A3D6:  MOVWF  xA7
0A3D8:  MOVLW  94
0A3DA:  MOVWF  xA6
0A3DC:  MOVLW  74
0A3DE:  MOVWF  xAB
0A3E0:  MOVLW  74
0A3E2:  MOVWF  xAA
0A3E4:  MOVLW  75
0A3E6:  MOVWF  xAF
0A3E8:  MOVLW  D6
0A3EA:  MOVWF  xAE
0A3EC:  MOVLW  77
0A3EE:  MOVWF  xB3
0A3F0:  MOVLW  94
0A3F2:  MOVWF  xB2
0A3F4:  MOVLW  7B
0A3F6:  MOVWF  xB7
0A3F8:  MOVLW  4A
0A3FA:  MOVWF  xB6
0A3FC:  MOVLW  80
0A3FE:  MOVWF  xBB
0A400:  MOVLW  A6
0A402:  MOVWF  xBA
0A404:  MOVLW  84
0A406:  MOVWF  xBF
0A408:  MOVLW  3E
0A40A:  MOVWF  xBE
0A40C:  MOVLW  89
0A40E:  MOVWF  xC3
0A410:  MOVLW  6A
0A412:  MOVWF  xC2
0A414:  MOVLW  89
0A416:  MOVWF  xC7
0A418:  MOVLW  70
0A41A:  MOVWF  xC6
0A41C:  MOVLW  8F
0A41E:  MOVWF  xCB
0A420:  MOVLW  E4
0A422:  MOVWF  xCA
0A424:  MOVLW  95
0A426:  MOVWF  xCF
0A428:  MOVLW  48
0A42A:  MOVWF  xCE
0A42C:  MOVLW  9C
0A42E:  MOVWF  xD3
0A430:  MOVLW  6A
0A432:  MOVWF  xD2
0A434:  MOVLW  9D
0A436:  MOVWF  xD7
0A438:  MOVLW  BC
0A43A:  MOVWF  xD6
0A43C:  MOVLW  9F
0A43E:  MOVWF  xDB
0A440:  MOVLW  FE
0A442:  MOVWF  xDA
0A444:  BRA    A60C
0A446:  DATA 02,00
0A448:  DATA 1A,00
0A44A:  DATA 00,0C
0A44C:  DATA 00,20
0A44E:  DATA 78,23
0A450:  DATA D7,0A
0A452:  DATA 7D,19
0A454:  DATA 99,9A
0A456:  DATA 7B,4C
0A458:  DATA CC,CD
0A45A:  DATA 14,C0
0A45C:  DATA 00,0C
0A45E:  DATA 80,78
0A460:  DATA 23,D7
0A462:  DATA 0A,7D
0A464:  DATA 19,99
0A466:  DATA 9A,7B
0A468:  DATA 4C,CC
0A46A:  DATA CD,14
0A46C:  DATA C0,00
0A46E:  DATA 01,80
0A470:  DATA 02,09
0A472:  DATA C0,00
0A474:  DATA 05,80
0A476:  DATA 7F,00
0A478:  DATA 00,00
0A47A:  DATA 7F,0B
0A47C:  DATA C0,00
0A47E:  DATA 05,80
0A480:  DATA 7F,00
0A482:  DATA 00,00
0A484:  DATA 7F,07
0A486:  DATA C0,00
0A488:  DATA 01,80
0A48A:  DATA 7F,17
0A48C:  DATA C0,00
0A48E:  DATA 01,80
0A490:  DATA 7F,17
0A492:  DATA C0,00
0A494:  DATA 04,80
0A496:  DATA 79,B7
0A498:  DATA F3,BD
0A49A:  DATA 04,C0
0A49C:  DATA 00,04
0A49E:  DATA 80,7C
0A4A0:  DATA 59,DF
0A4A2:  DATA 4E,04
0A4A4:  DATA C0,00
0A4A6:  DATA 04,80
0A4A8:  DATA 78,0A
0A4AA:  DATA 28,88
0A4AC:  DATA 04,C0
0A4AE:  DATA 00,04
0A4B0:  DATA 80,78
0A4B2:  DATA 05,EA
0A4B4:  DATA 16,04
0A4B6:  DATA C0,00
0A4B8:  DATA 04,80
0A4BA:  DATA 78,1E
0A4BC:  DATA 33,D7
0A4BE:  DATA 04,C0
0A4C0:  DATA 00,04
0A4C2:  DATA 80,77
0A4C4:  DATA 68,7B
0A4C6:  DATA BB,04
0A4C8:  DATA C0,00
0A4CA:  DATA 04,80
0A4CC:  DATA 77,68
0A4CE:  DATA 0D,C6
0A4D0:  DATA 08,C0
0A4D2:  DATA 00,64
0A4D4:  DATA 40,F3
0A4D6:  DATA 00,05
0A4D8:  DATA 01,E9
0A4DA:  DATA 00,65
0A4DC:  DATA 01,86
0A4DE:  DATA 01,09
0A4E0:  DATA C0,00
0A4E2:  DATA 04,80
0A4E4:  DATA A7,01
0A4E6:  DATA C8,01
0A4E8:  DATA 0D,C0
0A4EA:  DATA 00,3C
0A4EC:  DATA 45,42
0A4EE:  DATA 00,02
0A4F0:  DATA 05,88
0A4F2:  DATA DC,05
0A4F4:  DATA 02,05
0A4F6:  DATA 8C,DF
0A4F8:  DATA 05,02
0A4FA:  DATA 05,90
0A4FC:  DATA E2,05
0A4FE:  DATA 02,05
0A500:  DATA 94,E9
0A502:  DATA 05,02
0A504:  DATA 05,98
0A506:  DATA F0,05
0A508:  DATA 02,05
0A50A:  DATA 9C,F8
0A50C:  DATA 05,02
0A50E:  DATA 05,A0
0A510:  DATA 00,06
0A512:  DATA 02,05
0A514:  DATA A4,05
0A516:  DATA 06,02
0A518:  DATA 05,A8
0A51A:  DATA 0A,06
0A51C:  DATA 02,05
0A51E:  DATA AC,0E
0A520:  DATA 06,02
0A522:  DATA 05,B0
0A524:  DATA 12,06
0A526:  DATA 02,05
0A528:  DATA B4,19
0A52A:  DATA 06,02
0A52C:  DATA 05,B8
0A52E:  DATA 1F,06
0A530:  DATA 02,05
0A532:  DATA BC,25
0A534:  DATA 06,02
0A536:  DATA 05,C0
0A538:  DATA 2B,06
0A53A:  DATA 02,05
0A53C:  DATA C4,31
0A53E:  DATA 06,02
0A540:  DATA 05,C8
0A542:  DATA 36,06
0A544:  DATA 02,05
0A546:  DATA CC,3F
0A548:  DATA 06,02
0A54A:  DATA 05,D0
0A54C:  DATA 47,06
0A54E:  DATA 02,05
0A550:  DATA D4,4E
0A552:  DATA 06,02
0A554:  DATA 05,D8
0A556:  DATA 55,06
0A558:  DATA 78,05
0A55A:  DATA DC,67
0A55C:  DATA 72,00
0A55E:  DATA 67,73
0A560:  DATA 00,67
0A562:  DATA 43,68
0A564:  DATA 4D,61
0A566:  DATA 70,00
0A568:  DATA 73,43
0A56A:  DATA 68,4D
0A56C:  DATA 61,70
0A56E:  DATA 00,67
0A570:  DATA 43,68
0A572:  DATA 4D,6F
0A574:  DATA 64,65
0A576:  DATA 00,73
0A578:  DATA 43,68
0A57A:  DATA 4D,6F
0A57C:  DATA 64,65
0A57E:  DATA 00,67
0A580:  DATA 50,49
0A582:  DATA 44,00
0A584:  DATA 73,50
0A586:  DATA 49,44
0A588:  DATA 00,67
0A58A:  DATA 53,50
0A58C:  DATA 00,73
0A58E:  DATA 53,50
0A590:  DATA 00,67
0A592:  DATA 53,43
0A594:  DATA 61,6C
0A596:  DATA 73,00
0A598:  DATA 67,53
0A59A:  DATA 43,61
0A59C:  DATA 6C,00
0A59E:  DATA 73,53
0A5A0:  DATA 43,61
0A5A2:  DATA 6C,00
0A5A4:  DATA 67,4D
0A5A6:  DATA 43,61
0A5A8:  DATA 6C,00
0A5AA:  DATA 73,4D
0A5AC:  DATA 43,61
0A5AE:  DATA 6C,00
0A5B0:  DATA 67,4D
0A5B2:  DATA 6F,6E
0A5B4:  DATA 00,67
0A5B6:  DATA 50,49
0A5B8:  DATA 44,64
0A5BA:  DATA 61,74
0A5BC:  DATA 61,00
0A5BE:  DATA 67,49
0A5C0:  DATA 50,64
0A5C2:  DATA 61,74
0A5C4:  DATA 61,00
0A5C6:  DATA 67,4D
0A5C8:  DATA 61,6E
0A5CA:  DATA 4F,50
0A5CC:  DATA 00,73
0A5CE:  DATA 4D,61
0A5D0:  DATA 6E,4F
0A5D2:  DATA 50,04
0A5D4:  DATA C0,00
0A5D6:  DATA 33,80
0A5D8:  DATA 60,06
0A5DA:  DATA 01,68
0A5DC:  DATA 06,02
0A5DE:  DATA 78,06
0A5E0:  DATA 53,55
0A5E2:  DATA 43,43
0A5E4:  DATA 45,53
0A5E6:  DATA 53,00
0A5E8:  DATA 49,4E
0A5EA:  DATA 56,41
0A5EC:  DATA 4C,49
0A5EE:  DATA 44,20
0A5F0:  DATA 43,4F
0A5F2:  DATA 4D,4D
0A5F4:  DATA 41,4E
0A5F6:  DATA 44,00
0A5F8:  DATA 49,4E
0A5FA:  DATA 56,41
0A5FC:  DATA 4C,49
0A5FE:  DATA 44,20
0A600:  DATA 50,41
0A602:  DATA 52,41
0A604:  DATA 4D,45
0A606:  DATA 54,45
0A608:  DATA 52,00
0A60A:  DATA 00,00
0A60C:  MOVLW  00
0A60E:  MOVWF  FF8
0A610:  MOVLW  A4
0A612:  MOVWF  FF7
0A614:  MOVLW  46
0A616:  MOVWF  FF6
0A618:  TBLRD*+
0A61A:  MOVF   FF5,W
0A61C:  MOVWF  00
0A61E:  XORLW  00
0A620:  BZ    A648
0A622:  TBLRD*+
0A624:  MOVF   FF5,W
0A626:  MOVWF  01
0A628:  BTFSC  FE8.7
0A62A:  BRA    A636
0A62C:  ANDLW  3F
0A62E:  MOVWF  FEA
0A630:  TBLRD*+
0A632:  MOVFF  FF5,FE9
0A636:  BTFSC  01.6
0A638:  TBLRD*+
0A63A:  BTFSS  01.6
0A63C:  TBLRD*+
0A63E:  MOVFF  FF5,FEE
0A642:  DCFSNZ 00,F
0A644:  BRA    A618
0A646:  BRA    A63A
0A648:  CLRF   FF8
.................... {
....................    IO_init();                    // set up IO 
0A64A:  MOVLB  0
0A64C:  GOTO   03A2
....................    params_init();                // load parameters
0A650:  GOTO   064A
....................    monitor_init();               // initialize internal ADC for voltage and current telemetry
0A654:  GOTO   0B50
....................    control_init();               // initialize the output control DACs
0A658:  GOTO   0BE8
....................    serial_init();                // setup the serial port
0A65C:  GOTO   0DA8
....................    event_timer_init();
0A660:  GOTO   0DCA
.................... //!   setup_wdt(WDT_512MS);
....................    enable_interrupts(GLOBAL);
0A664:  MOVLW  C0
0A666:  IORWF  FF2,F
....................    
....................    while(TRUE)
....................    {
.................... //!      restart_wdt();
....................       internal_monitor_task();   //Update monitored voltage and currents etc
0A668:  GOTO   11A8
....................       sensor_monitor_task();     //get magnetoresistive sensor data
0A66C:  GOTO   454A
....................       control_task();            //output control
0A670:  GOTO   5016
....................       serial_task();             //serial port 
0A674:  GOTO   50DE
....................       
....................       #ifdef DEBUG_1
....................       static int8 ch = 0;
....................       fprintf(SERIAL, "#D0,CNT,%u,%.0f,%.0f\n", ch+1, adcVals[ch].sinCounts, adcVals[ch].cosCounts);
0A678:  MOVLW  01
0A67A:  MOVLB  6
0A67C:  ADDWF  x8A,W
0A67E:  MOVWF  x90
0A680:  MOVF   x8A,W
0A682:  MULLW  21
0A684:  MOVF   FF3,W
0A686:  CLRF   x92
0A688:  MOVWF  x91
0A68A:  MOVLW  08
0A68C:  ADDWF  x91,W
0A68E:  MOVWF  01
0A690:  MOVLW  00
0A692:  ADDWFC x92,W
0A694:  MOVWF  03
0A696:  MOVF   01,W
0A698:  ADDLW  0F
0A69A:  MOVWF  FE9
0A69C:  MOVLW  01
0A69E:  ADDWFC 03,W
0A6A0:  MOVWF  FEA
0A6A2:  MOVFF  FEF,691
0A6A6:  MOVFF  FEC,692
0A6AA:  MOVFF  FEC,693
0A6AE:  MOVFF  FEC,694
0A6B2:  MOVF   x8A,W
0A6B4:  MULLW  21
0A6B6:  MOVF   FF3,W
0A6B8:  CLRF   x96
0A6BA:  MOVWF  x95
0A6BC:  MOVLW  0C
0A6BE:  ADDWF  x95,W
0A6C0:  MOVWF  01
0A6C2:  MOVLW  00
0A6C4:  ADDWFC x96,W
0A6C6:  MOVWF  03
0A6C8:  MOVF   01,W
0A6CA:  ADDLW  0F
0A6CC:  MOVWF  FE9
0A6CE:  MOVLW  01
0A6D0:  ADDWFC 03,W
0A6D2:  MOVWF  FEA
0A6D4:  MOVFF  FEF,695
0A6D8:  MOVFF  FEC,696
0A6DC:  MOVFF  FEC,697
0A6E0:  MOVFF  FEC,698
0A6E4:  MOVLW  56
0A6E6:  MOVWF  FF6
0A6E8:  MOVLW  03
0A6EA:  MOVWF  FF7
0A6EC:  MOVLW  08
0A6EE:  MOVWF  x99
0A6F0:  MOVLB  0
0A6F2:  CALL   55D6
0A6F6:  MOVFF  690,699
0A6FA:  MOVLW  1B
0A6FC:  MOVLB  6
0A6FE:  MOVWF  x9A
0A700:  MOVLB  0
0A702:  CALL   562A
0A706:  MOVLW  2C
0A708:  MOVLB  6
0A70A:  MOVWF  xA6
0A70C:  MOVLB  0
0A70E:  CALL   5092
0A712:  MOVLW  89
0A714:  MOVWF  FE9
0A716:  MOVFF  694,69C
0A71A:  MOVFF  693,69B
0A71E:  MOVFF  692,69A
0A722:  MOVFF  691,699
0A726:  MOVLB  6
0A728:  CLRF   x9D
0A72A:  MOVLB  0
0A72C:  CALL   577C
0A730:  MOVLW  2C
0A732:  MOVLB  6
0A734:  MOVWF  xA6
0A736:  MOVLB  0
0A738:  CALL   5092
0A73C:  MOVLW  89
0A73E:  MOVWF  FE9
0A740:  MOVFF  698,69C
0A744:  MOVFF  697,69B
0A748:  MOVFF  696,69A
0A74C:  MOVFF  695,699
0A750:  MOVLB  6
0A752:  CLRF   x9D
0A754:  MOVLB  0
0A756:  CALL   577C
0A75A:  MOVLW  0A
0A75C:  MOVLB  6
0A75E:  MOVWF  xA6
0A760:  MOVLB  0
0A762:  CALL   5092
....................       fprintf(SERIAL, "#D0,POS,%u,%3.3f\n", ch+1, adcVals[ch].pReal);
0A766:  MOVLW  01
0A768:  MOVLB  6
0A76A:  ADDWF  x8A,W
0A76C:  MOVWF  x90
0A76E:  MOVF   x8A,W
0A770:  MULLW  21
0A772:  MOVF   FF3,W
0A774:  CLRF   x92
0A776:  MOVWF  x91
0A778:  MOVLW  1D
0A77A:  ADDWF  x91,W
0A77C:  MOVWF  01
0A77E:  MOVLW  00
0A780:  ADDWFC x92,W
0A782:  MOVWF  03
0A784:  MOVF   01,W
0A786:  ADDLW  0F
0A788:  MOVWF  FE9
0A78A:  MOVLW  01
0A78C:  ADDWFC 03,W
0A78E:  MOVWF  FEA
0A790:  MOVFF  FEF,691
0A794:  MOVFF  FEC,692
0A798:  MOVFF  FEC,693
0A79C:  MOVFF  FEC,694
0A7A0:  MOVLW  6C
0A7A2:  MOVWF  FF6
0A7A4:  MOVLW  03
0A7A6:  MOVWF  FF7
0A7A8:  MOVLW  08
0A7AA:  MOVWF  x99
0A7AC:  MOVLB  0
0A7AE:  CALL   55D6
0A7B2:  MOVFF  690,699
0A7B6:  MOVLW  1B
0A7B8:  MOVLB  6
0A7BA:  MOVWF  x9A
0A7BC:  MOVLB  0
0A7BE:  CALL   562A
0A7C2:  MOVLW  2C
0A7C4:  MOVLB  6
0A7C6:  MOVWF  xA6
0A7C8:  MOVLB  0
0A7CA:  CALL   5092
0A7CE:  MOVLW  89
0A7D0:  MOVWF  FE9
0A7D2:  MOVFF  694,69C
0A7D6:  MOVFF  693,69B
0A7DA:  MOVFF  692,69A
0A7DE:  MOVFF  691,699
0A7E2:  MOVLW  03
0A7E4:  MOVLB  6
0A7E6:  MOVWF  x9D
0A7E8:  MOVLB  0
0A7EA:  CALL   577C
0A7EE:  MOVLW  0A
0A7F0:  MOVLB  6
0A7F2:  MOVWF  xA6
0A7F4:  MOVLB  0
0A7F6:  CALL   5092
....................       if ( dacVals[ch].invV ) fprintf(SERIAL, "#D0,OUT,%u,-,%Lu\n", ch+1, dacVals[ch].val);
0A7FA:  MOVLB  6
0A7FC:  MOVF   x8A,W
0A7FE:  MULLW  03
0A800:  MOVF   FF3,W
0A802:  CLRF   x91
0A804:  MOVWF  x90
0A806:  MOVLW  02
0A808:  ADDWF  x90,W
0A80A:  MOVWF  01
0A80C:  MOVLW  00
0A80E:  ADDWFC x91,W
0A810:  MOVWF  03
0A812:  MOVF   01,W
0A814:  ADDLW  51
0A816:  MOVWF  FE9
0A818:  MOVLW  01
0A81A:  ADDWFC 03,W
0A81C:  MOVWF  FEA
0A81E:  BTFSS  FEF.0
0A820:  BRA    A89E
0A822:  MOVLW  01
0A824:  ADDWF  x8A,W
0A826:  MOVWF  x90
0A828:  MOVF   x8A,W
0A82A:  MULLW  03
0A82C:  MOVF   FF3,W
0A82E:  CLRF   x92
0A830:  MOVWF  x91
0A832:  MOVLW  51
0A834:  ADDWF  x91,W
0A836:  MOVWF  FE9
0A838:  MOVLW  01
0A83A:  ADDWFC x92,W
0A83C:  MOVWF  FEA
0A83E:  MOVFF  FEC,694
0A842:  MOVF   FED,F
0A844:  MOVFF  FEF,693
0A848:  MOVLW  7E
0A84A:  MOVWF  FF6
0A84C:  MOVLW  03
0A84E:  MOVWF  FF7
0A850:  MOVLW  08
0A852:  MOVWF  x99
0A854:  MOVLB  0
0A856:  CALL   55D6
0A85A:  MOVFF  690,699
0A85E:  MOVLW  1B
0A860:  MOVLB  6
0A862:  MOVWF  x9A
0A864:  MOVLB  0
0A866:  CALL   562A
0A86A:  MOVLW  88
0A86C:  MOVWF  FF6
0A86E:  MOVLW  03
0A870:  MOVWF  FF7
0A872:  MOVLW  03
0A874:  MOVLB  6
0A876:  MOVWF  x99
0A878:  MOVLB  0
0A87A:  CALL   55D6
0A87E:  MOVLW  10
0A880:  MOVWF  FE9
0A882:  MOVFF  694,696
0A886:  MOVFF  693,695
0A88A:  CALL   592C
0A88E:  MOVLW  0A
0A890:  MOVLB  6
0A892:  MOVWF  xA6
0A894:  MOVLB  0
0A896:  CALL   5092
0A89A:  BRA    A916
0A89C:  MOVLB  6
....................       else                    fprintf(SERIAL, "#D0,OUT,%u,+,%Lu\n", ch+1, dacVals[ch].val);
0A89E:  MOVLW  01
0A8A0:  ADDWF  x8A,W
0A8A2:  MOVWF  x90
0A8A4:  MOVF   x8A,W
0A8A6:  MULLW  03
0A8A8:  MOVF   FF3,W
0A8AA:  CLRF   x92
0A8AC:  MOVWF  x91
0A8AE:  MOVLW  51
0A8B0:  ADDWF  x91,W
0A8B2:  MOVWF  FE9
0A8B4:  MOVLW  01
0A8B6:  ADDWFC x92,W
0A8B8:  MOVWF  FEA
0A8BA:  MOVFF  FEC,694
0A8BE:  MOVF   FED,F
0A8C0:  MOVFF  FEF,693
0A8C4:  MOVLW  90
0A8C6:  MOVWF  FF6
0A8C8:  MOVLW  03
0A8CA:  MOVWF  FF7
0A8CC:  MOVLW  08
0A8CE:  MOVWF  x99
0A8D0:  MOVLB  0
0A8D2:  CALL   55D6
0A8D6:  MOVFF  690,699
0A8DA:  MOVLW  1B
0A8DC:  MOVLB  6
0A8DE:  MOVWF  x9A
0A8E0:  MOVLB  0
0A8E2:  CALL   562A
0A8E6:  MOVLW  9A
0A8E8:  MOVWF  FF6
0A8EA:  MOVLW  03
0A8EC:  MOVWF  FF7
0A8EE:  MOVLW  03
0A8F0:  MOVLB  6
0A8F2:  MOVWF  x99
0A8F4:  MOVLB  0
0A8F6:  CALL   55D6
0A8FA:  MOVLW  10
0A8FC:  MOVWF  FE9
0A8FE:  MOVFF  694,696
0A902:  MOVFF  693,695
0A906:  CALL   592C
0A90A:  MOVLW  0A
0A90C:  MOVLB  6
0A90E:  MOVWF  xA6
0A910:  MOVLB  0
0A912:  CALL   5092
....................       ch = !ch;
0A916:  MOVLB  6
0A918:  MOVF   x8A,F
0A91A:  BZ    A920
0A91C:  MOVLW  00
0A91E:  BRA    A922
0A920:  MOVLW  01
0A922:  MOVWF  x8A
.................... //!      fprintf(SERIAL, "---------------\n");
....................       #endif
....................       
....................       command_handler_task();    //execute commands
0A924:  MOVLB  0
0A926:  BRA    A1B2
....................       
....................       delay_ms(250);
0A928:  MOVLW  FA
0A92A:  MOVLB  6
0A92C:  MOVWF  x98
0A92E:  MOVLB  0
0A930:  CALL   0438
0A934:  BRA    A668
....................    }
.................... }
0A936:  SLEEP 

Configuration Fuses:
   Word  1: FF8C   NOEXTOSC RSTOSC_HFINTRC_64MHZ NOCLKOUT CKS FCMEN
   Word  2: FFFD   MCLR PUT NOLPBOR BROWNOUT BORV19 ZCDDIS PPS1WAY STVREN NODEBUG NOXINST
   Word  3: FF9F   WDTSW NOWDT WDTWIN_SW WDTCLK_SW
   Word  4: DFFF   NOWRT NOWRTC NOWRTB NOWRTD SCANE NOLVP
   Word  5: FFFF   NOPROTECT NOCPD
   Word  6: FFFF   NOEBTR NOEBTRB
