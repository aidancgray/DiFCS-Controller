CCS PCH C Compiler, Version 5.109, 62303               25-Nov-25 18:49

               Filename:   C:\Users\aidan\Documents\GitHub\DiFCS-Controller\src\main.lst

               ROM used:   45410 bytes (69%)
                           Largest free fragment is 20124
               RAM used:   1585 (44%) at main() level
                           1691 (47%) worst case
               Stack used: 6 locations (4 in main + 2 for interrupts)
               Stack size: 31

*
00000:  NOP   
00002:  GOTO   AAD8
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  MOVLB  E
00056:  BTFSS  xC0.5
00058:  GOTO   0062
0005C:  BTFSC  xC8.5
0005E:  GOTO   00E8
00062:  BTFSS  xC1.0
00064:  GOTO   006E
00068:  BTFSC  xC9.0
0006A:  GOTO   025A
0006E:  MOVFF  0E,00
00072:  MOVFF  0F,01
00076:  MOVFF  10,02
0007A:  MOVFF  11,03
0007E:  MOVFF  0C,FE9
00082:  MOVFF  07,FEA
00086:  BSF    07.7
00088:  MOVFF  08,FE1
0008C:  MOVFF  09,FE2
00090:  MOVFF  0A,FD9
00094:  MOVFF  0B,FDA
00098:  MOVFF  12,FF3
0009C:  MOVFF  13,FF4
000A0:  MOVFF  14,FFA
000A4:  MOVFF  15,FF5
000A8:  MOVFF  16,FF6
000AC:  MOVFF  17,FF7
000B0:  MOVF   04,W
000B2:  MOVFF  06,FE0
000B6:  MOVFF  05,FD8
000BA:  RETFIE 0
.................... #include <main.h>
.................... #include <18F46Q10.h>
.................... //////////// Standard Header file for the PIC18F46Q10 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F46Q10
000BC:  MOVFF  FEC,FFA
000C0:  MOVF   FED,F
000C2:  MOVFF  FEF,FE8
000C6:  MOVWF  FF9
000C8:  RETURN 0
*
0032E:  DATA 32,30
00330:  DATA 32,35
00332:  DATA 31,31
00334:  DATA 30,34
00336:  DATA 00,00
00338:  DATA 30,30
0033A:  DATA 30,30
0033C:  DATA 00,00
0033E:  DATA 25,64
00340:  DATA 2C,4D
00342:  DATA 41,4E
00344:  DATA 55,41
00346:  DATA 4C,2C
00348:  DATA 00,00
0034A:  DATA 25,64
0034C:  DATA 2C,4D
0034E:  DATA 41,47
00350:  DATA 53,4E
00352:  DATA 53,2C
00354:  DATA 00,00
00356:  DATA 23,44
00358:  DATA 30,2C
0035A:  DATA 43,4E
0035C:  DATA 54,2C
0035E:  DATA 25,75
00360:  DATA 2C,25
00362:  DATA 2E,30
00364:  DATA 66,2C
00366:  DATA 25,2E
00368:  DATA 30,66
0036A:  DATA 0A,00
0036C:  DATA 23,44
0036E:  DATA 30,2C
00370:  DATA 50,4F
00372:  DATA 53,2C
00374:  DATA 25,75
00376:  DATA 2C,25
00378:  DATA 33,2E
0037A:  DATA 33,66
0037C:  DATA 0A,00
0037E:  DATA 23,44
00380:  DATA 30,2C
00382:  DATA 4F,55
00384:  DATA 54,2C
00386:  DATA 25,75
00388:  DATA 2C,2D
0038A:  DATA 2C,25
0038C:  DATA 4C,75
0038E:  DATA 0A,00
00390:  DATA 23,44
00392:  DATA 30,2C
00394:  DATA 4F,55
00396:  DATA 54,2C
00398:  DATA 25,75
0039A:  DATA 2C,2B
0039C:  DATA 2C,25
0039E:  DATA 4C,75
003A0:  DATA 0A,00
*
006C8:  ADDWF  FE8,W
006CA:  CLRF   FF7
006CC:  RLCF   FF7,F
006CE:  ADDLW  E3
006D0:  MOVWF  FF6
006D2:  MOVLW  06
006D4:  ADDWFC FF7,F
006D6:  TBLRD*-
006D8:  MOVF   FF5,W
006DA:  MOVWF  FFA
006DC:  TBLRD*
006DE:  MOVF   FF5,W
006E0:  MOVWF  FF9
006E2:  DATA 92,06
006E4:  DATA 9C,06
006E6:  DATA A6,06
006E8:  DATA B0,06
*
00FC4:  MOVLB  6
00FC6:  MOVF   x69,W
00FC8:  MULWF  x6B
00FCA:  MOVFF  FF3,01
00FCE:  MOVFF  FF4,00
00FD2:  MULWF  x6C
00FD4:  MOVF   FF3,W
00FD6:  ADDWF  00,F
00FD8:  MOVF   x6A,W
00FDA:  MULWF  x6B
00FDC:  MOVF   FF3,W
00FDE:  ADDWFC 00,W
00FE0:  MOVWF  02
00FE2:  MOVLB  0
00FE4:  RETURN 0
*
011BC:  MOVLW  8E
011BE:  MOVWF  00
011C0:  MOVFF  678,01
011C4:  MOVFF  677,02
011C8:  CLRF   03
011CA:  MOVF   01,F
011CC:  BNZ   11E0
011CE:  MOVFF  02,01
011D2:  CLRF   02
011D4:  MOVLW  08
011D6:  SUBWF  00,F
011D8:  MOVF   01,F
011DA:  BNZ   11E0
011DC:  CLRF   00
011DE:  BRA    11F0
011E0:  BCF    FD8.0
011E2:  BTFSC  01.7
011E4:  BRA    11EE
011E6:  RLCF   02,F
011E8:  RLCF   01,F
011EA:  DECF   00,F
011EC:  BRA    11E0
011EE:  BCF    01.7
011F0:  RETURN 0
011F2:  MOVLB  6
011F4:  MOVF   x78,W
011F6:  BTFSC  FD8.2
011F8:  BRA    12DC
011FA:  MOVWF  00
011FC:  MOVF   x7C,W
011FE:  BTFSC  FD8.2
01200:  BRA    12DC
01202:  ADDWF  00,F
01204:  BNC   120E
01206:  MOVLW  81
01208:  ADDWF  00,F
0120A:  BC    12DC
0120C:  BRA    1216
0120E:  MOVLW  7F
01210:  SUBWF  00,F
01212:  BNC   12DC
01214:  BZ    12DC
01216:  MOVFF  679,680
0121A:  MOVF   x7D,W
0121C:  XORWF  x80,F
0121E:  BSF    x79.7
01220:  BSF    x7D.7
01222:  MOVF   x7B,W
01224:  MULWF  x7F
01226:  MOVFF  FF4,682
0122A:  MOVF   x7A,W
0122C:  MULWF  x7E
0122E:  MOVFF  FF4,03
01232:  MOVFF  FF3,681
01236:  MULWF  x7F
01238:  MOVF   FF3,W
0123A:  ADDWF  x82,F
0123C:  MOVF   FF4,W
0123E:  ADDWFC x81,F
01240:  MOVLW  00
01242:  ADDWFC 03,F
01244:  MOVF   x7B,W
01246:  MULWF  x7E
01248:  MOVF   FF3,W
0124A:  ADDWF  x82,F
0124C:  MOVF   FF4,W
0124E:  ADDWFC x81,F
01250:  MOVLW  00
01252:  CLRF   02
01254:  ADDWFC 03,F
01256:  ADDWFC 02,F
01258:  MOVF   x79,W
0125A:  MULWF  x7F
0125C:  MOVF   FF3,W
0125E:  ADDWF  x81,F
01260:  MOVF   FF4,W
01262:  ADDWFC 03,F
01264:  MOVLW  00
01266:  ADDWFC 02,F
01268:  MOVF   x79,W
0126A:  MULWF  x7E
0126C:  MOVF   FF3,W
0126E:  ADDWF  03,F
01270:  MOVF   FF4,W
01272:  ADDWFC 02,F
01274:  MOVLW  00
01276:  CLRF   01
01278:  ADDWFC 01,F
0127A:  MOVF   x7B,W
0127C:  MULWF  x7D
0127E:  MOVF   FF3,W
01280:  ADDWF  x81,F
01282:  MOVF   FF4,W
01284:  ADDWFC 03,F
01286:  MOVLW  00
01288:  ADDWFC 02,F
0128A:  ADDWFC 01,F
0128C:  MOVF   x7A,W
0128E:  MULWF  x7D
01290:  MOVF   FF3,W
01292:  ADDWF  03,F
01294:  MOVF   FF4,W
01296:  ADDWFC 02,F
01298:  MOVLW  00
0129A:  ADDWFC 01,F
0129C:  MOVF   x79,W
0129E:  MULWF  x7D
012A0:  MOVF   FF3,W
012A2:  ADDWF  02,F
012A4:  MOVF   FF4,W
012A6:  ADDWFC 01,F
012A8:  INCF   00,F
012AA:  BTFSC  01.7
012AC:  BRA    12B8
012AE:  RLCF   x81,F
012B0:  RLCF   03,F
012B2:  RLCF   02,F
012B4:  RLCF   01,F
012B6:  DECF   00,F
012B8:  MOVLW  00
012BA:  BTFSS  x81.7
012BC:  BRA    12D2
012BE:  INCF   03,F
012C0:  ADDWFC 02,F
012C2:  ADDWFC 01,F
012C4:  MOVF   01,W
012C6:  BNZ   12D2
012C8:  MOVF   02,W
012CA:  BNZ   12D2
012CC:  MOVF   03,W
012CE:  BNZ   12D2
012D0:  INCF   00,F
012D2:  BTFSC  x80.7
012D4:  BSF    01.7
012D6:  BTFSS  x80.7
012D8:  BCF    01.7
012DA:  BRA    12E4
012DC:  CLRF   00
012DE:  CLRF   01
012E0:  CLRF   02
012E2:  CLRF   03
012E4:  MOVLB  0
012E6:  RETURN 0
012E8:  MOVLW  80
012EA:  BTFSS  FD8.1
012EC:  BRA    12F2
012EE:  MOVLB  6
012F0:  XORWF  x7C,F
012F2:  MOVLB  6
012F4:  CLRF   x81
012F6:  CLRF   x82
012F8:  MOVFF  678,680
012FC:  MOVF   x7C,W
012FE:  XORWF  x80,F
01300:  MOVF   x77,W
01302:  BTFSC  FD8.2
01304:  BRA    14C4
01306:  MOVWF  x7F
01308:  MOVWF  00
0130A:  MOVF   x7B,W
0130C:  BTFSC  FD8.2
0130E:  BRA    14D6
01310:  SUBWF  x7F,F
01312:  BTFSC  FD8.2
01314:  BRA    141C
01316:  BNC   1394
01318:  MOVFF  67C,685
0131C:  BSF    x85.7
0131E:  MOVFF  67D,684
01322:  MOVFF  67E,683
01326:  CLRF   x82
01328:  BCF    FD8.0
0132A:  RRCF   x85,F
0132C:  RRCF   x84,F
0132E:  RRCF   x83,F
01330:  RRCF   x82,F
01332:  DECFSZ x7F,F
01334:  BRA    1326
01336:  BTFSS  x80.7
01338:  BRA    1340
0133A:  BSF    x81.0
0133C:  BRA    14FE
0133E:  BCF    x81.0
01340:  BCF    x7F.0
01342:  BSF    x81.4
01344:  MOVLW  06
01346:  MOVWF  FEA
01348:  MOVLW  7A
0134A:  MOVWF  FE9
0134C:  BRA    1524
0134E:  BCF    x81.4
01350:  BTFSC  x80.7
01352:  BRA    1368
01354:  BTFSS  x7F.0
01356:  BRA    137E
01358:  RRCF   x85,F
0135A:  RRCF   x84,F
0135C:  RRCF   x83,F
0135E:  RRCF   x82,F
01360:  INCF   00,F
01362:  BTFSC  FD8.2
01364:  BRA    14F4
01366:  BRA    137E
01368:  BTFSC  x85.7
0136A:  BRA    1384
0136C:  BCF    FD8.0
0136E:  RLCF   x82,F
01370:  RLCF   x83,F
01372:  RLCF   x84,F
01374:  RLCF   x85,F
01376:  DECF   00,F
01378:  BTFSC  FD8.2
0137A:  BRA    14F4
0137C:  BRA    1368
0137E:  BSF    x81.6
01380:  BRA    145C
01382:  BCF    x81.6
01384:  MOVFF  678,680
01388:  BTFSS  x78.7
0138A:  BRA    1390
0138C:  BSF    x85.7
0138E:  BRA    14E6
01390:  BCF    x85.7
01392:  BRA    14E6
01394:  MOVFF  67B,67F
01398:  MOVFF  67B,00
0139C:  MOVF   x77,W
0139E:  SUBWF  x7F,F
013A0:  MOVFF  678,685
013A4:  BSF    x85.7
013A6:  MOVFF  679,684
013AA:  MOVFF  67A,683
013AE:  CLRF   x82
013B0:  BCF    FD8.0
013B2:  RRCF   x85,F
013B4:  RRCF   x84,F
013B6:  RRCF   x83,F
013B8:  RRCF   x82,F
013BA:  DECFSZ x7F,F
013BC:  BRA    13AE
013BE:  BTFSS  x80.7
013C0:  BRA    13C8
013C2:  BSF    x81.1
013C4:  BRA    14FE
013C6:  BCF    x81.1
013C8:  BCF    x7F.0
013CA:  BSF    x81.5
013CC:  MOVLW  06
013CE:  MOVWF  FEA
013D0:  MOVLW  7E
013D2:  MOVWF  FE9
013D4:  BRA    1524
013D6:  BCF    x81.5
013D8:  BTFSC  x80.7
013DA:  BRA    13F0
013DC:  BTFSS  x7F.0
013DE:  BRA    1406
013E0:  RRCF   x85,F
013E2:  RRCF   x84,F
013E4:  RRCF   x83,F
013E6:  RRCF   x82,F
013E8:  INCF   00,F
013EA:  BTFSC  FD8.2
013EC:  BRA    14F4
013EE:  BRA    1406
013F0:  BTFSC  x85.7
013F2:  BRA    140C
013F4:  BCF    FD8.0
013F6:  RLCF   x82,F
013F8:  RLCF   x83,F
013FA:  RLCF   x84,F
013FC:  RLCF   x85,F
013FE:  DECF   00,F
01400:  BTFSC  FD8.2
01402:  BRA    14F4
01404:  BRA    13F0
01406:  BSF    x81.7
01408:  BRA    145C
0140A:  BCF    x81.7
0140C:  MOVFF  67C,680
01410:  BTFSS  x7C.7
01412:  BRA    1418
01414:  BSF    x85.7
01416:  BRA    14E6
01418:  BCF    x85.7
0141A:  BRA    14E6
0141C:  MOVFF  67C,685
01420:  BSF    x85.7
01422:  MOVFF  67D,684
01426:  MOVFF  67E,683
0142A:  BTFSS  x80.7
0142C:  BRA    1436
0142E:  BCF    x85.7
01430:  BSF    x81.2
01432:  BRA    14FE
01434:  BCF    x81.2
01436:  CLRF   x82
01438:  BCF    x7F.0
0143A:  MOVLW  06
0143C:  MOVWF  FEA
0143E:  MOVLW  7A
01440:  MOVWF  FE9
01442:  BRA    1524
01444:  BTFSC  x80.7
01446:  BRA    1480
01448:  MOVFF  678,680
0144C:  BTFSS  x7F.0
0144E:  BRA    145C
01450:  RRCF   x85,F
01452:  RRCF   x84,F
01454:  RRCF   x83,F
01456:  RRCF   x82,F
01458:  INCF   00,F
0145A:  BZ    14F4
0145C:  BTFSS  x82.7
0145E:  BRA    1476
01460:  INCF   x83,F
01462:  BNZ   1476
01464:  INCF   x84,F
01466:  BNZ   1476
01468:  INCF   x85,F
0146A:  BNZ   1476
0146C:  RRCF   x85,F
0146E:  RRCF   x84,F
01470:  RRCF   x83,F
01472:  INCF   00,F
01474:  BZ    14F4
01476:  BTFSC  x81.6
01478:  BRA    1382
0147A:  BTFSC  x81.7
0147C:  BRA    140A
0147E:  BRA    14B8
01480:  MOVLW  80
01482:  XORWF  x85,F
01484:  BTFSS  x85.7
01486:  BRA    1490
01488:  BRA    14FE
0148A:  MOVFF  67C,680
0148E:  BRA    14A4
01490:  MOVFF  678,680
01494:  MOVF   x85,F
01496:  BNZ   14A4
01498:  MOVF   x84,F
0149A:  BNZ   14A4
0149C:  MOVF   x83,F
0149E:  BNZ   14A4
014A0:  CLRF   00
014A2:  BRA    14E6
014A4:  BTFSC  x85.7
014A6:  BRA    14B8
014A8:  BCF    FD8.0
014AA:  RLCF   x82,F
014AC:  RLCF   x83,F
014AE:  RLCF   x84,F
014B0:  RLCF   x85,F
014B2:  DECFSZ 00,F
014B4:  BRA    14A4
014B6:  BRA    14F4
014B8:  BTFSS  x80.7
014BA:  BRA    14C0
014BC:  BSF    x85.7
014BE:  BRA    14E6
014C0:  BCF    x85.7
014C2:  BRA    14E6
014C4:  MOVFF  67B,00
014C8:  MOVFF  67C,685
014CC:  MOVFF  67D,684
014D0:  MOVFF  67E,683
014D4:  BRA    14E6
014D6:  MOVFF  677,00
014DA:  MOVFF  678,685
014DE:  MOVFF  679,684
014E2:  MOVFF  67A,683
014E6:  MOVFF  685,01
014EA:  MOVFF  684,02
014EE:  MOVFF  683,03
014F2:  BRA    155C
014F4:  CLRF   00
014F6:  CLRF   01
014F8:  CLRF   02
014FA:  CLRF   03
014FC:  BRA    155C
014FE:  CLRF   x82
01500:  COMF   x83,F
01502:  COMF   x84,F
01504:  COMF   x85,F
01506:  COMF   x82,F
01508:  INCF   x82,F
0150A:  BNZ   1516
0150C:  INCF   x83,F
0150E:  BNZ   1516
01510:  INCF   x84,F
01512:  BNZ   1516
01514:  INCF   x85,F
01516:  BTFSC  x81.0
01518:  BRA    133E
0151A:  BTFSC  x81.1
0151C:  BRA    13C6
0151E:  BTFSC  x81.2
01520:  BRA    1434
01522:  BRA    148A
01524:  MOVF   FEF,W
01526:  ADDWF  x83,F
01528:  BNC   1534
0152A:  INCF   x84,F
0152C:  BNZ   1534
0152E:  INCF   x85,F
01530:  BTFSC  FD8.2
01532:  BSF    x7F.0
01534:  MOVF   FED,F
01536:  MOVF   FEF,W
01538:  ADDWF  x84,F
0153A:  BNC   1542
0153C:  INCF   x85,F
0153E:  BTFSC  FD8.2
01540:  BSF    x7F.0
01542:  MOVF   FED,F
01544:  MOVF   FEF,W
01546:  BTFSC  FEF.7
01548:  BRA    154C
0154A:  XORLW  80
0154C:  ADDWF  x85,F
0154E:  BTFSC  FD8.0
01550:  BSF    x7F.0
01552:  BTFSC  x81.4
01554:  BRA    134E
01556:  BTFSC  x81.5
01558:  BRA    13D6
0155A:  BRA    1444
0155C:  MOVLB  0
0155E:  RETURN 0
*
01AB6:  ADDWF  FE8,W
01AB8:  CLRF   FF7
01ABA:  RLCF   FF7,F
01ABC:  ADDLW  D1
01ABE:  MOVWF  FF6
01AC0:  MOVLW  1A
01AC2:  ADDWFC FF7,F
01AC4:  TBLRD*-
01AC6:  MOVF   FF5,W
01AC8:  MOVWF  FFA
01ACA:  TBLRD*
01ACC:  MOVF   FF5,W
01ACE:  MOVWF  FF9
01AD0:  DATA 78,15
01AD2:  DATA 38,16
01AD4:  DATA F8,16
01AD6:  DATA B8,17
01AD8:  DATA 78,18
01ADA:  DATA 38,19
01ADC:  DATA F8,19
*
01C3A:  BTFSC  FD8.1
01C3C:  BRA    1C46
01C3E:  MOVLW  06
01C40:  MOVWF  FEA
01C42:  MOVLW  57
01C44:  MOVWF  FE9
01C46:  MOVLB  6
01C48:  MOVF   x52,W
01C4A:  XORWF  x56,W
01C4C:  ANDLW  80
01C4E:  MOVWF  x5C
01C50:  BTFSS  x52.7
01C52:  BRA    1C6A
01C54:  COMF   x4F,F
01C56:  COMF   x50,F
01C58:  COMF   x51,F
01C5A:  COMF   x52,F
01C5C:  INCF   x4F,F
01C5E:  BTFSC  FD8.2
01C60:  INCF   x50,F
01C62:  BTFSC  FD8.2
01C64:  INCF   x51,F
01C66:  BTFSC  FD8.2
01C68:  INCF   x52,F
01C6A:  BTFSS  x56.7
01C6C:  BRA    1C84
01C6E:  COMF   x53,F
01C70:  COMF   x54,F
01C72:  COMF   x55,F
01C74:  COMF   x56,F
01C76:  INCF   x53,F
01C78:  BTFSC  FD8.2
01C7A:  INCF   x54,F
01C7C:  BTFSC  FD8.2
01C7E:  INCF   x55,F
01C80:  BTFSC  FD8.2
01C82:  INCF   x56,F
01C84:  CLRF   00
01C86:  CLRF   01
01C88:  CLRF   02
01C8A:  CLRF   03
01C8C:  CLRF   x57
01C8E:  CLRF   x58
01C90:  CLRF   x59
01C92:  CLRF   x5A
01C94:  MOVF   x56,W
01C96:  IORWF  x55,W
01C98:  IORWF  x54,W
01C9A:  IORWF  x53,W
01C9C:  BZ    1CF6
01C9E:  MOVLW  20
01CA0:  MOVWF  x5B
01CA2:  BCF    FD8.0
01CA4:  RLCF   x4F,F
01CA6:  RLCF   x50,F
01CA8:  RLCF   x51,F
01CAA:  RLCF   x52,F
01CAC:  RLCF   x57,F
01CAE:  RLCF   x58,F
01CB0:  RLCF   x59,F
01CB2:  RLCF   x5A,F
01CB4:  MOVF   x56,W
01CB6:  SUBWF  x5A,W
01CB8:  BNZ   1CCA
01CBA:  MOVF   x55,W
01CBC:  SUBWF  x59,W
01CBE:  BNZ   1CCA
01CC0:  MOVF   x54,W
01CC2:  SUBWF  x58,W
01CC4:  BNZ   1CCA
01CC6:  MOVF   x53,W
01CC8:  SUBWF  x57,W
01CCA:  BNC   1CEA
01CCC:  MOVF   x53,W
01CCE:  SUBWF  x57,F
01CD0:  MOVF   x54,W
01CD2:  BTFSS  FD8.0
01CD4:  INCFSZ x54,W
01CD6:  SUBWF  x58,F
01CD8:  MOVF   x55,W
01CDA:  BTFSS  FD8.0
01CDC:  INCFSZ x55,W
01CDE:  SUBWF  x59,F
01CE0:  MOVF   x56,W
01CE2:  BTFSS  FD8.0
01CE4:  INCFSZ x56,W
01CE6:  SUBWF  x5A,F
01CE8:  BSF    FD8.0
01CEA:  RLCF   00,F
01CEC:  RLCF   01,F
01CEE:  RLCF   02,F
01CF0:  RLCF   03,F
01CF2:  DECFSZ x5B,F
01CF4:  BRA    1CA2
01CF6:  BTFSS  x5C.7
01CF8:  BRA    1D10
01CFA:  COMF   00,F
01CFC:  COMF   01,F
01CFE:  COMF   02,F
01D00:  COMF   03,F
01D02:  INCF   00,F
01D04:  BTFSC  FD8.2
01D06:  INCF   01,F
01D08:  BTFSC  FD8.2
01D0A:  INCF   02,F
01D0C:  BTFSC  FD8.2
01D0E:  INCF   03,F
01D10:  MOVFF  657,FEF
01D14:  MOVFF  658,FEC
01D18:  MOVFF  659,FEC
01D1C:  MOVFF  65A,FEC
01D20:  MOVLB  0
01D22:  RETURN 0
*
02596:  MOVLW  B6
02598:  MOVWF  00
0259A:  CLRF   03
0259C:  CLRF   02
0259E:  CLRF   01
025A0:  MOVLB  6
025A2:  BCF    x41.0
025A4:  BTFSS  x40.7
025A6:  BRA    25C0
025A8:  BSF    x41.0
025AA:  COMF   x3D,F
025AC:  COMF   x3E,F
025AE:  COMF   x3F,F
025B0:  COMF   x40,F
025B2:  INCF   x3D,F
025B4:  BNZ   25C0
025B6:  INCF   x3E,F
025B8:  BNZ   25C0
025BA:  INCF   x3F,F
025BC:  BTFSC  FD8.2
025BE:  INCF   x40,F
025C0:  MOVF   x3D,W
025C2:  IORWF  x3E,W
025C4:  IORWF  x3F,W
025C6:  IORWF  x40,W
025C8:  BNZ   25CE
025CA:  CLRF   00
025CC:  BRA    25EC
025CE:  BCF    FD8.0
025D0:  BTFSC  01.7
025D2:  BRA    25E6
025D4:  RLCF   x3D,F
025D6:  RLCF   x3E,F
025D8:  RLCF   x3F,F
025DA:  RLCF   x40,F
025DC:  RLCF   03,F
025DE:  RLCF   02,F
025E0:  RLCF   01,F
025E2:  DECFSZ 00,F
025E4:  BRA    25CE
025E6:  BCF    01.7
025E8:  BTFSC  x41.0
025EA:  BSF    01.7
025EC:  MOVLB  0
025EE:  RETURN 0
025F0:  MOVFF  674,67B
025F4:  MOVLB  6
025F6:  MOVF   x78,W
025F8:  XORWF  x7B,F
025FA:  BTFSS  x7B.7
025FC:  BRA    2608
025FE:  BCF    FD8.2
02600:  BCF    FD8.0
02602:  BTFSC  x74.7
02604:  BSF    FD8.0
02606:  BRA    2666
02608:  MOVFF  674,67B
0260C:  MOVFF  677,67C
02610:  MOVF   x73,W
02612:  SUBWF  x7C,F
02614:  BZ    2622
02616:  BTFSS  x7B.7
02618:  BRA    2666
0261A:  MOVF   FD8,W
0261C:  XORLW  01
0261E:  MOVWF  FD8
02620:  BRA    2666
02622:  MOVFF  678,67C
02626:  MOVF   x74,W
02628:  SUBWF  x7C,F
0262A:  BZ    2638
0262C:  BTFSS  x7B.7
0262E:  BRA    2666
02630:  MOVF   FD8,W
02632:  XORLW  01
02634:  MOVWF  FD8
02636:  BRA    2666
02638:  MOVFF  679,67C
0263C:  MOVF   x75,W
0263E:  SUBWF  x7C,F
02640:  BZ    264E
02642:  BTFSS  x7B.7
02644:  BRA    2666
02646:  MOVF   FD8,W
02648:  XORLW  01
0264A:  MOVWF  FD8
0264C:  BRA    2666
0264E:  MOVFF  67A,67C
02652:  MOVF   x76,W
02654:  SUBWF  x7C,F
02656:  BZ    2664
02658:  BTFSS  x7B.7
0265A:  BRA    2666
0265C:  MOVF   FD8,W
0265E:  XORLW  01
02660:  MOVWF  FD8
02662:  BRA    2666
02664:  BCF    FD8.0
02666:  MOVLB  0
02668:  RETURN 0
0266A:  MOVLB  6
0266C:  MOVF   x6C,W
0266E:  BTFSC  FD8.2
02670:  BRA    27BC
02672:  MOVWF  x78
02674:  MOVF   x70,W
02676:  BTFSC  FD8.2
02678:  BRA    27BC
0267A:  SUBWF  x78,F
0267C:  BNC   2688
0267E:  MOVLW  7F
02680:  ADDWF  x78,F
02682:  BTFSC  FD8.0
02684:  BRA    27BC
02686:  BRA    2694
02688:  MOVLW  81
0268A:  SUBWF  x78,F
0268C:  BTFSS  FD8.0
0268E:  BRA    27BC
02690:  BTFSC  FD8.2
02692:  BRA    27BC
02694:  MOVFF  678,00
02698:  CLRF   01
0269A:  CLRF   02
0269C:  CLRF   03
0269E:  CLRF   x77
026A0:  MOVFF  66D,676
026A4:  BSF    x76.7
026A6:  MOVFF  66E,675
026AA:  MOVFF  66F,674
026AE:  MOVLW  19
026B0:  MOVWF  x78
026B2:  MOVF   x73,W
026B4:  SUBWF  x74,F
026B6:  BC    26D2
026B8:  MOVLW  01
026BA:  SUBWF  x75,F
026BC:  BC    26D2
026BE:  SUBWF  x76,F
026C0:  BC    26D2
026C2:  SUBWF  x77,F
026C4:  BC    26D2
026C6:  INCF   x77,F
026C8:  INCF   x76,F
026CA:  INCF   x75,F
026CC:  MOVF   x73,W
026CE:  ADDWF  x74,F
026D0:  BRA    2722
026D2:  MOVF   x72,W
026D4:  SUBWF  x75,F
026D6:  BC    26FC
026D8:  MOVLW  01
026DA:  SUBWF  x76,F
026DC:  BC    26FC
026DE:  SUBWF  x77,F
026E0:  BC    26FC
026E2:  INCF   x77,F
026E4:  INCF   x76,F
026E6:  MOVF   x72,W
026E8:  ADDWF  x75,F
026EA:  MOVF   x73,W
026EC:  ADDWF  x74,F
026EE:  BNC   2722
026F0:  INCF   x75,F
026F2:  BNZ   2722
026F4:  INCF   x76,F
026F6:  BNZ   2722
026F8:  INCF   x77,F
026FA:  BRA    2722
026FC:  MOVF   x71,W
026FE:  IORLW  80
02700:  SUBWF  x76,F
02702:  BC    2720
02704:  MOVLW  01
02706:  SUBWF  x77,F
02708:  BC    2720
0270A:  INCF   x77,F
0270C:  MOVF   x71,W
0270E:  IORLW  80
02710:  ADDWF  x76,F
02712:  MOVF   x72,W
02714:  ADDWF  x75,F
02716:  BNC   26EA
02718:  INCF   x76,F
0271A:  BNZ   26EA
0271C:  INCF   x77,F
0271E:  BRA    26EA
02720:  BSF    03.0
02722:  DECFSZ x78,F
02724:  BRA    2728
02726:  BRA    273E
02728:  BCF    FD8.0
0272A:  RLCF   x74,F
0272C:  RLCF   x75,F
0272E:  RLCF   x76,F
02730:  RLCF   x77,F
02732:  BCF    FD8.0
02734:  RLCF   03,F
02736:  RLCF   02,F
02738:  RLCF   01,F
0273A:  RLCF   x79,F
0273C:  BRA    26B2
0273E:  BTFSS  x79.0
02740:  BRA    274E
02742:  BCF    FD8.0
02744:  RRCF   01,F
02746:  RRCF   02,F
02748:  RRCF   03,F
0274A:  RRCF   x79,F
0274C:  BRA    2752
0274E:  DECF   00,F
02750:  BZ    27BC
02752:  BTFSC  x79.7
02754:  BRA    2792
02756:  BCF    FD8.0
02758:  RLCF   x74,F
0275A:  RLCF   x75,F
0275C:  RLCF   x76,F
0275E:  RLCF   x77,F
02760:  MOVF   x73,W
02762:  SUBWF  x74,F
02764:  BC    2774
02766:  MOVLW  01
02768:  SUBWF  x75,F
0276A:  BC    2774
0276C:  SUBWF  x76,F
0276E:  BC    2774
02770:  SUBWF  x77,F
02772:  BNC   27A8
02774:  MOVF   x72,W
02776:  SUBWF  x75,F
02778:  BC    2784
0277A:  MOVLW  01
0277C:  SUBWF  x76,F
0277E:  BC    2784
02780:  SUBWF  x77,F
02782:  BNC   27A8
02784:  MOVF   x71,W
02786:  IORLW  80
02788:  SUBWF  x76,F
0278A:  BC    2792
0278C:  MOVLW  01
0278E:  SUBWF  x77,F
02790:  BNC   27A8
02792:  INCF   03,F
02794:  BNZ   27A8
02796:  INCF   02,F
02798:  BNZ   27A8
0279A:  INCF   01,F
0279C:  BNZ   27A8
0279E:  INCF   00,F
027A0:  BZ    27BC
027A2:  RRCF   01,F
027A4:  RRCF   02,F
027A6:  RRCF   03,F
027A8:  MOVFF  66D,678
027AC:  MOVF   x71,W
027AE:  XORWF  x78,F
027B0:  BTFSS  x78.7
027B2:  BRA    27B8
027B4:  BSF    01.7
027B6:  BRA    27C4
027B8:  BCF    01.7
027BA:  BRA    27C4
027BC:  CLRF   00
027BE:  CLRF   01
027C0:  CLRF   02
027C2:  CLRF   03
027C4:  MOVLB  0
027C6:  RETURN 0
*
02F72:  ADDWF  FE8,W
02F74:  CLRF   FF7
02F76:  RLCF   FF7,F
02F78:  ADDLW  8D
02F7A:  MOVWF  FF6
02F7C:  MOVLW  2F
02F7E:  ADDWFC FF7,F
02F80:  TBLRD*-
02F82:  MOVF   FF5,W
02F84:  MOVWF  FFA
02F86:  TBLRD*
02F88:  MOVF   FF5,W
02F8A:  MOVWF  FF9
02F8C:  DATA 7A,2E
02F8E:  DATA 94,2E
02F90:  DATA E8,2E
02F92:  DATA 4C,2F
02F94:  MOVLW  8E
02F96:  MOVWF  00
02F98:  MOVFF  66A,01
02F9C:  MOVFF  669,02
02FA0:  CLRF   03
02FA2:  BTFSS  01.7
02FA4:  BRA    2FB0
02FA6:  COMF   01,F
02FA8:  COMF   02,F
02FAA:  INCF   02,F
02FAC:  BNZ   2FB0
02FAE:  INCF   01,F
02FB0:  MOVF   01,F
02FB2:  BNZ   2FC6
02FB4:  MOVFF  02,01
02FB8:  CLRF   02
02FBA:  MOVLW  08
02FBC:  SUBWF  00,F
02FBE:  MOVF   01,F
02FC0:  BNZ   2FC6
02FC2:  CLRF   00
02FC4:  BRA    2FE2
02FC6:  BCF    FD8.0
02FC8:  BTFSC  01.7
02FCA:  BRA    2FD4
02FCC:  RLCF   02,F
02FCE:  RLCF   01,F
02FD0:  DECF   00,F
02FD2:  BRA    2FC6
02FD4:  MOVLB  6
02FD6:  BTFSS  x6A.7
02FD8:  BRA    2FDE
02FDA:  MOVLB  0
02FDC:  BRA    2FE2
02FDE:  BCF    01.7
02FE0:  MOVLB  0
02FE2:  RETURN 0
02FE4:  MOVLW  8E
02FE6:  MOVWF  00
02FE8:  MOVLB  6
02FEA:  MOVF   x73,W
02FEC:  SUBWF  00,F
02FEE:  MOVFF  674,02
02FF2:  MOVFF  675,01
02FF6:  BSF    02.7
02FF8:  MOVF   00,F
02FFA:  BZ    300E
02FFC:  BCF    FD8.0
02FFE:  MOVF   02,F
03000:  BNZ   3006
03002:  MOVF   01,F
03004:  BZ    300E
03006:  RRCF   02,F
03008:  RRCF   01,F
0300A:  DECFSZ 00,F
0300C:  BRA    2FFC
0300E:  BTFSS  x74.7
03010:  BRA    301C
03012:  COMF   01,F
03014:  COMF   02,F
03016:  INCF   01,F
03018:  BTFSC  FD8.2
0301A:  INCF   02,F
0301C:  MOVLB  0
0301E:  RETURN 0
*
04E5C:  MOVLB  6
04E5E:  MOVF   x35,W
04E60:  ANDLW  07
04E62:  MOVWF  00
04E64:  RRCF   x35,W
04E66:  MOVWF  01
04E68:  RRCF   01,F
04E6A:  RRCF   01,F
04E6C:  MOVLW  1F
04E6E:  ANDWF  01,F
04E70:  MOVF   01,W
04E72:  ADDWF  x36,W
04E74:  MOVWF  FE9
04E76:  MOVLW  00
04E78:  ADDWFC x37,W
04E7A:  MOVWF  FEA
04E7C:  MOVFF  FEF,01
04E80:  INCF   00,F
04E82:  BRA    4E86
04E84:  RRCF   01,F
04E86:  DECFSZ 00,F
04E88:  BRA    4E84
04E8A:  MOVLW  01
04E8C:  ANDWF  01,F
04E8E:  MOVLB  0
04E90:  RETURN 0
*
05892:  MOVF   FEF,F
05894:  BZ    58B4
05896:  MOVFF  FEA,62E
0589A:  MOVFF  FE9,62D
0589E:  MOVFF  FEF,63E
058A2:  RCALL  586A
058A4:  MOVFF  62E,FEA
058A8:  MOVFF  62D,FE9
058AC:  INCF   FE9,F
058AE:  BTFSC  FD8.2
058B0:  INCF   FEA,F
058B2:  BRA    5892
058B4:  RETURN 0
*
05DAE:  TBLRD*+
05DB0:  MOVFF  FF6,632
05DB4:  MOVFF  FF7,633
05DB8:  MOVFF  FF5,63E
05DBC:  RCALL  586A
05DBE:  MOVFF  632,FF6
05DC2:  MOVFF  633,FF7
05DC6:  MOVLB  6
05DC8:  DECFSZ x31,F
05DCA:  BRA    5DCE
05DCC:  BRA    5DD2
05DCE:  MOVLB  0
05DD0:  BRA    5DAE
05DD2:  MOVLB  0
05DD4:  RETURN 0
05DD6:  MOVLB  6
05DD8:  MOVF   x63,W
05DDA:  CLRF   01
05DDC:  SUBWF  x62,W
05DDE:  BC    5DE6
05DE0:  MOVFF  662,00
05DE4:  BRA    5DFE
05DE6:  CLRF   00
05DE8:  MOVLW  08
05DEA:  MOVWF  x64
05DEC:  RLCF   x62,F
05DEE:  RLCF   00,F
05DF0:  MOVF   x63,W
05DF2:  SUBWF  00,W
05DF4:  BTFSC  FD8.0
05DF6:  MOVWF  00
05DF8:  RLCF   01,F
05DFA:  DECFSZ x64,F
05DFC:  BRA    5DEC
05DFE:  MOVLB  0
05E00:  RETURN 0
05E02:  MOVF   01,W
05E04:  MOVFF  631,662
05E08:  MOVLW  64
05E0A:  MOVLB  6
05E0C:  MOVWF  x63
05E0E:  MOVLB  0
05E10:  RCALL  5DD6
05E12:  MOVFF  00,631
05E16:  MOVF   01,W
05E18:  MOVLW  30
05E1A:  BNZ   5E2C
05E1C:  MOVLB  6
05E1E:  BTFSS  x32.1
05E20:  BRA    5E40
05E22:  BTFSC  x32.3
05E24:  BRA    5E40
05E26:  BTFSC  x32.4
05E28:  MOVLW  20
05E2A:  BRA    5E34
05E2C:  MOVLB  6
05E2E:  BCF    x32.3
05E30:  BCF    x32.4
05E32:  BSF    x32.0
05E34:  ADDWF  01,F
05E36:  MOVFF  01,63E
05E3A:  MOVLB  0
05E3C:  RCALL  586A
05E3E:  MOVLB  6
05E40:  MOVFF  631,662
05E44:  MOVLW  0A
05E46:  MOVWF  x63
05E48:  MOVLB  0
05E4A:  RCALL  5DD6
05E4C:  MOVFF  00,631
05E50:  MOVF   01,W
05E52:  MOVLW  30
05E54:  BNZ   5E66
05E56:  MOVLB  6
05E58:  BTFSC  x32.3
05E5A:  BRA    5E70
05E5C:  BTFSS  x32.0
05E5E:  BRA    5E70
05E60:  BTFSC  x32.4
05E62:  MOVLW  20
05E64:  MOVLB  0
05E66:  ADDWF  01,F
05E68:  MOVFF  01,63E
05E6C:  RCALL  586A
05E6E:  MOVLB  6
05E70:  MOVLW  30
05E72:  ADDWF  x31,F
05E74:  MOVFF  631,63E
05E78:  MOVLB  0
05E7A:  RCALL  586A
05E7C:  RETURN 0
05E7E:  MOVLB  6
05E80:  MOVF   x78,W
05E82:  SUBLW  B6
05E84:  MOVWF  x78
05E86:  CLRF   03
05E88:  MOVFF  679,67C
05E8C:  BSF    x79.7
05E8E:  BCF    FD8.0
05E90:  RRCF   x79,F
05E92:  RRCF   x7A,F
05E94:  RRCF   x7B,F
05E96:  RRCF   03,F
05E98:  RRCF   02,F
05E9A:  RRCF   01,F
05E9C:  RRCF   00,F
05E9E:  DECFSZ x78,F
05EA0:  BRA    5E8E
05EA2:  BTFSS  x7C.7
05EA4:  BRA    5EBC
05EA6:  COMF   00,F
05EA8:  COMF   01,F
05EAA:  COMF   02,F
05EAC:  COMF   03,F
05EAE:  INCF   00,F
05EB0:  BTFSC  FD8.2
05EB2:  INCF   01,F
05EB4:  BTFSC  FD8.2
05EB6:  INCF   02,F
05EB8:  BTFSC  FD8.2
05EBA:  INCF   03,F
05EBC:  MOVLB  0
05EBE:  RETURN 0
05EC0:  BTFSC  FD8.1
05EC2:  BRA    5ECC
05EC4:  MOVLW  06
05EC6:  MOVWF  FEA
05EC8:  MOVLW  80
05ECA:  MOVWF  FE9
05ECC:  CLRF   00
05ECE:  CLRF   01
05ED0:  CLRF   02
05ED2:  CLRF   03
05ED4:  MOVLB  6
05ED6:  CLRF   x80
05ED8:  CLRF   x81
05EDA:  CLRF   x82
05EDC:  CLRF   x83
05EDE:  MOVF   x7F,W
05EE0:  IORWF  x7E,W
05EE2:  IORWF  x7D,W
05EE4:  IORWF  x7C,W
05EE6:  BZ    5F40
05EE8:  MOVLW  20
05EEA:  MOVWF  x84
05EEC:  BCF    FD8.0
05EEE:  RLCF   x78,F
05EF0:  RLCF   x79,F
05EF2:  RLCF   x7A,F
05EF4:  RLCF   x7B,F
05EF6:  RLCF   x80,F
05EF8:  RLCF   x81,F
05EFA:  RLCF   x82,F
05EFC:  RLCF   x83,F
05EFE:  MOVF   x7F,W
05F00:  SUBWF  x83,W
05F02:  BNZ   5F14
05F04:  MOVF   x7E,W
05F06:  SUBWF  x82,W
05F08:  BNZ   5F14
05F0A:  MOVF   x7D,W
05F0C:  SUBWF  x81,W
05F0E:  BNZ   5F14
05F10:  MOVF   x7C,W
05F12:  SUBWF  x80,W
05F14:  BNC   5F34
05F16:  MOVF   x7C,W
05F18:  SUBWF  x80,F
05F1A:  MOVF   x7D,W
05F1C:  BTFSS  FD8.0
05F1E:  INCFSZ x7D,W
05F20:  SUBWF  x81,F
05F22:  MOVF   x7E,W
05F24:  BTFSS  FD8.0
05F26:  INCFSZ x7E,W
05F28:  SUBWF  x82,F
05F2A:  MOVF   x7F,W
05F2C:  BTFSS  FD8.0
05F2E:  INCFSZ x7F,W
05F30:  SUBWF  x83,F
05F32:  BSF    FD8.0
05F34:  RLCF   00,F
05F36:  RLCF   01,F
05F38:  RLCF   02,F
05F3A:  RLCF   03,F
05F3C:  DECFSZ x84,F
05F3E:  BRA    5EEC
05F40:  MOVFF  680,FEF
05F44:  MOVFF  681,FEC
05F48:  MOVFF  682,FEC
05F4C:  MOVFF  683,FEC
05F50:  MOVLB  0
05F52:  RETURN 0
05F54:  MOVF   FE9,W
05F56:  MOVLB  6
05F58:  MOVWF  x36
05F5A:  MOVF   x35,W
05F5C:  MOVWF  x38
05F5E:  BZ    5F98
05F60:  MOVFF  634,67B
05F64:  MOVFF  633,67A
05F68:  MOVFF  632,679
05F6C:  MOVFF  631,678
05F70:  CLRF   x7F
05F72:  CLRF   x7E
05F74:  MOVLW  20
05F76:  MOVWF  x7D
05F78:  MOVLW  82
05F7A:  MOVWF  x7C
05F7C:  MOVLB  0
05F7E:  CALL   11F2
05F82:  MOVFF  03,634
05F86:  MOVFF  02,633
05F8A:  MOVFF  01,632
05F8E:  MOVFF  00,631
05F92:  MOVLB  6
05F94:  DECFSZ x38,F
05F96:  BRA    5F60
05F98:  MOVFF  634,67B
05F9C:  MOVFF  633,67A
05FA0:  MOVFF  632,679
05FA4:  MOVFF  631,678
05FA8:  MOVLB  0
05FAA:  RCALL  5E7E
05FAC:  MOVFF  03,634
05FB0:  MOVFF  02,633
05FB4:  MOVFF  01,632
05FB8:  MOVFF  00,631
05FBC:  MOVLB  6
05FBE:  BTFSS  x34.7
05FC0:  BRA    5FDC
05FC2:  DECF   x36,F
05FC4:  BSF    x36.5
05FC6:  COMF   x31,F
05FC8:  COMF   x32,F
05FCA:  COMF   x33,F
05FCC:  COMF   x34,F
05FCE:  INCF   x31,F
05FD0:  BTFSC  FD8.2
05FD2:  INCF   x32,F
05FD4:  BTFSC  FD8.2
05FD6:  INCF   x33,F
05FD8:  BTFSC  FD8.2
05FDA:  INCF   x34,F
05FDC:  MOVLW  3B
05FDE:  MOVWF  x3D
05FE0:  MOVLW  9A
05FE2:  MOVWF  x3C
05FE4:  MOVLW  CA
05FE6:  MOVWF  x3B
05FE8:  CLRF   x3A
05FEA:  MOVLW  0A
05FEC:  MOVWF  x38
05FEE:  MOVF   x35,W
05FF0:  BTFSC  FD8.2
05FF2:  INCF   x36,F
05FF4:  BSF    FD8.1
05FF6:  MOVLW  06
05FF8:  MOVWF  FEA
05FFA:  MOVLW  31
05FFC:  MOVWF  FE9
05FFE:  MOVFF  634,67B
06002:  MOVFF  633,67A
06006:  MOVFF  632,679
0600A:  MOVFF  631,678
0600E:  MOVFF  63D,67F
06012:  MOVFF  63C,67E
06016:  MOVFF  63B,67D
0601A:  MOVFF  63A,67C
0601E:  MOVLB  0
06020:  RCALL  5EC0
06022:  MOVF   01,W
06024:  MOVF   00,F
06026:  BNZ   604E
06028:  MOVLB  6
0602A:  INCF   x35,W
0602C:  SUBWF  x38,W
0602E:  BTFSS  FD8.2
06030:  BRA    6036
06032:  MOVLB  0
06034:  BRA    604E
06036:  MOVF   x36,W
06038:  BZ    6054
0603A:  ANDLW  0F
0603C:  SUBWF  x38,W
0603E:  BZ    6042
06040:  BC    60CA
06042:  BTFSC  x36.7
06044:  BRA    60CA
06046:  BTFSC  x36.6
06048:  BRA    6054
0604A:  MOVLW  20
0604C:  BRA    60BC
0604E:  MOVLW  20
06050:  MOVLB  6
06052:  ANDWF  x36,F
06054:  BTFSS  x36.5
06056:  BRA    6076
06058:  BCF    x36.5
0605A:  MOVF   x35,W
0605C:  BTFSS  FD8.2
0605E:  DECF   x36,F
06060:  MOVF   00,W
06062:  MOVWF  x36
06064:  MOVLW  2D
06066:  MOVWF  x3E
06068:  MOVLB  0
0606A:  CALL   586A
0606E:  MOVLB  6
06070:  MOVF   x36,W
06072:  MOVWF  00
06074:  CLRF   x36
06076:  MOVF   x35,W
06078:  SUBWF  x38,W
0607A:  BNZ   6096
0607C:  MOVF   00,W
0607E:  MOVWF  x36
06080:  MOVLW  2E
06082:  MOVWF  x3E
06084:  MOVLB  0
06086:  CALL   586A
0608A:  MOVLB  6
0608C:  MOVF   x36,W
0608E:  MOVWF  00
06090:  MOVLW  20
06092:  ANDWF  x36,F
06094:  MOVLW  00
06096:  MOVLW  30
06098:  BTFSS  x36.5
0609A:  BRA    60BC
0609C:  BCF    x36.5
0609E:  MOVF   x35,W
060A0:  BTFSS  FD8.2
060A2:  DECF   x36,F
060A4:  MOVF   00,W
060A6:  MOVWF  x36
060A8:  MOVLW  2D
060AA:  MOVWF  x3E
060AC:  MOVLB  0
060AE:  CALL   586A
060B2:  MOVLB  6
060B4:  MOVF   x36,W
060B6:  MOVWF  00
060B8:  CLRF   x36
060BA:  MOVLW  30
060BC:  ADDWF  00,F
060BE:  MOVFF  00,63E
060C2:  MOVLB  0
060C4:  CALL   586A
060C8:  MOVLB  6
060CA:  BCF    FD8.1
060CC:  MOVFF  63D,67B
060D0:  MOVFF  63C,67A
060D4:  MOVFF  63B,679
060D8:  MOVFF  63A,678
060DC:  CLRF   x7F
060DE:  CLRF   x7E
060E0:  CLRF   x7D
060E2:  MOVLW  0A
060E4:  MOVWF  x7C
060E6:  MOVLB  0
060E8:  RCALL  5EC0
060EA:  MOVFF  03,63D
060EE:  MOVFF  02,63C
060F2:  MOVFF  01,63B
060F6:  MOVFF  00,63A
060FA:  MOVLB  6
060FC:  DECFSZ x38,F
060FE:  BRA    5FF4
06100:  MOVLB  0
06102:  RETURN 0
06104:  MOVFF  FEA,635
06108:  MOVFF  FE9,634
0610C:  MOVLB  6
0610E:  SWAPF  x2E,W
06110:  IORLW  F0
06112:  MOVWF  x30
06114:  ADDWF  x30,F
06116:  ADDLW  E2
06118:  MOVWF  x31
0611A:  ADDLW  32
0611C:  MOVWF  x33
0611E:  MOVF   x2E,W
06120:  ANDLW  0F
06122:  ADDWF  x31,F
06124:  ADDWF  x31,F
06126:  ADDWF  x33,F
06128:  ADDLW  E9
0612A:  MOVWF  x32
0612C:  ADDWF  x32,F
0612E:  ADDWF  x32,F
06130:  SWAPF  x2D,W
06132:  ANDLW  0F
06134:  ADDWF  x32,F
06136:  ADDWF  x33,F
06138:  RLCF   x32,F
0613A:  RLCF   x33,F
0613C:  COMF   x33,F
0613E:  RLCF   x33,F
06140:  MOVF   x2D,W
06142:  ANDLW  0F
06144:  ADDWF  x33,F
06146:  RLCF   x30,F
06148:  MOVLW  07
0614A:  MOVWF  x2F
0614C:  MOVLW  0A
0614E:  DECF   x32,F
06150:  ADDWF  x33,F
06152:  BNC   614E
06154:  DECF   x31,F
06156:  ADDWF  x32,F
06158:  BNC   6154
0615A:  DECF   x30,F
0615C:  ADDWF  x31,F
0615E:  BNC   615A
06160:  DECF   x2F,F
06162:  ADDWF  x30,F
06164:  BNC   6160
06166:  MOVLW  06
06168:  MOVWF  FEA
0616A:  MOVLW  2F
0616C:  MOVWF  FE9
0616E:  MOVLW  07
06170:  ANDWF  x34,W
06172:  BCF    x34.6
06174:  ADDWF  FE9,F
06176:  MOVLW  00
06178:  ADDWFC FEA,F
0617A:  MOVF   FE9,W
0617C:  SUBLW  33
0617E:  BNZ   6188
06180:  MOVF   FEA,W
06182:  SUBLW  06
06184:  BNZ   6188
06186:  BSF    x34.6
06188:  MOVF   FEF,W
0618A:  MOVWF  00
0618C:  BNZ   619E
0618E:  BTFSC  x34.6
06190:  BRA    619E
06192:  BTFSC  x34.4
06194:  BRA    61C2
06196:  BTFSC  x34.3
06198:  BRA    619E
0619A:  MOVLW  20
0619C:  BRA    61A4
0619E:  BSF    x34.3
061A0:  BCF    x34.4
061A2:  MOVLW  30
061A4:  ADDWF  00,F
061A6:  MOVFF  FEA,62E
061AA:  MOVFF  FE9,62D
061AE:  MOVFF  00,63E
061B2:  MOVLB  0
061B4:  CALL   586A
061B8:  MOVFF  62E,FEA
061BC:  MOVFF  62D,FE9
061C0:  MOVLB  6
061C2:  MOVF   FEE,W
061C4:  BTFSS  x34.6
061C6:  BRA    617A
061C8:  MOVLB  0
061CA:  RETURN 0
*
06310:  MOVFF  51B,FEA
06314:  MOVFF  51A,FE9
06318:  MOVFF  678,FEF
0631C:  INCF   FE9,F
0631E:  BTFSC  FD8.2
06320:  INCF   FEA,F
06322:  CLRF   FEF
06324:  MOVLB  5
06326:  INCF   x1A,F
06328:  BTFSC  FD8.2
0632A:  INCF   x1B,F
0632C:  MOVLB  0
0632E:  RETURN 0
06330:  TBLRD*+
06332:  MOVF   FF5,F
06334:  BZ    634E
06336:  MOVFF  FF6,636
0633A:  MOVFF  FF7,637
0633E:  MOVFF  FF5,678
06342:  RCALL  6310
06344:  MOVFF  636,FF6
06348:  MOVFF  637,FF7
0634C:  BRA    6330
0634E:  RETURN 0
*
06472:  MOVLB  6
06474:  MOVF   x90,W
06476:  XORWF  x92,W
06478:  ANDLW  80
0647A:  MOVWF  x94
0647C:  BTFSS  x90.7
0647E:  BRA    648A
06480:  COMF   x8F,F
06482:  COMF   x90,F
06484:  INCF   x8F,F
06486:  BTFSC  FD8.2
06488:  INCF   x90,F
0648A:  BTFSS  x92.7
0648C:  BRA    6498
0648E:  COMF   x91,F
06490:  COMF   x92,F
06492:  INCF   x91,F
06494:  BTFSC  FD8.2
06496:  INCF   x92,F
06498:  MOVF   x8F,W
0649A:  MULWF  x91
0649C:  MOVFF  FF3,01
064A0:  MOVFF  FF4,00
064A4:  MULWF  x92
064A6:  MOVF   FF3,W
064A8:  ADDWF  00,F
064AA:  MOVF   x90,W
064AC:  MULWF  x91
064AE:  MOVF   FF3,W
064B0:  ADDWFC 00,W
064B2:  MOVWF  02
064B4:  BTFSS  x94.7
064B6:  BRA    64C2
064B8:  COMF   01,F
064BA:  COMF   02,F
064BC:  INCF   01,F
064BE:  BTFSC  FD8.2
064C0:  INCF   02,F
064C2:  MOVLB  0
064C4:  GOTO   6758 (RETURN)
*
0681C:  MOVLW  20
0681E:  MOVLB  6
06820:  BTFSS  x5D.4
06822:  MOVLW  30
06824:  MOVWF  x5E
06826:  MOVFF  65C,00
0682A:  BTFSS  00.7
0682C:  BRA    683E
0682E:  COMF   00,F
06830:  INCF   00,F
06832:  MOVFF  00,65C
06836:  MOVLW  2D
06838:  MOVWF  x5E
0683A:  BSF    x5D.7
0683C:  BSF    x5D.0
0683E:  MOVF   01,W
06840:  MOVFF  65C,662
06844:  MOVLW  64
06846:  MOVWF  x63
06848:  MOVLB  0
0684A:  CALL   5DD6
0684E:  MOVFF  00,65C
06852:  MOVLW  30
06854:  ADDWF  01,W
06856:  MOVLB  6
06858:  MOVWF  x5F
0685A:  MOVFF  65C,662
0685E:  MOVLW  0A
06860:  MOVWF  x63
06862:  MOVLB  0
06864:  CALL   5DD6
06868:  MOVLW  30
0686A:  ADDWF  00,W
0686C:  MOVLB  6
0686E:  MOVWF  x61
06870:  MOVLW  30
06872:  ADDWF  01,W
06874:  MOVWF  x60
06876:  MOVFF  65E,00
0687A:  MOVLW  30
0687C:  SUBWF  x5F,W
0687E:  BZ    6888
06880:  BSF    x5D.1
06882:  BTFSC  x5D.7
06884:  BSF    x5D.2
06886:  BRA    68AC
06888:  MOVFF  65E,65F
0688C:  MOVLW  20
0688E:  MOVWF  x5E
06890:  MOVLW  30
06892:  SUBWF  x60,W
06894:  BZ    689E
06896:  BSF    x5D.0
06898:  BTFSC  x5D.7
0689A:  BSF    x5D.1
0689C:  BRA    68AC
0689E:  BTFSS  FD8.2
068A0:  BSF    x5D.0
068A2:  BNZ   68AC
068A4:  MOVFF  65F,660
068A8:  MOVLW  20
068AA:  MOVWF  x5F
068AC:  BTFSC  x5D.2
068AE:  BRA    68BA
068B0:  BTFSC  x5D.1
068B2:  BRA    68C2
068B4:  BTFSC  x5D.0
068B6:  BRA    68CA
068B8:  BRA    68D2
068BA:  MOVFF  65E,678
068BE:  MOVLB  0
068C0:  RCALL  6310
068C2:  MOVFF  65F,678
068C6:  MOVLB  0
068C8:  RCALL  6310
068CA:  MOVFF  660,678
068CE:  MOVLB  0
068D0:  RCALL  6310
068D2:  MOVFF  661,678
068D6:  MOVLB  0
068D8:  RCALL  6310
068DA:  RETURN 0
*
06A78:  MOVLB  6
06A7A:  MOVF   x4A,W
06A7C:  ANDLW  07
06A7E:  MOVWF  00
06A80:  RRCF   x4A,W
06A82:  MOVWF  01
06A84:  RRCF   01,F
06A86:  RRCF   01,F
06A88:  MOVLW  1F
06A8A:  ANDWF  01,F
06A8C:  MOVF   01,W
06A8E:  ADDWF  x4C,W
06A90:  MOVWF  FE9
06A92:  MOVLW  00
06A94:  ADDWFC x4D,W
06A96:  MOVWF  FEA
06A98:  CLRF   01
06A9A:  INCF   01,F
06A9C:  INCF   00,F
06A9E:  BRA    6AA2
06AA0:  RLCF   01,F
06AA2:  DECFSZ 00,F
06AA4:  BRA    6AA0
06AA6:  MOVF   x4B,F
06AA8:  BZ    6AB0
06AAA:  MOVF   01,W
06AAC:  IORWF  FEF,F
06AAE:  BRA    6AB6
06AB0:  COMF   01,F
06AB2:  MOVF   01,W
06AB4:  ANDWF  FEF,F
06AB6:  MOVLB  0
06AB8:  RETURN 0
*
06C68:  TBLRD*+
06C6A:  MOVFF  FF6,638
06C6E:  MOVFF  FF7,639
06C72:  MOVFF  FF5,678
06C76:  CALL   6310
06C7A:  MOVFF  638,FF6
06C7E:  MOVFF  639,FF7
06C82:  MOVLB  6
06C84:  DECFSZ x37,F
06C86:  BRA    6C8A
06C88:  BRA    6C8E
06C8A:  MOVLB  0
06C8C:  BRA    6C68
06C8E:  MOVLB  0
06C90:  RETURN 0
*
07038:  MOVF   FE9,W
0703A:  MOVLB  6
0703C:  MOVWF  x70
0703E:  MOVF   x6F,W
07040:  MOVWF  x72
07042:  BZ    707C
07044:  MOVFF  66E,67B
07048:  MOVFF  66D,67A
0704C:  MOVFF  66C,679
07050:  MOVFF  66B,678
07054:  CLRF   x7F
07056:  CLRF   x7E
07058:  MOVLW  20
0705A:  MOVWF  x7D
0705C:  MOVLW  82
0705E:  MOVWF  x7C
07060:  MOVLB  0
07062:  CALL   11F2
07066:  MOVFF  03,66E
0706A:  MOVFF  02,66D
0706E:  MOVFF  01,66C
07072:  MOVFF  00,66B
07076:  MOVLB  6
07078:  DECFSZ x72,F
0707A:  BRA    7044
0707C:  MOVFF  66E,67B
07080:  MOVFF  66D,67A
07084:  MOVFF  66C,679
07088:  MOVFF  66B,678
0708C:  MOVLB  0
0708E:  CALL   5E7E
07092:  MOVFF  03,66E
07096:  MOVFF  02,66D
0709A:  MOVFF  01,66C
0709E:  MOVFF  00,66B
070A2:  MOVLB  6
070A4:  BTFSS  x6E.7
070A6:  BRA    70C2
070A8:  DECF   x70,F
070AA:  BSF    x70.5
070AC:  COMF   x6B,F
070AE:  COMF   x6C,F
070B0:  COMF   x6D,F
070B2:  COMF   x6E,F
070B4:  INCF   x6B,F
070B6:  BTFSC  FD8.2
070B8:  INCF   x6C,F
070BA:  BTFSC  FD8.2
070BC:  INCF   x6D,F
070BE:  BTFSC  FD8.2
070C0:  INCF   x6E,F
070C2:  MOVLW  3B
070C4:  MOVWF  x77
070C6:  MOVLW  9A
070C8:  MOVWF  x76
070CA:  MOVLW  CA
070CC:  MOVWF  x75
070CE:  CLRF   x74
070D0:  MOVLW  0A
070D2:  MOVWF  x72
070D4:  MOVF   x6F,W
070D6:  BTFSC  FD8.2
070D8:  INCF   x70,F
070DA:  BSF    FD8.1
070DC:  MOVLW  06
070DE:  MOVWF  FEA
070E0:  MOVLW  6B
070E2:  MOVWF  FE9
070E4:  MOVFF  66E,67B
070E8:  MOVFF  66D,67A
070EC:  MOVFF  66C,679
070F0:  MOVFF  66B,678
070F4:  MOVFF  677,67F
070F8:  MOVFF  676,67E
070FC:  MOVFF  675,67D
07100:  MOVFF  674,67C
07104:  MOVLB  0
07106:  CALL   5EC0
0710A:  MOVF   01,W
0710C:  MOVF   00,F
0710E:  BNZ   7136
07110:  MOVLB  6
07112:  INCF   x6F,W
07114:  SUBWF  x72,W
07116:  BTFSS  FD8.2
07118:  BRA    711E
0711A:  MOVLB  0
0711C:  BRA    7136
0711E:  MOVF   x70,W
07120:  BZ    713C
07122:  ANDLW  0F
07124:  SUBWF  x72,W
07126:  BZ    712A
07128:  BC    71B2
0712A:  BTFSC  x70.7
0712C:  BRA    71B2
0712E:  BTFSC  x70.6
07130:  BRA    713C
07132:  MOVLW  20
07134:  BRA    71A4
07136:  MOVLW  20
07138:  MOVLB  6
0713A:  ANDWF  x70,F
0713C:  BTFSS  x70.5
0713E:  BRA    715E
07140:  BCF    x70.5
07142:  MOVF   x6F,W
07144:  BTFSS  FD8.2
07146:  DECF   x70,F
07148:  MOVF   00,W
0714A:  MOVWF  x70
0714C:  MOVLW  2D
0714E:  MOVWF  x78
07150:  MOVLB  0
07152:  CALL   6310
07156:  MOVLB  6
07158:  MOVF   x70,W
0715A:  MOVWF  00
0715C:  CLRF   x70
0715E:  MOVF   x6F,W
07160:  SUBWF  x72,W
07162:  BNZ   717E
07164:  MOVF   00,W
07166:  MOVWF  x70
07168:  MOVLW  2E
0716A:  MOVWF  x78
0716C:  MOVLB  0
0716E:  CALL   6310
07172:  MOVLB  6
07174:  MOVF   x70,W
07176:  MOVWF  00
07178:  MOVLW  20
0717A:  ANDWF  x70,F
0717C:  MOVLW  00
0717E:  MOVLW  30
07180:  BTFSS  x70.5
07182:  BRA    71A4
07184:  BCF    x70.5
07186:  MOVF   x6F,W
07188:  BTFSS  FD8.2
0718A:  DECF   x70,F
0718C:  MOVF   00,W
0718E:  MOVWF  x70
07190:  MOVLW  2D
07192:  MOVWF  x78
07194:  MOVLB  0
07196:  CALL   6310
0719A:  MOVLB  6
0719C:  MOVF   x70,W
0719E:  MOVWF  00
071A0:  CLRF   x70
071A2:  MOVLW  30
071A4:  ADDWF  00,F
071A6:  MOVFF  00,678
071AA:  MOVLB  0
071AC:  CALL   6310
071B0:  MOVLB  6
071B2:  BCF    FD8.1
071B4:  MOVFF  677,67B
071B8:  MOVFF  676,67A
071BC:  MOVFF  675,679
071C0:  MOVFF  674,678
071C4:  CLRF   x7F
071C6:  CLRF   x7E
071C8:  CLRF   x7D
071CA:  MOVLW  0A
071CC:  MOVWF  x7C
071CE:  MOVLB  0
071D0:  CALL   5EC0
071D4:  MOVFF  03,677
071D8:  MOVFF  02,676
071DC:  MOVFF  01,675
071E0:  MOVFF  00,674
071E4:  MOVLB  6
071E6:  DECFSZ x72,F
071E8:  BRA    70DA
071EA:  MOVLB  0
071EC:  RETURN 0
*
09C56:  MOVF   FE9,W
09C58:  MOVLB  6
09C5A:  MOVWF  x65
09C5C:  BTFSS  x64.7
09C5E:  BRA    9C7A
09C60:  DECF   x65,F
09C62:  BSF    x65.5
09C64:  COMF   x61,F
09C66:  COMF   x62,F
09C68:  COMF   x63,F
09C6A:  COMF   x64,F
09C6C:  INCF   x61,F
09C6E:  BTFSC  FD8.2
09C70:  INCF   x62,F
09C72:  BTFSC  FD8.2
09C74:  INCF   x63,F
09C76:  BTFSC  FD8.2
09C78:  INCF   x64,F
09C7A:  MOVLW  3B
09C7C:  MOVWF  x6C
09C7E:  MOVLW  9A
09C80:  MOVWF  x6B
09C82:  MOVLW  CA
09C84:  MOVWF  x6A
09C86:  CLRF   x69
09C88:  MOVLW  0A
09C8A:  MOVWF  x67
09C8C:  BSF    FD8.1
09C8E:  MOVLW  06
09C90:  MOVWF  FEA
09C92:  MOVLW  61
09C94:  MOVWF  FE9
09C96:  MOVFF  664,67B
09C9A:  MOVFF  663,67A
09C9E:  MOVFF  662,679
09CA2:  MOVFF  661,678
09CA6:  MOVFF  66C,67F
09CAA:  MOVFF  66B,67E
09CAE:  MOVFF  66A,67D
09CB2:  MOVFF  669,67C
09CB6:  MOVLB  0
09CB8:  CALL   5EC0
09CBC:  MOVF   01,W
09CBE:  MOVF   00,F
09CC0:  BNZ   9CE8
09CC2:  MOVLB  6
09CC4:  MOVF   x67,W
09CC6:  XORLW  01
09CC8:  BTFSS  FD8.2
09CCA:  BRA    9CD0
09CCC:  MOVLB  0
09CCE:  BRA    9CE8
09CD0:  MOVF   x65,W
09CD2:  BZ    9CEE
09CD4:  ANDLW  0F
09CD6:  SUBWF  x67,W
09CD8:  BZ    9CDC
09CDA:  BC    9D38
09CDC:  BTFSC  x65.7
09CDE:  BRA    9D38
09CE0:  BTFSC  x65.6
09CE2:  BRA    9CEE
09CE4:  MOVLW  20
09CE6:  BRA    9D2A
09CE8:  MOVLW  20
09CEA:  MOVLB  6
09CEC:  ANDWF  x65,F
09CEE:  BTFSS  x65.5
09CF0:  BRA    9D0A
09CF2:  BCF    x65.5
09CF4:  MOVFF  00,665
09CF8:  MOVLW  2D
09CFA:  MOVWF  x78
09CFC:  MOVLB  0
09CFE:  CALL   6310
09D02:  MOVLB  6
09D04:  MOVFF  665,00
09D08:  CLRF   x65
09D0A:  MOVLW  30
09D0C:  BTFSS  x65.5
09D0E:  BRA    9D2A
09D10:  BCF    x65.5
09D12:  MOVFF  00,665
09D16:  MOVLW  2D
09D18:  MOVWF  x78
09D1A:  MOVLB  0
09D1C:  CALL   6310
09D20:  MOVLB  6
09D22:  MOVFF  665,00
09D26:  CLRF   x65
09D28:  MOVLW  30
09D2A:  ADDWF  00,F
09D2C:  MOVFF  00,678
09D30:  MOVLB  0
09D32:  CALL   6310
09D36:  MOVLB  6
09D38:  BCF    FD8.1
09D3A:  MOVFF  66C,67B
09D3E:  MOVFF  66B,67A
09D42:  MOVFF  66A,679
09D46:  MOVFF  669,678
09D4A:  CLRF   x7F
09D4C:  CLRF   x7E
09D4E:  CLRF   x7D
09D50:  MOVLW  0A
09D52:  MOVWF  x7C
09D54:  MOVLB  0
09D56:  CALL   5EC0
09D5A:  MOVFF  03,66C
09D5E:  MOVFF  02,66B
09D62:  MOVFF  01,66A
09D66:  MOVFF  00,669
09D6A:  MOVLB  6
09D6C:  DECFSZ x67,F
09D6E:  BRA    9C8C
09D70:  MOVLB  0
09D72:  RETURN 0
*
0A9B6:  MOVF   FEF,F
0A9B8:  BZ    A9DA
0A9BA:  MOVFF  FEA,62E
0A9BE:  MOVFF  FE9,62D
0A9C2:  MOVFF  FEF,678
0A9C6:  CALL   6310
0A9CA:  MOVFF  62E,FEA
0A9CE:  MOVFF  62D,FE9
0A9D2:  INCF   FE9,F
0A9D4:  BTFSC  FD8.2
0A9D6:  INCF   FEA,F
0A9D8:  BRA    A9B6
0A9DA:  GOTO   AA58 (RETURN)
.................... 
.................... #list
.................... 
.................... 
.................... #device ADC=10
.................... 
.................... //!#FUSES WDT                      //Watch Dog Timer
.................... //!#FUSES WDT4096                  //Watch Dog Timer uses 1:4096 Postscale
.................... 
.................... #use delay(internal=64000000)
*
00438:  MOVLW  06
0043A:  MOVWF  FEA
0043C:  MOVLW  30
0043E:  MOVWF  FE9
00440:  MOVF   FEF,W
00442:  BZ    0460
00444:  MOVLW  14
00446:  MOVWF  01
00448:  CLRF   00
0044A:  DECFSZ 00,F
0044C:  BRA    044A
0044E:  DECFSZ 01,F
00450:  BRA    0448
00452:  MOVLW  BF
00454:  MOVWF  00
00456:  DECFSZ 00,F
00458:  BRA    0456
0045A:  BRA    045C
0045C:  DECFSZ FEF,F
0045E:  BRA    0444
00460:  RETURN 0
*
00700:  MOVLW  01
00702:  MOVLB  6
00704:  SUBWF  x35,F
00706:  BNC   0720
00708:  MOVLW  06
0070A:  MOVWF  FEA
0070C:  MOVLW  35
0070E:  MOVWF  FE9
00710:  MOVF   FEF,W
00712:  BZ    0720
00714:  MOVLW  04
00716:  MOVWF  00
00718:  DECFSZ 00,F
0071A:  BRA    0718
0071C:  DECFSZ FEF,F
0071E:  BRA    0714
00720:  MOVLB  0
00722:  GOTO   0768 (RETURN)
.................... #define baudRate 128000
.................... #define numChannels 2
.................... 
.................... #define version  "20251104" // SW Version
.................... #define serialID "0000"     // Unique Serial ID
.................... #define magPP 1             // Magnetoresistive Sensor Pole Pitch in mm   
.................... #define gainLvl 16          // 1, 2, 4, 8, 16, 32, 64, 128
.................... 
.................... 
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
*
003A2:  MOVLW  CF
003A4:  MOVWF  F87
003A6:  CLRF   F82
....................    output_b(portB_reset);
003A8:  MOVLW  C4
003AA:  MOVWF  F88
003AC:  CLRF   F83
....................    output_c(portC_reset);
003AE:  MOVLW  93
003B0:  MOVWF  F89
003B2:  CLRF   F84
....................    output_d(portD_reset);
003B4:  MOVLW  1F
003B6:  MOVWF  F8A
003B8:  CLRF   F85
....................    output_e(portE_reset);
003BA:  BCF    F8B.0
003BC:  BCF    F8B.1
003BE:  BCF    F8B.2
003C0:  BCF    F8B.3
003C2:  CLRF   F86
....................    
....................    port_a_pullups(portA_pullups);
003C4:  MOVLB  F
003C6:  SETF   x0B
....................    port_b_pullups(portB_pullups);
003C8:  CLRF   x13
....................    port_c_pullups(portC_pullups);
003CA:  CLRF   x1B
....................    port_d_pullups(portD_pullups);
003CC:  SETF   x20
....................    port_e_pullups(portE_pullups);
003CE:  CLRF   x28
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
003D0:  MOVLW  40
003D2:  MOVWF  x0C
003D4:  CLRF   x14
003D6:  MOVLW  03
003D8:  MOVWF  x1C
003DA:  MOVLW  0F
003DC:  MOVWF  x21
003DE:  CLRF   x29
003E0:  MOVLB  0
003E2:  GOTO   AE7C (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
*
06298:  MOVFF  66A,FEA
0629C:  MOVLB  6
0629E:  MOVFF  669,FE9
062A2:  MOVFF  FEF,66D
062A6:  MOVFF  66C,FEA
062AA:  MOVFF  66B,FE9
062AE:  MOVF   FEF,W
062B0:  SUBWF  x6D,W
062B2:  BNZ   62E2
....................       if (*s1 == '\0')
062B4:  MOVFF  66A,03
062B8:  MOVFF  669,FE9
062BC:  MOVFF  03,FEA
062C0:  MOVF   FEF,F
062C2:  BNZ   62CA
....................          return(0);
062C4:  MOVLW  00
062C6:  MOVWF  01
062C8:  BRA    630C
062CA:  MOVFF  66A,03
062CE:  MOVF   x69,W
062D0:  INCF   x69,F
062D2:  BTFSC  FD8.2
062D4:  INCF   x6A,F
062D6:  INCF   x6B,F
062D8:  BTFSC  FD8.2
062DA:  INCF   x6C,F
062DC:  MOVLB  0
062DE:  BRA    6298
062E0:  MOVLB  6
....................    return((*s1 < *s2) ? -1: 1);
062E2:  MOVFF  66A,03
062E6:  MOVFF  669,FE9
062EA:  MOVFF  03,FEA
062EE:  MOVFF  FEF,66D
062F2:  MOVFF  66C,03
062F6:  MOVFF  66B,FE9
062FA:  MOVFF  03,FEA
062FE:  MOVF   FEF,W
06300:  SUBWF  x6D,W
06302:  BC    6308
06304:  MOVLW  FF
06306:  BRA    630A
06308:  MOVLW  01
0630A:  MOVWF  01
0630C:  MOVLB  0
0630E:  RETURN 0
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
*
06428:  MOVFF  690,693
....................    for(su=s;0<n;++su,--n)
0642C:  MOVFF  68F,695
06430:  MOVFF  68E,694
06434:  MOVLB  6
06436:  MOVF   x92,F
06438:  BNZ   6440
0643A:  MOVF   x91,W
0643C:  SUBLW  00
0643E:  BC    6468
....................       if(*su==uc)
06440:  MOVFF  695,FEA
06444:  MOVFF  694,FE9
06448:  MOVF   x93,W
0644A:  SUBWF  FEF,W
0644C:  BNZ   6458
....................       return su;
0644E:  MOVFF  694,01
06452:  MOVFF  695,02
06456:  BRA    646E
06458:  INCF   x94,F
0645A:  BTFSC  FD8.2
0645C:  INCF   x95,F
0645E:  MOVF   x91,W
06460:  BTFSC  FD8.2
06462:  DECF   x92,F
06464:  DECF   x91,F
06466:  BRA    6436
....................    return NULL;
06468:  MOVLW  00
0646A:  MOVWF  01
0646C:  MOVWF  02
0646E:  MOVLB  0
06470:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
*
06260:  MOVFF  66A,66C
06264:  MOVFF  669,66B
06268:  MOVFF  66C,FEA
0626C:  MOVLB  6
0626E:  MOVFF  66B,FE9
06272:  MOVF   FEF,F
06274:  BZ    6282
06276:  INCF   x6B,F
06278:  BTFSC  FD8.2
0627A:  INCF   x6C,F
0627C:  MOVLB  0
0627E:  BRA    6268
06280:  MOVLB  6
....................    return(sc - s);
06282:  MOVF   x69,W
06284:  SUBWF  x6B,W
06286:  MOVWF  00
06288:  MOVF   x6A,W
0628A:  SUBWFB x6C,W
0628C:  MOVWF  03
0628E:  MOVFF  00,01
06292:  MOVWF  02
06294:  MOVLB  0
06296:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
*
07766:  MOVLB  6
07768:  CLRF   x43
0776A:  CLRF   x42
0776C:  CLRF   x41
0776E:  MOVLW  7F
07770:  MOVWF  x40
07772:  CLRF   x47
07774:  CLRF   x46
07776:  CLRF   x45
07778:  CLRF   x44
0777A:  BSF    x48.0
0777C:  BCF    x48.1
0777E:  BCF    x48.2
07780:  CLRF   x4A
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
07782:  MOVF   x3C,W
07784:  IORWF  x3D,W
07786:  BNZ   7792
....................       return 0;
07788:  CLRF   00
0778A:  CLRF   01
0778C:  CLRF   02
0778E:  CLRF   03
07790:  BRA    79BC
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
07792:  MOVF   x4A,W
07794:  INCF   x4A,F
07796:  ADDWF  x3C,W
07798:  MOVWF  FE9
0779A:  MOVLW  00
0779C:  ADDWFC x3D,W
0779E:  MOVWF  FEA
077A0:  MOVFF  FEF,649
077A4:  MOVF   x49,F
077A6:  BTFSC  FD8.2
077A8:  BRA    7940
....................    {
....................       if (skip && !isspace(c))
077AA:  BTFSS  x48.0
077AC:  BRA    77CC
077AE:  MOVF   x49,W
077B0:  SUBLW  20
077B2:  BZ    77CC
....................       {
....................          skip = 0;
077B4:  BCF    x48.0
....................          if (c == '+')
077B6:  MOVF   x49,W
077B8:  SUBLW  2B
077BA:  BNZ   77C2
....................          {
....................             sign = 0;
077BC:  BCF    x48.1
....................             continue;
077BE:  BRA    7928
....................          }            
077C0:  BRA    77CC
....................          else if (c == '-')
077C2:  MOVF   x49,W
077C4:  SUBLW  2D
077C6:  BNZ   77CC
....................          {
....................             sign = 1;
077C8:  BSF    x48.1
....................             continue;
077CA:  BRA    7928
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
077CC:  BTFSC  x48.0
077CE:  BRA    77DE
077D0:  MOVF   x49,W
077D2:  SUBLW  2E
077D4:  BNZ   77DE
077D6:  BTFSC  x48.2
077D8:  BRA    77DE
....................          point = 1;
077DA:  BSF    x48.2
077DC:  BRA    7928
....................       else if (!skip && isdigit(c))
077DE:  BTFSC  x48.0
077E0:  BRA    7922
077E2:  MOVF   x49,W
077E4:  SUBLW  2F
077E6:  BTFSC  FD8.0
077E8:  BRA    7922
077EA:  MOVF   x49,W
077EC:  SUBLW  39
077EE:  BTFSS  FD8.0
077F0:  BRA    7922
....................       {
....................          c -= '0';
077F2:  MOVLW  30
077F4:  SUBWF  x49,F
....................          if (point)
077F6:  BTFSS  x48.2
077F8:  BRA    78A8
....................          {
....................             pow10 = pow10 * 10.0;
077FA:  MOVFF  643,67B
077FE:  MOVFF  642,67A
07802:  MOVFF  641,679
07806:  MOVFF  640,678
0780A:  CLRF   x7F
0780C:  CLRF   x7E
0780E:  MOVLW  20
07810:  MOVWF  x7D
07812:  MOVLW  82
07814:  MOVWF  x7C
07816:  MOVLB  0
07818:  CALL   11F2
0781C:  MOVFF  03,643
07820:  MOVFF  02,642
07824:  MOVFF  01,641
07828:  MOVFF  00,640
....................             result += (float)c / pow10;   
0782C:  MOVLB  6
0782E:  CLRF   x78
07830:  MOVFF  649,677
07834:  MOVLB  0
07836:  CALL   11BC
0783A:  MOVFF  03,64E
0783E:  MOVFF  02,64D
07842:  MOVFF  01,64C
07846:  MOVFF  00,64B
0784A:  MOVFF  03,66F
0784E:  MOVFF  02,66E
07852:  MOVFF  01,66D
07856:  MOVFF  00,66C
0785A:  MOVFF  643,673
0785E:  MOVFF  642,672
07862:  MOVFF  641,671
07866:  MOVFF  640,670
0786A:  CALL   266A
0786E:  BCF    FD8.1
07870:  MOVFF  647,67A
07874:  MOVFF  646,679
07878:  MOVFF  645,678
0787C:  MOVFF  644,677
07880:  MOVFF  03,67E
07884:  MOVFF  02,67D
07888:  MOVFF  01,67C
0788C:  MOVFF  00,67B
07890:  CALL   12E8
07894:  MOVFF  03,647
07898:  MOVFF  02,646
0789C:  MOVFF  01,645
078A0:  MOVFF  00,644
....................          }
078A4:  BRA    791E
078A6:  MOVLB  6
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
078A8:  CLRF   x7B
078AA:  CLRF   x7A
078AC:  MOVLW  20
078AE:  MOVWF  x79
078B0:  MOVLW  82
078B2:  MOVWF  x78
078B4:  MOVFF  647,67F
078B8:  MOVFF  646,67E
078BC:  MOVFF  645,67D
078C0:  MOVFF  644,67C
078C4:  MOVLB  0
078C6:  CALL   11F2
078CA:  MOVFF  03,64E
078CE:  MOVFF  02,64D
078D2:  MOVFF  01,64C
078D6:  MOVFF  00,64B
078DA:  MOVLB  6
078DC:  CLRF   x78
078DE:  MOVFF  649,677
078E2:  MOVLB  0
078E4:  CALL   11BC
078E8:  BCF    FD8.1
078EA:  MOVFF  64E,67A
078EE:  MOVFF  64D,679
078F2:  MOVFF  64C,678
078F6:  MOVFF  64B,677
078FA:  MOVFF  03,67E
078FE:  MOVFF  02,67D
07902:  MOVFF  01,67C
07906:  MOVFF  00,67B
0790A:  CALL   12E8
0790E:  MOVFF  03,647
07912:  MOVFF  02,646
07916:  MOVFF  01,645
0791A:  MOVFF  00,644
....................          }
....................       }
0791E:  BRA    792A
07920:  MOVLB  6
....................       else if (!skip)
07922:  BTFSC  x48.0
07924:  BRA    7928
....................          break;
07926:  BRA    7940
07928:  MOVLB  0
0792A:  MOVLB  6
0792C:  MOVF   x4A,W
0792E:  INCF   x4A,F
07930:  ADDWF  x3C,W
07932:  MOVWF  FE9
07934:  MOVLW  00
07936:  ADDWFC x3D,W
07938:  MOVWF  FEA
0793A:  MOVFF  FEF,649
0793E:  BRA    77A4
....................    }
.................... 
....................    if (sign)
07940:  BTFSS  x48.1
07942:  BRA    7978
....................       result = -1*result;
07944:  CLRF   x7B
07946:  CLRF   x7A
07948:  MOVLW  80
0794A:  MOVWF  x79
0794C:  MOVLW  7F
0794E:  MOVWF  x78
07950:  MOVFF  647,67F
07954:  MOVFF  646,67E
07958:  MOVFF  645,67D
0795C:  MOVFF  644,67C
07960:  MOVLB  0
07962:  CALL   11F2
07966:  MOVFF  03,647
0796A:  MOVFF  02,646
0796E:  MOVFF  01,645
07972:  MOVFF  00,644
07976:  MOVLB  6
....................       
....................    if(endptr)
07978:  MOVF   x3E,W
0797A:  IORWF  x3F,W
0797C:  BZ    79AC
....................    {
....................       if (ptr) {
0797E:  MOVF   x4A,F
07980:  BZ    799A
....................          ptr--;
07982:  DECF   x4A,F
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
07984:  MOVFF  63F,FEA
07988:  MOVFF  63E,FE9
0798C:  MOVF   x4A,W
0798E:  ADDWF  x3C,W
07990:  MOVWF  FEF
07992:  MOVLW  00
07994:  ADDWFC x3D,W
07996:  MOVWF  FEC
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
07998:  BRA    79AC
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
0799A:  MOVFF  63F,FEA
0799E:  MOVFF  63E,FE9
079A2:  MOVFF  63D,FEC
079A6:  MOVF   FED,F
079A8:  MOVFF  63C,FEF
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
079AC:  MOVFF  644,00
079B0:  MOVFF  645,01
079B4:  MOVFF  646,02
079B8:  MOVFF  647,03
079BC:  MOVLB  0
079BE:  RETURN 0
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
*
064C8:  MOVLB  6
064CA:  CLRF   x67
064CC:  CLRF   x66
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
064CE:  MOVLW  30
064D0:  MOVWF  x69
064D2:  MOVLW  31
064D4:  MOVWF  x6A
064D6:  MOVLW  32
064D8:  MOVWF  x6B
064DA:  MOVLW  33
064DC:  MOVWF  x6C
064DE:  MOVLW  34
064E0:  MOVWF  x6D
064E2:  MOVLW  35
064E4:  MOVWF  x6E
064E6:  MOVLW  36
064E8:  MOVWF  x6F
064EA:  MOVLW  37
064EC:  MOVWF  x70
064EE:  MOVLW  38
064F0:  MOVWF  x71
064F2:  MOVLW  39
064F4:  MOVWF  x72
064F6:  MOVLW  61
064F8:  MOVWF  x73
064FA:  MOVLW  62
064FC:  MOVWF  x74
064FE:  MOVLW  63
06500:  MOVWF  x75
06502:  MOVLW  64
06504:  MOVWF  x76
06506:  MOVLW  65
06508:  MOVWF  x77
0650A:  MOVLW  66
0650C:  MOVWF  x78
0650E:  MOVLW  67
06510:  MOVWF  x79
06512:  MOVLW  68
06514:  MOVWF  x7A
06516:  MOVLW  69
06518:  MOVWF  x7B
0651A:  MOVLW  6A
0651C:  MOVWF  x7C
0651E:  MOVLW  6B
06520:  MOVWF  x7D
06522:  MOVLW  6C
06524:  MOVWF  x7E
06526:  MOVLW  6D
06528:  MOVWF  x7F
0652A:  MOVLW  6E
0652C:  MOVWF  x80
0652E:  MOVLW  6F
06530:  MOVWF  x81
06532:  MOVLW  70
06534:  MOVWF  x82
06536:  MOVLW  71
06538:  MOVWF  x83
0653A:  MOVLW  73
0653C:  MOVWF  x84
0653E:  MOVLW  74
06540:  MOVWF  x85
06542:  MOVLW  75
06544:  MOVWF  x86
06546:  MOVLW  76
06548:  MOVWF  x87
0654A:  MOVLW  77
0654C:  MOVWF  x88
0654E:  MOVLW  78
06550:  MOVWF  x89
06552:  MOVLW  79
06554:  MOVWF  x8A
06556:  MOVLW  7A
06558:  MOVWF  x8B
0655A:  CLRF   x8C
....................    for(sc=s;isspace(*sc);++sc);
0655C:  MOVFF  65C,661
06560:  MOVFF  65B,660
06564:  MOVFF  661,FEA
06568:  MOVFF  660,FE9
0656C:  MOVF   FEF,W
0656E:  SUBLW  20
06570:  BNZ   657A
06572:  INCF   x60,F
06574:  BTFSC  FD8.2
06576:  INCF   x61,F
06578:  BRA    6564
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
0657A:  MOVFF  661,03
0657E:  MOVFF  660,FE9
06582:  MOVFF  03,FEA
06586:  MOVF   FEF,W
06588:  SUBLW  2D
0658A:  BZ    659A
0658C:  MOVFF  661,FEA
06590:  MOVFF  660,FE9
06594:  MOVF   FEF,W
06596:  SUBLW  2B
06598:  BNZ   65AC
0659A:  MOVFF  661,FEA
0659E:  MOVF   x60,W
065A0:  INCF   x60,F
065A2:  BTFSC  FD8.2
065A4:  INCF   x61,F
065A6:  MOVWF  FE9
065A8:  MOVF   FEF,W
065AA:  BRA    65AE
065AC:  MOVLW  2B
065AE:  MOVWF  x68
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
065B0:  MOVF   x68,W
065B2:  SUBLW  2D
065B4:  BZ    65CA
065B6:  BTFSC  x5F.7
065B8:  BRA    65CA
065BA:  DECFSZ x5F,W
065BC:  BRA    65C0
065BE:  BRA    65CA
065C0:  BTFSC  x5F.7
065C2:  BRA    65CE
065C4:  MOVF   x5F,W
065C6:  SUBLW  24
065C8:  BC    65CE
....................    goto StrtoulGO;
065CA:  BRA    67D6
065CC:  BRA    66C6
.................... 
....................    else if (base)
065CE:  MOVF   x5F,F
065D0:  BZ    665E
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
065D2:  MOVF   x5F,W
065D4:  SUBLW  10
065D6:  BNZ   6612
065D8:  MOVFF  661,FEA
065DC:  MOVFF  660,FE9
065E0:  MOVF   FEF,W
065E2:  SUBLW  30
065E4:  BNZ   6612
065E6:  MOVLW  01
065E8:  ADDWF  x60,W
065EA:  MOVWF  FE9
065EC:  MOVLW  00
065EE:  ADDWFC x61,W
065F0:  MOVWF  FEA
065F2:  MOVF   FEF,W
065F4:  SUBLW  78
065F6:  BZ    660A
065F8:  MOVLW  01
065FA:  ADDWF  x60,W
065FC:  MOVWF  FE9
065FE:  MOVLW  00
06600:  ADDWFC x61,W
06602:  MOVWF  FEA
06604:  MOVF   FEF,W
06606:  SUBLW  58
06608:  BNZ   6612
....................          sc+=2;
0660A:  MOVLW  02
0660C:  ADDWF  x60,F
0660E:  MOVLW  00
06610:  ADDWFC x61,F
....................       if(base==8 && *sc =='0')
06612:  MOVF   x5F,W
06614:  SUBLW  08
06616:  BNZ   662E
06618:  MOVFF  661,FEA
0661C:  MOVFF  660,FE9
06620:  MOVF   FEF,W
06622:  SUBLW  30
06624:  BNZ   662E
....................          sc+=1;
06626:  MOVLW  01
06628:  ADDWF  x60,F
0662A:  MOVLW  00
0662C:  ADDWFC x61,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
0662E:  MOVF   x5F,W
06630:  SUBLW  02
06632:  BNZ   665C
06634:  MOVFF  661,FEA
06638:  MOVFF  660,FE9
0663C:  MOVF   FEF,W
0663E:  SUBLW  30
06640:  BNZ   665C
06642:  MOVLW  01
06644:  ADDWF  x60,W
06646:  MOVWF  FE9
06648:  MOVLW  00
0664A:  ADDWFC x61,W
0664C:  MOVWF  FEA
0664E:  MOVF   FEF,W
06650:  SUBLW  62
06652:  BNZ   665C
....................          sc+=2;
06654:  MOVLW  02
06656:  ADDWF  x60,F
06658:  MOVLW  00
0665A:  ADDWFC x61,F
.................... 
....................    }
0665C:  BRA    66C6
....................    else if(*sc!='0') // base is 0, find base
0665E:  MOVFF  661,FEA
06662:  MOVFF  660,FE9
06666:  MOVF   FEF,W
06668:  SUBLW  30
0666A:  BZ    6672
....................       base=10;
0666C:  MOVLW  0A
0666E:  MOVWF  x5F
06670:  BRA    66C6
....................    else if (sc[1]=='x' || sc[1]=='X')
06672:  MOVLW  01
06674:  ADDWF  x60,W
06676:  MOVWF  FE9
06678:  MOVLW  00
0667A:  ADDWFC x61,W
0667C:  MOVWF  FEA
0667E:  MOVF   FEF,W
06680:  SUBLW  78
06682:  BZ    6696
06684:  MOVLW  01
06686:  ADDWF  x60,W
06688:  MOVWF  FE9
0668A:  MOVLW  00
0668C:  ADDWFC x61,W
0668E:  MOVWF  FEA
06690:  MOVF   FEF,W
06692:  SUBLW  58
06694:  BNZ   66A4
....................       base =16,sc+=2;
06696:  MOVLW  10
06698:  MOVWF  x5F
0669A:  MOVLW  02
0669C:  ADDWF  x60,F
0669E:  MOVLW  00
066A0:  ADDWFC x61,F
066A2:  BRA    66C6
....................    else if(sc[1]=='b')
066A4:  MOVLW  01
066A6:  ADDWF  x60,W
066A8:  MOVWF  FE9
066AA:  MOVLW  00
066AC:  ADDWFC x61,W
066AE:  MOVWF  FEA
066B0:  MOVF   FEF,W
066B2:  SUBLW  62
066B4:  BNZ   66C2
....................       base=2,sc+=2;
066B6:  MOVLW  02
066B8:  MOVWF  x5F
066BA:  ADDWF  x60,F
066BC:  MOVLW  00
066BE:  ADDWFC x61,F
066C0:  BRA    66C6
....................    else
....................       base=8;
066C2:  MOVLW  08
066C4:  MOVWF  x5F
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
066C6:  MOVFF  661,663
066CA:  MOVFF  660,662
066CE:  MOVFF  661,FEA
066D2:  MOVFF  660,FE9
066D6:  MOVF   FEF,W
066D8:  SUBLW  30
066DA:  BNZ   66E4
066DC:  INCF   x60,F
066DE:  BTFSC  FD8.2
066E0:  INCF   x61,F
066E2:  BRA    66CE
....................    sd=memchr(digits,tolower(*sc),base);
066E4:  MOVFF  661,03
066E8:  MOVFF  660,FE9
066EC:  MOVFF  03,FEA
066F0:  MOVFF  FEF,68D
066F4:  MOVF   x8D,W
066F6:  SUBLW  40
066F8:  BC    6706
066FA:  MOVF   x8D,W
066FC:  SUBLW  5A
066FE:  BNC   6706
06700:  MOVF   x8D,W
06702:  IORLW  20
06704:  BRA    6708
06706:  MOVF   x8D,W
06708:  MOVWF  x8D
0670A:  MOVLW  06
0670C:  MOVWF  x8F
0670E:  MOVLW  69
06710:  MOVWF  x8E
06712:  MOVFF  68D,690
06716:  CLRF   x92
06718:  MOVFF  65F,691
0671C:  BTFSC  x91.7
0671E:  DECF   x92,F
06720:  MOVLB  0
06722:  RCALL  6428
06724:  MOVFF  02,665
06728:  MOVFF  01,664
....................    for(; sd!=0; )
0672C:  MOVLB  6
0672E:  MOVF   x64,F
06730:  BNZ   6736
06732:  MOVF   x65,F
06734:  BZ    67CA
....................    {
....................       x=x*base+(int16)(sd-digits);
06736:  CLRF   03
06738:  MOVF   x5F,W
0673A:  MOVWF  00
0673C:  BTFSC  FE8.7
0673E:  DECF   03,F
06740:  MOVWF  x8D
06742:  MOVFF  03,68E
06746:  MOVFF  667,690
0674A:  MOVFF  666,68F
0674E:  MOVFF  03,692
06752:  MOVWF  x91
06754:  MOVLB  0
06756:  BRA    6472
06758:  MOVFF  01,68D
0675C:  MOVLW  69
0675E:  MOVLB  6
06760:  SUBWF  x64,W
06762:  MOVWF  00
06764:  MOVLW  06
06766:  SUBWFB x65,W
06768:  MOVWF  03
0676A:  MOVF   00,W
0676C:  ADDWF  01,W
0676E:  MOVWF  01
06770:  MOVF   02,W
06772:  ADDWFC 03,F
06774:  MOVFF  01,666
06778:  MOVFF  03,667
....................       ++sc;
0677C:  INCF   x60,F
0677E:  BTFSC  FD8.2
06780:  INCF   x61,F
....................       sd=memchr(digits,tolower(*sc),base);
06782:  MOVFF  661,FEA
06786:  MOVFF  660,FE9
0678A:  MOVFF  FEF,68D
0678E:  MOVF   x8D,W
06790:  SUBLW  40
06792:  BC    67A0
06794:  MOVF   x8D,W
06796:  SUBLW  5A
06798:  BNC   67A0
0679A:  MOVF   x8D,W
0679C:  IORLW  20
0679E:  BRA    67A2
067A0:  MOVF   x8D,W
067A2:  MOVWF  x8D
067A4:  MOVLW  06
067A6:  MOVWF  x8F
067A8:  MOVLW  69
067AA:  MOVWF  x8E
067AC:  MOVFF  68D,690
067B0:  CLRF   x92
067B2:  MOVFF  65F,691
067B6:  BTFSC  x91.7
067B8:  DECF   x92,F
067BA:  MOVLB  0
067BC:  RCALL  6428
067BE:  MOVFF  02,665
067C2:  MOVFF  01,664
067C6:  BRA    672C
067C8:  MOVLB  6
....................    }
....................    if(s1==sc)
067CA:  MOVF   x60,W
067CC:  SUBWF  x62,W
067CE:  BNZ   67F8
067D0:  MOVF   x61,W
067D2:  SUBWF  x63,W
067D4:  BNZ   67F8
....................    {
....................    StrtoulGO:
....................       if (endptr)
067D6:  MOVLB  6
067D8:  MOVF   x5D,W
067DA:  IORWF  x5E,W
067DC:  BZ    67F0
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
067DE:  MOVFF  65E,FEA
067E2:  MOVFF  65D,FE9
067E6:  MOVFF  65C,FEC
067EA:  MOVF   FED,F
067EC:  MOVFF  65B,FEF
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
067F0:  MOVLW  00
067F2:  MOVWF  01
067F4:  MOVWF  02
067F6:  BRA    6818
....................    }
....................    if (endptr)
067F8:  MOVF   x5D,W
067FA:  IORWF  x5E,W
067FC:  BZ    6810
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
067FE:  MOVFF  65E,FEA
06802:  MOVFF  65D,FE9
06806:  MOVFF  661,FEC
0680A:  MOVF   FED,F
0680C:  MOVFF  660,FEF
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
06810:  MOVFF  666,01
06814:  MOVFF  667,02
06818:  MOVLB  0
0681A:  RETURN 0
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
*
01B12:  BCF    FD8.0
01B14:  MOVLB  6
01B16:  RRCF   x51,W
01B18:  MOVWF  x55
....................    while( m > 0 ) {
01B1A:  MOVF   x55,F
01B1C:  BTFSC  FD8.2
01B1E:  BRA    1C36
....................      for(j=0; j<(qitems-m); ++j) {
01B20:  CLRF   x56
01B22:  MOVF   x55,W
01B24:  SUBWF  x51,W
01B26:  SUBWF  x56,W
01B28:  BTFSC  FD8.0
01B2A:  BRA    1C30
....................         i = j;
01B2C:  MOVFF  656,657
....................         do
....................         {
....................            done=1;
01B30:  BSF    x59.0
....................            l = i+m;
01B32:  MOVF   x55,W
01B34:  ADDWF  x57,W
01B36:  MOVWF  x58
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
01B38:  MOVF   x57,W
01B3A:  MULWF  x52
01B3C:  MOVF   FF3,W
01B3E:  ADDWF  x4F,W
01B40:  MOVWF  x6A
01B42:  MOVLW  00
01B44:  ADDWFC x50,W
01B46:  MOVWF  x6B
01B48:  MOVF   x58,W
01B4A:  MULWF  x52
01B4C:  MOVF   FF3,W
01B4E:  ADDWF  x4F,W
01B50:  MOVWF  x6C
01B52:  MOVLW  00
01B54:  ADDWFC x50,W
01B56:  MOVWF  x6D
01B58:  MOVLW  06
01B5A:  MOVWF  FEA
01B5C:  MOVLW  53
01B5E:  MOVWF  FE9
01B60:  MOVFF  66B,624
01B64:  MOVFF  66A,623
01B68:  MOVFF  66D,626
01B6C:  MOVFF  66C,625
01B70:  MOVLB  0
01B72:  CALL   00BC
01B76:  BTFSC  01.7
01B78:  BRA    1C26
01B7A:  MOVF   01,W
01B7C:  SUBLW  00
01B7E:  BC    1C26
....................               memcpy(t, qdata+i*qsize, qsize);
01B80:  MOVLB  6
01B82:  MOVF   x57,W
01B84:  MULWF  x52
01B86:  MOVF   FF3,W
01B88:  ADDWF  x4F,W
01B8A:  MOVWF  x6A
01B8C:  MOVLW  00
01B8E:  ADDWFC x50,W
01B90:  MOVWF  x6B
01B92:  MOVLW  06
01B94:  MOVWF  FEA
01B96:  MOVLW  5A
01B98:  MOVWF  FE9
01B9A:  MOVFF  66B,FE2
01B9E:  MOVFF  66A,FE1
01BA2:  MOVF   x52,W
01BA4:  MOVWF  01
01BA6:  BZ    1BB0
01BA8:  MOVFF  FE6,FEE
01BAC:  DECFSZ 01,F
01BAE:  BRA    1BA8
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
01BB0:  MOVF   x57,W
01BB2:  MULWF  x52
01BB4:  MOVF   FF3,W
01BB6:  ADDWF  x4F,W
01BB8:  MOVWF  x6A
01BBA:  MOVLW  00
01BBC:  ADDWFC x50,W
01BBE:  MOVWF  x6B
01BC0:  MOVF   x58,W
01BC2:  MULWF  x52
01BC4:  MOVF   FF3,W
01BC6:  ADDWF  x4F,W
01BC8:  MOVWF  x6C
01BCA:  MOVLW  00
01BCC:  ADDWFC x50,W
01BCE:  MOVWF  x6D
01BD0:  MOVFF  66B,FEA
01BD4:  MOVFF  66A,FE9
01BD8:  MOVWF  FE2
01BDA:  MOVFF  66C,FE1
01BDE:  MOVF   x52,W
01BE0:  MOVWF  01
01BE2:  BZ    1BEC
01BE4:  MOVFF  FE6,FEE
01BE8:  DECFSZ 01,F
01BEA:  BRA    1BE4
....................               memcpy(qdata+l*qsize, t, qsize);
01BEC:  MOVF   x58,W
01BEE:  MULWF  x52
01BF0:  MOVF   FF3,W
01BF2:  ADDWF  x4F,W
01BF4:  MOVWF  x6A
01BF6:  MOVLW  00
01BF8:  ADDWFC x50,W
01BFA:  MOVWF  x6B
01BFC:  MOVWF  FEA
01BFE:  MOVFF  66A,FE9
01C02:  MOVLW  06
01C04:  MOVWF  FE2
01C06:  MOVLW  5A
01C08:  MOVWF  FE1
01C0A:  MOVF   x52,W
01C0C:  MOVWF  01
01C0E:  BZ    1C18
01C10:  MOVFF  FE6,FEE
01C14:  DECFSZ 01,F
01C16:  BRA    1C10
....................               if(m <= i)
01C18:  MOVF   x55,W
01C1A:  SUBWF  x57,W
01C1C:  BNC   1C22
....................                 i -= m;
01C1E:  MOVF   x55,W
01C20:  SUBWF  x57,F
....................                 done = 0;
01C22:  BCF    x59.0
01C24:  MOVLB  0
....................            }
....................         } while(!done);
01C26:  MOVLB  6
01C28:  BTFSS  x59.0
01C2A:  BRA    1B30
01C2C:  INCF   x56,F
01C2E:  BRA    1B22
....................      }
....................      m = m/2;
01C30:  BCF    FD8.0
01C32:  RRCF   x55,F
01C34:  BRA    1B1A
....................    }
01C36:  MOVLB  0
01C38:  RETURN 0
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0.3,0.1,0,0,0,0,0},
....................    {0.01,0.3,0.1,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
*
00462:  MOVLB  6
00464:  CLRF   x2D
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
00466:  CLRF   x2D
00468:  MOVF   x2C,W
0046A:  SUBWF  x2D,W
0046C:  BC    04C4
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
0046E:  MOVF   x2D,W
00470:  ADDWF  x2A,W
00472:  MOVWF  x2E
00474:  MOVLW  00
00476:  ADDWFC x2B,W
00478:  MOVWF  x2F
0047A:  MOVF   x2D,W
0047C:  ADDWF  x28,W
0047E:  MOVWF  01
00480:  MOVLW  00
00482:  ADDWFC x29,W
00484:  MOVWF  03
00486:  MOVF   01,W
00488:  MOVWF  FE9
0048A:  MOVFF  03,FEA
0048E:  MOVFF  FEF,630
00492:  BSF    F7F.7
00494:  MOVF   FF2,W
00496:  MOVWF  00
00498:  BCF    FF2.7
0049A:  MOVFF  62F,F7A
0049E:  MOVFF  62E,F79
004A2:  MOVLW  31
004A4:  MOVWF  F7B
004A6:  MOVFF  630,F7C
004AA:  MOVLB  F
004AC:  MOVLW  55
004AE:  MOVWF  F81
004B0:  MOVLW  AA
004B2:  MOVWF  F81
004B4:  BSF    F80.4
004B6:  BTFSC  F80.4
004B8:  BRA    04B6
004BA:  MOVF   00,W
004BC:  IORWF  FF2,F
004BE:  MOVLB  6
004C0:  INCF   x2D,F
004C2:  BRA    0468
....................    }
004C4:  MOVLB  0
004C6:  RETURN 0
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
*
003E6:  MOVLB  6
003E8:  CLRF   x2D
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
003EA:  CLRF   x2D
003EC:  MOVF   x2C,W
003EE:  SUBWF  x2D,W
003F0:  BC    0434
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
003F2:  MOVF   x2D,W
003F4:  ADDWF  x28,W
003F6:  MOVWF  01
003F8:  MOVLW  00
003FA:  ADDWFC x29,W
003FC:  MOVWF  03
003FE:  MOVF   01,W
00400:  MOVWF  FE9
00402:  MOVFF  03,FEA
00406:  MOVF   x2D,W
00408:  ADDWF  x2A,W
0040A:  MOVWF  x30
0040C:  MOVLW  00
0040E:  ADDWFC x2B,W
00410:  MOVWF  x31
00412:  BSF    F7F.7
00414:  MOVFF  FF2,632
00418:  BCF    FF2.7
0041A:  MOVFF  631,F7A
0041E:  MOVFF  630,F79
00422:  MOVLW  31
00424:  MOVWF  F7B
00426:  BSF    F80.0
00428:  MOVF   F7C,W
0042A:  BTFSC  x32.7
0042C:  BSF    FF2.7
0042E:  MOVWF  FEF
00430:  INCF   x2D,F
00432:  BRA    03EC
....................    }
00434:  MOVLB  0
00436:  RETURN 0
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
*
004C8:  MOVLB  6
004CA:  CLRF   x29
004CC:  MOVLW  20
004CE:  MOVWF  x28
004D0:  CLRF   x2B
004D2:  CLRF   x2A
004D4:  MOVLW  80
004D6:  MOVWF  x2C
004D8:  MOVLB  0
004DA:  RCALL  0462
....................    delay_ms(1);
004DC:  MOVLW  01
004DE:  MOVLB  6
004E0:  MOVWF  x30
004E2:  MOVLB  0
004E4:  RCALL  0438
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
004E6:  MOVLB  6
004E8:  CLRF   x29
004EA:  MOVLW  60
004EC:  MOVWF  x28
004EE:  CLRF   x2B
004F0:  MOVLW  80
004F2:  MOVWF  x2A
004F4:  MOVLW  02
004F6:  MOVWF  x2C
004F8:  MOVLB  0
004FA:  RCALL  0462
....................    delay_ms(1);
004FC:  MOVLW  01
004FE:  MOVLB  6
00500:  MOVWF  x30
00502:  MOVLB  0
00504:  RCALL  0438
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
00506:  MOVLB  6
00508:  CLRF   x29
0050A:  MOVLW  61
0050C:  MOVWF  x28
0050E:  CLRF   x2B
00510:  MOVLW  90
00512:  MOVWF  x2A
00514:  MOVLW  02
00516:  MOVWF  x2C
00518:  MOVLB  0
0051A:  RCALL  0462
....................    delay_ms(1);
0051C:  MOVLW  01
0051E:  MOVLB  6
00520:  MOVWF  x30
00522:  MOVLB  0
00524:  RCALL  0438
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
00526:  MOVLB  6
00528:  CLRF   x29
0052A:  MOVLW  62
0052C:  MOVWF  x28
0052E:  CLRF   x2B
00530:  MOVLW  A0
00532:  MOVWF  x2A
00534:  MOVLW  20
00536:  MOVWF  x2C
00538:  MOVLB  0
0053A:  RCALL  0462
....................    delay_ms(1);
0053C:  MOVLW  01
0053E:  MOVLB  6
00540:  MOVWF  x30
00542:  MOVLB  0
00544:  RCALL  0438
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
00546:  MOVLB  6
00548:  CLRF   x29
0054A:  MOVLW  82
0054C:  MOVWF  x28
0054E:  CLRF   x2B
00550:  MOVLW  C0
00552:  MOVWF  x2A
00554:  MOVLW  30
00556:  MOVWF  x2C
00558:  MOVLB  0
0055A:  RCALL  0462
....................    delay_ms(1);
0055C:  MOVLW  01
0055E:  MOVLB  6
00560:  MOVWF  x30
00562:  MOVLB  0
00564:  RCALL  0438
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
00566:  MOVLB  6
00568:  CLRF   x29
0056A:  MOVLW  B2
0056C:  MOVWF  x28
0056E:  CLRF   x2B
00570:  MOVLW  F0
00572:  MOVWF  x2A
00574:  MOVLW  38
00576:  MOVWF  x2C
00578:  MOVLB  0
0057A:  RCALL  0462
....................    delay_ms(1);
0057C:  MOVLW  01
0057E:  MOVLB  6
00580:  MOVWF  x30
00582:  MOVLB  0
00584:  RCALL  0438
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
00586:  MOVLB  6
00588:  CLRF   x29
0058A:  MOVLW  F2
0058C:  MOVWF  x28
0058E:  MOVLW  01
00590:  MOVWF  x2B
00592:  MOVLW  40
00594:  MOVWF  x2A
00596:  MOVLW  01
00598:  MOVWF  x2C
0059A:  MOVLB  0
0059C:  RCALL  0462
....................    delay_ms(1);
0059E:  MOVLW  01
005A0:  MOVLB  6
005A2:  MOVWF  x30
005A4:  MOVLB  0
005A6:  RCALL  0438
005A8:  GOTO   0678 (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
005AC:  MOVLB  6
005AE:  CLRF   x29
005B0:  MOVLW  20
005B2:  MOVWF  x28
005B4:  CLRF   x2B
005B6:  CLRF   x2A
005B8:  MOVLW  80
005BA:  MOVWF  x2C
005BC:  MOVLB  0
005BE:  RCALL  03E6
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
005C0:  MOVLB  6
005C2:  CLRF   x29
005C4:  MOVLW  60
005C6:  MOVWF  x28
005C8:  CLRF   x2B
005CA:  MOVLW  80
005CC:  MOVWF  x2A
005CE:  MOVLW  02
005D0:  MOVWF  x2C
005D2:  MOVLB  0
005D4:  RCALL  03E6
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
005D6:  MOVLB  6
005D8:  CLRF   x29
005DA:  MOVLW  61
005DC:  MOVWF  x28
005DE:  CLRF   x2B
005E0:  MOVLW  90
005E2:  MOVWF  x2A
005E4:  MOVLW  02
005E6:  MOVWF  x2C
005E8:  MOVLB  0
005EA:  RCALL  03E6
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
005EC:  MOVLB  6
005EE:  CLRF   x29
005F0:  MOVLW  62
005F2:  MOVWF  x28
005F4:  CLRF   x2B
005F6:  MOVLW  A0
005F8:  MOVWF  x2A
005FA:  MOVLW  20
005FC:  MOVWF  x2C
005FE:  MOVLB  0
00600:  RCALL  03E6
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
00602:  MOVLB  6
00604:  CLRF   x29
00606:  MOVLW  82
00608:  MOVWF  x28
0060A:  CLRF   x2B
0060C:  MOVLW  C0
0060E:  MOVWF  x2A
00610:  MOVLW  30
00612:  MOVWF  x2C
00614:  MOVLB  0
00616:  RCALL  03E6
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
00618:  MOVLB  6
0061A:  CLRF   x29
0061C:  MOVLW  B2
0061E:  MOVWF  x28
00620:  CLRF   x2B
00622:  MOVLW  F0
00624:  MOVWF  x2A
00626:  MOVLW  38
00628:  MOVWF  x2C
0062A:  MOVLB  0
0062C:  RCALL  03E6
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
0062E:  MOVLB  6
00630:  CLRF   x29
00632:  MOVLW  F2
00634:  MOVWF  x28
00636:  MOVLW  01
00638:  MOVWF  x2B
0063A:  MOVLW  40
0063C:  MOVWF  x2A
0063E:  MOVLW  01
00640:  MOVWF  x2C
00642:  MOVLB  0
00644:  RCALL  03E6
00646:  GOTO   067C (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
0064A:  MOVLB  6
0064C:  CLRF   x29
0064E:  MOVLW  F2
00650:  MOVWF  x28
00652:  MOVLW  01
00654:  MOVWF  x2B
00656:  MOVLW  40
00658:  MOVWF  x2A
0065A:  MOVLW  01
0065C:  MOVWF  x2C
0065E:  MOVLB  0
00660:  RCALL  03E6
....................    delay_ms(1);
00662:  MOVLW  01
00664:  MOVLB  6
00666:  MOVWF  x30
00668:  MOVLB  0
0066A:  RCALL  0438
....................    if (paramsValid != isValid)
0066C:  MOVF   xF2,W
0066E:  SUBLW  AA
00670:  BZ    067A
....................    {
....................       paramsValid = isValid;
00672:  MOVLW  AA
00674:  MOVWF  xF2
....................       params_save_to_ee(); // saves the base parameters on first boot
00676:  BRA    04C8
....................    }
00678:  BRA    067C
....................    else
....................    {
....................       params_load_from_ee();
0067A:  BRA    05AC
....................    }
0067C:  GOTO   AE80 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <monitor.h>
.................... #ifndef monitor
.................... #define monitor
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
....................    output_b(portB_reset);
....................    output_c(portC_reset);
....................    output_d(portD_reset);
....................    output_e(portE_reset);
....................    
....................    port_a_pullups(portA_pullups);
....................    port_b_pullups(portB_pullups);
....................    port_c_pullups(portC_pullups);
....................    port_d_pullups(portD_pullups);
....................    port_e_pullups(portE_pullups);
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0.3,0.1,0,0,0,0,0},
....................    {0.01,0.3,0.1,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <ADS1220.h>
.................... #ifndef ADS1220
.................... #define ADS1220
.................... 
.................... /*****************************************************************************/
.................... /* SET UP PORTS FOR USE WITH DRIVER                                          */
.................... /*****************************************************************************/
.................... #define _CS0  PIN_D5 // chip select pins 
.................... #define _CS1  PIN_D6
.................... #define _CS2  PIN_D7
.................... #define _CS3  PIN_B0
.................... 
.................... #pin_select SCK2=PIN_B1
.................... #pin_select SDI2=PIN_B2
.................... #pin_select SDO2=PIN_B3
.................... #use spi(MASTER, SPI2, BAUD=1000000, MODE=1, STREAM=SPI_mon)
.................... //!setup_spi2(SPI_MASTER | SPI_SCK_IDLE_LOW | SPI_XMIT_H_TO_L | SPI_CLK_DIV_64);
.................... 
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* REGISTER DEFINITIONS                                                      */
.................... /*****************************************************************************/
.................... typedef enum {reg0 = 0x00,reg1 = 0x04 ,reg2 = 0x08, reg3 = 0x0C}adsReg;
.................... 
.................... //REGISTER 0 OPTIONS
.................... 
.................... #define IPp0n1 0x00
.................... #define IPp0n2 0x10
.................... #define IPp0n3 0x20
.................... #define IPp1n2 0x30
.................... #define IPp1n3 0x40
.................... #define IPp2n3 0x50
.................... #define IPp1n0 0x60
.................... #define IPp3n2 0x70
.................... #define IPp0nVss 0x80
.................... #define IPp1nVss 0x90
.................... #define IPp2nVss 0xA0
.................... #define IPp3nVss 0xB0
.................... #define IPVrpVrn 0xC0
.................... #define IPVddVss 0xD0
.................... #define IPhalfRail 0xE0
.................... 
.................... #define g1 0x00
.................... #define g2 0x02
.................... #define g4 0x04
.................... #define g8 0x06
.................... #define g16 0x08
.................... #define g32 0x0A
.................... #define g64 0x0C
.................... #define g128 0x0E
.................... 
.................... #define PGAenabled 0x00
.................... #define PGAbypass 0x01
.................... 
.................... //REGISTER 1 OPTIONS
.................... 
.................... #define DRn20 0x00
.................... #define DRn45 0x20
.................... #define DRn90 0x40
.................... #define DRn175 0x60
.................... #define DRn330 0x80
.................... #define DRn600 0xA0
.................... #define DRn1000 0xC0
.................... 
.................... #define MDnormal 0x00
.................... #define MDduty 0x80
.................... #define MDturbo 0x10
.................... 
.................... #define CMsingle 0x00
.................... #define CMcont 0x40
.................... 
.................... #define TSdisable 0x00
.................... #define TSenable 0x20
.................... 
.................... #define BCSoff 0x00
.................... #define BCSon 0x01
.................... 
.................... //REGISTER 2 OPTIONS
.................... 
.................... #define REFinternal 0x00
.................... #define REFp0n0 0x40
.................... #define REFp1n1 0x80
.................... #define REFVddVss 0xC0
.................... 
.................... #define FIRoff 0x00
.................... #define FIR5060 0x10
.................... #define FIR50 0x20
.................... #define FIR60 0x30
.................... 
.................... #define PSWopen 0x00
.................... #define PSWstart 0x08
.................... 
.................... #define Ioff 0x00
.................... #define Iu10 0x01
.................... #define Iu50 0x02
.................... #define Iu100 0x03
.................... #define Iu250 0x04
.................... #define Iu500 0x05
.................... #define Iu1000 0x06
.................... #define Iu1500 0x07  
.................... 
.................... //REGISTER 3 OPTIONS
.................... 
.................... #define I1disabled 0x00
.................... #define I1a0p1 0x20
.................... #define I1a1 0x40
.................... #define I1a2 0x60
.................... #define I1a3n1 0x80
.................... #define I1p0 0xA0
.................... #define I1n0 0xC0
.................... 
.................... #define I2disabled 0x00
.................... #define I2a0p1 0x04
.................... #define I2a1 0x08
.................... #define I2a2 0x0A
.................... #define I2a3n1 0x10
.................... #define I2p0 0x14
.................... #define I2n0 0x18
.................... 
.................... #define drdyPin 0x00
.................... #define doutPin 0x20
.................... 
.................... // REGISTER CONGIGURATIONS FOR THIS APP
.................... #define reg0config IPp1n2|g1|PGAenabled // 0x30//
.................... #define reg1config DRn20|MDturbo|CMsingle|TSDisable|BCSoff //0x10
.................... #define reg2config REFinternal|FIR60|PSWopen|Ioff //0x30
.................... #define reg3config I1disabled|I2disabled|drdyPin //0x00
.................... 
.................... //COMMANDS
.................... #define ADSreset 0x06
.................... #define ADSstart 0x08
.................... #define ADSpowerDn 0x02
.................... #define ADSreadData 0x10
.................... #define ADSreadReg 0x20
.................... #define ADSwriteReg 0x40
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* DESELECT ALL ADCs                                                         */
.................... /*****************************************************************************/
.................... void ads_deselect_all()
.................... {   
....................    output_high(_CS0); // deselect all chip select pins
*
00136:  MOVLW  1F
00138:  MOVWF  F8A
0013A:  BSF    F85.5
....................    output_high(_CS1);
0013C:  MOVWF  F8A
0013E:  BSF    F85.6
....................    output_high(_CS2);
00140:  MOVWF  F8A
00142:  BSF    F85.7
....................    output_high(_CS3); 
00144:  MOVLW  C4
00146:  MOVWF  F88
00148:  BSF    F83.0
....................    delay_us(10);
0014A:  MOVLW  35
0014C:  MOVWF  00
0014E:  DECFSZ 00,F
00150:  BRA    014E
00152:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT DESIRED ADC                                                        */
.................... /*****************************************************************************/
.................... void ads_select_ch(int8 ch)
.................... {
....................    ads_deselect_all();
*
00680:  RCALL  0136
....................    switch(ch)
00682:  MOVLB  6
00684:  MOVF   x41,W
00686:  ADDLW  FC
00688:  BC    06BC
0068A:  ADDLW  04
0068C:  MOVLB  0
0068E:  GOTO   06C8
....................    {
....................       case 0:
....................          output_low(_CS0);
00692:  MOVLW  1F
00694:  MOVWF  F8A
00696:  BCF    F85.5
....................       break; 
00698:  MOVLB  6
0069A:  BRA    06BC
....................       case 1:
....................          output_low(_CS1);
0069C:  MOVLW  1F
0069E:  MOVWF  F8A
006A0:  BCF    F85.6
....................       break;   
006A2:  MOVLB  6
006A4:  BRA    06BC
....................       case 2:
....................          output_low(_CS2);
006A6:  MOVLW  1F
006A8:  MOVWF  F8A
006AA:  BCF    F85.7
....................       break;
006AC:  MOVLB  6
006AE:  BRA    06BC
....................       case 3:
....................          output_low(_CS3);
006B0:  MOVLW  C4
006B2:  MOVWF  F88
006B4:  BCF    F83.0
....................       break;              
006B6:  MOVLB  6
006B8:  BRA    06BC
006BA:  MOVLB  6
....................    }
....................    delay_us(10);
006BC:  MOVLW  35
006BE:  MOVWF  00
006C0:  DECFSZ 00,F
006C2:  BRA    06C0
006C4:  MOVLB  0
006C6:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT ADC BLOCK (2 ADCs/BLOCK)                                           */
.................... /*****************************************************************************/
.................... void ads_select_block(int8 block)
.................... {
....................    ads_deselect_all();
*
00154:  RCALL  0136
....................    switch(block)
00156:  MOVLB  6
00158:  MOVF   x9A,W
0015A:  XORLW  00
0015C:  MOVLB  0
0015E:  BZ    0166
00160:  XORLW  01
00162:  BZ    0172
00164:  BRA    017E
....................    {
....................       case 0:
....................          output_low(_CS0);
00166:  MOVLW  1F
00168:  MOVWF  F8A
0016A:  BCF    F85.5
....................          output_low(_CS1);
0016C:  MOVWF  F8A
0016E:  BCF    F85.6
....................       break; 
00170:  BRA    017E
....................       case 1:         
....................          output_low(_CS2);
00172:  MOVLW  1F
00174:  MOVWF  F8A
00176:  BCF    F85.7
....................          output_low(_CS3);
00178:  MOVLW  C4
0017A:  MOVWF  F88
0017C:  BCF    F83.0
....................       break;         
....................    }
....................    delay_us(10);
0017E:  MOVLW  35
00180:  MOVWF  00
00182:  DECFSZ 00,F
00184:  BRA    0182
00186:  GOTO   0190 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT ALL ADCs                                                           */
.................... /*****************************************************************************/
.................... void ads_select_all()
.................... {
....................    output_low(_CS0);
*
007B6:  MOVLW  1F
007B8:  MOVWF  F8A
007BA:  BCF    F85.5
....................    output_low(_CS1);
007BC:  MOVWF  F8A
007BE:  BCF    F85.6
....................    output_low(_CS2);
007C0:  MOVWF  F8A
007C2:  BCF    F85.7
....................    output_low(_CS3);
007C4:  MOVLW  C4
007C6:  MOVWF  F88
007C8:  BCF    F83.0
....................    delay_us(10);
007CA:  MOVLW  35
007CC:  MOVWF  00
007CE:  DECFSZ 00,F
007D0:  BRA    07CE
007D2:  GOTO   07D8 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO AN ADC                                          */
.................... /*****************************************************************************/
.................... void ads_write_command(int8 ch, unsigned int8 command)
.................... {
....................    ads_select_ch(ch);
*
006EA:  MOVFF  638,641
006EE:  RCALL  0680
....................    spi_write2(command);
006F0:  MOVLB  E
006F2:  MOVF   x8D,W
006F4:  MOVFF  639,E8D
006F8:  RRCF   x90,W
006FA:  BNC   06F8
006FC:  MOVLB  0
006FE:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO A BLOCK OF ADCs                                 */
.................... /*****************************************************************************/
.................... void ads_write_command_block(int8 block, unsigned int8 command)
.................... {
....................    ads_select_block(block);
*
0018A:  MOVFF  698,69A
0018E:  BRA    0154
....................    spi_write2(command);
00190:  MOVLB  E
00192:  MOVF   x8D,W
00194:  MOVFF  699,E8D
00198:  RRCF   x90,W
0019A:  BNC   0198
0019C:  MOVLB  0
0019E:  GOTO   01B0 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO ALL ADCs                                        */
.................... /*****************************************************************************/
.................... void ads_write_command_all(unsigned int8 command)
.................... {
....................    ads_select_all();
*
007D6:  BRA    07B6
....................    spi_write2(command);
007D8:  MOVLB  E
007DA:  MOVF   x8D,W
007DC:  MOVFF  62F,E8D
007E0:  RRCF   x90,W
007E2:  BNC   07E0
007E4:  MOVLB  0
007E6:  GOTO   07F4 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PREPARE TO READ FROM AN ADC                                               */
.................... /*****************************************************************************/
.................... void ads_read_command(int8 ch, unsigned int8 command)
.................... {
....................    ads_select_ch(ch);
*
00802:  MOVFF  63F,641
00806:  RCALL  0680
....................    spi_read2(command);
00808:  MOVLB  E
0080A:  MOVF   x8D,W
0080C:  MOVFF  640,E8D
00810:  RRCF   x90,W
00812:  BNC   0810
00814:  MOVLB  0
00816:  GOTO   0828 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE TO THE CONFIGURATION REGISTERS                                      */
.................... /*****************************************************************************/
.................... void ads_write_reg(int8 ch, adsReg regID, int8 data)
*
00726:  MOVLB  6
00728:  MOVF   x35,W
0072A:  IORLW  40
0072C:  MOVWF  x37
.................... {
....................    unsigned int8 command = ADSwriteReg | regID | 0; // 0 is numbytes to write-1
....................    ads_write_command(ch, command);
0072E:  MOVFF  634,638
00732:  MOVFF  637,639
00736:  MOVLB  0
00738:  RCALL  06EA
....................    spi_write2(data);
0073A:  MOVLB  E
0073C:  MOVF   x8D,W
0073E:  MOVFF  636,E8D
00742:  RRCF   x90,W
00744:  BNC   0742
....................    ads_deselect_all();
00746:  MOVLB  0
00748:  RCALL  0136
0074A:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* READ FROM THE CONFIGURATION REGISTERS                                     */
.................... /*****************************************************************************/
.................... unsigned int8 ads_read_reg(int8 ch, adsReg regID)
.................... {
....................    unsigned int8 command = ADSreadReg | regID | 0;
....................    ads_read_command(ch, command);
....................    unsigned int8 data = spi_read2(0);
....................    ads_deselect_all();
....................    return data;
.................... }
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* START BLOCK CONVERSION                                                    */
.................... /*****************************************************************************/
.................... void ads_start_conv_block(int8 block)
.................... {
....................    ads_write_command_block(block, ADSstart);
*
001A2:  MOVFF  697,698
001A6:  MOVLW  08
001A8:  MOVLB  6
001AA:  MOVWF  x99
001AC:  MOVLB  0
001AE:  BRA    018A
....................    delay_us(10);
001B0:  MOVLW  35
001B2:  MOVWF  00
001B4:  DECFSZ 00,F
001B6:  BRA    01B4
....................    ads_deselect_all();
001B8:  RCALL  0136
001BA:  GOTO   0200 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* START ALL CONVERSION                                                      */
.................... /*****************************************************************************/
.................... void ads_start_conv_all()
.................... {
....................    ads_write_command_all(ADSstart);
*
007EA:  MOVLW  08
007EC:  MOVLB  6
007EE:  MOVWF  x2F
007F0:  MOVLB  0
007F2:  BRA    07D6
....................    delay_us(10);
007F4:  MOVLW  35
007F6:  MOVWF  00
007F8:  DECFSZ 00,F
007FA:  BRA    07F8
....................    ads_deselect_all();
007FC:  RCALL  0136
007FE:  GOTO   08BE (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* READ THE MOST RECENT CONVERSION                                           */
.................... /*****************************************************************************/
.................... signed int32 ads_read_data(int8 ch)
.................... {
....................    union Data
....................    {
....................       unsigned int8 dBytes[4];
....................       signed int32 dWord;
....................    }data;
....................    
....................    ads_read_command(ch, ADSreadData);
*
0081A:  MOVFF  63A,63F
0081E:  MOVLW  10
00820:  MOVLB  6
00822:  MOVWF  x40
00824:  MOVLB  0
00826:  BRA    0802
....................    data.dBytes[0] = 0;
00828:  MOVLB  6
0082A:  CLRF   x3B
....................    data.dBytes[3] = spi_read2(0);
0082C:  MOVLB  E
0082E:  MOVF   x8D,W
00830:  CLRF   x8D
00832:  RRCF   x90,W
00834:  BNC   0832
00836:  MOVFF  E8D,63E
....................    data.dBytes[2] = spi_read2(0);
0083A:  MOVF   x8D,W
0083C:  CLRF   x8D
0083E:  RRCF   x90,W
00840:  BNC   083E
00842:  MOVFF  E8D,63D
....................    data.dBytes[1] = spi_read2(0);
00846:  MOVF   x8D,W
00848:  CLRF   x8D
0084A:  RRCF   x90,W
0084C:  BNC   084A
0084E:  MOVFF  E8D,63C
....................    
....................    ads_deselect_all();
00852:  MOVLB  0
00854:  RCALL  0136
....................    return data.dWord;
00856:  MOVFF  63B,00
0085A:  MOVFF  63C,01
0085E:  MOVFF  63D,02
00862:  MOVFF  63E,03
00866:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE A CHANNEL                                                      */
.................... /*****************************************************************************/
.................... 
.................... void ADS1220init(int8 ch, rc0=reg0config, rc1=reg1config, rc2=reg2config, rc3=reg3config)
.................... {
....................    ads_write_command(ch, ADSreset);   //reset the device
*
0074C:  MOVFF  62F,638
00750:  MOVLW  06
00752:  MOVLB  6
00754:  MOVWF  x39
00756:  MOVLB  0
00758:  RCALL  06EA
....................    delay_us(300);                    
0075A:  MOVLW  02
0075C:  MOVLB  6
0075E:  MOVWF  x34
00760:  MOVLW  96
00762:  MOVWF  x35
00764:  MOVLB  0
00766:  BRA    0700
00768:  MOVLB  6
0076A:  DECFSZ x34,F
0076C:  BRA    0760
....................    ads_write_reg(ch, reg0, rc0);   //send default configurations
0076E:  MOVFF  62F,634
00772:  CLRF   x35
00774:  MOVFF  630,636
00778:  MOVLB  0
0077A:  RCALL  0726
....................    ads_write_reg(ch, reg1, rc1);
0077C:  MOVFF  62F,634
00780:  MOVLW  04
00782:  MOVLB  6
00784:  MOVWF  x35
00786:  MOVFF  631,636
0078A:  MOVLB  0
0078C:  RCALL  0726
....................    ads_write_reg(ch, reg2, rc2);
0078E:  MOVFF  62F,634
00792:  MOVLW  08
00794:  MOVLB  6
00796:  MOVWF  x35
00798:  MOVFF  632,636
0079C:  MOVLB  0
0079E:  RCALL  0726
....................    ads_write_reg(ch, reg3, rc3);  
007A0:  MOVFF  62F,634
007A4:  MOVLW  0C
007A6:  MOVLB  6
007A8:  MOVWF  x35
007AA:  MOVFF  633,636
007AE:  MOVLB  0
007B0:  RCALL  0726
007B2:  GOTO   08A0 (RETURN)
.................... }
.................... #endif 
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
*
03020:  MOVLB  6
03022:  BCF    x72.0
....................    y = x;
03024:  MOVFF  666,66B
03028:  MOVFF  665,66A
0302C:  MOVFF  664,669
03030:  MOVFF  663,668
.................... 
....................    if (x < 0)
03034:  MOVFF  666,676
03038:  MOVFF  665,675
0303C:  MOVFF  664,674
03040:  MOVFF  663,673
03044:  CLRF   x7A
03046:  CLRF   x79
03048:  CLRF   x78
0304A:  CLRF   x77
0304C:  MOVLB  0
0304E:  CALL   25F0
03052:  BNC   3060
....................    {
....................       s = 1;
03054:  MOVLB  6
03056:  BSF    x72.0
....................       y = -y;
03058:  MOVF   x69,W
0305A:  XORLW  80
0305C:  MOVWF  x69
0305E:  MOVLB  0
....................    }
.................... 
....................    if (y <= 32768.0)
03060:  MOVFF  66B,676
03064:  MOVFF  66A,675
03068:  MOVFF  669,674
0306C:  MOVFF  668,673
03070:  MOVLB  6
03072:  CLRF   x7A
03074:  CLRF   x79
03076:  CLRF   x78
03078:  MOVLW  8E
0307A:  MOVWF  x77
0307C:  MOVLB  0
0307E:  CALL   25F0
03082:  BC    3086
03084:  BNZ   30B6
....................       res = (float32)(unsigned int16)y;
03086:  MOVFF  66B,676
0308A:  MOVFF  66A,675
0308E:  MOVFF  669,674
03092:  MOVFF  668,673
03096:  RCALL  2FE4
03098:  MOVFF  02,678
0309C:  MOVFF  01,677
030A0:  CALL   11BC
030A4:  MOVFF  03,66F
030A8:  MOVFF  02,66E
030AC:  MOVFF  01,66D
030B0:  MOVFF  00,66C
030B4:  BRA    3258
.................... 
....................  else if (y < 10000000.0)
030B6:  MOVFF  66B,676
030BA:  MOVFF  66A,675
030BE:  MOVFF  669,674
030C2:  MOVFF  668,673
030C6:  MOVLW  80
030C8:  MOVLB  6
030CA:  MOVWF  x7A
030CC:  MOVLW  96
030CE:  MOVWF  x79
030D0:  MOVLW  18
030D2:  MOVWF  x78
030D4:  MOVLW  96
030D6:  MOVWF  x77
030D8:  MOVLB  0
030DA:  CALL   25F0
030DE:  BTFSS  FD8.0
030E0:  BRA    3248
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
030E2:  MOVFF  66B,67B
030E6:  MOVFF  66A,67A
030EA:  MOVFF  669,679
030EE:  MOVFF  668,678
030F2:  MOVLB  6
030F4:  CLRF   x7F
030F6:  CLRF   x7E
030F8:  CLRF   x7D
030FA:  MOVLW  70
030FC:  MOVWF  x7C
030FE:  MOVLB  0
03100:  CALL   11F2
03104:  MOVFF  03,676
03108:  MOVFF  02,675
0310C:  MOVFF  01,674
03110:  MOVFF  00,673
03114:  RCALL  2FE4
03116:  MOVFF  02,671
0311A:  MOVFF  01,670
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
0311E:  MOVFF  66B,67B
03122:  MOVFF  66A,67A
03126:  MOVFF  669,679
0312A:  MOVFF  668,678
0312E:  MOVLB  6
03130:  CLRF   x7F
03132:  CLRF   x7E
03134:  CLRF   x7D
03136:  MOVLW  70
03138:  MOVWF  x7C
0313A:  MOVLB  0
0313C:  CALL   11F2
03140:  MOVFF  03,676
03144:  MOVFF  02,675
03148:  MOVFF  01,674
0314C:  MOVFF  00,673
03150:  MOVFF  671,678
03154:  MOVFF  670,677
03158:  CALL   11BC
0315C:  BSF    FD8.1
0315E:  MOVFF  676,67A
03162:  MOVFF  675,679
03166:  MOVFF  674,678
0316A:  MOVFF  673,677
0316E:  MOVFF  03,67E
03172:  MOVFF  02,67D
03176:  MOVFF  01,67C
0317A:  MOVFF  00,67B
0317E:  CALL   12E8
03182:  MOVLB  6
03184:  CLRF   x7B
03186:  CLRF   x7A
03188:  CLRF   x79
0318A:  MOVLW  8E
0318C:  MOVWF  x78
0318E:  MOVFF  03,67F
03192:  MOVFF  02,67E
03196:  MOVFF  01,67D
0319A:  MOVFF  00,67C
0319E:  MOVLB  0
031A0:  CALL   11F2
031A4:  MOVFF  03,66B
031A8:  MOVFF  02,66A
031AC:  MOVFF  01,669
031B0:  MOVFF  00,668
....................       res = 32768.0*(float32)l;
031B4:  MOVFF  671,678
031B8:  MOVFF  670,677
031BC:  CALL   11BC
031C0:  MOVLB  6
031C2:  CLRF   x7B
031C4:  CLRF   x7A
031C6:  CLRF   x79
031C8:  MOVLW  8E
031CA:  MOVWF  x78
031CC:  MOVFF  03,67F
031D0:  MOVFF  02,67E
031D4:  MOVFF  01,67D
031D8:  MOVFF  00,67C
031DC:  MOVLB  0
031DE:  CALL   11F2
031E2:  MOVFF  03,66F
031E6:  MOVFF  02,66E
031EA:  MOVFF  01,66D
031EE:  MOVFF  00,66C
....................       res += (float32)(unsigned int16)y;
031F2:  MOVFF  66B,676
031F6:  MOVFF  66A,675
031FA:  MOVFF  669,674
031FE:  MOVFF  668,673
03202:  RCALL  2FE4
03204:  MOVFF  02,678
03208:  MOVFF  01,677
0320C:  CALL   11BC
03210:  BCF    FD8.1
03212:  MOVFF  66F,67A
03216:  MOVFF  66E,679
0321A:  MOVFF  66D,678
0321E:  MOVFF  66C,677
03222:  MOVFF  03,67E
03226:  MOVFF  02,67D
0322A:  MOVFF  01,67C
0322E:  MOVFF  00,67B
03232:  CALL   12E8
03236:  MOVFF  03,66F
0323A:  MOVFF  02,66E
0323E:  MOVFF  01,66D
03242:  MOVFF  00,66C
....................    }
03246:  BRA    3258
.................... 
....................  else
....................   res = y;
03248:  MOVFF  66B,66F
0324C:  MOVFF  66A,66E
03250:  MOVFF  669,66D
03254:  MOVFF  668,66C
.................... 
....................  y = y - (float32)(unsigned int16)y;
03258:  MOVFF  66B,676
0325C:  MOVFF  66A,675
03260:  MOVFF  669,674
03264:  MOVFF  668,673
03268:  RCALL  2FE4
0326A:  MOVFF  02,678
0326E:  MOVFF  01,677
03272:  CALL   11BC
03276:  BSF    FD8.1
03278:  MOVFF  66B,67A
0327C:  MOVFF  66A,679
03280:  MOVFF  669,678
03284:  MOVFF  668,677
03288:  MOVFF  03,67E
0328C:  MOVFF  02,67D
03290:  MOVFF  01,67C
03294:  MOVFF  00,67B
03298:  CALL   12E8
0329C:  MOVFF  03,66B
032A0:  MOVFF  02,66A
032A4:  MOVFF  01,669
032A8:  MOVFF  00,668
.................... 
....................  if (s)
032AC:  MOVLB  6
032AE:  BTFSS  x72.0
032B0:  BRA    32B8
....................   res = -res;
032B2:  MOVF   x6D,W
032B4:  XORLW  80
032B6:  MOVWF  x6D
.................... 
....................  if (y != 0)
032B8:  MOVFF  66B,676
032BC:  MOVFF  66A,675
032C0:  MOVFF  669,674
032C4:  MOVFF  668,673
032C8:  CLRF   x7A
032CA:  CLRF   x79
032CC:  CLRF   x78
032CE:  CLRF   x77
032D0:  MOVLB  0
032D2:  CALL   25F0
032D6:  BZ    3350
....................  {
....................   if (s == 1 && n == 0)
032D8:  MOVLB  6
032DA:  BTFSS  x72.0
032DC:  BRA    3316
032DE:  MOVF   x67,F
032E0:  BNZ   3316
....................    res -= 1.0;
032E2:  BSF    FD8.1
032E4:  MOVFF  66F,67A
032E8:  MOVFF  66E,679
032EC:  MOVFF  66D,678
032F0:  MOVFF  66C,677
032F4:  CLRF   x7E
032F6:  CLRF   x7D
032F8:  CLRF   x7C
032FA:  MOVLW  7F
032FC:  MOVWF  x7B
032FE:  MOVLB  0
03300:  CALL   12E8
03304:  MOVFF  03,66F
03308:  MOVFF  02,66E
0330C:  MOVFF  01,66D
03310:  MOVFF  00,66C
03314:  MOVLB  6
.................... 
....................   if (s == 0 && n == 1)
03316:  BTFSC  x72.0
03318:  BRA    3352
0331A:  DECFSZ x67,W
0331C:  BRA    3352
....................    res += 1.0;
0331E:  BCF    FD8.1
03320:  MOVFF  66F,67A
03324:  MOVFF  66E,679
03328:  MOVFF  66D,678
0332C:  MOVFF  66C,677
03330:  CLRF   x7E
03332:  CLRF   x7D
03334:  CLRF   x7C
03336:  MOVLW  7F
03338:  MOVWF  x7B
0333A:  MOVLB  0
0333C:  CALL   12E8
03340:  MOVFF  03,66F
03344:  MOVFF  02,66E
03348:  MOVFF  01,66D
0334C:  MOVFF  00,66C
03350:  MOVLB  6
....................  }
....................  if (x == 0)
03352:  MOVFF  666,676
03356:  MOVFF  665,675
0335A:  MOVFF  664,674
0335E:  MOVFF  663,673
03362:  CLRF   x7A
03364:  CLRF   x79
03366:  CLRF   x78
03368:  CLRF   x77
0336A:  MOVLB  0
0336C:  CALL   25F0
03370:  BNZ   337E
....................     res = 0;
03372:  MOVLB  6
03374:  CLRF   x6F
03376:  CLRF   x6E
03378:  CLRF   x6D
0337A:  CLRF   x6C
0337C:  MOVLB  0
.................... 
....................  return (res);
0337E:  MOVFF  66C,00
03382:  MOVFF  66D,01
03386:  MOVFF  66E,02
0338A:  MOVFF  66F,03
0338E:  RETURN 0
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
*
033AE:  MOVFF  662,666
033B2:  MOVFF  661,665
033B6:  MOVFF  660,664
033BA:  MOVFF  65F,663
033BE:  MOVLB  6
033C0:  CLRF   x67
033C2:  MOVLB  0
033C4:  RCALL  3020
033C6:  GOTO   34D2 (RETURN)
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
*
03390:  MOVFF  662,666
03394:  MOVFF  661,665
03398:  MOVFF  660,664
0339C:  MOVFF  65F,663
033A0:  MOVLW  01
033A2:  MOVLB  6
033A4:  MOVWF  x67
033A6:  MOVLB  0
033A8:  RCALL  3020
033AA:  GOTO   348A (RETURN)
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
*
033CA:  MOVFF  656,676
033CE:  MOVFF  655,675
033D2:  MOVFF  654,674
033D6:  MOVFF  653,673
033DA:  MOVLB  6
033DC:  CLRF   x7A
033DE:  CLRF   x79
033E0:  CLRF   x78
033E2:  CLRF   x77
033E4:  MOVLB  0
033E6:  CALL   25F0
033EA:  BTFSC  FD8.2
033EC:  BRA    352E
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
033EE:  MOVFF  652,66F
033F2:  MOVFF  651,66E
033F6:  MOVFF  650,66D
033FA:  MOVFF  64F,66C
033FE:  MOVFF  656,673
03402:  MOVFF  655,672
03406:  MOVFF  654,671
0340A:  MOVFF  653,670
0340E:  CALL   266A
03412:  MOVFF  03,65E
03416:  MOVFF  02,65D
0341A:  MOVFF  01,65C
0341E:  MOVFF  00,65B
03422:  MOVFF  03,676
03426:  MOVFF  02,675
0342A:  MOVFF  01,674
0342E:  MOVFF  00,673
03432:  MOVLB  6
03434:  CLRF   x7A
03436:  CLRF   x79
03438:  CLRF   x78
0343A:  CLRF   x77
0343C:  MOVLB  0
0343E:  CALL   25F0
03442:  BNC   348C
03444:  MOVFF  652,66F
03448:  MOVFF  651,66E
0344C:  MOVFF  650,66D
03450:  MOVFF  64F,66C
03454:  MOVFF  656,673
03458:  MOVFF  655,672
0345C:  MOVFF  654,671
03460:  MOVFF  653,670
03464:  CALL   266A
03468:  MOVFF  03,65E
0346C:  MOVFF  02,65D
03470:  MOVFF  01,65C
03474:  MOVFF  00,65B
03478:  MOVFF  03,662
0347C:  MOVFF  02,661
03480:  MOVFF  01,660
03484:  MOVFF  00,65F
03488:  BRA    3390
0348A:  BRA    34D2
0348C:  MOVFF  652,66F
03490:  MOVFF  651,66E
03494:  MOVFF  650,66D
03498:  MOVFF  64F,66C
0349C:  MOVFF  656,673
034A0:  MOVFF  655,672
034A4:  MOVFF  654,671
034A8:  MOVFF  653,670
034AC:  CALL   266A
034B0:  MOVFF  03,65E
034B4:  MOVFF  02,65D
034B8:  MOVFF  01,65C
034BC:  MOVFF  00,65B
034C0:  MOVFF  03,662
034C4:  MOVFF  02,661
034C8:  MOVFF  01,660
034CC:  MOVFF  00,65F
034D0:  BRA    33AE
034D2:  MOVFF  03,65A
034D6:  MOVFF  02,659
034DA:  MOVFF  01,658
034DE:  MOVFF  00,657
....................       return(x-(i*y));
034E2:  MOVFF  65A,67B
034E6:  MOVFF  659,67A
034EA:  MOVFF  658,679
034EE:  MOVFF  657,678
034F2:  MOVFF  656,67F
034F6:  MOVFF  655,67E
034FA:  MOVFF  654,67D
034FE:  MOVFF  653,67C
03502:  CALL   11F2
03506:  BSF    FD8.1
03508:  MOVFF  652,67A
0350C:  MOVFF  651,679
03510:  MOVFF  650,678
03514:  MOVFF  64F,677
03518:  MOVFF  03,67E
0351C:  MOVFF  02,67D
03520:  MOVFF  01,67C
03524:  MOVFF  00,67B
03528:  CALL   12E8
0352C:  BRA    352E
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
0352E:  RETURN 0
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
*
038C4:  MOVFF  656,67B
038C8:  MOVFF  655,67A
038CC:  MOVFF  654,679
038D0:  MOVFF  653,678
038D4:  MOVLW  3B
038D6:  MOVLB  6
038D8:  MOVWF  x7F
038DA:  MOVLW  AA
038DC:  MOVWF  x7E
038DE:  MOVLW  38
038E0:  MOVWF  x7D
038E2:  MOVLW  7F
038E4:  MOVWF  x7C
038E6:  MOVLB  0
038E8:  CALL   11F2
038EC:  MOVFF  03,676
038F0:  MOVFF  02,675
038F4:  MOVFF  01,674
038F8:  MOVFF  00,673
038FC:  CALL   2FE4
03900:  MOVFF  01,663
....................    s = 0;
03904:  MOVLB  6
03906:  BCF    x64.0
....................    y = x;
03908:  MOVFF  656,65A
0390C:  MOVFF  655,659
03910:  MOVFF  654,658
03914:  MOVFF  653,657
.................... 
....................    if (x < 0)
03918:  MOVFF  656,676
0391C:  MOVFF  655,675
03920:  MOVFF  654,674
03924:  MOVFF  653,673
03928:  CLRF   x7A
0392A:  CLRF   x79
0392C:  CLRF   x78
0392E:  CLRF   x77
03930:  MOVLB  0
03932:  CALL   25F0
03936:  BNC   3946
....................    {
....................       s = 1;
03938:  MOVLB  6
0393A:  BSF    x64.0
....................       n = -n;
0393C:  NEGF   x63
....................       y = -y;
0393E:  MOVF   x58,W
03940:  XORLW  80
03942:  MOVWF  x58
03944:  MOVLB  0
....................    }
.................... 
....................    res = 0.0;
03946:  MOVLB  6
03948:  CLRF   x5E
0394A:  CLRF   x5D
0394C:  CLRF   x5C
0394E:  CLRF   x5B
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
03950:  MOVLW  06
03952:  MOVWF  x66
03954:  MOVLW  5B
03956:  MOVFF  666,FEA
0395A:  MOVWF  FE9
0395C:  MOVLW  7F
0395E:  ADDWF  x63,W
03960:  MOVWF  FEF
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
03962:  MOVFF  65A,67B
03966:  MOVFF  659,67A
0396A:  MOVFF  658,679
0396E:  MOVFF  657,678
03972:  MOVLW  3B
03974:  MOVWF  x7F
03976:  MOVLW  AA
03978:  MOVWF  x7E
0397A:  MOVLW  38
0397C:  MOVWF  x7D
0397E:  MOVLW  7F
03980:  MOVWF  x7C
03982:  MOVLB  0
03984:  CALL   11F2
03988:  MOVFF  03,668
0398C:  MOVFF  02,667
03990:  MOVFF  01,666
03994:  MOVFF  00,665
03998:  MOVLB  6
0399A:  CLRF   x6A
0399C:  MOVFF  663,669
039A0:  BTFSC  x69.7
039A2:  DECF   x6A,F
039A4:  MOVLB  0
039A6:  CALL   2F94
039AA:  BSF    FD8.1
039AC:  MOVFF  668,67A
039B0:  MOVFF  667,679
039B4:  MOVFF  666,678
039B8:  MOVFF  665,677
039BC:  MOVFF  03,67E
039C0:  MOVFF  02,67D
039C4:  MOVFF  01,67C
039C8:  MOVFF  00,67B
039CC:  CALL   12E8
039D0:  MOVFF  03,65A
039D4:  MOVFF  02,659
039D8:  MOVFF  01,658
039DC:  MOVFF  00,657
.................... 
....................    r = pe[0]*y + pe[1];
039E0:  MOVLW  7C
039E2:  MOVLB  6
039E4:  MOVWF  x7B
039E6:  MOVLW  88
039E8:  MOVWF  x7A
039EA:  MOVLW  59
039EC:  MOVWF  x79
039EE:  MOVLW  72
039F0:  MOVWF  x78
039F2:  MOVFF  65A,67F
039F6:  MOVFF  659,67E
039FA:  MOVFF  658,67D
039FE:  MOVFF  657,67C
03A02:  MOVLB  0
03A04:  CALL   11F2
03A08:  MOVFF  03,668
03A0C:  MOVFF  02,667
03A10:  MOVFF  01,666
03A14:  MOVFF  00,665
03A18:  BCF    FD8.1
03A1A:  MOVFF  03,67A
03A1E:  MOVFF  02,679
03A22:  MOVFF  01,678
03A26:  MOVFF  00,677
03A2A:  MOVLW  E0
03A2C:  MOVLB  6
03A2E:  MOVWF  x7E
03A30:  MOVLW  97
03A32:  MOVWF  x7D
03A34:  MOVLW  26
03A36:  MOVWF  x7C
03A38:  MOVLW  75
03A3A:  MOVWF  x7B
03A3C:  MOVLB  0
03A3E:  CALL   12E8
03A42:  MOVFF  03,662
03A46:  MOVFF  02,661
03A4A:  MOVFF  01,660
03A4E:  MOVFF  00,65F
....................    r = r*y + pe[2];
03A52:  MOVFF  662,67B
03A56:  MOVFF  661,67A
03A5A:  MOVFF  660,679
03A5E:  MOVFF  65F,678
03A62:  MOVFF  65A,67F
03A66:  MOVFF  659,67E
03A6A:  MOVFF  658,67D
03A6E:  MOVFF  657,67C
03A72:  CALL   11F2
03A76:  MOVFF  03,668
03A7A:  MOVFF  02,667
03A7E:  MOVFF  01,666
03A82:  MOVFF  00,665
03A86:  BCF    FD8.1
03A88:  MOVFF  03,67A
03A8C:  MOVFF  02,679
03A90:  MOVFF  01,678
03A94:  MOVFF  00,677
03A98:  MOVLW  C4
03A9A:  MOVLB  6
03A9C:  MOVWF  x7E
03A9E:  MOVLW  1D
03AA0:  MOVWF  x7D
03AA2:  MOVLW  1E
03AA4:  MOVWF  x7C
03AA6:  MOVLW  78
03AA8:  MOVWF  x7B
03AAA:  MOVLB  0
03AAC:  CALL   12E8
03AB0:  MOVFF  03,662
03AB4:  MOVFF  02,661
03AB8:  MOVFF  01,660
03ABC:  MOVFF  00,65F
....................    r = r*y + pe[3];
03AC0:  MOVFF  662,67B
03AC4:  MOVFF  661,67A
03AC8:  MOVFF  660,679
03ACC:  MOVFF  65F,678
03AD0:  MOVFF  65A,67F
03AD4:  MOVFF  659,67E
03AD8:  MOVFF  658,67D
03ADC:  MOVFF  657,67C
03AE0:  CALL   11F2
03AE4:  MOVFF  03,668
03AE8:  MOVFF  02,667
03AEC:  MOVFF  01,666
03AF0:  MOVFF  00,665
03AF4:  BCF    FD8.1
03AF6:  MOVFF  03,67A
03AFA:  MOVFF  02,679
03AFE:  MOVFF  01,678
03B02:  MOVFF  00,677
03B06:  MOVLW  5E
03B08:  MOVLB  6
03B0A:  MOVWF  x7E
03B0C:  MOVLW  50
03B0E:  MOVWF  x7D
03B10:  MOVLW  63
03B12:  MOVWF  x7C
03B14:  MOVLW  7A
03B16:  MOVWF  x7B
03B18:  MOVLB  0
03B1A:  CALL   12E8
03B1E:  MOVFF  03,662
03B22:  MOVFF  02,661
03B26:  MOVFF  01,660
03B2A:  MOVFF  00,65F
....................    r = r*y + pe[4];
03B2E:  MOVFF  662,67B
03B32:  MOVFF  661,67A
03B36:  MOVFF  660,679
03B3A:  MOVFF  65F,678
03B3E:  MOVFF  65A,67F
03B42:  MOVFF  659,67E
03B46:  MOVFF  658,67D
03B4A:  MOVFF  657,67C
03B4E:  CALL   11F2
03B52:  MOVFF  03,668
03B56:  MOVFF  02,667
03B5A:  MOVFF  01,666
03B5E:  MOVFF  00,665
03B62:  BCF    FD8.1
03B64:  MOVFF  03,67A
03B68:  MOVFF  02,679
03B6C:  MOVFF  01,678
03B70:  MOVFF  00,677
03B74:  MOVLW  1A
03B76:  MOVLB  6
03B78:  MOVWF  x7E
03B7A:  MOVLW  FE
03B7C:  MOVWF  x7D
03B7E:  MOVLW  75
03B80:  MOVWF  x7C
03B82:  MOVLW  7C
03B84:  MOVWF  x7B
03B86:  MOVLB  0
03B88:  CALL   12E8
03B8C:  MOVFF  03,662
03B90:  MOVFF  02,661
03B94:  MOVFF  01,660
03B98:  MOVFF  00,65F
....................    r = r*y + pe[5];
03B9C:  MOVFF  662,67B
03BA0:  MOVFF  661,67A
03BA4:  MOVFF  660,679
03BA8:  MOVFF  65F,678
03BAC:  MOVFF  65A,67F
03BB0:  MOVFF  659,67E
03BB4:  MOVFF  658,67D
03BB8:  MOVFF  657,67C
03BBC:  CALL   11F2
03BC0:  MOVFF  03,668
03BC4:  MOVFF  02,667
03BC8:  MOVFF  01,666
03BCC:  MOVFF  00,665
03BD0:  BCF    FD8.1
03BD2:  MOVFF  03,67A
03BD6:  MOVFF  02,679
03BDA:  MOVFF  01,678
03BDE:  MOVFF  00,677
03BE2:  MOVLW  18
03BE4:  MOVLB  6
03BE6:  MOVWF  x7E
03BE8:  MOVLW  72
03BEA:  MOVWF  x7D
03BEC:  MOVLW  31
03BEE:  MOVWF  x7C
03BF0:  MOVLW  7E
03BF2:  MOVWF  x7B
03BF4:  MOVLB  0
03BF6:  CALL   12E8
03BFA:  MOVFF  03,662
03BFE:  MOVFF  02,661
03C02:  MOVFF  01,660
03C06:  MOVFF  00,65F
.................... 
....................    res = res*(1.0 + y*r);
03C0A:  MOVFF  65A,67B
03C0E:  MOVFF  659,67A
03C12:  MOVFF  658,679
03C16:  MOVFF  657,678
03C1A:  MOVFF  662,67F
03C1E:  MOVFF  661,67E
03C22:  MOVFF  660,67D
03C26:  MOVFF  65F,67C
03C2A:  CALL   11F2
03C2E:  BCF    FD8.1
03C30:  MOVLB  6
03C32:  CLRF   x7A
03C34:  CLRF   x79
03C36:  CLRF   x78
03C38:  MOVLW  7F
03C3A:  MOVWF  x77
03C3C:  MOVFF  03,67E
03C40:  MOVFF  02,67D
03C44:  MOVFF  01,67C
03C48:  MOVFF  00,67B
03C4C:  MOVLB  0
03C4E:  CALL   12E8
03C52:  MOVFF  65E,67B
03C56:  MOVFF  65D,67A
03C5A:  MOVFF  65C,679
03C5E:  MOVFF  65B,678
03C62:  MOVFF  03,67F
03C66:  MOVFF  02,67E
03C6A:  MOVFF  01,67D
03C6E:  MOVFF  00,67C
03C72:  CALL   11F2
03C76:  MOVFF  03,65E
03C7A:  MOVFF  02,65D
03C7E:  MOVFF  01,65C
03C82:  MOVFF  00,65B
.................... 
....................    if (s)
03C86:  MOVLB  6
03C88:  BTFSS  x64.0
03C8A:  BRA    3CBE
....................       res = 1.0/res;
03C8C:  CLRF   x6F
03C8E:  CLRF   x6E
03C90:  CLRF   x6D
03C92:  MOVLW  7F
03C94:  MOVWF  x6C
03C96:  MOVFF  65E,673
03C9A:  MOVFF  65D,672
03C9E:  MOVFF  65C,671
03CA2:  MOVFF  65B,670
03CA6:  MOVLB  0
03CA8:  CALL   266A
03CAC:  MOVFF  03,65E
03CB0:  MOVFF  02,65D
03CB4:  MOVFF  01,65C
03CB8:  MOVFF  00,65B
03CBC:  MOVLB  6
....................    return(res);
03CBE:  MOVFF  65B,00
03CC2:  MOVFF  65C,01
03CC6:  MOVFF  65D,02
03CCA:  MOVFF  65E,03
03CCE:  MOVLB  0
03CD0:  RETURN 0
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
*
03530:  MOVFF  656,65A
03534:  MOVFF  655,659
03538:  MOVFF  654,658
0353C:  MOVFF  653,657
.................... 
....................    if (y != 1.0)
03540:  MOVFF  65A,676
03544:  MOVFF  659,675
03548:  MOVFF  658,674
0354C:  MOVFF  657,673
03550:  MOVLB  6
03552:  CLRF   x7A
03554:  CLRF   x79
03556:  CLRF   x78
03558:  MOVLW  7F
0355A:  MOVWF  x77
0355C:  MOVLB  0
0355E:  CALL   25F0
03562:  BTFSC  FD8.2
03564:  BRA    38A6
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
03566:  MOVLW  06
03568:  MOVLB  6
0356A:  MOVWF  x69
0356C:  MOVLW  57
0356E:  MOVFF  669,FEA
03572:  MOVWF  FE9
03574:  MOVLW  7E
03576:  MOVWF  FEF
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
03578:  BSF    FD8.1
0357A:  MOVFF  65A,67A
0357E:  MOVFF  659,679
03582:  MOVFF  658,678
03586:  MOVFF  657,677
0358A:  CLRF   x7E
0358C:  CLRF   x7D
0358E:  CLRF   x7C
03590:  MOVLW  7F
03592:  MOVWF  x7B
03594:  MOVLB  0
03596:  CALL   12E8
0359A:  MOVFF  03,66B
0359E:  MOVFF  02,66A
035A2:  MOVFF  01,669
035A6:  MOVFF  00,668
035AA:  BCF    FD8.1
035AC:  MOVFF  65A,67A
035B0:  MOVFF  659,679
035B4:  MOVFF  658,678
035B8:  MOVFF  657,677
035BC:  MOVLB  6
035BE:  CLRF   x7E
035C0:  CLRF   x7D
035C2:  CLRF   x7C
035C4:  MOVLW  7F
035C6:  MOVWF  x7B
035C8:  MOVLB  0
035CA:  CALL   12E8
035CE:  MOVFF  66B,66F
035D2:  MOVFF  66A,66E
035D6:  MOVFF  669,66D
035DA:  MOVFF  668,66C
035DE:  MOVFF  03,673
035E2:  MOVFF  02,672
035E6:  MOVFF  01,671
035EA:  MOVFF  00,670
035EE:  CALL   266A
035F2:  MOVFF  03,65A
035F6:  MOVFF  02,659
035FA:  MOVFF  01,658
035FE:  MOVFF  00,657
.................... 
....................       y2=y*y;
03602:  MOVFF  65A,67B
03606:  MOVFF  659,67A
0360A:  MOVFF  658,679
0360E:  MOVFF  657,678
03612:  MOVFF  65A,67F
03616:  MOVFF  659,67E
0361A:  MOVFF  658,67D
0361E:  MOVFF  657,67C
03622:  CALL   11F2
03626:  MOVFF  03,666
0362A:  MOVFF  02,665
0362E:  MOVFF  01,664
03632:  MOVFF  00,663
.................... 
....................       res = pl[0]*y2 + pl[1];
03636:  MOVLW  99
03638:  MOVLB  6
0363A:  MOVWF  x7B
0363C:  MOVLW  47
0363E:  MOVWF  x7A
03640:  MOVLW  8A
03642:  MOVWF  x79
03644:  MOVLW  7F
03646:  MOVWF  x78
03648:  MOVFF  666,67F
0364C:  MOVFF  665,67E
03650:  MOVFF  664,67D
03654:  MOVFF  663,67C
03658:  MOVLB  0
0365A:  CALL   11F2
0365E:  MOVFF  03,66B
03662:  MOVFF  02,66A
03666:  MOVFF  01,669
0366A:  MOVFF  00,668
0366E:  BCF    FD8.1
03670:  MOVFF  03,67A
03674:  MOVFF  02,679
03678:  MOVFF  01,678
0367C:  MOVFF  00,677
03680:  MOVLB  6
03682:  CLRF   x7E
03684:  CLRF   x7D
03686:  CLRF   x7C
03688:  MOVLW  80
0368A:  MOVWF  x7B
0368C:  MOVLB  0
0368E:  CALL   12E8
03692:  MOVFF  03,65E
03696:  MOVFF  02,65D
0369A:  MOVFF  01,65C
0369E:  MOVFF  00,65B
.................... 
....................       r = ql[0]*y2 + ql[1];
036A2:  MOVLW  4C
036A4:  MOVLB  6
036A6:  MOVWF  x7B
036A8:  MOVLW  F3
036AA:  MOVWF  x7A
036AC:  MOVLW  3A
036AE:  MOVWF  x79
036B0:  MOVLW  7B
036B2:  MOVWF  x78
036B4:  MOVFF  666,67F
036B8:  MOVFF  665,67E
036BC:  MOVFF  664,67D
036C0:  MOVFF  663,67C
036C4:  MOVLB  0
036C6:  CALL   11F2
036CA:  MOVFF  03,66B
036CE:  MOVFF  02,66A
036D2:  MOVFF  01,669
036D6:  MOVFF  00,668
036DA:  BCF    FD8.1
036DC:  MOVFF  03,67A
036E0:  MOVFF  02,679
036E4:  MOVFF  01,678
036E8:  MOVFF  00,677
036EC:  MOVLW  2B
036EE:  MOVLB  6
036F0:  MOVWF  x7E
036F2:  MOVLW  9D
036F4:  MOVWF  x7D
036F6:  MOVLW  DF
036F8:  MOVWF  x7C
036FA:  MOVLW  7E
036FC:  MOVWF  x7B
036FE:  MOVLB  0
03700:  CALL   12E8
03704:  MOVFF  03,662
03708:  MOVFF  02,661
0370C:  MOVFF  01,660
03710:  MOVFF  00,65F
....................       r = r*y2 + 1.0;
03714:  MOVFF  662,67B
03718:  MOVFF  661,67A
0371C:  MOVFF  660,679
03720:  MOVFF  65F,678
03724:  MOVFF  666,67F
03728:  MOVFF  665,67E
0372C:  MOVFF  664,67D
03730:  MOVFF  663,67C
03734:  CALL   11F2
03738:  MOVFF  03,66B
0373C:  MOVFF  02,66A
03740:  MOVFF  01,669
03744:  MOVFF  00,668
03748:  BCF    FD8.1
0374A:  MOVFF  03,67A
0374E:  MOVFF  02,679
03752:  MOVFF  01,678
03756:  MOVFF  00,677
0375A:  MOVLB  6
0375C:  CLRF   x7E
0375E:  CLRF   x7D
03760:  CLRF   x7C
03762:  MOVLW  7F
03764:  MOVWF  x7B
03766:  MOVLB  0
03768:  CALL   12E8
0376C:  MOVFF  03,662
03770:  MOVFF  02,661
03774:  MOVFF  01,660
03778:  MOVFF  00,65F
.................... 
....................       res = y*res/r;
0377C:  MOVFF  65A,67B
03780:  MOVFF  659,67A
03784:  MOVFF  658,679
03788:  MOVFF  657,678
0378C:  MOVFF  65E,67F
03790:  MOVFF  65D,67E
03794:  MOVFF  65C,67D
03798:  MOVFF  65B,67C
0379C:  CALL   11F2
037A0:  MOVFF  03,66B
037A4:  MOVFF  02,66A
037A8:  MOVFF  01,669
037AC:  MOVFF  00,668
037B0:  MOVFF  03,66F
037B4:  MOVFF  02,66E
037B8:  MOVFF  01,66D
037BC:  MOVFF  00,66C
037C0:  MOVFF  662,673
037C4:  MOVFF  661,672
037C8:  MOVFF  660,671
037CC:  MOVFF  65F,670
037D0:  CALL   266A
037D4:  MOVFF  03,65E
037D8:  MOVFF  02,65D
037DC:  MOVFF  01,65C
037E0:  MOVFF  00,65B
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
037E4:  MOVLW  06
037E6:  MOVLB  6
037E8:  MOVWF  x69
037EA:  MOVLW  53
037EC:  MOVFF  669,FEA
037F0:  MOVWF  FE9
037F2:  MOVLW  7E
037F4:  SUBWF  FEF,W
037F6:  MOVWF  x67
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
037F8:  BTFSS  x67.7
037FA:  BRA    3826
....................          r = -(float32)-n;
037FC:  MOVLW  00
037FE:  BSF    FD8.0
03800:  SUBFWB x67,W
03802:  CLRF   x6A
03804:  MOVWF  x69
03806:  BTFSC  x69.7
03808:  DECF   x6A,F
0380A:  MOVLB  0
0380C:  CALL   2F94
03810:  MOVFF  00,65F
03814:  MOVF   01,W
03816:  XORLW  80
03818:  MOVLB  6
0381A:  MOVWF  x60
0381C:  MOVFF  02,661
03820:  MOVFF  03,662
03824:  BRA    3848
....................       else
....................          r = (float32)n;
03826:  CLRF   x6A
03828:  MOVFF  667,669
0382C:  BTFSC  x69.7
0382E:  DECF   x6A,F
03830:  MOVLB  0
03832:  CALL   2F94
03836:  MOVFF  03,662
0383A:  MOVFF  02,661
0383E:  MOVFF  01,660
03842:  MOVFF  00,65F
03846:  MOVLB  6
.................... 
....................       res += r*LN2;
03848:  MOVFF  662,67B
0384C:  MOVFF  661,67A
03850:  MOVFF  660,679
03854:  MOVFF  65F,678
03858:  MOVLW  18
0385A:  MOVWF  x7F
0385C:  MOVLW  72
0385E:  MOVWF  x7E
03860:  MOVLW  31
03862:  MOVWF  x7D
03864:  MOVLW  7E
03866:  MOVWF  x7C
03868:  MOVLB  0
0386A:  CALL   11F2
0386E:  BCF    FD8.1
03870:  MOVFF  65E,67A
03874:  MOVFF  65D,679
03878:  MOVFF  65C,678
0387C:  MOVFF  65B,677
03880:  MOVFF  03,67E
03884:  MOVFF  02,67D
03888:  MOVFF  01,67C
0388C:  MOVFF  00,67B
03890:  CALL   12E8
03894:  MOVFF  03,65E
03898:  MOVFF  02,65D
0389C:  MOVFF  01,65C
038A0:  MOVFF  00,65B
....................    }
038A4:  BRA    38B2
.................... 
....................    else
....................       res = 0.0;
038A6:  MOVLB  6
038A8:  CLRF   x5E
038AA:  CLRF   x5D
038AC:  CLRF   x5C
038AE:  CLRF   x5B
038B0:  MOVLB  0
.................... 
....................    return(res);
038B2:  MOVFF  65B,00
038B6:  MOVFF  65C,01
038BA:  MOVFF  65D,02
038BE:  MOVFF  65E,03
038C2:  RETURN 0
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
*
03CD2:  MOVFF  64A,676
03CD6:  MOVFF  649,675
03CDA:  MOVFF  648,674
03CDE:  MOVFF  647,673
03CE2:  MOVLB  6
03CE4:  CLRF   x7A
03CE6:  CLRF   x79
03CE8:  CLRF   x78
03CEA:  CLRF   x77
03CEC:  MOVLB  0
03CEE:  CALL   25F0
03CF2:  BTFSS  FD8.0
03CF4:  BRA    3E90
03CF6:  MOVFF  64E,652
03CFA:  MOVFF  64D,651
03CFE:  MOVFF  64C,650
03D02:  MOVFF  64B,64F
03D06:  MOVLB  6
03D08:  CLRF   x56
03D0A:  CLRF   x55
03D0C:  CLRF   x54
03D0E:  MOVLW  7F
03D10:  MOVWF  x53
03D12:  MOVLB  0
03D14:  CALL   33CA
03D18:  MOVFF  03,652
03D1C:  MOVFF  02,651
03D20:  MOVFF  01,650
03D24:  MOVFF  00,64F
03D28:  MOVFF  03,676
03D2C:  MOVFF  02,675
03D30:  MOVFF  01,674
03D34:  MOVFF  00,673
03D38:  MOVLB  6
03D3A:  CLRF   x7A
03D3C:  CLRF   x79
03D3E:  CLRF   x78
03D40:  CLRF   x77
03D42:  MOVLB  0
03D44:  CALL   25F0
03D48:  BTFSS  FD8.2
03D4A:  BRA    3E90
....................       if(fmod(y, 2) == 0) {
03D4C:  MOVFF  64E,652
03D50:  MOVFF  64D,651
03D54:  MOVFF  64C,650
03D58:  MOVFF  64B,64F
03D5C:  MOVLB  6
03D5E:  CLRF   x56
03D60:  CLRF   x55
03D62:  CLRF   x54
03D64:  MOVLW  80
03D66:  MOVWF  x53
03D68:  MOVLB  0
03D6A:  CALL   33CA
03D6E:  MOVFF  03,652
03D72:  MOVFF  02,651
03D76:  MOVFF  01,650
03D7A:  MOVFF  00,64F
03D7E:  MOVFF  03,676
03D82:  MOVFF  02,675
03D86:  MOVFF  01,674
03D8A:  MOVFF  00,673
03D8E:  MOVLB  6
03D90:  CLRF   x7A
03D92:  CLRF   x79
03D94:  CLRF   x78
03D96:  CLRF   x77
03D98:  MOVLB  0
03D9A:  CALL   25F0
03D9E:  BNZ   3E16
....................          return (exp(log(-x) * y));
03DA0:  MOVLB  6
03DA2:  MOVF   x48,W
03DA4:  XORLW  80
03DA6:  MOVWF  x50
03DA8:  MOVFF  64A,656
03DAC:  MOVFF  649,655
03DB0:  MOVWF  x54
03DB2:  MOVFF  647,653
03DB6:  MOVLB  0
03DB8:  CALL   3530
03DBC:  MOVFF  03,652
03DC0:  MOVFF  02,651
03DC4:  MOVFF  01,650
03DC8:  MOVFF  00,64F
03DCC:  MOVFF  03,67B
03DD0:  MOVFF  02,67A
03DD4:  MOVFF  01,679
03DD8:  MOVFF  00,678
03DDC:  MOVFF  64E,67F
03DE0:  MOVFF  64D,67E
03DE4:  MOVFF  64C,67D
03DE8:  MOVFF  64B,67C
03DEC:  CALL   11F2
03DF0:  MOVFF  03,652
03DF4:  MOVFF  02,651
03DF8:  MOVFF  01,650
03DFC:  MOVFF  00,64F
03E00:  MOVFF  03,656
03E04:  MOVFF  02,655
03E08:  MOVFF  01,654
03E0C:  MOVFF  00,653
03E10:  RCALL  38C4
03E12:  BRA    3FCE
....................       } else {
03E14:  BRA    3E8E
....................          return (-exp(log(-x) * y));
03E16:  MOVLB  6
03E18:  MOVF   x48,W
03E1A:  XORLW  80
03E1C:  MOVWF  x50
03E1E:  MOVFF  64A,656
03E22:  MOVFF  649,655
03E26:  MOVWF  x54
03E28:  MOVFF  647,653
03E2C:  MOVLB  0
03E2E:  CALL   3530
03E32:  MOVFF  03,652
03E36:  MOVFF  02,651
03E3A:  MOVFF  01,650
03E3E:  MOVFF  00,64F
03E42:  MOVFF  03,67B
03E46:  MOVFF  02,67A
03E4A:  MOVFF  01,679
03E4E:  MOVFF  00,678
03E52:  MOVFF  64E,67F
03E56:  MOVFF  64D,67E
03E5A:  MOVFF  64C,67D
03E5E:  MOVFF  64B,67C
03E62:  CALL   11F2
03E66:  MOVFF  03,652
03E6A:  MOVFF  02,651
03E6E:  MOVFF  01,650
03E72:  MOVFF  00,64F
03E76:  MOVFF  03,656
03E7A:  MOVFF  02,655
03E7E:  MOVFF  01,654
03E82:  MOVFF  00,653
03E86:  RCALL  38C4
03E88:  MOVLW  80
03E8A:  XORWF  01,F
03E8C:  BRA    3FCE
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
03E8E:  BRA    3FCE
03E90:  MOVFF  64A,676
03E94:  MOVFF  649,675
03E98:  MOVFF  648,674
03E9C:  MOVFF  647,673
03EA0:  MOVLB  6
03EA2:  CLRF   x7A
03EA4:  CLRF   x79
03EA6:  CLRF   x78
03EA8:  CLRF   x77
03EAA:  MOVLB  0
03EAC:  CALL   25F0
03EB0:  BNC   3F12
03EB2:  MOVFF  64E,652
03EB6:  MOVFF  64D,651
03EBA:  MOVFF  64C,650
03EBE:  MOVFF  64B,64F
03EC2:  MOVLB  6
03EC4:  CLRF   x56
03EC6:  CLRF   x55
03EC8:  CLRF   x54
03ECA:  MOVLW  7F
03ECC:  MOVWF  x53
03ECE:  MOVLB  0
03ED0:  CALL   33CA
03ED4:  MOVFF  03,652
03ED8:  MOVFF  02,651
03EDC:  MOVFF  01,650
03EE0:  MOVFF  00,64F
03EE4:  MOVFF  03,676
03EE8:  MOVFF  02,675
03EEC:  MOVFF  01,674
03EF0:  MOVFF  00,673
03EF4:  MOVLB  6
03EF6:  CLRF   x7A
03EF8:  CLRF   x79
03EFA:  CLRF   x78
03EFC:  CLRF   x77
03EFE:  MOVLB  0
03F00:  CALL   25F0
03F04:  BZ    3F12
....................       return 0;
03F06:  CLRF   00
03F08:  CLRF   01
03F0A:  CLRF   02
03F0C:  CLRF   03
03F0E:  BRA    3FCE
....................    } else {
03F10:  BRA    3FCE
....................       if(x != 0 || 0 >= y) {
03F12:  MOVFF  64A,676
03F16:  MOVFF  649,675
03F1A:  MOVFF  648,674
03F1E:  MOVFF  647,673
03F22:  MOVLB  6
03F24:  CLRF   x7A
03F26:  CLRF   x79
03F28:  CLRF   x78
03F2A:  CLRF   x77
03F2C:  MOVLB  0
03F2E:  CALL   25F0
03F32:  BNZ   3F58
03F34:  MOVFF  64E,676
03F38:  MOVFF  64D,675
03F3C:  MOVFF  64C,674
03F40:  MOVFF  64B,673
03F44:  MOVLB  6
03F46:  CLRF   x7A
03F48:  CLRF   x79
03F4A:  CLRF   x78
03F4C:  CLRF   x77
03F4E:  MOVLB  0
03F50:  CALL   25F0
03F54:  BC    3F58
03F56:  BNZ   3FC6
....................          return (exp(log(x) * y));
03F58:  MOVFF  64A,656
03F5C:  MOVFF  649,655
03F60:  MOVFF  648,654
03F64:  MOVFF  647,653
03F68:  CALL   3530
03F6C:  MOVFF  03,652
03F70:  MOVFF  02,651
03F74:  MOVFF  01,650
03F78:  MOVFF  00,64F
03F7C:  MOVFF  03,67B
03F80:  MOVFF  02,67A
03F84:  MOVFF  01,679
03F88:  MOVFF  00,678
03F8C:  MOVFF  64E,67F
03F90:  MOVFF  64D,67E
03F94:  MOVFF  64C,67D
03F98:  MOVFF  64B,67C
03F9C:  CALL   11F2
03FA0:  MOVFF  03,652
03FA4:  MOVFF  02,651
03FA8:  MOVFF  01,650
03FAC:  MOVFF  00,64F
03FB0:  MOVFF  03,656
03FB4:  MOVFF  02,655
03FB8:  MOVFF  01,654
03FBC:  MOVFF  00,653
03FC0:  RCALL  38C4
03FC2:  BRA    3FCE
....................       } else return 0;
03FC4:  BRA    3FCE
03FC6:  CLRF   00
03FC8:  CLRF   01
03FCA:  CLRF   02
03FCC:  CLRF   03
....................    }
03FCE:  RETURN 0
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
*
027C8:  MOVLB  6
027CA:  BCF    x65.0
....................    flag = 0;
027CC:  BCF    x65.1
....................    y = x;
027CE:  MOVFF  658,65C
027D2:  MOVFF  657,65B
027D6:  MOVFF  656,65A
027DA:  MOVFF  655,659
.................... 
....................    if (x < 0)
027DE:  MOVFF  658,676
027E2:  MOVFF  657,675
027E6:  MOVFF  656,674
027EA:  MOVFF  655,673
027EE:  CLRF   x7A
027F0:  CLRF   x79
027F2:  CLRF   x78
027F4:  CLRF   x77
027F6:  MOVLB  0
027F8:  RCALL  25F0
027FA:  BNC   2808
....................    {
....................       s = 1;
027FC:  MOVLB  6
027FE:  BSF    x65.0
....................       y = -y;
02800:  MOVF   x5A,W
02802:  XORLW  80
02804:  MOVWF  x5A
02806:  MOVLB  0
....................    }
.................... 
....................    if (y > 1.0)
02808:  MOVLB  6
0280A:  CLRF   x76
0280C:  CLRF   x75
0280E:  CLRF   x74
02810:  MOVLW  7F
02812:  MOVWF  x73
02814:  MOVFF  65C,67A
02818:  MOVFF  65B,679
0281C:  MOVFF  65A,678
02820:  MOVFF  659,677
02824:  MOVLB  0
02826:  RCALL  25F0
02828:  BNC   2860
....................    {
....................       y = 1.0/y;
0282A:  MOVLB  6
0282C:  CLRF   x6F
0282E:  CLRF   x6E
02830:  CLRF   x6D
02832:  MOVLW  7F
02834:  MOVWF  x6C
02836:  MOVFF  65C,673
0283A:  MOVFF  65B,672
0283E:  MOVFF  65A,671
02842:  MOVFF  659,670
02846:  MOVLB  0
02848:  RCALL  266A
0284A:  MOVFF  03,65C
0284E:  MOVFF  02,65B
02852:  MOVFF  01,65A
02856:  MOVFF  00,659
....................       flag = 1;
0285A:  MOVLB  6
0285C:  BSF    x65.1
0285E:  MOVLB  0
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
02860:  MOVLW  0A
02862:  MOVLB  6
02864:  MOVWF  x7B
02866:  MOVLW  89
02868:  MOVWF  x7A
0286A:  MOVLW  34
0286C:  MOVWF  x79
0286E:  MOVLW  7C
02870:  MOVWF  x78
02872:  MOVFF  65C,67F
02876:  MOVFF  65B,67E
0287A:  MOVFF  65A,67D
0287E:  MOVFF  659,67C
02882:  MOVLB  0
02884:  CALL   11F2
02888:  MOVFF  03,669
0288C:  MOVFF  02,668
02890:  MOVFF  01,667
02894:  MOVFF  00,666
02898:  MOVFF  03,67B
0289C:  MOVFF  02,67A
028A0:  MOVFF  01,679
028A4:  MOVFF  00,678
028A8:  MOVFF  65C,67F
028AC:  MOVFF  65B,67E
028B0:  MOVFF  65A,67D
028B4:  MOVFF  659,67C
028B8:  CALL   11F2
028BC:  MOVFF  03,669
028C0:  MOVFF  02,668
028C4:  MOVFF  01,667
028C8:  MOVFF  00,666
028CC:  BCF    FD8.1
028CE:  MOVFF  03,67A
028D2:  MOVFF  02,679
028D6:  MOVFF  01,678
028DA:  MOVFF  00,677
028DE:  MOVLW  7C
028E0:  MOVLB  6
028E2:  MOVWF  x7E
028E4:  MOVLW  79
028E6:  MOVWF  x7D
028E8:  MOVLW  35
028EA:  MOVWF  x7C
028EC:  MOVLW  81
028EE:  MOVWF  x7B
028F0:  MOVLB  0
028F2:  CALL   12E8
028F6:  MOVFF  03,660
028FA:  MOVFF  02,65F
028FE:  MOVFF  01,65E
02902:  MOVFF  00,65D
....................    res = res*y*y + pat[2];
02906:  MOVFF  660,67B
0290A:  MOVFF  65F,67A
0290E:  MOVFF  65E,679
02912:  MOVFF  65D,678
02916:  MOVFF  65C,67F
0291A:  MOVFF  65B,67E
0291E:  MOVFF  65A,67D
02922:  MOVFF  659,67C
02926:  CALL   11F2
0292A:  MOVFF  03,669
0292E:  MOVFF  02,668
02932:  MOVFF  01,667
02936:  MOVFF  00,666
0293A:  MOVFF  03,67B
0293E:  MOVFF  02,67A
02942:  MOVFF  01,679
02946:  MOVFF  00,678
0294A:  MOVFF  65C,67F
0294E:  MOVFF  65B,67E
02952:  MOVFF  65A,67D
02956:  MOVFF  659,67C
0295A:  CALL   11F2
0295E:  MOVFF  03,669
02962:  MOVFF  02,668
02966:  MOVFF  01,667
0296A:  MOVFF  00,666
0296E:  BCF    FD8.1
02970:  MOVFF  03,67A
02974:  MOVFF  02,679
02978:  MOVFF  01,678
0297C:  MOVFF  00,677
02980:  MOVLW  3F
02982:  MOVLB  6
02984:  MOVWF  x7E
02986:  MOVLW  02
02988:  MOVWF  x7D
0298A:  MOVLW  33
0298C:  MOVWF  x7C
0298E:  MOVLW  83
02990:  MOVWF  x7B
02992:  MOVLB  0
02994:  CALL   12E8
02998:  MOVFF  03,660
0299C:  MOVFF  02,65F
029A0:  MOVFF  01,65E
029A4:  MOVFF  00,65D
....................    res = res*y*y + pat[3];
029A8:  MOVFF  660,67B
029AC:  MOVFF  65F,67A
029B0:  MOVFF  65E,679
029B4:  MOVFF  65D,678
029B8:  MOVFF  65C,67F
029BC:  MOVFF  65B,67E
029C0:  MOVFF  65A,67D
029C4:  MOVFF  659,67C
029C8:  CALL   11F2
029CC:  MOVFF  03,669
029D0:  MOVFF  02,668
029D4:  MOVFF  01,667
029D8:  MOVFF  00,666
029DC:  MOVFF  03,67B
029E0:  MOVFF  02,67A
029E4:  MOVFF  01,679
029E8:  MOVFF  00,678
029EC:  MOVFF  65C,67F
029F0:  MOVFF  65B,67E
029F4:  MOVFF  65A,67D
029F8:  MOVFF  659,67C
029FC:  CALL   11F2
02A00:  MOVFF  03,669
02A04:  MOVFF  02,668
02A08:  MOVFF  01,667
02A0C:  MOVFF  00,666
02A10:  BCF    FD8.1
02A12:  MOVFF  03,67A
02A16:  MOVFF  02,679
02A1A:  MOVFF  01,678
02A1E:  MOVFF  00,677
02A22:  MOVLW  33
02A24:  MOVLB  6
02A26:  MOVWF  x7E
02A28:  MOVLW  8C
02A2A:  MOVWF  x7D
02A2C:  MOVLW  1E
02A2E:  MOVWF  x7C
02A30:  MOVLW  83
02A32:  MOVWF  x7B
02A34:  MOVLB  0
02A36:  CALL   12E8
02A3A:  MOVFF  03,660
02A3E:  MOVFF  02,65F
02A42:  MOVFF  01,65E
02A46:  MOVFF  00,65D
.................... 
....................    r = qat[0]*y*y + qat[1];
02A4A:  MOVLB  6
02A4C:  CLRF   x7B
02A4E:  CLRF   x7A
02A50:  CLRF   x79
02A52:  MOVLW  7F
02A54:  MOVWF  x78
02A56:  MOVFF  65C,67F
02A5A:  MOVFF  65B,67E
02A5E:  MOVFF  65A,67D
02A62:  MOVFF  659,67C
02A66:  MOVLB  0
02A68:  CALL   11F2
02A6C:  MOVFF  03,669
02A70:  MOVFF  02,668
02A74:  MOVFF  01,667
02A78:  MOVFF  00,666
02A7C:  MOVFF  03,67B
02A80:  MOVFF  02,67A
02A84:  MOVFF  01,679
02A88:  MOVFF  00,678
02A8C:  MOVFF  65C,67F
02A90:  MOVFF  65B,67E
02A94:  MOVFF  65A,67D
02A98:  MOVFF  659,67C
02A9C:  CALL   11F2
02AA0:  MOVFF  03,669
02AA4:  MOVFF  02,668
02AA8:  MOVFF  01,667
02AAC:  MOVFF  00,666
02AB0:  BCF    FD8.1
02AB2:  MOVFF  03,67A
02AB6:  MOVFF  02,679
02ABA:  MOVFF  01,678
02ABE:  MOVFF  00,677
02AC2:  MOVLW  1B
02AC4:  MOVLB  6
02AC6:  MOVWF  x7E
02AC8:  MOVLW  E4
02ACA:  MOVWF  x7D
02ACC:  MOVLW  35
02ACE:  MOVWF  x7C
02AD0:  MOVLW  82
02AD2:  MOVWF  x7B
02AD4:  MOVLB  0
02AD6:  CALL   12E8
02ADA:  MOVFF  03,664
02ADE:  MOVFF  02,663
02AE2:  MOVFF  01,662
02AE6:  MOVFF  00,661
....................    r = r*y*y + qat[2];
02AEA:  MOVFF  664,67B
02AEE:  MOVFF  663,67A
02AF2:  MOVFF  662,679
02AF6:  MOVFF  661,678
02AFA:  MOVFF  65C,67F
02AFE:  MOVFF  65B,67E
02B02:  MOVFF  65A,67D
02B06:  MOVFF  659,67C
02B0A:  CALL   11F2
02B0E:  MOVFF  03,669
02B12:  MOVFF  02,668
02B16:  MOVFF  01,667
02B1A:  MOVFF  00,666
02B1E:  MOVFF  03,67B
02B22:  MOVFF  02,67A
02B26:  MOVFF  01,679
02B2A:  MOVFF  00,678
02B2E:  MOVFF  65C,67F
02B32:  MOVFF  65B,67E
02B36:  MOVFF  65A,67D
02B3A:  MOVFF  659,67C
02B3E:  CALL   11F2
02B42:  MOVFF  03,669
02B46:  MOVFF  02,668
02B4A:  MOVFF  01,667
02B4E:  MOVFF  00,666
02B52:  BCF    FD8.1
02B54:  MOVFF  03,67A
02B58:  MOVFF  02,679
02B5C:  MOVFF  01,678
02B60:  MOVFF  00,677
02B64:  MOVLW  A4
02B66:  MOVLB  6
02B68:  MOVWF  x7E
02B6A:  MOVLW  DB
02B6C:  MOVWF  x7D
02B6E:  MOVLW  67
02B70:  MOVWF  x7C
02B72:  MOVLW  83
02B74:  MOVWF  x7B
02B76:  MOVLB  0
02B78:  CALL   12E8
02B7C:  MOVFF  03,664
02B80:  MOVFF  02,663
02B84:  MOVFF  01,662
02B88:  MOVFF  00,661
....................    r = r*y*y + qat[3];
02B8C:  MOVFF  664,67B
02B90:  MOVFF  663,67A
02B94:  MOVFF  662,679
02B98:  MOVFF  661,678
02B9C:  MOVFF  65C,67F
02BA0:  MOVFF  65B,67E
02BA4:  MOVFF  65A,67D
02BA8:  MOVFF  659,67C
02BAC:  CALL   11F2
02BB0:  MOVFF  03,669
02BB4:  MOVFF  02,668
02BB8:  MOVFF  01,667
02BBC:  MOVFF  00,666
02BC0:  MOVFF  03,67B
02BC4:  MOVFF  02,67A
02BC8:  MOVFF  01,679
02BCC:  MOVFF  00,678
02BD0:  MOVFF  65C,67F
02BD4:  MOVFF  65B,67E
02BD8:  MOVFF  65A,67D
02BDC:  MOVFF  659,67C
02BE0:  CALL   11F2
02BE4:  MOVFF  03,669
02BE8:  MOVFF  02,668
02BEC:  MOVFF  01,667
02BF0:  MOVFF  00,666
02BF4:  BCF    FD8.1
02BF6:  MOVFF  03,67A
02BFA:  MOVFF  02,679
02BFE:  MOVFF  01,678
02C02:  MOVFF  00,677
02C06:  MOVLW  33
02C08:  MOVLB  6
02C0A:  MOVWF  x7E
02C0C:  MOVLW  8C
02C0E:  MOVWF  x7D
02C10:  MOVLW  1E
02C12:  MOVWF  x7C
02C14:  MOVLW  83
02C16:  MOVWF  x7B
02C18:  MOVLB  0
02C1A:  CALL   12E8
02C1E:  MOVFF  03,664
02C22:  MOVFF  02,663
02C26:  MOVFF  01,662
02C2A:  MOVFF  00,661
.................... 
....................    res = y*res/r;
02C2E:  MOVFF  65C,67B
02C32:  MOVFF  65B,67A
02C36:  MOVFF  65A,679
02C3A:  MOVFF  659,678
02C3E:  MOVFF  660,67F
02C42:  MOVFF  65F,67E
02C46:  MOVFF  65E,67D
02C4A:  MOVFF  65D,67C
02C4E:  CALL   11F2
02C52:  MOVFF  03,669
02C56:  MOVFF  02,668
02C5A:  MOVFF  01,667
02C5E:  MOVFF  00,666
02C62:  MOVFF  03,66F
02C66:  MOVFF  02,66E
02C6A:  MOVFF  01,66D
02C6E:  MOVFF  00,66C
02C72:  MOVFF  664,673
02C76:  MOVFF  663,672
02C7A:  MOVFF  662,671
02C7E:  MOVFF  661,670
02C82:  RCALL  266A
02C84:  MOVFF  03,660
02C88:  MOVFF  02,65F
02C8C:  MOVFF  01,65E
02C90:  MOVFF  00,65D
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
02C94:  MOVLB  6
02C96:  BTFSS  x65.1
02C98:  BRA    2CD4
....................       res = PI_DIV_BY_TWO - res;
02C9A:  BSF    FD8.1
02C9C:  MOVLW  DB
02C9E:  MOVWF  x7A
02CA0:  MOVLW  0F
02CA2:  MOVWF  x79
02CA4:  MOVLW  49
02CA6:  MOVWF  x78
02CA8:  MOVLW  7F
02CAA:  MOVWF  x77
02CAC:  MOVFF  660,67E
02CB0:  MOVFF  65F,67D
02CB4:  MOVFF  65E,67C
02CB8:  MOVFF  65D,67B
02CBC:  MOVLB  0
02CBE:  CALL   12E8
02CC2:  MOVFF  03,660
02CC6:  MOVFF  02,65F
02CCA:  MOVFF  01,65E
02CCE:  MOVFF  00,65D
02CD2:  MOVLB  6
....................    if (s)
02CD4:  BTFSS  x65.0
02CD6:  BRA    2CDE
....................       res = -res;
02CD8:  MOVF   x5E,W
02CDA:  XORLW  80
02CDC:  MOVWF  x5E
.................... 
....................    return(res);
02CDE:  MOVFF  65D,00
02CE2:  MOVFF  65E,01
02CE6:  MOVFF  65F,02
02CEA:  MOVFF  660,03
02CEE:  MOVLB  0
02CF0:  RETURN 0
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
02CF2:  MOVLB  6
02CF4:  BCF    x53.0
....................    quad=0; //quadrant
02CF6:  CLRF   x54
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
02CF8:  MOVFF  64A,676
02CFC:  MOVFF  649,675
02D00:  MOVFF  648,674
02D04:  MOVFF  647,673
02D08:  CLRF   x7A
02D0A:  CLRF   x79
02D0C:  CLRF   x78
02D0E:  CLRF   x77
02D10:  MOVLB  0
02D12:  RCALL  25F0
02D14:  BC    2D18
02D16:  BNZ   2D42
02D18:  MOVFF  64E,676
02D1C:  MOVFF  64D,675
02D20:  MOVFF  64C,674
02D24:  MOVFF  64B,673
02D28:  MOVLB  6
02D2A:  CLRF   x7A
02D2C:  CLRF   x79
02D2E:  CLRF   x78
02D30:  CLRF   x77
02D32:  MOVLB  0
02D34:  RCALL  25F0
02D36:  BC    2D3A
02D38:  BNZ   2D3E
02D3A:  MOVLW  03
02D3C:  BRA    2D40
02D3E:  MOVLW  04
02D40:  BRA    2D68
02D42:  MOVFF  64E,676
02D46:  MOVFF  64D,675
02D4A:  MOVFF  64C,674
02D4E:  MOVFF  64B,673
02D52:  MOVLB  6
02D54:  CLRF   x7A
02D56:  CLRF   x79
02D58:  CLRF   x78
02D5A:  CLRF   x77
02D5C:  MOVLB  0
02D5E:  RCALL  25F0
02D60:  BNC   2D66
02D62:  MOVLW  02
02D64:  BRA    2D68
02D66:  MOVLW  01
02D68:  MOVLB  6
02D6A:  MOVWF  x54
....................    if(y<0.0)
02D6C:  MOVFF  64A,676
02D70:  MOVFF  649,675
02D74:  MOVFF  648,674
02D78:  MOVFF  647,673
02D7C:  CLRF   x7A
02D7E:  CLRF   x79
02D80:  CLRF   x78
02D82:  CLRF   x77
02D84:  MOVLB  0
02D86:  RCALL  25F0
02D88:  BNC   2D96
....................    {
....................       sign=1;
02D8A:  MOVLB  6
02D8C:  BSF    x53.0
....................       y=-y;
02D8E:  MOVF   x48,W
02D90:  XORLW  80
02D92:  MOVWF  x48
02D94:  MOVLB  0
....................    }
....................    if(x<0.0)
02D96:  MOVFF  64E,676
02D9A:  MOVFF  64D,675
02D9E:  MOVFF  64C,674
02DA2:  MOVFF  64B,673
02DA6:  MOVLB  6
02DA8:  CLRF   x7A
02DAA:  CLRF   x79
02DAC:  CLRF   x78
02DAE:  CLRF   x77
02DB0:  MOVLB  0
02DB2:  RCALL  25F0
02DB4:  BNC   2DC0
....................    {
....................       x=-x;
02DB6:  MOVLB  6
02DB8:  MOVF   x4C,W
02DBA:  XORLW  80
02DBC:  MOVWF  x4C
02DBE:  MOVLB  0
....................    }
....................    if (x==0.0)
02DC0:  MOVFF  64E,676
02DC4:  MOVFF  64D,675
02DC8:  MOVFF  64C,674
02DCC:  MOVFF  64B,673
02DD0:  MOVLB  6
02DD2:  CLRF   x7A
02DD4:  CLRF   x79
02DD6:  CLRF   x78
02DD8:  CLRF   x77
02DDA:  MOVLB  0
02DDC:  RCALL  25F0
02DDE:  BNZ   2E34
....................    {
....................       if(y==0.0)
02DE0:  MOVFF  64A,676
02DE4:  MOVFF  649,675
02DE8:  MOVFF  648,674
02DEC:  MOVFF  647,673
02DF0:  MOVLB  6
02DF2:  CLRF   x7A
02DF4:  CLRF   x79
02DF6:  CLRF   x78
02DF8:  CLRF   x77
02DFA:  MOVLB  0
02DFC:  CALL   25F0
02E00:  BNZ   2E04
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
02E02:  BRA    2E32
....................       else
....................       {
....................          if(sign)
02E04:  MOVLB  6
02E06:  BTFSS  x53.0
02E08:  BRA    2E1E
....................          {
....................          return (-(PI_DIV_BY_TWO));
02E0A:  MOVLW  7F
02E0C:  MOVWF  00
02E0E:  MOVLW  C9
02E10:  MOVWF  01
02E12:  MOVLW  0F
02E14:  MOVWF  02
02E16:  MOVLW  DB
02E18:  MOVWF  03
02E1A:  BRA    2F6C
....................          }
02E1C:  BRA    2E30
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
02E1E:  MOVLW  7F
02E20:  MOVWF  00
02E22:  MOVLW  49
02E24:  MOVWF  01
02E26:  MOVLW  0F
02E28:  MOVWF  02
02E2A:  MOVLW  DB
02E2C:  MOVWF  03
02E2E:  BRA    2F6C
02E30:  MOVLB  0
....................          }
....................       }
....................    }
02E32:  BRA    2F6A
....................    else
....................    {
....................       z=y/x;
02E34:  MOVFF  64A,66F
02E38:  MOVFF  649,66E
02E3C:  MOVFF  648,66D
02E40:  MOVFF  647,66C
02E44:  MOVFF  64E,673
02E48:  MOVFF  64D,672
02E4C:  MOVFF  64C,671
02E50:  MOVFF  64B,670
02E54:  RCALL  266A
02E56:  MOVFF  03,652
02E5A:  MOVFF  02,651
02E5E:  MOVFF  01,650
02E62:  MOVFF  00,64F
....................       switch(quad)
02E66:  MOVLW  01
02E68:  MOVLB  6
02E6A:  SUBWF  x54,W
02E6C:  ADDLW  FC
02E6E:  BTFSC  FD8.0
02E70:  BRA    2F6C
02E72:  ADDLW  04
02E74:  MOVLB  0
02E76:  GOTO   2F72
....................       {
....................          case 1:
....................          {
....................             return atan(z);
02E7A:  MOVFF  652,658
02E7E:  MOVFF  651,657
02E82:  MOVFF  650,656
02E86:  MOVFF  64F,655
02E8A:  RCALL  27C8
02E8C:  MOVLB  6
02E8E:  BRA    2F6C
....................             break;
02E90:  BRA    2F6C
02E92:  MOVLB  0
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
02E94:  MOVFF  652,658
02E98:  MOVFF  651,657
02E9C:  MOVFF  650,656
02EA0:  MOVFF  64F,655
02EA4:  RCALL  27C8
02EA6:  MOVFF  FEA,656
02EAA:  MOVFF  FE9,655
02EAE:  BSF    FD8.1
02EB0:  MOVLW  DB
02EB2:  MOVLB  6
02EB4:  MOVWF  x7A
02EB6:  MOVLW  0F
02EB8:  MOVWF  x79
02EBA:  MOVLW  49
02EBC:  MOVWF  x78
02EBE:  MOVLW  80
02EC0:  MOVWF  x77
02EC2:  MOVFF  03,67E
02EC6:  MOVFF  02,67D
02ECA:  MOVFF  01,67C
02ECE:  MOVFF  00,67B
02ED2:  MOVLB  0
02ED4:  CALL   12E8
02ED8:  MOVFF  656,FEA
02EDC:  MOVFF  655,FE9
02EE0:  MOVLB  6
02EE2:  BRA    2F6C
....................             break;
02EE4:  BRA    2F6C
02EE6:  MOVLB  0
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
02EE8:  MOVFF  652,658
02EEC:  MOVFF  651,657
02EF0:  MOVFF  650,656
02EF4:  MOVFF  64F,655
02EF8:  RCALL  27C8
02EFA:  MOVFF  03,658
02EFE:  MOVFF  02,657
02F02:  MOVFF  01,656
02F06:  MOVFF  00,655
02F0A:  MOVFF  FEA,65A
02F0E:  MOVFF  FE9,659
02F12:  BSF    FD8.1
02F14:  MOVFF  03,67A
02F18:  MOVFF  02,679
02F1C:  MOVFF  01,678
02F20:  MOVFF  00,677
02F24:  MOVLW  DB
02F26:  MOVLB  6
02F28:  MOVWF  x7E
02F2A:  MOVLW  0F
02F2C:  MOVWF  x7D
02F2E:  MOVLW  49
02F30:  MOVWF  x7C
02F32:  MOVLW  80
02F34:  MOVWF  x7B
02F36:  MOVLB  0
02F38:  CALL   12E8
02F3C:  MOVFF  65A,FEA
02F40:  MOVFF  659,FE9
02F44:  MOVLB  6
02F46:  BRA    2F6C
....................             break;
02F48:  BRA    2F6C
02F4A:  MOVLB  0
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
02F4C:  MOVFF  652,658
02F50:  MOVFF  651,657
02F54:  MOVFF  650,656
02F58:  MOVFF  64F,655
02F5C:  RCALL  27C8
02F5E:  MOVLW  80
02F60:  XORWF  01,F
02F62:  MOVLB  6
02F64:  BRA    2F6C
....................             break;
02F66:  BRA    2F6C
02F68:  MOVLB  0
02F6A:  MOVLB  6
....................          }
....................       }
....................    }
02F6C:  MOVLB  0
02F6E:  GOTO   4678 (RETURN)
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... #define sensorSampleRate 50 // 50mS delay between each sensor sample = 200ms cadence 
.................... 
.................... #define maxCount 16777216.0   // ADC max count
.................... #define vRef 2.048            // ADC vRef
.................... 
.................... #define sc sensorCal
.................... 
.................... #define vMonN15   6
.................... #define vMon200   16
.................... #define vMon5V6   24
.................... #define vMon5VA   25
.................... #define vMon3V6X  17
.................... #define vMon3V3A  27
.................... #define vMon3V3D  26
.................... 
.................... #define BUFFER_SIZE 5
.................... typedef struct {
....................    int in;
....................    int out;
....................    int buff[BUFFER_SIZE];
.................... } buffer;
.................... 
.................... buffer sinQ_x;
.................... buffer cosQ_x;
.................... buffer sinQ_y;
.................... buffer cosQ_y;
.................... 
.................... #define incin(buff) ((buff->in==(BUFFER_SIZE-1))?0:buff->in+1)
.................... #define incout(buff) ((buff->out==(BUFFER_SIZE-1))?0:buff->out+1)
.................... #define isempty(buff) (buff->in==buff->out)
.................... #define hasdata(buff) (buff->in!=buff->out)
.................... #define isfull(buff) (incin(buff)==buff->out)
.................... 
.................... #define tobuff(bname,c) { bname->buff[bname->in]=c;\
....................    bname->in=incin(bname);\
....................    if (bname->in==bname->out) bname->out=incout(bname);\
....................    }
.................... #define frombuff(bname) (btemp##bname=bname->buff[bname->out],\
....................    bname->out=incout(bname), \
....................    btemp##bname)
.................... #define clrbuff(buff) buff->in=buff->out=0
.................... 
.................... #define COMPARE(a,b) (((a) > (b)) - ((a) < (b)))
.................... 
.................... struct sensorMonitorData
.................... {
....................    boolean dataReady;
....................    boolean adcBusy;
....................    buffer* sinQ;
....................    buffer* cosQ;
....................    signed int32 avgSin;
....................    signed int32 avgCos;
.................... } smData[2] = 
.................... {
....................    {false, false, &sinQ_x, &cosQ_x, 0, 0},
....................    {false, false, &sinQ_y, &cosQ_y, 0, 0}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* INTERNAL MONITOR task - gets voltages                                     */
.................... /* gets one value each time the task is run                                  */
.................... /*****************************************************************************/
.................... void internal_monitor_task()
.................... {
....................    static int8 state = 0;
....................    if (adc_done())
*
01560:  MOVLB  F
01562:  BTFSC  x5B.0
01564:  BRA    1AB0
....................    {
....................       switch (state)
01566:  MOVLB  1
01568:  MOVF   x9B,W
0156A:  ADDLW  F9
0156C:  BTFSC  FD8.0
0156E:  BRA    1AAE
01570:  ADDLW  07
01572:  MOVLB  0
01574:  GOTO   1AB6
....................       {
....................          case 0:     // vMonN15
....................             monitorVals.vN15 = read_adc(ADC_READ_ONLY) * monCal.vN15[1] + monCal.vN15[0];
01578:  MOVLB  F
0157A:  BTFSC  x5B.0
0157C:  BRA    157A
0157E:  MOVFF  F5F,02
01582:  MOVFF  F5E,01
01586:  MOVFF  02,629
0158A:  MOVFF  01,628
0158E:  MOVFF  02,678
01592:  MOVFF  01,677
01596:  MOVLB  0
01598:  RCALL  11BC
0159A:  MOVFF  03,67B
0159E:  MOVFF  02,67A
015A2:  MOVFF  01,679
015A6:  MOVFF  00,678
015AA:  MOVFF  B9,67F
015AE:  MOVFF  B8,67E
015B2:  MOVFF  B7,67D
015B6:  MOVFF  B6,67C
015BA:  RCALL  11F2
015BC:  MOVFF  03,62B
015C0:  MOVFF  02,62A
015C4:  MOVFF  01,629
015C8:  MOVFF  00,628
015CC:  BCF    FD8.1
015CE:  MOVFF  03,67A
015D2:  MOVFF  02,679
015D6:  MOVFF  01,678
015DA:  MOVFF  00,677
015DE:  MOVFF  B5,67E
015E2:  MOVFF  B4,67D
015E6:  MOVFF  B3,67C
015EA:  MOVFF  B2,67B
015EE:  RCALL  12E8
015F0:  MOVFF  03,F6
015F4:  MOVFF  02,F5
015F8:  MOVFF  01,F4
015FC:  MOVFF  00,F3
....................             set_adc_channel(vMon200);
01600:  MOVLB  F
01602:  MOVF   x5A,W
01604:  ANDLW  3F
01606:  MOVWF  01
01608:  MOVLW  10
0160A:  MOVWF  x5A
0160C:  BTFSS  x5B.7
0160E:  BRA    161E
01610:  MOVF   01,W
01612:  SUBLW  10
01614:  BZ    161E
01616:  BSF    x5B.0
01618:  NOP   
0161A:  BTFSC  x5B.0
0161C:  BRA    161A
....................             delay_ms(10);
0161E:  MOVLW  0A
01620:  MOVLB  6
01622:  MOVWF  x30
01624:  MOVLB  0
01626:  CALL   0438
....................             read_adc(ADC_START_ONLY);
0162A:  MOVLB  F
0162C:  BSF    x5B.0
0162E:  NOP   
....................             state = 1;
01630:  MOVLW  01
01632:  MOVLB  1
01634:  MOVWF  x9B
....................          break;
01636:  BRA    1AAE
....................          
....................          case 1:     // vMon200
....................             monitorVals.v200 = read_adc(ADC_READ_ONLY) * monCal.v200[1] + monCal.v200[0];
01638:  MOVLB  F
0163A:  BTFSC  x5B.0
0163C:  BRA    163A
0163E:  MOVFF  F5F,02
01642:  MOVFF  F5E,01
01646:  MOVFF  02,629
0164A:  MOVFF  01,628
0164E:  MOVFF  02,678
01652:  MOVFF  01,677
01656:  MOVLB  0
01658:  RCALL  11BC
0165A:  MOVFF  03,67B
0165E:  MOVFF  02,67A
01662:  MOVFF  01,679
01666:  MOVFF  00,678
0166A:  MOVFF  C1,67F
0166E:  MOVFF  C0,67E
01672:  MOVFF  BF,67D
01676:  MOVFF  BE,67C
0167A:  RCALL  11F2
0167C:  MOVFF  03,62B
01680:  MOVFF  02,62A
01684:  MOVFF  01,629
01688:  MOVFF  00,628
0168C:  BCF    FD8.1
0168E:  MOVFF  03,67A
01692:  MOVFF  02,679
01696:  MOVFF  01,678
0169A:  MOVFF  00,677
0169E:  MOVFF  BD,67E
016A2:  MOVFF  BC,67D
016A6:  MOVFF  BB,67C
016AA:  MOVFF  BA,67B
016AE:  RCALL  12E8
016B0:  MOVFF  03,FA
016B4:  MOVFF  02,F9
016B8:  MOVFF  01,F8
016BC:  MOVFF  00,F7
....................             set_adc_channel(vMon5V6);
016C0:  MOVLB  F
016C2:  MOVF   x5A,W
016C4:  ANDLW  3F
016C6:  MOVWF  01
016C8:  MOVLW  18
016CA:  MOVWF  x5A
016CC:  BTFSS  x5B.7
016CE:  BRA    16DE
016D0:  MOVF   01,W
016D2:  SUBLW  18
016D4:  BZ    16DE
016D6:  BSF    x5B.0
016D8:  NOP   
016DA:  BTFSC  x5B.0
016DC:  BRA    16DA
....................             delay_ms(10);
016DE:  MOVLW  0A
016E0:  MOVLB  6
016E2:  MOVWF  x30
016E4:  MOVLB  0
016E6:  CALL   0438
....................             read_adc(ADC_START_ONLY);
016EA:  MOVLB  F
016EC:  BSF    x5B.0
016EE:  NOP   
....................             state = 2;
016F0:  MOVLW  02
016F2:  MOVLB  1
016F4:  MOVWF  x9B
....................          break;
016F6:  BRA    1AAE
....................          
....................          case 2:     // vMon5V6
....................             monitorVals.v5V6 = read_adc(ADC_READ_ONLY) * monCal.v5V6[1] + monCal.v5V6[0];
016F8:  MOVLB  F
016FA:  BTFSC  x5B.0
016FC:  BRA    16FA
016FE:  MOVFF  F5F,02
01702:  MOVFF  F5E,01
01706:  MOVFF  02,629
0170A:  MOVFF  01,628
0170E:  MOVFF  02,678
01712:  MOVFF  01,677
01716:  MOVLB  0
01718:  RCALL  11BC
0171A:  MOVFF  03,67B
0171E:  MOVFF  02,67A
01722:  MOVFF  01,679
01726:  MOVFF  00,678
0172A:  MOVFF  C9,67F
0172E:  MOVFF  C8,67E
01732:  MOVFF  C7,67D
01736:  MOVFF  C6,67C
0173A:  RCALL  11F2
0173C:  MOVFF  03,62B
01740:  MOVFF  02,62A
01744:  MOVFF  01,629
01748:  MOVFF  00,628
0174C:  BCF    FD8.1
0174E:  MOVFF  03,67A
01752:  MOVFF  02,679
01756:  MOVFF  01,678
0175A:  MOVFF  00,677
0175E:  MOVFF  C5,67E
01762:  MOVFF  C4,67D
01766:  MOVFF  C3,67C
0176A:  MOVFF  C2,67B
0176E:  RCALL  12E8
01770:  MOVFF  03,FE
01774:  MOVFF  02,FD
01778:  MOVFF  01,FC
0177C:  MOVFF  00,FB
....................             set_adc_channel(vMon5VA);
01780:  MOVLB  F
01782:  MOVF   x5A,W
01784:  ANDLW  3F
01786:  MOVWF  01
01788:  MOVLW  19
0178A:  MOVWF  x5A
0178C:  BTFSS  x5B.7
0178E:  BRA    179E
01790:  MOVF   01,W
01792:  SUBLW  19
01794:  BZ    179E
01796:  BSF    x5B.0
01798:  NOP   
0179A:  BTFSC  x5B.0
0179C:  BRA    179A
....................             delay_ms(10);
0179E:  MOVLW  0A
017A0:  MOVLB  6
017A2:  MOVWF  x30
017A4:  MOVLB  0
017A6:  CALL   0438
....................             read_adc(ADC_START_ONLY);
017AA:  MOVLB  F
017AC:  BSF    x5B.0
017AE:  NOP   
....................             state = 3;
017B0:  MOVLW  03
017B2:  MOVLB  1
017B4:  MOVWF  x9B
....................          break;
017B6:  BRA    1AAE
....................          
....................          case 3:     // vMon5VA
....................             monitorVals.v5VA = read_adc(ADC_READ_ONLY) * monCal.v5VA[1] + monCal.v5VA[0];
017B8:  MOVLB  F
017BA:  BTFSC  x5B.0
017BC:  BRA    17BA
017BE:  MOVFF  F5F,02
017C2:  MOVFF  F5E,01
017C6:  MOVFF  02,629
017CA:  MOVFF  01,628
017CE:  MOVFF  02,678
017D2:  MOVFF  01,677
017D6:  MOVLB  0
017D8:  RCALL  11BC
017DA:  MOVFF  03,67B
017DE:  MOVFF  02,67A
017E2:  MOVFF  01,679
017E6:  MOVFF  00,678
017EA:  MOVFF  D1,67F
017EE:  MOVFF  D0,67E
017F2:  MOVFF  CF,67D
017F6:  MOVFF  CE,67C
017FA:  RCALL  11F2
017FC:  MOVFF  03,62B
01800:  MOVFF  02,62A
01804:  MOVFF  01,629
01808:  MOVFF  00,628
0180C:  BCF    FD8.1
0180E:  MOVFF  03,67A
01812:  MOVFF  02,679
01816:  MOVFF  01,678
0181A:  MOVFF  00,677
0181E:  MOVFF  CD,67E
01822:  MOVFF  CC,67D
01826:  MOVFF  CB,67C
0182A:  MOVFF  CA,67B
0182E:  RCALL  12E8
01830:  MOVFF  03,102
01834:  MOVFF  02,101
01838:  MOVFF  01,100
0183C:  MOVFF  00,FF
....................             set_adc_channel(vMon3V6X);
01840:  MOVLB  F
01842:  MOVF   x5A,W
01844:  ANDLW  3F
01846:  MOVWF  01
01848:  MOVLW  11
0184A:  MOVWF  x5A
0184C:  BTFSS  x5B.7
0184E:  BRA    185E
01850:  MOVF   01,W
01852:  SUBLW  11
01854:  BZ    185E
01856:  BSF    x5B.0
01858:  NOP   
0185A:  BTFSC  x5B.0
0185C:  BRA    185A
....................             delay_ms(10);
0185E:  MOVLW  0A
01860:  MOVLB  6
01862:  MOVWF  x30
01864:  MOVLB  0
01866:  CALL   0438
....................             read_adc(ADC_START_ONLY);
0186A:  MOVLB  F
0186C:  BSF    x5B.0
0186E:  NOP   
....................             state = 4;
01870:  MOVLW  04
01872:  MOVLB  1
01874:  MOVWF  x9B
....................          break;
01876:  BRA    1AAE
....................          
....................          case 4:     // vMon3V6X
....................             monitorVals.v3V6X = read_adc(ADC_READ_ONLY) * monCal.v3V6X[1] + monCal.v3V6X[0];
01878:  MOVLB  F
0187A:  BTFSC  x5B.0
0187C:  BRA    187A
0187E:  MOVFF  F5F,02
01882:  MOVFF  F5E,01
01886:  MOVFF  02,629
0188A:  MOVFF  01,628
0188E:  MOVFF  02,678
01892:  MOVFF  01,677
01896:  MOVLB  0
01898:  RCALL  11BC
0189A:  MOVFF  03,67B
0189E:  MOVFF  02,67A
018A2:  MOVFF  01,679
018A6:  MOVFF  00,678
018AA:  MOVFF  D9,67F
018AE:  MOVFF  D8,67E
018B2:  MOVFF  D7,67D
018B6:  MOVFF  D6,67C
018BA:  RCALL  11F2
018BC:  MOVFF  03,62B
018C0:  MOVFF  02,62A
018C4:  MOVFF  01,629
018C8:  MOVFF  00,628
018CC:  BCF    FD8.1
018CE:  MOVFF  03,67A
018D2:  MOVFF  02,679
018D6:  MOVFF  01,678
018DA:  MOVFF  00,677
018DE:  MOVFF  D5,67E
018E2:  MOVFF  D4,67D
018E6:  MOVFF  D3,67C
018EA:  MOVFF  D2,67B
018EE:  RCALL  12E8
018F0:  MOVFF  03,106
018F4:  MOVFF  02,105
018F8:  MOVFF  01,104
018FC:  MOVFF  00,103
....................             set_adc_channel(vMon3V3A);
01900:  MOVLB  F
01902:  MOVF   x5A,W
01904:  ANDLW  3F
01906:  MOVWF  01
01908:  MOVLW  1B
0190A:  MOVWF  x5A
0190C:  BTFSS  x5B.7
0190E:  BRA    191E
01910:  MOVF   01,W
01912:  SUBLW  1B
01914:  BZ    191E
01916:  BSF    x5B.0
01918:  NOP   
0191A:  BTFSC  x5B.0
0191C:  BRA    191A
....................             delay_ms(10);
0191E:  MOVLW  0A
01920:  MOVLB  6
01922:  MOVWF  x30
01924:  MOVLB  0
01926:  CALL   0438
....................             read_adc(ADC_START_ONLY);
0192A:  MOVLB  F
0192C:  BSF    x5B.0
0192E:  NOP   
....................             state = 5;
01930:  MOVLW  05
01932:  MOVLB  1
01934:  MOVWF  x9B
....................          break;
01936:  BRA    1AAE
....................          
....................          case 5:     // vMon3V3A
....................             monitorVals.v3V3A = read_adc(ADC_READ_ONLY) * monCal.v3V3A[1] + monCal.v3V3A[0];
01938:  MOVLB  F
0193A:  BTFSC  x5B.0
0193C:  BRA    193A
0193E:  MOVFF  F5F,02
01942:  MOVFF  F5E,01
01946:  MOVFF  02,629
0194A:  MOVFF  01,628
0194E:  MOVFF  02,678
01952:  MOVFF  01,677
01956:  MOVLB  0
01958:  RCALL  11BC
0195A:  MOVFF  03,67B
0195E:  MOVFF  02,67A
01962:  MOVFF  01,679
01966:  MOVFF  00,678
0196A:  MOVFF  E1,67F
0196E:  MOVFF  E0,67E
01972:  MOVFF  DF,67D
01976:  MOVFF  DE,67C
0197A:  RCALL  11F2
0197C:  MOVFF  03,62B
01980:  MOVFF  02,62A
01984:  MOVFF  01,629
01988:  MOVFF  00,628
0198C:  BCF    FD8.1
0198E:  MOVFF  03,67A
01992:  MOVFF  02,679
01996:  MOVFF  01,678
0199A:  MOVFF  00,677
0199E:  MOVFF  DD,67E
019A2:  MOVFF  DC,67D
019A6:  MOVFF  DB,67C
019AA:  MOVFF  DA,67B
019AE:  RCALL  12E8
019B0:  MOVFF  03,10A
019B4:  MOVFF  02,109
019B8:  MOVFF  01,108
019BC:  MOVFF  00,107
....................             set_adc_channel(vMon3V3D);
019C0:  MOVLB  F
019C2:  MOVF   x5A,W
019C4:  ANDLW  3F
019C6:  MOVWF  01
019C8:  MOVLW  1A
019CA:  MOVWF  x5A
019CC:  BTFSS  x5B.7
019CE:  BRA    19DE
019D0:  MOVF   01,W
019D2:  SUBLW  1A
019D4:  BZ    19DE
019D6:  BSF    x5B.0
019D8:  NOP   
019DA:  BTFSC  x5B.0
019DC:  BRA    19DA
....................             delay_ms(10);
019DE:  MOVLW  0A
019E0:  MOVLB  6
019E2:  MOVWF  x30
019E4:  MOVLB  0
019E6:  CALL   0438
....................             read_adc(ADC_START_ONLY);
019EA:  MOVLB  F
019EC:  BSF    x5B.0
019EE:  NOP   
....................             state = 6;
019F0:  MOVLW  06
019F2:  MOVLB  1
019F4:  MOVWF  x9B
....................          break;
019F6:  BRA    1AAE
....................          
....................          case 6:    // vMon3V3D
....................             monitorVals.v3V3D = read_adc(ADC_READ_ONLY) * monCal.v3V3D[1] + monCal.v3V3D[0];
019F8:  MOVLB  F
019FA:  BTFSC  x5B.0
019FC:  BRA    19FA
019FE:  MOVFF  F5F,02
01A02:  MOVFF  F5E,01
01A06:  MOVFF  02,629
01A0A:  MOVFF  01,628
01A0E:  MOVFF  02,678
01A12:  MOVFF  01,677
01A16:  MOVLB  0
01A18:  CALL   11BC
01A1C:  MOVFF  03,67B
01A20:  MOVFF  02,67A
01A24:  MOVFF  01,679
01A28:  MOVFF  00,678
01A2C:  MOVFF  E9,67F
01A30:  MOVFF  E8,67E
01A34:  MOVFF  E7,67D
01A38:  MOVFF  E6,67C
01A3C:  CALL   11F2
01A40:  MOVFF  03,62B
01A44:  MOVFF  02,62A
01A48:  MOVFF  01,629
01A4C:  MOVFF  00,628
01A50:  BCF    FD8.1
01A52:  MOVFF  03,67A
01A56:  MOVFF  02,679
01A5A:  MOVFF  01,678
01A5E:  MOVFF  00,677
01A62:  MOVFF  E5,67E
01A66:  MOVFF  E4,67D
01A6A:  MOVFF  E3,67C
01A6E:  MOVFF  E2,67B
01A72:  RCALL  12E8
01A74:  MOVFF  03,10E
01A78:  MOVFF  02,10D
01A7C:  MOVFF  01,10C
01A80:  MOVFF  00,10B
....................             set_adc_channel(vMonN15);
01A84:  MOVLB  F
01A86:  MOVF   x5A,W
01A88:  ANDLW  3F
01A8A:  MOVWF  01
01A8C:  MOVLW  06
01A8E:  MOVWF  x5A
01A90:  BTFSS  x5B.7
01A92:  BRA    1AA2
01A94:  MOVF   01,W
01A96:  SUBLW  06
01A98:  BZ    1AA2
01A9A:  BSF    x5B.0
01A9C:  NOP   
01A9E:  BTFSC  x5B.0
01AA0:  BRA    1A9E
....................             read_adc(ADC_START_ONLY);
01AA2:  BSF    x5B.0
01AA4:  NOP   
....................             state = 0;
01AA6:  MOVLB  1
01AA8:  CLRF   x9B
....................          break;   
01AAA:  BRA    1AAE
01AAC:  MOVLB  1
01AAE:  MOVLB  F
....................       }
....................    }
01AB0:  MOVLB  0
01AB2:  GOTO   AE98 (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* PROCESS ADC SENSOR DATA                                                   */
.................... /*****************************************************************************/
.................... void sensor_process_data(int8 ch)//, signed int32 sinRawCounts, signed int32 cosRawCounts)
.................... {
....................    adcVals[ch].sinLast = adcVals[ch].sinCounts;
*
03FD0:  MOVLB  6
03FD2:  MOVF   x30,W
03FD4:  MULLW  21
03FD6:  MOVF   FF3,W
03FD8:  CLRF   x3A
03FDA:  MOVWF  x39
03FDC:  MOVLW  10
03FDE:  ADDWF  x39,W
03FE0:  MOVWF  01
03FE2:  MOVLW  00
03FE4:  ADDWFC x3A,W
03FE6:  MOVWF  03
03FE8:  MOVF   01,W
03FEA:  ADDLW  0F
03FEC:  MOVWF  01
03FEE:  MOVLW  01
03FF0:  ADDWFC 03,F
03FF2:  MOVFF  01,639
03FF6:  MOVFF  03,63A
03FFA:  MOVF   x30,W
03FFC:  MULLW  21
03FFE:  MOVF   FF3,W
04000:  CLRF   x3C
04002:  MOVWF  x3B
04004:  MOVLW  08
04006:  ADDWF  x3B,W
04008:  MOVWF  01
0400A:  MOVLW  00
0400C:  ADDWFC x3C,W
0400E:  MOVWF  03
04010:  MOVF   01,W
04012:  ADDLW  0F
04014:  MOVWF  FE9
04016:  MOVLW  01
04018:  ADDWFC 03,W
0401A:  MOVWF  FEA
0401C:  MOVFF  FEF,00
04020:  MOVFF  FEC,01
04024:  MOVFF  FEC,02
04028:  MOVFF  FEC,03
0402C:  MOVFF  63A,FEA
04030:  MOVFF  639,FE9
04034:  MOVFF  00,FEF
04038:  MOVFF  01,FEC
0403C:  MOVFF  02,FEC
04040:  MOVFF  03,FEC
....................    adcVals[ch].cosLast = adcVals[ch].cosCounts;
04044:  MOVF   x30,W
04046:  MULLW  21
04048:  MOVF   FF3,W
0404A:  CLRF   x3A
0404C:  MOVWF  x39
0404E:  MOVLW  14
04050:  ADDWF  x39,W
04052:  MOVWF  01
04054:  MOVLW  00
04056:  ADDWFC x3A,W
04058:  MOVWF  03
0405A:  MOVF   01,W
0405C:  ADDLW  0F
0405E:  MOVWF  01
04060:  MOVLW  01
04062:  ADDWFC 03,F
04064:  MOVFF  01,639
04068:  MOVFF  03,63A
0406C:  MOVF   x30,W
0406E:  MULLW  21
04070:  MOVF   FF3,W
04072:  CLRF   x3C
04074:  MOVWF  x3B
04076:  MOVLW  0C
04078:  ADDWF  x3B,W
0407A:  MOVWF  01
0407C:  MOVLW  00
0407E:  ADDWFC x3C,W
04080:  MOVWF  03
04082:  MOVF   01,W
04084:  ADDLW  0F
04086:  MOVWF  FE9
04088:  MOVLW  01
0408A:  ADDWFC 03,W
0408C:  MOVWF  FEA
0408E:  MOVFF  FEF,00
04092:  MOVFF  FEC,01
04096:  MOVFF  FEC,02
0409A:  MOVFF  FEC,03
0409E:  MOVFF  63A,FEA
040A2:  MOVFF  639,FE9
040A6:  MOVFF  00,FEF
040AA:  MOVFF  01,FEC
040AE:  MOVFF  02,FEC
040B2:  MOVFF  03,FEC
....................    
....................    adcVals[ch].sinRaw = (float)smData[ch].avgSin;
040B6:  MOVF   x30,W
040B8:  MULLW  21
040BA:  MOVF   FF3,W
040BC:  CLRF   x3A
040BE:  MOVWF  x39
040C0:  MOVLW  0F
040C2:  ADDWF  x39,W
040C4:  MOVWF  01
040C6:  MOVLW  01
040C8:  ADDWFC x3A,W
040CA:  MOVWF  03
040CC:  MOVFF  01,63B
040D0:  MOVWF  x3C
040D2:  MOVF   x30,W
040D4:  MULLW  0D
040D6:  MOVF   FF3,W
040D8:  CLRF   x3E
040DA:  MOVWF  x3D
040DC:  MOVLW  05
040DE:  ADDWF  x3D,W
040E0:  MOVWF  01
040E2:  MOVLW  00
040E4:  ADDWFC x3E,W
040E6:  MOVWF  03
040E8:  MOVF   01,W
040EA:  ADDLW  81
040EC:  MOVWF  FE9
040EE:  MOVLW  01
040F0:  ADDWFC 03,W
040F2:  MOVWF  FEA
040F4:  MOVFF  FEF,63D
040F8:  MOVFF  FEC,01
040FC:  MOVFF  FEC,02
04100:  MOVFF  FEC,03
04104:  MOVFF  03,640
04108:  MOVFF  02,63F
0410C:  MOVFF  01,63E
04110:  MOVLB  0
04112:  CALL   2596
04116:  MOVFF  63C,FEA
0411A:  MOVFF  63B,FE9
0411E:  MOVFF  00,FEF
04122:  MOVFF  01,FEC
04126:  MOVFF  02,FEC
0412A:  MOVFF  03,FEC
....................    adcVals[ch].cosRaw = (float)smData[ch].avgCos;
0412E:  MOVLB  6
04130:  MOVF   x30,W
04132:  MULLW  21
04134:  MOVF   FF3,W
04136:  CLRF   x3A
04138:  MOVWF  x39
0413A:  MOVLW  04
0413C:  ADDWF  x39,W
0413E:  MOVWF  01
04140:  MOVLW  00
04142:  ADDWFC x3A,W
04144:  MOVWF  03
04146:  MOVF   01,W
04148:  ADDLW  0F
0414A:  MOVWF  01
0414C:  MOVLW  01
0414E:  ADDWFC 03,F
04150:  MOVFF  01,639
04154:  MOVFF  03,63A
04158:  MOVF   x30,W
0415A:  MULLW  0D
0415C:  MOVF   FF3,W
0415E:  CLRF   x3C
04160:  MOVWF  x3B
04162:  MOVLW  09
04164:  ADDWF  x3B,W
04166:  MOVWF  01
04168:  MOVLW  00
0416A:  ADDWFC x3C,W
0416C:  MOVWF  03
0416E:  MOVF   01,W
04170:  ADDLW  81
04172:  MOVWF  FE9
04174:  MOVLW  01
04176:  ADDWFC 03,W
04178:  MOVWF  FEA
0417A:  MOVFF  FEF,63D
0417E:  MOVFF  FEC,01
04182:  MOVFF  FEC,02
04186:  MOVFF  FEC,03
0418A:  MOVFF  03,640
0418E:  MOVFF  02,63F
04192:  MOVFF  01,63E
04196:  MOVLB  0
04198:  CALL   2596
0419C:  MOVFF  63A,FEA
041A0:  MOVFF  639,FE9
041A4:  MOVFF  00,FEF
041A8:  MOVFF  01,FEC
041AC:  MOVFF  02,FEC
041B0:  MOVFF  03,FEC
....................    
....................    adcVals[ch].sinCounts = adcVals[ch].sinRaw * adcCal[ch].sinGain + adcCal[ch].sinOS;
041B4:  MOVLB  6
041B6:  MOVF   x30,W
041B8:  MULLW  21
041BA:  MOVF   FF3,W
041BC:  CLRF   x3A
041BE:  MOVWF  x39
041C0:  MOVLW  08
041C2:  ADDWF  x39,W
041C4:  MOVWF  01
041C6:  MOVLW  00
041C8:  ADDWFC x3A,W
041CA:  MOVWF  03
041CC:  MOVF   01,W
041CE:  ADDLW  0F
041D0:  MOVWF  01
041D2:  MOVLW  01
041D4:  ADDWFC 03,F
041D6:  MOVFF  01,639
041DA:  MOVFF  03,63A
041DE:  MOVF   x30,W
041E0:  MULLW  21
041E2:  MOVF   FF3,W
041E4:  CLRF   x3C
041E6:  MOVWF  x3B
041E8:  MOVLW  0F
041EA:  ADDWF  x3B,W
041EC:  MOVWF  FE9
041EE:  MOVLW  01
041F0:  ADDWFC x3C,W
041F2:  MOVWF  FEA
041F4:  MOVFF  FEF,678
041F8:  MOVFF  FEC,679
041FC:  MOVFF  FEC,67A
04200:  MOVFF  FEC,67B
04204:  MOVF   x30,W
04206:  MULLW  10
04208:  MOVF   FF3,W
0420A:  CLRF   x42
0420C:  MOVWF  x41
0420E:  MOVLW  08
04210:  ADDWF  x41,W
04212:  MOVWF  01
04214:  MOVLW  00
04216:  ADDWFC x42,W
04218:  MOVWF  03
0421A:  MOVF   01,W
0421C:  ADDLW  62
0421E:  MOVWF  FE9
04220:  MOVLW  00
04222:  ADDWFC 03,W
04224:  MOVWF  FEA
04226:  MOVFF  FEF,67C
0422A:  MOVFF  FEC,01
0422E:  MOVFF  FEC,02
04232:  MOVFF  FEC,03
04236:  MOVFF  03,67F
0423A:  MOVFF  02,67E
0423E:  MOVFF  01,67D
04242:  MOVLB  0
04244:  CALL   11F2
04248:  MOVFF  03,67A
0424C:  MOVFF  02,679
04250:  MOVFF  01,678
04254:  MOVFF  00,677
04258:  MOVLB  6
0425A:  MOVF   x30,W
0425C:  MULLW  10
0425E:  MOVF   FF3,W
04260:  CLRF   x42
04262:  MOVWF  x41
04264:  MOVLW  62
04266:  ADDWF  x41,W
04268:  MOVWF  FE9
0426A:  MOVLW  00
0426C:  ADDWFC x42,W
0426E:  MOVWF  FEA
04270:  MOVFF  FEF,67B
04274:  MOVFF  FEC,01
04278:  MOVFF  FEC,02
0427C:  MOVFF  FEC,03
04280:  BCF    FD8.1
04282:  MOVFF  03,67E
04286:  MOVFF  02,67D
0428A:  MOVFF  01,67C
0428E:  MOVLB  0
04290:  CALL   12E8
04294:  MOVFF  63A,FEA
04298:  MOVFF  639,FE9
0429C:  MOVFF  00,FEF
042A0:  MOVFF  01,FEC
042A4:  MOVFF  02,FEC
042A8:  MOVFF  03,FEC
....................    adcVals[ch].cosCounts = adcVals[ch].cosRaw * adcCal[ch].cosGain + adcCal[ch].cosOS;
042AC:  MOVLB  6
042AE:  MOVF   x30,W
042B0:  MULLW  21
042B2:  MOVF   FF3,W
042B4:  CLRF   x3A
042B6:  MOVWF  x39
042B8:  MOVLW  0C
042BA:  ADDWF  x39,W
042BC:  MOVWF  01
042BE:  MOVLW  00
042C0:  ADDWFC x3A,W
042C2:  MOVWF  03
042C4:  MOVF   01,W
042C6:  ADDLW  0F
042C8:  MOVWF  01
042CA:  MOVLW  01
042CC:  ADDWFC 03,F
042CE:  MOVFF  01,639
042D2:  MOVFF  03,63A
042D6:  MOVF   x30,W
042D8:  MULLW  21
042DA:  MOVF   FF3,W
042DC:  CLRF   x3C
042DE:  MOVWF  x3B
042E0:  MOVLW  04
042E2:  ADDWF  x3B,W
042E4:  MOVWF  01
042E6:  MOVLW  00
042E8:  ADDWFC x3C,W
042EA:  MOVWF  03
042EC:  MOVF   01,W
042EE:  ADDLW  0F
042F0:  MOVWF  FE9
042F2:  MOVLW  01
042F4:  ADDWFC 03,W
042F6:  MOVWF  FEA
042F8:  MOVFF  FEF,678
042FC:  MOVFF  FEC,679
04300:  MOVFF  FEC,67A
04304:  MOVFF  FEC,67B
04308:  MOVF   x30,W
0430A:  MULLW  10
0430C:  MOVF   FF3,W
0430E:  CLRF   x40
04310:  MOVWF  x3F
04312:  MOVLW  0C
04314:  ADDWF  x3F,W
04316:  MOVWF  01
04318:  MOVLW  00
0431A:  ADDWFC x40,W
0431C:  MOVWF  03
0431E:  MOVF   01,W
04320:  ADDLW  62
04322:  MOVWF  FE9
04324:  MOVLW  00
04326:  ADDWFC 03,W
04328:  MOVWF  FEA
0432A:  MOVFF  FEF,67C
0432E:  MOVFF  FEC,01
04332:  MOVFF  FEC,02
04336:  MOVFF  FEC,03
0433A:  MOVFF  03,67F
0433E:  MOVFF  02,67E
04342:  MOVFF  01,67D
04346:  MOVLB  0
04348:  CALL   11F2
0434C:  MOVFF  03,67A
04350:  MOVFF  02,679
04354:  MOVFF  01,678
04358:  MOVFF  00,677
0435C:  MOVLB  6
0435E:  MOVF   x30,W
04360:  MULLW  10
04362:  MOVF   FF3,W
04364:  CLRF   x40
04366:  MOVWF  x3F
04368:  MOVLW  04
0436A:  ADDWF  x3F,W
0436C:  MOVWF  01
0436E:  MOVLW  00
04370:  ADDWFC x40,W
04372:  MOVWF  03
04374:  MOVF   01,W
04376:  ADDLW  62
04378:  MOVWF  FE9
0437A:  MOVLW  00
0437C:  ADDWFC 03,W
0437E:  MOVWF  FEA
04380:  MOVFF  FEF,67B
04384:  MOVFF  FEC,01
04388:  MOVFF  FEC,02
0438C:  MOVFF  FEC,03
04390:  BCF    FD8.1
04392:  MOVFF  03,67E
04396:  MOVFF  02,67D
0439A:  MOVFF  01,67C
0439E:  MOVLB  0
043A0:  CALL   12E8
043A4:  MOVFF  63A,FEA
043A8:  MOVFF  639,FE9
043AC:  MOVFF  00,FEF
043B0:  MOVFF  01,FEC
043B4:  MOVFF  02,FEC
043B8:  MOVFF  03,FEC
....................    float pTmp = 0;
....................    float polePitch = magPP;
043BC:  MOVLB  6
043BE:  CLRF   x34
043C0:  CLRF   x33
043C2:  CLRF   x32
043C4:  CLRF   x31
043C6:  CLRF   x38
043C8:  CLRF   x37
043CA:  CLRF   x36
043CC:  MOVLW  7F
043CE:  MOVWF  x35
....................    
....................    if (adcVals[ch].cosCounts < 0){
043D0:  MOVF   x30,W
043D2:  MULLW  21
043D4:  MOVF   FF3,W
043D6:  CLRF   x3A
043D8:  MOVWF  x39
043DA:  MOVLW  0C
043DC:  ADDWF  x39,W
043DE:  MOVWF  01
043E0:  MOVLW  00
043E2:  ADDWFC x3A,W
043E4:  MOVWF  03
043E6:  MOVF   01,W
043E8:  ADDLW  0F
043EA:  MOVWF  FE9
043EC:  MOVLW  01
043EE:  ADDWFC 03,W
043F0:  MOVWF  FEA
043F2:  MOVFF  FEF,673
043F6:  MOVFF  FEC,674
043FA:  MOVFF  FEC,675
043FE:  MOVFF  FEC,676
04402:  CLRF   x7A
04404:  CLRF   x79
04406:  CLRF   x78
04408:  CLRF   x77
0440A:  MOVLB  0
0440C:  CALL   25F0
04410:  BTFSS  FD8.0
04412:  BRA    457C
....................       if ((adcVals[ch].sinCounts > 0) && (adcVals[ch].sinLast < 0)){
04414:  MOVLB  6
04416:  MOVF   x30,W
04418:  MULLW  21
0441A:  MOVF   FF3,W
0441C:  CLRF   x3A
0441E:  MOVWF  x39
04420:  MOVLW  08
04422:  ADDWF  x39,W
04424:  MOVWF  01
04426:  MOVLW  00
04428:  ADDWFC x3A,W
0442A:  MOVWF  03
0442C:  MOVF   01,W
0442E:  ADDLW  0F
04430:  MOVWF  FE9
04432:  MOVLW  01
04434:  ADDWFC 03,W
04436:  MOVWF  FEA
04438:  MOVFF  FEF,677
0443C:  MOVFF  FEC,63A
04440:  MOVFF  FEC,679
04444:  MOVFF  FEC,67A
04448:  CLRF   x76
0444A:  CLRF   x75
0444C:  CLRF   x74
0444E:  CLRF   x73
04450:  MOVFF  63A,678
04454:  MOVLB  0
04456:  CALL   25F0
0445A:  BNC   44C8
0445C:  MOVLB  6
0445E:  MOVF   x30,W
04460:  MULLW  21
04462:  MOVF   FF3,W
04464:  CLRF   x3A
04466:  MOVWF  x39
04468:  MOVLW  10
0446A:  ADDWF  x39,W
0446C:  MOVWF  01
0446E:  MOVLW  00
04470:  ADDWFC x3A,W
04472:  MOVWF  03
04474:  MOVF   01,W
04476:  ADDLW  0F
04478:  MOVWF  FE9
0447A:  MOVLW  01
0447C:  ADDWFC 03,W
0447E:  MOVWF  FEA
04480:  MOVFF  FEF,673
04484:  MOVFF  FEC,674
04488:  MOVFF  FEC,675
0448C:  MOVFF  FEC,676
04490:  CLRF   x7A
04492:  CLRF   x79
04494:  CLRF   x78
04496:  CLRF   x77
04498:  MOVLB  0
0449A:  CALL   25F0
0449E:  BNC   44C8
....................          adcVals[ch].npoles--;
044A0:  MOVLB  6
044A2:  MOVF   x30,W
044A4:  MULLW  21
044A6:  MOVF   FF3,W
044A8:  CLRF   x3A
044AA:  MOVWF  x39
044AC:  MOVLW  1C
044AE:  ADDWF  x39,W
044B0:  MOVWF  01
044B2:  MOVLW  00
044B4:  ADDWFC x3A,W
044B6:  MOVWF  03
044B8:  MOVF   01,W
044BA:  ADDLW  0F
044BC:  MOVWF  FE9
044BE:  MOVLW  01
044C0:  ADDWFC 03,W
044C2:  MOVWF  FEA
044C4:  DECF   FEF,F
....................       }
044C6:  BRA    457A
....................       else if ((adcVals[ch].sinCounts < 0) && (adcVals[ch].sinLast > 0)){
044C8:  MOVLB  6
044CA:  MOVF   x30,W
044CC:  MULLW  21
044CE:  MOVF   FF3,W
044D0:  CLRF   x3A
044D2:  MOVWF  x39
044D4:  MOVLW  08
044D6:  ADDWF  x39,W
044D8:  MOVWF  01
044DA:  MOVLW  00
044DC:  ADDWFC x3A,W
044DE:  MOVWF  03
044E0:  MOVF   01,W
044E2:  ADDLW  0F
044E4:  MOVWF  FE9
044E6:  MOVLW  01
044E8:  ADDWFC 03,W
044EA:  MOVWF  FEA
044EC:  MOVFF  FEF,673
044F0:  MOVFF  FEC,63A
044F4:  MOVFF  FEC,675
044F8:  MOVFF  FEC,676
044FC:  MOVFF  63A,674
04500:  CLRF   x7A
04502:  CLRF   x79
04504:  CLRF   x78
04506:  CLRF   x77
04508:  MOVLB  0
0450A:  CALL   25F0
0450E:  BNC   457C
04510:  MOVLB  6
04512:  MOVF   x30,W
04514:  MULLW  21
04516:  MOVF   FF3,W
04518:  CLRF   x3A
0451A:  MOVWF  x39
0451C:  MOVLW  10
0451E:  ADDWF  x39,W
04520:  MOVWF  01
04522:  MOVLW  00
04524:  ADDWFC x3A,W
04526:  MOVWF  03
04528:  MOVF   01,W
0452A:  ADDLW  0F
0452C:  MOVWF  FE9
0452E:  MOVLW  01
04530:  ADDWFC 03,W
04532:  MOVWF  FEA
04534:  MOVFF  FEF,677
04538:  MOVFF  FEC,678
0453C:  MOVFF  FEC,679
04540:  MOVFF  FEC,67A
04544:  CLRF   x76
04546:  CLRF   x75
04548:  CLRF   x74
0454A:  CLRF   x73
0454C:  MOVLB  0
0454E:  CALL   25F0
04552:  BNC   457C
....................          adcVals[ch].npoles++;
04554:  MOVLB  6
04556:  MOVF   x30,W
04558:  MULLW  21
0455A:  MOVF   FF3,W
0455C:  CLRF   x3A
0455E:  MOVWF  x39
04560:  MOVLW  1C
04562:  ADDWF  x39,W
04564:  MOVWF  01
04566:  MOVLW  00
04568:  ADDWFC x3A,W
0456A:  MOVWF  03
0456C:  MOVF   01,W
0456E:  ADDLW  0F
04570:  MOVWF  FE9
04572:  MOVLW  01
04574:  ADDWFC 03,W
04576:  MOVWF  FEA
04578:  INCF   FEF,F
0457A:  MOVLB  0
....................       }
....................    }
....................    
....................    adcVals[ch].p0 = polePitch * ( 1000 / (2*PI) ) * atan2( (float)adcVals[ch].sinCounts, (float)adcVals[ch].cosCounts );
0457C:  MOVLB  6
0457E:  MOVF   x30,W
04580:  MULLW  21
04582:  MOVF   FF3,W
04584:  CLRF   x3A
04586:  MOVWF  x39
04588:  MOVLW  18
0458A:  ADDWF  x39,W
0458C:  MOVWF  01
0458E:  MOVLW  00
04590:  ADDWFC x3A,W
04592:  MOVWF  03
04594:  MOVF   01,W
04596:  ADDLW  0F
04598:  MOVWF  01
0459A:  MOVLW  01
0459C:  ADDWFC 03,F
0459E:  MOVFF  01,639
045A2:  MOVFF  03,63A
045A6:  MOVFF  638,67B
045AA:  MOVFF  637,67A
045AE:  MOVFF  636,679
045B2:  MOVFF  635,678
045B6:  MOVLW  AA
045B8:  MOVWF  x7F
045BA:  MOVLW  27
045BC:  MOVWF  x7E
045BE:  MOVLW  1F
045C0:  MOVWF  x7D
045C2:  MOVLW  86
045C4:  MOVWF  x7C
045C6:  MOVLB  0
045C8:  CALL   11F2
045CC:  MOVFF  03,63E
045D0:  MOVFF  02,63D
045D4:  MOVFF  01,63C
045D8:  MOVFF  00,63B
045DC:  MOVLB  6
045DE:  MOVF   x30,W
045E0:  MULLW  21
045E2:  MOVF   FF3,W
045E4:  CLRF   x40
045E6:  MOVWF  x3F
045E8:  MOVLW  08
045EA:  ADDWF  x3F,W
045EC:  MOVWF  01
045EE:  MOVLW  00
045F0:  ADDWFC x40,W
045F2:  MOVWF  03
045F4:  MOVF   01,W
045F6:  ADDLW  0F
045F8:  MOVWF  FE9
045FA:  MOVLW  01
045FC:  ADDWFC 03,W
045FE:  MOVWF  FEA
04600:  MOVFF  FEF,63F
04604:  MOVFF  FEC,640
04608:  MOVFF  FEC,641
0460C:  MOVFF  FEC,642
04610:  MOVF   x30,W
04612:  MULLW  21
04614:  MOVF   FF3,W
04616:  CLRF   x44
04618:  MOVWF  x43
0461A:  MOVLW  0C
0461C:  ADDWF  x43,W
0461E:  MOVWF  01
04620:  MOVLW  00
04622:  ADDWFC x44,W
04624:  MOVWF  03
04626:  MOVF   01,W
04628:  ADDLW  0F
0462A:  MOVWF  FE9
0462C:  MOVLW  01
0462E:  ADDWFC 03,W
04630:  MOVWF  FEA
04632:  MOVFF  FEF,00
04636:  MOVFF  FEC,01
0463A:  MOVFF  FEC,02
0463E:  MOVFF  FEC,03
04642:  MOVFF  03,646
04646:  MOVFF  02,645
0464A:  MOVFF  01,644
0464E:  MOVFF  00,643
04652:  MOVFF  642,64A
04656:  MOVFF  641,649
0465A:  MOVFF  640,648
0465E:  MOVFF  63F,647
04662:  MOVFF  03,64E
04666:  MOVFF  02,64D
0466A:  MOVFF  01,64C
0466E:  MOVFF  00,64B
04672:  MOVLB  0
04674:  GOTO   2CF2
04678:  MOVFF  63E,67B
0467C:  MOVFF  63D,67A
04680:  MOVFF  63C,679
04684:  MOVFF  63B,678
04688:  MOVFF  03,67F
0468C:  MOVFF  02,67E
04690:  MOVFF  01,67D
04694:  MOVFF  00,67C
04698:  CALL   11F2
0469C:  MOVFF  63A,FEA
046A0:  MOVFF  639,FE9
046A4:  MOVFF  00,FEF
046A8:  MOVFF  01,FEC
046AC:  MOVFF  02,FEC
046B0:  MOVFF  03,FEC
....................    pTmp = adcVals[ch].p0 + ( 1000 * polePitch * (float)adcVals[ch].npoles );
046B4:  MOVLB  6
046B6:  MOVF   x30,W
046B8:  MULLW  21
046BA:  MOVF   FF3,W
046BC:  CLRF   x3A
046BE:  MOVWF  x39
046C0:  MOVLW  18
046C2:  ADDWF  x39,W
046C4:  MOVWF  01
046C6:  MOVLW  00
046C8:  ADDWFC x3A,W
046CA:  MOVWF  03
046CC:  MOVF   01,W
046CE:  ADDLW  0F
046D0:  MOVWF  FE9
046D2:  MOVLW  01
046D4:  ADDWFC 03,W
046D6:  MOVWF  FEA
046D8:  MOVFF  FEF,639
046DC:  MOVFF  FEC,63A
046E0:  MOVFF  FEC,63B
046E4:  MOVFF  FEC,63C
046E8:  CLRF   x7B
046EA:  CLRF   x7A
046EC:  MOVLW  7A
046EE:  MOVWF  x79
046F0:  MOVLW  88
046F2:  MOVWF  x78
046F4:  MOVFF  638,67F
046F8:  MOVFF  637,67E
046FC:  MOVFF  636,67D
04700:  MOVFF  635,67C
04704:  MOVLB  0
04706:  CALL   11F2
0470A:  MOVFF  03,640
0470E:  MOVFF  02,63F
04712:  MOVFF  01,63E
04716:  MOVFF  00,63D
0471A:  MOVLB  6
0471C:  MOVF   x30,W
0471E:  MULLW  21
04720:  MOVF   FF3,W
04722:  CLRF   x42
04724:  MOVWF  x41
04726:  MOVLW  1C
04728:  ADDWF  x41,W
0472A:  MOVWF  01
0472C:  MOVLW  00
0472E:  ADDWFC x42,W
04730:  MOVWF  03
04732:  MOVF   01,W
04734:  ADDLW  0F
04736:  MOVWF  FE9
04738:  MOVLW  01
0473A:  ADDWFC 03,W
0473C:  MOVWF  FEA
0473E:  MOVF   FEF,W
04740:  CLRF   x6A
04742:  MOVWF  x69
04744:  BTFSC  x69.7
04746:  DECF   x6A,F
04748:  MOVLB  0
0474A:  CALL   2F94
0474E:  MOVFF  640,67B
04752:  MOVFF  63F,67A
04756:  MOVFF  63E,679
0475A:  MOVFF  63D,678
0475E:  MOVFF  03,67F
04762:  MOVFF  02,67E
04766:  MOVFF  01,67D
0476A:  MOVFF  00,67C
0476E:  CALL   11F2
04772:  MOVFF  FEA,63E
04776:  MOVFF  FE9,63D
0477A:  BCF    FD8.1
0477C:  MOVFF  63C,67A
04780:  MOVFF  63B,679
04784:  MOVFF  63A,678
04788:  MOVFF  639,677
0478C:  MOVFF  03,67E
04790:  MOVFF  02,67D
04794:  MOVFF  01,67C
04798:  MOVFF  00,67B
0479C:  CALL   12E8
047A0:  MOVFF  63E,FEA
047A4:  MOVFF  63D,FE9
047A8:  MOVFF  03,634
047AC:  MOVFF  02,633
047B0:  MOVFF  01,632
047B4:  MOVFF  00,631
....................    
....................    adcVals[ch].pReal = (pow(pTmp*sc[ch].c5,5) + pow(pTmp*sc[ch].c4,4) + pow(pTmp*sc[ch].c3,3) + pow(pTmp*sc[ch].c2,2) + pTmp*sc[ch].c1 + sc[ch].c0);
047B8:  MOVLB  6
047BA:  MOVF   x30,W
047BC:  MULLW  21
047BE:  MOVF   FF3,W
047C0:  CLRF   x3A
047C2:  MOVWF  x39
047C4:  MOVLW  1D
047C6:  ADDWF  x39,W
047C8:  MOVWF  01
047CA:  MOVLW  00
047CC:  ADDWFC x3A,W
047CE:  MOVWF  03
047D0:  MOVF   01,W
047D2:  ADDLW  0F
047D4:  MOVWF  01
047D6:  MOVLW  01
047D8:  ADDWFC 03,F
047DA:  MOVFF  01,639
047DE:  MOVFF  03,63A
047E2:  MOVF   x30,W
047E4:  MULLW  18
047E6:  MOVF   FF3,W
047E8:  CLRF   x3C
047EA:  MOVWF  x3B
047EC:  MOVLW  14
047EE:  ADDWF  x3B,W
047F0:  MOVWF  01
047F2:  MOVLW  00
047F4:  ADDWFC x3C,W
047F6:  MOVWF  03
047F8:  MOVF   01,W
047FA:  ADDLW  82
047FC:  MOVWF  FE9
047FE:  MOVLW  00
04800:  ADDWFC 03,W
04802:  MOVWF  FEA
04804:  MOVFF  FEF,67C
04808:  MOVFF  FEC,01
0480C:  MOVFF  FEC,02
04810:  MOVFF  FEC,03
04814:  MOVFF  634,67B
04818:  MOVFF  633,67A
0481C:  MOVFF  632,679
04820:  MOVFF  631,678
04824:  MOVFF  03,67F
04828:  MOVFF  02,67E
0482C:  MOVFF  01,67D
04830:  MOVLB  0
04832:  CALL   11F2
04836:  MOVFF  03,63E
0483A:  MOVFF  02,63D
0483E:  MOVFF  01,63C
04842:  MOVFF  00,63B
04846:  MOVFF  03,64A
0484A:  MOVFF  02,649
0484E:  MOVFF  01,648
04852:  MOVFF  00,647
04856:  MOVLB  6
04858:  CLRF   x4E
0485A:  CLRF   x4D
0485C:  MOVLW  20
0485E:  MOVWF  x4C
04860:  MOVLW  81
04862:  MOVWF  x4B
04864:  MOVLB  0
04866:  CALL   3CD2
0486A:  MOVFF  03,63E
0486E:  MOVFF  02,63D
04872:  MOVFF  01,63C
04876:  MOVFF  00,63B
0487A:  MOVLB  6
0487C:  MOVF   x30,W
0487E:  MULLW  18
04880:  MOVF   FF3,W
04882:  CLRF   x40
04884:  MOVWF  x3F
04886:  MOVLW  10
04888:  ADDWF  x3F,W
0488A:  MOVWF  01
0488C:  MOVLW  00
0488E:  ADDWFC x40,W
04890:  MOVWF  03
04892:  MOVF   01,W
04894:  ADDLW  82
04896:  MOVWF  FE9
04898:  MOVLW  00
0489A:  ADDWFC 03,W
0489C:  MOVWF  FEA
0489E:  MOVFF  FEF,67C
048A2:  MOVFF  FEC,01
048A6:  MOVFF  FEC,02
048AA:  MOVFF  FEC,03
048AE:  MOVFF  634,67B
048B2:  MOVFF  633,67A
048B6:  MOVFF  632,679
048BA:  MOVFF  631,678
048BE:  MOVFF  03,67F
048C2:  MOVFF  02,67E
048C6:  MOVFF  01,67D
048CA:  MOVLB  0
048CC:  CALL   11F2
048D0:  MOVFF  03,642
048D4:  MOVFF  02,641
048D8:  MOVFF  01,640
048DC:  MOVFF  00,63F
048E0:  MOVFF  03,64A
048E4:  MOVFF  02,649
048E8:  MOVFF  01,648
048EC:  MOVFF  00,647
048F0:  MOVLB  6
048F2:  CLRF   x4E
048F4:  CLRF   x4D
048F6:  CLRF   x4C
048F8:  MOVLW  81
048FA:  MOVWF  x4B
048FC:  MOVLB  0
048FE:  CALL   3CD2
04902:  MOVFF  FEA,640
04906:  MOVFF  FE9,63F
0490A:  BCF    FD8.1
0490C:  MOVFF  63E,67A
04910:  MOVFF  63D,679
04914:  MOVFF  63C,678
04918:  MOVFF  63B,677
0491C:  MOVFF  03,67E
04920:  MOVFF  02,67D
04924:  MOVFF  01,67C
04928:  MOVFF  00,67B
0492C:  CALL   12E8
04930:  MOVFF  640,FEA
04934:  MOVFF  63F,FE9
04938:  MOVFF  03,63E
0493C:  MOVFF  02,63D
04940:  MOVFF  01,63C
04944:  MOVFF  00,63B
04948:  MOVLB  6
0494A:  MOVF   x30,W
0494C:  MULLW  18
0494E:  MOVF   FF3,W
04950:  CLRF   x42
04952:  MOVWF  x41
04954:  MOVLW  0C
04956:  ADDWF  x41,W
04958:  MOVWF  01
0495A:  MOVLW  00
0495C:  ADDWFC x42,W
0495E:  MOVWF  03
04960:  MOVF   01,W
04962:  ADDLW  82
04964:  MOVWF  FE9
04966:  MOVLW  00
04968:  ADDWFC 03,W
0496A:  MOVWF  FEA
0496C:  MOVFF  FEF,67C
04970:  MOVFF  FEC,01
04974:  MOVFF  FEC,02
04978:  MOVFF  FEC,03
0497C:  MOVFF  634,67B
04980:  MOVFF  633,67A
04984:  MOVFF  632,679
04988:  MOVFF  631,678
0498C:  MOVFF  03,67F
04990:  MOVFF  02,67E
04994:  MOVFF  01,67D
04998:  MOVLB  0
0499A:  CALL   11F2
0499E:  MOVFF  03,644
049A2:  MOVFF  02,643
049A6:  MOVFF  01,642
049AA:  MOVFF  00,641
049AE:  MOVFF  03,64A
049B2:  MOVFF  02,649
049B6:  MOVFF  01,648
049BA:  MOVFF  00,647
049BE:  MOVLB  6
049C0:  CLRF   x4E
049C2:  CLRF   x4D
049C4:  MOVLW  40
049C6:  MOVWF  x4C
049C8:  MOVLW  80
049CA:  MOVWF  x4B
049CC:  MOVLB  0
049CE:  CALL   3CD2
049D2:  MOVFF  FEA,642
049D6:  MOVFF  FE9,641
049DA:  BCF    FD8.1
049DC:  MOVFF  63E,67A
049E0:  MOVFF  63D,679
049E4:  MOVFF  63C,678
049E8:  MOVFF  63B,677
049EC:  MOVFF  03,67E
049F0:  MOVFF  02,67D
049F4:  MOVFF  01,67C
049F8:  MOVFF  00,67B
049FC:  CALL   12E8
04A00:  MOVFF  642,FEA
04A04:  MOVFF  641,FE9
04A08:  MOVFF  03,63E
04A0C:  MOVFF  02,63D
04A10:  MOVFF  01,63C
04A14:  MOVFF  00,63B
04A18:  MOVLB  6
04A1A:  MOVF   x30,W
04A1C:  MULLW  18
04A1E:  MOVF   FF3,W
04A20:  CLRF   x44
04A22:  MOVWF  x43
04A24:  MOVLW  08
04A26:  ADDWF  x43,W
04A28:  MOVWF  01
04A2A:  MOVLW  00
04A2C:  ADDWFC x44,W
04A2E:  MOVWF  03
04A30:  MOVF   01,W
04A32:  ADDLW  82
04A34:  MOVWF  FE9
04A36:  MOVLW  00
04A38:  ADDWFC 03,W
04A3A:  MOVWF  FEA
04A3C:  MOVFF  FEF,67C
04A40:  MOVFF  FEC,01
04A44:  MOVFF  FEC,02
04A48:  MOVFF  FEC,03
04A4C:  MOVFF  634,67B
04A50:  MOVFF  633,67A
04A54:  MOVFF  632,679
04A58:  MOVFF  631,678
04A5C:  MOVFF  03,67F
04A60:  MOVFF  02,67E
04A64:  MOVFF  01,67D
04A68:  MOVLB  0
04A6A:  CALL   11F2
04A6E:  MOVFF  03,646
04A72:  MOVFF  02,645
04A76:  MOVFF  01,644
04A7A:  MOVFF  00,643
04A7E:  MOVFF  03,64A
04A82:  MOVFF  02,649
04A86:  MOVFF  01,648
04A8A:  MOVFF  00,647
04A8E:  MOVLB  6
04A90:  CLRF   x4E
04A92:  CLRF   x4D
04A94:  CLRF   x4C
04A96:  MOVLW  80
04A98:  MOVWF  x4B
04A9A:  MOVLB  0
04A9C:  CALL   3CD2
04AA0:  MOVFF  FEA,644
04AA4:  MOVFF  FE9,643
04AA8:  BCF    FD8.1
04AAA:  MOVFF  63E,67A
04AAE:  MOVFF  63D,679
04AB2:  MOVFF  63C,678
04AB6:  MOVFF  63B,677
04ABA:  MOVFF  03,67E
04ABE:  MOVFF  02,67D
04AC2:  MOVFF  01,67C
04AC6:  MOVFF  00,67B
04ACA:  CALL   12E8
04ACE:  MOVFF  644,FEA
04AD2:  MOVFF  643,FE9
04AD6:  MOVFF  03,63E
04ADA:  MOVFF  02,63D
04ADE:  MOVFF  01,63C
04AE2:  MOVFF  00,63B
04AE6:  MOVLB  6
04AE8:  MOVF   x30,W
04AEA:  MULLW  18
04AEC:  MOVF   FF3,W
04AEE:  CLRF   x46
04AF0:  MOVWF  x45
04AF2:  MOVLW  04
04AF4:  ADDWF  x45,W
04AF6:  MOVWF  01
04AF8:  MOVLW  00
04AFA:  ADDWFC x46,W
04AFC:  MOVWF  03
04AFE:  MOVF   01,W
04B00:  ADDLW  82
04B02:  MOVWF  FE9
04B04:  MOVLW  00
04B06:  ADDWFC 03,W
04B08:  MOVWF  FEA
04B0A:  MOVFF  FEF,67C
04B0E:  MOVFF  FEC,01
04B12:  MOVFF  FEC,02
04B16:  MOVFF  FEC,03
04B1A:  MOVFF  634,67B
04B1E:  MOVFF  633,67A
04B22:  MOVFF  632,679
04B26:  MOVFF  631,678
04B2A:  MOVFF  03,67F
04B2E:  MOVFF  02,67E
04B32:  MOVFF  01,67D
04B36:  MOVLB  0
04B38:  CALL   11F2
04B3C:  MOVFF  FEA,646
04B40:  MOVFF  FE9,645
04B44:  BCF    FD8.1
04B46:  MOVFF  63E,67A
04B4A:  MOVFF  63D,679
04B4E:  MOVFF  63C,678
04B52:  MOVFF  63B,677
04B56:  MOVFF  03,67E
04B5A:  MOVFF  02,67D
04B5E:  MOVFF  01,67C
04B62:  MOVFF  00,67B
04B66:  CALL   12E8
04B6A:  MOVFF  646,FEA
04B6E:  MOVFF  645,FE9
04B72:  MOVFF  03,67A
04B76:  MOVFF  02,679
04B7A:  MOVFF  01,678
04B7E:  MOVFF  00,677
04B82:  MOVLB  6
04B84:  MOVF   x30,W
04B86:  MULLW  18
04B88:  MOVF   FF3,W
04B8A:  CLRF   x48
04B8C:  MOVWF  x47
04B8E:  MOVLW  82
04B90:  ADDWF  x47,W
04B92:  MOVWF  FE9
04B94:  MOVLW  00
04B96:  ADDWFC x48,W
04B98:  MOVWF  FEA
04B9A:  MOVFF  FEF,67B
04B9E:  MOVFF  FEC,01
04BA2:  MOVFF  FEC,02
04BA6:  MOVFF  FEC,03
04BAA:  BCF    FD8.1
04BAC:  MOVFF  03,67E
04BB0:  MOVFF  02,67D
04BB4:  MOVFF  01,67C
04BB8:  MOVLB  0
04BBA:  CALL   12E8
04BBE:  MOVFF  63A,FEA
04BC2:  MOVFF  639,FE9
04BC6:  MOVFF  00,FEF
04BCA:  MOVFF  01,FEC
04BCE:  MOVFF  02,FEC
04BD2:  MOVFF  03,FEC
....................    if (ch == chX) adcVals[ch].pReal *= -1;
04BD6:  MOVLB  6
04BD8:  MOVF   x30,F
04BDA:  BNZ   4C38
04BDC:  MOVF   x30,W
04BDE:  MULLW  21
04BE0:  MOVF   FF3,W
04BE2:  CLRF   x3A
04BE4:  MOVWF  x39
04BE6:  MOVLW  1D
04BE8:  ADDWF  x39,W
04BEA:  MOVWF  01
04BEC:  MOVLW  00
04BEE:  ADDWFC x3A,W
04BF0:  MOVWF  03
04BF2:  MOVF   01,W
04BF4:  ADDLW  0F
04BF6:  MOVWF  FE9
04BF8:  MOVLW  01
04BFA:  ADDWFC 03,W
04BFC:  MOVWF  FEA
04BFE:  MOVFF  FEF,678
04C02:  MOVFF  FEC,679
04C06:  MOVFF  FEC,67A
04C0A:  MOVFF  FEC,67B
04C0E:  MOVF   FED,F
04C10:  MOVF   FED,F
04C12:  MOVF   FED,F
04C14:  CLRF   x7F
04C16:  CLRF   x7E
04C18:  MOVLW  80
04C1A:  MOVWF  x7D
04C1C:  MOVLW  7F
04C1E:  MOVWF  x7C
04C20:  MOVLB  0
04C22:  CALL   11F2
04C26:  MOVFF  00,FEF
04C2A:  MOVFF  01,FEC
04C2E:  MOVFF  02,FEC
04C32:  MOVFF  03,FEC
04C36:  MOVLB  6
....................    PID[ch].PVold = PID[ch].PV;
04C38:  MOVF   x30,W
04C3A:  MULLW  20
04C3C:  MOVF   FF3,W
04C3E:  CLRF   x3A
04C40:  MOVWF  x39
04C42:  MOVLW  14
04C44:  ADDWF  x39,W
04C46:  MOVWF  01
04C48:  MOVLW  00
04C4A:  ADDWFC x3A,W
04C4C:  MOVWF  03
04C4E:  MOVF   01,W
04C50:  ADDLW  20
04C52:  MOVWF  01
04C54:  MOVLW  00
04C56:  ADDWFC 03,F
04C58:  MOVFF  01,639
04C5C:  MOVFF  03,63A
04C60:  MOVF   x30,W
04C62:  MULLW  20
04C64:  MOVF   FF3,W
04C66:  CLRF   x3C
04C68:  MOVWF  x3B
04C6A:  MOVLW  10
04C6C:  ADDWF  x3B,W
04C6E:  MOVWF  01
04C70:  MOVLW  00
04C72:  ADDWFC x3C,W
04C74:  MOVWF  03
04C76:  MOVF   01,W
04C78:  ADDLW  20
04C7A:  MOVWF  FE9
04C7C:  MOVLW  00
04C7E:  ADDWFC 03,W
04C80:  MOVWF  FEA
04C82:  MOVFF  FEF,00
04C86:  MOVFF  FEC,01
04C8A:  MOVFF  FEC,02
04C8E:  MOVFF  FEC,03
04C92:  MOVFF  63A,FEA
04C96:  MOVFF  639,FE9
04C9A:  MOVFF  00,FEF
04C9E:  MOVFF  01,FEC
04CA2:  MOVFF  02,FEC
04CA6:  MOVFF  03,FEC
....................    PID[ch].PV = adcVals[ch].pReal;
04CAA:  MOVF   x30,W
04CAC:  MULLW  20
04CAE:  MOVF   FF3,W
04CB0:  CLRF   x3A
04CB2:  MOVWF  x39
04CB4:  MOVLW  10
04CB6:  ADDWF  x39,W
04CB8:  MOVWF  01
04CBA:  MOVLW  00
04CBC:  ADDWFC x3A,W
04CBE:  MOVWF  03
04CC0:  MOVF   01,W
04CC2:  ADDLW  20
04CC4:  MOVWF  01
04CC6:  MOVLW  00
04CC8:  ADDWFC 03,F
04CCA:  MOVFF  01,639
04CCE:  MOVFF  03,63A
04CD2:  MOVF   x30,W
04CD4:  MULLW  21
04CD6:  MOVF   FF3,W
04CD8:  CLRF   x3C
04CDA:  MOVWF  x3B
04CDC:  MOVLW  1D
04CDE:  ADDWF  x3B,W
04CE0:  MOVWF  01
04CE2:  MOVLW  00
04CE4:  ADDWFC x3C,W
04CE6:  MOVWF  03
04CE8:  MOVF   01,W
04CEA:  ADDLW  0F
04CEC:  MOVWF  FE9
04CEE:  MOVLW  01
04CF0:  ADDWFC 03,W
04CF2:  MOVWF  FEA
04CF4:  MOVFF  FEF,00
04CF8:  MOVFF  FEC,01
04CFC:  MOVFF  FEC,02
04D00:  MOVFF  FEC,03
04D04:  MOVFF  63A,FEA
04D08:  MOVFF  639,FE9
04D0C:  MOVFF  00,FEF
04D10:  MOVFF  01,FEC
04D14:  MOVFF  02,FEC
04D18:  MOVFF  03,FEC
04D1C:  MOVLB  0
04D1E:  GOTO   4E02 (RETURN)
.................... }  
.................... 
.................... /*****************************************************************************/
.................... /* SENSOR MONITOR INTERRUPT TASK                                             */
.................... /* starts conversion of the other two ADCs                                   */
.................... /*****************************************************************************/
.................... void sensor_monitor_interrupt_task()
.................... {
....................    static int8 ch = 0;
....................    
....................    if (!smData[ch].adcBusy)
*
001BE:  MOVLB  1
001C0:  MOVF   x9C,W
001C2:  MULLW  0D
001C4:  MOVF   FF3,W
001C6:  MOVLB  6
001C8:  CLRF   x98
001CA:  MOVWF  x97
001CC:  MOVLW  81
001CE:  ADDWF  x97,W
001D0:  MOVWF  FE9
001D2:  MOVLW  01
001D4:  ADDWFC x98,W
001D6:  MOVWF  FEA
001D8:  BTFSC  FEF.1
001DA:  BRA    0254
....................    {
....................       smData[ch].adcBusy = true;
001DC:  MOVLB  1
001DE:  MOVF   x9C,W
001E0:  MULLW  0D
001E2:  MOVF   FF3,W
001E4:  MOVLB  6
001E6:  CLRF   x98
001E8:  MOVWF  x97
001EA:  MOVLW  81
001EC:  ADDWF  x97,W
001EE:  MOVWF  FE9
001F0:  MOVLW  01
001F2:  ADDWFC x98,W
001F4:  MOVWF  FEA
001F6:  BSF    FEF.1
....................       
....................       ads_start_conv_block(ch);
001F8:  MOVFF  19C,697
001FC:  MOVLB  0
001FE:  BRA    01A2
....................       ch = !ch;
00200:  MOVLB  1
00202:  MOVF   x9C,F
00204:  BZ    020A
00206:  MOVLW  00
00208:  BRA    020C
0020A:  MOVLW  01
0020C:  MOVWF  x9C
....................       
....................       smData[!ch].dataReady = true;
0020E:  MOVF   x9C,F
00210:  BZ    0216
00212:  MOVLW  00
00214:  BRA    0218
00216:  MOVLW  01
00218:  MULLW  0D
0021A:  MOVF   FF3,W
0021C:  MOVLB  6
0021E:  CLRF   x98
00220:  MOVWF  x97
00222:  MOVLW  81
00224:  ADDWF  x97,W
00226:  MOVWF  FE9
00228:  MOVLW  01
0022A:  ADDWFC x98,W
0022C:  MOVWF  FEA
0022E:  BSF    FEF.0
....................       smData[!ch].adcBusy = false;
00230:  MOVLB  1
00232:  MOVF   x9C,F
00234:  BZ    023A
00236:  MOVLW  00
00238:  BRA    023C
0023A:  MOVLW  01
0023C:  MULLW  0D
0023E:  MOVF   FF3,W
00240:  MOVLB  6
00242:  CLRF   x98
00244:  MOVWF  x97
00246:  MOVLW  81
00248:  ADDWF  x97,W
0024A:  MOVWF  FE9
0024C:  MOVLW  01
0024E:  ADDWFC x98,W
00250:  MOVWF  FEA
00252:  BCF    FEF.1
....................    }
00254:  MOVLB  0
00256:  GOTO   0318 (RETURN)
.................... }
.................... 
.................... signed int compar(void *a, void *b) {
....................    return COMPARE(a,b);
*
01ADE:  MOVLB  6
01AE0:  MOVF   x26,W
01AE2:  SUBWF  x24,W
01AE4:  BNC   1AEE
01AE6:  BNZ   1AF2
01AE8:  MOVF   x23,W
01AEA:  SUBWF  x25,W
01AEC:  BNC   1AF2
01AEE:  MOVLW  00
01AF0:  BRA    1AF4
01AF2:  MOVLW  01
01AF4:  MOVWF  x6E
01AF6:  MOVF   x24,W
01AF8:  SUBWF  x26,W
01AFA:  BNC   1B04
01AFC:  BNZ   1B08
01AFE:  MOVF   x25,W
01B00:  SUBWF  x23,W
01B02:  BNC   1B08
01B04:  MOVLW  00
01B06:  BRA    1B0A
01B08:  MOVLW  01
01B0A:  SUBWF  x6E,W
01B0C:  MOVWF  01
01B0E:  MOVLB  0
01B10:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Interquartile Mean Ring Buffer                                            */
.................... /* Filters the ADC data to remove spurious readings                          */
.................... /*****************************************************************************/
.................... void iqm_ring_buffer(int8 ch, signed int32 sinCnts, signed int32 cosCnts)
*
01D24:  MOVLB  6
01D26:  CLRF   x44
01D28:  CLRF   x43
01D2A:  CLRF   x42
01D2C:  CLRF   x41
01D2E:  CLRF   x48
01D30:  CLRF   x47
01D32:  CLRF   x46
01D34:  CLRF   x45
.................... {
....................    /* 
....................    -  copy data out to IQM buffer
....................    -  sort IQM buffer
....................    -  average values from middle quartile
....................    **************************************/
....................    signed int32 iqmBufSin[];
....................    signed int32 iqmBufCos[];
....................    signed int32 sumSin=0;
....................    signed int32 sumCos=0;
....................    
....................    tobuff(smData[ch].sinQ, sinCnts); // push new data into queues
01D36:  MOVF   x30,W
01D38:  MULLW  0D
01D3A:  MOVF   FF3,W
01D3C:  CLRF   x4C
01D3E:  MOVWF  x4B
01D40:  MOVLW  01
01D42:  ADDWF  x4B,W
01D44:  MOVWF  01
01D46:  MOVLW  00
01D48:  ADDWFC x4C,W
01D4A:  MOVWF  03
01D4C:  MOVF   01,W
01D4E:  ADDLW  81
01D50:  MOVWF  01
01D52:  MOVLW  01
01D54:  ADDWFC 03,F
01D56:  MOVFF  01,64B
01D5A:  MOVFF  03,64C
01D5E:  MOVFF  03,FEA
01D62:  MOVFF  01,FE9
01D66:  MOVFF  FEC,64E
01D6A:  MOVF   FED,F
01D6C:  MOVFF  FEF,64D
01D70:  MOVF   x30,W
01D72:  MULLW  0D
01D74:  MOVF   FF3,W
01D76:  CLRF   x50
01D78:  MOVWF  x4F
01D7A:  MOVLW  01
01D7C:  ADDWF  x4F,W
01D7E:  MOVWF  01
01D80:  MOVLW  00
01D82:  ADDWFC x50,W
01D84:  MOVWF  03
01D86:  MOVF   01,W
01D88:  ADDLW  81
01D8A:  MOVWF  01
01D8C:  MOVLW  01
01D8E:  ADDWFC 03,F
01D90:  MOVFF  01,64F
01D94:  MOVFF  03,650
01D98:  MOVFF  03,FEA
01D9C:  MOVFF  01,FE9
01DA0:  MOVFF  FEC,652
01DA4:  MOVF   FED,F
01DA6:  MOVFF  FEF,651
01DAA:  MOVFF  651,FE9
01DAE:  MOVFF  652,FEA
01DB2:  MOVLW  02
01DB4:  ADDWF  FEF,W
01DB6:  ADDWF  x4D,W
01DB8:  MOVWF  FE9
01DBA:  MOVLW  00
01DBC:  ADDWFC x4E,W
01DBE:  MOVWF  FEA
01DC0:  MOVFF  631,FEF
01DC4:  MOVF   x30,W
01DC6:  MULLW  0D
01DC8:  MOVF   FF3,W
01DCA:  CLRF   x4C
01DCC:  MOVWF  x4B
01DCE:  MOVLW  01
01DD0:  ADDWF  x4B,W
01DD2:  MOVWF  01
01DD4:  MOVLW  00
01DD6:  ADDWFC x4C,W
01DD8:  MOVWF  03
01DDA:  MOVF   01,W
01DDC:  ADDLW  81
01DDE:  MOVWF  01
01DE0:  MOVLW  01
01DE2:  ADDWFC 03,F
01DE4:  MOVFF  01,64B
01DE8:  MOVFF  03,64C
01DEC:  MOVFF  03,FEA
01DF0:  MOVFF  01,FE9
01DF4:  MOVFF  FEC,03
01DF8:  MOVF   FED,F
01DFA:  MOVFF  FEF,01
01DFE:  MOVFF  01,64F
01E02:  MOVFF  03,650
01E06:  MOVF   x30,W
01E08:  MULLW  0D
01E0A:  MOVF   FF3,W
01E0C:  CLRF   x52
01E0E:  MOVWF  x51
01E10:  MOVLW  01
01E12:  ADDWF  x51,W
01E14:  MOVWF  01
01E16:  MOVLW  00
01E18:  ADDWFC x52,W
01E1A:  MOVWF  03
01E1C:  MOVF   01,W
01E1E:  ADDLW  81
01E20:  MOVWF  01
01E22:  MOVLW  01
01E24:  ADDWFC 03,F
01E26:  MOVFF  01,651
01E2A:  MOVFF  03,652
01E2E:  MOVFF  03,FEA
01E32:  MOVFF  01,FE9
01E36:  MOVFF  FEC,654
01E3A:  MOVF   FED,F
01E3C:  MOVFF  FEF,653
01E40:  MOVFF  653,FE9
01E44:  MOVFF  654,FEA
01E48:  MOVF   FEF,W
01E4A:  SUBLW  04
01E4C:  BNZ   1E52
01E4E:  MOVLW  00
01E50:  BRA    1E98
01E52:  MOVF   x30,W
01E54:  MULLW  0D
01E56:  MOVF   FF3,W
01E58:  CLRF   x56
01E5A:  MOVWF  x55
01E5C:  MOVLW  01
01E5E:  ADDWF  x55,W
01E60:  MOVWF  01
01E62:  MOVLW  00
01E64:  ADDWFC x56,W
01E66:  MOVWF  03
01E68:  MOVF   01,W
01E6A:  ADDLW  81
01E6C:  MOVWF  01
01E6E:  MOVLW  01
01E70:  ADDWFC 03,F
01E72:  MOVFF  01,655
01E76:  MOVFF  03,656
01E7A:  MOVFF  03,FEA
01E7E:  MOVFF  01,FE9
01E82:  MOVFF  FEC,658
01E86:  MOVF   FED,F
01E88:  MOVFF  FEF,657
01E8C:  MOVFF  657,FE9
01E90:  MOVFF  658,FEA
01E94:  MOVLW  01
01E96:  ADDWF  FEF,W
01E98:  MOVWF  x59
01E9A:  MOVFF  650,FEA
01E9E:  MOVFF  64F,FE9
01EA2:  MOVWF  FEF
01EA4:  MOVF   x30,W
01EA6:  MULLW  0D
01EA8:  MOVF   FF3,W
01EAA:  CLRF   x4C
01EAC:  MOVWF  x4B
01EAE:  MOVLW  01
01EB0:  ADDWF  x4B,W
01EB2:  MOVWF  01
01EB4:  MOVLW  00
01EB6:  ADDWFC x4C,W
01EB8:  MOVWF  03
01EBA:  MOVF   01,W
01EBC:  ADDLW  81
01EBE:  MOVWF  01
01EC0:  MOVLW  01
01EC2:  ADDWFC 03,F
01EC4:  MOVFF  01,64B
01EC8:  MOVFF  03,64C
01ECC:  MOVFF  03,FEA
01ED0:  MOVFF  01,FE9
01ED4:  MOVFF  FEC,64E
01ED8:  MOVF   FED,F
01EDA:  MOVFF  FEF,64D
01EDE:  MOVFF  64D,FE9
01EE2:  MOVFF  64E,FEA
01EE6:  MOVFF  FEF,64F
01EEA:  MOVF   x30,W
01EEC:  MULLW  0D
01EEE:  MOVF   FF3,W
01EF0:  CLRF   x51
01EF2:  MOVWF  x50
01EF4:  MOVLW  01
01EF6:  ADDWF  x50,W
01EF8:  MOVWF  01
01EFA:  MOVLW  00
01EFC:  ADDWFC x51,W
01EFE:  MOVWF  03
01F00:  MOVF   01,W
01F02:  ADDLW  81
01F04:  MOVWF  01
01F06:  MOVLW  01
01F08:  ADDWFC 03,F
01F0A:  MOVFF  01,650
01F0E:  MOVFF  03,651
01F12:  MOVFF  03,FEA
01F16:  MOVFF  01,FE9
01F1A:  MOVFF  FEC,653
01F1E:  MOVF   FED,F
01F20:  MOVFF  FEF,652
01F24:  MOVLW  01
01F26:  ADDWF  x52,W
01F28:  MOVWF  FE9
01F2A:  MOVLW  00
01F2C:  ADDWFC x53,W
01F2E:  MOVWF  FEA
01F30:  MOVF   FEF,W
01F32:  SUBWF  x4F,W
01F34:  BNZ   2026
01F36:  MOVF   x30,W
01F38:  MULLW  0D
01F3A:  MOVF   FF3,W
01F3C:  CLRF   x4C
01F3E:  MOVWF  x4B
01F40:  MOVLW  01
01F42:  ADDWF  x4B,W
01F44:  MOVWF  01
01F46:  MOVLW  00
01F48:  ADDWFC x4C,W
01F4A:  MOVWF  03
01F4C:  MOVF   01,W
01F4E:  ADDLW  81
01F50:  MOVWF  01
01F52:  MOVLW  01
01F54:  ADDWFC 03,F
01F56:  MOVFF  01,64B
01F5A:  MOVFF  03,64C
01F5E:  MOVFF  03,FEA
01F62:  MOVFF  01,FE9
01F66:  MOVFF  FEC,64E
01F6A:  MOVF   FED,F
01F6C:  MOVFF  FEF,64D
01F70:  MOVLW  01
01F72:  ADDWF  x4D,W
01F74:  MOVWF  01
01F76:  MOVLW  00
01F78:  ADDWFC x4E,W
01F7A:  MOVWF  03
01F7C:  MOVFF  01,64F
01F80:  MOVWF  x50
01F82:  MOVF   x30,W
01F84:  MULLW  0D
01F86:  MOVF   FF3,W
01F88:  CLRF   x52
01F8A:  MOVWF  x51
01F8C:  MOVLW  01
01F8E:  ADDWF  x51,W
01F90:  MOVWF  01
01F92:  MOVLW  00
01F94:  ADDWFC x52,W
01F96:  MOVWF  03
01F98:  MOVF   01,W
01F9A:  ADDLW  81
01F9C:  MOVWF  01
01F9E:  MOVLW  01
01FA0:  ADDWFC 03,F
01FA2:  MOVFF  01,651
01FA6:  MOVFF  03,652
01FAA:  MOVFF  03,FEA
01FAE:  MOVFF  01,FE9
01FB2:  MOVFF  FEC,654
01FB6:  MOVF   FED,F
01FB8:  MOVFF  FEF,653
01FBC:  MOVLW  01
01FBE:  ADDWF  x53,W
01FC0:  MOVWF  FE9
01FC2:  MOVLW  00
01FC4:  ADDWFC x54,W
01FC6:  MOVWF  FEA
01FC8:  MOVF   FEF,W
01FCA:  SUBLW  04
01FCC:  BNZ   1FD2
01FCE:  MOVLW  00
01FD0:  BRA    201C
01FD2:  MOVF   x30,W
01FD4:  MULLW  0D
01FD6:  MOVF   FF3,W
01FD8:  CLRF   x56
01FDA:  MOVWF  x55
01FDC:  MOVLW  01
01FDE:  ADDWF  x55,W
01FE0:  MOVWF  01
01FE2:  MOVLW  00
01FE4:  ADDWFC x56,W
01FE6:  MOVWF  03
01FE8:  MOVF   01,W
01FEA:  ADDLW  81
01FEC:  MOVWF  01
01FEE:  MOVLW  01
01FF0:  ADDWFC 03,F
01FF2:  MOVFF  01,655
01FF6:  MOVFF  03,656
01FFA:  MOVFF  03,FEA
01FFE:  MOVFF  01,FE9
02002:  MOVFF  FEC,658
02006:  MOVF   FED,F
02008:  MOVFF  FEF,657
0200C:  MOVLW  01
0200E:  ADDWF  x57,W
02010:  MOVWF  FE9
02012:  MOVLW  00
02014:  ADDWFC x58,W
02016:  MOVWF  FEA
02018:  MOVLW  01
0201A:  ADDWF  FEF,W
0201C:  MOVFF  650,FEA
02020:  MOVFF  64F,FE9
02024:  MOVWF  FEF
....................    tobuff(smData[ch].cosQ, cosCnts);
02026:  MOVF   x30,W
02028:  MULLW  0D
0202A:  MOVF   FF3,W
0202C:  CLRF   x4C
0202E:  MOVWF  x4B
02030:  MOVLW  03
02032:  ADDWF  x4B,W
02034:  MOVWF  01
02036:  MOVLW  00
02038:  ADDWFC x4C,W
0203A:  MOVWF  03
0203C:  MOVF   01,W
0203E:  ADDLW  81
02040:  MOVWF  01
02042:  MOVLW  01
02044:  ADDWFC 03,F
02046:  MOVFF  01,64B
0204A:  MOVFF  03,64C
0204E:  MOVFF  03,FEA
02052:  MOVFF  01,FE9
02056:  MOVFF  FEC,64E
0205A:  MOVF   FED,F
0205C:  MOVFF  FEF,64D
02060:  MOVF   x30,W
02062:  MULLW  0D
02064:  MOVF   FF3,W
02066:  CLRF   x50
02068:  MOVWF  x4F
0206A:  MOVLW  03
0206C:  ADDWF  x4F,W
0206E:  MOVWF  01
02070:  MOVLW  00
02072:  ADDWFC x50,W
02074:  MOVWF  03
02076:  MOVF   01,W
02078:  ADDLW  81
0207A:  MOVWF  01
0207C:  MOVLW  01
0207E:  ADDWFC 03,F
02080:  MOVFF  01,64F
02084:  MOVFF  03,650
02088:  MOVFF  03,FEA
0208C:  MOVFF  01,FE9
02090:  MOVFF  FEC,652
02094:  MOVF   FED,F
02096:  MOVFF  FEF,651
0209A:  MOVFF  651,FE9
0209E:  MOVFF  652,FEA
020A2:  MOVLW  02
020A4:  ADDWF  FEF,W
020A6:  ADDWF  x4D,W
020A8:  MOVWF  FE9
020AA:  MOVLW  00
020AC:  ADDWFC x4E,W
020AE:  MOVWF  FEA
020B0:  MOVFF  635,FEF
020B4:  MOVF   x30,W
020B6:  MULLW  0D
020B8:  MOVF   FF3,W
020BA:  CLRF   x4C
020BC:  MOVWF  x4B
020BE:  MOVLW  03
020C0:  ADDWF  x4B,W
020C2:  MOVWF  01
020C4:  MOVLW  00
020C6:  ADDWFC x4C,W
020C8:  MOVWF  03
020CA:  MOVF   01,W
020CC:  ADDLW  81
020CE:  MOVWF  01
020D0:  MOVLW  01
020D2:  ADDWFC 03,F
020D4:  MOVFF  01,64B
020D8:  MOVFF  03,64C
020DC:  MOVFF  03,FEA
020E0:  MOVFF  01,FE9
020E4:  MOVFF  FEC,03
020E8:  MOVF   FED,F
020EA:  MOVFF  FEF,01
020EE:  MOVFF  01,64F
020F2:  MOVFF  03,650
020F6:  MOVF   x30,W
020F8:  MULLW  0D
020FA:  MOVF   FF3,W
020FC:  CLRF   x52
020FE:  MOVWF  x51
02100:  MOVLW  03
02102:  ADDWF  x51,W
02104:  MOVWF  01
02106:  MOVLW  00
02108:  ADDWFC x52,W
0210A:  MOVWF  03
0210C:  MOVF   01,W
0210E:  ADDLW  81
02110:  MOVWF  01
02112:  MOVLW  01
02114:  ADDWFC 03,F
02116:  MOVFF  01,651
0211A:  MOVFF  03,652
0211E:  MOVFF  03,FEA
02122:  MOVFF  01,FE9
02126:  MOVFF  FEC,654
0212A:  MOVF   FED,F
0212C:  MOVFF  FEF,653
02130:  MOVFF  653,FE9
02134:  MOVFF  654,FEA
02138:  MOVF   FEF,W
0213A:  SUBLW  04
0213C:  BNZ   2142
0213E:  MOVLW  00
02140:  BRA    2188
02142:  MOVF   x30,W
02144:  MULLW  0D
02146:  MOVF   FF3,W
02148:  CLRF   x56
0214A:  MOVWF  x55
0214C:  MOVLW  03
0214E:  ADDWF  x55,W
02150:  MOVWF  01
02152:  MOVLW  00
02154:  ADDWFC x56,W
02156:  MOVWF  03
02158:  MOVF   01,W
0215A:  ADDLW  81
0215C:  MOVWF  01
0215E:  MOVLW  01
02160:  ADDWFC 03,F
02162:  MOVFF  01,655
02166:  MOVFF  03,656
0216A:  MOVFF  03,FEA
0216E:  MOVFF  01,FE9
02172:  MOVFF  FEC,658
02176:  MOVF   FED,F
02178:  MOVFF  FEF,657
0217C:  MOVFF  657,FE9
02180:  MOVFF  658,FEA
02184:  MOVLW  01
02186:  ADDWF  FEF,W
02188:  MOVWF  x59
0218A:  MOVFF  650,FEA
0218E:  MOVFF  64F,FE9
02192:  MOVWF  FEF
02194:  MOVF   x30,W
02196:  MULLW  0D
02198:  MOVF   FF3,W
0219A:  CLRF   x4C
0219C:  MOVWF  x4B
0219E:  MOVLW  03
021A0:  ADDWF  x4B,W
021A2:  MOVWF  01
021A4:  MOVLW  00
021A6:  ADDWFC x4C,W
021A8:  MOVWF  03
021AA:  MOVF   01,W
021AC:  ADDLW  81
021AE:  MOVWF  01
021B0:  MOVLW  01
021B2:  ADDWFC 03,F
021B4:  MOVFF  01,64B
021B8:  MOVFF  03,64C
021BC:  MOVFF  03,FEA
021C0:  MOVFF  01,FE9
021C4:  MOVFF  FEC,64E
021C8:  MOVF   FED,F
021CA:  MOVFF  FEF,64D
021CE:  MOVFF  64D,FE9
021D2:  MOVFF  64E,FEA
021D6:  MOVFF  FEF,64F
021DA:  MOVF   x30,W
021DC:  MULLW  0D
021DE:  MOVF   FF3,W
021E0:  CLRF   x51
021E2:  MOVWF  x50
021E4:  MOVLW  03
021E6:  ADDWF  x50,W
021E8:  MOVWF  01
021EA:  MOVLW  00
021EC:  ADDWFC x51,W
021EE:  MOVWF  03
021F0:  MOVF   01,W
021F2:  ADDLW  81
021F4:  MOVWF  01
021F6:  MOVLW  01
021F8:  ADDWFC 03,F
021FA:  MOVFF  01,650
021FE:  MOVFF  03,651
02202:  MOVFF  03,FEA
02206:  MOVFF  01,FE9
0220A:  MOVFF  FEC,653
0220E:  MOVF   FED,F
02210:  MOVFF  FEF,652
02214:  MOVLW  01
02216:  ADDWF  x52,W
02218:  MOVWF  FE9
0221A:  MOVLW  00
0221C:  ADDWFC x53,W
0221E:  MOVWF  FEA
02220:  MOVF   FEF,W
02222:  SUBWF  x4F,W
02224:  BNZ   2316
02226:  MOVF   x30,W
02228:  MULLW  0D
0222A:  MOVF   FF3,W
0222C:  CLRF   x4C
0222E:  MOVWF  x4B
02230:  MOVLW  03
02232:  ADDWF  x4B,W
02234:  MOVWF  01
02236:  MOVLW  00
02238:  ADDWFC x4C,W
0223A:  MOVWF  03
0223C:  MOVF   01,W
0223E:  ADDLW  81
02240:  MOVWF  01
02242:  MOVLW  01
02244:  ADDWFC 03,F
02246:  MOVFF  01,64B
0224A:  MOVFF  03,64C
0224E:  MOVFF  03,FEA
02252:  MOVFF  01,FE9
02256:  MOVFF  FEC,64E
0225A:  MOVF   FED,F
0225C:  MOVFF  FEF,64D
02260:  MOVLW  01
02262:  ADDWF  x4D,W
02264:  MOVWF  01
02266:  MOVLW  00
02268:  ADDWFC x4E,W
0226A:  MOVWF  03
0226C:  MOVFF  01,64F
02270:  MOVWF  x50
02272:  MOVF   x30,W
02274:  MULLW  0D
02276:  MOVF   FF3,W
02278:  CLRF   x52
0227A:  MOVWF  x51
0227C:  MOVLW  03
0227E:  ADDWF  x51,W
02280:  MOVWF  01
02282:  MOVLW  00
02284:  ADDWFC x52,W
02286:  MOVWF  03
02288:  MOVF   01,W
0228A:  ADDLW  81
0228C:  MOVWF  01
0228E:  MOVLW  01
02290:  ADDWFC 03,F
02292:  MOVFF  01,651
02296:  MOVFF  03,652
0229A:  MOVFF  03,FEA
0229E:  MOVFF  01,FE9
022A2:  MOVFF  FEC,654
022A6:  MOVF   FED,F
022A8:  MOVFF  FEF,653
022AC:  MOVLW  01
022AE:  ADDWF  x53,W
022B0:  MOVWF  FE9
022B2:  MOVLW  00
022B4:  ADDWFC x54,W
022B6:  MOVWF  FEA
022B8:  MOVF   FEF,W
022BA:  SUBLW  04
022BC:  BNZ   22C2
022BE:  MOVLW  00
022C0:  BRA    230C
022C2:  MOVF   x30,W
022C4:  MULLW  0D
022C6:  MOVF   FF3,W
022C8:  CLRF   x56
022CA:  MOVWF  x55
022CC:  MOVLW  03
022CE:  ADDWF  x55,W
022D0:  MOVWF  01
022D2:  MOVLW  00
022D4:  ADDWFC x56,W
022D6:  MOVWF  03
022D8:  MOVF   01,W
022DA:  ADDLW  81
022DC:  MOVWF  01
022DE:  MOVLW  01
022E0:  ADDWFC 03,F
022E2:  MOVFF  01,655
022E6:  MOVFF  03,656
022EA:  MOVFF  03,FEA
022EE:  MOVFF  01,FE9
022F2:  MOVFF  FEC,658
022F6:  MOVF   FED,F
022F8:  MOVFF  FEF,657
022FC:  MOVLW  01
022FE:  ADDWF  x57,W
02300:  MOVWF  FE9
02302:  MOVLW  00
02304:  ADDWFC x58,W
02306:  MOVWF  FEA
02308:  MOVLW  01
0230A:  ADDWF  FEF,W
0230C:  MOVFF  650,FEA
02310:  MOVFF  64F,FE9
02314:  MOVWF  FEF
....................    
....................    // copy queue contents out to buffer for qsorting
....................    for (int8 i=0; i<BUFFER_SIZE; i++){
02316:  CLRF   x49
02318:  MOVF   x49,W
0231A:  SUBLW  04
0231C:  BNC   23FE
....................       iqmBufSin[i] = smData[ch].sinQ->buff[i];
0231E:  MOVF   x49,W
02320:  MULLW  04
02322:  MOVF   FF3,W
02324:  CLRF   03
02326:  ADDLW  39
02328:  MOVWF  01
0232A:  MOVLW  06
0232C:  ADDWFC 03,F
0232E:  MOVFF  01,64B
02332:  MOVFF  03,64C
02336:  MOVF   x30,W
02338:  MULLW  0D
0233A:  MOVF   FF3,W
0233C:  CLRF   x4E
0233E:  MOVWF  x4D
02340:  MOVLW  01
02342:  ADDWF  x4D,W
02344:  MOVWF  01
02346:  MOVLW  00
02348:  ADDWFC x4E,W
0234A:  MOVWF  03
0234C:  MOVF   01,W
0234E:  ADDLW  81
02350:  MOVWF  01
02352:  MOVLW  01
02354:  ADDWFC 03,F
02356:  MOVFF  03,FEA
0235A:  MOVFF  01,FE9
0235E:  MOVFF  FEC,650
02362:  MOVF   FED,F
02364:  MOVFF  FEF,64F
02368:  MOVLW  02
0236A:  ADDWF  x49,W
0236C:  ADDWF  x4F,W
0236E:  MOVWF  FE9
02370:  MOVLW  00
02372:  ADDWFC x50,W
02374:  MOVWF  FEA
02376:  MOVFF  FEF,00
0237A:  MOVFF  64C,FEA
0237E:  MOVFF  64B,FE9
02382:  MOVFF  00,FEF
02386:  CLRF   FEC
02388:  CLRF   FEC
0238A:  CLRF   FEC
....................       iqmBufCos[i] = smData[ch].cosQ->buff[i];
0238C:  MOVF   x49,W
0238E:  MULLW  04
02390:  MOVF   FF3,W
02392:  CLRF   03
02394:  ADDLW  3D
02396:  MOVWF  01
02398:  MOVLW  06
0239A:  ADDWFC 03,F
0239C:  MOVFF  01,64B
023A0:  MOVFF  03,64C
023A4:  MOVF   x30,W
023A6:  MULLW  0D
023A8:  MOVF   FF3,W
023AA:  CLRF   x4E
023AC:  MOVWF  x4D
023AE:  MOVLW  03
023B0:  ADDWF  x4D,W
023B2:  MOVWF  01
023B4:  MOVLW  00
023B6:  ADDWFC x4E,W
023B8:  MOVWF  03
023BA:  MOVF   01,W
023BC:  ADDLW  81
023BE:  MOVWF  01
023C0:  MOVLW  01
023C2:  ADDWFC 03,F
023C4:  MOVFF  03,FEA
023C8:  MOVFF  01,FE9
023CC:  MOVFF  FEC,650
023D0:  MOVF   FED,F
023D2:  MOVFF  FEF,64F
023D6:  MOVLW  02
023D8:  ADDWF  x49,W
023DA:  ADDWF  x4F,W
023DC:  MOVWF  FE9
023DE:  MOVLW  00
023E0:  ADDWFC x50,W
023E2:  MOVWF  FEA
023E4:  MOVFF  FEF,00
023E8:  MOVFF  64C,FEA
023EC:  MOVFF  64B,FE9
023F0:  MOVFF  00,FEF
023F4:  CLRF   FEC
023F6:  CLRF   FEC
023F8:  CLRF   FEC
023FA:  INCF   x49,F
023FC:  BRA    2318
....................    }
....................    
....................    qsort(iqmBufSin, BUFFER_SIZE, sizeof(*iqmBufSin), compar);
023FE:  MOVLW  1A
02400:  MOVWF  03
02402:  MOVLW  DE
02404:  MOVWF  x4D
02406:  MOVFF  03,64E
0240A:  MOVFF  63A,650
0240E:  MOVFF  639,64F
02412:  MOVLW  05
02414:  MOVWF  x51
02416:  MOVLW  01
02418:  MOVWF  x52
0241A:  MOVFF  03,654
0241E:  MOVFF  64D,653
02422:  MOVLB  0
02424:  CALL   1B12
....................    qsort(iqmBufCos, BUFFER_SIZE, sizeof(*iqmBufCos), compar);
02428:  MOVLW  1A
0242A:  MOVWF  03
0242C:  MOVLW  DE
0242E:  MOVLB  6
02430:  MOVWF  x4D
02432:  MOVFF  03,64E
02436:  MOVFF  63E,650
0243A:  MOVFF  63D,64F
0243E:  MOVLW  05
02440:  MOVWF  x51
02442:  MOVLW  01
02444:  MOVWF  x52
02446:  MOVFF  03,654
0244A:  MOVFF  64D,653
0244E:  MOVLB  0
02450:  CALL   1B12
....................    
....................    for (int8 i=1; i<BUFFER_SIZE-1; i++){
02454:  MOVLW  01
02456:  MOVLB  6
02458:  MOVWF  x4A
0245A:  MOVF   x4A,W
0245C:  SUBLW  03
0245E:  BNC   24C8
....................       sumSin+=iqmBufSin[i];
02460:  MOVF   x4A,W
02462:  MULLW  04
02464:  MOVF   FF3,W
02466:  CLRF   03
02468:  ADDLW  39
0246A:  MOVWF  FE9
0246C:  MOVLW  06
0246E:  ADDWFC 03,W
02470:  MOVWF  FEA
02472:  MOVFF  FEF,00
02476:  MOVFF  FEC,01
0247A:  MOVFF  FEC,02
0247E:  MOVFF  FEC,03
02482:  MOVF   00,W
02484:  ADDWF  x41,F
02486:  MOVF   01,W
02488:  ADDWFC x42,F
0248A:  MOVF   02,W
0248C:  ADDWFC x43,F
0248E:  MOVF   03,W
02490:  ADDWFC x44,F
....................       sumCos+=iqmBufCos[i];
02492:  MOVF   x4A,W
02494:  MULLW  04
02496:  MOVF   FF3,W
02498:  CLRF   03
0249A:  ADDLW  3D
0249C:  MOVWF  FE9
0249E:  MOVLW  06
024A0:  ADDWFC 03,W
024A2:  MOVWF  FEA
024A4:  MOVFF  FEF,00
024A8:  MOVFF  FEC,01
024AC:  MOVFF  FEC,02
024B0:  MOVFF  FEC,03
024B4:  MOVF   00,W
024B6:  ADDWF  x45,F
024B8:  MOVF   01,W
024BA:  ADDWFC x46,F
024BC:  MOVF   02,W
024BE:  ADDWFC x47,F
024C0:  MOVF   03,W
024C2:  ADDWFC x48,F
024C4:  INCF   x4A,F
024C6:  BRA    245A
....................    }
....................    smData[ch].avgSin = sumSin / (BUFFER_SIZE-2);
024C8:  MOVF   x30,W
024CA:  MULLW  0D
024CC:  MOVF   FF3,W
024CE:  CLRF   x4C
024D0:  MOVWF  x4B
024D2:  MOVLW  05
024D4:  ADDWF  x4B,W
024D6:  MOVWF  01
024D8:  MOVLW  00
024DA:  ADDWFC x4C,W
024DC:  MOVWF  03
024DE:  MOVF   01,W
024E0:  ADDLW  81
024E2:  MOVWF  FE9
024E4:  MOVLW  01
024E6:  ADDWFC 03,W
024E8:  MOVWF  FEA
024EA:  MOVFF  FEA,64E
024EE:  MOVFF  FE9,64D
024F2:  BCF    FD8.1
024F4:  MOVFF  644,652
024F8:  MOVFF  643,651
024FC:  MOVFF  642,650
02500:  MOVFF  641,64F
02504:  CLRF   x56
02506:  CLRF   x55
02508:  CLRF   x54
0250A:  MOVLW  03
0250C:  MOVWF  x53
0250E:  MOVLB  0
02510:  CALL   1C3A
02514:  MOVFF  64E,FEA
02518:  MOVFF  64D,FE9
0251C:  MOVFF  00,FEF
02520:  MOVFF  01,FEC
02524:  MOVFF  02,FEC
02528:  MOVFF  03,FEC
....................    smData[ch].avgCos = sumCos / (BUFFER_SIZE-2);
0252C:  MOVLB  6
0252E:  MOVF   x30,W
02530:  MULLW  0D
02532:  MOVF   FF3,W
02534:  CLRF   x4C
02536:  MOVWF  x4B
02538:  MOVLW  09
0253A:  ADDWF  x4B,W
0253C:  MOVWF  01
0253E:  MOVLW  00
02540:  ADDWFC x4C,W
02542:  MOVWF  03
02544:  MOVF   01,W
02546:  ADDLW  81
02548:  MOVWF  FE9
0254A:  MOVLW  01
0254C:  ADDWFC 03,W
0254E:  MOVWF  FEA
02550:  MOVFF  FEA,64E
02554:  MOVFF  FE9,64D
02558:  BCF    FD8.1
0255A:  MOVFF  648,652
0255E:  MOVFF  647,651
02562:  MOVFF  646,650
02566:  MOVFF  645,64F
0256A:  CLRF   x56
0256C:  CLRF   x55
0256E:  CLRF   x54
02570:  MOVLW  03
02572:  MOVWF  x53
02574:  MOVLB  0
02576:  CALL   1C3A
0257A:  MOVFF  64E,FEA
0257E:  MOVFF  64D,FE9
02582:  MOVFF  00,FEF
02586:  MOVFF  01,FEC
0258A:  MOVFF  02,FEC
0258E:  MOVFF  03,FEC
02592:  GOTO   4DFA (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SENSOR MONITOR task - gets magnetoresistive sensor counts                 */
.................... /* gets two values each time the task is run                                 */
.................... /*****************************************************************************/
.................... void sensor_monitor_task()
*
04D22:  MOVLB  6
04D24:  CLRF   x2B
04D26:  CLRF   x2A
04D28:  CLRF   x29
04D2A:  CLRF   x28
04D2C:  CLRF   x2F
04D2E:  CLRF   x2E
04D30:  CLRF   x2D
04D32:  CLRF   x2C
.................... {
....................    static int8 ch = 0;
....................    signed int32 sinNew = 0;
....................    signed int32 cosNew = 0;
....................    
....................    if ( (!smData[ch].adcBusy) && smData[ch].dataReady ){
04D34:  MOVLB  1
04D36:  MOVF   x9D,W
04D38:  MULLW  0D
04D3A:  MOVF   FF3,W
04D3C:  MOVLB  6
04D3E:  CLRF   x31
04D40:  MOVWF  x30
04D42:  MOVLW  81
04D44:  ADDWF  x30,W
04D46:  MOVWF  FE9
04D48:  MOVLW  01
04D4A:  ADDWFC x31,W
04D4C:  MOVWF  FEA
04D4E:  BTFSC  FEF.1
04D50:  BRA    4E56
04D52:  MOVLB  1
04D54:  MOVF   x9D,W
04D56:  MULLW  0D
04D58:  MOVF   FF3,W
04D5A:  MOVLB  6
04D5C:  CLRF   x33
04D5E:  MOVWF  x32
04D60:  MOVLW  81
04D62:  ADDWF  x32,W
04D64:  MOVWF  FE9
04D66:  MOVLW  01
04D68:  ADDWFC x33,W
04D6A:  MOVWF  FEA
04D6C:  BTFSS  FEF.0
04D6E:  BRA    4E56
....................       smData[ch].adcBusy = true;
04D70:  MOVLB  1
04D72:  MOVF   x9D,W
04D74:  MULLW  0D
04D76:  MOVF   FF3,W
04D78:  MOVLB  6
04D7A:  CLRF   x31
04D7C:  MOVWF  x30
04D7E:  MOVLW  81
04D80:  ADDWF  x30,W
04D82:  MOVWF  FE9
04D84:  MOVLW  01
04D86:  ADDWFC x31,W
04D88:  MOVWF  FEA
04D8A:  BSF    FEF.1
....................       
....................       sinNew = ads_read_data(ch*2);
04D8C:  BCF    FD8.0
04D8E:  MOVLB  1
04D90:  RLCF   x9D,W
04D92:  MOVLB  6
04D94:  MOVWF  x30
04D96:  MOVWF  x3A
04D98:  MOVLB  0
04D9A:  CALL   081A
04D9E:  MOVFF  03,62B
04DA2:  MOVFF  02,62A
04DA6:  MOVFF  01,629
04DAA:  MOVFF  00,628
....................       cosNew = ads_read_data(ch*2+1);      
04DAE:  BCF    FD8.0
04DB0:  MOVLB  1
04DB2:  RLCF   x9D,W
04DB4:  ADDLW  01
04DB6:  MOVLB  6
04DB8:  MOVWF  x30
04DBA:  MOVWF  x3A
04DBC:  MOVLB  0
04DBE:  CALL   081A
04DC2:  MOVFF  03,62F
04DC6:  MOVFF  02,62E
04DCA:  MOVFF  01,62D
04DCE:  MOVFF  00,62C
....................       
....................       iqm_ring_buffer(ch, sinNew, cosNew);
04DD2:  MOVFF  19D,630
04DD6:  MOVFF  62B,634
04DDA:  MOVFF  62A,633
04DDE:  MOVFF  629,632
04DE2:  MOVFF  628,631
04DE6:  MOVFF  62F,638
04DEA:  MOVFF  62E,637
04DEE:  MOVFF  62D,636
04DF2:  MOVFF  62C,635
04DF6:  GOTO   1D24
....................       
....................       sensor_process_data(ch);
04DFA:  MOVFF  19D,630
04DFE:  GOTO   3FD0
....................       ch = !ch;
04E02:  MOVLB  1
04E04:  MOVF   x9D,F
04E06:  BZ    4E0C
04E08:  MOVLW  00
04E0A:  BRA    4E0E
04E0C:  MOVLW  01
04E0E:  MOVWF  x9D
....................       
....................       smData[!ch].dataReady = false;
04E10:  MOVF   x9D,F
04E12:  BZ    4E18
04E14:  MOVLW  00
04E16:  BRA    4E1A
04E18:  MOVLW  01
04E1A:  MULLW  0D
04E1C:  MOVF   FF3,W
04E1E:  MOVLB  6
04E20:  CLRF   x31
04E22:  MOVWF  x30
04E24:  MOVLW  81
04E26:  ADDWF  x30,W
04E28:  MOVWF  FE9
04E2A:  MOVLW  01
04E2C:  ADDWFC x31,W
04E2E:  MOVWF  FEA
04E30:  BCF    FEF.0
....................       smData[!ch].adcBusy = false;
04E32:  MOVLB  1
04E34:  MOVF   x9D,F
04E36:  BZ    4E3C
04E38:  MOVLW  00
04E3A:  BRA    4E3E
04E3C:  MOVLW  01
04E3E:  MULLW  0D
04E40:  MOVF   FF3,W
04E42:  MOVLB  6
04E44:  CLRF   x31
04E46:  MOVWF  x30
04E48:  MOVLW  81
04E4A:  ADDWF  x30,W
04E4C:  MOVWF  FE9
04E4E:  MOVLW  01
04E50:  ADDWFC x31,W
04E52:  MOVWF  FEA
04E54:  BCF    FEF.1
....................    }
04E56:  MOVLB  0
04E58:  GOTO   AE9C (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* INITIALIZE ADC's                                                          */
.................... /*****************************************************************************/
.................... void setup_external_ADCs()
*
00868:  MOVLB  6
0086A:  CLRF   x28
0086C:  CLRF   x29
0086E:  CLRF   x2A
00870:  CLRF   x2B
.................... {
....................    unsigned int8 rc0=0;
....................    unsigned int8 rc1=0;
....................    unsigned int8 rc2=0;
....................    unsigned int8 rc3=0;
....................    
....................    for (int ch = 0; ch < 4; ch++)
00872:  CLRF   x2C
00874:  MOVF   x2C,W
00876:  SUBLW  03
00878:  BNC   08B0
....................    {
....................       rc0=reg0config;
0087A:  MOVLW  30
0087C:  MOVWF  x28
....................       rc1=reg1config;
0087E:  MOVLW  10
00880:  MOVWF  x29
....................       rc2=reg2config;
00882:  MOVLW  30
00884:  MOVWF  x2A
....................       rc3=reg3config;
00886:  CLRF   x2B
....................       
....................       ADS1220init(ch, rc0, rc1, rc2, rc3);
00888:  MOVFF  62C,62F
0088C:  MOVFF  628,630
00890:  MOVFF  629,631
00894:  MOVFF  62A,632
00898:  MOVFF  62B,633
0089C:  MOVLB  0
0089E:  BRA    074C
....................       delay_ms(1);
008A0:  MOVLW  01
008A2:  MOVLB  6
008A4:  MOVWF  x30
008A6:  MOVLB  0
008A8:  RCALL  0438
008AA:  MOVLB  6
008AC:  INCF   x2C,F
008AE:  BRA    0874
....................    }
....................    
....................    for (int i = 0; i < BUFFER_SIZE; i++){
008B0:  CLRF   x2D
008B2:  MOVF   x2D,W
008B4:  SUBLW  04
008B6:  BTFSS  FD8.0
008B8:  BRA    0F00
....................       ads_start_conv_all();
008BA:  MOVLB  0
008BC:  BRA    07EA
....................       delay_ms(300);
008BE:  MOVLW  02
008C0:  MOVLB  6
008C2:  MOVWF  x2F
008C4:  MOVLW  96
008C6:  MOVWF  x30
008C8:  MOVLB  0
008CA:  RCALL  0438
008CC:  MOVLB  6
008CE:  DECFSZ x2F,F
008D0:  BRA    08C4
....................       for (int b = 0; b < 2; b++){
008D2:  CLRF   x2E
008D4:  MOVF   x2E,W
008D6:  SUBLW  01
008D8:  BTFSS  FD8.0
008DA:  BRA    0EFC
....................          tobuff(smData[b].sinQ, ads_read_data(b*2+1));
008DC:  MOVF   x2E,W
008DE:  MULLW  0D
008E0:  MOVF   FF3,W
008E2:  CLRF   x30
008E4:  MOVWF  x2F
008E6:  MOVLW  01
008E8:  ADDWF  x2F,W
008EA:  MOVWF  01
008EC:  MOVLW  00
008EE:  ADDWFC x30,W
008F0:  MOVWF  03
008F2:  MOVF   01,W
008F4:  ADDLW  81
008F6:  MOVWF  01
008F8:  MOVLW  01
008FA:  ADDWFC 03,F
008FC:  MOVFF  01,62F
00900:  MOVFF  03,630
00904:  MOVFF  03,FEA
00908:  MOVFF  01,FE9
0090C:  MOVFF  FEC,632
00910:  MOVF   FED,F
00912:  MOVFF  FEF,631
00916:  MOVF   x2E,W
00918:  MULLW  0D
0091A:  MOVF   FF3,W
0091C:  CLRF   x34
0091E:  MOVWF  x33
00920:  MOVLW  01
00922:  ADDWF  x33,W
00924:  MOVWF  01
00926:  MOVLW  00
00928:  ADDWFC x34,W
0092A:  MOVWF  03
0092C:  MOVF   01,W
0092E:  ADDLW  81
00930:  MOVWF  01
00932:  MOVLW  01
00934:  ADDWFC 03,F
00936:  MOVFF  01,633
0093A:  MOVFF  03,634
0093E:  MOVFF  03,FEA
00942:  MOVFF  01,FE9
00946:  MOVFF  FEC,636
0094A:  MOVF   FED,F
0094C:  MOVFF  FEF,635
00950:  MOVFF  635,FE9
00954:  MOVFF  636,FEA
00958:  MOVLW  02
0095A:  ADDWF  FEF,W
0095C:  ADDWF  x31,W
0095E:  MOVWF  01
00960:  MOVLW  00
00962:  ADDWFC x32,W
00964:  MOVWF  03
00966:  MOVFF  01,637
0096A:  MOVWF  x38
0096C:  BCF    FD8.0
0096E:  RLCF   x2E,W
00970:  ADDLW  01
00972:  MOVWF  x39
00974:  MOVWF  x3A
00976:  MOVLB  0
00978:  RCALL  081A
0097A:  MOVFF  638,FEA
0097E:  MOVFF  637,FE9
00982:  MOVFF  00,FEF
00986:  MOVLB  6
00988:  MOVF   x2E,W
0098A:  MULLW  0D
0098C:  MOVF   FF3,W
0098E:  CLRF   x30
00990:  MOVWF  x2F
00992:  MOVLW  01
00994:  ADDWF  x2F,W
00996:  MOVWF  01
00998:  MOVLW  00
0099A:  ADDWFC x30,W
0099C:  MOVWF  03
0099E:  MOVF   01,W
009A0:  ADDLW  81
009A2:  MOVWF  01
009A4:  MOVLW  01
009A6:  ADDWFC 03,F
009A8:  MOVFF  01,62F
009AC:  MOVFF  03,630
009B0:  MOVFF  03,FEA
009B4:  MOVFF  01,FE9
009B8:  MOVFF  FEC,03
009BC:  MOVF   FED,F
009BE:  MOVFF  FEF,01
009C2:  MOVFF  01,633
009C6:  MOVFF  03,634
009CA:  MOVF   x2E,W
009CC:  MULLW  0D
009CE:  MOVF   FF3,W
009D0:  CLRF   x36
009D2:  MOVWF  x35
009D4:  MOVLW  01
009D6:  ADDWF  x35,W
009D8:  MOVWF  01
009DA:  MOVLW  00
009DC:  ADDWFC x36,W
009DE:  MOVWF  03
009E0:  MOVF   01,W
009E2:  ADDLW  81
009E4:  MOVWF  01
009E6:  MOVLW  01
009E8:  ADDWFC 03,F
009EA:  MOVFF  01,635
009EE:  MOVFF  03,636
009F2:  MOVFF  03,FEA
009F6:  MOVFF  01,FE9
009FA:  MOVFF  FEC,638
009FE:  MOVF   FED,F
00A00:  MOVFF  FEF,637
00A04:  MOVFF  637,FE9
00A08:  MOVFF  638,FEA
00A0C:  MOVF   FEF,W
00A0E:  SUBLW  04
00A10:  BNZ   0A16
00A12:  MOVLW  00
00A14:  BRA    0A5C
00A16:  MOVF   x2E,W
00A18:  MULLW  0D
00A1A:  MOVF   FF3,W
00A1C:  CLRF   x3A
00A1E:  MOVWF  x39
00A20:  MOVLW  01
00A22:  ADDWF  x39,W
00A24:  MOVWF  01
00A26:  MOVLW  00
00A28:  ADDWFC x3A,W
00A2A:  MOVWF  03
00A2C:  MOVF   01,W
00A2E:  ADDLW  81
00A30:  MOVWF  01
00A32:  MOVLW  01
00A34:  ADDWFC 03,F
00A36:  MOVFF  01,639
00A3A:  MOVFF  03,63A
00A3E:  MOVFF  03,FEA
00A42:  MOVFF  01,FE9
00A46:  MOVFF  FEC,63C
00A4A:  MOVF   FED,F
00A4C:  MOVFF  FEF,63B
00A50:  MOVFF  63B,FE9
00A54:  MOVFF  63C,FEA
00A58:  MOVLW  01
00A5A:  ADDWF  FEF,W
00A5C:  MOVWF  x3D
00A5E:  MOVFF  634,FEA
00A62:  MOVFF  633,FE9
00A66:  MOVWF  FEF
00A68:  MOVF   x2E,W
00A6A:  MULLW  0D
00A6C:  MOVF   FF3,W
00A6E:  CLRF   x30
00A70:  MOVWF  x2F
00A72:  MOVLW  01
00A74:  ADDWF  x2F,W
00A76:  MOVWF  01
00A78:  MOVLW  00
00A7A:  ADDWFC x30,W
00A7C:  MOVWF  03
00A7E:  MOVF   01,W
00A80:  ADDLW  81
00A82:  MOVWF  01
00A84:  MOVLW  01
00A86:  ADDWFC 03,F
00A88:  MOVFF  01,62F
00A8C:  MOVFF  03,630
00A90:  MOVFF  03,FEA
00A94:  MOVFF  01,FE9
00A98:  MOVFF  FEC,632
00A9C:  MOVF   FED,F
00A9E:  MOVFF  FEF,631
00AA2:  MOVFF  631,FE9
00AA6:  MOVFF  632,FEA
00AAA:  MOVFF  FEF,633
00AAE:  MOVF   x2E,W
00AB0:  MULLW  0D
00AB2:  MOVF   FF3,W
00AB4:  CLRF   x35
00AB6:  MOVWF  x34
00AB8:  MOVLW  01
00ABA:  ADDWF  x34,W
00ABC:  MOVWF  01
00ABE:  MOVLW  00
00AC0:  ADDWFC x35,W
00AC2:  MOVWF  03
00AC4:  MOVF   01,W
00AC6:  ADDLW  81
00AC8:  MOVWF  01
00ACA:  MOVLW  01
00ACC:  ADDWFC 03,F
00ACE:  MOVFF  01,634
00AD2:  MOVFF  03,635
00AD6:  MOVFF  03,FEA
00ADA:  MOVFF  01,FE9
00ADE:  MOVFF  FEC,637
00AE2:  MOVF   FED,F
00AE4:  MOVFF  FEF,636
00AE8:  MOVLW  01
00AEA:  ADDWF  x36,W
00AEC:  MOVWF  FE9
00AEE:  MOVLW  00
00AF0:  ADDWFC x37,W
00AF2:  MOVWF  FEA
00AF4:  MOVF   FEF,W
00AF6:  SUBWF  x33,W
00AF8:  BNZ   0BEA
00AFA:  MOVF   x2E,W
00AFC:  MULLW  0D
00AFE:  MOVF   FF3,W
00B00:  CLRF   x30
00B02:  MOVWF  x2F
00B04:  MOVLW  01
00B06:  ADDWF  x2F,W
00B08:  MOVWF  01
00B0A:  MOVLW  00
00B0C:  ADDWFC x30,W
00B0E:  MOVWF  03
00B10:  MOVF   01,W
00B12:  ADDLW  81
00B14:  MOVWF  01
00B16:  MOVLW  01
00B18:  ADDWFC 03,F
00B1A:  MOVFF  01,62F
00B1E:  MOVFF  03,630
00B22:  MOVFF  03,FEA
00B26:  MOVFF  01,FE9
00B2A:  MOVFF  FEC,632
00B2E:  MOVF   FED,F
00B30:  MOVFF  FEF,631
00B34:  MOVLW  01
00B36:  ADDWF  x31,W
00B38:  MOVWF  01
00B3A:  MOVLW  00
00B3C:  ADDWFC x32,W
00B3E:  MOVWF  03
00B40:  MOVFF  01,633
00B44:  MOVWF  x34
00B46:  MOVF   x2E,W
00B48:  MULLW  0D
00B4A:  MOVF   FF3,W
00B4C:  CLRF   x36
00B4E:  MOVWF  x35
00B50:  MOVLW  01
00B52:  ADDWF  x35,W
00B54:  MOVWF  01
00B56:  MOVLW  00
00B58:  ADDWFC x36,W
00B5A:  MOVWF  03
00B5C:  MOVF   01,W
00B5E:  ADDLW  81
00B60:  MOVWF  01
00B62:  MOVLW  01
00B64:  ADDWFC 03,F
00B66:  MOVFF  01,635
00B6A:  MOVFF  03,636
00B6E:  MOVFF  03,FEA
00B72:  MOVFF  01,FE9
00B76:  MOVFF  FEC,638
00B7A:  MOVF   FED,F
00B7C:  MOVFF  FEF,637
00B80:  MOVLW  01
00B82:  ADDWF  x37,W
00B84:  MOVWF  FE9
00B86:  MOVLW  00
00B88:  ADDWFC x38,W
00B8A:  MOVWF  FEA
00B8C:  MOVF   FEF,W
00B8E:  SUBLW  04
00B90:  BNZ   0B96
00B92:  MOVLW  00
00B94:  BRA    0BE0
00B96:  MOVF   x2E,W
00B98:  MULLW  0D
00B9A:  MOVF   FF3,W
00B9C:  CLRF   x3A
00B9E:  MOVWF  x39
00BA0:  MOVLW  01
00BA2:  ADDWF  x39,W
00BA4:  MOVWF  01
00BA6:  MOVLW  00
00BA8:  ADDWFC x3A,W
00BAA:  MOVWF  03
00BAC:  MOVF   01,W
00BAE:  ADDLW  81
00BB0:  MOVWF  01
00BB2:  MOVLW  01
00BB4:  ADDWFC 03,F
00BB6:  MOVFF  01,639
00BBA:  MOVFF  03,63A
00BBE:  MOVFF  03,FEA
00BC2:  MOVFF  01,FE9
00BC6:  MOVFF  FEC,63C
00BCA:  MOVF   FED,F
00BCC:  MOVFF  FEF,63B
00BD0:  MOVLW  01
00BD2:  ADDWF  x3B,W
00BD4:  MOVWF  FE9
00BD6:  MOVLW  00
00BD8:  ADDWFC x3C,W
00BDA:  MOVWF  FEA
00BDC:  MOVLW  01
00BDE:  ADDWF  FEF,W
00BE0:  MOVFF  634,FEA
00BE4:  MOVFF  633,FE9
00BE8:  MOVWF  FEF
....................          tobuff(smData[b].cosQ, ads_read_data(b*2+1));      
00BEA:  MOVF   x2E,W
00BEC:  MULLW  0D
00BEE:  MOVF   FF3,W
00BF0:  CLRF   x30
00BF2:  MOVWF  x2F
00BF4:  MOVLW  03
00BF6:  ADDWF  x2F,W
00BF8:  MOVWF  01
00BFA:  MOVLW  00
00BFC:  ADDWFC x30,W
00BFE:  MOVWF  03
00C00:  MOVF   01,W
00C02:  ADDLW  81
00C04:  MOVWF  01
00C06:  MOVLW  01
00C08:  ADDWFC 03,F
00C0A:  MOVFF  01,62F
00C0E:  MOVFF  03,630
00C12:  MOVFF  03,FEA
00C16:  MOVFF  01,FE9
00C1A:  MOVFF  FEC,632
00C1E:  MOVF   FED,F
00C20:  MOVFF  FEF,631
00C24:  MOVF   x2E,W
00C26:  MULLW  0D
00C28:  MOVF   FF3,W
00C2A:  CLRF   x34
00C2C:  MOVWF  x33
00C2E:  MOVLW  03
00C30:  ADDWF  x33,W
00C32:  MOVWF  01
00C34:  MOVLW  00
00C36:  ADDWFC x34,W
00C38:  MOVWF  03
00C3A:  MOVF   01,W
00C3C:  ADDLW  81
00C3E:  MOVWF  01
00C40:  MOVLW  01
00C42:  ADDWFC 03,F
00C44:  MOVFF  01,633
00C48:  MOVFF  03,634
00C4C:  MOVFF  03,FEA
00C50:  MOVFF  01,FE9
00C54:  MOVFF  FEC,636
00C58:  MOVF   FED,F
00C5A:  MOVFF  FEF,635
00C5E:  MOVFF  635,FE9
00C62:  MOVFF  636,FEA
00C66:  MOVLW  02
00C68:  ADDWF  FEF,W
00C6A:  ADDWF  x31,W
00C6C:  MOVWF  01
00C6E:  MOVLW  00
00C70:  ADDWFC x32,W
00C72:  MOVWF  03
00C74:  MOVFF  01,637
00C78:  MOVWF  x38
00C7A:  BCF    FD8.0
00C7C:  RLCF   x2E,W
00C7E:  ADDLW  01
00C80:  MOVWF  x39
00C82:  MOVWF  x3A
00C84:  MOVLB  0
00C86:  RCALL  081A
00C88:  MOVFF  638,FEA
00C8C:  MOVFF  637,FE9
00C90:  MOVFF  00,FEF
00C94:  MOVLB  6
00C96:  MOVF   x2E,W
00C98:  MULLW  0D
00C9A:  MOVF   FF3,W
00C9C:  CLRF   x30
00C9E:  MOVWF  x2F
00CA0:  MOVLW  03
00CA2:  ADDWF  x2F,W
00CA4:  MOVWF  01
00CA6:  MOVLW  00
00CA8:  ADDWFC x30,W
00CAA:  MOVWF  03
00CAC:  MOVF   01,W
00CAE:  ADDLW  81
00CB0:  MOVWF  01
00CB2:  MOVLW  01
00CB4:  ADDWFC 03,F
00CB6:  MOVFF  01,62F
00CBA:  MOVFF  03,630
00CBE:  MOVFF  03,FEA
00CC2:  MOVFF  01,FE9
00CC6:  MOVFF  FEC,03
00CCA:  MOVF   FED,F
00CCC:  MOVFF  FEF,01
00CD0:  MOVFF  01,633
00CD4:  MOVFF  03,634
00CD8:  MOVF   x2E,W
00CDA:  MULLW  0D
00CDC:  MOVF   FF3,W
00CDE:  CLRF   x36
00CE0:  MOVWF  x35
00CE2:  MOVLW  03
00CE4:  ADDWF  x35,W
00CE6:  MOVWF  01
00CE8:  MOVLW  00
00CEA:  ADDWFC x36,W
00CEC:  MOVWF  03
00CEE:  MOVF   01,W
00CF0:  ADDLW  81
00CF2:  MOVWF  01
00CF4:  MOVLW  01
00CF6:  ADDWFC 03,F
00CF8:  MOVFF  01,635
00CFC:  MOVFF  03,636
00D00:  MOVFF  03,FEA
00D04:  MOVFF  01,FE9
00D08:  MOVFF  FEC,638
00D0C:  MOVF   FED,F
00D0E:  MOVFF  FEF,637
00D12:  MOVFF  637,FE9
00D16:  MOVFF  638,FEA
00D1A:  MOVF   FEF,W
00D1C:  SUBLW  04
00D1E:  BNZ   0D24
00D20:  MOVLW  00
00D22:  BRA    0D6A
00D24:  MOVF   x2E,W
00D26:  MULLW  0D
00D28:  MOVF   FF3,W
00D2A:  CLRF   x3A
00D2C:  MOVWF  x39
00D2E:  MOVLW  03
00D30:  ADDWF  x39,W
00D32:  MOVWF  01
00D34:  MOVLW  00
00D36:  ADDWFC x3A,W
00D38:  MOVWF  03
00D3A:  MOVF   01,W
00D3C:  ADDLW  81
00D3E:  MOVWF  01
00D40:  MOVLW  01
00D42:  ADDWFC 03,F
00D44:  MOVFF  01,639
00D48:  MOVFF  03,63A
00D4C:  MOVFF  03,FEA
00D50:  MOVFF  01,FE9
00D54:  MOVFF  FEC,63C
00D58:  MOVF   FED,F
00D5A:  MOVFF  FEF,63B
00D5E:  MOVFF  63B,FE9
00D62:  MOVFF  63C,FEA
00D66:  MOVLW  01
00D68:  ADDWF  FEF,W
00D6A:  MOVWF  x3D
00D6C:  MOVFF  634,FEA
00D70:  MOVFF  633,FE9
00D74:  MOVWF  FEF
00D76:  MOVF   x2E,W
00D78:  MULLW  0D
00D7A:  MOVF   FF3,W
00D7C:  CLRF   x30
00D7E:  MOVWF  x2F
00D80:  MOVLW  03
00D82:  ADDWF  x2F,W
00D84:  MOVWF  01
00D86:  MOVLW  00
00D88:  ADDWFC x30,W
00D8A:  MOVWF  03
00D8C:  MOVF   01,W
00D8E:  ADDLW  81
00D90:  MOVWF  01
00D92:  MOVLW  01
00D94:  ADDWFC 03,F
00D96:  MOVFF  01,62F
00D9A:  MOVFF  03,630
00D9E:  MOVFF  03,FEA
00DA2:  MOVFF  01,FE9
00DA6:  MOVFF  FEC,632
00DAA:  MOVF   FED,F
00DAC:  MOVFF  FEF,631
00DB0:  MOVFF  631,FE9
00DB4:  MOVFF  632,FEA
00DB8:  MOVFF  FEF,633
00DBC:  MOVF   x2E,W
00DBE:  MULLW  0D
00DC0:  MOVF   FF3,W
00DC2:  CLRF   x35
00DC4:  MOVWF  x34
00DC6:  MOVLW  03
00DC8:  ADDWF  x34,W
00DCA:  MOVWF  01
00DCC:  MOVLW  00
00DCE:  ADDWFC x35,W
00DD0:  MOVWF  03
00DD2:  MOVF   01,W
00DD4:  ADDLW  81
00DD6:  MOVWF  01
00DD8:  MOVLW  01
00DDA:  ADDWFC 03,F
00DDC:  MOVFF  01,634
00DE0:  MOVFF  03,635
00DE4:  MOVFF  03,FEA
00DE8:  MOVFF  01,FE9
00DEC:  MOVFF  FEC,637
00DF0:  MOVF   FED,F
00DF2:  MOVFF  FEF,636
00DF6:  MOVLW  01
00DF8:  ADDWF  x36,W
00DFA:  MOVWF  FE9
00DFC:  MOVLW  00
00DFE:  ADDWFC x37,W
00E00:  MOVWF  FEA
00E02:  MOVF   FEF,W
00E04:  SUBWF  x33,W
00E06:  BNZ   0EF8
00E08:  MOVF   x2E,W
00E0A:  MULLW  0D
00E0C:  MOVF   FF3,W
00E0E:  CLRF   x30
00E10:  MOVWF  x2F
00E12:  MOVLW  03
00E14:  ADDWF  x2F,W
00E16:  MOVWF  01
00E18:  MOVLW  00
00E1A:  ADDWFC x30,W
00E1C:  MOVWF  03
00E1E:  MOVF   01,W
00E20:  ADDLW  81
00E22:  MOVWF  01
00E24:  MOVLW  01
00E26:  ADDWFC 03,F
00E28:  MOVFF  01,62F
00E2C:  MOVFF  03,630
00E30:  MOVFF  03,FEA
00E34:  MOVFF  01,FE9
00E38:  MOVFF  FEC,632
00E3C:  MOVF   FED,F
00E3E:  MOVFF  FEF,631
00E42:  MOVLW  01
00E44:  ADDWF  x31,W
00E46:  MOVWF  01
00E48:  MOVLW  00
00E4A:  ADDWFC x32,W
00E4C:  MOVWF  03
00E4E:  MOVFF  01,633
00E52:  MOVWF  x34
00E54:  MOVF   x2E,W
00E56:  MULLW  0D
00E58:  MOVF   FF3,W
00E5A:  CLRF   x36
00E5C:  MOVWF  x35
00E5E:  MOVLW  03
00E60:  ADDWF  x35,W
00E62:  MOVWF  01
00E64:  MOVLW  00
00E66:  ADDWFC x36,W
00E68:  MOVWF  03
00E6A:  MOVF   01,W
00E6C:  ADDLW  81
00E6E:  MOVWF  01
00E70:  MOVLW  01
00E72:  ADDWFC 03,F
00E74:  MOVFF  01,635
00E78:  MOVFF  03,636
00E7C:  MOVFF  03,FEA
00E80:  MOVFF  01,FE9
00E84:  MOVFF  FEC,638
00E88:  MOVF   FED,F
00E8A:  MOVFF  FEF,637
00E8E:  MOVLW  01
00E90:  ADDWF  x37,W
00E92:  MOVWF  FE9
00E94:  MOVLW  00
00E96:  ADDWFC x38,W
00E98:  MOVWF  FEA
00E9A:  MOVF   FEF,W
00E9C:  SUBLW  04
00E9E:  BNZ   0EA4
00EA0:  MOVLW  00
00EA2:  BRA    0EEE
00EA4:  MOVF   x2E,W
00EA6:  MULLW  0D
00EA8:  MOVF   FF3,W
00EAA:  CLRF   x3A
00EAC:  MOVWF  x39
00EAE:  MOVLW  03
00EB0:  ADDWF  x39,W
00EB2:  MOVWF  01
00EB4:  MOVLW  00
00EB6:  ADDWFC x3A,W
00EB8:  MOVWF  03
00EBA:  MOVF   01,W
00EBC:  ADDLW  81
00EBE:  MOVWF  01
00EC0:  MOVLW  01
00EC2:  ADDWFC 03,F
00EC4:  MOVFF  01,639
00EC8:  MOVFF  03,63A
00ECC:  MOVFF  03,FEA
00ED0:  MOVFF  01,FE9
00ED4:  MOVFF  FEC,63C
00ED8:  MOVF   FED,F
00EDA:  MOVFF  FEF,63B
00EDE:  MOVLW  01
00EE0:  ADDWF  x3B,W
00EE2:  MOVWF  FE9
00EE4:  MOVLW  00
00EE6:  ADDWFC x3C,W
00EE8:  MOVWF  FEA
00EEA:  MOVLW  01
00EEC:  ADDWF  FEF,W
00EEE:  MOVFF  634,FEA
00EF2:  MOVFF  633,FE9
00EF6:  MOVWF  FEF
00EF8:  INCF   x2E,F
00EFA:  BRA    08D4
....................       }
00EFC:  INCF   x2D,F
00EFE:  BRA    08B2
....................    }
00F00:  MOVLB  0
00F02:  GOTO   0F68 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE MONITOR -- sets up ADC channels                                */
.................... /*****************************************************************************/
.................... void monitor_init()
.................... {
....................    setup_adc_ports(sAN6 | sAN16 | sAN17 | sAN24 | sAN25 | sAN26 | sAN27, NO_ANALOGS_P2, VSS_VDD);
00F06:  MOVLW  00
00F08:  MOVLB  F
00F0A:  MOVWF  x53
00F0C:  MOVLW  40
00F0E:  MOVWF  x0C
00F10:  MOVLW  00
00F12:  MOVWF  x14
00F14:  MOVLW  03
00F16:  MOVWF  x1C
00F18:  MOVLW  0F
00F1A:  MOVWF  x21
00F1C:  MOVLW  00
00F1E:  MOVWF  x29
....................    setup_adc(ADC_CLOCK_INTERNAL | ADC_TAD_MUL_255 | ADC_LEGACY_MODE | ADC_THRESHOLD_INT_DISABLED);
00F20:  MOVLW  08
00F22:  MOVWF  x55
00F24:  CLRF   x56
00F26:  CLRF   x52
00F28:  SETF   x57
00F2A:  CLRF   F61
00F2C:  MOVLW  94
00F2E:  MOVWF  x5B
....................    output_high(EN_EXC);
00F30:  MOVLW  E8
00F32:  MOVWF  F8B
00F34:  BSF    F86.0
....................    set_adc_channel(vMonN15); // internal MUX
00F36:  MOVF   x5A,W
00F38:  ANDLW  3F
00F3A:  MOVWF  01
00F3C:  MOVLW  06
00F3E:  MOVWF  x5A
00F40:  BTFSS  x5B.7
00F42:  BRA    0F52
00F44:  MOVF   01,W
00F46:  SUBLW  06
00F48:  BZ    0F52
00F4A:  BSF    x5B.0
00F4C:  NOP   
00F4E:  BTFSC  x5B.0
00F50:  BRA    0F4E
....................    delay_ms(10);
00F52:  MOVLW  0A
00F54:  MOVLB  6
00F56:  MOVWF  x30
00F58:  MOVLB  0
00F5A:  CALL   0438
....................    read_adc(ADC_START_ONLY);
00F5E:  MOVLB  F
00F60:  BSF    x5B.0
00F62:  NOP   
....................    setup_external_ADCs();
00F64:  MOVLB  0
00F66:  BRA    0868
....................    intTimeoutReg = sensorSampleRate;
00F68:  MOVLB  1
00F6A:  CLRF   x64
00F6C:  MOVLW  32
00F6E:  MOVWF  x63
00F70:  MOVLB  0
00F72:  GOTO   AE84 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <control.h>
.................... #ifndef control
.................... #define control
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0.3,0.1,0,0,0,0,0},
....................    {0.01,0.3,0.1,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <pid.h>
.................... #ifndef pidcontroller
.................... #define pidcontroller
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0.3,0.1,0,0,0,0,0},
....................    {0.01,0.3,0.1,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float32)(unsigned int16)y;
.................... 
....................  else if (y < 10000000.0)
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
....................       res = 32768.0*(float32)l;
....................       res += (float32)(unsigned int16)y;
....................    }
.................... 
....................  else
....................   res = y;
.................... 
....................  y = y - (float32)(unsigned int16)y;
.................... 
....................  if (s)
....................   res = -res;
.................... 
....................  if (y != 0)
....................  {
....................   if (s == 1 && n == 0)
....................    res -= 1.0;
.................... 
....................   if (s == 0 && n == 1)
....................    res += 1.0;
....................  }
....................  if (x == 0)
....................     res = 0;
.................... 
....................  return (res);
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl[0]*y2 + pl[1];
.................... 
....................       r = ql[0]*y2 + ql[1];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
....................          r = -(float32)-n;
....................       else
....................          r = (float32)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* UPDATE the Control Variable (CV)                                          */
.................... /*****************************************************************************/
.................... void pid_update (channelMap ch){
*
04F36:  MOVLB  6
04F38:  MOVF   x2C,W
04F3A:  MULLW  20
04F3C:  MOVF   FF3,W
04F3E:  CLRF   x3A
04F40:  MOVWF  x39
04F42:  MOVLW  0C
04F44:  ADDWF  x39,W
04F46:  MOVWF  01
04F48:  MOVLW  00
04F4A:  ADDWFC x3A,W
04F4C:  MOVWF  03
04F4E:  MOVF   01,W
04F50:  ADDLW  20
04F52:  MOVWF  FE9
04F54:  MOVLW  00
04F56:  ADDWFC 03,W
04F58:  MOVWF  FEA
04F5A:  MOVFF  FEF,677
04F5E:  MOVFF  FEC,678
04F62:  MOVFF  FEC,679
04F66:  MOVFF  FEC,67A
04F6A:  MOVF   x2C,W
04F6C:  MULLW  20
04F6E:  MOVF   FF3,W
04F70:  CLRF   x3E
04F72:  MOVWF  x3D
04F74:  MOVLW  10
04F76:  ADDWF  x3D,W
04F78:  MOVWF  01
04F7A:  MOVLW  00
04F7C:  ADDWFC x3E,W
04F7E:  MOVWF  03
04F80:  MOVF   01,W
04F82:  ADDLW  20
04F84:  MOVWF  FE9
04F86:  MOVLW  00
04F88:  ADDWFC 03,W
04F8A:  MOVWF  FEA
04F8C:  MOVFF  FEF,67B
04F90:  MOVFF  FEC,01
04F94:  MOVFF  FEC,02
04F98:  MOVFF  FEC,03
04F9C:  MOVFF  FEA,63E
04FA0:  MOVFF  FE9,63D
04FA4:  BSF    FD8.1
04FA6:  MOVFF  03,67E
04FAA:  MOVFF  02,67D
04FAE:  MOVFF  01,67C
04FB2:  MOVLB  0
04FB4:  CALL   12E8
04FB8:  MOVFF  63E,FEA
04FBC:  MOVFF  63D,FE9
04FC0:  MOVFF  03,630
04FC4:  MOVFF  02,62F
04FC8:  MOVFF  01,62E
04FCC:  MOVFF  00,62D
....................    float err = PID[ch].SP - PID[ch].PV;  // error = set value - measured
....................    
....................    PID[ch].I += err*PID[ch].kI;
04FD0:  MOVLB  6
04FD2:  MOVF   x2C,W
04FD4:  MULLW  20
04FD6:  MOVF   FF3,W
04FD8:  CLRF   x3A
04FDA:  MOVWF  x39
04FDC:  MOVLW  1C
04FDE:  ADDWF  x39,W
04FE0:  MOVWF  01
04FE2:  MOVLW  00
04FE4:  ADDWFC x3A,W
04FE6:  MOVWF  03
04FE8:  MOVF   01,W
04FEA:  ADDLW  20
04FEC:  MOVWF  01
04FEE:  MOVLW  00
04FF0:  ADDWFC 03,F
04FF2:  MOVFF  01,639
04FF6:  MOVFF  03,63A
04FFA:  MOVFF  03,FEA
04FFE:  MOVFF  01,FE9
05002:  MOVFF  FEF,63B
05006:  MOVFF  FEC,63C
0500A:  MOVFF  FEC,63D
0500E:  MOVFF  FEC,63E
05012:  MOVF   x2C,W
05014:  MULLW  20
05016:  MOVF   FF3,W
05018:  CLRF   x40
0501A:  MOVWF  x3F
0501C:  MOVLW  04
0501E:  ADDWF  x3F,W
05020:  MOVWF  01
05022:  MOVLW  00
05024:  ADDWFC x40,W
05026:  MOVWF  03
05028:  MOVF   01,W
0502A:  ADDLW  20
0502C:  MOVWF  FE9
0502E:  MOVLW  00
05030:  ADDWFC 03,W
05032:  MOVWF  FEA
05034:  MOVFF  FEF,67C
05038:  MOVFF  FEC,01
0503C:  MOVFF  FEC,02
05040:  MOVFF  FEC,03
05044:  MOVFF  630,67B
05048:  MOVFF  62F,67A
0504C:  MOVFF  62E,679
05050:  MOVFF  62D,678
05054:  MOVFF  03,67F
05058:  MOVFF  02,67E
0505C:  MOVFF  01,67D
05060:  MOVLB  0
05062:  CALL   11F2
05066:  BCF    FD8.1
05068:  MOVFF  63E,67A
0506C:  MOVFF  63D,679
05070:  MOVFF  63C,678
05074:  MOVFF  63B,677
05078:  MOVFF  03,67E
0507C:  MOVFF  02,67D
05080:  MOVFF  01,67C
05084:  MOVFF  00,67B
05088:  CALL   12E8
0508C:  MOVFF  63A,FEA
05090:  MOVFF  639,FE9
05094:  MOVFF  00,FEF
05098:  MOVFF  01,FEC
0509C:  MOVFF  02,FEC
050A0:  MOVFF  03,FEC
....................    if (PID[ch].I > op_upper_bound) PID[ch].I = op_upper_bound; // anti-windup
050A4:  MOVLB  6
050A6:  MOVF   x2C,W
050A8:  MULLW  20
050AA:  MOVF   FF3,W
050AC:  CLRF   x3A
050AE:  MOVWF  x39
050B0:  MOVLW  1C
050B2:  ADDWF  x39,W
050B4:  MOVWF  01
050B6:  MOVLW  00
050B8:  ADDWFC x3A,W
050BA:  MOVWF  03
050BC:  MOVF   01,W
050BE:  ADDLW  20
050C0:  MOVWF  FE9
050C2:  MOVLW  00
050C4:  ADDWFC 03,W
050C6:  MOVWF  FEA
050C8:  MOVFF  FEF,677
050CC:  MOVFF  FEC,63A
050D0:  MOVFF  FEC,679
050D4:  MOVFF  FEC,67A
050D8:  CLRF   x76
050DA:  CLRF   x75
050DC:  MOVLW  7C
050DE:  MOVWF  x74
050E0:  MOVLW  84
050E2:  MOVWF  x73
050E4:  MOVFF  63A,678
050E8:  MOVLB  0
050EA:  CALL   25F0
050EE:  BNC   5122
050F0:  MOVLB  6
050F2:  MOVF   x2C,W
050F4:  MULLW  20
050F6:  MOVF   FF3,W
050F8:  CLRF   x3A
050FA:  MOVWF  x39
050FC:  MOVLW  1C
050FE:  ADDWF  x39,W
05100:  MOVWF  01
05102:  MOVLW  00
05104:  ADDWFC x3A,W
05106:  MOVWF  03
05108:  MOVF   01,W
0510A:  ADDLW  20
0510C:  MOVWF  FE9
0510E:  MOVLW  00
05110:  ADDWFC 03,W
05112:  MOVWF  FEA
05114:  MOVLW  84
05116:  MOVWF  FEF
05118:  MOVLW  7C
0511A:  MOVWF  FEC
0511C:  CLRF   FEC
0511E:  CLRF   FEC
05120:  BRA    519E
....................    else if (PID[ch].I < op_lower_bound) PID[ch].I = op_lower_bound;
05122:  MOVLB  6
05124:  MOVF   x2C,W
05126:  MULLW  20
05128:  MOVF   FF3,W
0512A:  CLRF   x3A
0512C:  MOVWF  x39
0512E:  MOVLW  1C
05130:  ADDWF  x39,W
05132:  MOVWF  01
05134:  MOVLW  00
05136:  ADDWFC x3A,W
05138:  MOVWF  03
0513A:  MOVF   01,W
0513C:  ADDLW  20
0513E:  MOVWF  FE9
05140:  MOVLW  00
05142:  ADDWFC 03,W
05144:  MOVWF  FEA
05146:  MOVFF  FEF,673
0514A:  MOVFF  FEC,63A
0514E:  MOVFF  FEC,675
05152:  MOVFF  FEC,676
05156:  MOVFF  63A,674
0515A:  CLRF   x7A
0515C:  CLRF   x79
0515E:  MOVLW  FC
05160:  MOVWF  x78
05162:  MOVLW  84
05164:  MOVWF  x77
05166:  MOVLB  0
05168:  CALL   25F0
0516C:  BNC   51A0
0516E:  MOVLB  6
05170:  MOVF   x2C,W
05172:  MULLW  20
05174:  MOVF   FF3,W
05176:  CLRF   x3A
05178:  MOVWF  x39
0517A:  MOVLW  1C
0517C:  ADDWF  x39,W
0517E:  MOVWF  01
05180:  MOVLW  00
05182:  ADDWFC x3A,W
05184:  MOVWF  03
05186:  MOVF   01,W
05188:  ADDLW  20
0518A:  MOVWF  FE9
0518C:  MOVLW  00
0518E:  ADDWFC 03,W
05190:  MOVWF  FEA
05192:  MOVLW  84
05194:  MOVWF  FEF
05196:  MOVLW  FC
05198:  MOVWF  FEC
0519A:  CLRF   FEC
0519C:  CLRF   FEC
0519E:  MOVLB  0
....................    
....................    float P = err * PID[ch].kP;  // proportional value
....................    
....................    float D = PID[ch].kD * (PID[ch].PV - PID[ch].PVold);  // derivative value
051A0:  MOVLB  6
051A2:  MOVF   x2C,W
051A4:  MULLW  20
051A6:  MOVF   FF3,W
051A8:  CLRF   x3A
051AA:  MOVWF  x39
051AC:  MOVLW  20
051AE:  ADDWF  x39,W
051B0:  MOVWF  FE9
051B2:  MOVLW  00
051B4:  ADDWFC x3A,W
051B6:  MOVWF  FEA
051B8:  MOVFF  FEF,67C
051BC:  MOVFF  FEC,01
051C0:  MOVFF  FEC,02
051C4:  MOVFF  FEC,03
051C8:  MOVFF  630,67B
051CC:  MOVFF  62F,67A
051D0:  MOVFF  62E,679
051D4:  MOVFF  62D,678
051D8:  MOVFF  03,67F
051DC:  MOVFF  02,67E
051E0:  MOVFF  01,67D
051E4:  MOVLB  0
051E6:  CALL   11F2
051EA:  MOVFF  03,634
051EE:  MOVFF  02,633
051F2:  MOVFF  01,632
051F6:  MOVFF  00,631
051FA:  MOVLB  6
051FC:  MOVF   x2C,W
051FE:  MULLW  20
05200:  MOVF   FF3,W
05202:  CLRF   x3C
05204:  MOVWF  x3B
05206:  MOVLW  08
05208:  ADDWF  x3B,W
0520A:  MOVWF  01
0520C:  MOVLW  00
0520E:  ADDWFC x3C,W
05210:  MOVWF  03
05212:  MOVF   01,W
05214:  ADDLW  20
05216:  MOVWF  FE9
05218:  MOVLW  00
0521A:  ADDWFC 03,W
0521C:  MOVWF  FEA
0521E:  MOVFF  FEF,63B
05222:  MOVFF  FEC,63C
05226:  MOVFF  FEC,63D
0522A:  MOVFF  FEC,63E
0522E:  MOVF   x2C,W
05230:  MULLW  20
05232:  MOVF   FF3,W
05234:  CLRF   x40
05236:  MOVWF  x3F
05238:  MOVLW  10
0523A:  ADDWF  x3F,W
0523C:  MOVWF  01
0523E:  MOVLW  00
05240:  ADDWFC x40,W
05242:  MOVWF  03
05244:  MOVF   01,W
05246:  ADDLW  20
05248:  MOVWF  FE9
0524A:  MOVLW  00
0524C:  ADDWFC 03,W
0524E:  MOVWF  FEA
05250:  MOVFF  FEF,677
05254:  MOVFF  FEC,678
05258:  MOVFF  FEC,679
0525C:  MOVFF  FEC,67A
05260:  MOVF   x2C,W
05262:  MULLW  20
05264:  MOVF   FF3,W
05266:  CLRF   x44
05268:  MOVWF  x43
0526A:  MOVLW  14
0526C:  ADDWF  x43,W
0526E:  MOVWF  01
05270:  MOVLW  00
05272:  ADDWFC x44,W
05274:  MOVWF  03
05276:  MOVF   01,W
05278:  ADDLW  20
0527A:  MOVWF  FE9
0527C:  MOVLW  00
0527E:  ADDWFC 03,W
05280:  MOVWF  FEA
05282:  MOVFF  FEF,67B
05286:  MOVFF  FEC,01
0528A:  MOVFF  FEC,02
0528E:  MOVFF  FEC,03
05292:  MOVFF  FEA,644
05296:  MOVFF  FE9,643
0529A:  BSF    FD8.1
0529C:  MOVFF  03,67E
052A0:  MOVFF  02,67D
052A4:  MOVFF  01,67C
052A8:  MOVLB  0
052AA:  CALL   12E8
052AE:  MOVFF  644,FEA
052B2:  MOVFF  643,FE9
052B6:  MOVFF  63E,67B
052BA:  MOVFF  63D,67A
052BE:  MOVFF  63C,679
052C2:  MOVFF  63B,678
052C6:  MOVFF  03,67F
052CA:  MOVFF  02,67E
052CE:  MOVFF  01,67D
052D2:  MOVFF  00,67C
052D6:  CALL   11F2
052DA:  MOVFF  03,638
052DE:  MOVFF  02,637
052E2:  MOVFF  01,636
052E6:  MOVFF  00,635
....................    
....................    PID[ch].CV = P + PID[ch].I + D;  // new control variable
052EA:  MOVLB  6
052EC:  MOVF   x2C,W
052EE:  MULLW  20
052F0:  MOVF   FF3,W
052F2:  CLRF   x3A
052F4:  MOVWF  x39
052F6:  MOVLW  18
052F8:  ADDWF  x39,W
052FA:  MOVWF  01
052FC:  MOVLW  00
052FE:  ADDWFC x3A,W
05300:  MOVWF  03
05302:  MOVF   01,W
05304:  ADDLW  20
05306:  MOVWF  01
05308:  MOVLW  00
0530A:  ADDWFC 03,F
0530C:  MOVFF  01,639
05310:  MOVFF  03,63A
05314:  MOVF   x2C,W
05316:  MULLW  20
05318:  MOVF   FF3,W
0531A:  CLRF   x3C
0531C:  MOVWF  x3B
0531E:  MOVLW  1C
05320:  ADDWF  x3B,W
05322:  MOVWF  01
05324:  MOVLW  00
05326:  ADDWFC x3C,W
05328:  MOVWF  03
0532A:  MOVF   01,W
0532C:  ADDLW  20
0532E:  MOVWF  FE9
05330:  MOVLW  00
05332:  ADDWFC 03,W
05334:  MOVWF  FEA
05336:  MOVFF  FEF,67B
0533A:  MOVFF  FEC,01
0533E:  MOVFF  FEC,02
05342:  MOVFF  FEC,03
05346:  MOVFF  FEA,63C
0534A:  MOVFF  FE9,63B
0534E:  BCF    FD8.1
05350:  MOVFF  634,67A
05354:  MOVFF  633,679
05358:  MOVFF  632,678
0535C:  MOVFF  631,677
05360:  MOVFF  03,67E
05364:  MOVFF  02,67D
05368:  MOVFF  01,67C
0536C:  MOVLB  0
0536E:  CALL   12E8
05372:  MOVFF  63C,FEA
05376:  MOVFF  63B,FE9
0537A:  MOVFF  03,640
0537E:  MOVFF  02,63F
05382:  MOVFF  01,63E
05386:  MOVFF  00,63D
0538A:  BCF    FD8.1
0538C:  MOVFF  03,67A
05390:  MOVFF  02,679
05394:  MOVFF  01,678
05398:  MOVFF  00,677
0539C:  MOVFF  638,67E
053A0:  MOVFF  637,67D
053A4:  MOVFF  636,67C
053A8:  MOVFF  635,67B
053AC:  CALL   12E8
053B0:  MOVFF  63A,FEA
053B4:  MOVFF  639,FE9
053B8:  MOVFF  00,FEF
053BC:  MOVFF  01,FEC
053C0:  MOVFF  02,FEC
053C4:  MOVFF  03,FEC
....................    if (PID[ch].CV > op_upper_bound) PID[ch].CV = op_upper_bound; // limit positive output
053C8:  MOVLB  6
053CA:  MOVF   x2C,W
053CC:  MULLW  20
053CE:  MOVF   FF3,W
053D0:  CLRF   x3A
053D2:  MOVWF  x39
053D4:  MOVLW  18
053D6:  ADDWF  x39,W
053D8:  MOVWF  01
053DA:  MOVLW  00
053DC:  ADDWFC x3A,W
053DE:  MOVWF  03
053E0:  MOVF   01,W
053E2:  ADDLW  20
053E4:  MOVWF  FE9
053E6:  MOVLW  00
053E8:  ADDWFC 03,W
053EA:  MOVWF  FEA
053EC:  MOVFF  FEF,677
053F0:  MOVFF  FEC,63A
053F4:  MOVFF  FEC,679
053F8:  MOVFF  FEC,67A
053FC:  CLRF   x76
053FE:  CLRF   x75
05400:  MOVLW  7C
05402:  MOVWF  x74
05404:  MOVLW  84
05406:  MOVWF  x73
05408:  MOVFF  63A,678
0540C:  MOVLB  0
0540E:  CALL   25F0
05412:  BNC   5446
05414:  MOVLB  6
05416:  MOVF   x2C,W
05418:  MULLW  20
0541A:  MOVF   FF3,W
0541C:  CLRF   x3A
0541E:  MOVWF  x39
05420:  MOVLW  18
05422:  ADDWF  x39,W
05424:  MOVWF  01
05426:  MOVLW  00
05428:  ADDWFC x3A,W
0542A:  MOVWF  03
0542C:  MOVF   01,W
0542E:  ADDLW  20
05430:  MOVWF  FE9
05432:  MOVLW  00
05434:  ADDWFC 03,W
05436:  MOVWF  FEA
05438:  MOVLW  84
0543A:  MOVWF  FEF
0543C:  MOVLW  7C
0543E:  MOVWF  FEC
05440:  CLRF   FEC
05442:  CLRF   FEC
05444:  BRA    54C2
....................    else if (PID[ch].CV < op_lower_bound) PID[ch].CV = op_lower_bound; // limit negative output
05446:  MOVLB  6
05448:  MOVF   x2C,W
0544A:  MULLW  20
0544C:  MOVF   FF3,W
0544E:  CLRF   x3A
05450:  MOVWF  x39
05452:  MOVLW  18
05454:  ADDWF  x39,W
05456:  MOVWF  01
05458:  MOVLW  00
0545A:  ADDWFC x3A,W
0545C:  MOVWF  03
0545E:  MOVF   01,W
05460:  ADDLW  20
05462:  MOVWF  FE9
05464:  MOVLW  00
05466:  ADDWFC 03,W
05468:  MOVWF  FEA
0546A:  MOVFF  FEF,673
0546E:  MOVFF  FEC,63A
05472:  MOVFF  FEC,675
05476:  MOVFF  FEC,676
0547A:  MOVFF  63A,674
0547E:  CLRF   x7A
05480:  CLRF   x79
05482:  MOVLW  FC
05484:  MOVWF  x78
05486:  MOVLW  84
05488:  MOVWF  x77
0548A:  MOVLB  0
0548C:  CALL   25F0
05490:  BNC   54C2
05492:  MOVLB  6
05494:  MOVF   x2C,W
05496:  MULLW  20
05498:  MOVF   FF3,W
0549A:  CLRF   x3A
0549C:  MOVWF  x39
0549E:  MOVLW  18
054A0:  ADDWF  x39,W
054A2:  MOVWF  01
054A4:  MOVLW  00
054A6:  ADDWFC x3A,W
054A8:  MOVWF  03
054AA:  MOVF   01,W
054AC:  ADDLW  20
054AE:  MOVWF  FE9
054B0:  MOVLW  00
054B2:  ADDWFC 03,W
054B4:  MOVWF  FEA
054B6:  MOVLW  84
054B8:  MOVWF  FEF
054BA:  MOVLW  FC
054BC:  MOVWF  FEC
054BE:  CLRF   FEC
054C0:  CLRF   FEC
054C2:  MOVLB  0
054C4:  GOTO   553C (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PID Task - looks for change to PV and updates CV                          */
.................... /*****************************************************************************/
.................... void pid_task(channelMap ch){
....................    static int index = 0;
....................    if (PID[ch].SP != PID[ch].PV) pid_update(ch);
054C8:  MOVLB  6
054CA:  MOVF   x2B,W
054CC:  MULLW  20
054CE:  MOVF   FF3,W
054D0:  CLRF   x2D
054D2:  MOVWF  x2C
054D4:  MOVLW  0C
054D6:  ADDWF  x2C,W
054D8:  MOVWF  01
054DA:  MOVLW  00
054DC:  ADDWFC x2D,W
054DE:  MOVWF  03
054E0:  MOVF   01,W
054E2:  ADDLW  20
054E4:  MOVWF  FE9
054E6:  MOVLW  00
054E8:  ADDWFC 03,W
054EA:  MOVWF  FEA
054EC:  MOVFF  FEF,673
054F0:  MOVFF  FEC,674
054F4:  MOVFF  FEC,675
054F8:  MOVFF  FEC,676
054FC:  MOVF   x2B,W
054FE:  MULLW  20
05500:  MOVF   FF3,W
05502:  CLRF   x31
05504:  MOVWF  x30
05506:  MOVLW  10
05508:  ADDWF  x30,W
0550A:  MOVWF  01
0550C:  MOVLW  00
0550E:  ADDWFC x31,W
05510:  MOVWF  03
05512:  MOVF   01,W
05514:  ADDLW  20
05516:  MOVWF  FE9
05518:  MOVLW  00
0551A:  ADDWFC 03,W
0551C:  MOVWF  FEA
0551E:  MOVFF  FEF,677
05522:  MOVFF  FEC,678
05526:  MOVFF  FEC,679
0552A:  MOVFF  FEC,67A
0552E:  MOVLB  0
05530:  CALL   25F0
05534:  BZ    553C
05536:  MOVFF  62B,62C
0553A:  BRA    4F36
....................    if ((index++) >= numChannels) index = 0;
0553C:  MOVLB  1
0553E:  MOVF   x9E,W
05540:  INCF   x9E,F
05542:  SUBLW  01
05544:  BC    5548
05546:  CLRF   x9E
05548:  MOVLB  0
0554A:  GOTO   5636 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... #pin_select SCK1=PIN_C3
.................... #pin_select SDO1=PIN_C2
.................... #use spi (MASTER, SPI1, BAUD=100000, MODE=2, STREAM=SPI_ctrl)
*
00F76:  CLRF   03
00F78:  MOVF   F91,W
00F7A:  MOVFF  62D,F91
00F7E:  RRCF   F94,W
00F80:  BNC   0F7E
00F82:  MOVF   F91,W
00F84:  MOVWF  02
00F86:  MOVFF  62C,F91
00F8A:  RRCF   F94,W
00F8C:  BNC   0F8A
00F8E:  MOVF   F91,W
00F90:  MOVWF  01
00F92:  MOVFF  62B,F91
00F96:  RRCF   F94,W
00F98:  BNC   0F96
00F9A:  MOVFF  F91,00
00F9E:  RETURN 0
.................... 
.................... #define DACfullScale 655.35 // full scale/100 because CV = %
.................... 
.................... /*****************************************************************************/
.................... /*  Inverts the output voltage ( -180V - 0V )                                */ 
.................... /*****************************************************************************/
.................... void invert_voltage(channelMap ch, BOOLEAN inv_v){
....................    if ( inv_v ) {
*
04E92:  MOVLB  6
04E94:  MOVF   x2C,F
04E96:  BZ    4EE6
....................       if (chMap[0] == ch) output_low(INV_HVX);
04E98:  MOVLW  00
04E9A:  MOVLB  0
04E9C:  BTFSC  x60.0
04E9E:  MOVLW  01
04EA0:  MOVLB  6
04EA2:  SUBWF  x2B,W
04EA4:  BNZ   4EAC
04EA6:  MOVLW  C4
04EA8:  MOVWF  F88
04EAA:  BCF    F83.4
....................       if (chMap[1] == ch) output_low(INV_HVY);
04EAC:  MOVLW  00
04EAE:  MOVLB  0
04EB0:  BTFSC  x60.1
04EB2:  MOVLW  01
04EB4:  MOVLB  6
04EB6:  SUBWF  x2B,W
04EB8:  BNZ   4EC0
04EBA:  MOVLW  C4
04EBC:  MOVWF  F88
04EBE:  BCF    F83.5
....................       dacVals[ch].invV = TRUE;
04EC0:  MOVF   x2B,W
04EC2:  MULLW  03
04EC4:  MOVF   FF3,W
04EC6:  CLRF   x2E
04EC8:  MOVWF  x2D
04ECA:  MOVLW  02
04ECC:  ADDWF  x2D,W
04ECE:  MOVWF  01
04ED0:  MOVLW  00
04ED2:  ADDWFC x2E,W
04ED4:  MOVWF  03
04ED6:  MOVF   01,W
04ED8:  ADDLW  51
04EDA:  MOVWF  FE9
04EDC:  MOVLW  01
04EDE:  ADDWFC 03,W
04EE0:  MOVWF  FEA
04EE2:  BSF    FEF.0
....................    }
04EE4:  BRA    4F32
....................    else {
....................       if (chMap[0] == ch) output_high(INV_HVX);
04EE6:  MOVLW  00
04EE8:  MOVLB  0
04EEA:  BTFSC  x60.0
04EEC:  MOVLW  01
04EEE:  MOVLB  6
04EF0:  SUBWF  x2B,W
04EF2:  BNZ   4EFA
04EF4:  MOVLW  C4
04EF6:  MOVWF  F88
04EF8:  BSF    F83.4
....................       if (chMap[1] == ch) output_high(INV_HVY);
04EFA:  MOVLW  00
04EFC:  MOVLB  0
04EFE:  BTFSC  x60.1
04F00:  MOVLW  01
04F02:  MOVLB  6
04F04:  SUBWF  x2B,W
04F06:  BNZ   4F0E
04F08:  MOVLW  C4
04F0A:  MOVWF  F88
04F0C:  BSF    F83.5
....................       dacVals[ch].invV = FALSE;
04F0E:  MOVF   x2B,W
04F10:  MULLW  03
04F12:  MOVF   FF3,W
04F14:  CLRF   x2E
04F16:  MOVWF  x2D
04F18:  MOVLW  02
04F1A:  ADDWF  x2D,W
04F1C:  MOVWF  01
04F1E:  MOVLW  00
04F20:  ADDWFC x2E,W
04F22:  MOVWF  03
04F24:  MOVF   01,W
04F26:  ADDLW  51
04F28:  MOVWF  FE9
04F2A:  MOVLW  01
04F2C:  ADDWFC 03,W
04F2E:  MOVWF  FEA
04F30:  BCF    FEF.0
....................    }
04F32:  MOVLB  0
04F34:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  Nano DAC's have a 16bit serial shift register. Data is sync'ed to output */ 
.................... /*****************************************************************************/
.................... void set_nanoDAC_outputs(channelMap ch){
*
0554E:  MOVLB  6
05550:  CLRF   x2A
05552:  CLRF   x29
....................    unsigned int16 txData = 0;
....................    
....................    // use manualOutputValues if channel is manual mode
....................    // else, use PID control variable
....................    if (chMode[ch] == MANUAL){
05554:  MOVFF  628,635
05558:  CLRF   x37
0555A:  MOVLW  61
0555C:  MOVWF  x36
0555E:  MOVLB  0
05560:  RCALL  4E5C
05562:  MOVF   01,F
05564:  BNZ   5630
....................       if ( manualOutputValues[ch] < 0) invert_voltage(ch, TRUE); 
05566:  MOVLB  6
05568:  MOVF   x28,W
0556A:  MULLW  04
0556C:  MOVF   FF3,W
0556E:  CLRF   03
05570:  ADDLW  EA
05572:  MOVWF  FE9
05574:  MOVLW  00
05576:  ADDWFC 03,W
05578:  MOVWF  FEA
0557A:  MOVFF  FEF,673
0557E:  MOVFF  FEC,674
05582:  MOVFF  FEC,675
05586:  MOVFF  FEC,676
0558A:  CLRF   x7A
0558C:  CLRF   x79
0558E:  CLRF   x78
05590:  CLRF   x77
05592:  MOVLB  0
05594:  CALL   25F0
05598:  BNC   55AA
0559A:  MOVFF  628,62B
0559E:  MOVLW  01
055A0:  MOVLB  6
055A2:  MOVWF  x2C
055A4:  MOVLB  0
055A6:  RCALL  4E92
055A8:  BRA    55B6
....................       else                             invert_voltage(ch, FALSE);
055AA:  MOVFF  628,62B
055AE:  MOVLB  6
055B0:  CLRF   x2C
055B2:  MOVLB  0
055B4:  RCALL  4E92
....................       
....................       txData = (unsigned int16)(abs(manualOutputValues[ch]) * DACfullScale);
055B6:  MOVLB  6
055B8:  MOVF   x28,W
055BA:  MULLW  04
055BC:  MOVF   FF3,W
055BE:  CLRF   03
055C0:  ADDLW  EA
055C2:  MOVWF  FE9
055C4:  MOVLW  00
055C6:  ADDWFC 03,W
055C8:  MOVWF  FEA
055CA:  MOVFF  FEF,00
055CE:  MOVFF  FEC,01
055D2:  MOVFF  FEC,02
055D6:  MOVFF  FEC,03
055DA:  BCF    01.7
055DC:  MOVFF  03,62E
055E0:  MOVFF  02,62D
055E4:  MOVFF  01,62C
055E8:  MOVFF  00,62B
055EC:  MOVFF  03,67B
055F0:  MOVFF  02,67A
055F4:  MOVFF  01,679
055F8:  MOVFF  00,678
055FC:  MOVLW  66
055FE:  MOVWF  x7F
05600:  MOVLW  D6
05602:  MOVWF  x7E
05604:  MOVLW  23
05606:  MOVWF  x7D
05608:  MOVLW  88
0560A:  MOVWF  x7C
0560C:  MOVLB  0
0560E:  CALL   11F2
05612:  MOVFF  03,676
05616:  MOVFF  02,675
0561A:  MOVFF  01,674
0561E:  MOVFF  00,673
05622:  CALL   2FE4
05626:  MOVFF  02,62A
0562A:  MOVFF  01,629
....................    }
0562E:  BRA    5720
....................    else {
....................       pid_task(ch);
05630:  MOVFF  628,62B
05634:  BRA    54C8
....................       if ( PID[(int)ch].CV < 0 ) invert_voltage(ch, TRUE); 
05636:  MOVLB  6
05638:  MOVF   x28,W
0563A:  MULLW  20
0563C:  MOVF   FF3,W
0563E:  CLRF   x2C
05640:  MOVWF  x2B
05642:  MOVLW  18
05644:  ADDWF  x2B,W
05646:  MOVWF  01
05648:  MOVLW  00
0564A:  ADDWFC x2C,W
0564C:  MOVWF  03
0564E:  MOVF   01,W
05650:  ADDLW  20
05652:  MOVWF  FE9
05654:  MOVLW  00
05656:  ADDWFC 03,W
05658:  MOVWF  FEA
0565A:  MOVFF  FEF,673
0565E:  MOVFF  FEC,674
05662:  MOVFF  FEC,675
05666:  MOVFF  FEC,676
0566A:  CLRF   x7A
0566C:  CLRF   x79
0566E:  CLRF   x78
05670:  CLRF   x77
05672:  MOVLB  0
05674:  CALL   25F0
05678:  BNC   568A
0567A:  MOVFF  628,62B
0567E:  MOVLW  01
05680:  MOVLB  6
05682:  MOVWF  x2C
05684:  MOVLB  0
05686:  RCALL  4E92
05688:  BRA    5698
....................       else                       invert_voltage(ch, FALSE);
0568A:  MOVFF  628,62B
0568E:  MOVLB  6
05690:  CLRF   x2C
05692:  MOVLB  0
05694:  CALL   4E92
....................       
....................       txData = (unsigned int16)(abs(PID[(int)ch].CV) * DACfullScale);
05698:  MOVLB  6
0569A:  MOVF   x28,W
0569C:  MULLW  20
0569E:  MOVF   FF3,W
056A0:  CLRF   x2C
056A2:  MOVWF  x2B
056A4:  MOVLW  18
056A6:  ADDWF  x2B,W
056A8:  MOVWF  01
056AA:  MOVLW  00
056AC:  ADDWFC x2C,W
056AE:  MOVWF  03
056B0:  MOVF   01,W
056B2:  ADDLW  20
056B4:  MOVWF  FE9
056B6:  MOVLW  00
056B8:  ADDWFC 03,W
056BA:  MOVWF  FEA
056BC:  MOVFF  FEF,00
056C0:  MOVFF  FEC,01
056C4:  MOVFF  FEC,02
056C8:  MOVFF  FEC,03
056CC:  BCF    01.7
056CE:  MOVFF  03,62E
056D2:  MOVFF  02,62D
056D6:  MOVFF  01,62C
056DA:  MOVFF  00,62B
056DE:  MOVFF  03,67B
056E2:  MOVFF  02,67A
056E6:  MOVFF  01,679
056EA:  MOVFF  00,678
056EE:  MOVLW  66
056F0:  MOVWF  x7F
056F2:  MOVLW  D6
056F4:  MOVWF  x7E
056F6:  MOVLW  23
056F8:  MOVWF  x7D
056FA:  MOVLW  88
056FC:  MOVWF  x7C
056FE:  MOVLB  0
05700:  CALL   11F2
05704:  MOVFF  03,676
05708:  MOVFF  02,675
0570C:  MOVFF  01,674
05710:  MOVFF  00,673
05714:  CALL   2FE4
05718:  MOVFF  02,62A
0571C:  MOVFF  01,629
....................    }
....................    
....................    dacVals[ch].val = txData;
05720:  MOVLB  6
05722:  MOVF   x28,W
05724:  MULLW  03
05726:  MOVF   FF3,W
05728:  CLRF   x2C
0572A:  MOVWF  x2B
0572C:  MOVLW  51
0572E:  ADDWF  x2B,W
05730:  MOVWF  FE9
05732:  MOVLW  01
05734:  ADDWFC x2C,W
05736:  MOVWF  FEA
05738:  MOVFF  62A,FEC
0573C:  MOVF   FED,F
0573E:  MOVFF  629,FEF
....................    
....................    // use channel map to decide which outputs channels to update
....................    // strobe _sync low to push data to the outputs
....................    if (chMap[0] == ch) output_high(_SYNC_X);
05742:  MOVLW  00
05744:  MOVLB  0
05746:  BTFSC  x60.0
05748:  MOVLW  01
0574A:  MOVLB  6
0574C:  SUBWF  x28,W
0574E:  BNZ   5756
05750:  MOVLW  E8
05752:  MOVWF  F8B
05754:  BSF    F86.2
....................    if (chMap[1] == ch) output_high(_SYNC_Y);
05756:  MOVLW  00
05758:  MOVLB  0
0575A:  BTFSC  x60.1
0575C:  MOVLW  01
0575E:  MOVLB  6
05760:  SUBWF  x28,W
05762:  BNZ   576A
05764:  MOVLW  E8
05766:  MOVWF  F8B
05768:  BSF    F86.1
....................    
....................    delay_ms(1);
0576A:  MOVLW  01
0576C:  MOVWF  x30
0576E:  MOVLB  0
05770:  CALL   0438
....................    
....................    if (chMap[0] == ch) output_low(_SYNC_X);
05774:  MOVLW  00
05776:  BTFSC  x60.0
05778:  MOVLW  01
0577A:  MOVLB  6
0577C:  SUBWF  x28,W
0577E:  BNZ   5786
05780:  MOVLW  E8
05782:  MOVWF  F8B
05784:  BCF    F86.2
....................    if (chMap[1] == ch) output_low(_SYNC_Y);
05786:  MOVLW  00
05788:  MOVLB  0
0578A:  BTFSC  x60.1
0578C:  MOVLW  01
0578E:  MOVLB  6
05790:  SUBWF  x28,W
05792:  BNZ   579A
05794:  MOVLW  E8
05796:  MOVWF  F8B
05798:  BCF    F86.1
....................    delay_ms(1);
0579A:  MOVLW  01
0579C:  MOVWF  x30
0579E:  MOVLB  0
057A0:  CALL   0438
....................    
....................    // shift 16 bits of data
....................    spi_xfer(SPI_ctrl, txData, 24);
057A4:  MOVLB  6
057A6:  CLRF   x2E
057A8:  CLRF   x2D
057AA:  MOVFF  62A,62C
057AE:  MOVFF  629,62B
057B2:  MOVLB  0
057B4:  CALL   0F76
....................    delay_ms(1);
057B8:  MOVLW  01
057BA:  MOVLB  6
057BC:  MOVWF  x30
057BE:  MOVLB  0
057C0:  CALL   0438
....................    
....................    if (chMap[0] == ch) output_high(_SYNC_X);
057C4:  MOVLW  00
057C6:  BTFSC  x60.0
057C8:  MOVLW  01
057CA:  MOVLB  6
057CC:  SUBWF  x28,W
057CE:  BNZ   57D6
057D0:  MOVLW  E8
057D2:  MOVWF  F8B
057D4:  BSF    F86.2
....................    if (chMap[1] == ch) output_high(_SYNC_Y);
057D6:  MOVLW  00
057D8:  MOVLB  0
057DA:  BTFSC  x60.1
057DC:  MOVLW  01
057DE:  MOVLB  6
057E0:  SUBWF  x28,W
057E2:  BNZ   57EA
057E4:  MOVLW  E8
057E6:  MOVWF  F8B
057E8:  BSF    F86.1
057EA:  MOVLB  0
057EC:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  control task sets up the outputs channels                                */ 
.................... /*****************************************************************************/
.................... void control_task(){
....................    static int state = 0;
....................    
....................    switch (state)
057EE:  MOVLB  1
057F0:  MOVF   x9F,W
057F2:  XORLW  00
057F4:  MOVLB  0
057F6:  BZ    57FE
057F8:  XORLW  01
057FA:  BZ    5810
057FC:  BRA    5820
....................    {
....................       case 0:
....................          set_nanoDAC_outputs(chX);
057FE:  MOVLB  6
05800:  CLRF   x28
05802:  MOVLB  0
05804:  RCALL  554E
....................          state = 1;
05806:  MOVLW  01
05808:  MOVLB  1
0580A:  MOVWF  x9F
....................       break;
0580C:  MOVLB  0
0580E:  BRA    5820
....................       case 1:
....................          set_nanoDAC_outputs(chY);
05810:  MOVLW  01
05812:  MOVLB  6
05814:  MOVWF  x28
05816:  MOVLB  0
05818:  RCALL  554E
....................          state = 0;
0581A:  MOVLB  1
0581C:  CLRF   x9F
....................       break;
0581E:  MOVLB  0
....................    }
05820:  GOTO   AEA0 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  control task sets up the outputs channels                                */ 
.................... /*****************************************************************************/
.................... void control_init(){
....................    spi_xfer(SPI_ctrl, 0, 24);
*
00FA0:  MOVLB  6
00FA2:  CLRF   x2E
00FA4:  CLRF   x2D
00FA6:  CLRF   x2C
00FA8:  CLRF   x2B
00FAA:  MOVLB  0
00FAC:  RCALL  0F76
....................    output_low(_SYNC_X);
00FAE:  MOVLW  E8
00FB0:  MOVWF  F8B
00FB2:  BCF    F86.2
....................    output_low(_SYNC_Y);
00FB4:  MOVWF  F8B
00FB6:  BCF    F86.1
....................    output_high(_SYNC_X);
00FB8:  MOVWF  F8B
00FBA:  BSF    F86.2
....................    output_high(_SYNC_Y);
00FBC:  MOVWF  F8B
00FBE:  BSF    F86.1
00FC0:  GOTO   AE88 (RETURN)
.................... }
.................... #endif
.................... 
.................... #include <serialport.h>
.................... #ifndef serialPort
.................... #define serialPort
.................... #include <cmdBuffer.h>
.................... #ifndef cmd_buffer
.................... #define cmd_buffer
.................... 
.................... /*****************************************************************************/
.................... /* DIFCS COMMAND BUFFER                                                      */
.................... /* The beginning of a message is signified by an address record. The address */
.................... /* is 4 characters. The first 2 are the hardware identifier (TC - temperature*/
.................... /* controller, DC - difics controller, etc..) The second 2 characters dev-   */
.................... /* ice ID... Valid values are 00 thru 0F. A device ID of FF writes to all    */
.................... /* boards. This might be used to feed angles data to all listeners.          */
.................... /*****************************************************************************/
.................... 
.................... // t,p0,p1,p2,p3,p4,p5,p6
.................... // t is the start character, p0 is the address, p1 is command, p2-6 are params
.................... // these characters used for storing messages
.................... 
.................... #define startChr '~' // start character. Also diagnostic command type
.................... #define diagCmdType startChr
.................... #define endChr '\n'
.................... #define delimiter ','
.................... #define ignoreChr1 '\r'
.................... #define ignoreChr2 ' '
.................... #define noRecordFound (char)0xFF
.................... 
.................... #define numRecords 4
.................... #define numParam 7
.................... #define lenParam 25
.................... 
.................... #define useSerial
.................... //#define useTCPIP
.................... 
.................... typedef enum cmdMode {tcp, ser};
.................... 
.................... // this structure holds a command. This is used by the serial routine as well
.................... // as the TCP routine to store an incoming command + parameters
.................... // in the case of TCP socket id is also passed in this structure
.................... typedef struct cmd 
.................... {
....................    BOOLEAN full;        // if full, command is ready to execute
....................    unsigned int8 chrIndex;
....................    unsigned int8 paramIndex;
....................    unsigned int8 recReadIndex;
....................    unsigned int8 recWriteIndex;
....................    #ifdef useTCPIP
....................    TCP_SOCKET s;              // socket ID for TCP commands 
....................    #endif
....................    char t;
....................    char p[numParam][lenParam];   // only used with ~ type command
.................... };
.................... 
.................... #ifdef useSerial
.................... struct cmd SERcmd[numRecords]; // holds serial command 
.................... unsigned int8 SRI = 0; //usb readindex
.................... unsigned int8 SWI = 0; //usb write index
.................... #endif
.................... 
.................... #ifdef useTCPIP
.................... struct cmd TCPcmd[numRecords]; // holds TCP command
.................... unsigned int8 TRI = 0; //usb readindex
.................... unsigned int8 TWI = 0; //usb write index
.................... #endif
.................... 
.................... char retData[100]; // this is used to hold return data 
.................... 
.................... #ifdef useSerial
.................... /*****************************************************************************/
.................... /* RESET SER COMMAND -- ready for a new command                              */
.................... /*****************************************************************************/
.................... void resetSERcmd(unsigned int8 recNum)
.................... {
....................    if (recNum < numRecords)
*
00FE6:  MOVLB  6
00FE8:  MOVF   x29,W
00FEA:  SUBLW  03
00FEC:  BTFSS  FD8.0
00FEE:  BRA    115C
....................    {
....................       for (int i = 0; i <numParam; i ++)
00FF0:  CLRF   x2A
00FF2:  MOVF   x2A,W
00FF4:  SUBLW  06
00FF6:  BNC   1046
....................       {
....................          SERcmd[recNum].p[i][0] = '\0';
00FF8:  CLRF   x6A
00FFA:  MOVFF  629,669
00FFE:  CLRF   x6C
01000:  MOVLW  B5
01002:  MOVWF  x6B
01004:  MOVLB  0
01006:  RCALL  0FC4
01008:  MOVFF  02,62C
0100C:  MOVFF  01,62B
01010:  MOVLW  06
01012:  MOVLB  6
01014:  ADDWF  x2B,F
01016:  MOVLW  00
01018:  ADDWFC x2C,F
0101A:  CLRF   x6A
0101C:  MOVFF  62A,669
01020:  CLRF   x6C
01022:  MOVLW  19
01024:  MOVWF  x6B
01026:  MOVLB  0
01028:  RCALL  0FC4
0102A:  MOVF   01,W
0102C:  MOVLB  6
0102E:  ADDWF  x2B,F
01030:  MOVF   02,W
01032:  ADDWFC x2C,F
01034:  MOVLW  A0
01036:  ADDWF  x2B,W
01038:  MOVWF  FE9
0103A:  MOVLW  01
0103C:  ADDWFC x2C,W
0103E:  MOVWF  FEA
01040:  CLRF   FEF
01042:  INCF   x2A,F
01044:  BRA    0FF2
....................       }
....................       SERcmd[recNum].t = 0;
01046:  CLRF   x6A
01048:  MOVFF  629,669
0104C:  CLRF   x6C
0104E:  MOVLW  B5
01050:  MOVWF  x6B
01052:  MOVLB  0
01054:  RCALL  0FC4
01056:  MOVFF  01,62B
0105A:  MOVLW  05
0105C:  MOVLB  6
0105E:  ADDWF  01,W
01060:  MOVWF  01
01062:  MOVLW  00
01064:  ADDWFC 02,W
01066:  MOVWF  03
01068:  MOVF   01,W
0106A:  ADDLW  A0
0106C:  MOVWF  FE9
0106E:  MOVLW  01
01070:  ADDWFC 03,W
01072:  MOVWF  FEA
01074:  CLRF   FEF
....................       SERcmd[recNum].chrIndex = 0;
01076:  CLRF   x6A
01078:  MOVFF  629,669
0107C:  CLRF   x6C
0107E:  MOVLW  B5
01080:  MOVWF  x6B
01082:  MOVLB  0
01084:  RCALL  0FC4
01086:  MOVFF  01,62B
0108A:  MOVLW  01
0108C:  MOVLB  6
0108E:  ADDWF  01,W
01090:  MOVWF  01
01092:  MOVLW  00
01094:  ADDWFC 02,W
01096:  MOVWF  03
01098:  MOVF   01,W
0109A:  ADDLW  A0
0109C:  MOVWF  FE9
0109E:  MOVLW  01
010A0:  ADDWFC 03,W
010A2:  MOVWF  FEA
010A4:  CLRF   FEF
....................       SERcmd[recNum].paramIndex = 0;
010A6:  CLRF   x6A
010A8:  MOVFF  629,669
010AC:  CLRF   x6C
010AE:  MOVLW  B5
010B0:  MOVWF  x6B
010B2:  MOVLB  0
010B4:  RCALL  0FC4
010B6:  MOVFF  01,62B
010BA:  MOVLW  02
010BC:  MOVLB  6
010BE:  ADDWF  01,W
010C0:  MOVWF  01
010C2:  MOVLW  00
010C4:  ADDWFC 02,W
010C6:  MOVWF  03
010C8:  MOVF   01,W
010CA:  ADDLW  A0
010CC:  MOVWF  FE9
010CE:  MOVLW  01
010D0:  ADDWFC 03,W
010D2:  MOVWF  FEA
010D4:  CLRF   FEF
....................       SERcmd[recNum].recReadIndex = 0;
010D6:  CLRF   x6A
010D8:  MOVFF  629,669
010DC:  CLRF   x6C
010DE:  MOVLW  B5
010E0:  MOVWF  x6B
010E2:  MOVLB  0
010E4:  RCALL  0FC4
010E6:  MOVFF  01,62B
010EA:  MOVLW  03
010EC:  MOVLB  6
010EE:  ADDWF  01,W
010F0:  MOVWF  01
010F2:  MOVLW  00
010F4:  ADDWFC 02,W
010F6:  MOVWF  03
010F8:  MOVF   01,W
010FA:  ADDLW  A0
010FC:  MOVWF  FE9
010FE:  MOVLW  01
01100:  ADDWFC 03,W
01102:  MOVWF  FEA
01104:  CLRF   FEF
....................       SERcmd[recNum].recWriteIndex = 0;
01106:  CLRF   x6A
01108:  MOVFF  629,669
0110C:  CLRF   x6C
0110E:  MOVLW  B5
01110:  MOVWF  x6B
01112:  MOVLB  0
01114:  RCALL  0FC4
01116:  MOVFF  01,62B
0111A:  MOVLW  04
0111C:  MOVLB  6
0111E:  ADDWF  01,W
01120:  MOVWF  01
01122:  MOVLW  00
01124:  ADDWFC 02,W
01126:  MOVWF  03
01128:  MOVF   01,W
0112A:  ADDLW  A0
0112C:  MOVWF  FE9
0112E:  MOVLW  01
01130:  ADDWFC 03,W
01132:  MOVWF  FEA
01134:  CLRF   FEF
....................       SERcmd[recNum].full = FALSE;
01136:  CLRF   x6A
01138:  MOVFF  629,669
0113C:  CLRF   x6C
0113E:  MOVLW  B5
01140:  MOVWF  x6B
01142:  MOVLB  0
01144:  RCALL  0FC4
01146:  MOVLW  A0
01148:  MOVLB  6
0114A:  ADDWF  01,W
0114C:  MOVWF  FE9
0114E:  MOVLW  01
01150:  ADDWFC 02,W
01152:  MOVWF  FEA
01154:  BCF    FEF.0
....................       retData[0] = '\0';
01156:  MOVLB  4
01158:  CLRF   x76
0115A:  MOVLB  6
....................    }
0115C:  MOVLB  0
0115E:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next serial read index (SRI)                                          */
.................... /*****************************************************************************/
.................... BOOLEAN getNextSERReadIndex()
.................... {
....................    while (!SERcmd[SRI].full)
*
061CC:  MOVLB  6
061CE:  CLRF   x6A
061D0:  MOVFF  474,669
061D4:  CLRF   x6C
061D6:  MOVLW  B5
061D8:  MOVWF  x6B
061DA:  MOVLB  0
061DC:  CALL   0FC4
061E0:  MOVFF  02,62A
061E4:  MOVFF  01,629
061E8:  MOVLW  A0
061EA:  MOVLB  6
061EC:  ADDWF  01,W
061EE:  MOVWF  FE9
061F0:  MOVLW  01
061F2:  ADDWFC 02,W
061F4:  MOVWF  FEA
061F6:  BTFSC  FEF.0
061F8:  BRA    621A
....................    {
....................       if (SRI == SWI) return FALSE;
061FA:  MOVLB  4
061FC:  MOVF   x75,W
061FE:  SUBWF  x74,W
06200:  BNZ   6208
06202:  MOVLW  00
06204:  MOVWF  01
06206:  BRA    6220
....................       SRI +=1;
06208:  MOVLW  01
0620A:  ADDWF  x74,F
....................       if (SRI >= numRecords) SRI=0;
0620C:  MOVF   x74,W
0620E:  SUBLW  03
06210:  BC    6214
06212:  CLRF   x74
06214:  MOVLB  0
06216:  BRA    61CC
06218:  MOVLB  6
....................    }
....................    return TRUE;
0621A:  MOVLW  01
0621C:  MOVWF  01
0621E:  MOVLB  4
06220:  MOVLB  0
06222:  GOTO   A9E2 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next serial write index (SWI)                                         */
.................... /*****************************************************************************/
.................... void setNextSERWriteIndex()
.................... {
....................    SWI +=1;
*
05858:  MOVLW  01
0585A:  MOVLB  4
0585C:  ADDWF  x75,F
....................    if (SWI >= numRecords) SWI=0;
0585E:  MOVF   x75,W
05860:  SUBLW  03
05862:  BC    5866
05864:  CLRF   x75
05866:  MOVLB  0
05868:  RETURN 0
.................... }
.................... #endif
.................... 
.................... #ifdef useTCPIP
.................... /*****************************************************************************/
.................... /* RESET TCP COMMAND -- ready for a new command                              */
.................... /*****************************************************************************/
.................... void resetTCPcmd(unsigned int8 recNum)
.................... {
....................    if(recNum < numRecords)
....................    {
....................       for (int i = 0; i <numParam; i ++)
....................       {
....................          TCPcmd[recNum].p[i][0] = '\0';
....................       }
....................       TCPcmd[recNum].t = 0;
....................       TCPcmd[recNum].chrIndex = 0;
....................       TCPcmd[recNum].paramIndex = 0;
....................       TCPcmd[recNum].full = FALSE;
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next TCP read index (TRI)                                             */
.................... /*****************************************************************************/
.................... BOOLEAN getNextTCPReadIndex()
.................... {
....................    while (!TCPcmd[TRI].full)
....................    {
....................       if (TRI == TWI) return FALSE;
....................       TRI +=1;
....................       if (TRI >= numRecords) TRI=0;
....................    }
....................    return TRUE;
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next TCP write index (TWI)                                            */
.................... /*****************************************************************************/
.................... void setNextTCPWriteIndex()
.................... {
....................    TWI +=1;
....................    if (TWI >= numRecords) TWI=0;
.................... }
.................... #endif
.................... #endif
.................... 
.................... 
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
....................    output_b(portB_reset);
....................    output_c(portC_reset);
....................    output_d(portD_reset);
....................    output_e(portE_reset);
....................    
....................    port_a_pullups(portA_pullups);
....................    port_b_pullups(portB_pullups);
....................    port_c_pullups(portC_pullups);
....................    port_d_pullups(portD_pullups);
....................    port_e_pullups(portE_pullups);
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... #define use_RS485 // adds RX enable pin//
.................... 
.................... #define oneByteCmdTestValue 128
.................... #define UART_BUFFER_SIZE 60
.................... #define UART_EOT_CHAR1 0x0D //Carriage Return
.................... #define UART_EOT_CHAR2 0x0A //Line Feed
.................... #define UART_SOT_CHAR  '~' // START CHARACTER
.................... #define line_turnaround_char 0xFF
.................... 
.................... #bit UART_TXBuffer_Empty = 0x0FAC.1
.................... 
.................... char UART_BUFFER[UART_BUFFER_SIZE] = {0};
.................... unsigned int8 UART_WR_PTR = 0;
.................... unsigned int8 UART_RD_PTR = 0;
.................... boolean BYTES_AVAILABLE= FALSE;
.................... 
.................... #ifdef use_RS485
.................... #use rs232(baud=baudRate, xmit=TX_PIN, rcv=RX_PIN, enable=TX_ENABLE, stream=SERIAL, ERRORS)
*
000CA:  MOVLB  E
000CC:  BTFSS  xC8.5
000CE:  BRA    00CC
000D0:  MOVFF  F9C,519
000D4:  MOVLB  5
000D6:  MOVFF  F98,01
000DA:  BTFSS  x19.1
000DC:  BRA    00E2
000DE:  BCF    F9C.4
000E0:  BSF    F9C.4
000E2:  MOVLB  0
000E4:  GOTO   010C (RETURN)
*
0586A:  MOVLW  93
0586C:  MOVWF  F89
0586E:  BSF    F84.5
05870:  MOVLB  E
05872:  BTFSS  xC8.4
05874:  BRA    5872
05876:  MOVLW  93
05878:  MOVWF  F89
0587A:  BSF    F84.5
0587C:  MOVLB  6
0587E:  MOVFF  63E,F99
05882:  NOP   
05884:  BTFSS  F9D.1
05886:  BRA    5884
05888:  MOVLW  93
0588A:  MOVWF  F89
0588C:  BCF    F84.5
0588E:  MOVLB  0
05890:  RETURN 0
.................... #else
.................... #use rs232(baud=baudRate, xmit=TX_PIN, rcv=RX_PIN, stream=SERIAL)
.................... #endif
.................... 
.................... // Message format: [SOT]addr ,cmd, arg1, arg2, arg3[EOT]} 
.................... // arguments are optional
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* SERIAL PORT ISR                                                           */
.................... /*****************************************************************************/
.................... #INT_RDA
.................... void RX_isr()
*
000E8:  MOVLB  0
.................... {
....................    while (kbhit())
000EA:  MOVLB  E
000EC:  BTFSS  xC8.5
000EE:  BRA    012E
....................    {
....................       UART_BUFFER[UART_WR_PTR]=getch();
000F0:  CLRF   03
000F2:  MOVLB  5
000F4:  MOVF   x16,W
000F6:  ADDLW  DA
000F8:  MOVWF  FE9
000FA:  MOVLW  04
000FC:  ADDWFC 03,W
000FE:  MOVWF  FEA
00100:  MOVFF  FEA,69A
00104:  MOVFF  FE9,699
00108:  MOVLB  0
0010A:  BRA    00CA
0010C:  MOVFF  69A,FEA
00110:  MOVFF  699,FE9
00114:  MOVFF  01,FEF
....................       UART_WR_PTR +=1;
00118:  MOVLW  01
0011A:  MOVLB  5
0011C:  ADDWF  x16,F
....................       if (UART_WR_PTR>=UART_BUFFER_SIZE) UART_WR_PTR=0;
0011E:  MOVF   x16,W
00120:  SUBLW  3B
00122:  BC    0126
00124:  CLRF   x16
....................       BYTES_AVAILABLE=TRUE;
00126:  BSF    x18.0
00128:  MOVLB  0
0012A:  BRA    00EA
0012C:  MOVLB  E
....................    }
0012E:  BCF    xC8.5
00130:  MOVLB  0
00132:  GOTO   006E
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get character from buffer                                                 */
.................... /*****************************************************************************/
.................... char getchFromBuffer()
*
05824:  CLRF   03
05826:  MOVLB  5
05828:  MOVF   x17,W
0582A:  ADDLW  DA
0582C:  MOVWF  FE9
0582E:  MOVLW  04
05830:  ADDWFC 03,W
05832:  MOVWF  FEA
05834:  MOVFF  FEF,629
.................... {
....................    char data = UART_BUFFER[UART_RD_PTR];
....................    UART_RD_PTR +=1;
05838:  MOVLW  01
0583A:  ADDWF  x17,F
....................    if (UART_RD_PTR>=UART_BUFFER_SIZE) UART_RD_PTR=0;
0583C:  MOVF   x17,W
0583E:  SUBLW  3B
05840:  BC    5844
05842:  CLRF   x17
....................    if (UART_RD_PTR == UART_WR_PTR) BYTES_AVAILABLE=FALSE;
05844:  MOVF   x16,W
05846:  SUBWF  x17,W
05848:  BNZ   584C
0584A:  BCF    x18.0
....................    return data;
0584C:  MOVLB  6
0584E:  MOVFF  629,01
05852:  MOVLB  0
05854:  GOTO   58F8 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Serial Task transfers bytes to command buffer                             */
.................... /*****************************************************************************/
.................... void serial_task()
.................... {
....................    while(BYTES_AVAILABLE && SERcmd[SWI].full==FALSE)
*
058B6:  MOVLB  5
058B8:  BTFSS  x18.0
058BA:  BRA    5DA8
058BC:  MOVLB  6
058BE:  CLRF   x6A
058C0:  MOVFF  475,669
058C4:  CLRF   x6C
058C6:  MOVLW  B5
058C8:  MOVWF  x6B
058CA:  MOVLB  0
058CC:  CALL   0FC4
058D0:  MOVFF  02,62A
058D4:  MOVFF  01,629
058D8:  MOVLW  A0
058DA:  MOVLB  6
058DC:  ADDWF  01,W
058DE:  MOVWF  01
058E0:  MOVLW  01
058E2:  ADDWFC 02,W
058E4:  MOVWF  03
058E6:  MOVFF  01,FE9
058EA:  MOVWF  FEA
058EC:  BTFSS  FEF.0
058EE:  BRA    58F4
058F0:  MOVLB  5
058F2:  BRA    5DA8
....................    {  
....................       unsigned int8 rxChar = getchFromBuffer();
058F4:  MOVLB  0
058F6:  BRA    5824
058F8:  MOVFF  01,628
....................       if (rxChar == ignoreChr1 || rxChar == ignoreChr2)
058FC:  MOVLB  6
058FE:  MOVF   x28,W
05900:  SUBLW  0D
05902:  BZ    590A
05904:  MOVF   x28,W
05906:  SUBLW  20
05908:  BNZ   590C
....................       {
....................       }
0590A:  BRA    5DA2
....................       else if (rxChar == UART_SOT_CHAR)
0590C:  MOVF   x28,W
0590E:  SUBLW  7E
05910:  BNZ   5954
....................       {
....................          resetSERcmd(SWI);
05912:  MOVFF  475,629
05916:  MOVLB  0
05918:  CALL   0FE6
....................          SERcmd[SWI].t = rxChar;
0591C:  MOVLB  6
0591E:  CLRF   x6A
05920:  MOVFF  475,669
05924:  CLRF   x6C
05926:  MOVLW  B5
05928:  MOVWF  x6B
0592A:  MOVLB  0
0592C:  CALL   0FC4
05930:  MOVFF  01,629
05934:  MOVLW  05
05936:  MOVLB  6
05938:  ADDWF  01,W
0593A:  MOVWF  01
0593C:  MOVLW  00
0593E:  ADDWFC 02,W
05940:  MOVWF  03
05942:  MOVF   01,W
05944:  ADDLW  A0
05946:  MOVWF  FE9
05948:  MOVLW  01
0594A:  ADDWFC 03,W
0594C:  MOVWF  FEA
0594E:  MOVFF  628,FEF
....................       }
05952:  BRA    5DA2
....................       else if (rxChar >= oneByteCmdTestValue)
05954:  MOVF   x28,W
05956:  SUBLW  7F
05958:  BC    59C4
....................       {
....................          resetSERcmd(SWI);
0595A:  MOVFF  475,629
0595E:  MOVLB  0
05960:  CALL   0FE6
....................          SERcmd[SWI].t = rxChar;
05964:  MOVLB  6
05966:  CLRF   x6A
05968:  MOVFF  475,669
0596C:  CLRF   x6C
0596E:  MOVLW  B5
05970:  MOVWF  x6B
05972:  MOVLB  0
05974:  CALL   0FC4
05978:  MOVFF  01,629
0597C:  MOVLW  05
0597E:  MOVLB  6
05980:  ADDWF  01,W
05982:  MOVWF  01
05984:  MOVLW  00
05986:  ADDWFC 02,W
05988:  MOVWF  03
0598A:  MOVF   01,W
0598C:  ADDLW  A0
0598E:  MOVWF  FE9
05990:  MOVLW  01
05992:  ADDWFC 03,W
05994:  MOVWF  FEA
05996:  MOVFF  628,FEF
....................          SERcmd[SWI].full = TRUE;
0599A:  CLRF   x6A
0599C:  MOVFF  475,669
059A0:  CLRF   x6C
059A2:  MOVLW  B5
059A4:  MOVWF  x6B
059A6:  MOVLB  0
059A8:  CALL   0FC4
059AC:  MOVLW  A0
059AE:  MOVLB  6
059B0:  ADDWF  01,W
059B2:  MOVWF  FE9
059B4:  MOVLW  01
059B6:  ADDWFC 02,W
059B8:  MOVWF  FEA
059BA:  BSF    FEF.0
....................          setNextSERWriteIndex();
059BC:  MOVLB  0
059BE:  RCALL  5858
....................       }
059C0:  BRA    5DA0
059C2:  MOVLB  6
....................       else if (rxChar == UART_EOT_CHAR2)
059C4:  MOVF   x28,W
059C6:  SUBLW  0A
059C8:  BTFSS  FD8.2
059CA:  BRA    5AD0
....................       {
....................          SERcmd[SWI].full = TRUE;
059CC:  CLRF   x6A
059CE:  MOVFF  475,669
059D2:  CLRF   x6C
059D4:  MOVLW  B5
059D6:  MOVWF  x6B
059D8:  MOVLB  0
059DA:  CALL   0FC4
059DE:  MOVLW  A0
059E0:  MOVLB  6
059E2:  ADDWF  01,W
059E4:  MOVWF  FE9
059E6:  MOVLW  01
059E8:  ADDWFC 02,W
059EA:  MOVWF  FEA
059EC:  BSF    FEF.0
....................          SERcmd[SWI].recWriteIndex = SERcmd[SWI].paramIndex;
059EE:  CLRF   x6A
059F0:  MOVFF  475,669
059F4:  CLRF   x6C
059F6:  MOVLW  B5
059F8:  MOVWF  x6B
059FA:  MOVLB  0
059FC:  CALL   0FC4
05A00:  MOVFF  01,629
05A04:  MOVLW  04
05A06:  MOVLB  6
05A08:  ADDWF  01,W
05A0A:  MOVWF  01
05A0C:  MOVLW  00
05A0E:  ADDWFC 02,W
05A10:  MOVWF  03
05A12:  MOVF   01,W
05A14:  ADDLW  A0
05A16:  MOVWF  01
05A18:  MOVLW  01
05A1A:  ADDWFC 03,F
05A1C:  MOVFF  01,629
05A20:  MOVFF  03,62A
05A24:  CLRF   x6A
05A26:  MOVFF  475,669
05A2A:  CLRF   x6C
05A2C:  MOVLW  B5
05A2E:  MOVWF  x6B
05A30:  MOVLB  0
05A32:  CALL   0FC4
05A36:  MOVFF  01,62B
05A3A:  MOVLW  02
05A3C:  MOVLB  6
05A3E:  ADDWF  01,W
05A40:  MOVWF  01
05A42:  MOVLW  00
05A44:  ADDWFC 02,W
05A46:  MOVWF  03
05A48:  MOVF   01,W
05A4A:  ADDLW  A0
05A4C:  MOVWF  FE9
05A4E:  MOVLW  01
05A50:  ADDWFC 03,W
05A52:  MOVWF  FEA
05A54:  MOVFF  FEF,62B
05A58:  MOVFF  62A,FEA
05A5C:  MOVFF  629,FE9
05A60:  MOVFF  62B,FEF
....................          SERcmd[SWI].chrIndex = 0;
05A64:  CLRF   x6A
05A66:  MOVFF  475,669
05A6A:  CLRF   x6C
05A6C:  MOVLW  B5
05A6E:  MOVWF  x6B
05A70:  MOVLB  0
05A72:  CALL   0FC4
05A76:  MOVFF  01,629
05A7A:  MOVLW  01
05A7C:  MOVLB  6
05A7E:  ADDWF  01,W
05A80:  MOVWF  01
05A82:  MOVLW  00
05A84:  ADDWFC 02,W
05A86:  MOVWF  03
05A88:  MOVF   01,W
05A8A:  ADDLW  A0
05A8C:  MOVWF  FE9
05A8E:  MOVLW  01
05A90:  ADDWFC 03,W
05A92:  MOVWF  FEA
05A94:  CLRF   FEF
....................          SERcmd[SWI].paramIndex = 0;
05A96:  CLRF   x6A
05A98:  MOVFF  475,669
05A9C:  CLRF   x6C
05A9E:  MOVLW  B5
05AA0:  MOVWF  x6B
05AA2:  MOVLB  0
05AA4:  CALL   0FC4
05AA8:  MOVFF  01,629
05AAC:  MOVLW  02
05AAE:  MOVLB  6
05AB0:  ADDWF  01,W
05AB2:  MOVWF  01
05AB4:  MOVLW  00
05AB6:  ADDWFC 02,W
05AB8:  MOVWF  03
05ABA:  MOVF   01,W
05ABC:  ADDLW  A0
05ABE:  MOVWF  FE9
05AC0:  MOVLW  01
05AC2:  ADDWFC 03,W
05AC4:  MOVWF  FEA
05AC6:  CLRF   FEF
....................          setNextSERWriteIndex();
05AC8:  MOVLB  0
05ACA:  RCALL  5858
....................       }
05ACC:  BRA    5DA0
05ACE:  MOVLB  6
....................       else if (rxChar == delimiter)
05AD0:  MOVF   x28,W
05AD2:  SUBLW  2C
05AD4:  BNZ   5B92
....................       {
....................          if (SERcmd[SWI].paramIndex < numParam-1)
05AD6:  CLRF   x6A
05AD8:  MOVFF  475,669
05ADC:  CLRF   x6C
05ADE:  MOVLW  B5
05AE0:  MOVWF  x6B
05AE2:  MOVLB  0
05AE4:  CALL   0FC4
05AE8:  MOVFF  02,62A
05AEC:  MOVFF  01,629
05AF0:  MOVLW  02
05AF2:  MOVLB  6
05AF4:  ADDWF  01,W
05AF6:  MOVWF  01
05AF8:  MOVLW  00
05AFA:  ADDWFC 02,W
05AFC:  MOVWF  03
05AFE:  MOVF   01,W
05B00:  ADDLW  A0
05B02:  MOVWF  FE9
05B04:  MOVLW  01
05B06:  ADDWFC 03,W
05B08:  MOVWF  FEA
05B0A:  MOVF   FEF,W
05B0C:  SUBLW  05
05B0E:  BNC   5B7A
....................          {
....................             SERcmd[SWI].paramIndex +=1;
05B10:  CLRF   x6A
05B12:  MOVFF  475,669
05B16:  CLRF   x6C
05B18:  MOVLW  B5
05B1A:  MOVWF  x6B
05B1C:  MOVLB  0
05B1E:  CALL   0FC4
05B22:  MOVFF  01,629
05B26:  MOVLW  02
05B28:  MOVLB  6
05B2A:  ADDWF  01,W
05B2C:  MOVWF  01
05B2E:  MOVLW  00
05B30:  ADDWFC 02,W
05B32:  MOVWF  03
05B34:  MOVF   01,W
05B36:  ADDLW  A0
05B38:  MOVWF  FE9
05B3A:  MOVLW  01
05B3C:  ADDWFC 03,W
05B3E:  MOVWF  FEA
05B40:  MOVLW  01
05B42:  ADDWF  FEF,W
05B44:  MOVWF  FEF
....................             SERcmd[SWI].chrIndex = 0;
05B46:  CLRF   x6A
05B48:  MOVFF  475,669
05B4C:  CLRF   x6C
05B4E:  MOVLW  B5
05B50:  MOVWF  x6B
05B52:  MOVLB  0
05B54:  CALL   0FC4
05B58:  MOVFF  01,629
05B5C:  MOVLW  01
05B5E:  MOVLB  6
05B60:  ADDWF  01,W
05B62:  MOVWF  01
05B64:  MOVLW  00
05B66:  ADDWFC 02,W
05B68:  MOVWF  03
05B6A:  MOVF   01,W
05B6C:  ADDLW  A0
05B6E:  MOVWF  FE9
05B70:  MOVLW  01
05B72:  ADDWFC 03,W
05B74:  MOVWF  FEA
05B76:  CLRF   FEF
....................          }
05B78:  BRA    5B90
....................          else
....................          {
....................             resetSERcmd(SWI); // exceed number of params... reset capture
05B7A:  MOVFF  475,629
05B7E:  MOVLB  0
05B80:  CALL   0FE6
....................             fprintf(SERIAL, retData);
05B84:  MOVLW  04
05B86:  MOVWF  FEA
05B88:  MOVLW  76
05B8A:  MOVWF  FE9
05B8C:  RCALL  5892
05B8E:  MOVLB  6
....................          }
....................       }
05B90:  BRA    5DA2
....................       
....................       else
....................       {
....................          if (SERcmd[SWI].chrIndex < lenParam)
05B92:  CLRF   x6A
05B94:  MOVFF  475,669
05B98:  CLRF   x6C
05B9A:  MOVLW  B5
05B9C:  MOVWF  x6B
05B9E:  MOVLB  0
05BA0:  CALL   0FC4
05BA4:  MOVFF  02,62A
05BA8:  MOVFF  01,629
05BAC:  MOVLW  01
05BAE:  MOVLB  6
05BB0:  ADDWF  01,W
05BB2:  MOVWF  01
05BB4:  MOVLW  00
05BB6:  ADDWFC 02,W
05BB8:  MOVWF  03
05BBA:  MOVF   01,W
05BBC:  ADDLW  A0
05BBE:  MOVWF  FE9
05BC0:  MOVLW  01
05BC2:  ADDWFC 03,W
05BC4:  MOVWF  FEA
05BC6:  MOVF   FEF,W
05BC8:  SUBLW  18
05BCA:  BTFSS  FD8.0
05BCC:  BRA    5D8C
....................          {
....................             SERcmd[SWI].p[SERcmd[SWI].paramIndex][SERcmd[SWI].chrIndex] = rxChar;
05BCE:  CLRF   x6A
05BD0:  MOVFF  475,669
05BD4:  CLRF   x6C
05BD6:  MOVLW  B5
05BD8:  MOVWF  x6B
05BDA:  MOVLB  0
05BDC:  CALL   0FC4
05BE0:  MOVFF  02,62A
05BE4:  MOVFF  01,629
05BE8:  MOVLW  06
05BEA:  MOVLB  6
05BEC:  ADDWF  x29,F
05BEE:  MOVLW  00
05BF0:  ADDWFC x2A,F
05BF2:  CLRF   x6A
05BF4:  MOVFF  475,669
05BF8:  CLRF   x6C
05BFA:  MOVLW  B5
05BFC:  MOVWF  x6B
05BFE:  MOVLB  0
05C00:  CALL   0FC4
05C04:  MOVFF  02,62C
05C08:  MOVFF  01,62B
05C0C:  MOVLW  02
05C0E:  MOVLB  6
05C10:  ADDWF  01,W
05C12:  MOVWF  01
05C14:  MOVLW  00
05C16:  ADDWFC 02,W
05C18:  MOVWF  03
05C1A:  MOVF   01,W
05C1C:  ADDLW  A0
05C1E:  MOVWF  FE9
05C20:  MOVLW  01
05C22:  ADDWFC 03,W
05C24:  MOVWF  FEA
05C26:  CLRF   x6A
05C28:  MOVFF  FEF,669
05C2C:  CLRF   x6C
05C2E:  MOVLW  19
05C30:  MOVWF  x6B
05C32:  MOVLB  0
05C34:  CALL   0FC4
05C38:  MOVFF  02,03
05C3C:  MOVF   01,W
05C3E:  MOVLB  6
05C40:  ADDWF  x29,F
05C42:  MOVF   02,W
05C44:  ADDWFC x2A,F
05C46:  CLRF   x6A
05C48:  MOVFF  475,669
05C4C:  CLRF   x6C
05C4E:  MOVLW  B5
05C50:  MOVWF  x6B
05C52:  MOVLB  0
05C54:  CALL   0FC4
05C58:  MOVFF  01,62B
05C5C:  MOVLW  01
05C5E:  MOVLB  6
05C60:  ADDWF  01,W
05C62:  MOVWF  01
05C64:  MOVLW  00
05C66:  ADDWFC 02,W
05C68:  MOVWF  03
05C6A:  MOVF   01,W
05C6C:  ADDLW  A0
05C6E:  MOVWF  FE9
05C70:  MOVLW  01
05C72:  ADDWFC 03,W
05C74:  MOVWF  FEA
05C76:  MOVF   FEF,W
05C78:  ADDWF  x29,W
05C7A:  MOVWF  01
05C7C:  MOVLW  00
05C7E:  ADDWFC x2A,W
05C80:  MOVWF  03
05C82:  MOVF   01,W
05C84:  ADDLW  A0
05C86:  MOVWF  FE9
05C88:  MOVLW  01
05C8A:  ADDWFC 03,W
05C8C:  MOVWF  FEA
05C8E:  MOVFF  628,FEF
....................             SERcmd[SWI].chrIndex += 1;
05C92:  CLRF   x6A
05C94:  MOVFF  475,669
05C98:  CLRF   x6C
05C9A:  MOVLW  B5
05C9C:  MOVWF  x6B
05C9E:  MOVLB  0
05CA0:  CALL   0FC4
05CA4:  MOVFF  01,629
05CA8:  MOVLW  01
05CAA:  MOVLB  6
05CAC:  ADDWF  01,W
05CAE:  MOVWF  01
05CB0:  MOVLW  00
05CB2:  ADDWFC 02,W
05CB4:  MOVWF  03
05CB6:  MOVF   01,W
05CB8:  ADDLW  A0
05CBA:  MOVWF  FE9
05CBC:  MOVLW  01
05CBE:  ADDWFC 03,W
05CC0:  MOVWF  FEA
05CC2:  MOVLW  01
05CC4:  ADDWF  FEF,W
05CC6:  MOVWF  FEF
....................             SERcmd[SWI].p[SERcmd[SWI].paramIndex][SERcmd[SWI].chrIndex] = '\0';
05CC8:  CLRF   x6A
05CCA:  MOVFF  475,669
05CCE:  CLRF   x6C
05CD0:  MOVLW  B5
05CD2:  MOVWF  x6B
05CD4:  MOVLB  0
05CD6:  CALL   0FC4
05CDA:  MOVFF  02,62A
05CDE:  MOVFF  01,629
05CE2:  MOVLW  06
05CE4:  MOVLB  6
05CE6:  ADDWF  x29,F
05CE8:  MOVLW  00
05CEA:  ADDWFC x2A,F
05CEC:  CLRF   x6A
05CEE:  MOVFF  475,669
05CF2:  CLRF   x6C
05CF4:  MOVLW  B5
05CF6:  MOVWF  x6B
05CF8:  MOVLB  0
05CFA:  CALL   0FC4
05CFE:  MOVFF  02,62C
05D02:  MOVFF  01,62B
05D06:  MOVLW  02
05D08:  MOVLB  6
05D0A:  ADDWF  01,W
05D0C:  MOVWF  01
05D0E:  MOVLW  00
05D10:  ADDWFC 02,W
05D12:  MOVWF  03
05D14:  MOVF   01,W
05D16:  ADDLW  A0
05D18:  MOVWF  FE9
05D1A:  MOVLW  01
05D1C:  ADDWFC 03,W
05D1E:  MOVWF  FEA
05D20:  CLRF   x6A
05D22:  MOVFF  FEF,669
05D26:  CLRF   x6C
05D28:  MOVLW  19
05D2A:  MOVWF  x6B
05D2C:  MOVLB  0
05D2E:  CALL   0FC4
05D32:  MOVFF  02,03
05D36:  MOVF   01,W
05D38:  MOVLB  6
05D3A:  ADDWF  x29,F
05D3C:  MOVF   02,W
05D3E:  ADDWFC x2A,F
05D40:  CLRF   x6A
05D42:  MOVFF  475,669
05D46:  CLRF   x6C
05D48:  MOVLW  B5
05D4A:  MOVWF  x6B
05D4C:  MOVLB  0
05D4E:  CALL   0FC4
05D52:  MOVFF  01,62B
05D56:  MOVLW  01
05D58:  MOVLB  6
05D5A:  ADDWF  01,W
05D5C:  MOVWF  01
05D5E:  MOVLW  00
05D60:  ADDWFC 02,W
05D62:  MOVWF  03
05D64:  MOVF   01,W
05D66:  ADDLW  A0
05D68:  MOVWF  FE9
05D6A:  MOVLW  01
05D6C:  ADDWFC 03,W
05D6E:  MOVWF  FEA
05D70:  MOVF   FEF,W
05D72:  ADDWF  x29,W
05D74:  MOVWF  01
05D76:  MOVLW  00
05D78:  ADDWFC x2A,W
05D7A:  MOVWF  03
05D7C:  MOVF   01,W
05D7E:  ADDLW  A0
05D80:  MOVWF  FE9
05D82:  MOVLW  01
05D84:  ADDWFC 03,W
05D86:  MOVWF  FEA
05D88:  CLRF   FEF
....................          }
05D8A:  BRA    5DA2
....................          else
....................          {
....................             resetSERcmd(SWI); // exceed number of characters... reset capture
05D8C:  MOVFF  475,629
05D90:  MOVLB  0
05D92:  CALL   0FE6
....................             fprintf(SERIAL, retData);
05D96:  MOVLW  04
05D98:  MOVWF  FEA
05D9A:  MOVLW  76
05D9C:  MOVWF  FE9
05D9E:  RCALL  5892
05DA0:  MOVLB  6
....................          }
....................       }
05DA2:  MOVLB  0
05DA4:  BRA    58B6
05DA6:  MOVLB  5
....................    }          
05DA8:  MOVLB  0
05DAA:  GOTO   AEA4 (RETURN)
.................... }
....................            
.................... /*****************************************************************************/
.................... /* serialInit ROUTINE  - Sets up serial port                                 */
.................... /*****************************************************************************/ 
.................... void serial_init()
.................... {
....................    for (int i = 0; i < numRecords; i++) 
*
01160:  MOVLB  6
01162:  CLRF   x28
01164:  MOVF   x28,W
01166:  SUBLW  03
01168:  BNC   1178
....................    {
....................       resetSERcmd(i);
0116A:  MOVFF  628,629
0116E:  MOVLB  0
01170:  RCALL  0FE6
01172:  MOVLB  6
01174:  INCF   x28,F
01176:  BRA    1164
....................    }
....................    enable_interrupts(INT_RDA);
01178:  MOVLB  E
0117A:  BSF    xC0.5
0117C:  MOVLB  0
0117E:  GOTO   AE8C (RETURN)
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #include <pid.h>
.................... #ifndef pidcontroller
.................... #define pidcontroller
.................... #include <parameters.h>
.................... #include <math.h>
.................... 
.................... /*****************************************************************************/
.................... /* UPDATE the Control Variable (CV)                                          */
.................... /*****************************************************************************/
.................... void pid_update (channelMap ch){
....................    float err = PID[ch].SP - PID[ch].PV;  // error = set value - measured
....................    
....................    PID[ch].I += err*PID[ch].kI;
....................    if (PID[ch].I > op_upper_bound) PID[ch].I = op_upper_bound; // anti-windup
....................    else if (PID[ch].I < op_lower_bound) PID[ch].I = op_lower_bound;
....................    
....................    float P = err * PID[ch].kP;  // proportional value
....................    
....................    float D = PID[ch].kD * (PID[ch].PV - PID[ch].PVold);  // derivative value
....................    
....................    PID[ch].CV = P + PID[ch].I + D;  // new control variable
....................    if (PID[ch].CV > op_upper_bound) PID[ch].CV = op_upper_bound; // limit positive output
....................    else if (PID[ch].CV < op_lower_bound) PID[ch].CV = op_lower_bound; // limit negative output
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PID Task - looks for change to PV and updates CV                          */
.................... /*****************************************************************************/
.................... void pid_task(channelMap ch){
....................    static int index = 0;
....................    if (PID[ch].SP != PID[ch].PV) pid_update(ch);
....................    if ((index++) >= numChannels) index = 0;
.................... }
.................... 
.................... #endif
.................... 
.................... #include <eventTimer.h>
.................... #ifndef timeout
.................... #define timeout
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0.3,0.1,0,0,0,0,0},
....................    {0.01,0.3,0.1,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/           
.................... /* Global timers used by all routnes                                         */
.................... /* timeoutReg0-2 are used for timeouts. Other routines monitor the value of  */
.................... /* intTimeoutReg. On boot, they will be loaded from EEProm. Any              */
.................... /* configuration changes will be changed in EEprom, hence will be restored on*/
.................... /* subsequent boot.                                                          */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* Register definitions                                                      */
.................... /*****************************************************************************/
.................... //!unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... //!unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... //!unsigned int32 timeoutReg2 = 0;
.................... //!unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... unsigned int32 timeCounter = 0;
.................... 
.................... /*****************************************************************************/
.................... /* TIMEOUT_INIT initializes the timer                                        */
.................... /*****************************************************************************/
.................... void event_timer_init()
.................... {        
....................    disable_interrupts(INT_TIMER1);
01182:  MOVLB  E
01184:  BCF    xC1.0
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_1);
01186:  MOVLW  01
01188:  MOVWF  FD1
0118A:  MOVLW  07
0118C:  MOVWF  FCE
0118E:  CLRF   FCF
01190:  CLRF   FD0
....................    timeoutReg0 = 0;  // clear all the timers
01192:  MOVLB  1
01194:  CLRF   x5A
01196:  CLRF   x59
01198:  CLRF   x58
0119A:  CLRF   x57
....................    timeoutReg1 = 0;
0119C:  CLRF   x5E
0119E:  CLRF   x5D
011A0:  CLRF   x5C
011A2:  CLRF   x5B
....................    timeoutReg2 = 0;
011A4:  CLRF   x62
011A6:  CLRF   x61
011A8:  CLRF   x60
011AA:  CLRF   x5F
....................    intTimeoutReg = 50;
011AC:  CLRF   x64
011AE:  MOVLW  32
011B0:  MOVWF  x63
....................    enable_interrupts(INT_TIMER1);
011B2:  MOVLB  E
011B4:  BSF    xC1.0
011B6:  MOVLB  0
011B8:  GOTO   AE90 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* TIMEOUT INTERRUPT decrements the timeout registers every second           */
.................... /*****************************************************************************/
.................... #INT_TIMER1
.................... void TIMER1_isr(void) 
*
0025A:  MOVLB  0
.................... {
....................    set_timer1(0x0BDB); // load timer register to allow 10 millisecond interupts
0025C:  MOVLW  0B
0025E:  MOVWF  FCD
00260:  MOVLW  DB
00262:  MOVWF  FCC
00264:  NOP   
....................    if (timeoutReg0 > 10) timeoutReg0 -= 10; else timeoutReg0 = 0;
00266:  MOVLB  1
00268:  MOVF   x5A,F
0026A:  BNZ   027A
0026C:  MOVF   x59,F
0026E:  BNZ   027A
00270:  MOVF   x58,F
00272:  BNZ   027A
00274:  MOVF   x57,W
00276:  SUBLW  0A
00278:  BC    0288
0027A:  MOVLW  0A
0027C:  SUBWF  x57,F
0027E:  MOVLW  00
00280:  SUBWFB x58,F
00282:  SUBWFB x59,F
00284:  SUBWFB x5A,F
00286:  BRA    0290
00288:  CLRF   x5A
0028A:  CLRF   x59
0028C:  CLRF   x58
0028E:  CLRF   x57
....................    if (timeoutReg1 > 10) timeoutReg1 -= 10; else timeoutReg1 = 0;
00290:  MOVF   x5E,F
00292:  BNZ   02A2
00294:  MOVF   x5D,F
00296:  BNZ   02A2
00298:  MOVF   x5C,F
0029A:  BNZ   02A2
0029C:  MOVF   x5B,W
0029E:  SUBLW  0A
002A0:  BC    02B0
002A2:  MOVLW  0A
002A4:  SUBWF  x5B,F
002A6:  MOVLW  00
002A8:  SUBWFB x5C,F
002AA:  SUBWFB x5D,F
002AC:  SUBWFB x5E,F
002AE:  BRA    02B8
002B0:  CLRF   x5E
002B2:  CLRF   x5D
002B4:  CLRF   x5C
002B6:  CLRF   x5B
....................    if (timeoutReg2 > 10) timeoutReg2 -= 10; else timeoutReg2 = 0;
002B8:  MOVF   x62,F
002BA:  BNZ   02CA
002BC:  MOVF   x61,F
002BE:  BNZ   02CA
002C0:  MOVF   x60,F
002C2:  BNZ   02CA
002C4:  MOVF   x5F,W
002C6:  SUBLW  0A
002C8:  BC    02D8
002CA:  MOVLW  0A
002CC:  SUBWF  x5F,F
002CE:  MOVLW  00
002D0:  SUBWFB x60,F
002D2:  SUBWFB x61,F
002D4:  SUBWFB x62,F
002D6:  BRA    02E0
002D8:  CLRF   x62
002DA:  CLRF   x61
002DC:  CLRF   x60
002DE:  CLRF   x5F
....................    if (intTimeoutReg != 0) // INTERRUPTING TIMER
002E0:  MOVF   x63,F
002E2:  BNZ   02E8
002E4:  MOVF   x64,F
002E6:  BZ    0324
....................    {
....................       timeCounter+=10;
002E8:  MOVLW  0A
002EA:  MOVLB  5
002EC:  ADDWF  x1C,F
002EE:  MOVLW  00
002F0:  ADDWFC x1D,F
002F2:  ADDWFC x1E,F
002F4:  ADDWFC x1F,F
....................       if (timeCounter >= intTimeoutReg)
002F6:  MOVF   x1F,F
002F8:  BNZ   0314
002FA:  MOVF   x1E,F
002FC:  BNZ   0314
002FE:  MOVLB  1
00300:  MOVF   x64,W
00302:  MOVLB  5
00304:  SUBWF  x1D,W
00306:  BNC   0322
00308:  BNZ   0314
0030A:  MOVLB  1
0030C:  MOVF   x63,W
0030E:  MOVLB  5
00310:  SUBWF  x1C,W
00312:  BNC   0322
....................       {
....................          sensor_monitor_interrupt_task();
00314:  MOVLB  0
00316:  BRA    01BE
....................          timeCounter = 0;
00318:  MOVLB  5
0031A:  CLRF   x1F
0031C:  CLRF   x1E
0031E:  CLRF   x1D
00320:  CLRF   x1C
00322:  MOVLB  1
....................       }
....................    }
.................... }
.................... 
.................... #endif
.................... 
.................... #include <commandHandler.c>
.................... #ifndef cmdHandlerC
.................... #define cmdHandlerC
.................... #include <commandHandler.h>
.................... #ifndef cmdHandler
.................... #define cmdHandler
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0.3,0.1,0,0,0,0,0},
....................    {0.01,0.3,0.1,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... 
00324:  MOVLB  E
00326:  BCF    xC9.0
00328:  MOVLB  0
0032A:  GOTO   006E
.................... #define hwID 'D'   // DiFCS
.................... 
.................... /*****************************************************************************/
.................... /* RESPONSE MESSAGES                                                         */
.................... /*****************************************************************************/
.................... typedef struct response {
....................    int8 id;
....................    char *msg;
.................... } resp;
.................... 
.................... //!#define INVALID_DATA "error - invalid data"
.................... //!#define invalidTime "error - invalid TO value"
.................... //!#define overrun "error - buffer overrun"
.................... //!#define dcVoltage "VDC:%f1"
.................... //!#define USBVoltage "VUSB:%f"
.................... //!#define USBupstream "VUSBup:%f"
.................... //!#define plus5V "5V Rail:%f"
.................... //!#define plus3V3 "3V3 Rai:%f"
.................... //!#define allVoltages "All Voltages = %f, %f, %f, %f, %f"
.................... //!#define USBdownstream "USB downstream status:\r\nPG:%s\r\nch0:%s\r\nch1:%s"
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC MESSGAGE DUMP                                                  */
.................... /*****************************************************************************/
.................... //!#define voltageMsg "V0:%f\r\nV1:%f\r\nV2:%f\r\nV3:%f\r\nV4:%f"
.................... //!#define TimerMsg "T0:%Lu\r\nT1:%Lu\r\nT2:%Lu\r\Tint:%Lu\r\nTtick:%Lu"
.................... //!#define ioStatusMsg "Inputs:%u\r\nOutputs:%u\r\nStatus:%u"
.................... //!#define diagnosticMsg "V0:%f\r\nV1:%f\r\nV2:%f\r\nV3:%f\r\nV4:%f\r\nT0:%Lu\r\nT1:%Lu\r\nT2:%Lu\r\nTint:%Lu\r\nTtick:%Lu\r\nInputs:%u\r\nOutputs:%u\r\nStatus:%u"
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC COMMAND PROTOTYPES                                             */
.................... /*****************************************************************************/
.................... int8 getRev(unsigned int8);                // gr 
.................... int8 getSN(unsigned int8);                 // gs
.................... 
.................... int8 getOPchMap(unsigned int8);            // gChMap,   {1|2}
.................... int8 setOPchMap(unsigned int8);            // sChMap,   {1|2}, {X|Y}
.................... 
.................... int8 getIPchMode(unsigned int8);           // gChMode,  {1|2}
.................... int8 setIPchMode(unsigned int8);           // sChMode,  {1|2}, {MANUAL|MAGSNS}
....................    
.................... int8 getPIDvals(unsigned int8);            // gPID,     {1|2}, {P|I|D}
.................... int8 setPIDvals(unsigned int8);            // sPID,     {1|2}, {P|I|D}, <float>
.................... 
.................... int8 enablePID(unsigned int8);             // enaPID,   {1|2}
.................... int8 disablePID(unsigned int8);            // disPID,   {1|2}
.................... 
.................... int8 getSetPoint(unsigned int8);           // gSP,      {1|2}
.................... int8 setSetPoint(unsigned int8);           // sSP,      {1|2}, <float>
.................... 
.................... int8 getAllSensorCalParams(unsigned int8); // gSCals,   {1|2}
.................... int8 getSensorCalParam(unsigned int8);     // gSCal,    {1|2}, {0|1|2|3|4|5}
.................... int8 setSensorCalParam(unsigned int8);     // sSCal,    {1|2}, {0|1|2|3|4|5}, <float>
.................... 
.................... int8 getMonitorCalParam(unsigned int8);    // gMCal,    {N15|200|5V6|5VA|3V6X|3V3A|3V3D}
.................... int8 setMonitorCalParam(unsigned int8);    // sMCal,    {N15|200|5V6|5VA|3V6X|3V3A|3V3D}, <float>, <float>
.................... int8 getMonitorValue(unsigned int8);       // gMon,     {N15|200|5V6|5VA|3V6X|3V3A|3V3D|all}
.................... 
.................... int8 getPIDdata(unsigned int8);            // gPIDdata, {1|2}, {PV|CV|PVold|I}
.................... 
.................... int8 getIPdata(unsigned int8);             // gIPdata,  {1|2}, {raw|calib|p0|poles|real}
....................    
.................... int8 getManOPvals(unsigned int8);          // gManOP,   {1|2}  
.................... int8 setManOPvals(unsigned int8);          // sManOP,   {1|2}, <float>  
.................... 
.................... int8 invalidCmd(unsigned int8);
.................... 
.................... struct command {
....................    char *cmd_name;
....................    int8 (*cmd_func)(unsigned int8);
.................... };
.................... 
.................... BOOLEAN arg_is_float(char *);
.................... BOOLEAN is_valid_channel(char *);
.................... int8 hex_to_int(char);
.................... void echo_cmd(unsigned int8 rec);
.................... int8 command_parser(unsigned int8 rec);
.................... void command_handler_task();
.................... 
.................... #endif
.................... 
.................... 
.................... /* LIST OF DIAGNOSTIC COMMAND KEYWORDS AND THEIR FUNCTIONS */
.................... struct command cmd_list[] = {
....................    {"gr",       &getRev},
....................    {"gs",       &getSN},
....................    {"gChMap",   &getOPchMap},
....................    {"sChMap",   &setOPchMap},
....................    {"gChMode",  &getIPchMode},
....................    {"sChMode",  &setIPchMode},
....................    {"gPID",     &getPIDvals},
....................    {"sPID",     &setPIDvals},
.................... //!   {"enaPID",   &enablePID},
.................... //!   {"disPID",   &disablePID},
....................    {"gSP",      &getSetPoint},
....................    {"sSP",      &setSetPoint},
....................    {"gSCals",   &getAllSensorCalParams},
....................    {"gSCal",    &getSensorCalParam},
....................    {"sSCal",    &setSensorCalParam},
....................    {"gMCal",    &getMonitorCalParam},
....................    {"sMCal",    &setMonitorCalParam},
....................    {"gMon",     &getMonitorValue},
....................    {"gPIDdata", &getPIDdata},
....................    {"gIPdata",  &getIPdata},
....................    {"gManOP",   &getManOPvals},
....................    {"sManOP",   &setManOPvals},
....................    {"\0", &invalidCmd}
.................... };
.................... 
.................... /* LIST OF RESPONSE MESSAGES */
.................... enum resp_e { 
....................    SUCCESS,
....................    INV_CMD,
....................    INV_PARAM 
.................... };
.................... 
.................... resp resp_list[] = {
....................    {SUCCESS, "SUCCESS"},
....................    {INV_CMD, "INVALID COMMAND"},
....................    {INV_PARAM, "INVALID PARAMETER"}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC COMMAND DEFINITIONS                                            */
.................... /*****************************************************************************/
....................                           
.................... int8 getRev(unsigned int8 rec){
....................    sprintf(retData+strlen(retData), "%s,", version);
*
06350:  MOVLW  04
06352:  MOVLB  6
06354:  MOVWF  x6A
06356:  MOVLW  76
06358:  MOVWF  x69
0635A:  MOVLB  0
0635C:  RCALL  6260
0635E:  MOVFF  02,03
06362:  MOVF   01,W
06364:  ADDLW  76
06366:  MOVLB  6
06368:  MOVWF  x33
0636A:  MOVLW  04
0636C:  ADDWFC 02,W
0636E:  MOVWF  x34
06370:  MOVFF  FE8,51B
06374:  MOVFF  633,51A
06378:  MOVLW  2E
0637A:  MOVWF  FF6
0637C:  MOVLW  03
0637E:  MOVWF  FF7
06380:  MOVLB  0
06382:  RCALL  6330
06384:  MOVLW  2C
06386:  MOVLB  6
06388:  MOVWF  x78
0638A:  MOVLB  0
0638C:  RCALL  6310
....................    return SUCCESS;
0638E:  MOVLW  00
06390:  MOVWF  01
06392:  RETURN 0
.................... }
.................... 
.................... int8 getSN(unsigned int8 rec){
....................    sprintf(retData+strlen(retData), "%s,", serialID);
06394:  MOVLW  04
06396:  MOVLB  6
06398:  MOVWF  x6A
0639A:  MOVLW  76
0639C:  MOVWF  x69
0639E:  MOVLB  0
063A0:  RCALL  6260
063A2:  MOVFF  02,03
063A6:  MOVF   01,W
063A8:  ADDLW  76
063AA:  MOVLB  6
063AC:  MOVWF  x33
063AE:  MOVLW  04
063B0:  ADDWFC 02,W
063B2:  MOVWF  x34
063B4:  MOVFF  FE8,51B
063B8:  MOVFF  633,51A
063BC:  MOVLW  38
063BE:  MOVWF  FF6
063C0:  MOVLW  03
063C2:  MOVWF  FF7
063C4:  MOVLB  0
063C6:  RCALL  6330
063C8:  MOVLW  2C
063CA:  MOVLB  6
063CC:  MOVWF  x78
063CE:  MOVLB  0
063D0:  RCALL  6310
....................    return SUCCESS;
063D2:  MOVLW  00
063D4:  MOVWF  01
063D6:  RETURN 0
.................... }
.................... 
.................... int8 getOPchMap(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
068DC:  MOVLB  6
068DE:  CLRF   x6A
068E0:  MOVFF  627,669
068E4:  CLRF   x6C
068E6:  MOVLW  B5
068E8:  MOVWF  x6B
068EA:  MOVLB  0
068EC:  CALL   0FC4
068F0:  MOVFF  02,635
068F4:  MOVFF  01,634
068F8:  MOVLW  06
068FA:  MOVLB  6
068FC:  ADDWF  x34,F
068FE:  MOVLW  00
06900:  ADDWFC x35,F
06902:  MOVLW  32
06904:  ADDWF  x34,W
06906:  MOVWF  01
06908:  MOVLW  00
0690A:  ADDWFC x35,W
0690C:  MOVWF  03
0690E:  MOVF   01,W
06910:  ADDLW  A0
06912:  MOVWF  01
06914:  MOVLW  01
06916:  ADDWFC 03,F
06918:  MOVFF  01,634
0691C:  MOVFF  03,635
06920:  MOVFF  03,65C
06924:  MOVFF  01,65B
06928:  MOVLB  0
0692A:  RCALL  63D8
0692C:  MOVF   01,F
0692E:  BNZ   6938
06930:  MOVLW  02
06932:  MOVWF  01
06934:  BRA    6A76
06936:  BRA    6994
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06938:  MOVLB  6
0693A:  CLRF   x6A
0693C:  MOVFF  627,669
06940:  CLRF   x6C
06942:  MOVLW  B5
06944:  MOVWF  x6B
06946:  MOVLB  0
06948:  CALL   0FC4
0694C:  MOVFF  02,635
06950:  MOVFF  01,634
06954:  MOVLW  06
06956:  MOVLB  6
06958:  ADDWF  x34,F
0695A:  MOVLW  00
0695C:  ADDWFC x35,F
0695E:  MOVLW  32
06960:  ADDWF  x34,W
06962:  MOVWF  01
06964:  MOVLW  00
06966:  ADDWFC x35,W
06968:  MOVWF  03
0696A:  MOVF   01,W
0696C:  ADDLW  A0
0696E:  MOVWF  01
06970:  MOVLW  01
06972:  ADDWFC 03,F
06974:  MOVFF  01,634
06978:  MOVFF  03,635
0697C:  MOVFF  03,65C
06980:  MOVFF  01,65B
06984:  CLRF   x5E
06986:  CLRF   x5D
06988:  MOVLW  0A
0698A:  MOVWF  x5F
0698C:  MOVLB  0
0698E:  RCALL  64C8
06990:  MOVFF  01,633
....................    
....................    /*** GET CHANNEL MAP ***************/ 
....................    if      (0 == chMap[arg1-1]) sprintf(retData+strlen(retData), "%d,%c,", arg1, 'X');
06994:  MOVLW  01
06996:  MOVLB  6
06998:  SUBWF  x33,W
0699A:  MOVWF  x35
0699C:  CLRF   x37
0699E:  MOVLW  60
069A0:  MOVWF  x36
069A2:  MOVLB  0
069A4:  CALL   4E5C
069A8:  BTFSC  01.0
069AA:  BRA    6A00
069AC:  MOVLW  04
069AE:  MOVLB  6
069B0:  MOVWF  x6A
069B2:  MOVLW  76
069B4:  MOVWF  x69
069B6:  MOVLB  0
069B8:  RCALL  6260
069BA:  MOVFF  02,03
069BE:  MOVF   01,W
069C0:  ADDLW  76
069C2:  MOVLB  6
069C4:  MOVWF  x34
069C6:  MOVLW  04
069C8:  ADDWFC 02,W
069CA:  MOVWF  x35
069CC:  MOVFF  FE8,51B
069D0:  MOVFF  634,51A
069D4:  MOVFF  633,65C
069D8:  MOVLW  18
069DA:  MOVWF  x5D
069DC:  MOVLB  0
069DE:  RCALL  681C
069E0:  MOVLW  2C
069E2:  MOVLB  6
069E4:  MOVWF  x78
069E6:  MOVLB  0
069E8:  RCALL  6310
069EA:  MOVLW  58
069EC:  MOVLB  6
069EE:  MOVWF  x78
069F0:  MOVLB  0
069F2:  RCALL  6310
069F4:  MOVLW  2C
069F6:  MOVLB  6
069F8:  MOVWF  x78
069FA:  MOVLB  0
069FC:  RCALL  6310
069FE:  BRA    6A72
....................    else if (1 == chMap[arg1-1]) sprintf(retData+strlen(retData), "%d,%c,", arg1, 'Y');
06A00:  MOVLW  01
06A02:  MOVLB  6
06A04:  SUBWF  x33,W
06A06:  MOVWF  x35
06A08:  CLRF   x37
06A0A:  MOVLW  60
06A0C:  MOVWF  x36
06A0E:  MOVLB  0
06A10:  CALL   4E5C
06A14:  BTFSS  01.0
06A16:  BRA    6A6C
06A18:  MOVLW  04
06A1A:  MOVLB  6
06A1C:  MOVWF  x6A
06A1E:  MOVLW  76
06A20:  MOVWF  x69
06A22:  MOVLB  0
06A24:  RCALL  6260
06A26:  MOVFF  02,03
06A2A:  MOVF   01,W
06A2C:  ADDLW  76
06A2E:  MOVLB  6
06A30:  MOVWF  x34
06A32:  MOVLW  04
06A34:  ADDWFC 02,W
06A36:  MOVWF  x35
06A38:  MOVFF  FE8,51B
06A3C:  MOVFF  634,51A
06A40:  MOVFF  633,65C
06A44:  MOVLW  18
06A46:  MOVWF  x5D
06A48:  MOVLB  0
06A4A:  RCALL  681C
06A4C:  MOVLW  2C
06A4E:  MOVLB  6
06A50:  MOVWF  x78
06A52:  MOVLB  0
06A54:  RCALL  6310
06A56:  MOVLW  59
06A58:  MOVLB  6
06A5A:  MOVWF  x78
06A5C:  MOVLB  0
06A5E:  RCALL  6310
06A60:  MOVLW  2C
06A62:  MOVLB  6
06A64:  MOVWF  x78
06A66:  MOVLB  0
06A68:  RCALL  6310
06A6A:  BRA    6A72
....................    else return INV_PARAM;
06A6C:  MOVLW  02
06A6E:  MOVWF  01
06A70:  BRA    6A76
....................    
....................    return SUCCESS;
06A72:  MOVLW  00
06A74:  MOVWF  01
06A76:  RETURN 0
.................... }
.................... 
.................... int8 setOPchMap(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
06ABA:  MOVLB  6
06ABC:  CLRF   x6A
06ABE:  MOVFF  627,669
06AC2:  CLRF   x6C
06AC4:  MOVLW  B5
06AC6:  MOVWF  x6B
06AC8:  MOVLB  0
06ACA:  CALL   0FC4
06ACE:  MOVFF  02,636
06AD2:  MOVFF  01,635
06AD6:  MOVLW  06
06AD8:  MOVLB  6
06ADA:  ADDWF  x35,F
06ADC:  MOVLW  00
06ADE:  ADDWFC x36,F
06AE0:  MOVLW  32
06AE2:  ADDWF  x35,W
06AE4:  MOVWF  01
06AE6:  MOVLW  00
06AE8:  ADDWFC x36,W
06AEA:  MOVWF  03
06AEC:  MOVF   01,W
06AEE:  ADDLW  A0
06AF0:  MOVWF  01
06AF2:  MOVLW  01
06AF4:  ADDWFC 03,F
06AF6:  MOVFF  01,635
06AFA:  MOVFF  03,636
06AFE:  MOVFF  03,65C
06B02:  MOVFF  01,65B
06B06:  MOVLB  0
06B08:  RCALL  63D8
06B0A:  MOVF   01,F
06B0C:  BNZ   6B16
06B0E:  MOVLW  02
06B10:  MOVWF  01
06B12:  BRA    6C66
06B14:  BRA    6B72
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06B16:  MOVLB  6
06B18:  CLRF   x6A
06B1A:  MOVFF  627,669
06B1E:  CLRF   x6C
06B20:  MOVLW  B5
06B22:  MOVWF  x6B
06B24:  MOVLB  0
06B26:  CALL   0FC4
06B2A:  MOVFF  02,636
06B2E:  MOVFF  01,635
06B32:  MOVLW  06
06B34:  MOVLB  6
06B36:  ADDWF  x35,F
06B38:  MOVLW  00
06B3A:  ADDWFC x36,F
06B3C:  MOVLW  32
06B3E:  ADDWF  x35,W
06B40:  MOVWF  01
06B42:  MOVLW  00
06B44:  ADDWFC x36,W
06B46:  MOVWF  03
06B48:  MOVF   01,W
06B4A:  ADDLW  A0
06B4C:  MOVWF  01
06B4E:  MOVLW  01
06B50:  ADDWFC 03,F
06B52:  MOVFF  01,635
06B56:  MOVFF  03,636
06B5A:  MOVFF  03,65C
06B5E:  MOVFF  01,65B
06B62:  CLRF   x5E
06B64:  CLRF   x5D
06B66:  MOVLW  0A
06B68:  MOVWF  x5F
06B6A:  MOVLB  0
06B6C:  RCALL  64C8
06B6E:  MOVFF  01,633
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
06B72:  MOVLB  6
06B74:  CLRF   x6A
06B76:  MOVFF  627,669
06B7A:  CLRF   x6C
06B7C:  MOVLW  B5
06B7E:  MOVWF  x6B
06B80:  MOVLB  0
06B82:  CALL   0FC4
06B86:  MOVFF  02,636
06B8A:  MOVFF  01,635
06B8E:  MOVLW  06
06B90:  MOVLB  6
06B92:  ADDWF  x35,F
06B94:  MOVLW  00
06B96:  ADDWFC x36,F
06B98:  MOVLW  4B
06B9A:  ADDWF  x35,W
06B9C:  MOVWF  01
06B9E:  MOVLW  00
06BA0:  ADDWFC x36,W
06BA2:  MOVWF  03
06BA4:  MOVF   01,W
06BA6:  ADDLW  A0
06BA8:  MOVWF  01
06BAA:  MOVLW  01
06BAC:  ADDWFC 03,F
06BAE:  MOVFF  01,635
06BB2:  MOVFF  03,636
06BB6:  MOVFF  03,66A
06BBA:  MOVFF  01,669
06BBE:  MOVLB  0
06BC0:  CALL   6260
06BC4:  MOVFF  02,03
06BC8:  MOVF   01,W
06BCA:  SUBLW  01
06BCC:  BNZ   6BD2
06BCE:  MOVF   03,F
06BD0:  BZ    6BDA
06BD2:  MOVLW  02
06BD4:  MOVWF  01
06BD6:  BRA    6C66
06BD8:  BRA    6C1A
....................    else arg2 = SERcmd[rec].p[3][0];
06BDA:  MOVLB  6
06BDC:  CLRF   x6A
06BDE:  MOVFF  627,669
06BE2:  CLRF   x6C
06BE4:  MOVLW  B5
06BE6:  MOVWF  x6B
06BE8:  MOVLB  0
06BEA:  CALL   0FC4
06BEE:  MOVFF  02,636
06BF2:  MOVFF  01,635
06BF6:  MOVLW  06
06BF8:  MOVLB  6
06BFA:  ADDWF  x35,F
06BFC:  MOVLW  00
06BFE:  ADDWFC x36,F
06C00:  MOVLW  4B
06C02:  ADDWF  x35,F
06C04:  MOVLW  00
06C06:  ADDWFC x36,F
06C08:  MOVLW  A0
06C0A:  ADDWF  x35,W
06C0C:  MOVWF  FE9
06C0E:  MOVLW  01
06C10:  ADDWFC x36,W
06C12:  MOVWF  FEA
06C14:  MOVFF  FEF,634
06C18:  MOVLB  0
....................    
....................    /*** SET CHANNEL MAP ***************/
....................    if      ('X' == arg2) chMap[arg1-1] = chX;
06C1A:  MOVLB  6
06C1C:  MOVF   x34,W
06C1E:  SUBLW  58
06C20:  BNZ   6C3A
06C22:  MOVLW  01
06C24:  SUBWF  x33,W
06C26:  MOVWF  x35
06C28:  MOVWF  x4A
06C2A:  CLRF   x4B
06C2C:  CLRF   x4D
06C2E:  MOVLW  60
06C30:  MOVWF  x4C
06C32:  MOVLB  0
06C34:  RCALL  6A78
06C36:  BRA    6C62
06C38:  MOVLB  6
....................    else if ('Y' == arg2) chMap[arg1-1] = chY;
06C3A:  MOVF   x34,W
06C3C:  SUBLW  59
06C3E:  BNZ   6C5A
06C40:  MOVLW  01
06C42:  SUBWF  x33,W
06C44:  MOVWF  x35
06C46:  MOVWF  x4A
06C48:  MOVLW  01
06C4A:  MOVWF  x4B
06C4C:  CLRF   x4D
06C4E:  MOVLW  60
06C50:  MOVWF  x4C
06C52:  MOVLB  0
06C54:  RCALL  6A78
06C56:  BRA    6C62
06C58:  MOVLB  6
....................    else return INV_PARAM;
06C5A:  MOVLW  02
06C5C:  MOVWF  01
06C5E:  MOVLB  0
06C60:  BRA    6C66
....................    
....................    return SUCCESS;
06C62:  MOVLW  00
06C64:  MOVWF  01
06C66:  RETURN 0
.................... }
.................... 
.................... int8 getIPchMode(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
06C92:  MOVLB  6
06C94:  CLRF   x6A
06C96:  MOVFF  627,669
06C9A:  CLRF   x6C
06C9C:  MOVLW  B5
06C9E:  MOVWF  x6B
06CA0:  MOVLB  0
06CA2:  CALL   0FC4
06CA6:  MOVFF  02,635
06CAA:  MOVFF  01,634
06CAE:  MOVLW  06
06CB0:  MOVLB  6
06CB2:  ADDWF  x34,F
06CB4:  MOVLW  00
06CB6:  ADDWFC x35,F
06CB8:  MOVLW  32
06CBA:  ADDWF  x34,W
06CBC:  MOVWF  01
06CBE:  MOVLW  00
06CC0:  ADDWFC x35,W
06CC2:  MOVWF  03
06CC4:  MOVF   01,W
06CC6:  ADDLW  A0
06CC8:  MOVWF  01
06CCA:  MOVLW  01
06CCC:  ADDWFC 03,F
06CCE:  MOVFF  01,634
06CD2:  MOVFF  03,635
06CD6:  MOVFF  03,65C
06CDA:  MOVFF  01,65B
06CDE:  MOVLB  0
06CE0:  CALL   63D8
06CE4:  MOVF   01,F
06CE6:  BNZ   6CF0
06CE8:  MOVLW  02
06CEA:  MOVWF  01
06CEC:  BRA    6E1C
06CEE:  BRA    6D4E
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06CF0:  MOVLB  6
06CF2:  CLRF   x6A
06CF4:  MOVFF  627,669
06CF8:  CLRF   x6C
06CFA:  MOVLW  B5
06CFC:  MOVWF  x6B
06CFE:  MOVLB  0
06D00:  CALL   0FC4
06D04:  MOVFF  02,635
06D08:  MOVFF  01,634
06D0C:  MOVLW  06
06D0E:  MOVLB  6
06D10:  ADDWF  x34,F
06D12:  MOVLW  00
06D14:  ADDWFC x35,F
06D16:  MOVLW  32
06D18:  ADDWF  x34,W
06D1A:  MOVWF  01
06D1C:  MOVLW  00
06D1E:  ADDWFC x35,W
06D20:  MOVWF  03
06D22:  MOVF   01,W
06D24:  ADDLW  A0
06D26:  MOVWF  01
06D28:  MOVLW  01
06D2A:  ADDWFC 03,F
06D2C:  MOVFF  01,634
06D30:  MOVFF  03,635
06D34:  MOVFF  03,65C
06D38:  MOVFF  01,65B
06D3C:  CLRF   x5E
06D3E:  CLRF   x5D
06D40:  MOVLW  0A
06D42:  MOVWF  x5F
06D44:  MOVLB  0
06D46:  CALL   64C8
06D4A:  MOVFF  01,633
....................    
....................    /*** GET INPUT MAP *****************/
....................    if      (0 == chMode[arg1-1]) sprintf(retData+strlen(retData), "%d,MANUAL,", arg1);
06D4E:  MOVLW  01
06D50:  MOVLB  6
06D52:  SUBWF  x33,W
06D54:  MOVWF  x35
06D56:  CLRF   x37
06D58:  MOVLW  61
06D5A:  MOVWF  x36
06D5C:  MOVLB  0
06D5E:  CALL   4E5C
06D62:  BTFSC  01.0
06D64:  BRA    6DB0
06D66:  MOVLW  04
06D68:  MOVLB  6
06D6A:  MOVWF  x6A
06D6C:  MOVLW  76
06D6E:  MOVWF  x69
06D70:  MOVLB  0
06D72:  CALL   6260
06D76:  MOVFF  02,03
06D7A:  MOVF   01,W
06D7C:  ADDLW  76
06D7E:  MOVLB  6
06D80:  MOVWF  x34
06D82:  MOVLW  04
06D84:  ADDWFC 02,W
06D86:  MOVWF  x35
06D88:  MOVFF  FE8,51B
06D8C:  MOVFF  634,51A
06D90:  MOVFF  633,65C
06D94:  MOVLW  18
06D96:  MOVWF  x5D
06D98:  MOVLB  0
06D9A:  RCALL  681C
06D9C:  MOVLW  40
06D9E:  MOVWF  FF6
06DA0:  MOVLW  03
06DA2:  MOVWF  FF7
06DA4:  MOVLW  08
06DA6:  MOVLB  6
06DA8:  MOVWF  x37
06DAA:  MOVLB  0
06DAC:  RCALL  6C68
06DAE:  BRA    6E18
....................    else if (1 == chMode[arg1-1]) sprintf(retData+strlen(retData), "%d,MAGSNS,", arg1);
06DB0:  MOVLW  01
06DB2:  MOVLB  6
06DB4:  SUBWF  x33,W
06DB6:  MOVWF  x35
06DB8:  CLRF   x37
06DBA:  MOVLW  61
06DBC:  MOVWF  x36
06DBE:  MOVLB  0
06DC0:  CALL   4E5C
06DC4:  BTFSS  01.0
06DC6:  BRA    6E12
06DC8:  MOVLW  04
06DCA:  MOVLB  6
06DCC:  MOVWF  x6A
06DCE:  MOVLW  76
06DD0:  MOVWF  x69
06DD2:  MOVLB  0
06DD4:  CALL   6260
06DD8:  MOVFF  02,03
06DDC:  MOVF   01,W
06DDE:  ADDLW  76
06DE0:  MOVLB  6
06DE2:  MOVWF  x34
06DE4:  MOVLW  04
06DE6:  ADDWFC 02,W
06DE8:  MOVWF  x35
06DEA:  MOVFF  FE8,51B
06DEE:  MOVFF  634,51A
06DF2:  MOVFF  633,65C
06DF6:  MOVLW  18
06DF8:  MOVWF  x5D
06DFA:  MOVLB  0
06DFC:  RCALL  681C
06DFE:  MOVLW  4C
06E00:  MOVWF  FF6
06E02:  MOVLW  03
06E04:  MOVWF  FF7
06E06:  MOVLW  08
06E08:  MOVLB  6
06E0A:  MOVWF  x37
06E0C:  MOVLB  0
06E0E:  RCALL  6C68
06E10:  BRA    6E18
....................    else return INV_PARAM;
06E12:  MOVLW  02
06E14:  MOVWF  01
06E16:  BRA    6E1C
....................    
....................    return SUCCESS;
06E18:  MOVLW  00
06E1A:  MOVWF  01
06E1C:  RETURN 0
.................... }
.................... 
.................... int8 setIPchMode(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char *arg2;
....................    char *s_manual = "MANUAL";
06E1E:  MOVLW  4D
06E20:  MOVLB  6
06E22:  MOVWF  x38
06E24:  MOVLW  41
06E26:  MOVWF  x39
06E28:  MOVLW  4E
06E2A:  MOVWF  x3A
06E2C:  MOVLW  55
06E2E:  MOVWF  x3B
06E30:  MOVLW  41
06E32:  MOVWF  x3C
06E34:  MOVLW  4C
06E36:  MOVWF  x3D
06E38:  CLRF   x3E
06E3A:  MOVLW  06
06E3C:  MOVWF  x37
06E3E:  MOVLW  38
06E40:  MOVWF  x36
....................    char *s_magsns = "MAGSNS";
06E42:  MOVLW  4D
06E44:  MOVWF  x41
06E46:  MOVLW  41
06E48:  MOVWF  x42
06E4A:  MOVLW  47
06E4C:  MOVWF  x43
06E4E:  MOVLW  53
06E50:  MOVWF  x44
06E52:  MOVLW  4E
06E54:  MOVWF  x45
06E56:  MOVLW  53
06E58:  MOVWF  x46
06E5A:  CLRF   x47
06E5C:  MOVLW  06
06E5E:  MOVWF  x40
06E60:  MOVLW  41
06E62:  MOVWF  x3F
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
06E64:  CLRF   x6A
06E66:  MOVFF  627,669
06E6A:  CLRF   x6C
06E6C:  MOVLW  B5
06E6E:  MOVWF  x6B
06E70:  MOVLB  0
06E72:  CALL   0FC4
06E76:  MOVFF  02,649
06E7A:  MOVFF  01,648
06E7E:  MOVLW  06
06E80:  MOVLB  6
06E82:  ADDWF  x48,F
06E84:  MOVLW  00
06E86:  ADDWFC x49,F
06E88:  MOVLW  32
06E8A:  ADDWF  x48,W
06E8C:  MOVWF  01
06E8E:  MOVLW  00
06E90:  ADDWFC x49,W
06E92:  MOVWF  03
06E94:  MOVF   01,W
06E96:  ADDLW  A0
06E98:  MOVWF  01
06E9A:  MOVLW  01
06E9C:  ADDWFC 03,F
06E9E:  MOVFF  01,648
06EA2:  MOVFF  03,649
06EA6:  MOVFF  03,65C
06EAA:  MOVFF  01,65B
06EAE:  MOVLB  0
06EB0:  CALL   63D8
06EB4:  MOVF   01,F
06EB6:  BNZ   6EC0
06EB8:  MOVLW  02
06EBA:  MOVWF  01
06EBC:  BRA    7036
06EBE:  BRA    6F1E
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06EC0:  MOVLB  6
06EC2:  CLRF   x6A
06EC4:  MOVFF  627,669
06EC8:  CLRF   x6C
06ECA:  MOVLW  B5
06ECC:  MOVWF  x6B
06ECE:  MOVLB  0
06ED0:  CALL   0FC4
06ED4:  MOVFF  02,649
06ED8:  MOVFF  01,648
06EDC:  MOVLW  06
06EDE:  MOVLB  6
06EE0:  ADDWF  x48,F
06EE2:  MOVLW  00
06EE4:  ADDWFC x49,F
06EE6:  MOVLW  32
06EE8:  ADDWF  x48,W
06EEA:  MOVWF  01
06EEC:  MOVLW  00
06EEE:  ADDWFC x49,W
06EF0:  MOVWF  03
06EF2:  MOVF   01,W
06EF4:  ADDLW  A0
06EF6:  MOVWF  01
06EF8:  MOVLW  01
06EFA:  ADDWFC 03,F
06EFC:  MOVFF  01,648
06F00:  MOVFF  03,649
06F04:  MOVFF  03,65C
06F08:  MOVFF  01,65B
06F0C:  CLRF   x5E
06F0E:  CLRF   x5D
06F10:  MOVLW  0A
06F12:  MOVWF  x5F
06F14:  MOVLB  0
06F16:  CALL   64C8
06F1A:  MOVFF  01,633
....................    
....................    if (0 == strlen(SERcmd[rec].p[3])) return INV_PARAM;
06F1E:  MOVLB  6
06F20:  CLRF   x6A
06F22:  MOVFF  627,669
06F26:  CLRF   x6C
06F28:  MOVLW  B5
06F2A:  MOVWF  x6B
06F2C:  MOVLB  0
06F2E:  CALL   0FC4
06F32:  MOVFF  02,649
06F36:  MOVFF  01,648
06F3A:  MOVLW  06
06F3C:  MOVLB  6
06F3E:  ADDWF  x48,F
06F40:  MOVLW  00
06F42:  ADDWFC x49,F
06F44:  MOVLW  4B
06F46:  ADDWF  x48,W
06F48:  MOVWF  01
06F4A:  MOVLW  00
06F4C:  ADDWFC x49,W
06F4E:  MOVWF  03
06F50:  MOVF   01,W
06F52:  ADDLW  A0
06F54:  MOVWF  01
06F56:  MOVLW  01
06F58:  ADDWFC 03,F
06F5A:  MOVFF  01,648
06F5E:  MOVFF  03,649
06F62:  MOVFF  03,66A
06F66:  MOVFF  01,669
06F6A:  MOVLB  0
06F6C:  CALL   6260
06F70:  MOVFF  02,03
06F74:  MOVF   01,W
06F76:  BNZ   6F84
06F78:  MOVF   03,F
06F7A:  BNZ   6F84
06F7C:  MOVLW  02
06F7E:  MOVWF  01
06F80:  BRA    7036
06F82:  BRA    6FCA
....................    else arg2 = SERcmd[rec].p[3];
06F84:  MOVLB  6
06F86:  CLRF   x6A
06F88:  MOVFF  627,669
06F8C:  CLRF   x6C
06F8E:  MOVLW  B5
06F90:  MOVWF  x6B
06F92:  MOVLB  0
06F94:  CALL   0FC4
06F98:  MOVFF  02,649
06F9C:  MOVFF  01,648
06FA0:  MOVLW  06
06FA2:  MOVLB  6
06FA4:  ADDWF  x48,F
06FA6:  MOVLW  00
06FA8:  ADDWFC x49,F
06FAA:  MOVLW  4B
06FAC:  ADDWF  x48,W
06FAE:  MOVWF  01
06FB0:  MOVLW  00
06FB2:  ADDWFC x49,W
06FB4:  MOVWF  03
06FB6:  MOVF   01,W
06FB8:  ADDLW  A0
06FBA:  MOVWF  01
06FBC:  MOVLW  01
06FBE:  ADDWFC 03,F
06FC0:  MOVFF  01,634
06FC4:  MOVFF  03,635
06FC8:  MOVLB  0
....................    
....................    /*** SET INPUT MAP *****************/
....................    if      (0 == strcmp(s_manual, arg2)) chMode[arg1-1] = MANUAL;
06FCA:  MOVFF  637,66A
06FCE:  MOVFF  636,669
06FD2:  MOVFF  635,66C
06FD6:  MOVFF  634,66B
06FDA:  CALL   6298
06FDE:  MOVF   01,F
06FE0:  BNZ   6FFA
06FE2:  MOVLW  01
06FE4:  MOVLB  6
06FE6:  SUBWF  x33,W
06FE8:  MOVWF  x48
06FEA:  MOVWF  x4A
06FEC:  CLRF   x4B
06FEE:  CLRF   x4D
06FF0:  MOVLW  61
06FF2:  MOVWF  x4C
06FF4:  MOVLB  0
06FF6:  RCALL  6A78
06FF8:  BRA    7032
....................    else if (0 == strcmp(s_magsns, arg2)) chMode[arg1-1] = MAGSNS;
06FFA:  MOVFF  640,66A
06FFE:  MOVFF  63F,669
07002:  MOVFF  635,66C
07006:  MOVFF  634,66B
0700A:  CALL   6298
0700E:  MOVF   01,F
07010:  BNZ   702C
07012:  MOVLW  01
07014:  MOVLB  6
07016:  SUBWF  x33,W
07018:  MOVWF  x48
0701A:  MOVWF  x4A
0701C:  MOVLW  01
0701E:  MOVWF  x4B
07020:  CLRF   x4D
07022:  MOVLW  61
07024:  MOVWF  x4C
07026:  MOVLB  0
07028:  RCALL  6A78
0702A:  BRA    7032
....................    else return INV_PARAM;
0702C:  MOVLW  02
0702E:  MOVWF  01
07030:  BRA    7036
....................    
....................    return SUCCESS;
07032:  MOVLW  00
07034:  MOVWF  01
07036:  RETURN 0
.................... }
.................... 
.................... int8 getPIDvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/ 
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
071EE:  MOVLB  6
071F0:  CLRF   x6A
071F2:  MOVFF  627,669
071F6:  CLRF   x6C
071F8:  MOVLW  B5
071FA:  MOVWF  x6B
071FC:  MOVLB  0
071FE:  CALL   0FC4
07202:  MOVFF  02,636
07206:  MOVFF  01,635
0720A:  MOVLW  06
0720C:  MOVLB  6
0720E:  ADDWF  x35,F
07210:  MOVLW  00
07212:  ADDWFC x36,F
07214:  MOVLW  32
07216:  ADDWF  x35,W
07218:  MOVWF  01
0721A:  MOVLW  00
0721C:  ADDWFC x36,W
0721E:  MOVWF  03
07220:  MOVF   01,W
07222:  ADDLW  A0
07224:  MOVWF  01
07226:  MOVLW  01
07228:  ADDWFC 03,F
0722A:  MOVFF  01,635
0722E:  MOVFF  03,636
07232:  MOVFF  03,65C
07236:  MOVFF  01,65B
0723A:  MOVLB  0
0723C:  CALL   63D8
07240:  MOVF   01,F
07242:  BNZ   724C
07244:  MOVLW  02
07246:  MOVWF  01
07248:  BRA    76A2
0724A:  BRA    72AA
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
0724C:  MOVLB  6
0724E:  CLRF   x6A
07250:  MOVFF  627,669
07254:  CLRF   x6C
07256:  MOVLW  B5
07258:  MOVWF  x6B
0725A:  MOVLB  0
0725C:  CALL   0FC4
07260:  MOVFF  02,636
07264:  MOVFF  01,635
07268:  MOVLW  06
0726A:  MOVLB  6
0726C:  ADDWF  x35,F
0726E:  MOVLW  00
07270:  ADDWFC x36,F
07272:  MOVLW  32
07274:  ADDWF  x35,W
07276:  MOVWF  01
07278:  MOVLW  00
0727A:  ADDWFC x36,W
0727C:  MOVWF  03
0727E:  MOVF   01,W
07280:  ADDLW  A0
07282:  MOVWF  01
07284:  MOVLW  01
07286:  ADDWFC 03,F
07288:  MOVFF  01,635
0728C:  MOVFF  03,636
07290:  MOVFF  03,65C
07294:  MOVFF  01,65B
07298:  CLRF   x5E
0729A:  CLRF   x5D
0729C:  MOVLW  0A
0729E:  MOVWF  x5F
072A0:  MOVLB  0
072A2:  CALL   64C8
072A6:  MOVFF  01,633
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
072AA:  MOVLB  6
072AC:  CLRF   x6A
072AE:  MOVFF  627,669
072B2:  CLRF   x6C
072B4:  MOVLW  B5
072B6:  MOVWF  x6B
072B8:  MOVLB  0
072BA:  CALL   0FC4
072BE:  MOVFF  02,636
072C2:  MOVFF  01,635
072C6:  MOVLW  06
072C8:  MOVLB  6
072CA:  ADDWF  x35,F
072CC:  MOVLW  00
072CE:  ADDWFC x36,F
072D0:  MOVLW  4B
072D2:  ADDWF  x35,W
072D4:  MOVWF  01
072D6:  MOVLW  00
072D8:  ADDWFC x36,W
072DA:  MOVWF  03
072DC:  MOVF   01,W
072DE:  ADDLW  A0
072E0:  MOVWF  01
072E2:  MOVLW  01
072E4:  ADDWFC 03,F
072E6:  MOVFF  01,635
072EA:  MOVFF  03,636
072EE:  MOVFF  03,66A
072F2:  MOVFF  01,669
072F6:  MOVLB  0
072F8:  CALL   6260
072FC:  MOVFF  02,03
07300:  MOVF   01,W
07302:  SUBLW  01
07304:  BNZ   730A
07306:  MOVF   03,F
07308:  BZ    7312
0730A:  MOVLW  02
0730C:  MOVWF  01
0730E:  BRA    76A2
07310:  BRA    7352
....................    else arg2 = SERcmd[rec].p[3][0];
07312:  MOVLB  6
07314:  CLRF   x6A
07316:  MOVFF  627,669
0731A:  CLRF   x6C
0731C:  MOVLW  B5
0731E:  MOVWF  x6B
07320:  MOVLB  0
07322:  CALL   0FC4
07326:  MOVFF  02,636
0732A:  MOVFF  01,635
0732E:  MOVLW  06
07330:  MOVLB  6
07332:  ADDWF  x35,F
07334:  MOVLW  00
07336:  ADDWFC x36,F
07338:  MOVLW  4B
0733A:  ADDWF  x35,F
0733C:  MOVLW  00
0733E:  ADDWFC x36,F
07340:  MOVLW  A0
07342:  ADDWF  x35,W
07344:  MOVWF  FE9
07346:  MOVLW  01
07348:  ADDWFC x36,W
0734A:  MOVWF  FEA
0734C:  MOVFF  FEF,634
07350:  MOVLB  0
....................    
....................    /*** GET P, I, D, or A(LL) VALUE **********/
....................    if      ('P' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kP);
07352:  MOVLB  6
07354:  MOVF   x34,W
07356:  SUBLW  50
07358:  BNZ   73F2
0735A:  MOVLW  04
0735C:  MOVWF  x6A
0735E:  MOVLW  76
07360:  MOVWF  x69
07362:  MOVLB  0
07364:  CALL   6260
07368:  MOVFF  02,03
0736C:  MOVF   01,W
0736E:  ADDLW  76
07370:  MOVLB  6
07372:  MOVWF  x35
07374:  MOVLW  04
07376:  ADDWFC 02,W
07378:  MOVWF  x36
0737A:  MOVLW  01
0737C:  SUBWF  x33,W
0737E:  MULLW  20
07380:  MOVF   FF3,W
07382:  CLRF   x38
07384:  MOVWF  x37
07386:  MOVLW  20
07388:  ADDWF  x37,W
0738A:  MOVWF  FE9
0738C:  MOVLW  00
0738E:  ADDWFC x38,W
07390:  MOVWF  FEA
07392:  MOVFF  FEF,639
07396:  MOVFF  FEC,63A
0739A:  MOVFF  FEC,63B
0739E:  MOVFF  FEC,63C
073A2:  MOVFF  636,51B
073A6:  MOVFF  635,51A
073AA:  MOVFF  633,65C
073AE:  MOVLW  18
073B0:  MOVWF  x5D
073B2:  MOVLB  0
073B4:  CALL   681C
073B8:  MOVLW  2C
073BA:  MOVLB  6
073BC:  MOVWF  x78
073BE:  MOVLB  0
073C0:  CALL   6310
073C4:  MOVLW  89
073C6:  MOVWF  FE9
073C8:  MOVFF  63C,66E
073CC:  MOVFF  63B,66D
073D0:  MOVFF  63A,66C
073D4:  MOVFF  639,66B
073D8:  MOVLW  02
073DA:  MOVLB  6
073DC:  MOVWF  x6F
073DE:  MOVLB  0
073E0:  RCALL  7038
073E2:  MOVLW  2C
073E4:  MOVLB  6
073E6:  MOVWF  x78
073E8:  MOVLB  0
073EA:  CALL   6310
073EE:  BRA    769E
073F0:  MOVLB  6
....................    else if ('I' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kI);
073F2:  MOVF   x34,W
073F4:  SUBLW  49
073F6:  BNZ   7498
073F8:  MOVLW  04
073FA:  MOVWF  x6A
073FC:  MOVLW  76
073FE:  MOVWF  x69
07400:  MOVLB  0
07402:  CALL   6260
07406:  MOVF   01,W
07408:  ADDLW  76
0740A:  MOVLB  6
0740C:  MOVWF  x35
0740E:  MOVLW  04
07410:  ADDWFC 02,W
07412:  MOVWF  x36
07414:  MOVLW  01
07416:  SUBWF  x33,W
07418:  MULLW  20
0741A:  MOVF   FF3,W
0741C:  CLRF   x38
0741E:  MOVWF  x37
07420:  MOVLW  04
07422:  ADDWF  x37,W
07424:  MOVWF  01
07426:  MOVLW  00
07428:  ADDWFC x38,W
0742A:  MOVWF  03
0742C:  MOVF   01,W
0742E:  ADDLW  20
07430:  MOVWF  FE9
07432:  MOVLW  00
07434:  ADDWFC 03,W
07436:  MOVWF  FEA
07438:  MOVFF  FEF,637
0743C:  MOVFF  FEC,638
07440:  MOVFF  FEC,639
07444:  MOVFF  FEC,63A
07448:  MOVFF  636,51B
0744C:  MOVFF  635,51A
07450:  MOVFF  633,65C
07454:  MOVLW  18
07456:  MOVWF  x5D
07458:  MOVLB  0
0745A:  CALL   681C
0745E:  MOVLW  2C
07460:  MOVLB  6
07462:  MOVWF  x78
07464:  MOVLB  0
07466:  CALL   6310
0746A:  MOVLW  89
0746C:  MOVWF  FE9
0746E:  MOVFF  63A,66E
07472:  MOVFF  639,66D
07476:  MOVFF  638,66C
0747A:  MOVFF  637,66B
0747E:  MOVLW  02
07480:  MOVLB  6
07482:  MOVWF  x6F
07484:  MOVLB  0
07486:  RCALL  7038
07488:  MOVLW  2C
0748A:  MOVLB  6
0748C:  MOVWF  x78
0748E:  MOVLB  0
07490:  CALL   6310
07494:  BRA    769E
07496:  MOVLB  6
....................    else if ('D' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kD);
07498:  MOVF   x34,W
0749A:  SUBLW  44
0749C:  BNZ   753E
0749E:  MOVLW  04
074A0:  MOVWF  x6A
074A2:  MOVLW  76
074A4:  MOVWF  x69
074A6:  MOVLB  0
074A8:  CALL   6260
074AC:  MOVF   01,W
074AE:  ADDLW  76
074B0:  MOVLB  6
074B2:  MOVWF  x35
074B4:  MOVLW  04
074B6:  ADDWFC 02,W
074B8:  MOVWF  x36
074BA:  MOVLW  01
074BC:  SUBWF  x33,W
074BE:  MULLW  20
074C0:  MOVF   FF3,W
074C2:  CLRF   x38
074C4:  MOVWF  x37
074C6:  MOVLW  08
074C8:  ADDWF  x37,W
074CA:  MOVWF  01
074CC:  MOVLW  00
074CE:  ADDWFC x38,W
074D0:  MOVWF  03
074D2:  MOVF   01,W
074D4:  ADDLW  20
074D6:  MOVWF  FE9
074D8:  MOVLW  00
074DA:  ADDWFC 03,W
074DC:  MOVWF  FEA
074DE:  MOVFF  FEF,637
074E2:  MOVFF  FEC,638
074E6:  MOVFF  FEC,639
074EA:  MOVFF  FEC,63A
074EE:  MOVFF  636,51B
074F2:  MOVFF  635,51A
074F6:  MOVFF  633,65C
074FA:  MOVLW  18
074FC:  MOVWF  x5D
074FE:  MOVLB  0
07500:  CALL   681C
07504:  MOVLW  2C
07506:  MOVLB  6
07508:  MOVWF  x78
0750A:  MOVLB  0
0750C:  CALL   6310
07510:  MOVLW  89
07512:  MOVWF  FE9
07514:  MOVFF  63A,66E
07518:  MOVFF  639,66D
0751C:  MOVFF  638,66C
07520:  MOVFF  637,66B
07524:  MOVLW  02
07526:  MOVLB  6
07528:  MOVWF  x6F
0752A:  MOVLB  0
0752C:  RCALL  7038
0752E:  MOVLW  2C
07530:  MOVLB  6
07532:  MOVWF  x78
07534:  MOVLB  0
07536:  CALL   6310
0753A:  BRA    769E
0753C:  MOVLB  6
....................    else if ('A' == arg2) sprintf(retData+strlen(retData), "%d,%f,%f,%f,", arg1, PID[arg1-1].kP, PID[arg1-1].kI, PID[arg1-1].kD);
0753E:  MOVF   x34,W
07540:  SUBLW  41
07542:  BTFSS  FD8.2
07544:  BRA    7696
07546:  MOVLW  04
07548:  MOVWF  x6A
0754A:  MOVLW  76
0754C:  MOVWF  x69
0754E:  MOVLB  0
07550:  CALL   6260
07554:  MOVF   01,W
07556:  ADDLW  76
07558:  MOVLB  6
0755A:  MOVWF  x35
0755C:  MOVLW  04
0755E:  ADDWFC 02,W
07560:  MOVWF  x36
07562:  MOVLW  01
07564:  SUBWF  x33,W
07566:  MULLW  20
07568:  MOVF   FF3,W
0756A:  CLRF   x38
0756C:  MOVWF  x37
0756E:  MOVLW  20
07570:  ADDWF  x37,W
07572:  MOVWF  FE9
07574:  MOVLW  00
07576:  ADDWFC x38,W
07578:  MOVWF  FEA
0757A:  MOVFF  FEF,639
0757E:  MOVFF  FEC,63A
07582:  MOVFF  FEC,63B
07586:  MOVFF  FEC,63C
0758A:  MOVLW  01
0758C:  SUBWF  x33,W
0758E:  MULLW  20
07590:  MOVF   FF3,W
07592:  CLRF   x3E
07594:  MOVWF  x3D
07596:  MOVLW  04
07598:  ADDWF  x3D,W
0759A:  MOVWF  01
0759C:  MOVLW  00
0759E:  ADDWFC x3E,W
075A0:  MOVWF  03
075A2:  MOVF   01,W
075A4:  ADDLW  20
075A6:  MOVWF  FE9
075A8:  MOVLW  00
075AA:  ADDWFC 03,W
075AC:  MOVWF  FEA
075AE:  MOVFF  FEF,63D
075B2:  MOVFF  FEC,63E
075B6:  MOVFF  FEC,63F
075BA:  MOVFF  FEC,640
075BE:  MOVLW  01
075C0:  SUBWF  x33,W
075C2:  MULLW  20
075C4:  MOVF   FF3,W
075C6:  CLRF   x42
075C8:  MOVWF  x41
075CA:  MOVLW  08
075CC:  ADDWF  x41,W
075CE:  MOVWF  01
075D0:  MOVLW  00
075D2:  ADDWFC x42,W
075D4:  MOVWF  03
075D6:  MOVF   01,W
075D8:  ADDLW  20
075DA:  MOVWF  FE9
075DC:  MOVLW  00
075DE:  ADDWFC 03,W
075E0:  MOVWF  FEA
075E2:  MOVFF  FEF,641
075E6:  MOVFF  FEC,642
075EA:  MOVFF  FEC,643
075EE:  MOVFF  FEC,644
075F2:  MOVFF  636,51B
075F6:  MOVFF  635,51A
075FA:  MOVFF  633,65C
075FE:  MOVLW  18
07600:  MOVWF  x5D
07602:  MOVLB  0
07604:  CALL   681C
07608:  MOVLW  2C
0760A:  MOVLB  6
0760C:  MOVWF  x78
0760E:  MOVLB  0
07610:  CALL   6310
07614:  MOVLW  89
07616:  MOVWF  FE9
07618:  MOVFF  63C,66E
0761C:  MOVFF  63B,66D
07620:  MOVFF  63A,66C
07624:  MOVFF  639,66B
07628:  MOVLW  02
0762A:  MOVLB  6
0762C:  MOVWF  x6F
0762E:  MOVLB  0
07630:  RCALL  7038
07632:  MOVLW  2C
07634:  MOVLB  6
07636:  MOVWF  x78
07638:  MOVLB  0
0763A:  CALL   6310
0763E:  MOVLW  89
07640:  MOVWF  FE9
07642:  MOVFF  640,66E
07646:  MOVFF  63F,66D
0764A:  MOVFF  63E,66C
0764E:  MOVFF  63D,66B
07652:  MOVLW  02
07654:  MOVLB  6
07656:  MOVWF  x6F
07658:  MOVLB  0
0765A:  RCALL  7038
0765C:  MOVLW  2C
0765E:  MOVLB  6
07660:  MOVWF  x78
07662:  MOVLB  0
07664:  CALL   6310
07668:  MOVLW  89
0766A:  MOVWF  FE9
0766C:  MOVFF  644,66E
07670:  MOVFF  643,66D
07674:  MOVFF  642,66C
07678:  MOVFF  641,66B
0767C:  MOVLW  02
0767E:  MOVLB  6
07680:  MOVWF  x6F
07682:  MOVLB  0
07684:  RCALL  7038
07686:  MOVLW  2C
07688:  MOVLB  6
0768A:  MOVWF  x78
0768C:  MOVLB  0
0768E:  CALL   6310
07692:  BRA    769E
07694:  MOVLB  6
....................    else return INV_PARAM;
07696:  MOVLW  02
07698:  MOVWF  01
0769A:  MOVLB  0
0769C:  BRA    76A2
....................    
....................    return SUCCESS;
0769E:  MOVLW  00
076A0:  MOVWF  01
076A2:  RETURN 0
.................... }
.................... 
.................... int8 setPIDvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char  arg2;
....................    float arg3;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
079C0:  MOVLB  6
079C2:  CLRF   x6A
079C4:  MOVFF  627,669
079C8:  CLRF   x6C
079CA:  MOVLW  B5
079CC:  MOVWF  x6B
079CE:  MOVLB  0
079D0:  CALL   0FC4
079D4:  MOVFF  02,63A
079D8:  MOVFF  01,639
079DC:  MOVLW  06
079DE:  MOVLB  6
079E0:  ADDWF  x39,F
079E2:  MOVLW  00
079E4:  ADDWFC x3A,F
079E6:  MOVLW  32
079E8:  ADDWF  x39,W
079EA:  MOVWF  01
079EC:  MOVLW  00
079EE:  ADDWFC x3A,W
079F0:  MOVWF  03
079F2:  MOVF   01,W
079F4:  ADDLW  A0
079F6:  MOVWF  01
079F8:  MOVLW  01
079FA:  ADDWFC 03,F
079FC:  MOVFF  01,639
07A00:  MOVFF  03,63A
07A04:  MOVFF  03,65C
07A08:  MOVFF  01,65B
07A0C:  MOVLB  0
07A0E:  CALL   63D8
07A12:  MOVF   01,F
07A14:  BNZ   7A1E
07A16:  MOVLW  02
07A18:  MOVWF  01
07A1A:  BRA    7C9E
07A1C:  BRA    7A7C
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07A1E:  MOVLB  6
07A20:  CLRF   x6A
07A22:  MOVFF  627,669
07A26:  CLRF   x6C
07A28:  MOVLW  B5
07A2A:  MOVWF  x6B
07A2C:  MOVLB  0
07A2E:  CALL   0FC4
07A32:  MOVFF  02,63A
07A36:  MOVFF  01,639
07A3A:  MOVLW  06
07A3C:  MOVLB  6
07A3E:  ADDWF  x39,F
07A40:  MOVLW  00
07A42:  ADDWFC x3A,F
07A44:  MOVLW  32
07A46:  ADDWF  x39,W
07A48:  MOVWF  01
07A4A:  MOVLW  00
07A4C:  ADDWFC x3A,W
07A4E:  MOVWF  03
07A50:  MOVF   01,W
07A52:  ADDLW  A0
07A54:  MOVWF  01
07A56:  MOVLW  01
07A58:  ADDWFC 03,F
07A5A:  MOVFF  01,639
07A5E:  MOVFF  03,63A
07A62:  MOVFF  03,65C
07A66:  MOVFF  01,65B
07A6A:  CLRF   x5E
07A6C:  CLRF   x5D
07A6E:  MOVLW  0A
07A70:  MOVWF  x5F
07A72:  MOVLB  0
07A74:  CALL   64C8
07A78:  MOVFF  01,633
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
07A7C:  MOVLB  6
07A7E:  CLRF   x6A
07A80:  MOVFF  627,669
07A84:  CLRF   x6C
07A86:  MOVLW  B5
07A88:  MOVWF  x6B
07A8A:  MOVLB  0
07A8C:  CALL   0FC4
07A90:  MOVFF  02,63A
07A94:  MOVFF  01,639
07A98:  MOVLW  06
07A9A:  MOVLB  6
07A9C:  ADDWF  x39,F
07A9E:  MOVLW  00
07AA0:  ADDWFC x3A,F
07AA2:  MOVLW  4B
07AA4:  ADDWF  x39,W
07AA6:  MOVWF  01
07AA8:  MOVLW  00
07AAA:  ADDWFC x3A,W
07AAC:  MOVWF  03
07AAE:  MOVF   01,W
07AB0:  ADDLW  A0
07AB2:  MOVWF  01
07AB4:  MOVLW  01
07AB6:  ADDWFC 03,F
07AB8:  MOVFF  01,639
07ABC:  MOVFF  03,63A
07AC0:  MOVFF  03,66A
07AC4:  MOVFF  01,669
07AC8:  MOVLB  0
07ACA:  CALL   6260
07ACE:  MOVFF  02,03
07AD2:  MOVF   01,W
07AD4:  SUBLW  01
07AD6:  BNZ   7ADC
07AD8:  MOVF   03,F
07ADA:  BZ    7AE4
07ADC:  MOVLW  02
07ADE:  MOVWF  01
07AE0:  BRA    7C9E
07AE2:  BRA    7B24
....................    else arg2 = SERcmd[rec].p[3][0];
07AE4:  MOVLB  6
07AE6:  CLRF   x6A
07AE8:  MOVFF  627,669
07AEC:  CLRF   x6C
07AEE:  MOVLW  B5
07AF0:  MOVWF  x6B
07AF2:  MOVLB  0
07AF4:  CALL   0FC4
07AF8:  MOVFF  02,63A
07AFC:  MOVFF  01,639
07B00:  MOVLW  06
07B02:  MOVLB  6
07B04:  ADDWF  x39,F
07B06:  MOVLW  00
07B08:  ADDWFC x3A,F
07B0A:  MOVLW  4B
07B0C:  ADDWF  x39,F
07B0E:  MOVLW  00
07B10:  ADDWFC x3A,F
07B12:  MOVLW  A0
07B14:  ADDWF  x39,W
07B16:  MOVWF  FE9
07B18:  MOVLW  01
07B1A:  ADDWFC x3A,W
07B1C:  MOVWF  FEA
07B1E:  MOVFF  FEF,634
07B22:  MOVLB  0
....................    
....................    if (!arg_is_float(SERcmd[rec].p[4])) return INV_PARAM;
07B24:  MOVLB  6
07B26:  CLRF   x6A
07B28:  MOVFF  627,669
07B2C:  CLRF   x6C
07B2E:  MOVLW  B5
07B30:  MOVWF  x6B
07B32:  MOVLB  0
07B34:  CALL   0FC4
07B38:  MOVFF  02,63A
07B3C:  MOVFF  01,639
07B40:  MOVLW  06
07B42:  MOVLB  6
07B44:  ADDWF  x39,F
07B46:  MOVLW  00
07B48:  ADDWFC x3A,F
07B4A:  MOVLW  64
07B4C:  ADDWF  x39,W
07B4E:  MOVWF  01
07B50:  MOVLW  00
07B52:  ADDWFC x3A,W
07B54:  MOVWF  03
07B56:  MOVF   01,W
07B58:  ADDLW  A0
07B5A:  MOVWF  01
07B5C:  MOVLW  01
07B5E:  ADDWFC 03,F
07B60:  MOVFF  01,639
07B64:  MOVFF  03,63A
07B68:  MOVFF  03,63D
07B6C:  MOVFF  01,63C
07B70:  MOVLB  0
07B72:  RCALL  76A4
07B74:  MOVF   01,F
07B76:  BNZ   7B80
07B78:  MOVLW  02
07B7A:  MOVWF  01
07B7C:  BRA    7C9E
07B7E:  BRA    7BE4
....................    else arg3 = strtod(SERcmd[rec].p[4], '\0');
07B80:  MOVLB  6
07B82:  CLRF   x6A
07B84:  MOVFF  627,669
07B88:  CLRF   x6C
07B8A:  MOVLW  B5
07B8C:  MOVWF  x6B
07B8E:  MOVLB  0
07B90:  CALL   0FC4
07B94:  MOVFF  02,63A
07B98:  MOVFF  01,639
07B9C:  MOVLW  06
07B9E:  MOVLB  6
07BA0:  ADDWF  x39,F
07BA2:  MOVLW  00
07BA4:  ADDWFC x3A,F
07BA6:  MOVLW  64
07BA8:  ADDWF  x39,W
07BAA:  MOVWF  01
07BAC:  MOVLW  00
07BAE:  ADDWFC x3A,W
07BB0:  MOVWF  03
07BB2:  MOVF   01,W
07BB4:  ADDLW  A0
07BB6:  MOVWF  01
07BB8:  MOVLW  01
07BBA:  ADDWFC 03,F
07BBC:  MOVFF  01,639
07BC0:  MOVFF  03,63A
07BC4:  MOVFF  03,63D
07BC8:  MOVFF  01,63C
07BCC:  CLRF   x3F
07BCE:  CLRF   x3E
07BD0:  MOVLB  0
07BD2:  RCALL  7766
07BD4:  MOVFF  03,638
07BD8:  MOVFF  02,637
07BDC:  MOVFF  01,636
07BE0:  MOVFF  00,635
....................    
....................    /*** SET P, I, or D VALUE **********/
....................    if      ('P' == arg2) PID[arg1-1].kP = arg3;
07BE4:  MOVLB  6
07BE6:  MOVF   x34,W
07BE8:  SUBLW  50
07BEA:  BNZ   7C16
07BEC:  MOVLW  01
07BEE:  SUBWF  x33,W
07BF0:  MULLW  20
07BF2:  MOVF   FF3,W
07BF4:  CLRF   x3A
07BF6:  MOVWF  x39
07BF8:  MOVLW  20
07BFA:  ADDWF  x39,W
07BFC:  MOVWF  FE9
07BFE:  MOVLW  00
07C00:  ADDWFC x3A,W
07C02:  MOVWF  FEA
07C04:  MOVFF  635,FEF
07C08:  MOVFF  636,FEC
07C0C:  MOVFF  637,FEC
07C10:  MOVFF  638,FEC
07C14:  BRA    7C98
....................    else if ('I' == arg2) PID[arg1-1].kI = arg3;
07C16:  MOVF   x34,W
07C18:  SUBLW  49
07C1A:  BNZ   7C52
07C1C:  MOVLW  01
07C1E:  SUBWF  x33,W
07C20:  MULLW  20
07C22:  MOVF   FF3,W
07C24:  CLRF   x3A
07C26:  MOVWF  x39
07C28:  MOVLW  04
07C2A:  ADDWF  x39,W
07C2C:  MOVWF  01
07C2E:  MOVLW  00
07C30:  ADDWFC x3A,W
07C32:  MOVWF  03
07C34:  MOVF   01,W
07C36:  ADDLW  20
07C38:  MOVWF  FE9
07C3A:  MOVLW  00
07C3C:  ADDWFC 03,W
07C3E:  MOVWF  FEA
07C40:  MOVFF  635,FEF
07C44:  MOVFF  636,FEC
07C48:  MOVFF  637,FEC
07C4C:  MOVFF  638,FEC
07C50:  BRA    7C98
....................    else if ('D' == arg2) PID[arg1-1].kD = arg3;
07C52:  MOVF   x34,W
07C54:  SUBLW  44
07C56:  BNZ   7C8E
07C58:  MOVLW  01
07C5A:  SUBWF  x33,W
07C5C:  MULLW  20
07C5E:  MOVF   FF3,W
07C60:  CLRF   x3A
07C62:  MOVWF  x39
07C64:  MOVLW  08
07C66:  ADDWF  x39,W
07C68:  MOVWF  01
07C6A:  MOVLW  00
07C6C:  ADDWFC x3A,W
07C6E:  MOVWF  03
07C70:  MOVF   01,W
07C72:  ADDLW  20
07C74:  MOVWF  FE9
07C76:  MOVLW  00
07C78:  ADDWFC 03,W
07C7A:  MOVWF  FEA
07C7C:  MOVFF  635,FEF
07C80:  MOVFF  636,FEC
07C84:  MOVFF  637,FEC
07C88:  MOVFF  638,FEC
07C8C:  BRA    7C98
....................    else return INV_PARAM;
07C8E:  MOVLW  02
07C90:  MOVWF  01
07C92:  MOVLB  0
07C94:  BRA    7C9E
07C96:  MOVLB  6
....................    
....................    return SUCCESS;
07C98:  MOVLW  00
07C9A:  MOVWF  01
07C9C:  MOVLB  0
07C9E:  RETURN 0
.................... }
.................... 
.................... //!int8 enablePID(unsigned int8 rec){
.................... //!   /*** ARG CHECKS ********************/
.................... //!   int8  arg1;
.................... //!   
.................... //!   if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
.................... //!   else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
.................... //!   
.................... //!   PID[arg1-1].enable = TRUE;
.................... //!   
.................... //!   return SUCCESS;
.................... //!}
.................... //!
.................... //!int8 disablePID(unsigned int8 rec){
.................... //!   /*** ARG CHECKS ********************/
.................... //!   int8  arg1;
.................... //!   
.................... //!   if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
.................... //!   else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
.................... //!   
.................... //!   PID[arg1-1].enable = FALSE;
.................... //!   
.................... //!   return SUCCESS;
.................... //!}
.................... 
.................... int8 getSetPoint(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
07CA0:  MOVLB  6
07CA2:  CLRF   x6A
07CA4:  MOVFF  627,669
07CA8:  CLRF   x6C
07CAA:  MOVLW  B5
07CAC:  MOVWF  x6B
07CAE:  MOVLB  0
07CB0:  CALL   0FC4
07CB4:  MOVFF  02,635
07CB8:  MOVFF  01,634
07CBC:  MOVLW  06
07CBE:  MOVLB  6
07CC0:  ADDWF  x34,F
07CC2:  MOVLW  00
07CC4:  ADDWFC x35,F
07CC6:  MOVLW  32
07CC8:  ADDWF  x34,W
07CCA:  MOVWF  01
07CCC:  MOVLW  00
07CCE:  ADDWFC x35,W
07CD0:  MOVWF  03
07CD2:  MOVF   01,W
07CD4:  ADDLW  A0
07CD6:  MOVWF  01
07CD8:  MOVLW  01
07CDA:  ADDWFC 03,F
07CDC:  MOVFF  01,634
07CE0:  MOVFF  03,635
07CE4:  MOVFF  03,65C
07CE8:  MOVFF  01,65B
07CEC:  MOVLB  0
07CEE:  CALL   63D8
07CF2:  MOVF   01,F
07CF4:  BNZ   7CFE
07CF6:  MOVLW  02
07CF8:  MOVWF  01
07CFA:  BRA    7E00
07CFC:  BRA    7D5C
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07CFE:  MOVLB  6
07D00:  CLRF   x6A
07D02:  MOVFF  627,669
07D06:  CLRF   x6C
07D08:  MOVLW  B5
07D0A:  MOVWF  x6B
07D0C:  MOVLB  0
07D0E:  CALL   0FC4
07D12:  MOVFF  02,635
07D16:  MOVFF  01,634
07D1A:  MOVLW  06
07D1C:  MOVLB  6
07D1E:  ADDWF  x34,F
07D20:  MOVLW  00
07D22:  ADDWFC x35,F
07D24:  MOVLW  32
07D26:  ADDWF  x34,W
07D28:  MOVWF  01
07D2A:  MOVLW  00
07D2C:  ADDWFC x35,W
07D2E:  MOVWF  03
07D30:  MOVF   01,W
07D32:  ADDLW  A0
07D34:  MOVWF  01
07D36:  MOVLW  01
07D38:  ADDWFC 03,F
07D3A:  MOVFF  01,634
07D3E:  MOVFF  03,635
07D42:  MOVFF  03,65C
07D46:  MOVFF  01,65B
07D4A:  CLRF   x5E
07D4C:  CLRF   x5D
07D4E:  MOVLW  0A
07D50:  MOVWF  x5F
07D52:  MOVLB  0
07D54:  CALL   64C8
07D58:  MOVFF  01,633
....................    
....................    /*** GET SETPOINT ******************/ 
....................    sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].SP);
07D5C:  MOVLW  04
07D5E:  MOVLB  6
07D60:  MOVWF  x6A
07D62:  MOVLW  76
07D64:  MOVWF  x69
07D66:  MOVLB  0
07D68:  CALL   6260
07D6C:  MOVF   01,W
07D6E:  ADDLW  76
07D70:  MOVLB  6
07D72:  MOVWF  x34
07D74:  MOVLW  04
07D76:  ADDWFC 02,W
07D78:  MOVWF  x35
07D7A:  MOVLW  01
07D7C:  SUBWF  x33,W
07D7E:  MULLW  20
07D80:  MOVF   FF3,W
07D82:  CLRF   x37
07D84:  MOVWF  x36
07D86:  MOVLW  0C
07D88:  ADDWF  x36,W
07D8A:  MOVWF  01
07D8C:  MOVLW  00
07D8E:  ADDWFC x37,W
07D90:  MOVWF  03
07D92:  MOVF   01,W
07D94:  ADDLW  20
07D96:  MOVWF  FE9
07D98:  MOVLW  00
07D9A:  ADDWFC 03,W
07D9C:  MOVWF  FEA
07D9E:  MOVFF  FEF,636
07DA2:  MOVFF  FEC,637
07DA6:  MOVFF  FEC,638
07DAA:  MOVFF  FEC,639
07DAE:  MOVFF  635,51B
07DB2:  MOVFF  634,51A
07DB6:  MOVFF  633,65C
07DBA:  MOVLW  18
07DBC:  MOVWF  x5D
07DBE:  MOVLB  0
07DC0:  CALL   681C
07DC4:  MOVLW  2C
07DC6:  MOVLB  6
07DC8:  MOVWF  x78
07DCA:  MOVLB  0
07DCC:  CALL   6310
07DD0:  MOVLW  89
07DD2:  MOVWF  FE9
07DD4:  MOVFF  639,66E
07DD8:  MOVFF  638,66D
07DDC:  MOVFF  637,66C
07DE0:  MOVFF  636,66B
07DE4:  MOVLW  02
07DE6:  MOVLB  6
07DE8:  MOVWF  x6F
07DEA:  MOVLB  0
07DEC:  CALL   7038
07DF0:  MOVLW  2C
07DF2:  MOVLB  6
07DF4:  MOVWF  x78
07DF6:  MOVLB  0
07DF8:  CALL   6310
....................    return SUCCESS;
07DFC:  MOVLW  00
07DFE:  MOVWF  01
07E00:  RETURN 0
.................... }
.................... 
.................... int8 setSetPoint(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/   
....................    int8  arg1;
....................    float arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
07E02:  MOVLB  6
07E04:  CLRF   x6A
07E06:  MOVFF  627,669
07E0A:  CLRF   x6C
07E0C:  MOVLW  B5
07E0E:  MOVWF  x6B
07E10:  MOVLB  0
07E12:  CALL   0FC4
07E16:  MOVFF  02,639
07E1A:  MOVFF  01,638
07E1E:  MOVLW  06
07E20:  MOVLB  6
07E22:  ADDWF  x38,F
07E24:  MOVLW  00
07E26:  ADDWFC x39,F
07E28:  MOVLW  32
07E2A:  ADDWF  x38,W
07E2C:  MOVWF  01
07E2E:  MOVLW  00
07E30:  ADDWFC x39,W
07E32:  MOVWF  03
07E34:  MOVF   01,W
07E36:  ADDLW  A0
07E38:  MOVWF  01
07E3A:  MOVLW  01
07E3C:  ADDWFC 03,F
07E3E:  MOVFF  01,638
07E42:  MOVFF  03,639
07E46:  MOVFF  03,65C
07E4A:  MOVFF  01,65B
07E4E:  MOVLB  0
07E50:  CALL   63D8
07E54:  MOVF   01,F
07E56:  BNZ   7E60
07E58:  MOVLW  02
07E5A:  MOVWF  01
07E5C:  BRA    7FBE
07E5E:  BRA    7EBE
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07E60:  MOVLB  6
07E62:  CLRF   x6A
07E64:  MOVFF  627,669
07E68:  CLRF   x6C
07E6A:  MOVLW  B5
07E6C:  MOVWF  x6B
07E6E:  MOVLB  0
07E70:  CALL   0FC4
07E74:  MOVFF  02,639
07E78:  MOVFF  01,638
07E7C:  MOVLW  06
07E7E:  MOVLB  6
07E80:  ADDWF  x38,F
07E82:  MOVLW  00
07E84:  ADDWFC x39,F
07E86:  MOVLW  32
07E88:  ADDWF  x38,W
07E8A:  MOVWF  01
07E8C:  MOVLW  00
07E8E:  ADDWFC x39,W
07E90:  MOVWF  03
07E92:  MOVF   01,W
07E94:  ADDLW  A0
07E96:  MOVWF  01
07E98:  MOVLW  01
07E9A:  ADDWFC 03,F
07E9C:  MOVFF  01,638
07EA0:  MOVFF  03,639
07EA4:  MOVFF  03,65C
07EA8:  MOVFF  01,65B
07EAC:  CLRF   x5E
07EAE:  CLRF   x5D
07EB0:  MOVLW  0A
07EB2:  MOVWF  x5F
07EB4:  MOVLB  0
07EB6:  CALL   64C8
07EBA:  MOVFF  01,633
....................    
....................    if (!arg_is_float(SERcmd[rec].p[3])) return INV_PARAM;
07EBE:  MOVLB  6
07EC0:  CLRF   x6A
07EC2:  MOVFF  627,669
07EC6:  CLRF   x6C
07EC8:  MOVLW  B5
07ECA:  MOVWF  x6B
07ECC:  MOVLB  0
07ECE:  CALL   0FC4
07ED2:  MOVFF  02,639
07ED6:  MOVFF  01,638
07EDA:  MOVLW  06
07EDC:  MOVLB  6
07EDE:  ADDWF  x38,F
07EE0:  MOVLW  00
07EE2:  ADDWFC x39,F
07EE4:  MOVLW  4B
07EE6:  ADDWF  x38,W
07EE8:  MOVWF  01
07EEA:  MOVLW  00
07EEC:  ADDWFC x39,W
07EEE:  MOVWF  03
07EF0:  MOVF   01,W
07EF2:  ADDLW  A0
07EF4:  MOVWF  01
07EF6:  MOVLW  01
07EF8:  ADDWFC 03,F
07EFA:  MOVFF  01,638
07EFE:  MOVFF  03,639
07F02:  MOVFF  03,63D
07F06:  MOVFF  01,63C
07F0A:  MOVLB  0
07F0C:  CALL   76A4
07F10:  MOVF   01,F
07F12:  BNZ   7F1C
07F14:  MOVLW  02
07F16:  MOVWF  01
07F18:  BRA    7FBE
07F1A:  BRA    7F82
....................    else arg2 = strtod(SERcmd[rec].p[3], '\0');
07F1C:  MOVLB  6
07F1E:  CLRF   x6A
07F20:  MOVFF  627,669
07F24:  CLRF   x6C
07F26:  MOVLW  B5
07F28:  MOVWF  x6B
07F2A:  MOVLB  0
07F2C:  CALL   0FC4
07F30:  MOVFF  02,639
07F34:  MOVFF  01,638
07F38:  MOVLW  06
07F3A:  MOVLB  6
07F3C:  ADDWF  x38,F
07F3E:  MOVLW  00
07F40:  ADDWFC x39,F
07F42:  MOVLW  4B
07F44:  ADDWF  x38,W
07F46:  MOVWF  01
07F48:  MOVLW  00
07F4A:  ADDWFC x39,W
07F4C:  MOVWF  03
07F4E:  MOVF   01,W
07F50:  ADDLW  A0
07F52:  MOVWF  01
07F54:  MOVLW  01
07F56:  ADDWFC 03,F
07F58:  MOVFF  01,638
07F5C:  MOVFF  03,639
07F60:  MOVFF  03,63D
07F64:  MOVFF  01,63C
07F68:  CLRF   x3F
07F6A:  CLRF   x3E
07F6C:  MOVLB  0
07F6E:  CALL   7766
07F72:  MOVFF  03,637
07F76:  MOVFF  02,636
07F7A:  MOVFF  01,635
07F7E:  MOVFF  00,634
....................    
....................    /*** SET SETPOINT ******************/ 
....................    PID[arg1-1].SP = arg2;
07F82:  MOVLW  01
07F84:  MOVLB  6
07F86:  SUBWF  x33,W
07F88:  MULLW  20
07F8A:  MOVF   FF3,W
07F8C:  CLRF   x39
07F8E:  MOVWF  x38
07F90:  MOVLW  0C
07F92:  ADDWF  x38,W
07F94:  MOVWF  01
07F96:  MOVLW  00
07F98:  ADDWFC x39,W
07F9A:  MOVWF  03
07F9C:  MOVF   01,W
07F9E:  ADDLW  20
07FA0:  MOVWF  FE9
07FA2:  MOVLW  00
07FA4:  ADDWFC 03,W
07FA6:  MOVWF  FEA
07FA8:  MOVFF  634,FEF
07FAC:  MOVFF  635,FEC
07FB0:  MOVFF  636,FEC
07FB4:  MOVFF  637,FEC
....................    
....................    return SUCCESS;
07FB8:  MOVLW  00
07FBA:  MOVWF  01
07FBC:  MOVLB  0
07FBE:  RETURN 0
.................... }
.................... 
.................... int8 getAllSensorCalParams(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
07FC0:  MOVLB  6
07FC2:  CLRF   x6A
07FC4:  MOVFF  627,669
07FC8:  CLRF   x6C
07FCA:  MOVLW  B5
07FCC:  MOVWF  x6B
07FCE:  MOVLB  0
07FD0:  CALL   0FC4
07FD4:  MOVFF  02,635
07FD8:  MOVFF  01,634
07FDC:  MOVLW  06
07FDE:  MOVLB  6
07FE0:  ADDWF  x34,F
07FE2:  MOVLW  00
07FE4:  ADDWFC x35,F
07FE6:  MOVLW  32
07FE8:  ADDWF  x34,W
07FEA:  MOVWF  01
07FEC:  MOVLW  00
07FEE:  ADDWFC x35,W
07FF0:  MOVWF  03
07FF2:  MOVF   01,W
07FF4:  ADDLW  A0
07FF6:  MOVWF  01
07FF8:  MOVLW  01
07FFA:  ADDWFC 03,F
07FFC:  MOVFF  01,634
08000:  MOVFF  03,635
08004:  MOVFF  03,65C
08008:  MOVFF  01,65B
0800C:  MOVLB  0
0800E:  CALL   63D8
08012:  MOVF   01,F
08014:  BNZ   801E
08016:  MOVLW  02
08018:  MOVWF  01
0801A:  BRA    8374
0801C:  BRA    807C
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
0801E:  MOVLB  6
08020:  CLRF   x6A
08022:  MOVFF  627,669
08026:  CLRF   x6C
08028:  MOVLW  B5
0802A:  MOVWF  x6B
0802C:  MOVLB  0
0802E:  CALL   0FC4
08032:  MOVFF  02,635
08036:  MOVFF  01,634
0803A:  MOVLW  06
0803C:  MOVLB  6
0803E:  ADDWF  x34,F
08040:  MOVLW  00
08042:  ADDWFC x35,F
08044:  MOVLW  32
08046:  ADDWF  x34,W
08048:  MOVWF  01
0804A:  MOVLW  00
0804C:  ADDWFC x35,W
0804E:  MOVWF  03
08050:  MOVF   01,W
08052:  ADDLW  A0
08054:  MOVWF  01
08056:  MOVLW  01
08058:  ADDWFC 03,F
0805A:  MOVFF  01,634
0805E:  MOVFF  03,635
08062:  MOVFF  03,65C
08066:  MOVFF  01,65B
0806A:  CLRF   x5E
0806C:  CLRF   x5D
0806E:  MOVLW  0A
08070:  MOVWF  x5F
08072:  MOVLB  0
08074:  CALL   64C8
08078:  MOVFF  01,633
....................    
....................    /*** GET ALL SENSOR CAL PARAMS *****/
....................    sprintf(retData+strlen(retData), "%d,", arg1);
0807C:  MOVLW  04
0807E:  MOVLB  6
08080:  MOVWF  x6A
08082:  MOVLW  76
08084:  MOVWF  x69
08086:  MOVLB  0
08088:  CALL   6260
0808C:  MOVFF  02,03
08090:  MOVF   01,W
08092:  ADDLW  76
08094:  MOVLB  6
08096:  MOVWF  x34
08098:  MOVLW  04
0809A:  ADDWFC 02,W
0809C:  MOVWF  x35
0809E:  MOVFF  FE8,51B
080A2:  MOVFF  634,51A
080A6:  MOVFF  633,65C
080AA:  MOVLW  18
080AC:  MOVWF  x5D
080AE:  MOVLB  0
080B0:  CALL   681C
080B4:  MOVLW  2C
080B6:  MOVLB  6
080B8:  MOVWF  x78
080BA:  MOVLB  0
080BC:  CALL   6310
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c0);
080C0:  MOVLW  04
080C2:  MOVLB  6
080C4:  MOVWF  x6A
080C6:  MOVLW  76
080C8:  MOVWF  x69
080CA:  MOVLB  0
080CC:  CALL   6260
080D0:  MOVFF  02,03
080D4:  MOVF   01,W
080D6:  ADDLW  76
080D8:  MOVLB  6
080DA:  MOVWF  x34
080DC:  MOVLW  04
080DE:  ADDWFC 02,W
080E0:  MOVWF  x35
080E2:  MOVLW  01
080E4:  SUBWF  x33,W
080E6:  MULLW  18
080E8:  MOVF   FF3,W
080EA:  CLRF   x37
080EC:  MOVWF  x36
080EE:  MOVLW  82
080F0:  ADDWF  x36,W
080F2:  MOVWF  FE9
080F4:  MOVLW  00
080F6:  ADDWFC x37,W
080F8:  MOVWF  FEA
080FA:  MOVFF  FEF,66B
080FE:  MOVFF  FEC,66C
08102:  MOVFF  FEC,66D
08106:  MOVFF  FEC,66E
0810A:  MOVFF  635,51B
0810E:  MOVFF  634,51A
08112:  MOVLW  89
08114:  MOVWF  FE9
08116:  MOVLW  02
08118:  MOVWF  x6F
0811A:  MOVLB  0
0811C:  CALL   7038
08120:  MOVLW  2C
08122:  MOVLB  6
08124:  MOVWF  x78
08126:  MOVLB  0
08128:  CALL   6310
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c1);
0812C:  MOVLW  04
0812E:  MOVLB  6
08130:  MOVWF  x6A
08132:  MOVLW  76
08134:  MOVWF  x69
08136:  MOVLB  0
08138:  CALL   6260
0813C:  MOVF   01,W
0813E:  ADDLW  76
08140:  MOVLB  6
08142:  MOVWF  x34
08144:  MOVLW  04
08146:  ADDWFC 02,W
08148:  MOVWF  x35
0814A:  MOVLW  01
0814C:  SUBWF  x33,W
0814E:  MULLW  18
08150:  MOVF   FF3,W
08152:  CLRF   x37
08154:  MOVWF  x36
08156:  MOVLW  04
08158:  ADDWF  x36,W
0815A:  MOVWF  01
0815C:  MOVLW  00
0815E:  ADDWFC x37,W
08160:  MOVWF  03
08162:  MOVF   01,W
08164:  ADDLW  82
08166:  MOVWF  FE9
08168:  MOVLW  00
0816A:  ADDWFC 03,W
0816C:  MOVWF  FEA
0816E:  MOVFF  FEF,66B
08172:  MOVFF  FEC,66C
08176:  MOVFF  FEC,66D
0817A:  MOVFF  FEC,66E
0817E:  MOVFF  635,51B
08182:  MOVFF  634,51A
08186:  MOVLW  89
08188:  MOVWF  FE9
0818A:  MOVLW  02
0818C:  MOVWF  x6F
0818E:  MOVLB  0
08190:  CALL   7038
08194:  MOVLW  2C
08196:  MOVLB  6
08198:  MOVWF  x78
0819A:  MOVLB  0
0819C:  CALL   6310
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c2);
081A0:  MOVLW  04
081A2:  MOVLB  6
081A4:  MOVWF  x6A
081A6:  MOVLW  76
081A8:  MOVWF  x69
081AA:  MOVLB  0
081AC:  CALL   6260
081B0:  MOVF   01,W
081B2:  ADDLW  76
081B4:  MOVLB  6
081B6:  MOVWF  x34
081B8:  MOVLW  04
081BA:  ADDWFC 02,W
081BC:  MOVWF  x35
081BE:  MOVLW  01
081C0:  SUBWF  x33,W
081C2:  MULLW  18
081C4:  MOVF   FF3,W
081C6:  CLRF   x37
081C8:  MOVWF  x36
081CA:  MOVLW  08
081CC:  ADDWF  x36,W
081CE:  MOVWF  01
081D0:  MOVLW  00
081D2:  ADDWFC x37,W
081D4:  MOVWF  03
081D6:  MOVF   01,W
081D8:  ADDLW  82
081DA:  MOVWF  FE9
081DC:  MOVLW  00
081DE:  ADDWFC 03,W
081E0:  MOVWF  FEA
081E2:  MOVFF  FEF,66B
081E6:  MOVFF  FEC,66C
081EA:  MOVFF  FEC,66D
081EE:  MOVFF  FEC,66E
081F2:  MOVFF  635,51B
081F6:  MOVFF  634,51A
081FA:  MOVLW  89
081FC:  MOVWF  FE9
081FE:  MOVLW  02
08200:  MOVWF  x6F
08202:  MOVLB  0
08204:  CALL   7038
08208:  MOVLW  2C
0820A:  MOVLB  6
0820C:  MOVWF  x78
0820E:  MOVLB  0
08210:  CALL   6310
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c3);
08214:  MOVLW  04
08216:  MOVLB  6
08218:  MOVWF  x6A
0821A:  MOVLW  76
0821C:  MOVWF  x69
0821E:  MOVLB  0
08220:  CALL   6260
08224:  MOVF   01,W
08226:  ADDLW  76
08228:  MOVLB  6
0822A:  MOVWF  x34
0822C:  MOVLW  04
0822E:  ADDWFC 02,W
08230:  MOVWF  x35
08232:  MOVLW  01
08234:  SUBWF  x33,W
08236:  MULLW  18
08238:  MOVF   FF3,W
0823A:  CLRF   x37
0823C:  MOVWF  x36
0823E:  MOVLW  0C
08240:  ADDWF  x36,W
08242:  MOVWF  01
08244:  MOVLW  00
08246:  ADDWFC x37,W
08248:  MOVWF  03
0824A:  MOVF   01,W
0824C:  ADDLW  82
0824E:  MOVWF  FE9
08250:  MOVLW  00
08252:  ADDWFC 03,W
08254:  MOVWF  FEA
08256:  MOVFF  FEF,66B
0825A:  MOVFF  FEC,66C
0825E:  MOVFF  FEC,66D
08262:  MOVFF  FEC,66E
08266:  MOVFF  635,51B
0826A:  MOVFF  634,51A
0826E:  MOVLW  89
08270:  MOVWF  FE9
08272:  MOVLW  02
08274:  MOVWF  x6F
08276:  MOVLB  0
08278:  CALL   7038
0827C:  MOVLW  2C
0827E:  MOVLB  6
08280:  MOVWF  x78
08282:  MOVLB  0
08284:  CALL   6310
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c4);
08288:  MOVLW  04
0828A:  MOVLB  6
0828C:  MOVWF  x6A
0828E:  MOVLW  76
08290:  MOVWF  x69
08292:  MOVLB  0
08294:  CALL   6260
08298:  MOVF   01,W
0829A:  ADDLW  76
0829C:  MOVLB  6
0829E:  MOVWF  x34
082A0:  MOVLW  04
082A2:  ADDWFC 02,W
082A4:  MOVWF  x35
082A6:  MOVLW  01
082A8:  SUBWF  x33,W
082AA:  MULLW  18
082AC:  MOVF   FF3,W
082AE:  CLRF   x37
082B0:  MOVWF  x36
082B2:  MOVLW  10
082B4:  ADDWF  x36,W
082B6:  MOVWF  01
082B8:  MOVLW  00
082BA:  ADDWFC x37,W
082BC:  MOVWF  03
082BE:  MOVF   01,W
082C0:  ADDLW  82
082C2:  MOVWF  FE9
082C4:  MOVLW  00
082C6:  ADDWFC 03,W
082C8:  MOVWF  FEA
082CA:  MOVFF  FEF,66B
082CE:  MOVFF  FEC,66C
082D2:  MOVFF  FEC,66D
082D6:  MOVFF  FEC,66E
082DA:  MOVFF  635,51B
082DE:  MOVFF  634,51A
082E2:  MOVLW  89
082E4:  MOVWF  FE9
082E6:  MOVLW  02
082E8:  MOVWF  x6F
082EA:  MOVLB  0
082EC:  CALL   7038
082F0:  MOVLW  2C
082F2:  MOVLB  6
082F4:  MOVWF  x78
082F6:  MOVLB  0
082F8:  CALL   6310
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c5);
082FC:  MOVLW  04
082FE:  MOVLB  6
08300:  MOVWF  x6A
08302:  MOVLW  76
08304:  MOVWF  x69
08306:  MOVLB  0
08308:  CALL   6260
0830C:  MOVF   01,W
0830E:  ADDLW  76
08310:  MOVLB  6
08312:  MOVWF  x34
08314:  MOVLW  04
08316:  ADDWFC 02,W
08318:  MOVWF  x35
0831A:  MOVLW  01
0831C:  SUBWF  x33,W
0831E:  MULLW  18
08320:  MOVF   FF3,W
08322:  CLRF   x37
08324:  MOVWF  x36
08326:  MOVLW  14
08328:  ADDWF  x36,W
0832A:  MOVWF  01
0832C:  MOVLW  00
0832E:  ADDWFC x37,W
08330:  MOVWF  03
08332:  MOVF   01,W
08334:  ADDLW  82
08336:  MOVWF  FE9
08338:  MOVLW  00
0833A:  ADDWFC 03,W
0833C:  MOVWF  FEA
0833E:  MOVFF  FEF,66B
08342:  MOVFF  FEC,66C
08346:  MOVFF  FEC,66D
0834A:  MOVFF  FEC,66E
0834E:  MOVFF  635,51B
08352:  MOVFF  634,51A
08356:  MOVLW  89
08358:  MOVWF  FE9
0835A:  MOVLW  02
0835C:  MOVWF  x6F
0835E:  MOVLB  0
08360:  CALL   7038
08364:  MOVLW  2C
08366:  MOVLB  6
08368:  MOVWF  x78
0836A:  MOVLB  0
0836C:  CALL   6310
....................    
....................    return SUCCESS;
08370:  MOVLW  00
08372:  MOVWF  01
08374:  RETURN 0
.................... }
.................... 
.................... int8 getSensorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
08376:  MOVLB  6
08378:  CLRF   x6A
0837A:  MOVFF  627,669
0837E:  CLRF   x6C
08380:  MOVLW  B5
08382:  MOVWF  x6B
08384:  MOVLB  0
08386:  CALL   0FC4
0838A:  MOVFF  02,636
0838E:  MOVFF  01,635
08392:  MOVLW  06
08394:  MOVLB  6
08396:  ADDWF  x35,F
08398:  MOVLW  00
0839A:  ADDWFC x36,F
0839C:  MOVLW  32
0839E:  ADDWF  x35,W
083A0:  MOVWF  01
083A2:  MOVLW  00
083A4:  ADDWFC x36,W
083A6:  MOVWF  03
083A8:  MOVF   01,W
083AA:  ADDLW  A0
083AC:  MOVWF  01
083AE:  MOVLW  01
083B0:  ADDWFC 03,F
083B2:  MOVFF  01,635
083B6:  MOVFF  03,636
083BA:  MOVFF  03,65C
083BE:  MOVFF  01,65B
083C2:  MOVLB  0
083C4:  CALL   63D8
083C8:  MOVF   01,F
083CA:  BNZ   83D4
083CC:  MOVLW  02
083CE:  MOVWF  01
083D0:  BRA    88D0
083D2:  BRA    8432
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
083D4:  MOVLB  6
083D6:  CLRF   x6A
083D8:  MOVFF  627,669
083DC:  CLRF   x6C
083DE:  MOVLW  B5
083E0:  MOVWF  x6B
083E2:  MOVLB  0
083E4:  CALL   0FC4
083E8:  MOVFF  02,636
083EC:  MOVFF  01,635
083F0:  MOVLW  06
083F2:  MOVLB  6
083F4:  ADDWF  x35,F
083F6:  MOVLW  00
083F8:  ADDWFC x36,F
083FA:  MOVLW  32
083FC:  ADDWF  x35,W
083FE:  MOVWF  01
08400:  MOVLW  00
08402:  ADDWFC x36,W
08404:  MOVWF  03
08406:  MOVF   01,W
08408:  ADDLW  A0
0840A:  MOVWF  01
0840C:  MOVLW  01
0840E:  ADDWFC 03,F
08410:  MOVFF  01,635
08414:  MOVFF  03,636
08418:  MOVFF  03,65C
0841C:  MOVFF  01,65B
08420:  CLRF   x5E
08422:  CLRF   x5D
08424:  MOVLW  0A
08426:  MOVWF  x5F
08428:  MOVLB  0
0842A:  CALL   64C8
0842E:  MOVFF  01,633
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
08432:  MOVLB  6
08434:  CLRF   x6A
08436:  MOVFF  627,669
0843A:  CLRF   x6C
0843C:  MOVLW  B5
0843E:  MOVWF  x6B
08440:  MOVLB  0
08442:  CALL   0FC4
08446:  MOVFF  02,636
0844A:  MOVFF  01,635
0844E:  MOVLW  06
08450:  MOVLB  6
08452:  ADDWF  x35,F
08454:  MOVLW  00
08456:  ADDWFC x36,F
08458:  MOVLW  4B
0845A:  ADDWF  x35,W
0845C:  MOVWF  01
0845E:  MOVLW  00
08460:  ADDWFC x36,W
08462:  MOVWF  03
08464:  MOVF   01,W
08466:  ADDLW  A0
08468:  MOVWF  01
0846A:  MOVLW  01
0846C:  ADDWFC 03,F
0846E:  MOVFF  01,635
08472:  MOVFF  03,636
08476:  MOVFF  03,66A
0847A:  MOVFF  01,669
0847E:  MOVLB  0
08480:  CALL   6260
08484:  MOVFF  02,03
08488:  MOVF   01,W
0848A:  SUBLW  01
0848C:  BNZ   8492
0848E:  MOVF   03,F
08490:  BZ    849A
08492:  MOVLW  02
08494:  MOVWF  01
08496:  BRA    88D0
08498:  BRA    84DA
....................    else arg2 = SERcmd[rec].p[3][0];
0849A:  MOVLB  6
0849C:  CLRF   x6A
0849E:  MOVFF  627,669
084A2:  CLRF   x6C
084A4:  MOVLW  B5
084A6:  MOVWF  x6B
084A8:  MOVLB  0
084AA:  CALL   0FC4
084AE:  MOVFF  02,636
084B2:  MOVFF  01,635
084B6:  MOVLW  06
084B8:  MOVLB  6
084BA:  ADDWF  x35,F
084BC:  MOVLW  00
084BE:  ADDWFC x36,F
084C0:  MOVLW  4B
084C2:  ADDWF  x35,F
084C4:  MOVLW  00
084C6:  ADDWFC x36,F
084C8:  MOVLW  A0
084CA:  ADDWF  x35,W
084CC:  MOVWF  FE9
084CE:  MOVLW  01
084D0:  ADDWFC x36,W
084D2:  MOVWF  FEA
084D4:  MOVFF  FEF,634
084D8:  MOVLB  0
....................    
....................    /*** GET SENSOR CAL PARAM **********/
....................    if      ('0' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c0);
084DA:  MOVLB  6
084DC:  MOVF   x34,W
084DE:  SUBLW  30
084E0:  BNZ   857C
084E2:  MOVLW  04
084E4:  MOVWF  x6A
084E6:  MOVLW  76
084E8:  MOVWF  x69
084EA:  MOVLB  0
084EC:  CALL   6260
084F0:  MOVFF  02,03
084F4:  MOVF   01,W
084F6:  ADDLW  76
084F8:  MOVLB  6
084FA:  MOVWF  x35
084FC:  MOVLW  04
084FE:  ADDWFC 02,W
08500:  MOVWF  x36
08502:  MOVLW  01
08504:  SUBWF  x33,W
08506:  MULLW  18
08508:  MOVF   FF3,W
0850A:  CLRF   x38
0850C:  MOVWF  x37
0850E:  MOVLW  82
08510:  ADDWF  x37,W
08512:  MOVWF  FE9
08514:  MOVLW  00
08516:  ADDWFC x38,W
08518:  MOVWF  FEA
0851A:  MOVFF  FEF,639
0851E:  MOVFF  FEC,63A
08522:  MOVFF  FEC,63B
08526:  MOVFF  FEC,63C
0852A:  MOVFF  636,51B
0852E:  MOVFF  635,51A
08532:  MOVFF  633,65C
08536:  MOVLW  18
08538:  MOVWF  x5D
0853A:  MOVLB  0
0853C:  CALL   681C
08540:  MOVLW  2C
08542:  MOVLB  6
08544:  MOVWF  x78
08546:  MOVLB  0
08548:  CALL   6310
0854C:  MOVLW  89
0854E:  MOVWF  FE9
08550:  MOVFF  63C,66E
08554:  MOVFF  63B,66D
08558:  MOVFF  63A,66C
0855C:  MOVFF  639,66B
08560:  MOVLW  02
08562:  MOVLB  6
08564:  MOVWF  x6F
08566:  MOVLB  0
08568:  CALL   7038
0856C:  MOVLW  2C
0856E:  MOVLB  6
08570:  MOVWF  x78
08572:  MOVLB  0
08574:  CALL   6310
08578:  BRA    88CC
0857A:  MOVLB  6
....................    else if ('1' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c1);
0857C:  MOVF   x34,W
0857E:  SUBLW  31
08580:  BNZ   8624
08582:  MOVLW  04
08584:  MOVWF  x6A
08586:  MOVLW  76
08588:  MOVWF  x69
0858A:  MOVLB  0
0858C:  CALL   6260
08590:  MOVF   01,W
08592:  ADDLW  76
08594:  MOVLB  6
08596:  MOVWF  x35
08598:  MOVLW  04
0859A:  ADDWFC 02,W
0859C:  MOVWF  x36
0859E:  MOVLW  01
085A0:  SUBWF  x33,W
085A2:  MULLW  18
085A4:  MOVF   FF3,W
085A6:  CLRF   x38
085A8:  MOVWF  x37
085AA:  MOVLW  04
085AC:  ADDWF  x37,W
085AE:  MOVWF  01
085B0:  MOVLW  00
085B2:  ADDWFC x38,W
085B4:  MOVWF  03
085B6:  MOVF   01,W
085B8:  ADDLW  82
085BA:  MOVWF  FE9
085BC:  MOVLW  00
085BE:  ADDWFC 03,W
085C0:  MOVWF  FEA
085C2:  MOVFF  FEF,637
085C6:  MOVFF  FEC,638
085CA:  MOVFF  FEC,639
085CE:  MOVFF  FEC,63A
085D2:  MOVFF  636,51B
085D6:  MOVFF  635,51A
085DA:  MOVFF  633,65C
085DE:  MOVLW  18
085E0:  MOVWF  x5D
085E2:  MOVLB  0
085E4:  CALL   681C
085E8:  MOVLW  2C
085EA:  MOVLB  6
085EC:  MOVWF  x78
085EE:  MOVLB  0
085F0:  CALL   6310
085F4:  MOVLW  89
085F6:  MOVWF  FE9
085F8:  MOVFF  63A,66E
085FC:  MOVFF  639,66D
08600:  MOVFF  638,66C
08604:  MOVFF  637,66B
08608:  MOVLW  02
0860A:  MOVLB  6
0860C:  MOVWF  x6F
0860E:  MOVLB  0
08610:  CALL   7038
08614:  MOVLW  2C
08616:  MOVLB  6
08618:  MOVWF  x78
0861A:  MOVLB  0
0861C:  CALL   6310
08620:  BRA    88CC
08622:  MOVLB  6
....................    else if ('2' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c2);
08624:  MOVF   x34,W
08626:  SUBLW  32
08628:  BNZ   86CC
0862A:  MOVLW  04
0862C:  MOVWF  x6A
0862E:  MOVLW  76
08630:  MOVWF  x69
08632:  MOVLB  0
08634:  CALL   6260
08638:  MOVF   01,W
0863A:  ADDLW  76
0863C:  MOVLB  6
0863E:  MOVWF  x35
08640:  MOVLW  04
08642:  ADDWFC 02,W
08644:  MOVWF  x36
08646:  MOVLW  01
08648:  SUBWF  x33,W
0864A:  MULLW  18
0864C:  MOVF   FF3,W
0864E:  CLRF   x38
08650:  MOVWF  x37
08652:  MOVLW  08
08654:  ADDWF  x37,W
08656:  MOVWF  01
08658:  MOVLW  00
0865A:  ADDWFC x38,W
0865C:  MOVWF  03
0865E:  MOVF   01,W
08660:  ADDLW  82
08662:  MOVWF  FE9
08664:  MOVLW  00
08666:  ADDWFC 03,W
08668:  MOVWF  FEA
0866A:  MOVFF  FEF,637
0866E:  MOVFF  FEC,638
08672:  MOVFF  FEC,639
08676:  MOVFF  FEC,63A
0867A:  MOVFF  636,51B
0867E:  MOVFF  635,51A
08682:  MOVFF  633,65C
08686:  MOVLW  18
08688:  MOVWF  x5D
0868A:  MOVLB  0
0868C:  CALL   681C
08690:  MOVLW  2C
08692:  MOVLB  6
08694:  MOVWF  x78
08696:  MOVLB  0
08698:  CALL   6310
0869C:  MOVLW  89
0869E:  MOVWF  FE9
086A0:  MOVFF  63A,66E
086A4:  MOVFF  639,66D
086A8:  MOVFF  638,66C
086AC:  MOVFF  637,66B
086B0:  MOVLW  02
086B2:  MOVLB  6
086B4:  MOVWF  x6F
086B6:  MOVLB  0
086B8:  CALL   7038
086BC:  MOVLW  2C
086BE:  MOVLB  6
086C0:  MOVWF  x78
086C2:  MOVLB  0
086C4:  CALL   6310
086C8:  BRA    88CC
086CA:  MOVLB  6
....................    else if ('3' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c3);
086CC:  MOVF   x34,W
086CE:  SUBLW  33
086D0:  BNZ   8774
086D2:  MOVLW  04
086D4:  MOVWF  x6A
086D6:  MOVLW  76
086D8:  MOVWF  x69
086DA:  MOVLB  0
086DC:  CALL   6260
086E0:  MOVF   01,W
086E2:  ADDLW  76
086E4:  MOVLB  6
086E6:  MOVWF  x35
086E8:  MOVLW  04
086EA:  ADDWFC 02,W
086EC:  MOVWF  x36
086EE:  MOVLW  01
086F0:  SUBWF  x33,W
086F2:  MULLW  18
086F4:  MOVF   FF3,W
086F6:  CLRF   x38
086F8:  MOVWF  x37
086FA:  MOVLW  0C
086FC:  ADDWF  x37,W
086FE:  MOVWF  01
08700:  MOVLW  00
08702:  ADDWFC x38,W
08704:  MOVWF  03
08706:  MOVF   01,W
08708:  ADDLW  82
0870A:  MOVWF  FE9
0870C:  MOVLW  00
0870E:  ADDWFC 03,W
08710:  MOVWF  FEA
08712:  MOVFF  FEF,637
08716:  MOVFF  FEC,638
0871A:  MOVFF  FEC,639
0871E:  MOVFF  FEC,63A
08722:  MOVFF  636,51B
08726:  MOVFF  635,51A
0872A:  MOVFF  633,65C
0872E:  MOVLW  18
08730:  MOVWF  x5D
08732:  MOVLB  0
08734:  CALL   681C
08738:  MOVLW  2C
0873A:  MOVLB  6
0873C:  MOVWF  x78
0873E:  MOVLB  0
08740:  CALL   6310
08744:  MOVLW  89
08746:  MOVWF  FE9
08748:  MOVFF  63A,66E
0874C:  MOVFF  639,66D
08750:  MOVFF  638,66C
08754:  MOVFF  637,66B
08758:  MOVLW  02
0875A:  MOVLB  6
0875C:  MOVWF  x6F
0875E:  MOVLB  0
08760:  CALL   7038
08764:  MOVLW  2C
08766:  MOVLB  6
08768:  MOVWF  x78
0876A:  MOVLB  0
0876C:  CALL   6310
08770:  BRA    88CC
08772:  MOVLB  6
....................    else if ('4' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c4);
08774:  MOVF   x34,W
08776:  SUBLW  34
08778:  BNZ   881C
0877A:  MOVLW  04
0877C:  MOVWF  x6A
0877E:  MOVLW  76
08780:  MOVWF  x69
08782:  MOVLB  0
08784:  CALL   6260
08788:  MOVF   01,W
0878A:  ADDLW  76
0878C:  MOVLB  6
0878E:  MOVWF  x35
08790:  MOVLW  04
08792:  ADDWFC 02,W
08794:  MOVWF  x36
08796:  MOVLW  01
08798:  SUBWF  x33,W
0879A:  MULLW  18
0879C:  MOVF   FF3,W
0879E:  CLRF   x38
087A0:  MOVWF  x37
087A2:  MOVLW  10
087A4:  ADDWF  x37,W
087A6:  MOVWF  01
087A8:  MOVLW  00
087AA:  ADDWFC x38,W
087AC:  MOVWF  03
087AE:  MOVF   01,W
087B0:  ADDLW  82
087B2:  MOVWF  FE9
087B4:  MOVLW  00
087B6:  ADDWFC 03,W
087B8:  MOVWF  FEA
087BA:  MOVFF  FEF,637
087BE:  MOVFF  FEC,638
087C2:  MOVFF  FEC,639
087C6:  MOVFF  FEC,63A
087CA:  MOVFF  636,51B
087CE:  MOVFF  635,51A
087D2:  MOVFF  633,65C
087D6:  MOVLW  18
087D8:  MOVWF  x5D
087DA:  MOVLB  0
087DC:  CALL   681C
087E0:  MOVLW  2C
087E2:  MOVLB  6
087E4:  MOVWF  x78
087E6:  MOVLB  0
087E8:  CALL   6310
087EC:  MOVLW  89
087EE:  MOVWF  FE9
087F0:  MOVFF  63A,66E
087F4:  MOVFF  639,66D
087F8:  MOVFF  638,66C
087FC:  MOVFF  637,66B
08800:  MOVLW  02
08802:  MOVLB  6
08804:  MOVWF  x6F
08806:  MOVLB  0
08808:  CALL   7038
0880C:  MOVLW  2C
0880E:  MOVLB  6
08810:  MOVWF  x78
08812:  MOVLB  0
08814:  CALL   6310
08818:  BRA    88CC
0881A:  MOVLB  6
....................    else if ('5' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c5);
0881C:  MOVF   x34,W
0881E:  SUBLW  35
08820:  BNZ   88C4
08822:  MOVLW  04
08824:  MOVWF  x6A
08826:  MOVLW  76
08828:  MOVWF  x69
0882A:  MOVLB  0
0882C:  CALL   6260
08830:  MOVF   01,W
08832:  ADDLW  76
08834:  MOVLB  6
08836:  MOVWF  x35
08838:  MOVLW  04
0883A:  ADDWFC 02,W
0883C:  MOVWF  x36
0883E:  MOVLW  01
08840:  SUBWF  x33,W
08842:  MULLW  18
08844:  MOVF   FF3,W
08846:  CLRF   x38
08848:  MOVWF  x37
0884A:  MOVLW  14
0884C:  ADDWF  x37,W
0884E:  MOVWF  01
08850:  MOVLW  00
08852:  ADDWFC x38,W
08854:  MOVWF  03
08856:  MOVF   01,W
08858:  ADDLW  82
0885A:  MOVWF  FE9
0885C:  MOVLW  00
0885E:  ADDWFC 03,W
08860:  MOVWF  FEA
08862:  MOVFF  FEF,637
08866:  MOVFF  FEC,638
0886A:  MOVFF  FEC,639
0886E:  MOVFF  FEC,63A
08872:  MOVFF  636,51B
08876:  MOVFF  635,51A
0887A:  MOVFF  633,65C
0887E:  MOVLW  18
08880:  MOVWF  x5D
08882:  MOVLB  0
08884:  CALL   681C
08888:  MOVLW  2C
0888A:  MOVLB  6
0888C:  MOVWF  x78
0888E:  MOVLB  0
08890:  CALL   6310
08894:  MOVLW  89
08896:  MOVWF  FE9
08898:  MOVFF  63A,66E
0889C:  MOVFF  639,66D
088A0:  MOVFF  638,66C
088A4:  MOVFF  637,66B
088A8:  MOVLW  02
088AA:  MOVLB  6
088AC:  MOVWF  x6F
088AE:  MOVLB  0
088B0:  CALL   7038
088B4:  MOVLW  2C
088B6:  MOVLB  6
088B8:  MOVWF  x78
088BA:  MOVLB  0
088BC:  CALL   6310
088C0:  BRA    88CC
088C2:  MOVLB  6
....................    else return INV_PARAM;
088C4:  MOVLW  02
088C6:  MOVWF  01
088C8:  MOVLB  0
088CA:  BRA    88D0
....................    
....................    return SUCCESS;
088CC:  MOVLW  00
088CE:  MOVWF  01
088D0:  RETURN 0
.................... }
.................... 
.................... int8 setSensorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char  arg2;
....................    float arg3;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
088D2:  MOVLB  6
088D4:  CLRF   x6A
088D6:  MOVFF  627,669
088DA:  CLRF   x6C
088DC:  MOVLW  B5
088DE:  MOVWF  x6B
088E0:  MOVLB  0
088E2:  CALL   0FC4
088E6:  MOVFF  02,63A
088EA:  MOVFF  01,639
088EE:  MOVLW  06
088F0:  MOVLB  6
088F2:  ADDWF  x39,F
088F4:  MOVLW  00
088F6:  ADDWFC x3A,F
088F8:  MOVLW  32
088FA:  ADDWF  x39,W
088FC:  MOVWF  01
088FE:  MOVLW  00
08900:  ADDWFC x3A,W
08902:  MOVWF  03
08904:  MOVF   01,W
08906:  ADDLW  A0
08908:  MOVWF  01
0890A:  MOVLW  01
0890C:  ADDWFC 03,F
0890E:  MOVFF  01,639
08912:  MOVFF  03,63A
08916:  MOVFF  03,65C
0891A:  MOVFF  01,65B
0891E:  MOVLB  0
08920:  CALL   63D8
08924:  MOVF   01,F
08926:  BNZ   8930
08928:  MOVLW  02
0892A:  MOVWF  01
0892C:  BRA    8C68
0892E:  BRA    898E
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
08930:  MOVLB  6
08932:  CLRF   x6A
08934:  MOVFF  627,669
08938:  CLRF   x6C
0893A:  MOVLW  B5
0893C:  MOVWF  x6B
0893E:  MOVLB  0
08940:  CALL   0FC4
08944:  MOVFF  02,63A
08948:  MOVFF  01,639
0894C:  MOVLW  06
0894E:  MOVLB  6
08950:  ADDWF  x39,F
08952:  MOVLW  00
08954:  ADDWFC x3A,F
08956:  MOVLW  32
08958:  ADDWF  x39,W
0895A:  MOVWF  01
0895C:  MOVLW  00
0895E:  ADDWFC x3A,W
08960:  MOVWF  03
08962:  MOVF   01,W
08964:  ADDLW  A0
08966:  MOVWF  01
08968:  MOVLW  01
0896A:  ADDWFC 03,F
0896C:  MOVFF  01,639
08970:  MOVFF  03,63A
08974:  MOVFF  03,65C
08978:  MOVFF  01,65B
0897C:  CLRF   x5E
0897E:  CLRF   x5D
08980:  MOVLW  0A
08982:  MOVWF  x5F
08984:  MOVLB  0
08986:  CALL   64C8
0898A:  MOVFF  01,633
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
0898E:  MOVLB  6
08990:  CLRF   x6A
08992:  MOVFF  627,669
08996:  CLRF   x6C
08998:  MOVLW  B5
0899A:  MOVWF  x6B
0899C:  MOVLB  0
0899E:  CALL   0FC4
089A2:  MOVFF  02,63A
089A6:  MOVFF  01,639
089AA:  MOVLW  06
089AC:  MOVLB  6
089AE:  ADDWF  x39,F
089B0:  MOVLW  00
089B2:  ADDWFC x3A,F
089B4:  MOVLW  4B
089B6:  ADDWF  x39,W
089B8:  MOVWF  01
089BA:  MOVLW  00
089BC:  ADDWFC x3A,W
089BE:  MOVWF  03
089C0:  MOVF   01,W
089C2:  ADDLW  A0
089C4:  MOVWF  01
089C6:  MOVLW  01
089C8:  ADDWFC 03,F
089CA:  MOVFF  01,639
089CE:  MOVFF  03,63A
089D2:  MOVFF  03,66A
089D6:  MOVFF  01,669
089DA:  MOVLB  0
089DC:  CALL   6260
089E0:  MOVFF  02,03
089E4:  MOVF   01,W
089E6:  SUBLW  01
089E8:  BNZ   89EE
089EA:  MOVF   03,F
089EC:  BZ    89F6
089EE:  MOVLW  02
089F0:  MOVWF  01
089F2:  BRA    8C68
089F4:  BRA    8A36
....................    else arg2 = SERcmd[rec].p[3][0];
089F6:  MOVLB  6
089F8:  CLRF   x6A
089FA:  MOVFF  627,669
089FE:  CLRF   x6C
08A00:  MOVLW  B5
08A02:  MOVWF  x6B
08A04:  MOVLB  0
08A06:  CALL   0FC4
08A0A:  MOVFF  02,63A
08A0E:  MOVFF  01,639
08A12:  MOVLW  06
08A14:  MOVLB  6
08A16:  ADDWF  x39,F
08A18:  MOVLW  00
08A1A:  ADDWFC x3A,F
08A1C:  MOVLW  4B
08A1E:  ADDWF  x39,F
08A20:  MOVLW  00
08A22:  ADDWFC x3A,F
08A24:  MOVLW  A0
08A26:  ADDWF  x39,W
08A28:  MOVWF  FE9
08A2A:  MOVLW  01
08A2C:  ADDWFC x3A,W
08A2E:  MOVWF  FEA
08A30:  MOVFF  FEF,634
08A34:  MOVLB  0
....................    
....................    if (!arg_is_float(SERcmd[rec].p[4])) return INV_PARAM;
08A36:  MOVLB  6
08A38:  CLRF   x6A
08A3A:  MOVFF  627,669
08A3E:  CLRF   x6C
08A40:  MOVLW  B5
08A42:  MOVWF  x6B
08A44:  MOVLB  0
08A46:  CALL   0FC4
08A4A:  MOVFF  02,63A
08A4E:  MOVFF  01,639
08A52:  MOVLW  06
08A54:  MOVLB  6
08A56:  ADDWF  x39,F
08A58:  MOVLW  00
08A5A:  ADDWFC x3A,F
08A5C:  MOVLW  64
08A5E:  ADDWF  x39,W
08A60:  MOVWF  01
08A62:  MOVLW  00
08A64:  ADDWFC x3A,W
08A66:  MOVWF  03
08A68:  MOVF   01,W
08A6A:  ADDLW  A0
08A6C:  MOVWF  01
08A6E:  MOVLW  01
08A70:  ADDWFC 03,F
08A72:  MOVFF  01,639
08A76:  MOVFF  03,63A
08A7A:  MOVFF  03,63D
08A7E:  MOVFF  01,63C
08A82:  MOVLB  0
08A84:  CALL   76A4
08A88:  MOVF   01,F
08A8A:  BNZ   8A94
08A8C:  MOVLW  02
08A8E:  MOVWF  01
08A90:  BRA    8C68
08A92:  BRA    8AFA
....................    else arg3 = strtod(SERcmd[rec].p[4], '\0');
08A94:  MOVLB  6
08A96:  CLRF   x6A
08A98:  MOVFF  627,669
08A9C:  CLRF   x6C
08A9E:  MOVLW  B5
08AA0:  MOVWF  x6B
08AA2:  MOVLB  0
08AA4:  CALL   0FC4
08AA8:  MOVFF  02,63A
08AAC:  MOVFF  01,639
08AB0:  MOVLW  06
08AB2:  MOVLB  6
08AB4:  ADDWF  x39,F
08AB6:  MOVLW  00
08AB8:  ADDWFC x3A,F
08ABA:  MOVLW  64
08ABC:  ADDWF  x39,W
08ABE:  MOVWF  01
08AC0:  MOVLW  00
08AC2:  ADDWFC x3A,W
08AC4:  MOVWF  03
08AC6:  MOVF   01,W
08AC8:  ADDLW  A0
08ACA:  MOVWF  01
08ACC:  MOVLW  01
08ACE:  ADDWFC 03,F
08AD0:  MOVFF  01,639
08AD4:  MOVFF  03,63A
08AD8:  MOVFF  03,63D
08ADC:  MOVFF  01,63C
08AE0:  CLRF   x3F
08AE2:  CLRF   x3E
08AE4:  MOVLB  0
08AE6:  CALL   7766
08AEA:  MOVFF  03,638
08AEE:  MOVFF  02,637
08AF2:  MOVFF  01,636
08AF6:  MOVFF  00,635
....................    
....................    /*** SET SENSOR CAL PARAM **********/
....................    if      ('0' == arg2) sensorCal[arg1-1].c0 = arg3;
08AFA:  MOVLB  6
08AFC:  MOVF   x34,W
08AFE:  SUBLW  30
08B00:  BNZ   8B2C
08B02:  MOVLW  01
08B04:  SUBWF  x33,W
08B06:  MULLW  18
08B08:  MOVF   FF3,W
08B0A:  CLRF   x3A
08B0C:  MOVWF  x39
08B0E:  MOVLW  82
08B10:  ADDWF  x39,W
08B12:  MOVWF  FE9
08B14:  MOVLW  00
08B16:  ADDWFC x3A,W
08B18:  MOVWF  FEA
08B1A:  MOVFF  635,FEF
08B1E:  MOVFF  636,FEC
08B22:  MOVFF  637,FEC
08B26:  MOVFF  638,FEC
08B2A:  BRA    8C62
....................    else if ('1' == arg2) sensorCal[arg1-1].c1 = arg3;
08B2C:  MOVF   x34,W
08B2E:  SUBLW  31
08B30:  BNZ   8B68
08B32:  MOVLW  01
08B34:  SUBWF  x33,W
08B36:  MULLW  18
08B38:  MOVF   FF3,W
08B3A:  CLRF   x3A
08B3C:  MOVWF  x39
08B3E:  MOVLW  04
08B40:  ADDWF  x39,W
08B42:  MOVWF  01
08B44:  MOVLW  00
08B46:  ADDWFC x3A,W
08B48:  MOVWF  03
08B4A:  MOVF   01,W
08B4C:  ADDLW  82
08B4E:  MOVWF  FE9
08B50:  MOVLW  00
08B52:  ADDWFC 03,W
08B54:  MOVWF  FEA
08B56:  MOVFF  635,FEF
08B5A:  MOVFF  636,FEC
08B5E:  MOVFF  637,FEC
08B62:  MOVFF  638,FEC
08B66:  BRA    8C62
....................    else if ('2' == arg2) sensorCal[arg1-1].c2 = arg3;
08B68:  MOVF   x34,W
08B6A:  SUBLW  32
08B6C:  BNZ   8BA4
08B6E:  MOVLW  01
08B70:  SUBWF  x33,W
08B72:  MULLW  18
08B74:  MOVF   FF3,W
08B76:  CLRF   x3A
08B78:  MOVWF  x39
08B7A:  MOVLW  08
08B7C:  ADDWF  x39,W
08B7E:  MOVWF  01
08B80:  MOVLW  00
08B82:  ADDWFC x3A,W
08B84:  MOVWF  03
08B86:  MOVF   01,W
08B88:  ADDLW  82
08B8A:  MOVWF  FE9
08B8C:  MOVLW  00
08B8E:  ADDWFC 03,W
08B90:  MOVWF  FEA
08B92:  MOVFF  635,FEF
08B96:  MOVFF  636,FEC
08B9A:  MOVFF  637,FEC
08B9E:  MOVFF  638,FEC
08BA2:  BRA    8C62
....................    else if ('3' == arg2) sensorCal[arg1-1].c3 = arg3;
08BA4:  MOVF   x34,W
08BA6:  SUBLW  33
08BA8:  BNZ   8BE0
08BAA:  MOVLW  01
08BAC:  SUBWF  x33,W
08BAE:  MULLW  18
08BB0:  MOVF   FF3,W
08BB2:  CLRF   x3A
08BB4:  MOVWF  x39
08BB6:  MOVLW  0C
08BB8:  ADDWF  x39,W
08BBA:  MOVWF  01
08BBC:  MOVLW  00
08BBE:  ADDWFC x3A,W
08BC0:  MOVWF  03
08BC2:  MOVF   01,W
08BC4:  ADDLW  82
08BC6:  MOVWF  FE9
08BC8:  MOVLW  00
08BCA:  ADDWFC 03,W
08BCC:  MOVWF  FEA
08BCE:  MOVFF  635,FEF
08BD2:  MOVFF  636,FEC
08BD6:  MOVFF  637,FEC
08BDA:  MOVFF  638,FEC
08BDE:  BRA    8C62
....................    else if ('4' == arg2) sensorCal[arg1-1].c4 = arg3;
08BE0:  MOVF   x34,W
08BE2:  SUBLW  34
08BE4:  BNZ   8C1C
08BE6:  MOVLW  01
08BE8:  SUBWF  x33,W
08BEA:  MULLW  18
08BEC:  MOVF   FF3,W
08BEE:  CLRF   x3A
08BF0:  MOVWF  x39
08BF2:  MOVLW  10
08BF4:  ADDWF  x39,W
08BF6:  MOVWF  01
08BF8:  MOVLW  00
08BFA:  ADDWFC x3A,W
08BFC:  MOVWF  03
08BFE:  MOVF   01,W
08C00:  ADDLW  82
08C02:  MOVWF  FE9
08C04:  MOVLW  00
08C06:  ADDWFC 03,W
08C08:  MOVWF  FEA
08C0A:  MOVFF  635,FEF
08C0E:  MOVFF  636,FEC
08C12:  MOVFF  637,FEC
08C16:  MOVFF  638,FEC
08C1A:  BRA    8C62
....................    else if ('5' == arg2) sensorCal[arg1-1].c5 = arg3;
08C1C:  MOVF   x34,W
08C1E:  SUBLW  35
08C20:  BNZ   8C58
08C22:  MOVLW  01
08C24:  SUBWF  x33,W
08C26:  MULLW  18
08C28:  MOVF   FF3,W
08C2A:  CLRF   x3A
08C2C:  MOVWF  x39
08C2E:  MOVLW  14
08C30:  ADDWF  x39,W
08C32:  MOVWF  01
08C34:  MOVLW  00
08C36:  ADDWFC x3A,W
08C38:  MOVWF  03
08C3A:  MOVF   01,W
08C3C:  ADDLW  82
08C3E:  MOVWF  FE9
08C40:  MOVLW  00
08C42:  ADDWFC 03,W
08C44:  MOVWF  FEA
08C46:  MOVFF  635,FEF
08C4A:  MOVFF  636,FEC
08C4E:  MOVFF  637,FEC
08C52:  MOVFF  638,FEC
08C56:  BRA    8C62
....................    else return INV_PARAM;
08C58:  MOVLW  02
08C5A:  MOVWF  01
08C5C:  MOVLB  0
08C5E:  BRA    8C68
08C60:  MOVLB  6
....................    
....................    return SUCCESS;
08C62:  MOVLW  00
08C64:  MOVWF  01
08C66:  MOVLB  0
08C68:  RETURN 0
.................... }
.................... 
.................... int8 getMonitorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    char *arg1;
....................    char *s_N15 = "N15";
08C6A:  MOVLW  4E
08C6C:  MOVLB  6
08C6E:  MOVWF  x37
08C70:  MOVLW  31
08C72:  MOVWF  x38
08C74:  MOVLW  35
08C76:  MOVWF  x39
08C78:  CLRF   x3A
08C7A:  MOVLW  06
08C7C:  MOVWF  x36
08C7E:  MOVLW  37
08C80:  MOVWF  x35
....................    char *s_200 = "200";
08C82:  MOVLW  32
08C84:  MOVWF  x3D
08C86:  MOVLW  30
08C88:  MOVWF  x3E
08C8A:  MOVWF  x3F
08C8C:  CLRF   x40
08C8E:  MOVLW  06
08C90:  MOVWF  x3C
08C92:  MOVLW  3D
08C94:  MOVWF  x3B
....................    char *s_5V6 = "5V6";
08C96:  MOVLW  35
08C98:  MOVWF  x43
08C9A:  MOVLW  56
08C9C:  MOVWF  x44
08C9E:  MOVLW  36
08CA0:  MOVWF  x45
08CA2:  CLRF   x46
08CA4:  MOVLW  06
08CA6:  MOVWF  x42
08CA8:  MOVLW  43
08CAA:  MOVWF  x41
....................    char *s_5VA = "5VA";
08CAC:  MOVLW  35
08CAE:  MOVWF  x49
08CB0:  MOVLW  56
08CB2:  MOVWF  x4A
08CB4:  MOVLW  41
08CB6:  MOVWF  x4B
08CB8:  CLRF   x4C
08CBA:  MOVLW  06
08CBC:  MOVWF  x48
08CBE:  MOVLW  49
08CC0:  MOVWF  x47
....................    char *s_3V6X = "3V6X";
08CC2:  MOVLW  33
08CC4:  MOVWF  x4F
08CC6:  MOVLW  56
08CC8:  MOVWF  x50
08CCA:  MOVLW  36
08CCC:  MOVWF  x51
08CCE:  MOVLW  58
08CD0:  MOVWF  x52
08CD2:  CLRF   x53
08CD4:  MOVLW  06
08CD6:  MOVWF  x4E
08CD8:  MOVLW  4F
08CDA:  MOVWF  x4D
....................    char *s_3V3A = "3V3A";
08CDC:  MOVLW  33
08CDE:  MOVWF  x56
08CE0:  MOVLW  56
08CE2:  MOVWF  x57
08CE4:  MOVLW  33
08CE6:  MOVWF  x58
08CE8:  MOVLW  41
08CEA:  MOVWF  x59
08CEC:  CLRF   x5A
08CEE:  MOVLW  06
08CF0:  MOVWF  x55
08CF2:  MOVLW  56
08CF4:  MOVWF  x54
....................    char *s_3V3D = "3V3D";
08CF6:  MOVLW  33
08CF8:  MOVWF  x5D
08CFA:  MOVLW  56
08CFC:  MOVWF  x5E
08CFE:  MOVLW  33
08D00:  MOVWF  x5F
08D02:  MOVLW  44
08D04:  MOVWF  x60
08D06:  CLRF   x61
08D08:  MOVLW  06
08D0A:  MOVWF  x5C
08D0C:  MOVLW  5D
08D0E:  MOVWF  x5B
.................... //!   char *s_all = "all";
....................    
....................    arg1 = SERcmd[rec].p[2];
08D10:  CLRF   x6A
08D12:  MOVFF  627,669
08D16:  CLRF   x6C
08D18:  MOVLW  B5
08D1A:  MOVWF  x6B
08D1C:  MOVLB  0
08D1E:  CALL   0FC4
08D22:  MOVFF  02,663
08D26:  MOVFF  01,662
08D2A:  MOVLW  06
08D2C:  MOVLB  6
08D2E:  ADDWF  x62,F
08D30:  MOVLW  00
08D32:  ADDWFC x63,F
08D34:  MOVLW  32
08D36:  ADDWF  x62,W
08D38:  MOVWF  01
08D3A:  MOVLW  00
08D3C:  ADDWFC x63,W
08D3E:  MOVWF  03
08D40:  MOVF   01,W
08D42:  ADDLW  A0
08D44:  MOVWF  01
08D46:  MOVLW  01
08D48:  ADDWFC 03,F
08D4A:  MOVFF  01,633
08D4E:  MOVFF  03,634
....................    
....................    /*** GET MONITOR VALUES ************/
....................    if      (0 == strcmp(s_N15, arg1)) {
08D52:  MOVFF  636,66A
08D56:  MOVFF  635,669
08D5A:  MOVFF  634,66C
08D5E:  MOVFF  633,66B
08D62:  MOVLB  0
08D64:  CALL   6298
08D68:  MOVF   01,F
08D6A:  BNZ   8DEE
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.vN15[0],monCal.vN15[1]);
08D6C:  MOVLW  04
08D6E:  MOVLB  6
08D70:  MOVWF  x6A
08D72:  MOVLW  76
08D74:  MOVWF  x69
08D76:  MOVLB  0
08D78:  CALL   6260
08D7C:  MOVFF  02,03
08D80:  MOVF   01,W
08D82:  ADDLW  76
08D84:  MOVLB  6
08D86:  MOVWF  x62
08D88:  MOVLW  04
08D8A:  ADDWFC 02,W
08D8C:  MOVWF  x63
08D8E:  MOVFF  FE8,51B
08D92:  MOVFF  662,51A
08D96:  MOVLW  89
08D98:  MOVWF  FE9
08D9A:  MOVFF  B5,66E
08D9E:  MOVFF  B4,66D
08DA2:  MOVFF  B3,66C
08DA6:  MOVFF  B2,66B
08DAA:  MOVLW  02
08DAC:  MOVWF  x6F
08DAE:  MOVLB  0
08DB0:  CALL   7038
08DB4:  MOVLW  2C
08DB6:  MOVLB  6
08DB8:  MOVWF  x78
08DBA:  MOVLB  0
08DBC:  CALL   6310
08DC0:  MOVLW  89
08DC2:  MOVWF  FE9
08DC4:  MOVFF  B9,66E
08DC8:  MOVFF  B8,66D
08DCC:  MOVFF  B7,66C
08DD0:  MOVFF  B6,66B
08DD4:  MOVLW  02
08DD6:  MOVLB  6
08DD8:  MOVWF  x6F
08DDA:  MOVLB  0
08DDC:  CALL   7038
08DE0:  MOVLW  2C
08DE2:  MOVLB  6
08DE4:  MOVWF  x78
08DE6:  MOVLB  0
08DE8:  CALL   6310
....................    }
08DEC:  BRA    9190
....................    else if (0 == strcmp(s_200, arg1)) {
08DEE:  MOVFF  63C,66A
08DF2:  MOVFF  63B,669
08DF6:  MOVFF  634,66C
08DFA:  MOVFF  633,66B
08DFE:  CALL   6298
08E02:  MOVF   01,F
08E04:  BNZ   8E88
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v200[0],monCal.v200[1]);
08E06:  MOVLW  04
08E08:  MOVLB  6
08E0A:  MOVWF  x6A
08E0C:  MOVLW  76
08E0E:  MOVWF  x69
08E10:  MOVLB  0
08E12:  CALL   6260
08E16:  MOVFF  02,03
08E1A:  MOVF   01,W
08E1C:  ADDLW  76
08E1E:  MOVLB  6
08E20:  MOVWF  x62
08E22:  MOVLW  04
08E24:  ADDWFC 02,W
08E26:  MOVWF  x63
08E28:  MOVFF  FE8,51B
08E2C:  MOVFF  662,51A
08E30:  MOVLW  89
08E32:  MOVWF  FE9
08E34:  MOVFF  BD,66E
08E38:  MOVFF  BC,66D
08E3C:  MOVFF  BB,66C
08E40:  MOVFF  BA,66B
08E44:  MOVLW  02
08E46:  MOVWF  x6F
08E48:  MOVLB  0
08E4A:  CALL   7038
08E4E:  MOVLW  2C
08E50:  MOVLB  6
08E52:  MOVWF  x78
08E54:  MOVLB  0
08E56:  CALL   6310
08E5A:  MOVLW  89
08E5C:  MOVWF  FE9
08E5E:  MOVFF  C1,66E
08E62:  MOVFF  C0,66D
08E66:  MOVFF  BF,66C
08E6A:  MOVFF  BE,66B
08E6E:  MOVLW  02
08E70:  MOVLB  6
08E72:  MOVWF  x6F
08E74:  MOVLB  0
08E76:  CALL   7038
08E7A:  MOVLW  2C
08E7C:  MOVLB  6
08E7E:  MOVWF  x78
08E80:  MOVLB  0
08E82:  CALL   6310
....................    }
08E86:  BRA    9190
....................    else if (0 == strcmp(s_5V6, arg1)) {
08E88:  MOVFF  642,66A
08E8C:  MOVFF  641,669
08E90:  MOVFF  634,66C
08E94:  MOVFF  633,66B
08E98:  CALL   6298
08E9C:  MOVF   01,F
08E9E:  BNZ   8F22
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v5V6[0],monCal.v5V6[1]);
08EA0:  MOVLW  04
08EA2:  MOVLB  6
08EA4:  MOVWF  x6A
08EA6:  MOVLW  76
08EA8:  MOVWF  x69
08EAA:  MOVLB  0
08EAC:  CALL   6260
08EB0:  MOVFF  02,03
08EB4:  MOVF   01,W
08EB6:  ADDLW  76
08EB8:  MOVLB  6
08EBA:  MOVWF  x62
08EBC:  MOVLW  04
08EBE:  ADDWFC 02,W
08EC0:  MOVWF  x63
08EC2:  MOVFF  FE8,51B
08EC6:  MOVFF  662,51A
08ECA:  MOVLW  89
08ECC:  MOVWF  FE9
08ECE:  MOVFF  C5,66E
08ED2:  MOVFF  C4,66D
08ED6:  MOVFF  C3,66C
08EDA:  MOVFF  C2,66B
08EDE:  MOVLW  02
08EE0:  MOVWF  x6F
08EE2:  MOVLB  0
08EE4:  CALL   7038
08EE8:  MOVLW  2C
08EEA:  MOVLB  6
08EEC:  MOVWF  x78
08EEE:  MOVLB  0
08EF0:  CALL   6310
08EF4:  MOVLW  89
08EF6:  MOVWF  FE9
08EF8:  MOVFF  C9,66E
08EFC:  MOVFF  C8,66D
08F00:  MOVFF  C7,66C
08F04:  MOVFF  C6,66B
08F08:  MOVLW  02
08F0A:  MOVLB  6
08F0C:  MOVWF  x6F
08F0E:  MOVLB  0
08F10:  CALL   7038
08F14:  MOVLW  2C
08F16:  MOVLB  6
08F18:  MOVWF  x78
08F1A:  MOVLB  0
08F1C:  CALL   6310
....................    }
08F20:  BRA    9190
....................    else if (0 == strcmp(s_5VA, arg1)) {
08F22:  MOVFF  648,66A
08F26:  MOVFF  647,669
08F2A:  MOVFF  634,66C
08F2E:  MOVFF  633,66B
08F32:  CALL   6298
08F36:  MOVF   01,F
08F38:  BNZ   8FBC
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v5VA[0],monCal.v5VA[1]);
08F3A:  MOVLW  04
08F3C:  MOVLB  6
08F3E:  MOVWF  x6A
08F40:  MOVLW  76
08F42:  MOVWF  x69
08F44:  MOVLB  0
08F46:  CALL   6260
08F4A:  MOVFF  02,03
08F4E:  MOVF   01,W
08F50:  ADDLW  76
08F52:  MOVLB  6
08F54:  MOVWF  x62
08F56:  MOVLW  04
08F58:  ADDWFC 02,W
08F5A:  MOVWF  x63
08F5C:  MOVFF  FE8,51B
08F60:  MOVFF  662,51A
08F64:  MOVLW  89
08F66:  MOVWF  FE9
08F68:  MOVFF  CD,66E
08F6C:  MOVFF  CC,66D
08F70:  MOVFF  CB,66C
08F74:  MOVFF  CA,66B
08F78:  MOVLW  02
08F7A:  MOVWF  x6F
08F7C:  MOVLB  0
08F7E:  CALL   7038
08F82:  MOVLW  2C
08F84:  MOVLB  6
08F86:  MOVWF  x78
08F88:  MOVLB  0
08F8A:  CALL   6310
08F8E:  MOVLW  89
08F90:  MOVWF  FE9
08F92:  MOVFF  D1,66E
08F96:  MOVFF  D0,66D
08F9A:  MOVFF  CF,66C
08F9E:  MOVFF  CE,66B
08FA2:  MOVLW  02
08FA4:  MOVLB  6
08FA6:  MOVWF  x6F
08FA8:  MOVLB  0
08FAA:  CALL   7038
08FAE:  MOVLW  2C
08FB0:  MOVLB  6
08FB2:  MOVWF  x78
08FB4:  MOVLB  0
08FB6:  CALL   6310
....................    }
08FBA:  BRA    9190
....................    else if (0 == strcmp(s_3V6X, arg1)) {
08FBC:  MOVFF  64E,66A
08FC0:  MOVFF  64D,669
08FC4:  MOVFF  634,66C
08FC8:  MOVFF  633,66B
08FCC:  CALL   6298
08FD0:  MOVF   01,F
08FD2:  BNZ   9056
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V6X[0],monCal.v3V6X[1]);
08FD4:  MOVLW  04
08FD6:  MOVLB  6
08FD8:  MOVWF  x6A
08FDA:  MOVLW  76
08FDC:  MOVWF  x69
08FDE:  MOVLB  0
08FE0:  CALL   6260
08FE4:  MOVFF  02,03
08FE8:  MOVF   01,W
08FEA:  ADDLW  76
08FEC:  MOVLB  6
08FEE:  MOVWF  x62
08FF0:  MOVLW  04
08FF2:  ADDWFC 02,W
08FF4:  MOVWF  x63
08FF6:  MOVFF  FE8,51B
08FFA:  MOVFF  662,51A
08FFE:  MOVLW  89
09000:  MOVWF  FE9
09002:  MOVFF  D5,66E
09006:  MOVFF  D4,66D
0900A:  MOVFF  D3,66C
0900E:  MOVFF  D2,66B
09012:  MOVLW  02
09014:  MOVWF  x6F
09016:  MOVLB  0
09018:  CALL   7038
0901C:  MOVLW  2C
0901E:  MOVLB  6
09020:  MOVWF  x78
09022:  MOVLB  0
09024:  CALL   6310
09028:  MOVLW  89
0902A:  MOVWF  FE9
0902C:  MOVFF  D9,66E
09030:  MOVFF  D8,66D
09034:  MOVFF  D7,66C
09038:  MOVFF  D6,66B
0903C:  MOVLW  02
0903E:  MOVLB  6
09040:  MOVWF  x6F
09042:  MOVLB  0
09044:  CALL   7038
09048:  MOVLW  2C
0904A:  MOVLB  6
0904C:  MOVWF  x78
0904E:  MOVLB  0
09050:  CALL   6310
....................    }
09054:  BRA    9190
....................    else if (0 == strcmp(s_3V3A, arg1)) {
09056:  MOVFF  655,66A
0905A:  MOVFF  654,669
0905E:  MOVFF  634,66C
09062:  MOVFF  633,66B
09066:  CALL   6298
0906A:  MOVF   01,F
0906C:  BNZ   90F0
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3A[0],monCal.v3V3A[1]);
0906E:  MOVLW  04
09070:  MOVLB  6
09072:  MOVWF  x6A
09074:  MOVLW  76
09076:  MOVWF  x69
09078:  MOVLB  0
0907A:  CALL   6260
0907E:  MOVFF  02,03
09082:  MOVF   01,W
09084:  ADDLW  76
09086:  MOVLB  6
09088:  MOVWF  x62
0908A:  MOVLW  04
0908C:  ADDWFC 02,W
0908E:  MOVWF  x63
09090:  MOVFF  FE8,51B
09094:  MOVFF  662,51A
09098:  MOVLW  89
0909A:  MOVWF  FE9
0909C:  MOVFF  DD,66E
090A0:  MOVFF  DC,66D
090A4:  MOVFF  DB,66C
090A8:  MOVFF  DA,66B
090AC:  MOVLW  02
090AE:  MOVWF  x6F
090B0:  MOVLB  0
090B2:  CALL   7038
090B6:  MOVLW  2C
090B8:  MOVLB  6
090BA:  MOVWF  x78
090BC:  MOVLB  0
090BE:  CALL   6310
090C2:  MOVLW  89
090C4:  MOVWF  FE9
090C6:  MOVFF  E1,66E
090CA:  MOVFF  E0,66D
090CE:  MOVFF  DF,66C
090D2:  MOVFF  DE,66B
090D6:  MOVLW  02
090D8:  MOVLB  6
090DA:  MOVWF  x6F
090DC:  MOVLB  0
090DE:  CALL   7038
090E2:  MOVLW  2C
090E4:  MOVLB  6
090E6:  MOVWF  x78
090E8:  MOVLB  0
090EA:  CALL   6310
....................    }
090EE:  BRA    9190
....................    else if (0 == strcmp(s_3V3D, arg1)) {
090F0:  MOVFF  65C,66A
090F4:  MOVFF  65B,669
090F8:  MOVFF  634,66C
090FC:  MOVFF  633,66B
09100:  CALL   6298
09104:  MOVF   01,F
09106:  BNZ   918A
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3D[0],monCal.v3V3D[1]);
09108:  MOVLW  04
0910A:  MOVLB  6
0910C:  MOVWF  x6A
0910E:  MOVLW  76
09110:  MOVWF  x69
09112:  MOVLB  0
09114:  CALL   6260
09118:  MOVFF  02,03
0911C:  MOVF   01,W
0911E:  ADDLW  76
09120:  MOVLB  6
09122:  MOVWF  x62
09124:  MOVLW  04
09126:  ADDWFC 02,W
09128:  MOVWF  x63
0912A:  MOVFF  FE8,51B
0912E:  MOVFF  662,51A
09132:  MOVLW  89
09134:  MOVWF  FE9
09136:  MOVFF  E5,66E
0913A:  MOVFF  E4,66D
0913E:  MOVFF  E3,66C
09142:  MOVFF  E2,66B
09146:  MOVLW  02
09148:  MOVWF  x6F
0914A:  MOVLB  0
0914C:  CALL   7038
09150:  MOVLW  2C
09152:  MOVLB  6
09154:  MOVWF  x78
09156:  MOVLB  0
09158:  CALL   6310
0915C:  MOVLW  89
0915E:  MOVWF  FE9
09160:  MOVFF  E9,66E
09164:  MOVFF  E8,66D
09168:  MOVFF  E7,66C
0916C:  MOVFF  E6,66B
09170:  MOVLW  02
09172:  MOVLB  6
09174:  MOVWF  x6F
09176:  MOVLB  0
09178:  CALL   7038
0917C:  MOVLW  2C
0917E:  MOVLB  6
09180:  MOVWF  x78
09182:  MOVLB  0
09184:  CALL   6310
....................    }
09188:  BRA    9190
.................... //!   else if (0 == strcmp(s_all, arg1)) {
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.vN15[0],monCal.vN15[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v200[0],monCal.v200[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v5V6[0],monCal.v5V6[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v5VA[0],monCal.v5VA[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V6X[0],monCal.v3V6X[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3A[0],monCal.v3V3A[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3D[0],monCal.v3V3D[1]);
.................... //!   }
....................    else return INV_PARAM;
0918A:  MOVLW  02
0918C:  MOVWF  01
0918E:  BRA    9194
....................    
....................    return SUCCESS;
09190:  MOVLW  00
09192:  MOVWF  01
09194:  RETURN 0
.................... }
.................... 
.................... int8 setMonitorCalParam(unsigned int8 rec){
.................... 
....................    return SUCCESS;
09196:  MOVLW  00
09198:  MOVWF  01
0919A:  RETURN 0
.................... }
.................... 
.................... int8 getMonitorValue(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    char *arg1;
....................    char *s_N15 = "N15";
0919C:  MOVLW  4E
0919E:  MOVLB  6
091A0:  MOVWF  x37
091A2:  MOVLW  31
091A4:  MOVWF  x38
091A6:  MOVLW  35
091A8:  MOVWF  x39
091AA:  CLRF   x3A
091AC:  MOVLW  06
091AE:  MOVWF  x36
091B0:  MOVLW  37
091B2:  MOVWF  x35
....................    char *s_200 = "200";
091B4:  MOVLW  32
091B6:  MOVWF  x3D
091B8:  MOVLW  30
091BA:  MOVWF  x3E
091BC:  MOVWF  x3F
091BE:  CLRF   x40
091C0:  MOVLW  06
091C2:  MOVWF  x3C
091C4:  MOVLW  3D
091C6:  MOVWF  x3B
....................    char *s_5V6 = "5V6";
091C8:  MOVLW  35
091CA:  MOVWF  x43
091CC:  MOVLW  56
091CE:  MOVWF  x44
091D0:  MOVLW  36
091D2:  MOVWF  x45
091D4:  CLRF   x46
091D6:  MOVLW  06
091D8:  MOVWF  x42
091DA:  MOVLW  43
091DC:  MOVWF  x41
....................    char *s_5VA = "5VA";
091DE:  MOVLW  35
091E0:  MOVWF  x49
091E2:  MOVLW  56
091E4:  MOVWF  x4A
091E6:  MOVLW  41
091E8:  MOVWF  x4B
091EA:  CLRF   x4C
091EC:  MOVLW  06
091EE:  MOVWF  x48
091F0:  MOVLW  49
091F2:  MOVWF  x47
....................    char *s_3V6X = "3V6X";
091F4:  MOVLW  33
091F6:  MOVWF  x4F
091F8:  MOVLW  56
091FA:  MOVWF  x50
091FC:  MOVLW  36
091FE:  MOVWF  x51
09200:  MOVLW  58
09202:  MOVWF  x52
09204:  CLRF   x53
09206:  MOVLW  06
09208:  MOVWF  x4E
0920A:  MOVLW  4F
0920C:  MOVWF  x4D
....................    char *s_3V3A = "3V3A";
0920E:  MOVLW  33
09210:  MOVWF  x56
09212:  MOVLW  56
09214:  MOVWF  x57
09216:  MOVLW  33
09218:  MOVWF  x58
0921A:  MOVLW  41
0921C:  MOVWF  x59
0921E:  CLRF   x5A
09220:  MOVLW  06
09222:  MOVWF  x55
09224:  MOVLW  56
09226:  MOVWF  x54
....................    char *s_3V3D = "3V3D";
09228:  MOVLW  33
0922A:  MOVWF  x5D
0922C:  MOVLW  56
0922E:  MOVWF  x5E
09230:  MOVLW  33
09232:  MOVWF  x5F
09234:  MOVLW  44
09236:  MOVWF  x60
09238:  CLRF   x61
0923A:  MOVLW  06
0923C:  MOVWF  x5C
0923E:  MOVLW  5D
09240:  MOVWF  x5B
....................    char *s_all = "all";
09242:  MOVLW  61
09244:  MOVWF  x64
09246:  MOVLW  6C
09248:  MOVWF  x65
0924A:  MOVWF  x66
0924C:  CLRF   x67
0924E:  MOVLW  06
09250:  MOVWF  x63
09252:  MOVLW  64
09254:  MOVWF  x62
....................    
....................    arg1 = SERcmd[rec].p[2];
09256:  CLRF   x6A
09258:  MOVFF  627,669
0925C:  CLRF   x6C
0925E:  MOVLW  B5
09260:  MOVWF  x6B
09262:  MOVLB  0
09264:  CALL   0FC4
09268:  MOVFF  02,669
0926C:  MOVFF  01,668
09270:  MOVLW  06
09272:  MOVLB  6
09274:  ADDWF  x68,F
09276:  MOVLW  00
09278:  ADDWFC x69,F
0927A:  MOVLW  32
0927C:  ADDWF  x68,W
0927E:  MOVWF  01
09280:  MOVLW  00
09282:  ADDWFC x69,W
09284:  MOVWF  03
09286:  MOVF   01,W
09288:  ADDLW  A0
0928A:  MOVWF  01
0928C:  MOVLW  01
0928E:  ADDWFC 03,F
09290:  MOVFF  01,633
09294:  MOVFF  03,634
....................    
....................    /*** GET MONITOR VALUES ************/
....................    if      (0 == strcmp(s_N15, arg1)) {
09298:  MOVFF  636,66A
0929C:  MOVFF  635,669
092A0:  MOVFF  634,66C
092A4:  MOVFF  633,66B
092A8:  MOVLB  0
092AA:  CALL   6298
092AE:  MOVF   01,F
092B0:  BNZ   9308
....................       sprintf(retData+strlen(retData), "%.2f,", monitorVals.vN15);
092B2:  MOVLW  04
092B4:  MOVLB  6
092B6:  MOVWF  x6A
092B8:  MOVLW  76
092BA:  MOVWF  x69
092BC:  MOVLB  0
092BE:  CALL   6260
092C2:  MOVFF  02,03
092C6:  MOVF   01,W
092C8:  ADDLW  76
092CA:  MOVLB  6
092CC:  MOVWF  x68
092CE:  MOVLW  04
092D0:  ADDWFC 02,W
092D2:  MOVWF  x69
092D4:  MOVFF  FE8,51B
092D8:  MOVFF  668,51A
092DC:  MOVLW  89
092DE:  MOVWF  FE9
092E0:  MOVFF  F6,66E
092E4:  MOVFF  F5,66D
092E8:  MOVFF  F4,66C
092EC:  MOVFF  F3,66B
092F0:  MOVLW  02
092F2:  MOVWF  x6F
092F4:  MOVLB  0
092F6:  CALL   7038
092FA:  MOVLW  2C
092FC:  MOVLB  6
092FE:  MOVWF  x78
09300:  MOVLB  0
09302:  CALL   6310
....................    }
09306:  BRA    980A
....................    else if (0 == strcmp(s_200, arg1)) {
09308:  MOVFF  63C,66A
0930C:  MOVFF  63B,669
09310:  MOVFF  634,66C
09314:  MOVFF  633,66B
09318:  CALL   6298
0931C:  MOVF   01,F
0931E:  BNZ   9376
....................       sprintf(retData+strlen(retData), "%.1f,", monitorVals.v200);
09320:  MOVLW  04
09322:  MOVLB  6
09324:  MOVWF  x6A
09326:  MOVLW  76
09328:  MOVWF  x69
0932A:  MOVLB  0
0932C:  CALL   6260
09330:  MOVFF  02,03
09334:  MOVF   01,W
09336:  ADDLW  76
09338:  MOVLB  6
0933A:  MOVWF  x68
0933C:  MOVLW  04
0933E:  ADDWFC 02,W
09340:  MOVWF  x69
09342:  MOVFF  FE8,51B
09346:  MOVFF  668,51A
0934A:  MOVLW  89
0934C:  MOVWF  FE9
0934E:  MOVFF  FA,66E
09352:  MOVFF  F9,66D
09356:  MOVFF  F8,66C
0935A:  MOVFF  F7,66B
0935E:  MOVLW  01
09360:  MOVWF  x6F
09362:  MOVLB  0
09364:  CALL   7038
09368:  MOVLW  2C
0936A:  MOVLB  6
0936C:  MOVWF  x78
0936E:  MOVLB  0
09370:  CALL   6310
....................    }
09374:  BRA    980A
....................    else if (0 == strcmp(s_5V6, arg1)) {
09376:  MOVFF  642,66A
0937A:  MOVFF  641,669
0937E:  MOVFF  634,66C
09382:  MOVFF  633,66B
09386:  CALL   6298
0938A:  MOVF   01,F
0938C:  BNZ   93E4
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5V6);
0938E:  MOVLW  04
09390:  MOVLB  6
09392:  MOVWF  x6A
09394:  MOVLW  76
09396:  MOVWF  x69
09398:  MOVLB  0
0939A:  CALL   6260
0939E:  MOVFF  02,03
093A2:  MOVF   01,W
093A4:  ADDLW  76
093A6:  MOVLB  6
093A8:  MOVWF  x68
093AA:  MOVLW  04
093AC:  ADDWFC 02,W
093AE:  MOVWF  x69
093B0:  MOVFF  FE8,51B
093B4:  MOVFF  668,51A
093B8:  MOVLW  89
093BA:  MOVWF  FE9
093BC:  MOVFF  FE,66E
093C0:  MOVFF  FD,66D
093C4:  MOVFF  FC,66C
093C8:  MOVFF  FB,66B
093CC:  MOVLW  03
093CE:  MOVWF  x6F
093D0:  MOVLB  0
093D2:  CALL   7038
093D6:  MOVLW  2C
093D8:  MOVLB  6
093DA:  MOVWF  x78
093DC:  MOVLB  0
093DE:  CALL   6310
....................    }
093E2:  BRA    980A
....................    else if (0 == strcmp(s_5VA, arg1)) {
093E4:  MOVFF  648,66A
093E8:  MOVFF  647,669
093EC:  MOVFF  634,66C
093F0:  MOVFF  633,66B
093F4:  CALL   6298
093F8:  MOVF   01,F
093FA:  BNZ   9452
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5VA);
093FC:  MOVLW  04
093FE:  MOVLB  6
09400:  MOVWF  x6A
09402:  MOVLW  76
09404:  MOVWF  x69
09406:  MOVLB  0
09408:  CALL   6260
0940C:  MOVFF  02,03
09410:  MOVF   01,W
09412:  ADDLW  76
09414:  MOVLB  6
09416:  MOVWF  x68
09418:  MOVLW  04
0941A:  ADDWFC 02,W
0941C:  MOVWF  x69
0941E:  MOVFF  FE8,51B
09422:  MOVFF  668,51A
09426:  MOVLW  89
09428:  MOVWF  FE9
0942A:  MOVFF  102,66E
0942E:  MOVFF  101,66D
09432:  MOVFF  100,66C
09436:  MOVFF  FF,66B
0943A:  MOVLW  03
0943C:  MOVWF  x6F
0943E:  MOVLB  0
09440:  CALL   7038
09444:  MOVLW  2C
09446:  MOVLB  6
09448:  MOVWF  x78
0944A:  MOVLB  0
0944C:  CALL   6310
....................    }
09450:  BRA    980A
....................    else if (0 == strcmp(s_3V6X, arg1)) {
09452:  MOVFF  64E,66A
09456:  MOVFF  64D,669
0945A:  MOVFF  634,66C
0945E:  MOVFF  633,66B
09462:  CALL   6298
09466:  MOVF   01,F
09468:  BNZ   94C0
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V6X);
0946A:  MOVLW  04
0946C:  MOVLB  6
0946E:  MOVWF  x6A
09470:  MOVLW  76
09472:  MOVWF  x69
09474:  MOVLB  0
09476:  CALL   6260
0947A:  MOVFF  02,03
0947E:  MOVF   01,W
09480:  ADDLW  76
09482:  MOVLB  6
09484:  MOVWF  x68
09486:  MOVLW  04
09488:  ADDWFC 02,W
0948A:  MOVWF  x69
0948C:  MOVFF  FE8,51B
09490:  MOVFF  668,51A
09494:  MOVLW  89
09496:  MOVWF  FE9
09498:  MOVFF  106,66E
0949C:  MOVFF  105,66D
094A0:  MOVFF  104,66C
094A4:  MOVFF  103,66B
094A8:  MOVLW  03
094AA:  MOVWF  x6F
094AC:  MOVLB  0
094AE:  CALL   7038
094B2:  MOVLW  2C
094B4:  MOVLB  6
094B6:  MOVWF  x78
094B8:  MOVLB  0
094BA:  CALL   6310
....................    }
094BE:  BRA    980A
....................    else if (0 == strcmp(s_3V3A, arg1)) {
094C0:  MOVFF  655,66A
094C4:  MOVFF  654,669
094C8:  MOVFF  634,66C
094CC:  MOVFF  633,66B
094D0:  CALL   6298
094D4:  MOVF   01,F
094D6:  BNZ   952E
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3A);
094D8:  MOVLW  04
094DA:  MOVLB  6
094DC:  MOVWF  x6A
094DE:  MOVLW  76
094E0:  MOVWF  x69
094E2:  MOVLB  0
094E4:  CALL   6260
094E8:  MOVFF  02,03
094EC:  MOVF   01,W
094EE:  ADDLW  76
094F0:  MOVLB  6
094F2:  MOVWF  x68
094F4:  MOVLW  04
094F6:  ADDWFC 02,W
094F8:  MOVWF  x69
094FA:  MOVFF  FE8,51B
094FE:  MOVFF  668,51A
09502:  MOVLW  89
09504:  MOVWF  FE9
09506:  MOVFF  10A,66E
0950A:  MOVFF  109,66D
0950E:  MOVFF  108,66C
09512:  MOVFF  107,66B
09516:  MOVLW  03
09518:  MOVWF  x6F
0951A:  MOVLB  0
0951C:  CALL   7038
09520:  MOVLW  2C
09522:  MOVLB  6
09524:  MOVWF  x78
09526:  MOVLB  0
09528:  CALL   6310
....................    }
0952C:  BRA    980A
....................    else if (0 == strcmp(s_3V3D, arg1)) {
0952E:  MOVFF  65C,66A
09532:  MOVFF  65B,669
09536:  MOVFF  634,66C
0953A:  MOVFF  633,66B
0953E:  CALL   6298
09542:  MOVF   01,F
09544:  BNZ   959C
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3D);
09546:  MOVLW  04
09548:  MOVLB  6
0954A:  MOVWF  x6A
0954C:  MOVLW  76
0954E:  MOVWF  x69
09550:  MOVLB  0
09552:  CALL   6260
09556:  MOVFF  02,03
0955A:  MOVF   01,W
0955C:  ADDLW  76
0955E:  MOVLB  6
09560:  MOVWF  x68
09562:  MOVLW  04
09564:  ADDWFC 02,W
09566:  MOVWF  x69
09568:  MOVFF  FE8,51B
0956C:  MOVFF  668,51A
09570:  MOVLW  89
09572:  MOVWF  FE9
09574:  MOVFF  10E,66E
09578:  MOVFF  10D,66D
0957C:  MOVFF  10C,66C
09580:  MOVFF  10B,66B
09584:  MOVLW  03
09586:  MOVWF  x6F
09588:  MOVLB  0
0958A:  CALL   7038
0958E:  MOVLW  2C
09590:  MOVLB  6
09592:  MOVWF  x78
09594:  MOVLB  0
09596:  CALL   6310
....................    }
0959A:  BRA    980A
....................    else if (0 == strcmp(s_all, arg1)) {
0959C:  MOVFF  663,66A
095A0:  MOVFF  662,669
095A4:  MOVFF  634,66C
095A8:  MOVFF  633,66B
095AC:  CALL   6298
095B0:  MOVF   01,F
095B2:  BTFSS  FD8.2
095B4:  BRA    9804
....................       sprintf(retData+strlen(retData), "%.2f,", monitorVals.vN15);
095B6:  MOVLW  04
095B8:  MOVLB  6
095BA:  MOVWF  x6A
095BC:  MOVLW  76
095BE:  MOVWF  x69
095C0:  MOVLB  0
095C2:  CALL   6260
095C6:  MOVFF  02,03
095CA:  MOVF   01,W
095CC:  ADDLW  76
095CE:  MOVLB  6
095D0:  MOVWF  x68
095D2:  MOVLW  04
095D4:  ADDWFC 02,W
095D6:  MOVWF  x69
095D8:  MOVFF  FE8,51B
095DC:  MOVFF  668,51A
095E0:  MOVLW  89
095E2:  MOVWF  FE9
095E4:  MOVFF  F6,66E
095E8:  MOVFF  F5,66D
095EC:  MOVFF  F4,66C
095F0:  MOVFF  F3,66B
095F4:  MOVLW  02
095F6:  MOVWF  x6F
095F8:  MOVLB  0
095FA:  CALL   7038
095FE:  MOVLW  2C
09600:  MOVLB  6
09602:  MOVWF  x78
09604:  MOVLB  0
09606:  CALL   6310
....................       sprintf(retData+strlen(retData), "%.1f,", monitorVals.v200);
0960A:  MOVLW  04
0960C:  MOVLB  6
0960E:  MOVWF  x6A
09610:  MOVLW  76
09612:  MOVWF  x69
09614:  MOVLB  0
09616:  CALL   6260
0961A:  MOVFF  02,03
0961E:  MOVF   01,W
09620:  ADDLW  76
09622:  MOVLB  6
09624:  MOVWF  x68
09626:  MOVLW  04
09628:  ADDWFC 02,W
0962A:  MOVWF  x69
0962C:  MOVFF  FE8,51B
09630:  MOVFF  668,51A
09634:  MOVLW  89
09636:  MOVWF  FE9
09638:  MOVFF  FA,66E
0963C:  MOVFF  F9,66D
09640:  MOVFF  F8,66C
09644:  MOVFF  F7,66B
09648:  MOVLW  01
0964A:  MOVWF  x6F
0964C:  MOVLB  0
0964E:  CALL   7038
09652:  MOVLW  2C
09654:  MOVLB  6
09656:  MOVWF  x78
09658:  MOVLB  0
0965A:  CALL   6310
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5V6);
0965E:  MOVLW  04
09660:  MOVLB  6
09662:  MOVWF  x6A
09664:  MOVLW  76
09666:  MOVWF  x69
09668:  MOVLB  0
0966A:  CALL   6260
0966E:  MOVFF  02,03
09672:  MOVF   01,W
09674:  ADDLW  76
09676:  MOVLB  6
09678:  MOVWF  x68
0967A:  MOVLW  04
0967C:  ADDWFC 02,W
0967E:  MOVWF  x69
09680:  MOVFF  FE8,51B
09684:  MOVFF  668,51A
09688:  MOVLW  89
0968A:  MOVWF  FE9
0968C:  MOVFF  FE,66E
09690:  MOVFF  FD,66D
09694:  MOVFF  FC,66C
09698:  MOVFF  FB,66B
0969C:  MOVLW  03
0969E:  MOVWF  x6F
096A0:  MOVLB  0
096A2:  CALL   7038
096A6:  MOVLW  2C
096A8:  MOVLB  6
096AA:  MOVWF  x78
096AC:  MOVLB  0
096AE:  CALL   6310
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5VA);
096B2:  MOVLW  04
096B4:  MOVLB  6
096B6:  MOVWF  x6A
096B8:  MOVLW  76
096BA:  MOVWF  x69
096BC:  MOVLB  0
096BE:  CALL   6260
096C2:  MOVFF  02,03
096C6:  MOVF   01,W
096C8:  ADDLW  76
096CA:  MOVLB  6
096CC:  MOVWF  x68
096CE:  MOVLW  04
096D0:  ADDWFC 02,W
096D2:  MOVWF  x69
096D4:  MOVFF  FE8,51B
096D8:  MOVFF  668,51A
096DC:  MOVLW  89
096DE:  MOVWF  FE9
096E0:  MOVFF  102,66E
096E4:  MOVFF  101,66D
096E8:  MOVFF  100,66C
096EC:  MOVFF  FF,66B
096F0:  MOVLW  03
096F2:  MOVWF  x6F
096F4:  MOVLB  0
096F6:  CALL   7038
096FA:  MOVLW  2C
096FC:  MOVLB  6
096FE:  MOVWF  x78
09700:  MOVLB  0
09702:  CALL   6310
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V6X);
09706:  MOVLW  04
09708:  MOVLB  6
0970A:  MOVWF  x6A
0970C:  MOVLW  76
0970E:  MOVWF  x69
09710:  MOVLB  0
09712:  CALL   6260
09716:  MOVFF  02,03
0971A:  MOVF   01,W
0971C:  ADDLW  76
0971E:  MOVLB  6
09720:  MOVWF  x68
09722:  MOVLW  04
09724:  ADDWFC 02,W
09726:  MOVWF  x69
09728:  MOVFF  FE8,51B
0972C:  MOVFF  668,51A
09730:  MOVLW  89
09732:  MOVWF  FE9
09734:  MOVFF  106,66E
09738:  MOVFF  105,66D
0973C:  MOVFF  104,66C
09740:  MOVFF  103,66B
09744:  MOVLW  03
09746:  MOVWF  x6F
09748:  MOVLB  0
0974A:  CALL   7038
0974E:  MOVLW  2C
09750:  MOVLB  6
09752:  MOVWF  x78
09754:  MOVLB  0
09756:  CALL   6310
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3A);
0975A:  MOVLW  04
0975C:  MOVLB  6
0975E:  MOVWF  x6A
09760:  MOVLW  76
09762:  MOVWF  x69
09764:  MOVLB  0
09766:  CALL   6260
0976A:  MOVFF  02,03
0976E:  MOVF   01,W
09770:  ADDLW  76
09772:  MOVLB  6
09774:  MOVWF  x68
09776:  MOVLW  04
09778:  ADDWFC 02,W
0977A:  MOVWF  x69
0977C:  MOVFF  FE8,51B
09780:  MOVFF  668,51A
09784:  MOVLW  89
09786:  MOVWF  FE9
09788:  MOVFF  10A,66E
0978C:  MOVFF  109,66D
09790:  MOVFF  108,66C
09794:  MOVFF  107,66B
09798:  MOVLW  03
0979A:  MOVWF  x6F
0979C:  MOVLB  0
0979E:  CALL   7038
097A2:  MOVLW  2C
097A4:  MOVLB  6
097A6:  MOVWF  x78
097A8:  MOVLB  0
097AA:  CALL   6310
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3D);
097AE:  MOVLW  04
097B0:  MOVLB  6
097B2:  MOVWF  x6A
097B4:  MOVLW  76
097B6:  MOVWF  x69
097B8:  MOVLB  0
097BA:  CALL   6260
097BE:  MOVFF  02,03
097C2:  MOVF   01,W
097C4:  ADDLW  76
097C6:  MOVLB  6
097C8:  MOVWF  x68
097CA:  MOVLW  04
097CC:  ADDWFC 02,W
097CE:  MOVWF  x69
097D0:  MOVFF  FE8,51B
097D4:  MOVFF  668,51A
097D8:  MOVLW  89
097DA:  MOVWF  FE9
097DC:  MOVFF  10E,66E
097E0:  MOVFF  10D,66D
097E4:  MOVFF  10C,66C
097E8:  MOVFF  10B,66B
097EC:  MOVLW  03
097EE:  MOVWF  x6F
097F0:  MOVLB  0
097F2:  CALL   7038
097F6:  MOVLW  2C
097F8:  MOVLB  6
097FA:  MOVWF  x78
097FC:  MOVLB  0
097FE:  CALL   6310
....................    }
09802:  BRA    980A
....................    else return INV_PARAM;
09804:  MOVLW  02
09806:  MOVWF  01
09808:  BRA    980E
....................    
....................    return SUCCESS;
0980A:  MOVLW  00
0980C:  MOVWF  01
0980E:  RETURN 0
.................... }
.................... 
.................... int8 getPIDdata(unsigned int8 rec){
....................   /*** ARG CHECKS ********************/ 
....................    int8 arg1;
....................    char *arg2;
....................    char *s_PV = "PV";
09810:  MOVLW  50
09812:  MOVLB  6
09814:  MOVWF  x38
09816:  MOVLW  56
09818:  MOVWF  x39
0981A:  CLRF   x3A
0981C:  MOVLW  06
0981E:  MOVWF  x37
09820:  MOVLW  38
09822:  MOVWF  x36
....................    char *s_CV = "CV";
09824:  MOVLW  43
09826:  MOVWF  x3D
09828:  MOVLW  56
0982A:  MOVWF  x3E
0982C:  CLRF   x3F
0982E:  MOVLW  06
09830:  MOVWF  x3C
09832:  MOVLW  3D
09834:  MOVWF  x3B
....................    char *s_PVold = "PVold";
09836:  MOVLW  50
09838:  MOVWF  x42
0983A:  MOVLW  56
0983C:  MOVWF  x43
0983E:  MOVLW  6F
09840:  MOVWF  x44
09842:  MOVLW  6C
09844:  MOVWF  x45
09846:  MOVLW  64
09848:  MOVWF  x46
0984A:  CLRF   x47
0984C:  MOVLW  06
0984E:  MOVWF  x41
09850:  MOVLW  42
09852:  MOVWF  x40
....................    char *s_I = "I";
09854:  MOVLW  49
09856:  MOVWF  x4A
09858:  CLRF   x4B
0985A:  MOVLW  06
0985C:  MOVWF  x49
0985E:  MOVLW  4A
09860:  MOVWF  x48
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
09862:  CLRF   x6A
09864:  MOVFF  627,669
09868:  CLRF   x6C
0986A:  MOVLW  B5
0986C:  MOVWF  x6B
0986E:  MOVLB  0
09870:  CALL   0FC4
09874:  MOVFF  02,64D
09878:  MOVFF  01,64C
0987C:  MOVLW  06
0987E:  MOVLB  6
09880:  ADDWF  x4C,F
09882:  MOVLW  00
09884:  ADDWFC x4D,F
09886:  MOVLW  32
09888:  ADDWF  x4C,W
0988A:  MOVWF  01
0988C:  MOVLW  00
0988E:  ADDWFC x4D,W
09890:  MOVWF  03
09892:  MOVF   01,W
09894:  ADDLW  A0
09896:  MOVWF  01
09898:  MOVLW  01
0989A:  ADDWFC 03,F
0989C:  MOVFF  01,64C
098A0:  MOVFF  03,64D
098A4:  MOVFF  03,65C
098A8:  MOVFF  01,65B
098AC:  MOVLB  0
098AE:  CALL   63D8
098B2:  MOVF   01,F
098B4:  BNZ   98BE
098B6:  MOVLW  02
098B8:  MOVWF  01
098BA:  BRA    9C54
098BC:  BRA    991C
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
098BE:  MOVLB  6
098C0:  CLRF   x6A
098C2:  MOVFF  627,669
098C6:  CLRF   x6C
098C8:  MOVLW  B5
098CA:  MOVWF  x6B
098CC:  MOVLB  0
098CE:  CALL   0FC4
098D2:  MOVFF  02,64D
098D6:  MOVFF  01,64C
098DA:  MOVLW  06
098DC:  MOVLB  6
098DE:  ADDWF  x4C,F
098E0:  MOVLW  00
098E2:  ADDWFC x4D,F
098E4:  MOVLW  32
098E6:  ADDWF  x4C,W
098E8:  MOVWF  01
098EA:  MOVLW  00
098EC:  ADDWFC x4D,W
098EE:  MOVWF  03
098F0:  MOVF   01,W
098F2:  ADDLW  A0
098F4:  MOVWF  01
098F6:  MOVLW  01
098F8:  ADDWFC 03,F
098FA:  MOVFF  01,64C
098FE:  MOVFF  03,64D
09902:  MOVFF  03,65C
09906:  MOVFF  01,65B
0990A:  CLRF   x5E
0990C:  CLRF   x5D
0990E:  MOVLW  0A
09910:  MOVWF  x5F
09912:  MOVLB  0
09914:  CALL   64C8
09918:  MOVFF  01,633
....................    
....................    arg2 = SERcmd[rec].p[3];
0991C:  MOVLB  6
0991E:  CLRF   x6A
09920:  MOVFF  627,669
09924:  CLRF   x6C
09926:  MOVLW  B5
09928:  MOVWF  x6B
0992A:  MOVLB  0
0992C:  CALL   0FC4
09930:  MOVFF  02,64D
09934:  MOVFF  01,64C
09938:  MOVLW  06
0993A:  MOVLB  6
0993C:  ADDWF  x4C,F
0993E:  MOVLW  00
09940:  ADDWFC x4D,F
09942:  MOVLW  4B
09944:  ADDWF  x4C,W
09946:  MOVWF  01
09948:  MOVLW  00
0994A:  ADDWFC x4D,W
0994C:  MOVWF  03
0994E:  MOVF   01,W
09950:  ADDLW  A0
09952:  MOVWF  01
09954:  MOVLW  01
09956:  ADDWFC 03,F
09958:  MOVFF  01,634
0995C:  MOVFF  03,635
....................    
....................    /*** GET PV, CV, PVold, I, or A(LL) VALUE **********/
....................    if      (0 == strcmp(s_PV, arg2))     sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].PV);
09960:  MOVFF  637,66A
09964:  MOVFF  636,669
09968:  MOVFF  635,66C
0996C:  MOVFF  634,66B
09970:  MOVLB  0
09972:  CALL   6298
09976:  MOVF   01,F
09978:  BNZ   9A1C
0997A:  MOVLW  04
0997C:  MOVLB  6
0997E:  MOVWF  x6A
09980:  MOVLW  76
09982:  MOVWF  x69
09984:  MOVLB  0
09986:  CALL   6260
0998A:  MOVF   01,W
0998C:  ADDLW  76
0998E:  MOVLB  6
09990:  MOVWF  x4C
09992:  MOVLW  04
09994:  ADDWFC 02,W
09996:  MOVWF  x4D
09998:  MOVLW  01
0999A:  SUBWF  x33,W
0999C:  MULLW  20
0999E:  MOVF   FF3,W
099A0:  CLRF   x4F
099A2:  MOVWF  x4E
099A4:  MOVLW  10
099A6:  ADDWF  x4E,W
099A8:  MOVWF  01
099AA:  MOVLW  00
099AC:  ADDWFC x4F,W
099AE:  MOVWF  03
099B0:  MOVF   01,W
099B2:  ADDLW  20
099B4:  MOVWF  FE9
099B6:  MOVLW  00
099B8:  ADDWFC 03,W
099BA:  MOVWF  FEA
099BC:  MOVFF  FEF,64E
099C0:  MOVFF  FEC,64F
099C4:  MOVFF  FEC,650
099C8:  MOVFF  FEC,651
099CC:  MOVFF  64D,51B
099D0:  MOVFF  64C,51A
099D4:  MOVFF  633,65C
099D8:  MOVLW  18
099DA:  MOVWF  x5D
099DC:  MOVLB  0
099DE:  CALL   681C
099E2:  MOVLW  2C
099E4:  MOVLB  6
099E6:  MOVWF  x78
099E8:  MOVLB  0
099EA:  CALL   6310
099EE:  MOVLW  89
099F0:  MOVWF  FE9
099F2:  MOVFF  651,66E
099F6:  MOVFF  650,66D
099FA:  MOVFF  64F,66C
099FE:  MOVFF  64E,66B
09A02:  MOVLW  02
09A04:  MOVLB  6
09A06:  MOVWF  x6F
09A08:  MOVLB  0
09A0A:  CALL   7038
09A0E:  MOVLW  2C
09A10:  MOVLB  6
09A12:  MOVWF  x78
09A14:  MOVLB  0
09A16:  CALL   6310
09A1A:  BRA    9C50
....................    else if (0 == strcmp(s_CV, arg2))     sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].CV);
09A1C:  MOVFF  63C,66A
09A20:  MOVFF  63B,669
09A24:  MOVFF  635,66C
09A28:  MOVFF  634,66B
09A2C:  CALL   6298
09A30:  MOVF   01,F
09A32:  BNZ   9AD6
09A34:  MOVLW  04
09A36:  MOVLB  6
09A38:  MOVWF  x6A
09A3A:  MOVLW  76
09A3C:  MOVWF  x69
09A3E:  MOVLB  0
09A40:  CALL   6260
09A44:  MOVF   01,W
09A46:  ADDLW  76
09A48:  MOVLB  6
09A4A:  MOVWF  x4C
09A4C:  MOVLW  04
09A4E:  ADDWFC 02,W
09A50:  MOVWF  x4D
09A52:  MOVLW  01
09A54:  SUBWF  x33,W
09A56:  MULLW  20
09A58:  MOVF   FF3,W
09A5A:  CLRF   x4F
09A5C:  MOVWF  x4E
09A5E:  MOVLW  18
09A60:  ADDWF  x4E,W
09A62:  MOVWF  01
09A64:  MOVLW  00
09A66:  ADDWFC x4F,W
09A68:  MOVWF  03
09A6A:  MOVF   01,W
09A6C:  ADDLW  20
09A6E:  MOVWF  FE9
09A70:  MOVLW  00
09A72:  ADDWFC 03,W
09A74:  MOVWF  FEA
09A76:  MOVFF  FEF,64E
09A7A:  MOVFF  FEC,64F
09A7E:  MOVFF  FEC,650
09A82:  MOVFF  FEC,651
09A86:  MOVFF  64D,51B
09A8A:  MOVFF  64C,51A
09A8E:  MOVFF  633,65C
09A92:  MOVLW  18
09A94:  MOVWF  x5D
09A96:  MOVLB  0
09A98:  CALL   681C
09A9C:  MOVLW  2C
09A9E:  MOVLB  6
09AA0:  MOVWF  x78
09AA2:  MOVLB  0
09AA4:  CALL   6310
09AA8:  MOVLW  89
09AAA:  MOVWF  FE9
09AAC:  MOVFF  651,66E
09AB0:  MOVFF  650,66D
09AB4:  MOVFF  64F,66C
09AB8:  MOVFF  64E,66B
09ABC:  MOVLW  02
09ABE:  MOVLB  6
09AC0:  MOVWF  x6F
09AC2:  MOVLB  0
09AC4:  CALL   7038
09AC8:  MOVLW  2C
09ACA:  MOVLB  6
09ACC:  MOVWF  x78
09ACE:  MOVLB  0
09AD0:  CALL   6310
09AD4:  BRA    9C50
....................    else if (0 == strcmp(s_PVold, arg2))  sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].PVold);
09AD6:  MOVFF  641,66A
09ADA:  MOVFF  640,669
09ADE:  MOVFF  635,66C
09AE2:  MOVFF  634,66B
09AE6:  CALL   6298
09AEA:  MOVF   01,F
09AEC:  BNZ   9B90
09AEE:  MOVLW  04
09AF0:  MOVLB  6
09AF2:  MOVWF  x6A
09AF4:  MOVLW  76
09AF6:  MOVWF  x69
09AF8:  MOVLB  0
09AFA:  CALL   6260
09AFE:  MOVF   01,W
09B00:  ADDLW  76
09B02:  MOVLB  6
09B04:  MOVWF  x4C
09B06:  MOVLW  04
09B08:  ADDWFC 02,W
09B0A:  MOVWF  x4D
09B0C:  MOVLW  01
09B0E:  SUBWF  x33,W
09B10:  MULLW  20
09B12:  MOVF   FF3,W
09B14:  CLRF   x4F
09B16:  MOVWF  x4E
09B18:  MOVLW  14
09B1A:  ADDWF  x4E,W
09B1C:  MOVWF  01
09B1E:  MOVLW  00
09B20:  ADDWFC x4F,W
09B22:  MOVWF  03
09B24:  MOVF   01,W
09B26:  ADDLW  20
09B28:  MOVWF  FE9
09B2A:  MOVLW  00
09B2C:  ADDWFC 03,W
09B2E:  MOVWF  FEA
09B30:  MOVFF  FEF,64E
09B34:  MOVFF  FEC,64F
09B38:  MOVFF  FEC,650
09B3C:  MOVFF  FEC,651
09B40:  MOVFF  64D,51B
09B44:  MOVFF  64C,51A
09B48:  MOVFF  633,65C
09B4C:  MOVLW  18
09B4E:  MOVWF  x5D
09B50:  MOVLB  0
09B52:  CALL   681C
09B56:  MOVLW  2C
09B58:  MOVLB  6
09B5A:  MOVWF  x78
09B5C:  MOVLB  0
09B5E:  CALL   6310
09B62:  MOVLW  89
09B64:  MOVWF  FE9
09B66:  MOVFF  651,66E
09B6A:  MOVFF  650,66D
09B6E:  MOVFF  64F,66C
09B72:  MOVFF  64E,66B
09B76:  MOVLW  02
09B78:  MOVLB  6
09B7A:  MOVWF  x6F
09B7C:  MOVLB  0
09B7E:  CALL   7038
09B82:  MOVLW  2C
09B84:  MOVLB  6
09B86:  MOVWF  x78
09B88:  MOVLB  0
09B8A:  CALL   6310
09B8E:  BRA    9C50
....................    else if (0 == strcmp(s_I, arg2))      sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].I);
09B90:  MOVFF  649,66A
09B94:  MOVFF  648,669
09B98:  MOVFF  635,66C
09B9C:  MOVFF  634,66B
09BA0:  CALL   6298
09BA4:  MOVF   01,F
09BA6:  BNZ   9C4A
09BA8:  MOVLW  04
09BAA:  MOVLB  6
09BAC:  MOVWF  x6A
09BAE:  MOVLW  76
09BB0:  MOVWF  x69
09BB2:  MOVLB  0
09BB4:  CALL   6260
09BB8:  MOVF   01,W
09BBA:  ADDLW  76
09BBC:  MOVLB  6
09BBE:  MOVWF  x4C
09BC0:  MOVLW  04
09BC2:  ADDWFC 02,W
09BC4:  MOVWF  x4D
09BC6:  MOVLW  01
09BC8:  SUBWF  x33,W
09BCA:  MULLW  20
09BCC:  MOVF   FF3,W
09BCE:  CLRF   x4F
09BD0:  MOVWF  x4E
09BD2:  MOVLW  1C
09BD4:  ADDWF  x4E,W
09BD6:  MOVWF  01
09BD8:  MOVLW  00
09BDA:  ADDWFC x4F,W
09BDC:  MOVWF  03
09BDE:  MOVF   01,W
09BE0:  ADDLW  20
09BE2:  MOVWF  FE9
09BE4:  MOVLW  00
09BE6:  ADDWFC 03,W
09BE8:  MOVWF  FEA
09BEA:  MOVFF  FEF,64E
09BEE:  MOVFF  FEC,64F
09BF2:  MOVFF  FEC,650
09BF6:  MOVFF  FEC,651
09BFA:  MOVFF  64D,51B
09BFE:  MOVFF  64C,51A
09C02:  MOVFF  633,65C
09C06:  MOVLW  18
09C08:  MOVWF  x5D
09C0A:  MOVLB  0
09C0C:  CALL   681C
09C10:  MOVLW  2C
09C12:  MOVLB  6
09C14:  MOVWF  x78
09C16:  MOVLB  0
09C18:  CALL   6310
09C1C:  MOVLW  89
09C1E:  MOVWF  FE9
09C20:  MOVFF  651,66E
09C24:  MOVFF  650,66D
09C28:  MOVFF  64F,66C
09C2C:  MOVFF  64E,66B
09C30:  MOVLW  02
09C32:  MOVLB  6
09C34:  MOVWF  x6F
09C36:  MOVLB  0
09C38:  CALL   7038
09C3C:  MOVLW  2C
09C3E:  MOVLB  6
09C40:  MOVWF  x78
09C42:  MOVLB  0
09C44:  CALL   6310
09C48:  BRA    9C50
....................    else return INV_PARAM;
09C4A:  MOVLW  02
09C4C:  MOVWF  01
09C4E:  BRA    9C54
....................    
....................    return SUCCESS;
09C50:  MOVLW  00
09C52:  MOVWF  01
09C54:  RETURN 0
.................... }
.................... 
.................... int8 getIPdata(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char *arg2;
....................    char *s_raw = "raw";
*
09D74:  MOVLW  72
09D76:  MOVLB  6
09D78:  MOVWF  x38
09D7A:  MOVLW  61
09D7C:  MOVWF  x39
09D7E:  MOVLW  77
09D80:  MOVWF  x3A
09D82:  CLRF   x3B
09D84:  MOVLW  06
09D86:  MOVWF  x37
09D88:  MOVLW  38
09D8A:  MOVWF  x36
....................    char *s_calibrated = "calib";
09D8C:  MOVLW  63
09D8E:  MOVWF  x3E
09D90:  MOVLW  61
09D92:  MOVWF  x3F
09D94:  MOVLW  6C
09D96:  MOVWF  x40
09D98:  MOVLW  69
09D9A:  MOVWF  x41
09D9C:  MOVLW  62
09D9E:  MOVWF  x42
09DA0:  CLRF   x43
09DA2:  MOVLW  06
09DA4:  MOVWF  x3D
09DA6:  MOVLW  3E
09DA8:  MOVWF  x3C
....................    char *s_p0 = "p0";
09DAA:  MOVLW  70
09DAC:  MOVWF  x46
09DAE:  MOVLW  30
09DB0:  MOVWF  x47
09DB2:  CLRF   x48
09DB4:  MOVLW  06
09DB6:  MOVWF  x45
09DB8:  MOVLW  46
09DBA:  MOVWF  x44
....................    char *s_poles = "poles";
09DBC:  MOVLW  70
09DBE:  MOVWF  x4B
09DC0:  MOVLW  6F
09DC2:  MOVWF  x4C
09DC4:  MOVLW  6C
09DC6:  MOVWF  x4D
09DC8:  MOVLW  65
09DCA:  MOVWF  x4E
09DCC:  MOVLW  73
09DCE:  MOVWF  x4F
09DD0:  CLRF   x50
09DD2:  MOVLW  06
09DD4:  MOVWF  x4A
09DD6:  MOVLW  4B
09DD8:  MOVWF  x49
....................    char *s_real = "real";
09DDA:  MOVLW  72
09DDC:  MOVWF  x53
09DDE:  MOVLW  65
09DE0:  MOVWF  x54
09DE2:  MOVLW  61
09DE4:  MOVWF  x55
09DE6:  MOVLW  6C
09DE8:  MOVWF  x56
09DEA:  CLRF   x57
09DEC:  MOVLW  06
09DEE:  MOVWF  x52
09DF0:  MOVLW  53
09DF2:  MOVWF  x51
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
09DF4:  CLRF   x6A
09DF6:  MOVFF  627,669
09DFA:  CLRF   x6C
09DFC:  MOVLW  B5
09DFE:  MOVWF  x6B
09E00:  MOVLB  0
09E02:  CALL   0FC4
09E06:  MOVFF  02,659
09E0A:  MOVFF  01,658
09E0E:  MOVLW  06
09E10:  MOVLB  6
09E12:  ADDWF  x58,F
09E14:  MOVLW  00
09E16:  ADDWFC x59,F
09E18:  MOVLW  32
09E1A:  ADDWF  x58,W
09E1C:  MOVWF  01
09E1E:  MOVLW  00
09E20:  ADDWFC x59,W
09E22:  MOVWF  03
09E24:  MOVF   01,W
09E26:  ADDLW  A0
09E28:  MOVWF  01
09E2A:  MOVLW  01
09E2C:  ADDWFC 03,F
09E2E:  MOVFF  01,658
09E32:  MOVFF  03,659
09E36:  MOVFF  03,65C
09E3A:  MOVFF  01,65B
09E3E:  MOVLB  0
09E40:  CALL   63D8
09E44:  MOVF   01,F
09E46:  BNZ   9E50
09E48:  MOVLW  02
09E4A:  MOVWF  01
09E4C:  BRA    A494
09E4E:  BRA    9EAE
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
09E50:  MOVLB  6
09E52:  CLRF   x6A
09E54:  MOVFF  627,669
09E58:  CLRF   x6C
09E5A:  MOVLW  B5
09E5C:  MOVWF  x6B
09E5E:  MOVLB  0
09E60:  CALL   0FC4
09E64:  MOVFF  02,659
09E68:  MOVFF  01,658
09E6C:  MOVLW  06
09E6E:  MOVLB  6
09E70:  ADDWF  x58,F
09E72:  MOVLW  00
09E74:  ADDWFC x59,F
09E76:  MOVLW  32
09E78:  ADDWF  x58,W
09E7A:  MOVWF  01
09E7C:  MOVLW  00
09E7E:  ADDWFC x59,W
09E80:  MOVWF  03
09E82:  MOVF   01,W
09E84:  ADDLW  A0
09E86:  MOVWF  01
09E88:  MOVLW  01
09E8A:  ADDWFC 03,F
09E8C:  MOVFF  01,658
09E90:  MOVFF  03,659
09E94:  MOVFF  03,65C
09E98:  MOVFF  01,65B
09E9C:  CLRF   x5E
09E9E:  CLRF   x5D
09EA0:  MOVLW  0A
09EA2:  MOVWF  x5F
09EA4:  MOVLB  0
09EA6:  CALL   64C8
09EAA:  MOVFF  01,633
....................    
....................    arg2 = SERcmd[rec].p[3];
09EAE:  MOVLB  6
09EB0:  CLRF   x6A
09EB2:  MOVFF  627,669
09EB6:  CLRF   x6C
09EB8:  MOVLW  B5
09EBA:  MOVWF  x6B
09EBC:  MOVLB  0
09EBE:  CALL   0FC4
09EC2:  MOVFF  02,659
09EC6:  MOVFF  01,658
09ECA:  MOVLW  06
09ECC:  MOVLB  6
09ECE:  ADDWF  x58,F
09ED0:  MOVLW  00
09ED2:  ADDWFC x59,F
09ED4:  MOVLW  4B
09ED6:  ADDWF  x58,W
09ED8:  MOVWF  01
09EDA:  MOVLW  00
09EDC:  ADDWFC x59,W
09EDE:  MOVWF  03
09EE0:  MOVF   01,W
09EE2:  ADDLW  A0
09EE4:  MOVWF  01
09EE6:  MOVLW  01
09EE8:  ADDWFC 03,F
09EEA:  MOVFF  01,634
09EEE:  MOVFF  03,635
....................    
....................    /*** GET INPUT DATA ****************/
....................    if      (0 == strcmp(s_raw, arg2)) {
09EF2:  MOVFF  637,66A
09EF6:  MOVFF  636,669
09EFA:  MOVFF  635,66C
09EFE:  MOVFF  634,66B
09F02:  MOVLB  0
09F04:  CALL   6298
09F08:  MOVF   01,F
09F0A:  BTFSS  FD8.2
09F0C:  BRA    A088
....................       sprintf(retData+strlen(retData), "%d,", arg1);
09F0E:  MOVLW  04
09F10:  MOVLB  6
09F12:  MOVWF  x6A
09F14:  MOVLW  76
09F16:  MOVWF  x69
09F18:  MOVLB  0
09F1A:  CALL   6260
09F1E:  MOVFF  02,03
09F22:  MOVF   01,W
09F24:  ADDLW  76
09F26:  MOVLB  6
09F28:  MOVWF  x58
09F2A:  MOVLW  04
09F2C:  ADDWFC 02,W
09F2E:  MOVWF  x59
09F30:  MOVFF  FE8,51B
09F34:  MOVFF  658,51A
09F38:  MOVFF  633,65C
09F3C:  MOVLW  18
09F3E:  MOVWF  x5D
09F40:  MOVLB  0
09F42:  CALL   681C
09F46:  MOVLW  2C
09F48:  MOVLB  6
09F4A:  MOVWF  x78
09F4C:  MOVLB  0
09F4E:  CALL   6310
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].sinRaw);
09F52:  MOVLW  04
09F54:  MOVLB  6
09F56:  MOVWF  x6A
09F58:  MOVLW  76
09F5A:  MOVWF  x69
09F5C:  MOVLB  0
09F5E:  CALL   6260
09F62:  MOVFF  02,03
09F66:  MOVF   01,W
09F68:  ADDLW  76
09F6A:  MOVLB  6
09F6C:  MOVWF  x58
09F6E:  MOVLW  04
09F70:  ADDWFC 02,W
09F72:  MOVWF  x59
09F74:  MOVLW  01
09F76:  SUBWF  x33,W
09F78:  MULLW  21
09F7A:  MOVF   FF3,W
09F7C:  CLRF   x5B
09F7E:  MOVWF  x5A
09F80:  MOVLW  0F
09F82:  ADDWF  x5A,W
09F84:  MOVWF  FE9
09F86:  MOVLW  01
09F88:  ADDWFC x5B,W
09F8A:  MOVWF  FEA
09F8C:  MOVFF  FEF,678
09F90:  MOVFF  FEC,01
09F94:  MOVFF  FEC,02
09F98:  MOVFF  FEC,03
09F9C:  MOVFF  03,67B
09FA0:  MOVFF  02,67A
09FA4:  MOVFF  01,679
09FA8:  MOVLB  0
09FAA:  CALL   5E7E
09FAE:  MOVFF  03,65F
09FB2:  MOVFF  02,65E
09FB6:  MOVFF  01,65D
09FBA:  MOVFF  00,65C
09FBE:  MOVFF  659,51B
09FC2:  MOVFF  658,51A
09FC6:  MOVLW  41
09FC8:  MOVWF  FE9
09FCA:  MOVFF  03,664
09FCE:  MOVFF  02,663
09FD2:  MOVFF  01,662
09FD6:  MOVFF  00,661
09FDA:  RCALL  9C56
09FDC:  MOVLW  2C
09FDE:  MOVLB  6
09FE0:  MOVWF  x78
09FE2:  MOVLB  0
09FE4:  CALL   6310
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].cosRaw);
09FE8:  MOVLW  04
09FEA:  MOVLB  6
09FEC:  MOVWF  x6A
09FEE:  MOVLW  76
09FF0:  MOVWF  x69
09FF2:  MOVLB  0
09FF4:  CALL   6260
09FF8:  MOVF   01,W
09FFA:  ADDLW  76
09FFC:  MOVLB  6
09FFE:  MOVWF  x58
0A000:  MOVLW  04
0A002:  ADDWFC 02,W
0A004:  MOVWF  x59
0A006:  MOVLW  01
0A008:  SUBWF  x33,W
0A00A:  MULLW  21
0A00C:  MOVF   FF3,W
0A00E:  CLRF   x5B
0A010:  MOVWF  x5A
0A012:  MOVLW  04
0A014:  ADDWF  x5A,W
0A016:  MOVWF  01
0A018:  MOVLW  00
0A01A:  ADDWFC x5B,W
0A01C:  MOVWF  03
0A01E:  MOVF   01,W
0A020:  ADDLW  0F
0A022:  MOVWF  FE9
0A024:  MOVLW  01
0A026:  ADDWFC 03,W
0A028:  MOVWF  FEA
0A02A:  MOVFF  FEF,678
0A02E:  MOVFF  FEC,01
0A032:  MOVFF  FEC,02
0A036:  MOVFF  FEC,03
0A03A:  MOVFF  03,67B
0A03E:  MOVFF  02,67A
0A042:  MOVFF  01,679
0A046:  MOVLB  0
0A048:  CALL   5E7E
0A04C:  MOVFF  03,65D
0A050:  MOVFF  02,65C
0A054:  MOVFF  01,65B
0A058:  MOVFF  00,65A
0A05C:  MOVFF  659,51B
0A060:  MOVFF  658,51A
0A064:  MOVLW  41
0A066:  MOVWF  FE9
0A068:  MOVFF  03,664
0A06C:  MOVFF  02,663
0A070:  MOVFF  01,662
0A074:  MOVFF  00,661
0A078:  RCALL  9C56
0A07A:  MOVLW  2C
0A07C:  MOVLB  6
0A07E:  MOVWF  x78
0A080:  MOVLB  0
0A082:  CALL   6310
....................    }
0A086:  BRA    A490
....................    else if (0 == strcmp(s_calibrated, arg2)) {
0A088:  MOVFF  63D,66A
0A08C:  MOVFF  63C,669
0A090:  MOVFF  635,66C
0A094:  MOVFF  634,66B
0A098:  CALL   6298
0A09C:  MOVF   01,F
0A09E:  BTFSS  FD8.2
0A0A0:  BRA    A224
....................       sprintf(retData+strlen(retData), "%d,", arg1);
0A0A2:  MOVLW  04
0A0A4:  MOVLB  6
0A0A6:  MOVWF  x6A
0A0A8:  MOVLW  76
0A0AA:  MOVWF  x69
0A0AC:  MOVLB  0
0A0AE:  CALL   6260
0A0B2:  MOVFF  02,03
0A0B6:  MOVF   01,W
0A0B8:  ADDLW  76
0A0BA:  MOVLB  6
0A0BC:  MOVWF  x58
0A0BE:  MOVLW  04
0A0C0:  ADDWFC 02,W
0A0C2:  MOVWF  x59
0A0C4:  MOVFF  FE8,51B
0A0C8:  MOVFF  658,51A
0A0CC:  MOVFF  633,65C
0A0D0:  MOVLW  18
0A0D2:  MOVWF  x5D
0A0D4:  MOVLB  0
0A0D6:  CALL   681C
0A0DA:  MOVLW  2C
0A0DC:  MOVLB  6
0A0DE:  MOVWF  x78
0A0E0:  MOVLB  0
0A0E2:  CALL   6310
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].sinCounts);
0A0E6:  MOVLW  04
0A0E8:  MOVLB  6
0A0EA:  MOVWF  x6A
0A0EC:  MOVLW  76
0A0EE:  MOVWF  x69
0A0F0:  MOVLB  0
0A0F2:  CALL   6260
0A0F6:  MOVF   01,W
0A0F8:  ADDLW  76
0A0FA:  MOVLB  6
0A0FC:  MOVWF  x58
0A0FE:  MOVLW  04
0A100:  ADDWFC 02,W
0A102:  MOVWF  x59
0A104:  MOVLW  01
0A106:  SUBWF  x33,W
0A108:  MULLW  21
0A10A:  MOVF   FF3,W
0A10C:  CLRF   x5B
0A10E:  MOVWF  x5A
0A110:  MOVLW  08
0A112:  ADDWF  x5A,W
0A114:  MOVWF  01
0A116:  MOVLW  00
0A118:  ADDWFC x5B,W
0A11A:  MOVWF  03
0A11C:  MOVF   01,W
0A11E:  ADDLW  0F
0A120:  MOVWF  FE9
0A122:  MOVLW  01
0A124:  ADDWFC 03,W
0A126:  MOVWF  FEA
0A128:  MOVFF  FEF,678
0A12C:  MOVFF  FEC,01
0A130:  MOVFF  FEC,02
0A134:  MOVFF  FEC,03
0A138:  MOVFF  03,67B
0A13C:  MOVFF  02,67A
0A140:  MOVFF  01,679
0A144:  MOVLB  0
0A146:  CALL   5E7E
0A14A:  MOVFF  03,65D
0A14E:  MOVFF  02,65C
0A152:  MOVFF  01,65B
0A156:  MOVFF  00,65A
0A15A:  MOVFF  659,51B
0A15E:  MOVFF  658,51A
0A162:  MOVLW  41
0A164:  MOVWF  FE9
0A166:  MOVFF  03,664
0A16A:  MOVFF  02,663
0A16E:  MOVFF  01,662
0A172:  MOVFF  00,661
0A176:  RCALL  9C56
0A178:  MOVLW  2C
0A17A:  MOVLB  6
0A17C:  MOVWF  x78
0A17E:  MOVLB  0
0A180:  CALL   6310
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].cosCounts);
0A184:  MOVLW  04
0A186:  MOVLB  6
0A188:  MOVWF  x6A
0A18A:  MOVLW  76
0A18C:  MOVWF  x69
0A18E:  MOVLB  0
0A190:  CALL   6260
0A194:  MOVF   01,W
0A196:  ADDLW  76
0A198:  MOVLB  6
0A19A:  MOVWF  x58
0A19C:  MOVLW  04
0A19E:  ADDWFC 02,W
0A1A0:  MOVWF  x59
0A1A2:  MOVLW  01
0A1A4:  SUBWF  x33,W
0A1A6:  MULLW  21
0A1A8:  MOVF   FF3,W
0A1AA:  CLRF   x5B
0A1AC:  MOVWF  x5A
0A1AE:  MOVLW  0C
0A1B0:  ADDWF  x5A,W
0A1B2:  MOVWF  01
0A1B4:  MOVLW  00
0A1B6:  ADDWFC x5B,W
0A1B8:  MOVWF  03
0A1BA:  MOVF   01,W
0A1BC:  ADDLW  0F
0A1BE:  MOVWF  FE9
0A1C0:  MOVLW  01
0A1C2:  ADDWFC 03,W
0A1C4:  MOVWF  FEA
0A1C6:  MOVFF  FEF,678
0A1CA:  MOVFF  FEC,01
0A1CE:  MOVFF  FEC,02
0A1D2:  MOVFF  FEC,03
0A1D6:  MOVFF  03,67B
0A1DA:  MOVFF  02,67A
0A1DE:  MOVFF  01,679
0A1E2:  MOVLB  0
0A1E4:  CALL   5E7E
0A1E8:  MOVFF  03,65D
0A1EC:  MOVFF  02,65C
0A1F0:  MOVFF  01,65B
0A1F4:  MOVFF  00,65A
0A1F8:  MOVFF  659,51B
0A1FC:  MOVFF  658,51A
0A200:  MOVLW  41
0A202:  MOVWF  FE9
0A204:  MOVFF  03,664
0A208:  MOVFF  02,663
0A20C:  MOVFF  01,662
0A210:  MOVFF  00,661
0A214:  RCALL  9C56
0A216:  MOVLW  2C
0A218:  MOVLB  6
0A21A:  MOVWF  x78
0A21C:  MOVLB  0
0A21E:  CALL   6310
....................    }
0A222:  BRA    A490
....................    else if (0 == strcmp(s_p0, arg2)) {
0A224:  MOVFF  645,66A
0A228:  MOVFF  644,669
0A22C:  MOVFF  635,66C
0A230:  MOVFF  634,66B
0A234:  CALL   6298
0A238:  MOVF   01,F
0A23A:  BNZ   A2F6
....................       sprintf(retData+strlen(retData), "%d,", arg1);
0A23C:  MOVLW  04
0A23E:  MOVLB  6
0A240:  MOVWF  x6A
0A242:  MOVLW  76
0A244:  MOVWF  x69
0A246:  MOVLB  0
0A248:  CALL   6260
0A24C:  MOVFF  02,03
0A250:  MOVF   01,W
0A252:  ADDLW  76
0A254:  MOVLB  6
0A256:  MOVWF  x58
0A258:  MOVLW  04
0A25A:  ADDWFC 02,W
0A25C:  MOVWF  x59
0A25E:  MOVFF  FE8,51B
0A262:  MOVFF  658,51A
0A266:  MOVFF  633,65C
0A26A:  MOVLW  18
0A26C:  MOVWF  x5D
0A26E:  MOVLB  0
0A270:  CALL   681C
0A274:  MOVLW  2C
0A276:  MOVLB  6
0A278:  MOVWF  x78
0A27A:  MOVLB  0
0A27C:  CALL   6310
....................       sprintf(retData+strlen(retData), "%f,", adcVals[arg1-1].p0);
0A280:  MOVLW  04
0A282:  MOVLB  6
0A284:  MOVWF  x6A
0A286:  MOVLW  76
0A288:  MOVWF  x69
0A28A:  MOVLB  0
0A28C:  CALL   6260
0A290:  MOVF   01,W
0A292:  ADDLW  76
0A294:  MOVLB  6
0A296:  MOVWF  x58
0A298:  MOVLW  04
0A29A:  ADDWFC 02,W
0A29C:  MOVWF  x59
0A29E:  MOVLW  01
0A2A0:  SUBWF  x33,W
0A2A2:  MULLW  21
0A2A4:  MOVF   FF3,W
0A2A6:  CLRF   x5B
0A2A8:  MOVWF  x5A
0A2AA:  MOVLW  18
0A2AC:  ADDWF  x5A,W
0A2AE:  MOVWF  01
0A2B0:  MOVLW  00
0A2B2:  ADDWFC x5B,W
0A2B4:  MOVWF  03
0A2B6:  MOVF   01,W
0A2B8:  ADDLW  0F
0A2BA:  MOVWF  FE9
0A2BC:  MOVLW  01
0A2BE:  ADDWFC 03,W
0A2C0:  MOVWF  FEA
0A2C2:  MOVFF  FEF,66B
0A2C6:  MOVFF  FEC,66C
0A2CA:  MOVFF  FEC,66D
0A2CE:  MOVFF  FEC,66E
0A2D2:  MOVFF  659,51B
0A2D6:  MOVFF  658,51A
0A2DA:  MOVLW  89
0A2DC:  MOVWF  FE9
0A2DE:  MOVLW  02
0A2E0:  MOVWF  x6F
0A2E2:  MOVLB  0
0A2E4:  CALL   7038
0A2E8:  MOVLW  2C
0A2EA:  MOVLB  6
0A2EC:  MOVWF  x78
0A2EE:  MOVLB  0
0A2F0:  CALL   6310
....................    }
0A2F4:  BRA    A490
....................    else if (0 == strcmp(s_poles, arg2)) {
0A2F6:  MOVFF  64A,66A
0A2FA:  MOVFF  649,669
0A2FE:  MOVFF  635,66C
0A302:  MOVFF  634,66B
0A306:  CALL   6298
0A30A:  MOVF   01,F
0A30C:  BNZ   A3B8
....................       sprintf(retData+strlen(retData), "%d,", arg1);
0A30E:  MOVLW  04
0A310:  MOVLB  6
0A312:  MOVWF  x6A
0A314:  MOVLW  76
0A316:  MOVWF  x69
0A318:  MOVLB  0
0A31A:  CALL   6260
0A31E:  MOVFF  02,03
0A322:  MOVF   01,W
0A324:  ADDLW  76
0A326:  MOVLB  6
0A328:  MOVWF  x58
0A32A:  MOVLW  04
0A32C:  ADDWFC 02,W
0A32E:  MOVWF  x59
0A330:  MOVFF  FE8,51B
0A334:  MOVFF  658,51A
0A338:  MOVFF  633,65C
0A33C:  MOVLW  18
0A33E:  MOVWF  x5D
0A340:  MOVLB  0
0A342:  CALL   681C
0A346:  MOVLW  2C
0A348:  MOVLB  6
0A34A:  MOVWF  x78
0A34C:  MOVLB  0
0A34E:  CALL   6310
....................       sprintf(retData+strlen(retData), "%d,", adcVals[arg1-1].npoles);
0A352:  MOVLW  04
0A354:  MOVLB  6
0A356:  MOVWF  x6A
0A358:  MOVLW  76
0A35A:  MOVWF  x69
0A35C:  MOVLB  0
0A35E:  CALL   6260
0A362:  MOVF   01,W
0A364:  ADDLW  76
0A366:  MOVLB  6
0A368:  MOVWF  x58
0A36A:  MOVLW  04
0A36C:  ADDWFC 02,W
0A36E:  MOVWF  x59
0A370:  MOVLW  01
0A372:  SUBWF  x33,W
0A374:  MULLW  21
0A376:  MOVF   FF3,W
0A378:  CLRF   x5B
0A37A:  MOVWF  x5A
0A37C:  MOVLW  1C
0A37E:  ADDWF  x5A,W
0A380:  MOVWF  01
0A382:  MOVLW  00
0A384:  ADDWFC x5B,W
0A386:  MOVWF  03
0A388:  MOVF   01,W
0A38A:  ADDLW  0F
0A38C:  MOVWF  FE9
0A38E:  MOVLW  01
0A390:  ADDWFC 03,W
0A392:  MOVWF  FEA
0A394:  MOVFF  FEF,65C
0A398:  MOVFF  659,51B
0A39C:  MOVFF  658,51A
0A3A0:  MOVLW  18
0A3A2:  MOVWF  x5D
0A3A4:  MOVLB  0
0A3A6:  CALL   681C
0A3AA:  MOVLW  2C
0A3AC:  MOVLB  6
0A3AE:  MOVWF  x78
0A3B0:  MOVLB  0
0A3B2:  CALL   6310
....................    }
0A3B6:  BRA    A490
....................    else if (0 == strcmp(s_real, arg2)) {
0A3B8:  MOVFF  652,66A
0A3BC:  MOVFF  651,669
0A3C0:  MOVFF  635,66C
0A3C4:  MOVFF  634,66B
0A3C8:  CALL   6298
0A3CC:  MOVF   01,F
0A3CE:  BNZ   A48A
....................       sprintf(retData+strlen(retData), "%d,", arg1);
0A3D0:  MOVLW  04
0A3D2:  MOVLB  6
0A3D4:  MOVWF  x6A
0A3D6:  MOVLW  76
0A3D8:  MOVWF  x69
0A3DA:  MOVLB  0
0A3DC:  CALL   6260
0A3E0:  MOVFF  02,03
0A3E4:  MOVF   01,W
0A3E6:  ADDLW  76
0A3E8:  MOVLB  6
0A3EA:  MOVWF  x58
0A3EC:  MOVLW  04
0A3EE:  ADDWFC 02,W
0A3F0:  MOVWF  x59
0A3F2:  MOVFF  FE8,51B
0A3F6:  MOVFF  658,51A
0A3FA:  MOVFF  633,65C
0A3FE:  MOVLW  18
0A400:  MOVWF  x5D
0A402:  MOVLB  0
0A404:  CALL   681C
0A408:  MOVLW  2C
0A40A:  MOVLB  6
0A40C:  MOVWF  x78
0A40E:  MOVLB  0
0A410:  CALL   6310
....................       sprintf(retData+strlen(retData), "%f,", adcVals[arg1-1].pReal);
0A414:  MOVLW  04
0A416:  MOVLB  6
0A418:  MOVWF  x6A
0A41A:  MOVLW  76
0A41C:  MOVWF  x69
0A41E:  MOVLB  0
0A420:  CALL   6260
0A424:  MOVF   01,W
0A426:  ADDLW  76
0A428:  MOVLB  6
0A42A:  MOVWF  x58
0A42C:  MOVLW  04
0A42E:  ADDWFC 02,W
0A430:  MOVWF  x59
0A432:  MOVLW  01
0A434:  SUBWF  x33,W
0A436:  MULLW  21
0A438:  MOVF   FF3,W
0A43A:  CLRF   x5B
0A43C:  MOVWF  x5A
0A43E:  MOVLW  1D
0A440:  ADDWF  x5A,W
0A442:  MOVWF  01
0A444:  MOVLW  00
0A446:  ADDWFC x5B,W
0A448:  MOVWF  03
0A44A:  MOVF   01,W
0A44C:  ADDLW  0F
0A44E:  MOVWF  FE9
0A450:  MOVLW  01
0A452:  ADDWFC 03,W
0A454:  MOVWF  FEA
0A456:  MOVFF  FEF,66B
0A45A:  MOVFF  FEC,66C
0A45E:  MOVFF  FEC,66D
0A462:  MOVFF  FEC,66E
0A466:  MOVFF  659,51B
0A46A:  MOVFF  658,51A
0A46E:  MOVLW  89
0A470:  MOVWF  FE9
0A472:  MOVLW  02
0A474:  MOVWF  x6F
0A476:  MOVLB  0
0A478:  CALL   7038
0A47C:  MOVLW  2C
0A47E:  MOVLB  6
0A480:  MOVWF  x78
0A482:  MOVLB  0
0A484:  CALL   6310
....................    }
0A488:  BRA    A490
....................    else return INV_PARAM;
0A48A:  MOVLW  02
0A48C:  MOVWF  01
0A48E:  BRA    A494
....................    
....................    return SUCCESS;
0A490:  MOVLW  00
0A492:  MOVWF  01
0A494:  RETURN 0
.................... }
.................... 
.................... int8 getManOPvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0A496:  MOVLB  6
0A498:  CLRF   x6A
0A49A:  MOVFF  627,669
0A49E:  CLRF   x6C
0A4A0:  MOVLW  B5
0A4A2:  MOVWF  x6B
0A4A4:  MOVLB  0
0A4A6:  CALL   0FC4
0A4AA:  MOVFF  02,635
0A4AE:  MOVFF  01,634
0A4B2:  MOVLW  06
0A4B4:  MOVLB  6
0A4B6:  ADDWF  x34,F
0A4B8:  MOVLW  00
0A4BA:  ADDWFC x35,F
0A4BC:  MOVLW  32
0A4BE:  ADDWF  x34,W
0A4C0:  MOVWF  01
0A4C2:  MOVLW  00
0A4C4:  ADDWFC x35,W
0A4C6:  MOVWF  03
0A4C8:  MOVF   01,W
0A4CA:  ADDLW  A0
0A4CC:  MOVWF  01
0A4CE:  MOVLW  01
0A4D0:  ADDWFC 03,F
0A4D2:  MOVFF  01,634
0A4D6:  MOVFF  03,635
0A4DA:  MOVFF  03,65C
0A4DE:  MOVFF  01,65B
0A4E2:  MOVLB  0
0A4E4:  CALL   63D8
0A4E8:  MOVF   01,F
0A4EA:  BNZ   A4F4
0A4EC:  MOVLW  02
0A4EE:  MOVWF  01
0A4F0:  BRA    A5E6
0A4F2:  BRA    A552
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
0A4F4:  MOVLB  6
0A4F6:  CLRF   x6A
0A4F8:  MOVFF  627,669
0A4FC:  CLRF   x6C
0A4FE:  MOVLW  B5
0A500:  MOVWF  x6B
0A502:  MOVLB  0
0A504:  CALL   0FC4
0A508:  MOVFF  02,635
0A50C:  MOVFF  01,634
0A510:  MOVLW  06
0A512:  MOVLB  6
0A514:  ADDWF  x34,F
0A516:  MOVLW  00
0A518:  ADDWFC x35,F
0A51A:  MOVLW  32
0A51C:  ADDWF  x34,W
0A51E:  MOVWF  01
0A520:  MOVLW  00
0A522:  ADDWFC x35,W
0A524:  MOVWF  03
0A526:  MOVF   01,W
0A528:  ADDLW  A0
0A52A:  MOVWF  01
0A52C:  MOVLW  01
0A52E:  ADDWFC 03,F
0A530:  MOVFF  01,634
0A534:  MOVFF  03,635
0A538:  MOVFF  03,65C
0A53C:  MOVFF  01,65B
0A540:  CLRF   x5E
0A542:  CLRF   x5D
0A544:  MOVLW  0A
0A546:  MOVWF  x5F
0A548:  MOVLB  0
0A54A:  CALL   64C8
0A54E:  MOVFF  01,633
....................    
....................    /*** GET MANUAL OUTPUT VALUE ***************/ 
....................    sprintf(retData+strlen(retData), "%d,%f,", arg1, manualOutputValues[arg1-1]);
0A552:  MOVLW  04
0A554:  MOVLB  6
0A556:  MOVWF  x6A
0A558:  MOVLW  76
0A55A:  MOVWF  x69
0A55C:  MOVLB  0
0A55E:  CALL   6260
0A562:  MOVF   01,W
0A564:  ADDLW  76
0A566:  MOVLB  6
0A568:  MOVWF  x34
0A56A:  MOVLW  04
0A56C:  ADDWFC 02,W
0A56E:  MOVWF  x35
0A570:  MOVLW  01
0A572:  SUBWF  x33,W
0A574:  MULLW  04
0A576:  MOVF   FF3,W
0A578:  CLRF   03
0A57A:  ADDLW  EA
0A57C:  MOVWF  FE9
0A57E:  MOVLW  00
0A580:  ADDWFC 03,W
0A582:  MOVWF  FEA
0A584:  MOVFF  FEF,636
0A588:  MOVFF  FEC,637
0A58C:  MOVFF  FEC,638
0A590:  MOVFF  FEC,639
0A594:  MOVFF  635,51B
0A598:  MOVFF  634,51A
0A59C:  MOVFF  633,65C
0A5A0:  MOVLW  18
0A5A2:  MOVWF  x5D
0A5A4:  MOVLB  0
0A5A6:  CALL   681C
0A5AA:  MOVLW  2C
0A5AC:  MOVLB  6
0A5AE:  MOVWF  x78
0A5B0:  MOVLB  0
0A5B2:  CALL   6310
0A5B6:  MOVLW  89
0A5B8:  MOVWF  FE9
0A5BA:  MOVFF  639,66E
0A5BE:  MOVFF  638,66D
0A5C2:  MOVFF  637,66C
0A5C6:  MOVFF  636,66B
0A5CA:  MOVLW  02
0A5CC:  MOVLB  6
0A5CE:  MOVWF  x6F
0A5D0:  MOVLB  0
0A5D2:  CALL   7038
0A5D6:  MOVLW  2C
0A5D8:  MOVLB  6
0A5DA:  MOVWF  x78
0A5DC:  MOVLB  0
0A5DE:  CALL   6310
....................    
....................    return SUCCESS;
0A5E2:  MOVLW  00
0A5E4:  MOVWF  01
0A5E6:  RETURN 0
.................... }
.................... 
.................... int8 setManOPvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    float arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0A5E8:  MOVLB  6
0A5EA:  CLRF   x6A
0A5EC:  MOVFF  627,669
0A5F0:  CLRF   x6C
0A5F2:  MOVLW  B5
0A5F4:  MOVWF  x6B
0A5F6:  MOVLB  0
0A5F8:  CALL   0FC4
0A5FC:  MOVFF  02,639
0A600:  MOVFF  01,638
0A604:  MOVLW  06
0A606:  MOVLB  6
0A608:  ADDWF  x38,F
0A60A:  MOVLW  00
0A60C:  ADDWFC x39,F
0A60E:  MOVLW  32
0A610:  ADDWF  x38,W
0A612:  MOVWF  01
0A614:  MOVLW  00
0A616:  ADDWFC x39,W
0A618:  MOVWF  03
0A61A:  MOVF   01,W
0A61C:  ADDLW  A0
0A61E:  MOVWF  01
0A620:  MOVLW  01
0A622:  ADDWFC 03,F
0A624:  MOVFF  01,638
0A628:  MOVFF  03,639
0A62C:  MOVFF  03,65C
0A630:  MOVFF  01,65B
0A634:  MOVLB  0
0A636:  CALL   63D8
0A63A:  MOVF   01,F
0A63C:  BNZ   A646
0A63E:  MOVLW  02
0A640:  MOVWF  01
0A642:  BRA    A828
0A644:  BRA    A6A4
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
0A646:  MOVLB  6
0A648:  CLRF   x6A
0A64A:  MOVFF  627,669
0A64E:  CLRF   x6C
0A650:  MOVLW  B5
0A652:  MOVWF  x6B
0A654:  MOVLB  0
0A656:  CALL   0FC4
0A65A:  MOVFF  02,639
0A65E:  MOVFF  01,638
0A662:  MOVLW  06
0A664:  MOVLB  6
0A666:  ADDWF  x38,F
0A668:  MOVLW  00
0A66A:  ADDWFC x39,F
0A66C:  MOVLW  32
0A66E:  ADDWF  x38,W
0A670:  MOVWF  01
0A672:  MOVLW  00
0A674:  ADDWFC x39,W
0A676:  MOVWF  03
0A678:  MOVF   01,W
0A67A:  ADDLW  A0
0A67C:  MOVWF  01
0A67E:  MOVLW  01
0A680:  ADDWFC 03,F
0A682:  MOVFF  01,638
0A686:  MOVFF  03,639
0A68A:  MOVFF  03,65C
0A68E:  MOVFF  01,65B
0A692:  CLRF   x5E
0A694:  CLRF   x5D
0A696:  MOVLW  0A
0A698:  MOVWF  x5F
0A69A:  MOVLB  0
0A69C:  CALL   64C8
0A6A0:  MOVFF  01,633
....................    
....................    if (!arg_is_float(SERcmd[rec].p[3])) return INV_PARAM;
0A6A4:  MOVLB  6
0A6A6:  CLRF   x6A
0A6A8:  MOVFF  627,669
0A6AC:  CLRF   x6C
0A6AE:  MOVLW  B5
0A6B0:  MOVWF  x6B
0A6B2:  MOVLB  0
0A6B4:  CALL   0FC4
0A6B8:  MOVFF  02,639
0A6BC:  MOVFF  01,638
0A6C0:  MOVLW  06
0A6C2:  MOVLB  6
0A6C4:  ADDWF  x38,F
0A6C6:  MOVLW  00
0A6C8:  ADDWFC x39,F
0A6CA:  MOVLW  4B
0A6CC:  ADDWF  x38,W
0A6CE:  MOVWF  01
0A6D0:  MOVLW  00
0A6D2:  ADDWFC x39,W
0A6D4:  MOVWF  03
0A6D6:  MOVF   01,W
0A6D8:  ADDLW  A0
0A6DA:  MOVWF  01
0A6DC:  MOVLW  01
0A6DE:  ADDWFC 03,F
0A6E0:  MOVFF  01,638
0A6E4:  MOVFF  03,639
0A6E8:  MOVFF  03,63D
0A6EC:  MOVFF  01,63C
0A6F0:  MOVLB  0
0A6F2:  CALL   76A4
0A6F6:  MOVF   01,F
0A6F8:  BNZ   A702
0A6FA:  MOVLW  02
0A6FC:  MOVWF  01
0A6FE:  BRA    A828
0A700:  BRA    A768
....................    else arg2 = strtod(SERcmd[rec].p[3], '\0');
0A702:  MOVLB  6
0A704:  CLRF   x6A
0A706:  MOVFF  627,669
0A70A:  CLRF   x6C
0A70C:  MOVLW  B5
0A70E:  MOVWF  x6B
0A710:  MOVLB  0
0A712:  CALL   0FC4
0A716:  MOVFF  02,639
0A71A:  MOVFF  01,638
0A71E:  MOVLW  06
0A720:  MOVLB  6
0A722:  ADDWF  x38,F
0A724:  MOVLW  00
0A726:  ADDWFC x39,F
0A728:  MOVLW  4B
0A72A:  ADDWF  x38,W
0A72C:  MOVWF  01
0A72E:  MOVLW  00
0A730:  ADDWFC x39,W
0A732:  MOVWF  03
0A734:  MOVF   01,W
0A736:  ADDLW  A0
0A738:  MOVWF  01
0A73A:  MOVLW  01
0A73C:  ADDWFC 03,F
0A73E:  MOVFF  01,638
0A742:  MOVFF  03,639
0A746:  MOVFF  03,63D
0A74A:  MOVFF  01,63C
0A74E:  CLRF   x3F
0A750:  CLRF   x3E
0A752:  MOVLB  0
0A754:  CALL   7766
0A758:  MOVFF  03,637
0A75C:  MOVFF  02,636
0A760:  MOVFF  01,635
0A764:  MOVFF  00,634
....................    
....................    /*** SET MANUAL OUTPUT VALUE ***************/
....................    if (arg2 > op_upper_bound) manualOutputValues[arg1-1] = op_upper_bound;
0A768:  MOVLB  6
0A76A:  CLRF   x76
0A76C:  CLRF   x75
0A76E:  MOVLW  7C
0A770:  MOVWF  x74
0A772:  MOVLW  84
0A774:  MOVWF  x73
0A776:  MOVFF  637,67A
0A77A:  MOVFF  636,679
0A77E:  MOVFF  635,678
0A782:  MOVFF  634,677
0A786:  MOVLB  0
0A788:  CALL   25F0
0A78C:  BNC   A7B2
0A78E:  MOVLW  01
0A790:  MOVLB  6
0A792:  SUBWF  x33,W
0A794:  MULLW  04
0A796:  MOVF   FF3,W
0A798:  CLRF   03
0A79A:  ADDLW  EA
0A79C:  MOVWF  FE9
0A79E:  MOVLW  00
0A7A0:  ADDWFC 03,W
0A7A2:  MOVWF  FEA
0A7A4:  MOVLW  84
0A7A6:  MOVWF  FEF
0A7A8:  MOVLW  7C
0A7AA:  MOVWF  FEC
0A7AC:  CLRF   FEC
0A7AE:  CLRF   FEC
0A7B0:  BRA    A822
....................    else if (arg2 < op_lower_bound) manualOutputValues[arg1-1] = op_lower_bound;  
0A7B2:  MOVFF  637,676
0A7B6:  MOVFF  636,675
0A7BA:  MOVFF  635,674
0A7BE:  MOVFF  634,673
0A7C2:  MOVLB  6
0A7C4:  CLRF   x7A
0A7C6:  CLRF   x79
0A7C8:  MOVLW  FC
0A7CA:  MOVWF  x78
0A7CC:  MOVLW  84
0A7CE:  MOVWF  x77
0A7D0:  MOVLB  0
0A7D2:  CALL   25F0
0A7D6:  BNC   A7FC
0A7D8:  MOVLW  01
0A7DA:  MOVLB  6
0A7DC:  SUBWF  x33,W
0A7DE:  MULLW  04
0A7E0:  MOVF   FF3,W
0A7E2:  CLRF   03
0A7E4:  ADDLW  EA
0A7E6:  MOVWF  FE9
0A7E8:  MOVLW  00
0A7EA:  ADDWFC 03,W
0A7EC:  MOVWF  FEA
0A7EE:  MOVLW  84
0A7F0:  MOVWF  FEF
0A7F2:  MOVLW  FC
0A7F4:  MOVWF  FEC
0A7F6:  CLRF   FEC
0A7F8:  CLRF   FEC
0A7FA:  BRA    A822
....................    else manualOutputValues[arg1-1] = arg2;
0A7FC:  MOVLW  01
0A7FE:  MOVLB  6
0A800:  SUBWF  x33,W
0A802:  MULLW  04
0A804:  MOVF   FF3,W
0A806:  CLRF   03
0A808:  ADDLW  EA
0A80A:  MOVWF  FE9
0A80C:  MOVLW  00
0A80E:  ADDWFC 03,W
0A810:  MOVWF  FEA
0A812:  MOVFF  634,FEF
0A816:  MOVFF  635,FEC
0A81A:  MOVFF  636,FEC
0A81E:  MOVFF  637,FEC
....................    
....................    return SUCCESS;
0A822:  MOVLW  00
0A824:  MOVWF  01
0A826:  MOVLB  0
0A828:  RETURN 0
.................... }
.................... 
.................... int8 invalidCmd(unsigned int8 rec){
....................    return INV_CMD;
0A82A:  MOVLW  01
0A82C:  MOVWF  01
0A82E:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* ARG VALIDATION HELPER FUNCS                                               */
.................... /*****************************************************************************/
.................... BOOLEAN arg_is_float(char *arg){
*
076A4:  MOVLB  6
076A6:  BCF    x3E.0
....................    BOOLEAN decimal = FALSE;
....................    for (int i=0; i<strlen(arg); i++){
076A8:  CLRF   x3F
076AA:  MOVFF  63D,66A
076AE:  MOVFF  63C,669
076B2:  MOVLB  0
076B4:  CALL   6260
076B8:  MOVFF  02,03
076BC:  MOVF   01,W
076BE:  MOVF   03,F
076C0:  BNZ   76CC
076C2:  MOVF   01,W
076C4:  MOVLB  6
076C6:  SUBWF  x3F,W
076C8:  BC    775E
076CA:  MOVLB  0
....................       if (!isdigit(arg[i])){
076CC:  MOVLB  6
076CE:  MOVF   x3F,W
076D0:  ADDWF  x3C,W
076D2:  MOVWF  FE9
076D4:  MOVLW  00
076D6:  ADDWFC x3D,W
076D8:  MOVWF  FEA
076DA:  MOVFF  FEF,640
076DE:  MOVF   x40,W
076E0:  SUBLW  2F
076E2:  BC    76EA
076E4:  MOVF   x40,W
076E6:  SUBLW  39
076E8:  BC    7756
....................          // Check for negative sign
....................          if ('-' != arg[i]){
076EA:  MOVF   x3F,W
076EC:  ADDWF  x3C,W
076EE:  MOVWF  FE9
076F0:  MOVLW  00
076F2:  ADDWFC x3D,W
076F4:  MOVWF  FEA
076F6:  MOVF   FEF,W
076F8:  SUBLW  2D
076FA:  BZ    7726
....................             // Check for decimal
....................             if ('.' != arg[i]) return FALSE;
076FC:  MOVF   x3F,W
076FE:  ADDWF  x3C,W
07700:  MOVWF  FE9
07702:  MOVLW  00
07704:  ADDWFC x3D,W
07706:  MOVWF  FEA
07708:  MOVF   FEF,W
0770A:  SUBLW  2E
0770C:  BZ    7716
0770E:  MOVLW  00
07710:  MOVWF  01
07712:  BRA    7762
07714:  BRA    7724
....................             else if  (decimal) return FALSE;
07716:  BTFSS  x3E.0
07718:  BRA    7722
0771A:  MOVLW  00
0771C:  MOVWF  01
0771E:  BRA    7762
07720:  BRA    7724
....................             else decimal = TRUE;
07722:  BSF    x3E.0
....................          }
07724:  BRA    7756
....................          else if (0 != i) return FALSE;
07726:  MOVF   x3F,F
07728:  BZ    7732
0772A:  MOVLW  00
0772C:  MOVWF  01
0772E:  BRA    7762
07730:  BRA    7756
....................          else if (1 == strlen(arg)) return FALSE;
07732:  MOVFF  63D,66A
07736:  MOVFF  63C,669
0773A:  MOVLB  0
0773C:  CALL   6260
07740:  MOVFF  02,03
07744:  MOVF   01,W
07746:  SUBLW  01
07748:  BNZ   7758
0774A:  MOVF   03,F
0774C:  BNZ   7758
0774E:  MOVLW  00
07750:  MOVWF  01
07752:  MOVLB  6
07754:  BRA    7762
07756:  MOVLB  0
....................       }
07758:  MOVLB  6
0775A:  INCF   x3F,F
0775C:  BRA    76AA
....................    }
....................    return TRUE;
0775E:  MOVLW  01
07760:  MOVWF  01
07762:  MOVLB  0
07764:  RETURN 0
.................... }
.................... 
.................... BOOLEAN is_valid_channel(char *arg){
....................     if (1 != strlen(arg)) return FALSE;
*
063D8:  MOVFF  65C,66A
063DC:  MOVFF  65B,669
063E0:  RCALL  6260
063E2:  MOVFF  02,03
063E6:  MOVF   01,W
063E8:  SUBLW  01
063EA:  BNZ   63F0
063EC:  MOVF   03,F
063EE:  BZ    63F8
063F0:  MOVLW  00
063F2:  MOVWF  01
063F4:  BRA    6426
063F6:  BRA    641E
....................     else if ('1' != arg[0] && '2' != arg[0]) return FALSE;
063F8:  MOVLB  6
063FA:  MOVFF  65B,FE9
063FE:  MOVFF  65C,FEA
06402:  MOVF   FEF,W
06404:  SUBLW  31
06406:  BZ    6420
06408:  MOVFF  65B,FE9
0640C:  MOVFF  65C,FEA
06410:  MOVF   FEF,W
06412:  SUBLW  32
06414:  BZ    6420
06416:  MOVLW  00
06418:  MOVWF  01
0641A:  MOVLB  0
0641C:  BRA    6426
0641E:  MOVLB  6
....................     return TRUE;
06420:  MOVLW  01
06422:  MOVWF  01
06424:  MOVLB  0
06426:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* ASCII HEX CHARACTER TO INT                                                */
.................... /*****************************************************************************/
.................... int8 hex_to_int(char ascii){
....................    if (ascii >= '0' && ascii <= '9') return ascii-'0';
*
06226:  MOVLB  6
06228:  MOVF   x32,W
0622A:  SUBLW  2F
0622C:  BC    623E
0622E:  MOVF   x32,W
06230:  SUBLW  39
06232:  BNC   623E
06234:  MOVLW  30
06236:  SUBWF  x32,W
06238:  MOVWF  01
0623A:  BRA    625A
0623C:  BRA    625A
....................    else if (ascii >= 'A' && ascii <= 'F') return ascii-'A'+10;
0623E:  MOVF   x32,W
06240:  SUBLW  40
06242:  BC    6256
06244:  MOVF   x32,W
06246:  SUBLW  46
06248:  BNC   6256
0624A:  MOVLW  41
0624C:  SUBWF  x32,W
0624E:  ADDLW  0A
06250:  MOVWF  01
06252:  BRA    625A
06254:  BRA    625A
....................    else return 0xFF;
06256:  MOVLW  FF
06258:  MOVWF  01
0625A:  MOVLB  0
0625C:  GOTO   A8D4 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* COMMAND HANDLER/PARSER FUNCS                                              */
.................... /*****************************************************************************/
.................... void echo_cmd(unsigned int8 rec){
....................    fprintf(SERIAL, "%c", SERcmd[rec].t);
....................    while (SERcmd[rec].recReadIndex <= SERcmd[rec].recWriteIndex)
....................    {
....................       if (SERcmd[rec].recReadIndex != 0) fprintf(SERIAL, "%c", delimiter);
....................       fprintf(SERIAL, "%s", SERcmd[rec].p[SERcmd[rec].recReadIndex]);
....................       SERcmd[rec].recReadIndex++;
....................    }
....................    SERcmd[rec].recReadIndex=0;
.................... }
.................... 
.................... int8 command_parser(unsigned int8 rec){
*
0A830:  MOVLB  6
0A832:  CLRF   x6A
0A834:  MOVFF  629,669
0A838:  CLRF   x6C
0A83A:  MOVLW  B5
0A83C:  MOVWF  x6B
0A83E:  MOVLB  0
0A840:  CALL   0FC4
0A844:  MOVFF  02,632
0A848:  MOVFF  01,631
0A84C:  MOVLW  06
0A84E:  MOVLB  6
0A850:  ADDWF  x31,F
0A852:  MOVLW  00
0A854:  ADDWFC x32,F
0A856:  MOVLW  A0
0A858:  ADDWF  x31,W
0A85A:  MOVWF  01
0A85C:  MOVLW  01
0A85E:  ADDWFC x32,W
0A860:  MOVWF  03
0A862:  MOVFF  01,62A
0A866:  MOVWF  x2B
0A868:  CLRF   x6A
0A86A:  MOVFF  629,669
0A86E:  CLRF   x6C
0A870:  MOVLW  B5
0A872:  MOVWF  x6B
0A874:  MOVLB  0
0A876:  CALL   0FC4
0A87A:  MOVFF  02,634
0A87E:  MOVFF  01,633
0A882:  MOVLW  06
0A884:  MOVLB  6
0A886:  ADDWF  x33,F
0A888:  MOVLW  00
0A88A:  ADDWFC x34,F
0A88C:  MOVLW  19
0A88E:  ADDWF  x33,W
0A890:  MOVWF  01
0A892:  MOVLW  00
0A894:  ADDWFC x34,W
0A896:  MOVWF  03
0A898:  MOVF   01,W
0A89A:  ADDLW  A0
0A89C:  MOVWF  01
0A89E:  MOVLW  01
0A8A0:  ADDWFC 03,F
0A8A2:  MOVFF  01,62C
0A8A6:  MOVFF  03,62D
0A8AA:  CLRF   x2E
0A8AC:  CLRF   x2F
....................    char *cmd_adr = SERcmd[rec].p[0];
....................    char *cmd_str = SERcmd[rec].p[1];
.................... //!   int8 devID = input_a();
....................    int8 devID = 0;
....................    int8 i = 0;
....................    
....................    if (hwID == cmd_adr[0]){
0A8AE:  MOVFF  62A,FE9
0A8B2:  MOVFF  62B,FEA
0A8B6:  MOVF   FEF,W
0A8B8:  SUBLW  44
0A8BA:  BTFSS  FD8.2
0A8BC:  BRA    A9AC
....................       if (hex_to_int(cmd_adr[1]) == (devID & 0x0F)){
0A8BE:  MOVLW  01
0A8C0:  ADDWF  x2A,W
0A8C2:  MOVWF  FE9
0A8C4:  MOVLW  00
0A8C6:  ADDWFC x2B,W
0A8C8:  MOVWF  FEA
0A8CA:  MOVFF  FEF,632
0A8CE:  MOVLB  0
0A8D0:  GOTO   6226
0A8D4:  MOVFF  01,631
0A8D8:  MOVLB  6
0A8DA:  MOVF   x2E,W
0A8DC:  ANDLW  0F
0A8DE:  SUBWF  01,W
0A8E0:  BNZ   A9A4
....................          while (0 != strlen(cmd_list[i].cmd_name)){
0A8E2:  MOVF   x2F,W
0A8E4:  MULLW  04
0A8E6:  MOVF   FF3,W
0A8E8:  CLRF   x32
0A8EA:  MOVWF  x31
0A8EC:  MOVLW  20
0A8EE:  ADDWF  x31,W
0A8F0:  MOVWF  FE9
0A8F2:  MOVLW  05
0A8F4:  ADDWFC x32,W
0A8F6:  MOVWF  FEA
0A8F8:  MOVFF  FEC,66A
0A8FC:  MOVF   FED,F
0A8FE:  MOVFF  FEF,669
0A902:  MOVLB  0
0A904:  CALL   6260
0A908:  MOVFF  02,03
0A90C:  MOVF   01,W
0A90E:  BNZ   A914
0A910:  MOVF   03,F
0A912:  BZ    A99A
....................             if (0 == strcmp(cmd_str, cmd_list[i].cmd_name))
0A914:  MOVLB  6
0A916:  MOVF   x2F,W
0A918:  MULLW  04
0A91A:  MOVF   FF3,W
0A91C:  CLRF   x32
0A91E:  MOVWF  x31
0A920:  MOVLW  20
0A922:  ADDWF  x31,W
0A924:  MOVWF  FE9
0A926:  MOVLW  05
0A928:  ADDWFC x32,W
0A92A:  MOVWF  FEA
0A92C:  MOVFF  FEC,66C
0A930:  MOVF   FED,F
0A932:  MOVFF  FEF,66B
0A936:  MOVFF  62D,66A
0A93A:  MOVFF  62C,669
0A93E:  MOVLB  0
0A940:  CALL   6298
0A944:  MOVF   01,F
0A946:  BNZ   A992
....................             {
....................                int8 return_code = cmd_list[i].cmd_func(rec);
0A948:  MOVLB  6
0A94A:  MOVF   x2F,W
0A94C:  MULLW  04
0A94E:  MOVF   FF3,W
0A950:  CLRF   x32
0A952:  MOVWF  x31
0A954:  MOVLW  02
0A956:  ADDWF  x31,W
0A958:  MOVWF  01
0A95A:  MOVLW  00
0A95C:  ADDWFC x32,W
0A95E:  MOVWF  03
0A960:  MOVF   01,W
0A962:  ADDLW  20
0A964:  MOVWF  01
0A966:  MOVLW  05
0A968:  ADDWFC 03,F
0A96A:  MOVFF  01,631
0A96E:  MOVFF  03,632
0A972:  MOVFF  03,FEA
0A976:  MOVFF  01,FE9
0A97A:  MOVFF  629,627
0A97E:  MOVLB  0
0A980:  CALL   00BC
0A984:  MOVFF  01,630
....................                return return_code;
0A988:  MOVLB  6
0A98A:  MOVFF  630,01
0A98E:  BRA    A9B0
0A990:  MOVLB  0
....................             }
....................             i++;
0A992:  MOVLB  6
0A994:  INCF   x2F,F
0A996:  BRA    A8E2
0A998:  MOVLB  0
....................          }
....................          return INV_CMD; // INVALID_CMD
0A99A:  MOVLW  01
0A99C:  MOVWF  01
0A99E:  MOVLB  6
0A9A0:  BRA    A9B0
....................       } else return 254; // NOT THIS ADDRESS
0A9A2:  BRA    A9AA
0A9A4:  MOVLW  FE
0A9A6:  MOVWF  01
0A9A8:  BRA    A9B0
....................    } else return 255; // NOT THIS DEVICE TYPE
0A9AA:  BRA    A9B0
0A9AC:  MOVLW  FF
0A9AE:  MOVWF  01
0A9B0:  MOVLB  0
0A9B2:  GOTO   A9EC (RETURN)
.................... }
.................... 
.................... void command_handler_task(){
....................    while (getNextSERReadIndex())
*
0A9DE:  GOTO   61CC
0A9E2:  MOVF   01,F
0A9E4:  BZ    AAD4
....................    {
....................       int8 return_code = command_parser(SRI);
0A9E6:  MOVFF  474,629
0A9EA:  BRA    A830
0A9EC:  MOVFF  01,628
....................       //echo_cmd(SRI);
....................       sprintf(retData + strlen(retData), "%s", resp_list[return_code].msg);
0A9F0:  MOVLW  04
0A9F2:  MOVLB  6
0A9F4:  MOVWF  x6A
0A9F6:  MOVLW  76
0A9F8:  MOVWF  x69
0A9FA:  MOVLB  0
0A9FC:  CALL   6260
0AA00:  MOVF   01,W
0AA02:  ADDLW  76
0AA04:  MOVLB  6
0AA06:  MOVWF  x29
0AA08:  MOVLW  04
0AA0A:  ADDWFC 02,W
0AA0C:  MOVWF  x2A
0AA0E:  MOVF   x28,W
0AA10:  MULLW  03
0AA12:  MOVF   FF3,W
0AA14:  CLRF   x2C
0AA16:  MOVWF  x2B
0AA18:  MOVLW  01
0AA1A:  ADDWF  x2B,W
0AA1C:  MOVWF  01
0AA1E:  MOVLW  00
0AA20:  ADDWFC x2C,W
0AA22:  MOVWF  03
0AA24:  MOVF   01,W
0AA26:  ADDLW  EF
0AA28:  MOVWF  FE9
0AA2A:  MOVLW  05
0AA2C:  ADDWFC 03,W
0AA2E:  MOVWF  FEA
0AA30:  MOVFF  FEC,62C
0AA34:  MOVF   FED,F
0AA36:  MOVFF  FEF,62B
0AA3A:  MOVFF  62A,51B
0AA3E:  MOVFF  629,51A
0AA42:  MOVFF  51B,FEA
0AA46:  MOVFF  51A,FE9
0AA4A:  CLRF   FEF
0AA4C:  MOVFF  62C,FEA
0AA50:  MOVFF  62B,FE9
0AA54:  MOVLB  0
0AA56:  BRA    A9B6
....................       fprintf(SERIAL, "$%s,%s\n", SERcmd[SRI].p[0], retData);
0AA58:  MOVLB  6
0AA5A:  CLRF   x6A
0AA5C:  MOVFF  474,669
0AA60:  CLRF   x6C
0AA62:  MOVLW  B5
0AA64:  MOVWF  x6B
0AA66:  MOVLB  0
0AA68:  CALL   0FC4
0AA6C:  MOVFF  02,62A
0AA70:  MOVFF  01,629
0AA74:  MOVLW  06
0AA76:  MOVLB  6
0AA78:  ADDWF  x29,F
0AA7A:  MOVLW  00
0AA7C:  ADDWFC x2A,F
0AA7E:  MOVLW  A0
0AA80:  ADDWF  x29,W
0AA82:  MOVWF  01
0AA84:  MOVLW  01
0AA86:  ADDWFC x2A,W
0AA88:  MOVWF  03
0AA8A:  MOVFF  01,62B
0AA8E:  MOVWF  x2C
0AA90:  MOVLW  24
0AA92:  MOVWF  x3E
0AA94:  MOVLB  0
0AA96:  CALL   586A
0AA9A:  MOVFF  62C,FEA
0AA9E:  MOVFF  62B,FE9
0AAA2:  CALL   5892
0AAA6:  MOVLW  2C
0AAA8:  MOVLB  6
0AAAA:  MOVWF  x3E
0AAAC:  MOVLB  0
0AAAE:  CALL   586A
0AAB2:  MOVLW  04
0AAB4:  MOVWF  FEA
0AAB6:  MOVLW  76
0AAB8:  MOVWF  FE9
0AABA:  CALL   5892
0AABE:  MOVLW  0A
0AAC0:  MOVLB  6
0AAC2:  MOVWF  x3E
0AAC4:  MOVLB  0
0AAC6:  CALL   586A
....................       
....................       resetSERcmd(SRI);
0AACA:  MOVFF  474,629
0AACE:  CALL   0FE6
0AAD2:  BRA    A9DE
....................    }
0AAD4:  GOTO   B154 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... #define DEBUG_1
.................... 
.................... void main()
0AAD8:  CLRF   FF8
0AADA:  BCF    FF2.5
0AADC:  BSF    07.7
0AADE:  MOVLB  E
0AAE0:  MOVLW  55
0AAE2:  MOVWF  x9B
0AAE4:  MOVLW  AA
0AAE6:  MOVWF  x9B
0AAE8:  BCF    x9B.0
0AAEA:  MOVLW  17
0AAEC:  MOVWF  xB0
0AAEE:  MOVLW  13
0AAF0:  MOVWF  xB2
0AAF2:  MOVLW  09
0AAF4:  MOVWF  x8A
0AAF6:  MOVLW  0A
0AAF8:  MOVWF  x8B
0AAFA:  MOVLW  11
0AAFC:  MOVWF  xEB
0AAFE:  MOVLW  12
0AB00:  MOVWF  xED
0AB02:  MOVLW  10
0AB04:  MOVWF  xF4
0AB06:  MOVLW  0F
0AB08:  MOVWF  xF5
0AB0A:  MOVLW  09
0AB0C:  MOVWF  xF8
0AB0E:  MOVLW  55
0AB10:  MOVWF  x9B
0AB12:  MOVLW  AA
0AB14:  MOVWF  x9B
0AB16:  BSF    x9B.0
0AB18:  CLRF   xD8
0AB1A:  CLRF   xD5
0AB1C:  CLRF   xD7
0AB1E:  MOVLW  08
0AB20:  MOVWF  xD9
0AB22:  MOVLW  60
0AB24:  MOVWF  xD3
0AB26:  MOVLW  AA
0AB28:  MOVLB  0
0AB2A:  MOVWF  xF2
0AB2C:  MOVLB  1
0AB2E:  CLRF   x5A
0AB30:  CLRF   x59
0AB32:  CLRF   x58
0AB34:  CLRF   x57
0AB36:  CLRF   x5E
0AB38:  CLRF   x5D
0AB3A:  CLRF   x5C
0AB3C:  CLRF   x5B
0AB3E:  CLRF   x62
0AB40:  CLRF   x61
0AB42:  CLRF   x60
0AB44:  CLRF   x5F
0AB46:  CLRF   x64
0AB48:  CLRF   x63
0AB4A:  MOVLB  E
0AB4C:  BCF    x91.5
0AB4E:  MOVLW  00
0AB50:  MOVWF  x90
0AB52:  MOVLW  0F
0AB54:  MOVWF  x8E
0AB56:  MOVLW  2A
0AB58:  MOVWF  x91
0AB5A:  MOVLW  C4
0AB5C:  MOVWF  F88
0AB5E:  MOVWF  F88
0AB60:  MOVWF  F88
0AB62:  BCF    F95.5
0AB64:  MOVLW  40
0AB66:  MOVWF  F94
0AB68:  MOVLW  9F
0AB6A:  MOVWF  F92
0AB6C:  MOVLW  3A
0AB6E:  MOVWF  F95
0AB70:  MOVLW  93
0AB72:  MOVWF  F89
0AB74:  MOVWF  F89
0AB76:  MOVLB  4
0AB78:  CLRF   x74
0AB7A:  CLRF   x75
0AB7C:  MOVLB  5
0AB7E:  CLRF   x16
0AB80:  CLRF   x17
0AB82:  BCF    x18.0
0AB84:  CLRF   x19
0AB86:  BSF    F9E.3
0AB88:  MOVLW  7C
0AB8A:  MOVWF  F9A
0AB8C:  MOVLW  00
0AB8E:  MOVWF  F9B
0AB90:  MOVLW  A6
0AB92:  MOVWF  F9D
0AB94:  MOVLW  90
0AB96:  MOVWF  F9C
0AB98:  MOVLW  93
0AB9A:  MOVWF  F89
0AB9C:  BCF    F84.5
0AB9E:  CLRF   x1B
0ABA0:  CLRF   x1A
0ABA2:  CLRF   x1F
0ABA4:  CLRF   x1E
0ABA6:  CLRF   x1D
0ABA8:  CLRF   x1C
0ABAA:  MOVLB  F
0ABAC:  CLRF   x0C
0ABAE:  CLRF   x14
0ABB0:  CLRF   x1C
0ABB2:  CLRF   x21
0ABB4:  CLRF   x29
0ABB6:  CLRF   x35
0ABB8:  CLRF   x36
0ABBA:  CLRF   x37
0ABBC:  CLRF   x34
0ABBE:  CLRF   x31
0ABC0:  CLRF   x32
0ABC2:  CLRF   x33
0ABC4:  CLRF   x30
0ABC6:  MOVLW  63
0ABC8:  MOVLB  5
0ABCA:  MOVWF  x23
0ABCC:  MOVLW  50
0ABCE:  MOVWF  x22
0ABD0:  MOVLW  63
0ABD2:  MOVWF  x27
0ABD4:  MOVLW  94
0ABD6:  MOVWF  x26
0ABD8:  MOVLW  68
0ABDA:  MOVWF  x2B
0ABDC:  MOVLW  DC
0ABDE:  MOVWF  x2A
0ABE0:  MOVLW  6A
0ABE2:  MOVWF  x2F
0ABE4:  MOVLW  BA
0ABE6:  MOVWF  x2E
0ABE8:  MOVLW  6C
0ABEA:  MOVWF  x33
0ABEC:  MOVLW  92
0ABEE:  MOVWF  x32
0ABF0:  MOVLW  6E
0ABF2:  MOVWF  x37
0ABF4:  MOVLW  1E
0ABF6:  MOVWF  x36
0ABF8:  MOVLW  71
0ABFA:  MOVWF  x3B
0ABFC:  MOVLW  EE
0ABFE:  MOVWF  x3A
0AC00:  MOVLW  79
0AC02:  MOVWF  x3F
0AC04:  MOVLW  C0
0AC06:  MOVWF  x3E
0AC08:  MOVLW  7C
0AC0A:  MOVWF  x43
0AC0C:  MOVLW  A0
0AC0E:  MOVWF  x42
0AC10:  MOVLW  7E
0AC12:  MOVWF  x47
0AC14:  MOVLW  02
0AC16:  MOVWF  x46
0AC18:  MOVLW  7F
0AC1A:  MOVWF  x4B
0AC1C:  MOVLW  C0
0AC1E:  MOVWF  x4A
0AC20:  MOVLW  83
0AC22:  MOVWF  x4F
0AC24:  MOVLW  76
0AC26:  MOVWF  x4E
0AC28:  MOVLW  88
0AC2A:  MOVWF  x53
0AC2C:  MOVLW  D2
0AC2E:  MOVWF  x52
0AC30:  MOVLW  8C
0AC32:  MOVWF  x57
0AC34:  MOVLW  6A
0AC36:  MOVWF  x56
0AC38:  MOVLW  91
0AC3A:  MOVWF  x5B
0AC3C:  MOVLW  96
0AC3E:  MOVWF  x5A
0AC40:  MOVLW  91
0AC42:  MOVWF  x5F
0AC44:  MOVLW  9C
0AC46:  MOVWF  x5E
0AC48:  MOVLW  98
0AC4A:  MOVWF  x63
0AC4C:  MOVLW  10
0AC4E:  MOVWF  x62
0AC50:  MOVLW  9D
0AC52:  MOVWF  x67
0AC54:  MOVLW  74
0AC56:  MOVWF  x66
0AC58:  MOVLW  A4
0AC5A:  MOVWF  x6B
0AC5C:  MOVLW  96
0AC5E:  MOVWF  x6A
0AC60:  MOVLW  A5
0AC62:  MOVWF  x6F
0AC64:  MOVLW  E8
0AC66:  MOVWF  x6E
0AC68:  MOVLW  A8
0AC6A:  MOVWF  x73
0AC6C:  MOVLW  2A
0AC6E:  MOVWF  x72
0AC70:  BRA    AE38
0AC72:  DATA 02,00
0AC74:  DATA 1A,00
0AC76:  DATA 00,0C
0AC78:  DATA 00,20
0AC7A:  DATA 78,23
0AC7C:  DATA D7,0A
0AC7E:  DATA 7D,19
0AC80:  DATA 99,9A
0AC82:  DATA 7B,4C
0AC84:  DATA CC,CD
0AC86:  DATA 14,C0
0AC88:  DATA 00,0C
0AC8A:  DATA 80,78
0AC8C:  DATA 23,D7
0AC8E:  DATA 0A,7D
0AC90:  DATA 19,99
0AC92:  DATA 9A,7B
0AC94:  DATA 4C,CC
0AC96:  DATA CD,14
0AC98:  DATA C0,00
0AC9A:  DATA 01,80
0AC9C:  DATA 02,09
0AC9E:  DATA C0,00
0ACA0:  DATA 05,80
0ACA2:  DATA 7F,00
0ACA4:  DATA 00,00
0ACA6:  DATA 7F,0B
0ACA8:  DATA C0,00
0ACAA:  DATA 05,80
0ACAC:  DATA 7F,00
0ACAE:  DATA 00,00
0ACB0:  DATA 7F,07
0ACB2:  DATA C0,00
0ACB4:  DATA 01,80
0ACB6:  DATA 7F,17
0ACB8:  DATA C0,00
0ACBA:  DATA 01,80
0ACBC:  DATA 7F,17
0ACBE:  DATA C0,00
0ACC0:  DATA 04,80
0ACC2:  DATA 79,B7
0ACC4:  DATA F3,BD
0ACC6:  DATA 04,C0
0ACC8:  DATA 00,04
0ACCA:  DATA 80,7C
0ACCC:  DATA 59,DF
0ACCE:  DATA 4E,04
0ACD0:  DATA C0,00
0ACD2:  DATA 04,80
0ACD4:  DATA 78,0A
0ACD6:  DATA 28,88
0ACD8:  DATA 04,C0
0ACDA:  DATA 00,04
0ACDC:  DATA 80,78
0ACDE:  DATA 05,EA
0ACE0:  DATA 16,04
0ACE2:  DATA C0,00
0ACE4:  DATA 04,80
0ACE6:  DATA 78,1E
0ACE8:  DATA 33,D7
0ACEA:  DATA 04,C0
0ACEC:  DATA 00,04
0ACEE:  DATA 80,77
0ACF0:  DATA 68,7B
0ACF2:  DATA BB,04
0ACF4:  DATA C0,00
0ACF6:  DATA 04,80
0ACF8:  DATA 77,68
0ACFA:  DATA 0D,C6
0ACFC:  DATA 08,C0
0ACFE:  DATA 00,64
0AD00:  DATA 40,F3
0AD02:  DATA 00,05
0AD04:  DATA 01,81
0AD06:  DATA 00,65
0AD08:  DATA 01,6C
0AD0A:  DATA 01,09
0AD0C:  DATA C0,00
0AD0E:  DATA 04,80
0AD10:  DATA 73,01
0AD12:  DATA 7A,01
0AD14:  DATA 0D,C0
0AD16:  DATA 00,3C
0AD18:  DATA 44,DA
0AD1A:  DATA 00,02
0AD1C:  DATA 05,20
0AD1E:  DATA 74,05
0AD20:  DATA 02,05
0AD22:  DATA 24,77
0AD24:  DATA 05,02
0AD26:  DATA 05,28
0AD28:  DATA 7A,05
0AD2A:  DATA 02,05
0AD2C:  DATA 2C,81
0AD2E:  DATA 05,02
0AD30:  DATA 05,30
0AD32:  DATA 88,05
0AD34:  DATA 02,05
0AD36:  DATA 34,90
0AD38:  DATA 05,02
0AD3A:  DATA 05,38
0AD3C:  DATA 98,05
0AD3E:  DATA 02,05
0AD40:  DATA 3C,9D
0AD42:  DATA 05,02
0AD44:  DATA 05,40
0AD46:  DATA A2,05
0AD48:  DATA 02,05
0AD4A:  DATA 44,A6
0AD4C:  DATA 05,02
0AD4E:  DATA 05,48
0AD50:  DATA AA,05
0AD52:  DATA 02,05
0AD54:  DATA 4C,B1
0AD56:  DATA 05,02
0AD58:  DATA 05,50
0AD5A:  DATA B7,05
0AD5C:  DATA 02,05
0AD5E:  DATA 54,BD
0AD60:  DATA 05,02
0AD62:  DATA 05,58
0AD64:  DATA C3,05
0AD66:  DATA 02,05
0AD68:  DATA 5C,C9
0AD6A:  DATA 05,02
0AD6C:  DATA 05,60
0AD6E:  DATA CE,05
0AD70:  DATA 02,05
0AD72:  DATA 64,D7
0AD74:  DATA 05,02
0AD76:  DATA 05,68
0AD78:  DATA DF,05
0AD7A:  DATA 02,05
0AD7C:  DATA 6C,E6
0AD7E:  DATA 05,02
0AD80:  DATA 05,70
0AD82:  DATA ED,05
0AD84:  DATA 78,05
0AD86:  DATA 74,67
0AD88:  DATA 72,00
0AD8A:  DATA 67,73
0AD8C:  DATA 00,67
0AD8E:  DATA 43,68
0AD90:  DATA 4D,61
0AD92:  DATA 70,00
0AD94:  DATA 73,43
0AD96:  DATA 68,4D
0AD98:  DATA 61,70
0AD9A:  DATA 00,67
0AD9C:  DATA 43,68
0AD9E:  DATA 4D,6F
0ADA0:  DATA 64,65
0ADA2:  DATA 00,73
0ADA4:  DATA 43,68
0ADA6:  DATA 4D,6F
0ADA8:  DATA 64,65
0ADAA:  DATA 00,67
0ADAC:  DATA 50,49
0ADAE:  DATA 44,00
0ADB0:  DATA 73,50
0ADB2:  DATA 49,44
0ADB4:  DATA 00,67
0ADB6:  DATA 53,50
0ADB8:  DATA 00,73
0ADBA:  DATA 53,50
0ADBC:  DATA 00,67
0ADBE:  DATA 53,43
0ADC0:  DATA 61,6C
0ADC2:  DATA 73,00
0ADC4:  DATA 67,53
0ADC6:  DATA 43,61
0ADC8:  DATA 6C,00
0ADCA:  DATA 73,53
0ADCC:  DATA 43,61
0ADCE:  DATA 6C,00
0ADD0:  DATA 67,4D
0ADD2:  DATA 43,61
0ADD4:  DATA 6C,00
0ADD6:  DATA 73,4D
0ADD8:  DATA 43,61
0ADDA:  DATA 6C,00
0ADDC:  DATA 67,4D
0ADDE:  DATA 6F,6E
0ADE0:  DATA 00,67
0ADE2:  DATA 50,49
0ADE4:  DATA 44,64
0ADE6:  DATA 61,74
0ADE8:  DATA 61,00
0ADEA:  DATA 67,49
0ADEC:  DATA 50,64
0ADEE:  DATA 61,74
0ADF0:  DATA 61,00
0ADF2:  DATA 67,4D
0ADF4:  DATA 61,6E
0ADF6:  DATA 4F,50
0ADF8:  DATA 00,73
0ADFA:  DATA 4D,61
0ADFC:  DATA 6E,4F
0ADFE:  DATA 50,04
0AE00:  DATA C0,00
0AE02:  DATA 33,80
0AE04:  DATA F8,05
0AE06:  DATA 01,00
0AE08:  DATA 06,02
0AE0A:  DATA 10,06
0AE0C:  DATA 53,55
0AE0E:  DATA 43,43
0AE10:  DATA 45,53
0AE12:  DATA 53,00
0AE14:  DATA 49,4E
0AE16:  DATA 56,41
0AE18:  DATA 4C,49
0AE1A:  DATA 44,20
0AE1C:  DATA 43,4F
0AE1E:  DATA 4D,4D
0AE20:  DATA 41,4E
0AE22:  DATA 44,00
0AE24:  DATA 49,4E
0AE26:  DATA 56,41
0AE28:  DATA 4C,49
0AE2A:  DATA 44,20
0AE2C:  DATA 50,41
0AE2E:  DATA 52,41
0AE30:  DATA 4D,45
0AE32:  DATA 54,45
0AE34:  DATA 52,00
0AE36:  DATA 00,00
0AE38:  MOVLW  00
0AE3A:  MOVWF  FF8
0AE3C:  MOVLW  AC
0AE3E:  MOVWF  FF7
0AE40:  MOVLW  72
0AE42:  MOVWF  FF6
0AE44:  TBLRD*+
0AE46:  MOVF   FF5,W
0AE48:  MOVWF  00
0AE4A:  XORLW  00
0AE4C:  BZ    AE74
0AE4E:  TBLRD*+
0AE50:  MOVF   FF5,W
0AE52:  MOVWF  01
0AE54:  BTFSC  FE8.7
0AE56:  BRA    AE62
0AE58:  ANDLW  3F
0AE5A:  MOVWF  FEA
0AE5C:  TBLRD*+
0AE5E:  MOVFF  FF5,FE9
0AE62:  BTFSC  01.6
0AE64:  TBLRD*+
0AE66:  BTFSS  01.6
0AE68:  TBLRD*+
0AE6A:  MOVFF  FF5,FEE
0AE6E:  DCFSNZ 00,F
0AE70:  BRA    AE44
0AE72:  BRA    AE66
0AE74:  CLRF   FF8
.................... {
....................    IO_init();                    // set up IO 
0AE76:  MOVLB  0
0AE78:  GOTO   03A2
....................    params_init();                // load parameters
0AE7C:  GOTO   064A
....................    monitor_init();               // initialize internal ADC for voltage and current telemetry
0AE80:  GOTO   0F06
....................    control_init();               // initialize the output control DACs
0AE84:  GOTO   0FA0
....................    serial_init();                // setup the serial port
0AE88:  GOTO   1160
....................    event_timer_init();
0AE8C:  GOTO   1182
.................... //!   setup_wdt(WDT_512MS);
....................    enable_interrupts(GLOBAL);
0AE90:  MOVLW  C0
0AE92:  IORWF  FF2,F
....................    
....................    while(TRUE)
....................    {
.................... //!      restart_wdt();
....................       internal_monitor_task();   //Update monitored voltage and currents etc
0AE94:  GOTO   1560
....................       sensor_monitor_task();     //get magnetoresistive sensor data
0AE98:  GOTO   4D22
....................       control_task();            //output control
0AE9C:  GOTO   57EE
....................       serial_task();             //serial port 
0AEA0:  GOTO   58B6
....................       
....................       #ifdef DEBUG_1
....................       static int8 ch = 0;
....................       fprintf(SERIAL, "#D0,CNT,%u,%.0f,%.0f\n", ch+1, adcVals[ch].sinCounts, adcVals[ch].cosCounts);
0AEA4:  MOVLW  01
0AEA6:  MOVLB  6
0AEA8:  ADDWF  x22,W
0AEAA:  MOVWF  x28
0AEAC:  MOVF   x22,W
0AEAE:  MULLW  21
0AEB0:  MOVF   FF3,W
0AEB2:  CLRF   x2A
0AEB4:  MOVWF  x29
0AEB6:  MOVLW  08
0AEB8:  ADDWF  x29,W
0AEBA:  MOVWF  01
0AEBC:  MOVLW  00
0AEBE:  ADDWFC x2A,W
0AEC0:  MOVWF  03
0AEC2:  MOVF   01,W
0AEC4:  ADDLW  0F
0AEC6:  MOVWF  FE9
0AEC8:  MOVLW  01
0AECA:  ADDWFC 03,W
0AECC:  MOVWF  FEA
0AECE:  MOVFF  FEF,629
0AED2:  MOVFF  FEC,62A
0AED6:  MOVFF  FEC,62B
0AEDA:  MOVFF  FEC,62C
0AEDE:  MOVF   x22,W
0AEE0:  MULLW  21
0AEE2:  MOVF   FF3,W
0AEE4:  CLRF   x2E
0AEE6:  MOVWF  x2D
0AEE8:  MOVLW  0C
0AEEA:  ADDWF  x2D,W
0AEEC:  MOVWF  01
0AEEE:  MOVLW  00
0AEF0:  ADDWFC x2E,W
0AEF2:  MOVWF  03
0AEF4:  MOVF   01,W
0AEF6:  ADDLW  0F
0AEF8:  MOVWF  FE9
0AEFA:  MOVLW  01
0AEFC:  ADDWFC 03,W
0AEFE:  MOVWF  FEA
0AF00:  MOVFF  FEF,62D
0AF04:  MOVFF  FEC,62E
0AF08:  MOVFF  FEC,62F
0AF0C:  MOVFF  FEC,630
0AF10:  MOVLW  56
0AF12:  MOVWF  FF6
0AF14:  MOVLW  03
0AF16:  MOVWF  FF7
0AF18:  MOVLW  08
0AF1A:  MOVWF  x31
0AF1C:  MOVLB  0
0AF1E:  CALL   5DAE
0AF22:  MOVFF  628,631
0AF26:  MOVLW  1B
0AF28:  MOVLB  6
0AF2A:  MOVWF  x32
0AF2C:  MOVLB  0
0AF2E:  CALL   5E02
0AF32:  MOVLW  2C
0AF34:  MOVLB  6
0AF36:  MOVWF  x3E
0AF38:  MOVLB  0
0AF3A:  CALL   586A
0AF3E:  MOVLW  89
0AF40:  MOVWF  FE9
0AF42:  MOVFF  62C,634
0AF46:  MOVFF  62B,633
0AF4A:  MOVFF  62A,632
0AF4E:  MOVFF  629,631
0AF52:  MOVLB  6
0AF54:  CLRF   x35
0AF56:  MOVLB  0
0AF58:  CALL   5F54
0AF5C:  MOVLW  2C
0AF5E:  MOVLB  6
0AF60:  MOVWF  x3E
0AF62:  MOVLB  0
0AF64:  CALL   586A
0AF68:  MOVLW  89
0AF6A:  MOVWF  FE9
0AF6C:  MOVFF  630,634
0AF70:  MOVFF  62F,633
0AF74:  MOVFF  62E,632
0AF78:  MOVFF  62D,631
0AF7C:  MOVLB  6
0AF7E:  CLRF   x35
0AF80:  MOVLB  0
0AF82:  CALL   5F54
0AF86:  MOVLW  0A
0AF88:  MOVLB  6
0AF8A:  MOVWF  x3E
0AF8C:  MOVLB  0
0AF8E:  CALL   586A
....................       fprintf(SERIAL, "#D0,POS,%u,%3.3f\n", ch+1, adcVals[ch].pReal);
0AF92:  MOVLW  01
0AF94:  MOVLB  6
0AF96:  ADDWF  x22,W
0AF98:  MOVWF  x28
0AF9A:  MOVF   x22,W
0AF9C:  MULLW  21
0AF9E:  MOVF   FF3,W
0AFA0:  CLRF   x2A
0AFA2:  MOVWF  x29
0AFA4:  MOVLW  1D
0AFA6:  ADDWF  x29,W
0AFA8:  MOVWF  01
0AFAA:  MOVLW  00
0AFAC:  ADDWFC x2A,W
0AFAE:  MOVWF  03
0AFB0:  MOVF   01,W
0AFB2:  ADDLW  0F
0AFB4:  MOVWF  FE9
0AFB6:  MOVLW  01
0AFB8:  ADDWFC 03,W
0AFBA:  MOVWF  FEA
0AFBC:  MOVFF  FEF,629
0AFC0:  MOVFF  FEC,62A
0AFC4:  MOVFF  FEC,62B
0AFC8:  MOVFF  FEC,62C
0AFCC:  MOVLW  6C
0AFCE:  MOVWF  FF6
0AFD0:  MOVLW  03
0AFD2:  MOVWF  FF7
0AFD4:  MOVLW  08
0AFD6:  MOVWF  x31
0AFD8:  MOVLB  0
0AFDA:  CALL   5DAE
0AFDE:  MOVFF  628,631
0AFE2:  MOVLW  1B
0AFE4:  MOVLB  6
0AFE6:  MOVWF  x32
0AFE8:  MOVLB  0
0AFEA:  CALL   5E02
0AFEE:  MOVLW  2C
0AFF0:  MOVLB  6
0AFF2:  MOVWF  x3E
0AFF4:  MOVLB  0
0AFF6:  CALL   586A
0AFFA:  MOVLW  89
0AFFC:  MOVWF  FE9
0AFFE:  MOVFF  62C,634
0B002:  MOVFF  62B,633
0B006:  MOVFF  62A,632
0B00A:  MOVFF  629,631
0B00E:  MOVLW  03
0B010:  MOVLB  6
0B012:  MOVWF  x35
0B014:  MOVLB  0
0B016:  CALL   5F54
0B01A:  MOVLW  0A
0B01C:  MOVLB  6
0B01E:  MOVWF  x3E
0B020:  MOVLB  0
0B022:  CALL   586A
....................       if ( dacVals[ch].invV ) fprintf(SERIAL, "#D0,OUT,%u,-,%Lu\n", ch+1, dacVals[ch].val);
0B026:  MOVLB  6
0B028:  MOVF   x22,W
0B02A:  MULLW  03
0B02C:  MOVF   FF3,W
0B02E:  CLRF   x29
0B030:  MOVWF  x28
0B032:  MOVLW  02
0B034:  ADDWF  x28,W
0B036:  MOVWF  01
0B038:  MOVLW  00
0B03A:  ADDWFC x29,W
0B03C:  MOVWF  03
0B03E:  MOVF   01,W
0B040:  ADDLW  51
0B042:  MOVWF  FE9
0B044:  MOVLW  01
0B046:  ADDWFC 03,W
0B048:  MOVWF  FEA
0B04A:  BTFSS  FEF.0
0B04C:  BRA    B0CA
0B04E:  MOVLW  01
0B050:  ADDWF  x22,W
0B052:  MOVWF  x28
0B054:  MOVF   x22,W
0B056:  MULLW  03
0B058:  MOVF   FF3,W
0B05A:  CLRF   x2A
0B05C:  MOVWF  x29
0B05E:  MOVLW  51
0B060:  ADDWF  x29,W
0B062:  MOVWF  FE9
0B064:  MOVLW  01
0B066:  ADDWFC x2A,W
0B068:  MOVWF  FEA
0B06A:  MOVFF  FEC,62C
0B06E:  MOVF   FED,F
0B070:  MOVFF  FEF,62B
0B074:  MOVLW  7E
0B076:  MOVWF  FF6
0B078:  MOVLW  03
0B07A:  MOVWF  FF7
0B07C:  MOVLW  08
0B07E:  MOVWF  x31
0B080:  MOVLB  0
0B082:  CALL   5DAE
0B086:  MOVFF  628,631
0B08A:  MOVLW  1B
0B08C:  MOVLB  6
0B08E:  MOVWF  x32
0B090:  MOVLB  0
0B092:  CALL   5E02
0B096:  MOVLW  88
0B098:  MOVWF  FF6
0B09A:  MOVLW  03
0B09C:  MOVWF  FF7
0B09E:  MOVLW  03
0B0A0:  MOVLB  6
0B0A2:  MOVWF  x31
0B0A4:  MOVLB  0
0B0A6:  CALL   5DAE
0B0AA:  MOVLW  10
0B0AC:  MOVWF  FE9
0B0AE:  MOVFF  62C,62E
0B0B2:  MOVFF  62B,62D
0B0B6:  CALL   6104
0B0BA:  MOVLW  0A
0B0BC:  MOVLB  6
0B0BE:  MOVWF  x3E
0B0C0:  MOVLB  0
0B0C2:  CALL   586A
0B0C6:  BRA    B142
0B0C8:  MOVLB  6
....................       else                    fprintf(SERIAL, "#D0,OUT,%u,+,%Lu\n", ch+1, dacVals[ch].val);
0B0CA:  MOVLW  01
0B0CC:  ADDWF  x22,W
0B0CE:  MOVWF  x28
0B0D0:  MOVF   x22,W
0B0D2:  MULLW  03
0B0D4:  MOVF   FF3,W
0B0D6:  CLRF   x2A
0B0D8:  MOVWF  x29
0B0DA:  MOVLW  51
0B0DC:  ADDWF  x29,W
0B0DE:  MOVWF  FE9
0B0E0:  MOVLW  01
0B0E2:  ADDWFC x2A,W
0B0E4:  MOVWF  FEA
0B0E6:  MOVFF  FEC,62C
0B0EA:  MOVF   FED,F
0B0EC:  MOVFF  FEF,62B
0B0F0:  MOVLW  90
0B0F2:  MOVWF  FF6
0B0F4:  MOVLW  03
0B0F6:  MOVWF  FF7
0B0F8:  MOVLW  08
0B0FA:  MOVWF  x31
0B0FC:  MOVLB  0
0B0FE:  CALL   5DAE
0B102:  MOVFF  628,631
0B106:  MOVLW  1B
0B108:  MOVLB  6
0B10A:  MOVWF  x32
0B10C:  MOVLB  0
0B10E:  CALL   5E02
0B112:  MOVLW  9A
0B114:  MOVWF  FF6
0B116:  MOVLW  03
0B118:  MOVWF  FF7
0B11A:  MOVLW  03
0B11C:  MOVLB  6
0B11E:  MOVWF  x31
0B120:  MOVLB  0
0B122:  CALL   5DAE
0B126:  MOVLW  10
0B128:  MOVWF  FE9
0B12A:  MOVFF  62C,62E
0B12E:  MOVFF  62B,62D
0B132:  CALL   6104
0B136:  MOVLW  0A
0B138:  MOVLB  6
0B13A:  MOVWF  x3E
0B13C:  MOVLB  0
0B13E:  CALL   586A
....................       ch = !ch;
0B142:  MOVLB  6
0B144:  MOVF   x22,F
0B146:  BZ    B14C
0B148:  MOVLW  00
0B14A:  BRA    B14E
0B14C:  MOVLW  01
0B14E:  MOVWF  x22
....................       #endif
....................       
....................       command_handler_task();    //execute commands
0B150:  MOVLB  0
0B152:  BRA    A9DE
....................       
....................       delay_ms(250);
0B154:  MOVLW  FA
0B156:  MOVLB  6
0B158:  MOVWF  x30
0B15A:  MOVLB  0
0B15C:  CALL   0438
0B160:  BRA    AE94
....................    }
.................... }
0B162:  SLEEP 

Configuration Fuses:
   Word  1: FF8C   NOEXTOSC RSTOSC_HFINTRC_64MHZ NOCLKOUT CKS FCMEN
   Word  2: FFFD   MCLR PUT NOLPBOR BROWNOUT BORV19 ZCDDIS PPS1WAY STVREN NODEBUG NOXINST
   Word  3: FF9F   WDTSW NOWDT WDTWIN_SW WDTCLK_SW
   Word  4: DFFF   NOWRT NOWRTC NOWRTB NOWRTD SCANE NOLVP
   Word  5: FFFF   NOPROTECT NOCPD
   Word  6: FFFF   NOEBTR NOEBTRB
